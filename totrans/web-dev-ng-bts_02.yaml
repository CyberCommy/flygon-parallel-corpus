- en: ECMAScript and TypeScript Crash Course
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml), *Quick Start,* was
    a heterogeneous mix of topics that may have seemed a little loosey-goosey, but
    it was presented that way to lay down a swath of material and topics related to
    frontend web application development—with an obvious inroad to Angular, for starting
    your adventure in becoming an Angular guru. From this point onward, each chapter
    will remain as focused as possible and thus is dedicated to a specific area of
    coverage. As you progress through the chapters, you will generally find them to
    become more and more technical. This is a natural progression and not to be feared,
    because, as you may recall, one of my promises made to you in [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml), *Quick
    Start,* was to not get so deeply entwined in the technical details as to reach
    a point of diminishing returns. In other words, no deep technical babble that
    won''t add any value to our purpose. Instead, we''ll get as technical as we need
    to get—no more, and no less. Additionally, the material will be presented in an
    engaging way, where you have the greatest chance for retention with the least
    amount of effort.'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, please do not take this comment to mean that you don't have to work
    at it. As with anything else in life, the better you want to become at something,
    the more work it will take on your part. We all reap what we sow. That being said,
    this chapter and the next one will be a gradual ramp up to the technical deep
    dives that follow—kind of like the warm-up before we start working our Angular
    technical muscles throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between JavaScript and TypeScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A crash course on TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The (quick) roadmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a crash course on TypeScript and is meant to serve as a way
    to fast-track the transition from JavaScript to TypeScript for developers who are
    already comfortable with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: As was mentioned in [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml),
    Q*uick Start,* TypeScript is the language we'll be using throughout this book
    when working on Angular-specific things and so this chapter serves as your preparation
    for the programmatic part of getting up to speed for web development with Angular.
    You can think of [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml), *Bootstrap
    – Grid Layout and Components*, as being this chapter's cousin, in that its goal
    is similar but for the presentation side (that is, the layout of the web pages)
    as opposed to the programmatic side. Together, [Chapter 2](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml), *ECMAScript
    and TypeScript Crash Course*, and [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components**,* will round out the prerequisites for
    building client-side web applications in general—regardless of the client-side
    web application framework, but also specifically for Angular-based ones. From
    [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), *Flex-layout – Angular's
    Powerful Responsive Layout Engine*, onward, it's going to all pretty much be Angular-centric.
    In a nutshell, that's our roadmap for this chapter and the next. Let's start warming
    up our technical muscles!
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between JavaScript and TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript and TypeScript are inextricably tied together. Thus, while this
    chapter covers two technologies, ECMAScript and TypeScript, they are similar enough
    for this chapter to cover both simultaneously. How similar are they to each other?
    Well, for the most part, you can consider TypeScript to be a superset of JavaScript.
    The most useful description of their relationship is the following: TypeScript
    is a strictly typed language with lot of powerful features with optional typing,
    and with its transpiler, it becomes plain JavaScript. This is important and brings
    several advantages for developers; it''s compelling enough for Google''s Angular
    team to switch from JavaScript to TypeScript for developing Angular itself. We''ll
    cover what a transpiler is, as well as what the advantages of using TypeScript
    are, very shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: A series of fortunate events for JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into the technical parts and the code, it would be worthwhile
    to take a quick look at the evolution of JavaScript, and some of the drivers that
    led to the need for a language such as a TypeScript. Also, just as Angular's naming
    jungle caused some confusion in the development community, JavaScript has had
    an even more confusing versioning past since its inception over two decades ago,
    and so I'd like to try and clear up some of the confusion around JavaScript's version
    naming. More importantly, I'd like to cover what I like to refer to as the series
    of fortunate events for JavaScript. This will help set the pace for much of the
    material we'll be covering together in the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: I must confess, I love working with JavaScript. I have always enjoyed the language—not
    for the language itself, but because it allowed us to make the web come alive
    without the need for other plugins, such as Flash or Shockwave. However, in recent
    years, there are a few additional reasons for why I love working with the language,
    and the exact reasons I love JavaScript are precisely the series of fortunate events
    that I will cover shortly. Having said that, I have friends in the industry that
    are on the other end of the spectrum, who view JavaScript as a *toy language,* and
    prefer to remain shackled to languages such as Java and C#, avoiding JavaScript
    at all costs until they have to grudgingly write some code for the client side.
    These old-timers' usage of JavaScript typically extends no further than binding
    a click event to a function call (using the jQuery library) to submit form data to
    their Java or C# APIs. Sure, about a decade ago, JavaScript wasn't as powerful as
    Java or C# for a few reasons, such as it was a language that only ran on the client
    side (that is, on browsers), there were not as many libraries for it, and highly
    performant runtimes for it did not really exist. All this was about to change
    due the series of fortunate events—specifically, three of them. Let's review them
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Chromium project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first one was Google's Chromium Project. In September of 2008, Google released Chrome
    V8, which was a high-performant JavaScript engine. Google's Chrome V8 supercharged
    the way in which JavaScript code was able to be executed. It was such a successful
    project that it enabled other technologies to materialize, including the one that
    truly changed JavaScript's future immediately and forever: Node.js (referred to
    simply as Node).
  prefs: []
  type: TYPE_NORMAL
- en: Javascript frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second event in the series of fortunate events that have cemented JavaScript's
    reign as the most important programming language for web applications, and possibly for mobile
    and even desktop applications as well, has been the explosion of JavaScript frameworks.
    Ever since about 2010, the development world has gone absolutely ballistic in
    its insatiable urge to create JavaScript-based frameworks, not only for client-side web
    application development (such as Ember, Knockout, and React), but for server-side libraries
    (thanks again to Node), frameworks for creating native mobile applications (such
    as Ionic, React Native, and Native Script), and frameworks for developing desktop
    applications as well (such as Meteor and Electron). I haven't mentioned Angular
    in this paragraph, because we've already learned that Angular can be used for
    building cross-platform applications for all three domains—browser, desktop, and
    native mobile.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 2015
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third event in this series of fortunate events was the release of ECMAScript
    2015. ECMAScript is the official name for JavaScript when discussing its standard. Despite the
    increase in major version releases, the JavaScript language had largely gone on unchanged
    for many years. This was due to differences between influencing players (who are
    best left), causing splintered development and stalled progress in evolving the
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, this was a whirlwind tour of the current state of JavaScript
    and some of its ecosystem. JavaScript''s ecosystem is so vast that several books
    would need to be written to cover it. For instance, we''ve not even made mention
    of visualization JavaScript libraries. There are hundreds, if not thousands, of
    libraries available for JavaScript that you can use for your projects that we
    can''t even hope to begin to cover. However, there is a part of the JavaScript
    ecosystem that we will absolutely cover: unit testing. You probably know about
    the importance of unit testing, and have likely written unit tests for server-side
    code using frameworks such as JUnit, NUnit, RSpec, and others, depending on the
    programming language you used. However, unit testing is just as important on the
    client side, and most developers don''t do it, even though they may write unit
    test script for the server side. Well, in [Chapter 13](0e54e15a-bc1a-402b-adaa-28f877c68323.xhtml), *Unit
    Testing*, you will learn how to write unit tests for the client side and, specifically,
    how to write them to test your Angular application. The two frameworks we''ll
    cover together are Jasmine (a popular unit testing framework) and Karma (a test
    runner that has plugins for testing frameworks, such as Jasmine).'
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter's technical preamble out of the way, let's strap on our scuba
    gear and dive into TypeScript's ocean!
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript crash course
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript has a number of advantages over JavaScript for developers, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Purely object-oriented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional static typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to ECMAScript features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transpilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great tooling support with IntelliSense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can build Angular applications!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transpilation versus compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Developers can usually define what compilation is, within the context of programming.
    The definition would be something like this: compilation is the process of transforming
    source code, by putting it through another program known as a compiler, into machine-readable
    code. This resultant code is typically referred to as assembly code, which is
    a set of machine instructions native to the machine''s CPU, which the code is
    meant to be run on.'
  prefs: []
  type: TYPE_NORMAL
- en: Transpilation, on the other hand, is the process of transforming source code
    written in one language into equivalent code in another (or target) language.
    While this definition is good enough for discussion, for it to be fully accurate
    we have to also note that the source and target languages may, in fact, be different
    versions (or releases) of the same language. For our transpilation needs, we'll
    be using TypeScript's transpiler, tsc, which comes packaged with TypeScript. The
    reason we care about transpilation when building Angular applications is because
    we will be writing our code in TypeScript. However, web browsers only have JavaScript
    engines/interpreters, and so we need a way to transpile it into JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: let
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `let` and `const` keywords were introduced in ES6\. In order to discuss
    what these are and how they work, let''s review what the `var` keyword does. Prior
    to ES6, the way in which you initialized a variable was to use the `var` keyword.
    The two things to remember about `var` are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When you use `var` to define a variable outside of a function body, it becomes
    globally scoped. This is to say that all the other functions in your JavaScript
    file have access to it. While this may sometimes be convenient, it can also be
    dangerous because the value may inadvertently be changed by a function other than
    the one that you intended the variable to be used for. This is possible when more
    than one function refers to the same variable name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you use `var` to define a variable within a function, it becomes locally
    scoped. In contrast to globally scoped variables, locally scoped variables are
    only accessible within the function in which they were created. This is true regardless
    of block scope because JavaScript variables declared with the `var` keyword are
    scoped to the nearest parent function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can, of course, still use `var` to declare and define your variables, since
    the keyword has not been deprecated. It's just that you now have more explicit
    control over the behavior of your initialization code, and the readability of
    the code has improved with `let` and `const`, since the intentions are clear for
    when you're looking at JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: The `let` keyword creates block scope local variables and gets its name from
    other languages that have a similar construct, such as Lisp, Clojure, Scala, and
    F#. In these languages, variables declared using `let` can be assigned, but not
    changed. However, in ES6, variables assigned using `let` can be changed; even
    so, regardless of whether they are changed or not, the variable is a local block
    scoped variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find this is a little confusing, you''re not alone. Getting a firm understanding
    of the nuances in variable scoping is not something that you can learn by just
    reading. Programming is like learning math (or like learning most things, for
    that matter): the more you do it, the better you get. That being said, one way
    to boil it all down in your mind is to look at this one main difference between
    `var` and `let`: since you can have more than one block within a function, and
    even nested blocks (or sub-blocks), variables defined with the `let` keyword are
    accessible only within the block they are defined, as well as from that block''s
    nested blocks. In contrast, the scope of variables defined with `var` is the entire
    closing function. Remember that one main difference, and you''re golden.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some code to understand the impact of the `let` keyword, and
    then we can move on to discussing the `const` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Const
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `const` keyword creates a constant. You'll be glad to know that since you've
    gone through the pain of understanding what the `let` keyword does, understanding
    what the `const` keyword does will be dead simple. Ready? Here it is … `const`
    and `let` are identical in the way in which their scoping works. The only difference
    between `let` and `const` is that you cannot redeclare a constant, and its value
    can't be changed. That's it. Let's move on to discussing some data types.
  prefs: []
  type: TYPE_NORMAL
- en: Data typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every programming language has data types. They only vary in the number of types
    available, and the values (and range of values, for number types) that the typed
    variable can hold. I won't wade into the philosophical debate between strongly
    typed versus statically typed versus loosely typed languages (usually referred
    to as static versus dynamic typing) in this book—but since this chapter is devoted
    to JavaScript and TypeScript, I do need to say a couple of quick things about
    their typing.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a loosely typed language—which is to say it is a dynamic language
    as opposed to it being a static language. What this means is that variables in
    JavaScript are not bound to any particular type, but rather their values are associated
    with a type. Variables can be assigned, and re-assigned, to values of all available
    types. While convenient, hard-to-find bugs can occur, since there is no compiler
    that checks for adherence of value to a typed reference—and this is because when
    you declare a variable using `var`, `let`, or `const`, you do not specify an associated
    type.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, TypeScript is optionally statically typed. The important word here
    is *optionally*. TypeScript is a statically typed language, yes, but it does not
    force you to explicitly annotate your variable with the intended type. This is
    because TypeScript has what is called type inference, which is to say that the
    TypeScript runtime will infer the variables data type at runtime. This is the
    default behavior of TypeScript. Now, this is where the optional part of it comes…
    if you want to strictly type the variable, thereby binding the datatype to the
    variable instead of it resting with the variable's value, you have to explicitly
    add a type annotation to the variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the preceding lines are valid TypeScript syntax, but here are their differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line, the statically typed variable, which is annotated with the `num` keyword,
    is checked by the TypeScript transpiler, and any issues will be reported by it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line, where the variable declaration is made in the JavaScript fashion
    (that is, no annotations for static typing), goes unchecked, and any issues will
    only be found at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES6 has seven data types, six of which are known as primitive data types, and
    one of which is a reference data type (which is just called `Object`). JavaScript
    also has several built-in data types in its standard library, but since this is
    not comprehensive coverage of JavaScript, we''ll only cover a few of them here:
    the ones that you''re likely to use in your Angular development.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of the primitive data types provided:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the built-in data types provided:'
  prefs: []
  type: TYPE_NORMAL
- en: Dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Only having primitive data types and built-in complex data types is not enough
    when writing expressive software that attempts to model the real world or fictitious
    worlds (in gaming). The solution is to have programming languages with a construct
    for creating custom objects. Fortunately, JavaScript, and thus TypeScript, is
    a programming language that allows for the creation of custom objects. An object
    in JavaScript is a collection of mapped keys and values, where a key can be either
    a string or a symbol. This is similar to the case for many other programming languages,
    such as for Python''s dictionary, and Ruby''s hash. Not to get too technical just
    for the sake of being technical (which is a pet peeve of mine, and maybe is one
    for you as well), but JavaScript is not a *classical* object-oriented language.
    Rather, JavaScript uses prototypal inheritance to create other objects instead
    of creating an instance of an object from a class definition. In other words,
    JavaScript doesn''t have the notion of classes. JavaScript has prototypes. Objects
    in JavaScript inherit directly from other objects. In fact, when you create an
    empty object in JavaScript using curly braces, it''s really syntactic sugar for
    using the `create` method of the built-in object. There are several ways available
    to you for creating an empty object in JavaScript. We won''t cover them all here,
    but we''ll cover two of the ways that have been available in JavaScript for many
    years, and are made available to us in ES6:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Object` constructor: `var myObject = new Object();`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the curly brace syntax: `var myObject = {};`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ES6 class syntax (we'll get to the syntax in the following *Classes* section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two methods create an empty object. If you want to create an empty
    object in JavaScript with minimal fuss, the second approach is obviously the easiest.
    However, the third approach, ES6 class syntax, is what we'll be using in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON, which is an acronym for JavaScript Object Notation, is not a data type
    per se, but rather structured data. JSON is used as a lightweight data interchange
    format and is used by many programming languages. Not only will we cover this
    more a little later, but we will make extensive use of this format to pass data
    back and forth between our Angular application and the backend web services that
    we''ll also be building for it. Just as programming languages have data types, data
    interchange formats often do as well. Here are the data types allowed to be represented
    in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may have noticed that there is a large overlap between JavaScript and JSON
    data types. This is not by accident because JSON is JavaScript Object Notation,
    and thus was modeled after JavaScript''s data types. Here''s an example of JSON
    data that contains the names and ages of three people (each of which is a JavaScript
    object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous JSON example, I have `people` as the key, and its value is
    an array of three `people` objects. There''s no hard and fast rule that says you
    have to name structures nested structures, but it does become more legible. In
    this simple example, you could have instead omitted the key with no loss of data,
    as this next JSON sample shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, the first example, where we have the `people` key, is not only easier
    to read but is also easier to work with in the code. When we write our RESTful
    web service APIs for our application in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services,* we will take the first approach, providing keys for our
    collections of data.
  prefs: []
  type: TYPE_NORMAL
- en: Here's an interesting note for you about data interchange formats. While there
    are a few formats to choose from, such as XML and SOAP (Simple Object Access Protocol),
    when developing web services, JSON is the most popular one of all, and it was
    inspired by JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Where would we be without JavaScript? I shudder to think about it.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript runtime environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rest of this chapter has many code snippets, so if you''d like to experiment
    with the material as you work your way through the chapter, it''s a good idea
    to fire up your JavaScript runtime environment. Unless you''re using a JavaScript
    IDE, such as WebStorm by JetBrains, you have a few options available to you for
    testing out JavaScript code. Here are three of the many choices:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use an online a JavaScript console, such as [https://es6console.com/](https://es6console.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use Node right in your Terminal (Appendix A shows you how to install
    Node).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the console within your developer tools in your browser. For instance,
    I primarily develop using Chrome, and Google has excellent tools for developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any of these choices will work just fine. I prefer using the Node Terminal for
    quick little things and it's what I used to test the code I wrote for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays are part of a collection of objects, and are referred to as indexed
    collections. If you''ve written any amount of JavaScript, you have used arrays.
    Array objects can hold any valid JavaScript data types and can grow and shrink
    by calling their built-in methods, such as `push` and `splice`. You can search
    for the existence of a value in the array with the `indexOf` method, get an array''s
    length by using its `length` property, and so on. The JavaScript syntax for creating
    an empty array is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use the array''s built-in `push` method to add an item to the
    array, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can create the array in place in one fell swoop, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `indexOf` method is quite handy, and we''re sure to make use of it later.
    Let''s quickly cover this one before moving on to `TypedArrays`. When you need
    to find where in the array a specific item is, or whether it exists in an array
    at all, you can use the `indexOf` method. Let''s assume we''d like to see where
    in array the Mercedes is. We can search for it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Given our `myDreamCars` array, the `indexOf` function would return 1\. This
    is because arrays in JavaScript start their index at 0, and the Mercedes was in
    the second slot of our array. What if what we''re looking for is not in the array?
    Let''s see what happens when we look for a Corvette:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When the preceding line is executed, the `indexOf` function returns a -1, which
    indicates that the item we were searching for was not found.
  prefs: []
  type: TYPE_NORMAL
- en: TypedArray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TypedArray` is used in ES6 and even though it has a few of the same methods
    as normal JavaScript array objects, it is quite different from what you''d probably
    expect. In fact, `TypedArray` is not an array at all. If you try passing in `TypedArray`
    to `Array.isArray()`, you will see that the value returned is `false`. OK, so
    what are they then?`TypedArray` gives us a view of an underlying binary data buffer
    and enables us to access and manipulate data. We won''t be covering `TypedArray` in
    this book because we won''t be using them, and it is an advanced data type and
    mechanism, but the reason I mentioned it is so that you are aware that it exists.
    Before we move on, let me at least cover the motivation for its creation and a
    use case for when you may wish to look into possibly using it. `TypedArray` came
    into being with ES6 because web applications are getting more advanced all the
    time, and the client machine now has so much power available to it that writing
    a client application that processes and manipulates audio and video is a good
    idea. In order to do this, you need a mechanism to enable your JavaScript code
    to be able to read and write data to these raw binary streams.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two examples of something that you may want to build where `TypedArray` would
    be put to immediate good use are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Video editing (where you wish to remove segments of unwanted footage)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sampling audio (where you change the frequency of a sound byte, maybe creating
    11 versions of the original sample to create a chromatic scale, so as to be able
    to play melodies from the original single sample)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, this is an example of how far JavaScript has come.
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Maps is a data structure that came to JavaScript in ES6\. Maps are used for
    mapping values to values. Moreover, they allow the use of arbitrary values as
    keys, meaning that you can use integers as keys, or strings, or even objects;
    however, the use of symbols as keys is not allowed. There are also a few handy
    methods for performing operations on maps, and you can also iterate over a map.
    Let''s take a look at some code for creating a map and explore some of its common
    built-in functions. Let''s first create our map. We''ll create one for mapping
    learning curves to programming languages, using the `new` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s add a few entries to it using the Map''s set function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'While you can add key-value pairs in `Map` one line at a time, as we just did,
    the `set` method is chainable and so we can use this syntax to accomplish the
    exact same thing, which saves some typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, as a third way to declare and initialize our language learning
    curve `Map`, we can pass an array of two element arrays to the Map''s constructor.
    Let''s assume we had our array of two-element arrays set up like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then pass that into the constructor like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'These three methods of creating our `Map` all produce the exact same results.
    Cool, let''s move on and quickly look at some of the common operations that can
    be done on `Map`. We can get the Map''s size using its `size` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can retrieve a key''s value using the `get` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check for the existence of a key in `Map` using its `has` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can delete a key and its value using the `delete` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can clear out a set, removing all its items in one fell swoop, with the `clear`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re following along in your JavaScript environment, don''t try this
    just yet because we need some data to iterate through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can iterate over `Map` very easily in JavaScript using the `for` construct,
    but we need to know what we would like to iterate over. Do we want to get our
    map''s keys? or its values? Or maybe we''d like to get both. Here is how we iterate
    over our map''s keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how we iterate over our map''s values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how we iterate over both our Map''s keys and its values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, you'll probably want to have access to your map's keys and
    values and so you should use the map's `entries` function.
  prefs: []
  type: TYPE_NORMAL
- en: A bit later in this chapter, we'll take a look at a construct that ES6 gave
    us, called destructuring, which gives us the ability to access keys and values
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: WeakMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WeakMap` is a funny creature and is not inherited from `Map`, although they
    both are collections of key-value pairs and share some of the same functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important difference between `Map` and `WeakMap` is the datatypes that
    can be used as their keys. With a, we've seen that you can use a variety of data
    types as its keys, including objects. However, `WeakMap` can only have objects
    as its keys. This is by design and makes `WeakMap` particularly useful if you
    only care to have access to the value of the key if the key has not yet been garbage
    collected. Let that sink in for a moment. I know it sounds like a strange use
    case, but if you consider that `WeakMap` can help mitigate memory leaks in your
    JavaScript programs, it may be enough for thinking of how you may be able to make
    use of `WeakMap` in your code.
  prefs: []
  type: TYPE_NORMAL
- en: The *Weak* part of the data structure's name comes from the fact that `WeakMap`
    holds the references to its key objects weakly. This is to say that they are candidates
    for being garbage collected. This fact leads us to this next point. Since our
    keys may be garbage collected at any point without our involvement, it would not
    make sense to make them enumerable, and so they are not, and this means that we
    cannot iterate over the collection.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to iterate over the list of keys or values in your collection, you
    should use the `Map`. Conversely, if you don't need to iterate over `Map` and
    just intend to use it as a lookup table, you may want to consider using `WeakMap`.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about `Set` in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Set` is a collection of unique values and can be iterated over in the order
    in which its elements were added to it. `Set` can contain homogeneous data but
    each piece of data (that is, element) needs to be unique. If you try to add an
    existing element to a set, there will be no effect on the set.'
  prefs: []
  type: TYPE_NORMAL
- en: Sets have many of the same functionality that maps have. Let's create a `Set`
    object and zip through a few of its commonly used functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a set, we call its constructor using the `new` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a few elements (that is, celestial objects) to our `Set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, the number `7` isn''t exactly a celestial object, but I wanted to show
    you that you can add different types of elements to the same `Set`. The same thing
    with our array of constellations: we can add arrays, and any type of object, to
    our `Set`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the size of our `Set` using the `size` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t do this now, but you can clear out `Set` using its `clear` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can delete an element from our `Set` by passing its value into set''s `delete`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can iterate over `Set` using the `for` construct, as we used for our `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''d like to perform an operation on every element in your `Set`, you
    can use set''s `forEach` function, which takes a callback as its parameter. For
    instance, if you had a set of integers in your `Set` and wanted to square all
    of them, this is how you can accomplish that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does not change the elements within our `Set` while it prints
    the squared values to our console. We can''t easily change our elements in place,
    but we can create a new `Set` and store our squared elements in there, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check for the existence of an element in our `Set` using the `has` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you recall from when we covered maps, the `Map` object had the following
    three functions: keys, values, and entries. Sets have these same three functions
    as well, but their resulting value is quite different. When you call these built-in
    functions on your `Set`, you will get a `SetIterator` object back.'
  prefs: []
  type: TYPE_NORMAL
- en: We won't be using `SetIterator` in this book, but as with when I gave you a
    use case for `TypedArray`, I'd like to give you a use case for `SetIterator`.
    A `Map` object and a `Set` object are different data structures, and you iterate
    through each of these structures in different ways. If you use iterators, you
    can build a function that can iterate through these two types of data structures
    in the same way. In other words, you can pass the objects into your function that
    iterates over the collections without worrying about their type.
  prefs: []
  type: TYPE_NORMAL
- en: WeakSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WeakSet` is a collect of weakly held objects, where each one must be unique;
    duplicate objects are not allowed to be added. Recall from our discussion on `WeakMap`
    that its keys may be garbage collected from under our feet since their keys can
    only be objects. Thus, as it was with `WeakMap`, so it is with `WeakSet` with
    respect to iteration: we can''t iterate over the collection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`WeakSet` has a very small amount of built-in functions, namely add, delete,
    and has. `WeakSet` also has a `length` property, similar to arrays, as opposed
    to the `size` property for `Map`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look at the syntax for creating a `WeakSet` object, and its
    property and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an empty `WeakSet` object using its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create three empty objects to add to our `WeakSet`, and then add them
    to it using the `WeakSet` object''s `add` function, and then get the number of
    objects it contains using its `length` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You may be asking, *Wait a minute. You said that the objects must all be unique,
    and any duplicates will not be inserted into the WeakSet* object. *All the objects
    are empty; are they not the same?* True, duplicate objects will be rejected when
    the insertion operation is tried. However, while our three objects all have the
    same value (that is, they are all empty), they are in fact three separate and
    distinct objects.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, as with most other object-oriented languages, it is the object
    reference (that is, the underlying memory address) and not its contents that determine
    whether the object is the same as another object or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can compare two object variables referencing the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`objA` and `objB` each reference empty objects, but these are two different
    objects; thus, `blnSameObject` will be set to `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we did the following since the `objB` and `objC` variables point to the
    same object in memory, the line that tries to add `objC` to `myWeakSet` will have
    no effect on `myWeakSet` because the underlying object was already contained in
    the `WeakSet` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several pages ago, we covered three different ways to create an object in JavaScript.
    I had also mentioned that we were going to cover how to create an object using
    the ES6 class syntax later on. Additionally, I had mentioned that JavaScript doesn't
    have the notion of classes, yet we're covering classes in this section. Let's
    clear all this up and take a look at how to create classes in JavaScript, and
    how to create objects from these classes.
  prefs: []
  type: TYPE_NORMAL
- en: For JavaScript releases prior to ES6, the notion of classes did not exist. Rather,
    whenever you created an object, under the hood the JavaScript runtime would inherit
    directly from other objects, and not from classes (remember that JavaScript is
    not a classical object-oriented language; it uses prototypal inheritance). This
    doesn't make JavaScript *bad*, but it does make it different. In order to bring
    the same style and semantics from classical object orientation, ES6 brought us
    the notion of classes. A class is a blueprint for objects, and when we create
    an object from this blueprint, or template, it is referred to as instantiation.
    We use a class to instantiate (to bring into existence) one or more objects from
    it. Let's get into the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `Car` class and give it a constructor, three properties, and
    three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: I've purposely used the term *methods* here, whereas previously I had always
    referred to them as *functions*. Since we're now discussing classes and objects,
    in the classical object-orientation parlance, *method *is of better choice a word
    than *function*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two relationships that you need to remember for any object-oriented language,
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects are instances of their classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects encapsulate data and methods that manipulate that data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data represents the state of the object at any moment in time, and the methods
    represent the behaviors the object has. That's pretty much it.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, back to our class example. Our `Car` class has a constructor that takes
    two parameters: the car''s make and model. It also has three instance variables:
    `make`, `model`, and `speed`. Additionally, it has two methods, `speedUp` and
    `slowDown`. Lastly, the `speed` instance variable is actually a property; this
    is because it has an associated getter and setter.'
  prefs: []
  type: TYPE_NORMAL
- en: Something to pay attention to is that the setter and getter in our class have
    an underscore in front of the property name, while the associated instance variable
    does not. This is important because, without the underscores, the JavaScript runtime
    would throw an exception (that is, `RangeError: Maximum call stack size exceeded`) when
    instantiating your `Car` object.
  prefs: []
  type: TYPE_NORMAL
- en: Great! So, how do we create our instance of it (that is, a `Car` object), and
    how can we call its methods and read its property?Here's the code to help answer
    these questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create our `Car` object just like any other object, by calling its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s read our car''s current speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Oh, man! `Zero` miles per hour? That''s unacceptable. Let''s step on the gas
    pedal! See this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'How fast are we going? We''d better check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Crap! We just entered a school zone and have to drop down to a maximum speed
    of 20 mph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check our speed again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Whew! OK, we're good at this speed, for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wrap up this section, here are a couple of things to keep in mind about
    classes in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Java or Python, for instance, classes in JavaScript can only have one
    constructor. Overloading constructors is not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have a super call in your class (used in calling the constructor of
    a class higher up in the hierarchy), but it must be called prior to using the
    `this` reference, as in when we assign the `make` and `model` parameters to their
    respective instance variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been looking at several new additions to JavaScript that have
    been made available to us. This section on interfaces, for our purposes, is a
    TypeScript-specific thing, since JavaScript does not have the notion of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces are like a contract for a class and provide a set of rules that
    the class must follow. Let''s switch gears from building a `Car` class to building
    an `Animal` class, and, while we''re at it, let''s have our class implement an
    interface we''ll call `Species`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Our `Animal` class is empty. It doesn't even have a constructor or any instance
    variables, and that is not a problem for us, since it still serves our purposes
    to demonstrate how to use interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the `Species` interface for a moment. You''ll notice a couple
    of things:'
  prefs: []
  type: TYPE_NORMAL
- en: It has two public properties. TypeScript has access modifiers, just like Java
    and C# have, and we'll get to those when we make use of them in later chapters.
    For now, all you need to know is that the lack of an access modifier on the properties
    makes the properties public. This is important because since an interface describes
    the public interface of the class that implements it, its properties must be public.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second thing that you'll notice is that we're typing the properties. We're
    declaring the `name` property as being of type string, and the `isExtinct` property
    as being of type boolean. This is one major advantage of TypeScript, as we've
    previously learned, and is where TypeScript got its name (that is, a typed JavaScript).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll see access modifiers in action later in the book. There are three of
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public:** This is the default modifier and it means that the property or
    function is visible to all other code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private:** The visibility to a class''s properties and functions marked as
    private are only available to member functions of the class that they''re declared
    in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected**: This is the same as private, but the class members are also
    visible to any classes that are inherited from the class that they''re declared
    in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way in which we marry the class to the interface is by using the `implements`
    keyword in the class definition, as we have done so in this example. Once we do
    that, the class must adhere to the interface contract.
  prefs: []
  type: TYPE_NORMAL
- en: So now what? Well, if the `Animal` class doesn't implement the two properties
    that the `Species` interface says it must, then TypeScript will throw an error
    during transpilation.
  prefs: []
  type: TYPE_NORMAL
- en: We can also have an interface describe an optional contract, and we can do this
    by appending a question mark to the end of the property or function. We don't
    have a function listed in our interface, but we can absolutely have functions
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our interface was an optional contract, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned that class members marked with the protected access modifier are
    also visible to any classes that are inherited from the class that they're declared
    in, and so we'd better discuss inheritance real quick.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance does not mean that the classes that we create will become independently
    wealthy; that's a whole different kind of inheritance. The kind of inheritance
    that we're talking about is a little less exciting, but far more useful for our
    JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class can inherit from another class. In order for a class to do that, we
    use the `extends` keyword in the class definition. Let''s switch gears once more,
    this time going from `Animal` to `Employee` (though I''ve seen some bathrooms
    and kitchens at a couple of my client locations, and I can tell you that some
    employees can also be animals). Let''s get to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an `Employee` object, and have the employee announce himself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `Manager` object and have the manager announce himself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what''s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: We created an `Employee` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a `Manager` class that inherits from `Employee`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Manager` class does not have any properties or functions, other than it's
    constructor. However, it inherits the properties (`name` and `title`), and the
    method (`annouceThyself`), from the `Employee` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor in the `Manager` class calls the constructor in the `Employee`
    class, passing in the manager's name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The manager's constructor reassigns the value for the `title` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This was fairly straightforward but there are two takeaways here for you to
    remember:'
  prefs: []
  type: TYPE_NORMAL
- en: The inheriting class gets all the class members from the class that it inherits
    from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One constructor can call it's parent's constructor, and this can continue up
    the chain, if the parent had a parent, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Destructuring is a super cool and super useful construct that we will use many
    times throughout this book, and it'll be something that you won't be able to live
    without in your Angular projects well after you finish this book. In short, destructuring
    is a JavaScript expression that enables us to easily extract data from objects
    and collections.
  prefs: []
  type: TYPE_NORMAL
- en: Back when we were looking at `Map` objects, I had mentioned that we would look
    at an example of destructuring. Here it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume we have the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to extract `firstName`, `lastName`, and `publisher`, we know exactly
    how to do that the old-fashioned way (that is, before ES6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, destructuring (despite it''s odd-looking syntax) saves us a lot of keystrokes
    by giving us the exact same result (new variables with the extracted data) with
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily see that it did its job by writing a variable out to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty handy, and we're going to make good use of it when we write our
    application together.
  prefs: []
  type: TYPE_NORMAL
- en: Template strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template strings are strings that are enclosed within backticks (that is, `
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: the backtick character is typically found on the same key on your keyboard
    as the tilde (that is ~), and is immediately to the left of the number 1 key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript always gave us the ability to create strings using double quotes
    as well as by using single quotes, so what was the motivation for the third type
    of string creation character? Well, as it turns out, given the proliferation of
    frontend frameworks, there was a common need to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: String interpolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiline strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tagged templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for-of loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript brought us the `forEach` construct for looping through collections.
    It is a great built-in method to use, but you can't break out of this loop. We
    also have the `for-in` loop, which is great for objects with keys that are strings,
    but it has some drawbacks when iterating through arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the new `for-of` loop. It works well for objects, arrays, and maps, and
    you can break out of it. Here is the syntax, which is identical to that for the
    `for-in` loop, other than changing `in` to `of`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators are also a TypeScript thing. Decorators in TypeScript decorate functions
    and classes, just as they do in some other languages, such as Python and Java.
  prefs: []
  type: TYPE_NORMAL
- en: We won't spend too much time here because we won't be writing our own decorators
    for the application we're going to build together, but since Angular makes use
    of decorators quite a bit, I wanted to at least give you an idea of what they
    are used for. We'll also look at a quick example of how to create one and how
    to use it, but we'll fly through it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorators are a way to add functionality to a function or a class (typically
    a class), by annotating the class with the decorator. The decorator is just a
    function, although it has some strange looking syntax at first glance. Let''s
    look at some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is intermediate to advanced level TypeScript, and an entire chapter can
    be written on decorators. We don't have the luxury to cover them in detail here,
    but the takeaway is that they are simply functions that add functionality to functions
    or classes, and to do that you only need to annotate the function or class with
    the name of the decorator (that is, `@NameOfDecorator`).
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will cover promises in greater detail when we make use of them in [Chapter
    12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating Backend Data Services*,
    and so I'll defer the code until that time. The reason is thatshowing a really
    good real-world example of a promise, so that it's not contrived, takes quite
    a bit of code, since there needs to be asynchronous code that is called. So, I
    promise to have real-world promises later on in the book. However, we can at least
    look at a definition so that you know what they are.
  prefs: []
  type: TYPE_NORMAL
- en: When you call a function that may take a long time to return a result or to
    complete its task, and you don't want to delay the execution of your program,
    you can call that function asynchronously. This means that your code will continue
    on to the next line after it calls the function on the previous line asynchronously.
    If you don't call it asynchronously, your program's execution will stop and wait
    for the function you last called to return from what it was doing, such as reading
    a bunch of records from a database.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few different ways to call a function asynchronously. The most common
    way to call a function asynchronously is to use callbacks. A callback is a function
    that you pass to the function that you call asynchronously so it can then call
    that function when it has completed its work. That's how callbacks got their name;
    the function you called calls you back when it's done.
  prefs: []
  type: TYPE_NORMAL
- en: Promises are another mechanism we can use to program asynchronously. Although
    Promises made things a little more manageable, writing good asynchronous code
    in JavaScript is often still notoriously difficult. Because of this fact, people
    started writing JavaScript libraries to try and make asynchronous code easier
    to write. There are several out there. One library that saved my sanity is called
    Async.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this being said, I still have not given you a definition of Promises, so
    here it is: a Promise is a proxy for a value that is not yet known; it''s like
    a placeholder for the value that will eventually come back from a function that
    was called asynchronously. This construct allows asynchronous functions to immediately
    return a value as if it was a synchronous method. The initial value that is returned
    is a Promise, and the Promise will eventually be replaced by the value that comes
    back from the called function once it has completed its work.'
  prefs: []
  type: TYPE_NORMAL
- en: I know this may be a lot to get your head around, but when we write our code
    in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating Backend
    Data Services*, you will understand Promises. That's a promise, pun intended.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to ES6, JavaScript did not have the notion of modules. Modules are simple
    code files that can be loaded into the other code so that the functions within
    the module that is being loaded are made available to the code that is importing
    the module. Modules can load modules. Modules lead to modular code, and that is
    a good thing. Rather than write a monolithic bunch of code in one file, you can
    split it up into logical units and have that code live in more than one file.
    This leads to code reuse, namespacing, and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: While JavaScript didn't have modules, we were still able to accomplish the same
    thing, to a degree. We can load script files with script tags before calling their
    functions in our web pages. However, what about JavaScript running on the server
    side, or another environment outside of web pages? Without modules, writing non-monolithic
    applications becomes difficult.
  prefs: []
  type: TYPE_NORMAL
- en: let's move on to the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume we have a file named `alphafunctions.js` that has the following code
    in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `export` keyword is used to mark which functions can be exported and thus
    imported into other modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now assume we have this file, `main.js`, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Default exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that we always want to import our `alpha1` function into other
    modules, or at least more often than not. We can add the keyword's export default
    before the `keyword` function. So, when we import it, we no longer need the curly
    braces around the function name. Let's see this in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'See `alphafunctions.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'See `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: While this isn't an earth-shattering difference, the terms default exports do
    come up in conversation and in code snippets on blog posts, and so on, so I wanted
    to make sure we at least took a quick look so that you understood why the curly
    braces were sometimes there, and other times not. When you use JavaScript libraries,
    you'll see this in the documentation and code examples as well. So, now you know.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered some of the history around JavaScript, and
    specifically the series of fortunate events around JavaScript's ecosystem that
    have cemented the language as the most important programming language in recent
    history. We can now not only write client-side code for execution in the browser,
    but we can write JavaScript code that runs on the server. As if this wasn't a
    compelling enough reason to use more JavaScript than what you may have used in
    the past, you can also use JavaScript for native mobile development, and for creating
    desktop applications as well. It's quite an exciting story!
  prefs: []
  type: TYPE_NORMAL
- en: We then took a low fly-by look at the additions to JavaScript that were added
    with the release of ES6\. These additions were quite substantial, especially since
    JavaScript had remained largely unchanged for over a decade, and have really strengthened
    the language as a result. We also enumerated some of the benefits that TypeScript
    brings to the table. Remember that you can view TypeScript as being a superset
    of JavaScript, and you can define it as ES6 plus optional typing.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft's contribution of TypeScript to JavaScript developers was one of the
    most important things the company has contributed to the open source world in
    a long time. Angular itself was written in TypeScript, due to the advantages TypeScript
    has over pure JavaScript, and so when building Angular applications, it's best
    to use TypeScript to write them. We've remembered that JavaScript is the only
    language that can be executed in the browser, but fortunately, TypeScript ships
    with a transpiler to turn our TypeScript code into pure JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the roadmap, chapter 3 *Bootstrap – Responsive Grid Layout and
    Components*,  we have a similar goal. In this chapter we will do a crash course
    on SASS, which is what we'll be using to style our Angular components instead
    of using CSS. We'll also cover enough of Bootstrap to get you comfortable with
    using the venerable CSS framework to lay out our web pages for ListingCarousel,
    the web application we'll be building together. You'll gain enough knowledge to
    immediately apply these skills to virtually any web application project you may
    currently have or soon be starting on in the future.
  prefs: []
  type: TYPE_NORMAL
