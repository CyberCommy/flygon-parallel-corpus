- en: Chapter 8. ECFS – Extended Core File Snapshot Technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Extended Core File Snapshot** (**ECFS**) technology is a piece of software
    that plugs into the Linux core handler and creates specialized process memory
    snapshots specifically designed with process memory forensics in mind. Most people
    have no idea how to parse a process image, let alone how to examine one for anomalies.
    Even for experts, it can be an arduous task to look at a process image and detect
    infections or malware.'
  prefs: []
  type: TYPE_NORMAL
- en: Before ECFS, there existed no real standard for snapshotting of a process image
    other than using core files, which can be created on demand using the **gcore**
    script that comes with most Linux distributions. As briefly discussed in the previous
    chapter, regular core files are not particularly useful for process forensics
    analysis. This is why ECFS core files came into existence—to provide a file format
    that can describe every nuance of a process image so that it can be efficiently
    analyzed, easily navigated, and easily integrated with malware analysis and process
    forensics tools.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the basics of ECFS and how to use ECFS core
    files and the **libecfs** API to rapidly design malware analysis and forensics
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: History
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2011, I created a software prototype titled Linux VMA Monitor ([http://www.bitlackeys.org/#vmavudu](http://www.bitlackeys.org/#vmavudu))
    for a DARPA contract. This software was designed to look at live process memory
    or raw snapshots of process memory. It was able to detect all sorts of runtime
    infections, including shared library injection, PLT/GOT hijacking, and other anomalies
    that indicate runtime malware.
  prefs: []
  type: TYPE_NORMAL
- en: In more recent times, I considered rewriting this software into a more finished
    state, and I felt that a native snapshot format for process memory would be a
    really nice feature. This was the initial inspiration for developing ECFS, and
    although I have canceled my plans of reviving the Linux VMA Monitor software for
    now, I am continuing to expand and develop the ECFS software as it is of great
    value to many other people's projects. It is even being incorporated into the
    Lotan product, which is a piece of software used to detect exploitation attempts
    by analyzing crash dumps ([http://www.leviathansecurity.com/lotan](http://www.leviathansecurity.com/lotan)).
  prefs: []
  type: TYPE_NORMAL
- en: The ECFS philosophy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ECFS is all about making runtime analysis of a program easier than ever before.
    The entire process is encased within a single file, and it is organized in such
    a way that locating and accessing data and code that is critical for detecting
    anomalies and infections is achievable through orderly and efficient means. This
    is primarily done through parsing section headers to access useful data, such
    as symbol tables, dynamic linking data, and forensics-relevant structures.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with ECFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing this chapter, the complete ECFS project and source code
    is available at [http://github.com/elfmaster/ecfs](http://github.com/elfmaster/ecfs).
    Once you have cloned the repository with git, you should compile and install the
    software as described in the README file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, ECFS has two modes of use:'
  prefs: []
  type: TYPE_NORMAL
- en: Plugging ECFS into the core handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECFS snapshots without killing the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, the terms ECFS files, ECFS snapshots, and ECFS core files are
    used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: Plugging ECFS into the core handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing is to plug the ECFS core handler into the Linux kernel. The
    `make` install will accomplish this for you, but it must be done after every reboot
    or stored in an `init` script. The manual way of setting up the ECFS core handler
    is by modifying the `/proc/sys/kernel/core_pattern` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the command used to activate the ECFS core handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the `-t` option is set. This is very important for forensics and
    it should rarely be turned off. This option tells ECFS to capture the entire text
    segment for any executable or shared library mappings. In traditional core files,
    the text images are truncated to 4k. Later in this chapter, we will also examine
    the `-h` option (heuristics), which can be set to enable extended heuristics in
    order to detect shared library injection.
  prefs: []
  type: TYPE_NORMAL
- en: The `ecfs_handler` binary will invoke either `ecfs32` or `ecfs64` depending
    on whether the process is 64 bit or 32 bit. The pipe symbol (`|`) at the front
    of the line that we write into the procfs `core_pattern` entry tells the kernel
    to pipe the core files it produces into the standard input of our ECFS core handler
    process. The ECFS core handler then transforms the traditional core file into
    a highly customized and spectacular ECFS core file. Anytime if a process crashes
    or is delivered a signal that causes a core dump, such as **SIGSEGV** or **SIGABRT**,
    then the ECFS core handler will step in and instrument the core file creation
    with its own special set of procedures for creating an ECFS-style core dump.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of capturing an ECFS snapshot of `sshd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Having ECFS as the default core file handler is very nice and perfectly suitable
    for everyday use. This is because ECFS cores are backwards compatible with traditional
    core files and can be used with debuggers such as GDB. However, there are times
    when a user may want to capture an ECFS snapshot without having to kill the process.
    This is where the ECFS snapshot tool comes into usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: ECFS snapshots without killing the process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's consider a scenario where there is a suspicious process running. It is
    suspicious because it is consuming a lot of CPU and it has network sockets open
    even though it is known not to be a network program of any kind. In such a scenario,
    it may be desirable to leave the process running so that a potential attacker
    is not yet alerted, but still have the capability to produce an ECFS core file.
    The `ecfs_snapshot` utility should be used in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ecfs_snapshot` utility ultimately uses the ptrace system call, which means
    two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It may take noticeably longer to snapshot the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may be ineffective against processes that use anti-debugging techniques to
    prevent ptrace from attaching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In cases where either of these issues becomes a problem, you may have to consider
    using the ECFS core handler for the job, in which case you will have to kill the
    process. In most situations, however, the `ecfs_snapshot` utility will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of capturing an ECFS snapshot with the snapshot utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This snapshots the process for the program host and creates an ECFS snapshot
    called `host_snapshot`. In the following sections, we will demonstrate some actual
    use cases of ECFS and take a look at the ECFS files with a variety of utilities.
  prefs: []
  type: TYPE_NORMAL
- en: libecfs – a library for parsing ECFS files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ECFS file format is very easy to parse with traditional ELF utilities, such
    as `readelf`, but to build parsing tools that are custom, I highly recommend that
    you use the libecfs library. This library is specifically designed for easy parsing
    of ECFS core files. It will be demonstrated with slightly more details later in
    this chapter when we look at designing advanced malware analysis tools to detect
    infected processes.
  prefs: []
  type: TYPE_NORMAL
- en: libecfs is also used in the ongoing development of the `readecfs` utility, which
    is a tool for parsing ECFS files, and is very similar to the commonly known `readelf`
    utility. Note that libecfs is included with the ECFS package on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: readecfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `readecfs` utility will be used throughout the rest of this chapter while
    demonstrating the different ECFS features. Here is a synopsis of the tool from
    `readecfs -h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Examining an infected process using ECFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we show the effectiveness of ECFS with a real-world example, it would
    be helpful to have a little background of the method of infection that we will
    use from a hacker's perspective. It is often very useful for a hacker to be able
    to incorporate anti-forensic techniques into their workflow on compromised systems
    so that their programs, especially the ones that serve as backdoors and such,
    can remain hidden to the untrained eye.
  prefs: []
  type: TYPE_NORMAL
- en: One such technique is to perform process **cloaking**. This is the act of running
    a program inside of an existing process, ideally inside of a process that is known
    to be benign but persistent, such as ftpd or sshd. The Saruman anti-forensics
    exec ([http://www.bitlackeys.org/#saruman](http://www.bitlackeys.org/#saruman))
    allows an attacker to inject a complete, dynamically linked PIE executable into
    an existing process address space and run it.
  prefs: []
  type: TYPE_NORMAL
- en: It uses a thread injection technique so that the injected program can run simultaneously
    with the host program. This particular hacker technique was something that I came
    up with and designed in 2013, but I have no doubt that other such tools have existed
    for much longer than this in the underground scene. Typically, this type of anti-forensic
    technique would go unnoticed and would be very difficult to detect.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what type of efficiency and accuracy we can achieve by analyzing such
    a process with ECFS technology.
  prefs: []
  type: TYPE_NORMAL
- en: Infecting the host process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The host process is a benign process, and typically it would be something like
    sshd or ftpd, as already mentioned. For the sake of our example, we will use a
    simple and persistent program called host; it simply runs in an infinite loop,
    printing a message on the screen. We will then inject a remote server backdoor
    into the process using the Saruman anti-forensics exec launcher program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terminal 1, run the host program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In terminal 2, inject the backdoor into the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Capturing and analyzing an ECFS snapshot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, if we capture a snapshot of the process either by using the `ecfs_snapshot`
    utility or by signaling the process to the core dump, we can begin our examination.
  prefs: []
  type: TYPE_NORMAL
- en: The symbol table analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at the symbol table analysis of the `host.16186` snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `readelf` command allows us to view the symbol tables. Notice that a symbol
    table exists for both the dynamic symbols in `.dynsym` and the symbols for local
    functions, which are stored in the `.symtab` symbol table. ECFS is able to reconstruct
    the dynamic symbol table by accessing the dynamic segment and finding `DT_SYMTAB`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `.symtab` symbol table is a bit trickier but extremely valuable. ECFS uses
    a special method of parsing the `PT_GNU_EH_FRAME` segment that contains frame
    description entries in a dwarf format; these are used for exception handling.
    This information is useful for gathering the location and size of every single
    function defined within the binary.
  prefs: []
  type: TYPE_NORMAL
- en: In cases such as functions being obfuscated, tools such as IDA would fail to
    identify every function defined within a binary or core file, but the ECFS technology
    will succeed. This is one of the major impacts that ECFS makes on the reverse
    engineering world—a near-foolproof method of locating and sizing every function
    and producing a symbol table. In the `host.16186` file, the symbol table is fully
    reconstructed. This is useful because it could aid us in detecting whether or
    not any PLT/GOT hooks are being used to redirect shared library functions, and
    if so, we can identify the actual names of functions that have been hijacked.
  prefs: []
  type: TYPE_NORMAL
- en: The section header analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let's look at the section header analysis of the `host.16186` snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'My version of `readelf` has been slightly modified so that it recognizes the
    following custom types: `SHT_INJECTED` and `SHT_PRELOADED`. Without this modification
    to readelf, it will simply show the numerical values associated with those definitions.
    Check out `include/ecfs.h` for the definitions, and add them to the `readelf`
    source code if you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Section 23 is of particular interest to us; it has been marked as a suspicious
    ELF object with the injected denotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When the ECFS heuristics detects an ELF object as suspicious and it can''t
    find that particular object in its list of mapped shared libraries, it names the
    section in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The type can be one of four:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ET_NONE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ET_EXEC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ET_DYN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ET_REL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, it is obviously `ET_DYN`, represented as `dyn`. The count is
    simply the index of injected objects that have been found. In this case, the index
    is `0` as it is the first and only injected ELF object that was found in this
    particular process.
  prefs: []
  type: TYPE_NORMAL
- en: The type `INJECTED` obviously denotes that the section contains an ELF object
    that was determined suspicious or injected through unnatural means. In this particular
    case, the process was infected with Saruman (described earlier), which injects
    a **Position-Independent Executable** (**PIE**). A PIE executable is of type `ET_DYN`,
    similar to shared libraries, which is why ECFS has marked it as such.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting parasite code with readecfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have spotted a section in the ECFS core file that relates to parasitic code,
    which is an injected PIE executable in this case. The next step is to investigate
    the code itself. This can be done in one of the following ways: the `objdump`
    utility or a more advanced disassembler such as IDA pro can be used to navigate
    to the section called `.elf.dyn.0`, or the `readecfs` utility can first be used
    to extract the parasitic code from the ECFS core file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a singular copy of the parasite code that has been extracted from
    the process image, thanks to ECFS. The task of identifying this particular malware
    and then extracting it would be an extremely tedious task without ECFS. Now we
    can examine `parasite_code.exe` as a separate file, open it up in IDA, and so
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `readelf` is complaining in the preceding output. This is because
    the parasite that we extracted does not have a section header table of its own.
    In future, the `readecfs` utility will be able to reconstruct a minimal section
    header table for mapped ELF objects that are extracted from the overall ECFS core
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Azazel userland rootkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 7](part0069_split_000.html#21PMQ1-1d4163ae11644cc2802846625b2dc985
    "Chapter 7. Process Memory Forensics"), *Process Memory Forensics*, the Azazel
    userland rootkit is a userland rootkit that infects a process by means of `LD_PRELOAD`,
    where the Azazel shared library is linked to the process, and hijacks various
    `libc` functions. In [Chapter 7](part0069_split_000.html#21PMQ1-1d4163ae11644cc2802846625b2dc985
    "Chapter 7. Process Memory Forensics"), *Process Memory Forensics*, we used GDB
    and `readelf` to inspect a process for this particular rootkit infection. Now
    let's try the ECFS method to do this type of process introspection. The following
    is an ECFS snapshot of a process from the executable host2 that has been infected
    with the Azazel rootkit.
  prefs: []
  type: TYPE_NORMAL
- en: The symbol table of the host2 process reconstructed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, this is the symbol table of host2 with process reconstruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from the preceding symbol table that host2 is a simple program and
    has only a few shared library calls (this is shown in the `.dynsym` symbol table):
    `unlink`, `puts`, `opendir`, and `fopen`.'
  prefs: []
  type: TYPE_NORMAL
- en: The section header table of the host2 process reconstructed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see what the section header table of host2 looks like with process reconstruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The ELF sections 43 through 46 are all immediately suspicious because they
    are marked with the `PRELOADED` section type, which indicates that they are mappings
    from a shared library that was preloaded with the `LD_PRELOAD` environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Various userland rootkits, such as Azazel, use `LD_PRELOAD` as their means of
    injection. The next step is to look at the PLT/GOT (global offset table) and check
    whether it contains any pointers to functions outside of the respective boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might recall from previous chapters that the GOT contains a table of pointer
    values that should point to either of these:'
  prefs: []
  type: TYPE_NORMAL
- en: A PLT stub in the corresponding PLT entry (remember the lazy linking concepts
    from [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the particular GOT entry has already been resolved by the linker in some
    way (lazy or strict linking), then it will point to the shared library function
    denoted by the corresponding relocation entry from the `.rela.plt` section of
    the executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the PLT/GOT with ECFS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Understanding and systematically validating the integrity of the PLT/GOT is
    tedious by hand. Fortunately, there is a very easy way to do this with ECFS. If
    you prefer to write your own tool, then you should use the `libecfs` function
    that is designed specifically for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function allocates an array of structs, each element pertaining to a single
    PLT/GOT entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C struct named `pltgot_info_t` has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: An example of using this function can be found in `ecfs/libecfs/main/detect_plt_hooks.c`.
    This is a simple demonstrative tool for detecting shared library injection and
    PLT/GOT hooks, which is shown and commented for clarity later in this chapter.
    The `readecfs` utility also demonstrates the use of the `get_pltgot_info()` function
    when passed the `-g` flag.
  prefs: []
  type: TYPE_NORMAL
- en: The readecfs output for PLT/GOT validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output is easy to parse. The `gotvalue` should have an address
    that matches either `gotshlib` or `pltval`. We can see, however, that the very
    first entry, which is for the symbol `unlink`, has an address `0x7f0a0d3c8c81`.
    This does not match with the expected shared library function or PLT value.
  prefs: []
  type: TYPE_NORMAL
- en: More investigation would show that the address points to a function within `azazel.so`.
    From the preceding output, we can see that the only two functions that have not
    been tampered with are `puts` and `__libc_start_main`. For an even greater insight
    into the detection process, let's take a look at the source code for a tool that
    does automatic PLT/GOT validation as part of its detection capabilities. This
    tool is called `detect_plt_hooks` and was written in C. It utilizes the libecfs
    API to load and parse ECFS snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the following code has approximately 50 lines of source code, which
    is quite remarkable. If we were not using ECFS or libecfs, it would take approximately
    3,000 lines of C code to accurately analyze a process image for shared library
    injection and PLT/GOT hooks. I know this because I have done it, and using libecfs
    is by far the most painless way to go about coding such tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a code example using `detect_plt_hooks.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The ECFS reference guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ECFS file format is both simple and complicated! The ELF file format is
    complex in general, and ECFS inherits those complexities from a structural point
    of view. On the other side of the token, ECFS helps make navigating a process
    image quite easy if you know what specific features it has and what to look for.
  prefs: []
  type: TYPE_NORMAL
- en: In previous sections, we gave some real-life examples of utilizing ECFS that
    demonstrated many of its primary features. However, it is also important to have
    a simple and direct reference to what those characteristics are, such as which
    custom sections exist and what exactly they mean. In this section, we will provide
    a reference for the ECFS snapshot files.
  prefs: []
  type: TYPE_NORMAL
- en: ECFS symbol table reconstruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ECFS handler uses advanced understanding of the ELF binary format and even
    the dwarf debugging format—specifically with the dynamic segment and the `GNU_EH_FRAME`
    segment—to fully reconstruct the symbol tables of the program. Even if the original
    binary has been stripped and has no section headers, the ECFS handler is intelligent
    enough to rebuild the symbol tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have personally never encountered a situation where symbol table reconstruction
    failed completely. It usually reconstructs all or most symbol table entries. The
    symbol tables can be accessed using a utility such as `readelf` or `readecfs`.
    The libecfs API also has several functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: One function gets the dynamic symbol table and the other gets the local symbol
    table—`.dynsym` and `.symtab`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the reading symbol table with `readelf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: ECFS section headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ECFS handler reconstructs most of the original section headers that a program
    may have had. It also adds quite a few new sections and section types that can
    be very useful for forensic analysis. Section headers are identified by both name
    and type and contain data or code.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing section headers is very easy, and therefore they are very useful for
    creating a map of the process memory image. Navigating the entire process layout
    through section headers is a lot easier than having only program headers (such
    as with regular core files), which don't even have string names. The program headers
    are what describe the segments of memory, and the section headers are what give
    context to each part of a given segment. Section headers help give a much higher
    resolution to the reverse engineer.
  prefs: []
  type: TYPE_NORMAL
- en: '| Section header | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `._TEXT` | This points to the text segment (not the `.text` section). This
    makes locating the text segment possible without having to parse the program headers.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `._DATA` | This points to the data segment (not the `.data` section). This
    makes locating the data segment possible without having to parse the program headers.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.stack` | This points to one of several possible stack segments depending
    on the number of threads. Without a section named `.stack`, it would be far more
    difficult to know where the actual stack of the process is. You would have to
    look at the value of the `%rsp` register and then see which program header segments
    contain address ranges that match the stack pointer value. |'
  prefs: []
  type: TYPE_TB
- en: '| `.heap` | Similar to the `.stack` section, this points to the heap segment,
    also making identification of the heap much easier, especially on systems where
    ASLR moves the heap to random locations. On older systems, it was always extended
    from the data segment. |'
  prefs: []
  type: TYPE_TB
- en: '| `.bss` | This section is not new with ECFS. The only reason it is mentioned
    here is that with an executable or shared library, the `.bss` section contains
    nothing, since uninitialized data takes up no space on disk. ECFS represents the
    memory, however, and the `.bss` section is not actually created until runtime.
    The ECFS files have a `.bss` section that actually reflects the uninitialized
    data variables being used by the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `.vdso` | This points to the [vdso] segment that is mapped into every Linux
    process containing code that is necessary for certain `glibc` system call wrappers
    to invoke the real system call. |'
  prefs: []
  type: TYPE_TB
- en: '| `.vsyscall` | Similar to the `.vdso` code, the `.vsyscall` page contains
    code for invoking only a handful of virtual system calls. It has been kept around
    for backwards compatibility. It may prove useful to know this location during
    reverse engineering. |'
  prefs: []
  type: TYPE_TB
- en: '| `.procfs.tgz` | This section contains the entire directory structure and
    files for the `/proc/$pid` of the process that was captured by the ECFS handler.
    If you are an avid forensic analyst or programmer, then you probably already know
    how useful the information contained in the `proc` filesystem is. There are well
    over 300 files within `/proc/$pid` for a single process. |'
  prefs: []
  type: TYPE_TB
- en: '| `.prstatus` | This section contains an array of struct `elf_prstatus` structures.
    Very important information pertaining to the state of the process and its registers
    is stored in these structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `.fdinfo` | This section contains ECFS custom data that describes the file
    descriptors, sockets, and pipes being used for the processes'' open files, network
    connections, and inter-process communication. The header file, `ecfs.h`, defines
    the `fdinfo_t` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readecfs` utility parses and displays the file descriptor information
    nicely, as shown when looking at an ECFS snapshot for sshd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `.siginfo` | This section contains signal-specific information, such as what
    signal killed the process, or what the last signal code was before the snapshot
    was taken. The `siginfo_t struct` is stored in this section. The format of this
    struct can be seen in `/usr/include/bits/siginfo.h`. |'
  prefs: []
  type: TYPE_TB
- en: '| `.auxvector` | This contains the actual auxiliary vector from the bottom
    of the stack (the highest memory address). The auxiliary vector is set up by the
    kernel at runtime, and it contains information that is passed to the dynamic linker
    at runtime. This information may prove valuable in a number of ways to the advanced
    forensic analyst. |'
  prefs: []
  type: TYPE_TB
- en: '| `.exepath` | This holds the string of the original executable path that was
    invoked for this process, that is, `/usr/sbin/sshd`. |'
  prefs: []
  type: TYPE_TB
- en: '| `.personality` | This contains personality information, that is, ECFS personality
    information. An 8-byte unsigned integer can be set with any number of personality
    flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `.arglist` | Contains the original `''char **argv''` stored as an array in
    this section. |'
  prefs: []
  type: TYPE_TB
- en: Using an ECFS file as a regular core file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ECFS core file format is essentially backward compatible with regular Linux
    core files, and can therefore be used as core files for debugging with GDB in
    the traditional way.
  prefs: []
  type: TYPE_NORMAL
- en: The ELF file header for ECFS files has its `e_type` (ELF type) set to `ET_NONE`
    instead of `ET_CORE`, however. This is because core files are not expected to
    have section headers but ECFS files do have section headers, and to make sure
    that they are acknowledged by certain utilities such as `objdump`, `objcopy`,
    and so on, we have to mark them as files other than CORE files. The quickest way
    to toggle the ELF type in an ECFS file is with the `et_flip` utility that comes
    with the ECFS software suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using GDB with an ECFS core file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the following is an example of changing the ELF file type to `ET_CORE`
    and trying again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The libecfs API and how to use it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The libecfs API is the key component for integrating ECFS support into your
    malware analysis and reverse engineering tools for Linux. There is too much to
    document on this library to put into a single chapter of this book. I recommend
    that you use the manual that is still growing right alongside the project itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/elfmaster/ecfs/blob/master/Documentation/libecfs_manual.txt](https://github.com/elfmaster/ecfs/blob/master/Documentation/libecfs_manual.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: Process necromancy with ECFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever wanted to be able to pause and resume a process in Linux? After
    designing ECFS, it quickly became apparent that they contained enough information
    about the process and its state to relaunch them back into memory so that they
    can begin execution where they last left off. This feature has many possible use
    cases and demands more research and development.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the implementation for ECFS snapshot execution is basic and can only
    handle simple processes. At the time of writing this chapter, it can restore file
    streams but not sockets or pipes, and can only handle single-threaded processes.
    The software for executing an ECFS snapshot can be found on GitHub at [https://github.com/elfmaster/ecfs_exec](https://github.com/elfmaster/ecfs_exec).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of snapshot execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the ECFS snapshot file print_passfile.6627 (Where 6627 is the process
    ID). We will use ecfs_exec to execute this snapshot, and it should begin where
    it left off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That is a very simple demonstration of how `ecfs_exec` works. It uses the file
    descriptor information from the `.fdinfo` section to learn the file descriptor
    number, file path, and file offset. It also uses the `.prstatus` and `.fpregset`
    sections to learn the register state so that it can resume execution from where
    it left off.
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about ECFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The extended core file snapshot technology, ECFS, is still relatively new.
    I presented on it at defcon 23 ([https://www.defcon.org/html/defcon-23/dc-23-speakers.html#O%27Neill](https://www.defcon.org/html/defcon-23/dc-23-speakers.html#O%27Neill)),
    and the word is still spreading. Hopefully, a community will evolve and more people
    will begin adopting ECFS for their daily forensics work and tools. Nonetheless,
    at this point, there are several resources for ECFS in existence:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The official GitHub page: [https://github.com/elfmaster/ecfs](https://github.com/elfmaster/ecfs)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The original white paper (outdated): [http://www.leviathansecurity.com/white-papers/extending-the-elf-core-format-for-forensics-snapshots](http://www.leviathansecurity.com/white-papers/extending-the-elf-core-format-for-forensics-snapshots)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An article from POC || GTFO 0x7: *Innovations with core files*, [https://speakerdeck.com/ange/poc-gtfo-issue-0x07-1](https://speakerdeck.com/ange/poc-gtfo-issue-0x07-1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of the ECFS snapshot technology and the
    snapshot format. We experimented with ECFS using several real-life forensic examples,
    and even wrote a tool that detects shared library injection and PLT/GOT hooks
    using the libecfs C library. In the next chapter, we will jump out of userland
    and explore the Linux kernel, the layout of vmlinux, and a combination of kernel
    rootkit and forensic techniques.
  prefs: []
  type: TYPE_NORMAL
