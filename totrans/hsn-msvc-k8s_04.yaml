- en: Setting Up the CI/CD Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a microservice-based system, there are many moving parts. Kubernetes is a
    rich platform that provides a lot of building blocks for your system. Managing
    and deploying all of these components reliably and predictably requires a high
    level of organization and automation. Enter the CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will understand the problem the CI/CD pipeline solves, cover
    the different options for CI/CD pipelines for Kubernetes, and finally build a
    CI/CD pipeline for Delinkcious.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a CI/CD pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Options for Kubernetes CI/CD pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated CI/CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your images with CircleCI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up continuous delivery for Delinkcious
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will work with CircleCI and Argo CD. I will show you how
    to install Argo CD in the Kubernetes cluster later. To set up CircleCI, for free,
    follow *Getti**ng started* instructions on their website at [https://circleci.com/docs/2.0/getting-started/](https://circleci.com/docs/2.0/getting-started/).
  prefs: []
  type: TYPE_NORMAL
- en: The code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Delinkcious release for this chapter can be found at [https://github.com/the-gigi/delinkcious/releases/tag/v0.2](https://github.com/the-gigi/delinkcious/releases/tag/v0.2).
  prefs: []
  type: TYPE_NORMAL
- en: We will be working on the main Delinkcious code base, so there are no code snippets
    or examples.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a CI/CD pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development life cycle of software systems goes from code, through testing,
    generating artifacts, even more testing, and eventually, deployment to production.
    The basic idea is that whenever a developer commits changes to their source control
    system (for example, GitHub), these changes are detected by the **continuous integration**
    (**CI**) system, which immediately runs the tests.
  prefs: []
  type: TYPE_NORMAL
- en: This is often followed by a review by peers and merging the code changes (or
    a pull request) from a feature branch or development branch into the master. In
    the context of Kubernetes, the CI system is also responsible for building the
    Docker images for the services and pushing them to the image registry. At this
    point, we have Docker images that contain new code. This is where the CD system
    comes in.
  prefs: []
  type: TYPE_NORMAL
- en: When a new image becomes available, the **continuous delivery** (**CD**) system
    will deploy it to the target environment(s). CD is the process of ensuring that
    the overall system is in a desired state, which is done though provisioning and
    deployments. Sometimes, deployment can occur as a result of configuration change
    if the system doesn't support dynamic configuration. We will discuss configuration
    in great detail in [Chapter 5](0d340a5c-b2da-41ab-a50d-56bd985c10f2.xhtml), *Configuring
    Microservices with Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: So, a CI/CD pipeline is a set of tools that detect code changes and can take
    them all the way to production according to the processes and policies of the
    organization. It is typically the responsibility of DevOps engineers to build
    and maintain this pipeline, and it is used heavily by developers.
  prefs: []
  type: TYPE_NORMAL
- en: Every organization and company (or even different groups within the same company)
    will have a specific process. In one of my first jobs, my first task was to replace
    a Perl-based build system (that's what CI/CD pipelines were called back then)
    with lots of recursive makefiles that nobody understood any more. That build system
    had to run code generation steps on Windows using some modeling software, compile
    and run C++ unit tests on two flavors of Unix (including an embedded flavor) using
    two different toolchains, and trigger open CVS. I chose Python and had to create
    everything from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: It was fun, but very specific to this company. It's common to think of CI/CD
    pipelines as a workflow of steps driven by events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates a simple CI/CD pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c83021d-cee3-4999-9aca-fcaee423eabf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The stages in this pipeline function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The developer commits their changes to GitHub (source control)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CI server runs the tests, builds a Docker image, and pushes the image to
    DockerHub (image registry)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Argo CD server detects that there is a new image available and deploys to
    the Kubernetes cluster
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have understood the CI/CD pipeline, let's examine a specific CI/CD
    pipeline choice.
  prefs: []
  type: TYPE_NORMAL
- en: Options for the Delinkcious CI/CD pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Choosing a CI/CD pipeline for your system is a major decision. When I faced
    this decision for Delinkcious, I looked into several alternatives. There isn''t
    an obvious choice here. Kubernetes is moving fast and the tooling and processes
    struggle to catch up. I evaluated a few choices and settled on CircleCI for continuous
    integration and Argo CD for continuous delivery. I initially considered a one-stop
    shop for the entire CI/CD pipeline and, after reviewing some options, I decided
    that I preferred to consider them as two separate entities and chose a different
    solution for CI and CD. Let''s briefly review some of these options (there are
    many, many more):'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spinnaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Travis CI and CircleCI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tekton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argo CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rolling your own
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jenkins X was my first choice and favorite. I read some articles and watched
    some presentations that made me want to like it. It provides all the features
    you want, including some advanced capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Automated CI/CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment promotion via GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pull request preview environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic feedback on your commit and pull requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the cover, it utilizes Jenkins, which is a mature, albeit complex, product.
    The premise of Jenkins X is that it will mask the complexity of Jenkins and provide
    a Kubernetes-specific streamlined workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'I was disappointed by a couple of issues when I tried to actually use Jenkins
    X:'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't work out of the box and troubleshooting is complicated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very opinionated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't support the monorepo approach well (or at all).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I tried to make it work for a while, but after reading about other people's
    experiences and seeing the lack of response in the Jenkins X slack community channels,
    I was turned off Jenkins X. I still like the idea, but it really has to be super
    stable before I try it again.
  prefs: []
  type: TYPE_NORMAL
- en: Spinnaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spinnaker is an open source CI/CD solution from Netflix. It has many benefits,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It has been adopted by many companies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a lot of integration with other products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports a lot of best practices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The downsides of Spinnaker are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a large and complicated system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a steep learning curve.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not Kubernetes-specific.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, I decided to skip on Spinnaker – not because of any fault of Spinnaker
    itself, but because I don't have experience with it. I didn't want to learn such
    a large product from scratch while developing Delinkcious itself and writing this
    book. You may very well find that Spinnaker is the right CI/CD solution for you.
  prefs: []
  type: TYPE_NORMAL
- en: Travis CI and CircleCI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I prefer to separate the CI solution from the CD solution. Conceptually, the
    role of the CI process is to generate a container image and push it to a registry.
    It doesn't need to be aware of Kubernetes at all. The CD solution, on the other
    hand, must be Kubernetes-aware, and it ideally runs inside the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: For CI, I considered Travis CI and CircleCI. Both provide free CI services for
    open source projects. I settled on CircleCI because it is more feature-complete
    and has a nicer UI, which is important. I'm sure Travis CI would work well too.
    I use Travis CI in some of my other open source projects. It's important to note
    that the CI part of the pipeline is completely Kubernetes-agnostic. The end result
    is a Docker image in an image registry. This Docker image can be used for other
    purposes and not necessarily deployed in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Tekton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tekton is a very interesting project. It is Kubernetes-native and has great
    abstractions of steps, tasks, runs, and pipelines. It is relatively young, but
    seems very promising. It was also selected as one of the inaugural projects of
    the CD Foundation: [https://cd.foundation/projects/](https://cd.foundation/projects/).'
  prefs: []
  type: TYPE_NORMAL
- en: It will be interesting to see how it evolves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of Tekton are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Modern design and clean conceptual model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported by the CD foundation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built on top of prow (the CI/CD solution of Kubernetes itself)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes-native solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of Tekton are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It's still fairly new and unstable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't have all the features and capabilities of other solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argo CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CD solution, as opposed to the CI solution, is very specific to Kubernetes.
    I picked Argo CD for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes-aware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented on top of a general-purpose workflow engine (Argo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs on your Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented in Go (not that important, but I like it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Argo CD has a number of disadvantages, too:'
  prefs: []
  type: TYPE_NORMAL
- en: It isn't a member of the CD foundation or the CNCF (less recognition in the
    community).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intuit, the primary company behind it, is not a major cloud-native powerhouse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argo CD is a young project that comes from Intuit, who acquired the original
    developers of the Argo project – Applatix. I really like its architecture and,
    when I tried it, everything worked like a charm.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling your own
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I briefly considered creating my own simple CI/CD pipeline. The operations are
    not complicated. For the purpose of this book, I didn't need a very reliable solution,
    and it would have been easy to explain exactly what happens at each step. However,
    with the reader in mind, I decided that it was best to use existing tools that
    can be utilized directly and also save me time developing a poor CI/CD solution.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a good idea of the different options for CI/CD
    solutions on Kubernetes. We reviewed most of the popular solutions and chose CircleCI
    and Argo CD as the best fit for the Delinkcious CI/CD solution. Next, we'll discuss
    the hot new trend of GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitOps is a new buzzword, although the concept is not very new. It is another
    variant of *Infrastructure as Code*. The basic idea is that your code, configuration,
    and the resources it requires should all be described and stored in a source control
    repository where they are version controlled. Whenever you push a change to the
    repository, your CI/CD solution will respond and take the correct action. Even
    rollbacks can be initiated just by reverting to a previous version in your repository.
    The repository doesn't have to be Git, of course, but GitOps sounds way better
    than Source Control Ops, and most people use Git anyway, so here we are.
  prefs: []
  type: TYPE_NORMAL
- en: Both CircleCI and Argo CD fully support and advocate the GitOps model. When
    your `git push` code changes, CircleCI will trigger on it and start building the
    correct images. When you `git push` changes to the Kubernetes manifests, Argo
    CD will trigger and deploy those changes to your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're clear on what GitOps is, we can start implementing the continuous
    integration part of the pipeline for Delinkcious. We will use CircleCI to build
    Docker images from source code.
  prefs: []
  type: TYPE_NORMAL
- en: Building your images with CircleCI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s dive in and look at the Delinkcious CI pipeline. We will go over each
    step in the continuous integration process, which includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the source tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the CI pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the build script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerizing a Go service with a multi-stage Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the CircleCI user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the source tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Continuous integration is about building and testing stuff. The first step
    is to understand what needs to be built and tested in Delinkcious. Let''s have
    another look at the Delinkcious source tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `pkg` directory contains packages that are used by services and commands.
    We should run the unit tests of these packages. The `svc` directory contains our
    microservices. We should build those services, package each one in a properly
    versioned Docker image, and push those images to DockerHub (the image registry).
    The `cmd` directory currently contains end-to-end tests. Those are designed to
    run locally and don't need to be built by the CI pipeline (this can be changed
    if you want to add end-to-end tests to our testing processes).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the CI pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CircleCI is configured by a single YAML file with a standard name and location,
    that is, `<root directory>/.circleci/config.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break it apart and understand what''s going on. The first part specifies
    the build job, and below that are the necessary Docker images `(golang` and `postgres`)
    and their environment. Then, we have the working directory, where the `build`
    commands should be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part is the build steps. The first step is just checkout. In the CircleCI
    UI, I associated the project with the Delinkcious GitHub repository so that it
    knows where to checkout from. If the repository is not public, then you''ll need
    to provide an access token, too. The second step is a `run` command that gets
    all the Go dependencies of Delinkcious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I had to explicitly `go get` the `ginkgo` framework and the `gomega` library
    because they are imported using Golang dot notation, which makes them invisible
    to `go get ./...`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have all the dependencies, we can run the tests. I am using the `ginkgo`
    test framework in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section is where it builds and pushes the Docker images. Since it
    requires access to the Docker daemon, it needs special setup via the `setup_remote_docker`
    step. The `docker_layer_caching` option is used to make everything more efficient
    and faster by reusing previous layers. The actual build out and push is handled
    by the `build.sh` script, which we will look at in the next section. Note that
    I made sure it''s executable via `chmod +x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I'm just scratching the surface here. There is much more to CircleCI, with orbs
    for reusable configuration, workflows, triggers, and artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the build.sh script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `build.sh` script is available at [https://github.com/the-gigi/delinkcious/blob/master/build.sh](https://github.com/the-gigi/delinkcious/blob/master/build.sh).
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine it bit by bit. There are several best practices we will follow
    here. First, it's a good idea to add a shebang with the path of the binary that
    will execute your script – that is, if you know where it is located. If you try
    to write a cross-platform script that works on many different platforms, you may
    need to rely on the path or other techniques. `set -eo pipefail` will fail out
    immediately (even in the middle of a pipe) if anything goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is highly recommended for production environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next few lines just set some variables for directories and the tags for
    the Docker images. There are two tags: `STABLE_TAB` and `TAG`. The `STABLE_TAG`
    tag has a major and minor version and doesn''t change in every build. The `TAG`
    includes the `CIRCLE_BUILD_NUM` provided by CircleCI and is incremented in every
    build. This means that the `TAG` is always unique. This is considered a best practice
    for tagging and versioning images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, we go to the `svc` directory, which is the parent directory of all our
    services, and log in to DockerHub using the environment variables we set in the
    CircleCI project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we get to the main event. The script iterates over all the subdirectories
    of the `svc` directory looking for `Dockerfile`. If it finds a `Dockerfile`, it
    builds an image, tags it using a combination of service name and both `TAG` and
    `STABLE_TAG`, and finally pushes the tagged images to the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Dockerizing a Go service with a multi-stage Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Docker images you build in a microservice system are very important. You
    will build many of them, and each one many, many times. These images will also
    be shipped back and forth over the wire, and they present a target for attackers.
    With this in mind, it makes sense to build images that have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Present minimal attack surface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be done by using a proper base image. For example, Alpine is very
    popular due to its small footprint. However, nothing beats the scratch base image.
    With Go-based microservices, you can literally create an image that just contains
    your service binary. Let''s continue peeling the onion and look into the Dockerfile
    of one of the services. Spoiler alert: they are all virtually identical, and just
    differ in terms of their service names.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the `Dockerfile` of `link_service` at [https://github.com/the-gigi/delinkcious/blob/master/svc/link_service/Dockerfile](https://github.com/the-gigi/delinkcious/blob/master/svc/link_service/Dockerfile).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using the multi-stage `Dockerfile` here. We will build the image using
    the standard Golang image. The arcane magic in the last line is what it takes
    to build a truly static and self-contained Golang binary that doesn''t require
    a dynamic runtime library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We then copy the final binary into a scratch base image and create the smallest
    and most secure image possible. We exposed the `7070` port, which is the port
    the service listens on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Exploring the CircleCI UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CircleCI has a very friendly UI. Here, you can set various project settings,
    explore your builds, and drill down into specific builds. Remember that we used
    a monorepo approach and that, in the `build.sh` file, we took care of building
    multiple services. From CircleCI''s point of view, Delinkcious is a single cohesive
    project. Here is the project''s view of Delinkcious, which displays the recent
    builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9a97ae35-684e-46b5-a109-431a25306b59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s drill down into a successful build. All is well and green:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a41c4da5-4506-4b5d-b58b-ba086564d8e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can even expand any step and check the console output. Here''s the output
    of the test stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5aa9ea2b-c03b-4f08-9d2b-be6cb0ac69af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is cool, but it''s even more useful when things go wrong and you need
    to figure out why. For example, at one point, I tried to hide the `build.sh` script
    inside the `.circleci` directory next to the `config.yaml` file, but it wasn''t
    added to the Docker context and produced the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/517f725d-a032-41db-9dc5-8c68fbf28b44.png)'
  prefs: []
  type: TYPE_IMG
- en: Considering future improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Dockerfiles are pretty much duplicates, and there are some assumptions that
    can be parameterized. In the Kubernetes ecosystem, there are some interesting
    projects that help to address these concerns. Some of the solutions are for local
    development and can automatically generate the necessary Dockerfiles, while others
    are more targeted toward consistent and uniform production setups. We will look
    into some of these in later chapters. In this chapter, I want to keep it simple
    and avoid overwhelming you with too many options and layers of indirection.
  prefs: []
  type: TYPE_NORMAL
- en: Another opportunity for improvement is to test and build only services that
    have changed (or their dependencies have changed). As it stands, the `build.sh`
    script always builds all the images and tags them all with the same tags.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've built a complete CI pipeline using CircleCI and Docker. The next
    phase is to set up Argo CD as a continuous delivery pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up continuous delivery for Delinkcious
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With continuous integration in CircleCI under our belt, we can turn our attention
    to continuous delivery. First, we'll see what it takes to deploy a Delinkcious
    microservice to a Kubernetes cluster, then we'll look into Argo CD itself, and
    finally, we'll set up complete continuous delivery for Delinkcious via Argo CD.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Delinkcious microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each Delinkcious microservice has a set of Kubernetes resources defined in
    YAML manifests in its `k8s` subdirectory. Here is the link service `k8s` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `link_manager.yaml` file contains two resources: the Kubernetes deployment
    and the Kubernetes service. The Kubernetes deployment is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The Kubernetes service is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `db.yaml` file describes the database the link service uses to persist
    its state. Both can be deployed via `kubectl` in a single command by passing the
    `k8s` directory to `kubectl apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The main difference between kubectl create and `kubectl apply` is that `create`
    will return an error if a resource already exists.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying from the command line with `kubectl` is nice, but our goal is to automate
    the process. Let's understand this.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Argo CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Argo CD is an open source continuous delivery solution for Kubernetes. It was
    created by Intuit and adopted by many other companies, including Google, NVIDIA,
    Datadog, and Adobe. It has an impressive set of features, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Automated deployment of apps to specific target environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CLI and web visualization of applications and differences between the desired
    and live states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooks for supporting advanced deployment patterns (blue/green and canary)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for multiple config management tools (plain YAML, ksonnet, kustomize,
    Helm, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous monitoring of all deployed applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual or automated sync of applications to the desired state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rollback to any application state that's committed in the Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health assessment for all the components of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSO integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps webhook integration (GitHub, GitLab, and BitBucket)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service account/access key management for integration with CI pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audit trails for application events and API calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argo CD is built on Argo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Argo CD is a specialized CD pipeline, but it is built on the solid Argo workflow
    engine. I like this layered approach a lot, where you have a robust general-purpose
    foundation for the problem of orchestrating a workflow composed of steps and then
    build on top of it with CD-specific features and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD utilizes GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Argo CD adheres to the GitOps approach. The basic principle is that the state
    of your system is stored in Git. Argo CD manages your live state versus the desired
    state by examining Git diffs and using Git primitives to roll back and reconcile
    the live state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Argo CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Argo CD follows best practices and expects to be installed in a dedicated namespace
    on your Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what was created. Argo CD installed four types of objects: pods,
    services, deployments, and replica sets. Here are the pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here are the replica sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, Argo CD also installs two **custom resource definitions **(**CRDs**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'CRDs allow various projects to extend the Kubernetes API and add their own
    domain objects, as well as controllers to monitor them and other Kubernetes resources.
    Argo CD adds the concepts of an application and project to the world of Kubernetes.
    Soon, you will see how they integrate for the purposes of continuous delivery
    with built-in Kubernetes resources such as deployments, services, and pods. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Argo CD CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Port-forward to access the Argo CD server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial password for the admin user is the name of the Argo CD server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If it complains about an insecure login, just confirm by pressing *y*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, to skip the warning, type in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can change the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you store your password in an environment variable (for example, `ARGOCD_PASSWORD`),
    then you can have a one-liner so that you can log in with no further questions
    being asked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Argo CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember to port-forward the argocd-server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can just browse to `https://localhost:8080` and provide the `admin`
    user''s password to log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/89af4578-32da-4ec6-8162-c853c128dd08.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring Argo CD is a pleasure. Its UI is very pleasant and easy to work
    with. It supports the Delinkcious monorepo out of the box, and there are no assumptions
    that each Git repository contains one application or project.
  prefs: []
  type: TYPE_NORMAL
- en: It will ask you for a Git repository to watch for changes, a Kubernetes cluster
    (defaults to the cluster it is installed on), and then it will try to detect the
    manifests in the repository. Argo CD supports multiple manifest formats and templates,
    such as Helm, ksonnet, and kustomize. We will introduce some of these fine tools
    later in this book. To keep things simple, we have configured each application
    with the directory that contains its raw `k8s` YAML manifests, which Argo CD also
    supports.
  prefs: []
  type: TYPE_NORMAL
- en: When all is said and done, the Argo CD is ready to go!
  prefs: []
  type: TYPE_NORMAL
- en: Using sync policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Argo CD detects when an application's manifests are out of sync,
    but doesn't sync automatically. This is a good default. In some cases, more tests
    need to run in dedicated environments before pushing changes to production. In
    other cases, a human must be in the loop. However, in many other cases, it's OK
    to automatically deploy changes to the cluster immediately and without human intervention.
    The fact that Argo CD follows GitOps also makes it very easy to sync back to any
    previous version (including the last one).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Delinkcious, I chose auto sync because it is a demo project and the consequences
    of deploying a bad version are negligible. This can be done in the UI or from
    the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The auto sync policy doesn''t guarantee that the application will always be
    in sync. There are limitations that govern the auto sync process, which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications in error state will not attempt automated sync.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argo CD will attempt only a single auto sync for a specific commit SHA and parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If auto sync failed for whatever reason, it will not attempt it again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't roll back an application with auto sync.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all of these cases, you either have to make a change to the manifests to
    trigger another auto sync or sync manually. To roll back (or, in general, sync
    to a previous version), you must turn auto sync off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Argo CD offers another policy for pruning resources on deployment. When an
    existing resource no longer exists in Git, Argo CD will not delete it by default.
    This is a safety mechanism that''s used to avoid destroying critical resources
    if someone makes a mistake while editing Kubernetes manifests. However, if you
    know what you''re doing (for example, for stateless applications), you can turn
    on automatic pruning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Exploring Argo CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have logged in and configured Argo CD, let's explore it a little
    bit. I really like the UI, but you can do everything from the command line or
    through a REST API, too, if you want to access it programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'I already configured Argo CD with the three Delinkcious microservices. Each
    service is considered an application in Argo CD speak. Let''s take a look at the
    Applications view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/df0184c7-6233-48e9-acdd-69818bdbef64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a few interesting things here. Let''s talk about each one:'
  prefs: []
  type: TYPE_NORMAL
- en: The project is an Argo CD concept for grouping applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The namespace is the Kubernetes namespace where the application should be installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cluster is the Kubernetes cluster, that is, `https://kubernetes.default.svc` and
    this is the cluster where Argo CD is installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status tells you if the current application is in sync with its YAML manifests
    in the Git repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The health tells you if the application is OK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The repository is the application's Git repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path is the relative path within the repository where the `k8s` YAML manifests
    live (Argo CD monitors this directory for changes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what you get from the `argocd` CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see (both in the UI and in the CLI), `link-manager` is out of sync.
    We can sync it by selecting Sync from the ACTIONS dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a502437e-8c5b-4674-8729-86ef2c59a169.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can do this from the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the coolest things about the UI is how it presents all the `k8s` resources
    associated with an application. By clicking on the `social-graph-manager` application,
    we get the following view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/82b4007d-977f-4a44-99fb-04fcfe418ba2.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see the application itself, the services, the deployments, and the pods,
    including how many pods are running. This is actually a filtered view and, if
    we want to, we can add the replica sets associated with each deployment and the
    endpoints of each service to the display. However, these aren't interesting most
    of the time, so Argo CD doesn't display them by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can click on a service and view a SUMMARY of its information, including
    the MANIFEST:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aa33e5a2-434f-41e1-a431-0f1b81e471e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For pods, we can even check the logs, as shown in the following screenshot,
    all from the comfort of the Argo CD UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a3d9eeff-e579-4f2f-ac1f-48bcb964819a.png)'
  prefs: []
  type: TYPE_IMG
- en: Argo CD can already take you a long way. However, it has a lot more to offer,
    and we will dive into these offerings later on in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the importance of a CI/CD pipeline for a microservices-based
    distributed system. We reviewed some CI/CD options for Kubernetes and settled
    on a combination of CircleCI for the CI part (code change | Docker image) and
    Argo CD for the CD part (`k8s` manifest change | deployed application).
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the best practices for building Docker images using multi-stage
    builds, the `k8s` YAML manifests for Postgres DB, and the deployment and service
    `k8s` resources. Then, we installed Argo CD in the cluster, configured it to build
    all our microservices, and explored the UI and the CLI. At this point, you should
    have a clear understanding of the concept of CI/CD and how important it is, the
    pros and cons of various solutions, and how to choose the best option for your
    system.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is much more to come. In later chapters, we will improve our
    CI/CD pipeline with additional tests, security checks, and advanced multi-environment
    deployment options.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will turn out attention to configuring our services.
    Configuration is a huge part of developing complex systems that need to be developed,
    tested, and deployed by large teams. We will explore various conventional configuration
    options, such as command-line arguments, environment variables, and configuration
    files, as well as more dynamic configuration options and the special configuration
    features of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following sources for more information regarding what
    was covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some good resources to expand your knowledge of the CI/CD options
    on Kubernetes. First and foremost, here are the two projects I use for the Delinkcious
    CI/CD solution:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CircleCI**: [https://circleci.com/docs/](https://circleci.com/docs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Argo**: [https://argoproj.github.io/docs/argo-cd/docs/](https://argoproj.github.io/docs/argo-cd/docs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, there''s this free mini ebook about CI/CD with Kubernetes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://thenewstack.io/ebooks/kubernetes/ci-cd-with-kubernetes/](https://thenewstack.io/ebooks/kubernetes/ci-cd-with-kubernetes/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, here are a couple of the other options I discarded for Delinkcious,
    but may be a good option for you:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins X**: [https://jenkins-x.io/](https://jenkins-x.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spinnaker**: [https://www.spinnaker.io/](https://www.spinnaker.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
