- en: Working with Images, Audio, and other Assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading media content on the web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing a URL with urllib to get the filename
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining type of content for a URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining a file extension from a content type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading and saving images to the local file system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading and saving images to S3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating thumbnails for images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking website screenshots with Selenium
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking a website screenshot with an external service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing OCR on images with pytessaract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Video Thumbnail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ripping an MP4 video to an MP3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common practice in scraping is the download, storage, and further processing
    of media content (non-web pages or data files). This media can include images,
    audio, and video.  To store the content locally (or in a service like S3) and
    do it correctly, we need to know what the type of media is, and it's not enough
    to trust the file extension in the URL.  We will learn how to download and correctly
    represent the media type based on information from the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Another common task is the generation of thumbnails of images, videos, or even
    a page of a website.  We will examine several techniques of how to generate thumbnails
    and make website page screenshots.  Many times these are used on a new website
    as thumbnail links to the scraped media that is now stored locally.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is often the need to be able to transcode media, such as converting
    non-MP4 videos to MP4, or changing the bit-rate or resolution of a video.  Another
    scenario is to extract only the audio from a video file.  We won't look at video
    transcoding, but we will rip MP3 audio out of an MP4 file using `ffmpeg`.  It's
    a simple step from there to also transcode video with `ffmpeg`.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading media content from the web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Downloading media content from the web is a simple process: use Requests or
    another library and download it just like you would HTML content.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a class named `URLUtility` in the `urls.py mdoule` in the `util` folder
    of the solution.  This class handles several of the scenarios in this chapter
    with downloading and parsing URLs. We will be using this class in this recipe
    and a few others. Make sure the `modules` folder is in your Python path.  Also,
    the example for this recipe is in the `04/01_download_image.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is how we proceed with the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `URLUtility` class can download content from a URL.  The code in the recipe''s
    file is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this you will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The example reads `171014` bytes of data.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The URL is defined as a constant  `const.ApodEclipseImage()` in the `const`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of the `URLUtility` class has the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor stores the URL, parses it, and downloads the file with the
    `read()` method.  The following is the code of the `read()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function uses `urlopen` to get a response object, and then reads the stream
    and stores it as a property of the object.  That data can then be retrieved using
    the data property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code then simply reports on the length of that data, with the value of `171014`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This class will be used for other tasks such as determining content types, filename,
    and extensions for those files.  We will examine parsing of URLs for filenames
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a URL with urllib to get the filename
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When downloading content from a URL, we often want to save it in a file.  Often
    it is good enough to save the file in a file with a name found in the URL.  But
    the URL consists of a number of fragments, so how can we find the actual filename
    from the URL, especially where there are often many parameters after the file
    name?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will again be using the `URLUtility` class for this task.  The code file
    for the recipe is `04/02_parse_url.py`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the recipe''s file with your python interpreter.  It will run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the constructor for `URLUtility`, there is a call to `urlib.parse.urlparse`.
     The following demonstrates using the function interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ParseResult` object contains the various components of the URL.  The path
    element contains the path and the filename.  The call to the `.filename_without_ext`
    property returns just the filename without the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The call to `os.path.basename` returns only the filename portion of the path
    (including the extension). `os.path.splittext()` then separates the filename and
    the extension, and the function returns the first element of that tuple/list (the
    filename).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may seem odd that this does not also return the extension as part of the
    filename.  This is because we cannot assume that the content that we received
    actually matches the implied type from the extension.  It is more accurate to
    determine this using headers returned by the web server.  That's our next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the type of content for a URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When performing a `GET` requests for content from a web server, the web server
    will return a number of headers, one of which identities the type of the content
    from the perspective of the web server.  In this recipe we learn to use that to
    determine what the web server considers the type of the content.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We again use the `URLUtility` class.  The code for the recipe is in `04/03_determine_content_type_from_response.py`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the script for the recipe.  It contains the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `.contentype` property is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `.headers` property of the `_response` object is a dictionary-like class
    of headers.  The `content-type` key will retrieve the `content-type` specified
    by the server.  This call to the `ensure_response()` method simply ensures that
    the `.read()` function has been executed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The headers in a response contain a wealth of information.  If we look more
    closely at the `headers` property of the response, we can see the following headers
    are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And we can see the values for each of these headers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Many of these we will not examine in this book, but for the unfamiliar it is
    good to know that they exist.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the file extension from a content type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is good practice to use the `content-type` header to determine the type of
    content, and to determine the extension to use for storing the content as a file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We again use the `URLUtility` object that we created. The recipe's script is `04/04_determine_file_extension_from_contenttype.py):`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proceed by running the recipe's script.
  prefs: []
  type: TYPE_NORMAL
- en: 'An extension for the media type can be found using the `.extension` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This reports both the extension determined from the file type, and also from
    the URL.  These can be different, but in this case they are the same.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the implementation of the `.extension_from_contenttype` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line ensures that we have read the response from the URL.  The function
    then uses a python dictionary, defined in the `const` module, which contains a
    dictionary of content-types to extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If the content type is in the dictionary, then the corresponding value will
    be returned.  Otherwise, `None` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the corresponding property, `.extension_from_url`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This uses the same technique as the `.filename` property to parse the URL, but
    instead returns the `[1]` element, which represents the extension instead of the
    base filename.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated, it's best to use the `content-type` header to determine an extension
    for storing the file locally.  There are other techniques than what is provided
    here, but this is the easiest.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and saving images to the local file system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes when scraping we just download and parse data, such as HTML, to extract
    some data, and then throw out what we read.  Other times, we want to keep the
    downloaded content by storing it as a file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code example for this recipe is in the `04/05_save_image_as_file.py` file.
    The portion of the file of importance is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script with your Python interpreter and you will get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sample simply writes the data to a file using standard Python file access
    functions.  It does it in an object oriented manner by using a standard interface
    for writing data and with a file based implementation in the `FileBlobWriter`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The class is passed a string representing the directory where the file should
    be placed.  The data is actually written during a later call to the `.write()`
    method.  This method merges the filename and `directory (_location)`, and then
    opens/creates the file and writes the bytes.  The `with` statement ensures that
    the file is closed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This write could have simply been handled using a function that wraps the code. 
    This object will be reused throughout this chapter. We could use the duck-typing
    of python, or just a function, but the clarity of interfaces is easier.  Speaking
    of that, the following is the definition of this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We will also see another implementation of this interface that lets us store
    files in S3.  Through this type of implementation, through interface inheritance,
    we can easily substitute implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and saving images to S3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to write content into S3 in [Chapter 3](acb4595a-ad11-49ca-91bd-71ee144229d9.xhtml),
    *Processing Data*.  Here we will extend that process into an interface implementation
    of IBlobWriter to write to S3.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code example for this recipe is in the `04/06_save_image_in_s3.py` file. 
    Also ensure that you have set your AWS keys as environment variables so that Boto
    can authenticate the script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the recipe''s script.  It will execute the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking in S3, we can see that the bucket was created and the image placed
    within the bucket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5abb4f94-3072-4d9a-b868-60ac32c2d295.png)The Image in S3'
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the implementation of the `S3BlobWriter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have seen this code in before  in the recipe on writing to S3\.  This class
    wraps that up neatly into a reusable interface implementation.  When creating
    an instance, specify the bucket name.  Then every call to `.write()` will save
    in the same bucket.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: S3 provides a capability on buckets known as enabling a website.  Essentially,
    if you set this option, the content in your bucket will be served via HTTP.  We
    could write many images to this directory and then have them served directly from
    S3 without implementing a web server!
  prefs: []
  type: TYPE_NORMAL
- en: Generating thumbnails for images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many times when downloading an image, you do not want to save the full image,
    but only a thumbnail. Or you may also save both the full-size image and a thumbnail.
     Thumbnails can be easily created in python using the Pillow library.  Pillow
    is a fork of the Python Image Library, and contains many useful functions for
    manipulating images.  You can find more information on Pillow at [https://python-pillow.org](https://python-pillow.org). 
    In this recipe, we use Pillow to create an image thumbnail.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The script for this recipe is `04/07_create_image_thumbnail.py`.  It uses the
    Pillow library, so make sure you have installed Pillow into your environment with
    pip or other package management tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is how proceed with the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script for the recipe.  It will execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The result from this will be a file named `eclipse_thumbnail.png` written into
    your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bc8c1992-366f-43c9-bcb4-281c5644df69.png)The Thumbnail we Created'
  prefs: []
  type: TYPE_NORMAL
- en: Pillow keeps the ratio of width and height consistent.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ImageThumbnailGenerator` class wraps calls to Pillow to provide a very
    simple API for creating a thumbnail for an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The constructor is passed the data for the image and creates a Pillow image
    object from that data.  The thumbnail is created by calling `.thumbnail()` with
    a tuple representing the desired size of the thumbnail.  This resizes the existing
    image, and Pillow preserves the aspect ratio.  It will determine the longer side
    of the image and scale that to the value in the tuple representing that axis.
     This image is taller than it is wide, so the thumbnail is made 200 pixels high,
    and the width is scaled accordingly (in this case, to 160 pixels).
  prefs: []
  type: TYPE_NORMAL
- en: Taking a screenshot of a website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common scraping task is to create a screenshot of a website.  In Python we
    can create a thumbnail using selenium and webdriver.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The script for this recipe is `04/08_create_website_screenshot.py`.  Also, make
    sure you have selenium in your path and have installed the Python library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the script for the recipe.  The code in the script is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A `WebsiteScreenshotGenerator` object is created, and then its capture method
    is called, passing the URL of the website to capture, and a desired width in pixels
    for the image.
  prefs: []
  type: TYPE_NORMAL
- en: This creates a Pillow image that can be accessed using the `.image` property,
    and the bytes for the image can be directly accessed using `.image_bytes`.  This
    script gets those bytes and writes them to the `website_screenshot.png` file in
    you home directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following output from this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And our resulting image is the following (the image will vary in its content):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b9c8c756-e789-43ae-a20b-d90e7b146181.png)The Screenshot of the Web
    Page'
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the code of the `WebsiteScreenshotGenerator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The call to `driver.get_screenshot_as_png()` does the heavy lifting.  It renders
    the page to a PNG format image and returns the bytes of the image.  This data
    is then converted into a Pillow Image object.
  prefs: []
  type: TYPE_NORMAL
- en: Note in the output that the height of the image returned from webdriver is 7416
    pixels, and not 500 as we specified.  The PhantomJS renderer will attempt to handle
    infinitely scrolling web sites, and generally won't constrain the screenshot to
    the height given to the window.
  prefs: []
  type: TYPE_NORMAL
- en: To actually make the screenshot the specified height, set the crop parameter
    to `True` (the default).  Then this code will use the crop method of the Pillow
    Image to set the desired height.  If you run this code with `crop=False`, then
    the result would be an image 7416 pixels in height.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a screenshot of a website with an external service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe used selenium, webdriver, and PhantomJS to create the screenshot.
     This obviously requires having those packages installed.  If you don't want to
    install those and still want to make website screenshots, then you can use one
    of a number of web services that can take screenshots.  In this recipe, we will
    use the service at [www.screenshotapi.io](http://www.screenshotapi.io) to create
    a screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, head over to `www.screenshotapi.io` and sign up for a free account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ec4f1644-7736-4e42-ad3f-6f1b12bf1cc0.png)Screenshot of the free
    account sign up'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your account is created, proceed to get an API key.  This will be needed
    to authenticate against their service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4834f589-e457-4f33-aac9-c809451b33c5.png)The API Key'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The script for this example is `04/09_screenshotapi.py`.  Give this a run and
    it will make a screenshot.  The code is the following, and is very similar to
    the previous recipe in structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The functional difference to the previous recipe is that we used a different
    `WebsiteScreenshotGenerator` implementation.  This one comes from the `core.website_screenshot_with_screenshotapi`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'When run, the following will output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And gives us the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e8e5801-80c3-4d34-a228-f6633af08c75.png)The Website Screenshot
    from screenshotapi.io'
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the code of this `WebsiteScreenshotGenerator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `screenshotapi.io` API is a REST API.  There are two different endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://api.screenshotapi.io/capture](https://api.screenshotapi.io/capture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://api.screenshotapi.io/retrieve](https://api.screenshotapi.io/retrieve)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first endpoint is called and passes the URL and other parameters to their
    service.  Upon successful execution, this API returns a key that can be used on
    the other endpoint to retrieve the image.  The screenshot is performed asyncronously,
    and we need to continually call the `retrieve` API using the key returned from
    the capture endpoint.  This endpoint will return a status value of `ready` when
    the screenshot is complete.  The code simply loops until this is set, an error
    occurs, or the code times out.
  prefs: []
  type: TYPE_NORMAL
- en: When the snapshot is available, the API returns a URL to the image in the `retrieve`
    response.  The code then retrieves this image and constructs a Pillow Image object
    from the received data.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `screenshotapi.io` API has many useful parameters.  Several of these allow
    you to adjust which browser engine to use (Firefox, Chrome, or PhantomJS), device
    emulation, and whether or not to execute JavaScript in the web page.  For more
    details on these options and the API, go to [http://docs.screenshotapi.io/rest-api/](http://docs.screenshotapi.io/rest-api/).
  prefs: []
  type: TYPE_NORMAL
- en: Performing OCR on an image with pytesseract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to extract text from within images using the pytesseract library.
     In this recipe, we will use pytesseract to extract text from an image. Tesseract
    is an open source OCR library sponsored by Google.  The source is available here: [https://github.com/tesseract-ocr/tesseract](https://github.com/tesseract-ocr/tesseract),
    and you can also find more information on the library there. 0;pytesseract is
    a thin python wrapper that provides a pythonic API to the executable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make sure you have pytesseract installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to install tesseract-ocr.  On Windows, there is an executable
    installer, which you can get here: `https://github.com/tesseract-ocr/tesseract/wiki/4.0-with-LSTM#400-alpha-for-windows`.
     On a Linux system, you can use `apt-get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest means of installation on a Mac is using brew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The code for this recipe is in `04/10_perform_ocr.py`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the script for the recipe.  The script is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The image that will be processed is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1ede956f-a997-4723-8f79-39bdd0d1d30f.png)The Image we will OCR'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the script gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The image is first loaded as a Pillow Image object.  We can directly pass this
    object to the pytesseract `image_to_string()` function.  That function runs tesseract
    on the image and returns the text that it found.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary purposes for using OCR in a scraping application is in the
    solving of text-based captchas.  We won't get into captcha solutions as they can
    be cumbersome and are also documented in other Packt titles.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Video Thumbnail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might want to create a thumbnail for a video that you downloaded from a
    website. These could be used on a page that shows a number of video thumbnails
    and lets you click on them to watch the specific video.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This sample will use a tool known as ffmpeg.  ffmpeg is available at www.ffmpeg.org. 
    Download and install as per the instructions for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example script is in `04/11_create_video_thumbnail.py`.  It consists of
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When run you will see output from ffmpeg:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output JPG file will be the following JPG image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c9568a21-3200-4c2b-ad42-12ad7f7b92e4.jpg)The Thumbnail Created from
    the Video'
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `.ffmpeg` file is actually an executable. The code executes the following
    ffmpeg command as a sub process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The input file is `BigBuckBunny.mp4`.  The `-ss` option informs where we want
    to examine the video.  `-frames:v` states that we want to extract one frame. 
    Finally we tell `ffmpeg` to write that frame to `thumbnail.jpg` (and `-y` confirms
    overwriting an existing file).
  prefs: []
  type: TYPE_NORMAL
- en: There's more..
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ffmpeg is an incredibly versatile and power tool.  A scraper I once created
    would crawl and find media (actually, commercials played on websites), and store
    them in a digital archive.  The scraper would then send a message through a message
    queue that would be picked up by a farm of servers whose only job was to run ffmpeg
    to convert the video into many different formats, bit rates, and also create thumbnails.
    From that point, more messages would be sent to auditor to use a front end application
    to check the content for compliance to advertising contract terms.  Get to know
    ffmeg, it is a great tool.
  prefs: []
  type: TYPE_NORMAL
- en: Ripping an MP4 video to an MP3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's examine how to rip the audio from an MP4 video into an MP3 file. 
    The reasons you may want to do this include wanting to take the audio of the video
    with you (perhaps it's a music video), or you are building a scraper / media collection
    system that also requires the audio separate from the video.
  prefs: []
  type: TYPE_NORMAL
- en: This task can be accomplished using the `moviepy`  library.  `moviepy` is a
    neat library that lets you do all kinds of fun processing on your videos.  One
    of those capabilities is to extract the audio as an MP3.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make sure that you have moviepy installed in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We also need to have ffmpeg installed, which we used in the previous recipe,
    so you should be good to go with this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code to demonstrate ripping to MP3 is in `04/12_rip_mp3_from_mp4.py`. `moviepy` 
    makes this process incredibly easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rips the MP4 downloaded in the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this, you will see output, such as the following, as the file
    is ripped. This only took a few seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When complete, you will have an MP3 file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more info on moviepy, check out the project site at[ http://zulko.github.io/moviepy/](http://zulko.github.io/moviepy/).
  prefs: []
  type: TYPE_NORMAL
