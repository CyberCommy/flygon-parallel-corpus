- en: Chapter 2. Using the Functional Constructions of Java 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is not a new idea; actually, it's pretty old. For example,
    **Lisp**, which is a functional language, is the second oldest of today's commonly-used
    programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programs are built using small pieces of reusable pure functions
    (lambdas). The program logic is composed of small declarative steps and not complex
    algorithms. That's because functional programs minimize the use of state, which
    makes imperative programs complex and hard to refactor/support.
  prefs: []
  type: TYPE_NORMAL
- en: With Java 8, the Java world got the lambda expressions and the ability to pass
    functions to functions. With them, we can code in a more functional style and
    get rid of a lot of the boilerplate code. The other new thing we got with Java
    8 is the streams—something very similar to RxJava's observables but not asynchronous.
    Combining these streams and the lambdas, we are able to create more functional-like
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to familiarize ourselves with these new constructions and look
    at how they can be used with RxJava's abstractions. Our programs will be simpler
    and easier to follow by using the lambdas, and the concepts introduced in this
    chapter will be of help while designing applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas in Java 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First RxJava examples using the lambda syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What pure functions and higher order functions are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambdas in Java 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important change in Java 8 is the introduction of lambda expressions.
    They enable faster, clearer coding and make it possible to use functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Java was created back in the '90s as an object-oriented programming language,
    with the idea that everything should be an object. At that time, object-oriented
    programming was the principal paradigm for software development. But, recently,
    functional programming has become increasingly popular because it is well-suited
    for concurrent and event-driven programming. This doesn't mean that we should
    stop writing code using object-oriented languages. Instead, the best strategy
    is to mix elements of object-oriented and functional programming. Adding lambdas
    to Java 8 ties in with this idea—Java is an object-oriented language, but now
    it has lambdas, we are able to code using the functional style too.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at this new feature in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the new syntax and semantics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to introduce lambda expressions, we need to see their actual value.
    This is why this chapter will begin with one example implemented without using
    lambda expressions, followed by re-implementing the same example using lambda
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the `map(Func1)` method from the `Observable` class? Let's try to implement
    something similar for the `java.util.List` collections. Of course, Java doesn't
    support adding methods to existing classes, so the implementation will be a static
    method that takes a list and transformation and returns a new list containing
    the transformed elements. In order to pass a transformation to the method, we'll
    need an interface with one method representing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is happening here?
  prefs: []
  type: TYPE_NORMAL
- en: We define a generic interface, called `Mapper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has only one method, `M map(V)`, that receives a value of type `V` and transforms
    it to a value of type `M`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The static method `List<M> map(List<V>, Mapper<V, M>)` takes one list with elements
    of type `V` and a `Mapper` implementation. Using this `Mapper` implementation's
    `map()` method on every element of the source list, it converts the list to a
    new list of type `M` containing the transformed elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The implementation creates a new empty list of type `M` with the same size as
    the source list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every element in the source list is transformed using the passed `Mapper` implementation
    and added to the new list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new list is returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this implementation, every time we want to create a new list by transforming
    another, we will have to implement the `Mapper` interface with the right transformation.
    Until Java 8, the right way of passing custom logic to methods was exactly like
    this—with anonymous class instances, implementing the given methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s look at how we use this `List<M> map(List<V>, Mapper<V, M>)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In order to apply a mapping to a list, we need to write four lines of boilerplate
    code. The actual mapping is very simple and is only one of these lines. The real
    problem here is that instead of passing an action, we are passing an object. This
    obscures the real intention of this program—to pass an action that produces transformation
    from every item of the source list and to get a list with applied changes at the
    end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what this call looks like using the new lambda syntax of Java 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Pretty straight forward, isn't it? And it just works. Instead of passing an
    object and implementing an interface, we pass a block of code, a nameless function.
  prefs: []
  type: TYPE_NORMAL
- en: What is going on? We defined an arbitrary interface with an arbitrary method,
    but we could pass this lambda in place of an instance of the interface. In Java
    8, if you define *interface with only one abstract method* and you create a method
    that receives a parameter of this type of interface, you can pass a lambda instead.
    If the interface single method takes two arguments of type string and returns
    an integer value, the lambda will have to be composed of two arguments before
    the `->` and to return integer, the arguments will be inferred as strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces of this type are called **functional interfaces.** It is important
    for the single method to be abstract and not default. Another new thing in Java
    8 is the default methods of interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The default methods are useful when changing already existing interfaces. When
    we add default methods to them, the classes implementing them won't break. An
    interface with only one default method is not functional; a single method shouldn't
    be default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambdas act as implementations of the functional interfaces. So, it is possible
    to assign them to variables of type interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And we can reuse the square object as it's an implementation of the `Mapper`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe you''ve noticed, but in the examples up until now, the parameters of
    lambda expressions have no type. That is because the types are inferred. So this
    expression is absolutely the same as the preceding expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The fact that the example with a parameter without a type works is not magic.
    Java is a statically typed language, so the parameter of the single method of
    the functional interface is used for type checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about the body of the lambda expression? There is no `return` statement
    anywhere. It turns out that these two examples are exactly the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first expression is just a short form of the second. It is preferred for
    the lambda to be only one line of code. But if the lambda expression contains
    more than one line, the only way to define it is using the second approach, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, lambda expressions are not just syntax sugar for anonymous inner
    classes. They are implemented to perform quickly inside the **Java Virtual Machine**
    (**JVM**), so if your code is designed to be compatible only with Java 8+, you
    should definitely use them. Their main idea is to pass around behavior in the
    same way that data is passed. This makes your program more human readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing related to the new syntax is the ability to pass to methods
    and assign to variables already defined functions and methods. Let''s define a
    new functional interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it to execute arbitrary actions for each value in a list; for example,
    logging the list. Here is a method that uses this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is similar to the `map()` function. It iterates through the list
    and calls the passed action''s `act()` method on every element. Let''s call it
    using a lambda that simply logs the elements in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite simple but not necessary because the `println()` method can be
    passed itself to the `act()` method. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code for these examples can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/Java8LambdasSyntaxIntroduction.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/Java8LambdasSyntaxIntroduction.java).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is valid syntax in Java 8—every method can become a lambda and can be
    assigned to a variable or passed to a method. All these are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: Book::makeBook // Static method of a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: book::read // method of an instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Book::new // Constructor of a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Book::read // instance method, but referenced without using an actual instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've revealed the lambda syntax, we will be using it in our RxJava
    examples instead of anonymous inner classes.
  prefs: []
  type: TYPE_NORMAL
- en: Functional interfaces in Java 8 and RxJava
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java 8 comes with a special package containing functional interfaces for common
    cases. This package is `java.util.function`, and we are not going to look at it
    in detail in this book, but will present some of them that are worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Consumer<T>`: This represents a function that accepts an argument and returns
    nothing. Its abstract method is `void accept(T)`. As an example, we can use it
    to assign the `System.out::println` method to a variable, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Function<T,R>`: This represents a function that accepts one argument of a
    given type and returns a result of an arbitrary type. Its abstract method is `R
    accept(T)`, and it can be used for mapping. We don''t need the `Mapper` interface
    at all! Let''s take a look at the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`Predicate<T>`: This stands for a function with only one argument that returns
    a Boolean result. Its abstract method is `boolean test(T)` and it can be used
    for filtering. Let''s take a look at the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of functional interfaces similar to these; for example, a function
    with two arguments, or a binary operator. This is again a function with two arguments,
    but both of the same type and returning a result with the same type. They are
    there to help reuse lambdas in our code.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing is that RxJava is lambda compatible. This means that the actions
    we were passing to the `subscribe` method are in fact functional interfaces!
  prefs: []
  type: TYPE_NORMAL
- en: RxJava's functional interfaces are in the `rx.functions` package. All of them
    extend a base **marker** **interface** (interface with no methods, used for type
    checking), called `Function`. Additionally, there is another marker interface,
    extending the `Function` one, called `Action`. It is used to mark consumers (functions,
    returning nothing).
  prefs: []
  type: TYPE_NORMAL
- en: 'RxJava has eleven `Action` interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: They can be used mainly for subscriptions (`Action1` and `Action0`). The `Observable.OnSubscribe<T>`
    parameter, which we saw in [Chapter 1](ch01.html "Chapter 1. An Introduction to
    Reactive Programming"), *An Introduction to Reactive Programming*, (used for creating
    custom observables) extends the `Action` interface too.
  prefs: []
  type: TYPE_NORMAL
- en: Analogically, there are eleven `Function` extenders representing function returning
    result. They are `Func0<R>`, `Func1<T1, R>` … `Func9<T1,T2,T3,T4,T5,T6,T7,T8,T9,R>`,
    and `FuncN<R>`. They are used for mapping, filtering, combining, and many other
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Every operator and subscribe method in RxJava is applicable to one or more of
    these interfaces. This means that we can use lambda expressions instead of anonymous
    inner classes in RxJava almost everywhere. From this point on, all our examples
    will use lambdas in order to be more readable and somewhat functional.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at one big RxJava example implemented with lambdas. This is
    our familiar Reactive Sum example!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the reactive sum example with lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So this time, our main piece of code will be quite similar to the previous
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that we are going to take a more functional approach
    in calculating our sum and not to keep the same state. We won't be implementing
    the `Observer` interface; instead, we are going to pass lambdas to subscribe.
    This solution is much cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CreateObservable.from(InputStream)` method is a lot like we used previously.
    We will skip it and look at the `Observable<Double> varStream(String, Observable<String>)`
    method, which creates the `Observable` instances representing the collectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is much shorter than used previously and looks simpler. But semantically,
    it is the same. It creates an `Observable` instance connected to a source observable
    producing arbitrary strings, and if a string is in the format it expects, it extracts
    a double number from it and emits this number. The logic responsible for checking
    the format of the input and extracting the number is only four lines and is represented
    by simple lambdas. Let''s examine it:'
  prefs: []
  type: TYPE_NORMAL
- en: We map a lambda that creates a `matcher` instance using the pattern expected
    and the input string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `filter()` method, only the input that is in the right format is filtered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a `map()` operator, we create a string from the `matcher` instance, which
    contains only the number data we need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And again with the `map()` operator, the string is turned into a double number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And as for the new `void reactiveSum(Observable<Double>, Observable<Double>)`
    method''s implementation, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we use the `combineLatest()` method, but this time the third argument
    is a simple lambda that implements a sum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `subscribe()` method takes three lambda expressions that are triggered
    when the following events occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sum changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program is about to finish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source of this example can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/ReactiveSumV2.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/ReactiveSumV2.java).
  prefs: []
  type: TYPE_NORMAL
- en: Everything becomes simpler using lambdas. Looking at the preceding program,
    we can see that most of the logic is composed of small, independent functions,
    chained using other functions. This is what we mean by being functional, to express
    our programs using such small reusable functions that take other functions and
    return functions and data abstractions, which transform input data using chains
    of functions in order to produce the wanted result. But let's look at these functions
    in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions and higher order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don't have to remember most of the terms introduced in this chapter; the
    important thing is to understand how they help us write simplistic but powerful
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: RxJava's approach has many functional ideas incorporated, so it is important
    for us to learn how to think in more functional ways in order to write better
    reactive applications.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **pure function** is a function whose return value is only determined by
    its input, without observable **side effects**. If we call it with the same parameters
    *n* times, we are going to get the same result every single time. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Each time, the even function returns `False` because it *depends only on its
    input*, which is the same each time and is not even.
  prefs: []
  type: TYPE_NORMAL
- en: This property of pure functions is called **idempotence**. Idempotent functions
    don't depend on time, so they can treat continuous data as infinite data streams.
    And this is how ever-changing data is represented in RxJava (`Observable` instances).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that, here, the term "idempotence" is used in its computer science meaning.
    In computing, an idempotent operation is one that has no additional effect if
    it is called more than once with the same input parameters; in mathematics, an
    idempotent operation is one that satisfies this expression: *f(f(x)) = f(x)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pure functions *do not cause side-effects*. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is not pure because it prints on the output a message every time
    it is called. So it does two things: it tests whether the number is even, and
    it outputs a message as a side-effect. A side-effect is any possible observable
    output the function can produce, for example, triggering events and throwing exceptions
    and I/O, different from its return value. A side-effect also changes shared states
    or mutable arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Think about it. If most of your program is composed of pure functions, it will
    be easy to scale and to run parts of it in parallel because pure functions can't
    conflict with each other and don't change the shared state.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that's worth mentioning in this section is **immutability**. Immutable
    objects are objects that can not change their state. A good example is the `String`
    class in Java. The `String` instances cannot be changed; even methods such as
    `substring` create a new instance of `String` without modifying the calling one.
  prefs: []
  type: TYPE_NORMAL
- en: If we pass immutable data to a pure function, we can be sure that every time
    it is called with this data it will return the same. With **mutable** objects,
    is not quite the same when we write parallel programs, because one thread can
    change the object's state. In this case, the pure function will return a different
    result if called, and thus will stop being idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: If we store our data in immutable objects and operate over it using pure functions,
    creating new immutable objects in the process, we will be safe from unexpected
    concurrency issues. There will be no global state and no mutable state; everything
    will be simple and predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Using immutable objects is tricky; every action with them creates new instances,
    and this could eat up memory. But there are methods for avoiding that; for example,
    reusing as much as we can from the source immutable, or making the immutable objects'
    lifecycles as short as possible (because short lifecycle objects are friendly
    to GC or caching). Functional programs should be designed to work with immutable
    stateless data.
  prefs: []
  type: TYPE_NORMAL
- en: Complex programs can't be composed only of pure functions, but whenever it is
    possible, it is good to use them. In this chapter's implementation of *The Reactive
    Sum*, we passed to `map()`, `filter()`, and `combineLatest()` only pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of the `map()` and `filter()` functions, we call them higher order
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Higher order functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function with at least one parameter of type function or a function that returns
    functions is called a **higher order function**. Of course, *higher order functions
    can be pure*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a higher function that takes function parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes two functions of type `T -> int/R -> int` and some data in order to
    call them and sum their results. For example, we can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we sum the square of three and the cube of two.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the idea of higher order functions is to be flexible. For example, we can
    use the `highSum()` function for a completely different purpose, say, summing
    strings, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, a higher order function can be used to apply the same behavior to different
    kinds of input.
  prefs: []
  type: TYPE_NORMAL
- en: If the first two arguments we pass to the `highSum()` function are pure functions,
    it will be a pure function as well. The `strToInt` parameter is a pure function,
    and if we call the `highSum(strToInt, strToInt, "4", "5")` method *n* times, it
    will return the same result and won't have side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of a higher order function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a function that returns another function. It can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code for this example can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/PureAndHigherOrderFunctions.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/PureAndHigherOrderFunctions.java).
  prefs: []
  type: TYPE_NORMAL
- en: Functions like these can be used to implement different behaviors that have
    something in common. In object-oriented programming we define classes and then
    extend them, overloading their methods. In functional programming, we define higher
    order functions as interfaces and call them with different parameters, resulting
    in different behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: These functions are *first-class citizens*; we can code our logic using only
    functions, chaining them, and handling our data, transforming, filtering, or accumulating
    it into a result.
  prefs: []
  type: TYPE_NORMAL
- en: RxJava and functional programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functional concepts such as pure functions and higher order functions are very
    important to RxJava. RxJava''s `Observable` class is an implementation of a *fluent
    interface*. This means that most of its instance methods return an `Observable`
    instance. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `map()` operator returns a new `Observable` instance, emitting the data
    transformed by it. Operators such as `map()` are clearly higher order functions,
    and we can pass other functions to them. So, a typical RxJava program is represented
    by a chain of operators chained to an `Observable` instance to which multiple
    *subscribers* can subscribe. These functions chained together can benefit from
    the topics covered in this chapter. We can pass lambdas to them instead of anonymous
    interface implementations (as we saw with the second implementation of the *Reactive
    Sum*), and we should try working with immutable data and pure functions when possible.
    This way, our code will be simple and safe.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've looked at some of the functional programming principles
    and terms. We've learned how to write programs composed of small pure function
    actions, chained together using higher order functions.
  prefs: []
  type: TYPE_NORMAL
- en: As functional programming is getting increasingly popular, developers proficient
    in it will be in high demand in the very near future. That's because it helps
    us achieve scalability and parallelism with ease. And what is more, if we add
    the reactive idea to it, it becomes even more appealing.
  prefs: []
  type: TYPE_NORMAL
- en: That's why we are going to dive into the RxJava framework in the next chapters,
    learning how to use it for our benefit. We'll begin with the `Observable` instance
    creation techniques. This will provide us with the skill to create an `Observable`
    instance from everything, thus turning almost everything into a functional reactive
    program.
  prefs: []
  type: TYPE_NORMAL
