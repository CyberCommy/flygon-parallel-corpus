- en: Real-Time Web Apps with Socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you're going to learn about Socket.io and WebSockets, which
    enable two-way communication between the server and the client. This means that
    we're not only going to be setting up a Node server, but also a client. This client
    could be a web app, an iPhone app, or an Android app. For this book, the client
    will be a web app. This means that we're going to be connecting the two, allowing
    data to flow seamlessly from the browser to the server and from the server to
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our todo app data can only flow in one direction, and the client has to
    initialize the request. With Socket.io, we're going to be able to send data back
    and forth instantly. This means that for real-time apps, such as an email app,
    a food ordering app, or a chat app, the server doesn't need to wait for the client
    to request information; the server can say, "*Hey, I just got something you probably
    want to show the user, so here it is!"* This is going to open up a world of possibilities,
    and we're going to get started by figuring out how to integrate Socket.io into
    a Node app. Let's dive in!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new web app project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can add sockets to your web application, you need a web application
    to add them to, which is exactly what we'll create in this section. We'll make
    a basic Express app, which we'll get up on GitHub. Then, we'll deploy it to Heroku
    so we can view it live in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the first step to that process is going to be to making a directory. We'll
    do a few things together to get us all going in the right direction. The first
    step in the process from the desktop is to run `mkdir` to make a new directory
    for this project; I'm going to call it `node-chat-app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can use `cd` to navigate into that directory and we can run a few
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First up, `npm init`. As with all of our projects in this book, we''ll be taking
    advantage of npm, so we''ll run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3dcad9af-d069-4002-b47d-e98cd23bfa61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we''ll use the *e**nter* key to use the default value for every option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dabdb017-99da-4bf2-800a-b2519d8a7417.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we''re done, we can type `yes`, and now we have a `package.json` file.
    Before we move into Atom, we''ll run the following command to initialize a new
    Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We'll be putting this project under version control using Git, and we'll also
    use Git to push to GitHub and Heroku. With this in place, I can use the `clear`
    command to clear the Terminal output, and we can move into Atom. We'll start by
    opening up the folder and setting up our basic app structure.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our basic app structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up the basic app structure, I''m going to open up the folder that we
    just created on the desktop, called `node-chat-app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bc28905-c257-4137-82d4-d9090f43789b.png)'
  prefs: []
  type: TYPE_IMG
- en: In this folder, we'll get started by making a couple of directories. Now, unlike
    the other apps in the previous chapters, the chat app is going to have a frontend,
    which means we'll be writing some HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also add some styles and writing some JavaScript code that runs in the
    browser, as opposed to running on the server. For this to work, we''ll have two
    folders:'
  prefs: []
  type: TYPE_NORMAL
- en: One will be called `server`, which will store our Node.js code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other one will be called `public`, which will store our styles, our HTML
    files, and our client-side JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, inside `server`, just like we did for the todo API, we''ll have a `server.js`
    file, which is going to be the root of our Node application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbbb2aaf-1b53-4a38-8063-01926870b587.png)'
  prefs: []
  type: TYPE_IMG
- en: This file will do stuff like create a new Express app, configure the public
    directory to be the static folder Express serves up, and call `app.listen` to
    start up the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `public`, what we''ll do for this section is create just one file, called
    `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5682799-13ac-4176-8ec6-50e206eaf810.png)'
  prefs: []
  type: TYPE_IMG
- en: The `index.html` file will be the markup page we serve when someone visits the
    app. For now, we'll make a really simple one that just prints a message to the
    screen so we can confirm it's getting served up properly. In the next section,
    we'll worry about integrating Socket.io on the client.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the index.html file for DOCTYPE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For now though, in our `index.html` file, we''ll provide `DOCTYPE` so the browser
    knows which version of HTML we want to use. We tell it to use HTML which refers
    to HTML5\. Next up, we''ll open and close our `html` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This tag is going to let us provide the `head` and `body` tags, which are exactly
    what we''ll need to get things working:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First up is `head`. Inside `head`, we can provide various configuration tags.
    We''ll use just one for now, `meta`, so we can tell the browser which `charset`
    we want to use. In the `meta` tag, we''ll provide the `charset` attribute, setting
    it equal to `utf-8` inside quotes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll provide the `body` tag inside `html`. This contains the HTML
    we want to actually render to the screen, and what we''ll do for this one is render
    a `p` tag, which is for a paragraph, and we''ll have some simple text like `Welcome
    to the chat app`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is all that's going to show up for the moment. Now, we can move outside
    the `html` file, going back into the `server` file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the server.js file for the public directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our `server` file, we want to set up this server to serve up the `public`
    folder. Now, in this case, the `server.js` file is not in the root of the project,
    which means we have to go up a directory from `server` to `node-chat-app`. Then,
    we have to go into the `public` folder. This will make it a little hard to set
    up the Express middleware. What we'll do is take a look at a built-in Node module
    that makes it really easy to convert paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to show you what I''m talking about, let''s go ahead and use
    two `console.log` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first `console.log` call will show us how we used to do it, and the second
    one will show us the better way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the first `console.log` call, we''ll provide the same path we provided
    for our very first Express app. We use `__dirname` to reference the current directory,
    which in this case is the `server` directory because the file is inside the `server`
    folder. Then, we concatenate it, `/public`. Now, in this case, we do not have
    a `public` folder in the `server` folder; the `public` folder and the `server`
    folder are at the exact same level, which means we need to use `..` to go up a
    directory and then we need to go into `public`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the old way of doing things, and if we run this from the Terminal,
    we can see why it looks a little weird. I''m going to run `server/server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'What we get is this path, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27dff985-7df2-4295-a4ec-776fadd70a3b.png)'
  prefs: []
  type: TYPE_IMG
- en: We go into the `Users/Andrew/Desktop/` project folder, which is expected, then
    we go into `server`, out of `server`, and into `public`—this is absolutely unnecessary.
    What we'd like to do is just go from the `project` folder right into `public`,
    keeping a clean, cross-OS compatible path. In order to do that, we'll use a module
    that comes with Node called `path`.
  prefs: []
  type: TYPE_NORMAL
- en: The join method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s see the documentation of `path`, because `path` has plenty of methods
    that we won''t be using in this section. We''ll go to [nodejs.org](https://nodejs.org/en/),
    where we can find the Docs tab. We''ll go to the Docs page and then the API reference page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2a281b3-95b3-48da-9a15-8d521be5707e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a list of all the modules we have available to us. We''re using the
    Path module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0dbc7a1-cd59-472b-b676-d0b85daa536b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside Path, the method we''ll use is `join`, which you can see in the preceding
    screenshot. If you click on this method, you can go to a little example of how
    `join` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bd530c8-7f9f-497f-adc5-10780bf142e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `join` method takes your partial paths and joins them together, which means
    the example shown in the preceding screenshot results in the simpler path. In
    this example, we can see that we start with `foo`. We then go into `bar`, which
    also shows up; we then go into `baz/asdf`, which does indeed show up. The next
    part is the interesting part: we go into the `quux` directory, then we go out
    using `..`, and you can see the result path doesn''t show us going into and out
    of, like our path does inside the Terminal; instead, it resolves that into the
    final path, where the `quux` directory is nowhere in sight.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use this exact same method to clean up our path. Inside Atom, we can
    load in the `path` module by creating a constant called `path` and requiring it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, this one does not need to be installed: it is a built-in module,
    and you have access to it without using `npm`. Next up, we''ll make a variable
    called `publicPath`. I''ll make that a constant variable, since we''ll be making
    any changes to it, and we''ll call `path.join`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll pass some arguments into `path.join` in a moment. Before we do, though,
    I''m going to call `console.log(publicPath)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside `path.join`, what we want to do is take the two paths, `__dirname`
    and `''/../public''`, and pass them in as separate arguments. We do still want
    to start in the `server` folder of the `dirname` directory. Then, as the second
    argument, we''ll specify the relative path inside quotes. We''ll go out of the
    directory using `..` then use a forward slash to go into the `public` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll save the `server` file, and we should now be able to go back to the Terminal
    and see our new path—and here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99ebfc25-831e-4d61-9f80-4368ac0118f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Instead of going into `server` and then going out, we go right into the `public`
    directory, which is ideal. This is the path we want to provide to the Express
    static middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this `public` path variable in place, let''s set up Express
    locally. Before we get into that, we will install it using `npm i`. The module
    name is `express`, and we''ll use the most recent version, `@4.16.3`, with the
    `--save` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We'll run the installer, and then we can go ahead and actually use it inside
    `server.js`. In `package.json`, we now have it sitting in the dependencies object.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring basic server setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the Express installer in place, you'll create a brand new Express application
    and configure the Express static middleware, as we've done previously to serve
    up the `public` folder. Finally, you'll call `app.listen` on port `3000`. You'll
    provide one of those little callback functions to print a message to the Terminal,
    such as `server is up on port 3000`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the server created, you'll start it up inside the Terminal and
    head to `localhost:3000` inside the browser. If we go there right now we'll get
    an error, because there is no server running on that port. You should be able
    to refresh this page and see the little message we typed in the paragraph tag
    over inside `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing I''ll do is inside `server.js`, load in Express by creating
    a constant called `express` and requiring the library we just installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, you need to make an `app` variable where we can configure our Express
    application. I''ll make a variable called `app` and set it equal to a call to
    `express`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Remember, we don't configure Express by passing in arguments; instead, we configure
    Express by calling methods on `app` to create routes, add middleware, or start
    up the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, we''ll call `app.use` to configure our Express static middleware.
    This will serve up that `public` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'What you need to do is call `express.static` and pass in the path. We create
    a `publicPath` variable, which stores exactly the path we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The last thing to do is call `app.listen`. This will start up the server on
    port `3000`, and we'll provide a callback function as the second argument to print
    a little message to the Terminal once the server is up.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll use `console.log` to print `Server is up on port 3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can now start up the server inside the Terminal and
    make sure our `index.html` file shows up in the browser. I''ll go ahead and use
    the `clear` command to clear the Terminal output, then I''ll use `nodemon` to
    run the server, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9bb3fd9a-ba44-4ffe-b697-a53787f26ac9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we get our little message, `Server is up on port 3000`. In the browser,
    if I give things a refresh, we get our markup, `Welcome to the chat app`, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/702468dc-5328-47a3-a420-2ea2ee480034.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have a basic server set up, which means in the next section, we can actually
    add Socket.io on both the client and the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a gitignore file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, before we start getting things on GitHub and Heroku, we'll first set up
    a few things inside Atom. We need to set up a `.gitignore` file, which we'll provide
    in the root of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `.gitignore`, the only thing we'll be ignoring is the `node_modules`
    folder. We do not want to commit any of this code to our repo, because it can
    be generated using `npm install` and it's subject to change. It's a real pain
    to manage that sort of thing, and it is not recommended that you commit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we''ll do is configure a few things for Heroku. First up, we
    have to use the `process.env.PORT` environment variable. I''ll create a constant
    called `port` next to the `publicPath` variable, setting it equal to `process.env.PORT`
    or `3000`. We''ll use it locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can provide `port` in `app.listen`, and we can provide it in the following
    message by changing our regular string to a template string to get `Server is
    up on`. I''ll inject the `port` variable value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have that in place, the next thing we need to change in order to
    get our app set up for Heroku is update the `package.json` file, adding a `start`
    script and specifying the version of Node we want to use. Under `scripts`, I''ll
    add a `start` script telling Heroku how to start the application. In order to
    start the app, you have to run the `node` command. You''ll have to go into the
    `server` directory, and the file to start it up is `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re also going to specify `engines`, which we''ve done before. `engines`,
    as you know, lets you tell Heroku which version of Node to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be important as we are taking advantage of some features only available
    in the latest versions of Node. Inside `engines`, I''ll provide the exact same
    key-value pair I used previously, setting `node` equal to `9.3.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you're using a different version of Node, you can provide that instead of
    the version I have added here.
  prefs: []
  type: TYPE_NORMAL
- en: Making a commit with the current uncommitted files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have this in place, you are ready to make a commit with all of the
    current uncommitted files. You'll then go into GitHub and create a GitHub repository,
    where you'll push your local code up. Make sure the code actually gets on GitHub;
    you can do that by refreshing the GitHub repo page. You should see your directory
    structure right there on the repo.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you need to do is create a Heroku application and deploy to it.
    Once your application is deployed, you should be able to visit the app URL on
    the browser. You should see the exact same message as the one we have in our `localhost:3000`.
    The `Welcome to the chat app` message should print, but instead of being on `localhost:3000`,
    you should be on the actual Heroku app.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have made all the changes necessary inside the project. We have configured
    the `port` variable and we have set up our `scripts` and `engines`, so you don't
    have to make any more code changes; you just need to work your wizardry in the
    browser and the Terminal to get this done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to make a new GitHub repository. We need a place to push
    up our code. We can head over to [github.com](https://github.com/), click on that
    big green New repository button, and make a new one. I''ll call my repository
    `node-course-2-chat-app`. I will leave this public and create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87bf2c14-1f24-4ab5-a821-3303b4b45b5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we''ve created the repository, we have a list of commands we can use.
    We have an existing repository we want to push, so we can copy these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcd2bf63-eb91-40ab-9345-388086661b42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Terminal, before we can actually push anything, we need to make a commit.
    I''ll shut down `nodemon` and run the `git status` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14707ad1-5052-4aa0-a9c6-a1748b736135.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you see we have our expected files, we have the `public` and `server`
    folders, we have `.gitignore`, and we have `package.json`. However, `node_modules`
    is nowhere in sight. Then, you need to use `git add .` to add these untracked
    files to the next commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `git status` command again, you can see everything does look
    good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3283a9cf-163b-497c-94ee-29e67d7b5699.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have four changes to be committed: four new files. I''ll run `git commit`
    with the `-m` flag to specify a message. The `-a` flag is not required, since
    all of the files are already added. In the quotes, `Init commit` will get the
    job done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have that commit in place, you can actually push it up to GitHub by
    running the two lines they gave you. I''ll run both of those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown here, it''s now up on GitHub. We can confirm that by refreshing the
    page, and instead of seeing the instructions, we see the files we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcdd497d-6a76-4a67-ac36-6221823c42f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next and last thing to do is get the app on Heroku. You don''t actually
    have to go to the Heroku web app to get that done; we can run `heroku create`
    inside the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fd758d2-3258-4a0d-a20b-9ca567cb4ef6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go ahead and create the application. We can use the following command
    to deploy the app. I''m going to go ahead and run that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take my local code and push it up to Heroku. Heroku will see that
    new code was pushed, so it will then go ahead and deploy it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/568ef626-d985-4ab6-8f63-36485be6b3e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once it''s up, we can use the `heroku open` command to open up the app URL
    on the browser. Alternatively, you can always grab the URL from the Terminal.
    I''ll copy the URL, shown in the preceding screenshot, head into the browser,
    and paste it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f19e93c-32d4-47f5-bc74-ca3e10e809e6.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, we should see our app. Welcome to the
    chat app shows up on the screen, and with this in place, we are done! We have
    a basic Express server, we have a backend and a frontend, it's up on GitHub, and
    it's up on Heroku!
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to move on to the next section, where we are actually going to
    start integrating Socket.io.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Socket.io to an app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a basic Express application up and running, in this section,
    you'll configure your server to allow for incoming WebSocket connections. This
    means the server will be able to accept connections and we'll be setting up the
    client to make the connections. Then, we'll have a persistent connection and we
    can send data back and forth, whether it's data from the server to the client,
    or data from the client to the server. That is the beauty of WebSockets—you can
    send data in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to set up WebSockets, we'll be using a library called Socket.io.
    Just like Express makes it really easy to set up an HTTP server, Socket.io makes
    it dead simple to set up a server that supports WebSockets and to create a frontend
    that communicates with the server. Socket.io has a backend and frontend library;
    we'll be using both to set up WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, inside the Terminal, let''s go ahead and install the most recent
    version of Socket.io using `npm i`. The module name is `socket.io`, and the most
    recent version at time of writing is `@2.0.4`. We''ll use the `--save` dev flag
    to update the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is in place, we can go ahead and make a few changes to our `server`
    file. First up, we''ll load in the library. I''ll make a constant called `socketIO` and
    set it equal to the `require` statement for the `socket.io` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we now need to integrate Socket.io into our existing web
    server. Currently, we use Express to make our web server. We create a new Express
    app, we configure our middleware, and we call `app.listen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, behind the scenes, Express is actually using a built-in Node module called
    `http` to create this server. We'll need to use `http` ourselves. We need to configure
    Express to work with `http`. Then, and only then, will we also be able to add
    Socket.io support.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a server using the http library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First up, we''ll load in the `http` module. So, let''s make a constant called
    `http`, which is a built-in Node module so there''s no need to install it. We
    can simply enter `require(''http'')`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we''ll create a server using this `http` library. Just below our
    `app` variable, let''s make a variable called `server`. We''ll call `http.createServer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you might not know it but you''re actually already using the `createServer`
    method behind the scenes. When you call `app.listen` on your Express app, it literally
    calls this exact same method, passing in the app as the argument for `createServer`.
    The `createServer` method takes a function. This function looks really similar
    to one of our Express callbacks, and it gets called with a request and a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as I mentioned, `http` is actually used behind the scenes for Express.
    It''s integrated so much so that you can actually just provide `app` as the argument,
    and we are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we integrate Socket.io, let''s go ahead and wrap up this change. We''ll
    use the HTTP server as opposed to the Express server, so instead of calling `app.listen`,
    we''ll call `server.listen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Once again, there's no need to change the arguments passed in the `server.listen`
    method—they're exactly the same and built really closely to each other, so the
    `server.listen` arguments are the same as the Express `app.listen` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this in place, we haven''t actually changed any app functionality.
    Our server is still going to work on port `3000`, but we''re still not going to
    have access to Socket.io. In the Terminal, I can prove this by clearing the Terminal
    output and starting up our server using `nodemon` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, I''ll load `localhost:3000` in the browser URL and see what I get back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0d7f5b6-0533-4639-a599-8444ed9366bc.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, we get our HTML, and Welcome to the chat
    app shows up. This means that our app is still working even though we're now using
    the HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the server to use Socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing that we'll do is configure the server to use Socket.io—that's
    the entire reason we made this change. Next to the `server` variable, we'll make
    a variable called `io`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll set it equal to a call to `socket.io` and pass in `server`, which we
    want to use with our WebSockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now we have access to that server via the `server` variable, so we'll pass it
    in as the first and only argument. Now, what we get back is our WebSockets server.
    On here, we can do anything we want in terms of emitting or listening to events.
    This is how we're going to communicate between the server and the client, and
    we'll talk more about that later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, our server is ready to go; we are ready to accept new connections.
    The problem is that we don't have any connections to accept. When we load our
    web page, we're not doing anything. We're not actually connecting to the server.
    We are going to need to manually run some JavaScript code to initiate that connection
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we integrated Socket.io with our server, we actually got access to
    a few cool things. First up, we got access to a route that accepts incoming connections,
    which means that we can now accept WebSocket connections. Plus, we got access
    to a JavaScript library, which makes it really easy to work with Socket.io on
    the client. This library is available at the following path: `localhost:3000/socket.io/socket.io.js`.
    If you load this JavaScript file in the browser, you can see it''s just a really
    long JavaScript library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99e7d630-174a-4fa3-a6ab-376abd26388d.png)'
  prefs: []
  type: TYPE_IMG
- en: This contains all of the code we'll need on the client to make the connection
    and to transfer data, whether it's from server to client or client to server.
  prefs: []
  type: TYPE_NORMAL
- en: What we'll do in order to make the connection from our HTML file is load this
    in. I'll go back to `localhost:3000`. Now, we can go ahead and move into Atom,
    opening up `index.html`, and near the bottom of the `body` tag, we'll add a `script`
    tag to load in the file we just pulled up in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, we''ll make the `script` tag itself, opening and closing it, and
    in order to load in an external file, we''ll use the `src` attribute to provide
    the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this path is relative to our server. It''s going to be `/socket.io/socket.io.js`,
    which is exactly as we typed it in the browser earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the `script` tag, we''re now loading in the library. On the browser,
    we have access to all sorts of methods available, thanks to the `socket` library.
    One of those methods is going to let us initiate a connection request, and that''s
    exactly what we''re going to do in the next line. Let''s add a second `script`
    tag. This time, instead of loading an external script, we''ll write some JavaScript
    right in the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add any JavaScript we like, and this JavaScript is going to run right
    after the Socket.io library loads. A little bit later on, we''ll be breaking this
    out into its own file—but for the moment, we can simply have our JavaScript code
    right inside our HTML file. We''re going to call `io`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`io` is a method available to us because we loaded in this library. It''s not
    native to the browser, and when we call it, we''re actually initiating the request.
    We''re making a request from the client to the server to open up a WebSocket and
    keep that connection open. Now, what we get back from `io` is really important;
    we''ll save that in a variable called `socket`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This creates our connection and stores the socket in a variable. This variable
    is critical to communicating; it's exactly what we need in order to listen for
    data from the server and send data to the server. Now that we have this in place,
    let's go ahead and save our HTML file. We'll move into the browser and open up
    Chrome Developer Tools.
  prefs: []
  type: TYPE_NORMAL
- en: Now regardless of what browser you use, whether it's IE, Safari, Firefox, or
    Chrome, you'll have access to a set of developer tools, which makes it really
    easy to debug and see what's going on behind the scenes in your web page. We'll
    be using the Chrome Developer Tools here to do a little debugging, I'd highly
    recommend using Chrome for the course just so you can follow along exactly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open up Developer tools, we go to Settings | More tools | Developer tools.
    You can also use the keyboard shortcut particular to your operating system. When
    you open Developer tools, you''re going to be greeted with an overwhelming set
    of options, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72f77d05-d85e-479b-beb7-f6b57fa68309.png)'
  prefs: []
  type: TYPE_IMG
- en: You're most likely brought to the Elements panel if you've never used Chrome
    Developer Tools before. The panel we're going to be using right now is the Network
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: The Network panel keeps track of all of the requests made by your web page.
    So, if I make a request for a JavaScript file, I'm going to see that in a nice
    list, as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to have to refresh the page in order to see the list of network
    requests; right here, we have five:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab69f98e-f2d1-4a7a-80a2-93731e25162a.png)'
  prefs: []
  type: TYPE_IMG
- en: The network request at the very top is the first one that was made, and the
    one at the very bottom is the last one that was made. The first one was for the
    `localhost:3000` page, which was for the HTML file that loads `Welcome to the
    chat app`. The second one is for that JavaScript file that we saw on the browser,
    which gives us the library and gives us access to calling that `io` method that
    starts the connection process. The next four are all related to starting up and
    maintaining that connection. With this in place, we now have that live connection
    between the client and the server, and we can start communicating whatever we
    want to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between the client and server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the communication could be anything at all. In this case, it comes in the
    form of an event. Events can be emitted from both the client and the server, and
    both the client and the server can listen for events. Let's talk about an event
    that might happen in an email app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an email app, the server might emit an event called `newEmail` when a new
    email comes in. The client is then going to listen for that event. When it fires,
    it will get the `newEmail` data and render the email to the screen below the other
    ones. The same thing could happen the other way: maybe the client wants to create
    a new email and send it to someone else. It will ask for the email address of
    the person and the contents of the message, and it''s then going to emit an event
    on the client that the server is going to listen for. So, this whole server/client
    relationship is entirely run via these events.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll create custom events for our specific application throughout this
    chapter; but for now, we're going to look at a couple of default built-in ones
    that let you keep track of new users and disconnecting users. This means we'll
    be able to do something like greet a user when they join our application.
  prefs: []
  type: TYPE_NORMAL
- en: The io.on method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to play around with this inside Atom, in `server.js`, we are going
    to call a method on `io` called `io.on`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `io.on` method lets you register an event listener. We can listen for a
    specific event and do something when that event happens. One built-in event that
    we''re going to use—the most popular one—is called `connection`. This lets you
    listen for a new connection of a client to the server, and lets you do something
    when that connection comes in. In order to do something, you provide a callback
    function as the second argument, and this callback function is going to get called
    with a `socket`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This `socket` argument is really similar to the `socket` argument we have access
    to inside the `index.html` file. This represents the individual socket, as opposed
    to all of the users connected to the server. Now, with this in place, we can do
    whatever we like. For example, I could use `console.log` to print a little message,
    such as `New user connected`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time a user connects to our app, we''ll print a message to the console.
    I''ll go ahead and save the `server.js` file, move into the Terminal, and you''ll
    see that the message actually already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d65ffe25-41a2-4158-b4ac-3590bf86d903.png)'
  prefs: []
  type: TYPE_IMG
- en: To explain why, we need to understand one thing about WebSockets. WebSockets,
    as I mentioned, are a persistent technology, meaning that the client and server
    both keep the communication channel open for as long as either of them want to.
    If the server shuts down, the client doesn't really have a choice, and vice versa.
    If I close a browser tab, the server cannot force me to keep the connection open.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when a connection drops the client, it's still going to try to reconnect.
    When we restart the server using `nodemon`, there's about a quarter of a second
    where the server is down, and the client notices that. It says, "woah, woah, woah!
    Server went down! Let's try to reconnect!" Eventually it reconnects, and that's
    why we're seeing the message, `New user connected`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and shut down the server, and over inside the client, you''ll see
    that network requests are being made in Chrome Developer Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a98cb77-75d4-493b-9afb-d48ac57f2cbd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'They''re trying to reconnect to the server, and you can see they''re failing
    because the server is not up. Now, go back into the Terminal and restart the server
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05a56f3d-7382-46f4-86c3-3ebe0df21368.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the client, we''ll try to reconnect again. We''ll get a success result
    from the server—and boom—we are back! Just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73e49a7b-0326-40b2-86c4-130b7f59353e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, when we reconnect, you can see that we get the message again, and that's
    why we saw it when we first added it to the `server.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a connection event in the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, the connection event also exists in the client. This means that in the
    client, we can do something when we successfully connect to the server. It may
    not happen right away; it may take a little time. Over inside Atom, we can add
    this event inside `index.html`, right below our call to `io`. As shown, we''ll
    call `socket.on`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to listen for an event, and this event is a little different to the
    one we have in our `server.js` file. It''s not `on(''connection'')`, but `on(''connect'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `on` method here is exactly the same as the one we used in `server.js`.
    The first argument is the event name and the second argument is the callback function.
    In this case, we don't get access to a `socket` argument, since we already have
    it as a `socket` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, all I''ll do is use `console.log` to print a little message to
    the console, `Connected to server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this in place, we can go into the browser and go to a new
    tab in Developer tools. We''ll load the Console tab. The Console tab is kind of
    like the Terminal inside Node. If we use `console.log` in our client-side JavaScript
    code, those messages are going to show up there. As you can see in the preceding
    screenshot, we also have some errors. These errors occurred when our server was
    down as I was showing you how it reconnects; but if we refresh the page, as you''re
    going to see, `Connected to server` shows up, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2c5a05b-8a60-4dbf-92b8-8a736595cd37.png)'
  prefs: []
  type: TYPE_IMG
- en: As soon as the connection happens, the client and the server both have that
    event fired. The client prints `Connected to server` and the server prints `New
    user connected`.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we've now used the event system in Socket.io. We haven't
    set our own custom events, but we have taken advantage of some built-in ones.
  prefs: []
  type: TYPE_NORMAL
- en: The disconnect event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we're going to talk about in this section is the `disconnect`
    event, which lets you do something on both the server and the client when the
    connection drops. We'll add an event listener on the client, and do the same thing
    on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client, next to our `connect` event, we can call `socket.on` again to
    listen to a new event. Once again, the name of the event here is the name of a
    built-in event, so it''s only going to work if you type it correctly. This one
    is called `disconnect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `disconnect` event is going to fire whenever the connection drops. If the
    server goes down, the client is going to be able to do something. For now, that
    something is just going to be log a message, `console.log(''Disconnected from
    server'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this message in place, we can actually save our `index.html`
    file. Go over to the browser and give it a refresh to load in our new JavaScript
    file. Go ahead and make your browser screen just a little bit smaller so we can
    see it in the background of the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll go to the Terminal, shut down the connection by shutting down the server,
    and over inside the browser, we get `Disconnected from server` printing to the
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b2c98db-b167-450b-9edd-2866e78baf95.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If I restart my server inside the Terminal, you can see we''ve automatically
    connected, as `Connected to server` prints to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f0feac0-1f57-46ae-8260-c0053d06bb4c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, the exact same event exists on the server. We can listen for a disconnecting
    client and we can do something when they leave. In order to register this event,
    you are going to go into `server.js`, and inside our callback, you're going to
    call `socket.on` in `server.js`, just like we did in the `index.html` file. It's
    the exact same signature. The first argument is the event name, `disconnect`.
    The callback function should do something simple, like print `client disconnected`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have that in place, what I want you to do is open up the browser and
    open up the Terminal, then close the browser tab. You should see the message print
    in the server—whatever message you happened to type here. Open up another browser
    tab, close it, and make sure you get the same message. This message should print
    every time one of your browser tabs closes, assuming that browser tab had an open
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to do this, all you need to do is copy the exact same signature as we
    used in the `io.on` method. `socket.on` takes two arguments: the first one is
    the name of the event we''re trying to listen to, `disconnect`; and the second
    argument is the function to run when the event fires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, all we''re going to do is use `console.log` to print `User was
    disconnected`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll save the file, which is automatically going to restart our application.
    Switch to the Terminal and then to the browser, so you can see the Terminal in
    the background. I''m going to open up a new tab, so when I close this currently
    open tab, the Chrome browser doesn''t close completely. Close the tab with the
    open connection and, as shown in the following screenshot, inside the Terminal,
    we get `User was disconnected`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fafaca7c-7953-45ac-abff-01d99d39c79f.png)'
  prefs: []
  type: TYPE_IMG
- en: If I open up a new tab and go to `localhost:3000`, then `New user connected`
    prints. As soon as I close it,  `User was disconnected` prints to the screen on
    the server. Hopefully, you're starting to see why WebSockets are so awesome—that
    instant two-way communication makes any sort of real-time application effortless
    to build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s wrap this one up with a commit. I''ll shut down our server and
    run `git status`. We can see that we only have modified files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b7ad71a-38da-450f-a53b-87b0991bae91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, `git commit` with the `-am` flag is going to get the job done. We can add
    our message, `Add connect and disconnect event handlers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: I'll make the commit and push it up to GitHub by using the `git push` command.
  prefs: []
  type: TYPE_NORMAL
- en: With that in place, we are done. In the next section, we're going to get into
    the very interesting stuff—you're going to learn how to emit and listen to custom
    events. This means you can send any data you like from the server to the client,
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting and listening to custom events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to listen to those built-in events—things
    such as connection events and disconnection events. Those are fine, and they're
    a great starting place, but in this section, what we want to talk about is emitting
    and listening to custom events, and this is where Socket.io gets really interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re able to emit and listen to custom events, you can send anything
    you want from the server to the client or from the client to the server. Now,
    to go through a quick example of how that''ll look, we''re going to use an example
    app, which will be an email application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2900ca06-4ada-4f9d-b008-d808ba8d2aaf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the left, we have our server, which is starting up a Socket.io web server.
    On the right, we have our email app, which is showing a list of all our current
    emails. Now, one custom event that our app might require is a `newEmail` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e853b6ec-58a3-476c-b1ab-1dc5919a2e78.png)'
  prefs: []
  type: TYPE_IMG
- en: The `newEmail` event is going to be emitted by the server when an email comes
    in. For example, if I sign up to a new service, that service sends me an email
    to confirm my email. Then, the server eventually gets that email and it emits
    an event that the client listens to. The client is going to listen for the `newEmail`
    event and will be able to re-render the list of emails in the browser using jQuery,
    React, Ember, or whatever library it happens to be using, showing the new email
    to me, the user.
  prefs: []
  type: TYPE_NORMAL
- en: Now, aside from just sending a message that an event happened, the most important
    piece to the puzzle is sending data, and we can actually do that. When you create
    and emit a custom event, you can send whatever information you like from the server
    to the client or from the client to the server. Usually, this takes the form of
    an object with various properties. In the case of getting a new email, I might
    want to know who the email is from. I definitely need to know the text of the
    email, and I also want to know when the email arrived at my server so I can render
    what I need to inside the browser for whoever happens to be using the email app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this is data flowing from the server to the client, which is something
    we were not able to accomplish with HTTP requests, but it is something we can
    accomplish using Socket.io. Now, another event, the  `createEmail` event, is going
    to flow from the client to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4683655-d8fe-48a7-9f09-3c6d2500b135.png)'
  prefs: []
  type: TYPE_IMG
- en: When I create a new email inside my web browser, I'll need to emit that event
    from the client, and the server is going to listen for that event. Once again,
    we will be sending some data across. Although the data will be a little different,
    we want to know who the email needs to be sent to, we need the text of the email,
    and maybe we want to schedule it for down the line, so a `scheduleTimestamp` field
    could be used.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, these are all just example fields; your fields for a real email app
    would probably be a little different. With this in place, though, we are ready
    to go ahead and actually create these two events inside our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom events inside an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's dive in to creating custom events inside our application, starting with
    creating `newEmail` and `createEmail` events. Before we start emitting or listening
    to custom events, let's go ahead and make a few tweaks to our client-side JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the JavaScript into a separate file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you might have noticed in the last section, I accidentally used ES6 arrow
    functions inside our client-side JavaScript code. As I mentioned, we want to avoid
    this; the project is going to work correctly in Chrome, but if you tried to load
    it up on your mobile phone, Internet Explorer, Safari, or some versions of Firefox,
    the program would crash. So, instead of using arrow functions, we''ll use regular
    functions by removing the arrow and adding the `function` keyword before our arguments.
    I''ll do this for the `on(''connect''` listener and for the `on(''disconnect''`
    listener, adding the `function` keyword and removing the arrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: I'll also take our JavaScript and move it into a separate file. Instead of editing
    the client-side JavaScript right inside our HTML file, we'll have a separate file
    where that code lives. This is a better method to get things done.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `public` folder, we can make a new folder for this JavaScript file.
    I''ll make one called `js` (we''ll have multiple JavaScript files by the time
    this app is over, so it''s a good idea to create a folder to house all of those).
    For now, though, we just need one, `index.js`. The `index.js` file will load when
    we load `index.html`, and it will contain all the JavaScript required to get this
    page to work, starting with the JavaScript we wrote in the last section. Cut out
    all of the code in the `script` tag and paste it into `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can save the file and update our `script` tag. Instead of having the code
    in line, we''ll load it in by providing the `src` attribute, with the path to
    the file as `/js/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this in place, we have the exact same functionality that we
    had before—only this time around, the JavaScript has been broken out into its
    own file. Start up the server using `nodemon server/server.js`. Once it''s up,
    we can go ahead and load the app by going to the browser and opening up `localhost:3000`.
    I''ll open up Developer tools as well, so we can make sure everything is working
    as expected. Inside the console, we see `Connected to server` is still printing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8982ec98-bf7d-4919-af54-d88434f1a7ef.png)'
  prefs: []
  type: TYPE_IMG
- en: This is code that exists in `index.js`, and the very fact that it's showing
    up here proves that the file was loaded. With this in place, we can now move on
    to our custom events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have two events that we talked about for our example email application:
    we have `newEmail`, which is from the server to the client; and we have `createEmail`,
    which is an event emitted by the client and listened to by the server. We''re
    going to get started with `newEmail`, and to kick things off, we''re going to
    head into our client-side JavaScript and listen for that event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When that event fires, we want to do something: we want to take the data and
    use jQuery, React, or some other frontend framework to render it to the browser
    so the user can see the email as soon as it comes in.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a newEmail custom event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, in order to listen to a custom event, we are still going to use `socket.on`;
    although, instead of specifying the name of one of the built-in events, we''ll
    provide the first argument inside quotes as the name of our custom event. In this
    case, that name is going to be `newEmail`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the second argument for `socket.on` is the same as the second argument
    for the built-in event listeners. We''ll provide a function, and this function
    is going to get called when the event fires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, all we''re going to do inside the function is use `console.log` to
    print a little message, `New email`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This will print inside of the web developer console every time the client hears
    this event coming across the pipeline. Now that we have the listener in place
    for `newEmail`, let's go ahead and emit this event inside `server.js`.
  prefs: []
  type: TYPE_NORMAL
- en: The emit method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside `server.js`, what we want to do is call a method on `socket`. The `socket`
    method has a method called `emit`, which we''ll use on both the client and the
    server to emit events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `emit` method is really similar to the listeners; although, instead of
    listening to an event, we are creating the event. The first argument is the same.
    It''s going to be the name of the event you want to emit. In this case, we have
    to match it exactly as we specified in `index.js`, `newEmail`. Now, as shown in
    the following code, we''ll provide `newEmail`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this is not a listener, so we''ll not provide a callback function. What
    we want to do is specify the data. Now, by default, we don''t have to specify
    any data; maybe we just want to emit `newEmail` without anything, letting the
    browser know that something happened. If we do this, over inside the browser we
    can refresh the app, and we get `New email`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3015d73d-3ead-4b41-a4d1-574b92392d0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The event is still happening even though we''re not sending across any custom
    data. If you do want to send custom data, which is most likely the case, that''s
    super easy. All you have to do is provide a second argument for `newEmail`. Now,
    you could provide an argument of three, or true, or anything else, but you usually
    want to send multiple pieces of data across, so an object is going to be your
    second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to let you specify anything you like. In our case, we might specify
    who the email is from by specifying a `from` attribute; for instance, it''s from
    `mike@example.com`. Maybe we also have the `text` attribute for the email, `Hey.
    What is going on`, and we might have other attributes as well. For example, `createdAt`
    could be a timestamp of when the server got the email, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The data shown in the preceding code block will get sent along with the `newEmail`
    event from the server to the client. Now, go ahead and save `server.js`, and inside
    our client-side JavaScript `index.js` file, we can go ahead and do something with
    that data. The data that''s emitted with your event is provided as the first argument
    to your callback function. As shown in the following code, we have our callback
    function for `newEmail`, which means we can name the first argument `email` and
    do whatever we want with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We might be appending it to a list of emails in a real web app, but for our
    purposes, all we''ll do right now is provide it as the second argument to `console.log`,
    rendering it to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we can now test that everything is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the newEmail event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If I go to the browser and give things a refresh using *command* +* R*, we
    see over inside the console that we have `New email`, and below this we have `Object`. We
    can click on `Object` to expand it and we see all of the properties we specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd867838-4c51-46f5-b1b7-f8e364658f62.png)'
  prefs: []
  type: TYPE_IMG
- en: We have our `from` property, the `text` property, and our `createdAt` property.
    All of it is showing up as expected, which is fantastic! In real time, we were
    able to pass not only an event, but event data from the server to the client,
    which is something we could never do with an HTTP API.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a createEmail custom event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, on the other side of things, we have a situation where we want to emit
    an event from the client trying to send some data to the server. This is for our
    `createEmail` event. Now, in this case, we will add our event listener inside  `server.js`
    using `socket.on`, just as we do for any other event listener, such as we have
    in `server.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `io.on` method we used for the connection event is a very special event;
    you will usually not be attaching anything to `io`, or be making calls to `io.on`
    or `io.emit`, other than the one we have mentioned in this function. Our custom
    event listeners are going to happen in the following statement by calling `socket.on`
    as we do for `disconnect`, passing in the name of the event you want to listen
    to—in this case, it is the `createEmail` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for `createEmail`, we do want to add a listener. We are in our Node code,
    so we can use an arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re probably going to expect some data, such as the email to create, so
    we can name that first argument. We name it after the data sent along with the
    event, so I''m going to call this `newEmail`. For this example, all we''re going
    to do is print it to the console so we can make sure the event is properly going
    from client to server. I''ll add `console.log` and log out the event name, `createEmail`.
    As the second argument, I''ll log out the data so I can view it in the Terminal
    and make sure everything works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now we have our listener in place and our server did restart; however, we're
    never actually emitting the event on the client. We can go ahead and fix this
    by calling `socket.emit` in `index.js`. Now, call it inside our `connect` callback
    function. We don't want to emit the event until we are connected, and `socket.emit`
    is going to let us do just that. We can call `socket.emit` to emit the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event name is `createEmail`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can pass any data we like in as the second argument. In the case of
    an email app, we''re probably going to need to send it to someone, so we''ll have
    an address for that—something like `jen@example.com`. We''re obviously going to
    need some text—something like `Hey. This is Andrew`. Also, we might have other
    properties, such as subject, but for now we''re going to stick with just these
    two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: So, what we've done here is we've created a client-side script that connects
    it to the server, and as soon as it connects, it emits this `createEmail` event.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this is not a realistic example. In a real-world app, a user is most likely
    going to fill out a form. You'll grab the previously mentioned pieces of data
    from the form, and then you'll emit the event. We will be working with HTML forms
    a little later; for now, though, we're just calling `socket.emit` to play around
    with these custom events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save `index.js`, and inside the browser, we can now give the page a refresh.
    As soon as it connects, it''s going to emit that event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ea89ef8-d3e2-402f-ae94-0bf7b4b40141.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Terminal, you see `createEmail` printing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7b51fa1-5a51-452d-8594-bfb9a2b1972d.png)'
  prefs: []
  type: TYPE_IMG
- en: The event was emitted from the client to the server. The server got the data
    and all is well.
  prefs: []
  type: TYPE_NORMAL
- en: socket.emit in the developer console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, another cool thing about the console is that we have access to the variables
    created by our application; most notably the socket variable. This means that
    inside Google Chrome, in the developer console, we can call `socket.emit` and
    we emit whatever we like.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can emit an action, `createEmail`, and I can pass in some data as the second
    argument, an object where I have a to attribute equal to `julie@example.com`.
    I have my other attributes too—something like `text`, which I can set equal to
    `Hey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example of how we can use the developer console to make debugging
    our app even easier. We can type a statement, hit *enter*, and it''s going to
    go ahead and emit the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8811a670-5871-4777-b76f-fe0776ab552b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the Terminal, we''ll get that event and do something with it—whether
    it''s creating the email or doing anything else we might require. Inside the Terminal,
    you can see `createEmail` showed up. We''ll send that one to Julie, and then there''s
    the text, `Hey`. It all got to the server from the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d17b9f5-2766-4b66-a660-5dcb8c2720c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have this in place and we''ve played around with how we can use
    these custom events, it''s time to move from the email application to the actual
    app we''re going to be building: *the chat app*.'
  prefs: []
  type: TYPE_NORMAL
- en: The custom events in the chat app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you know how to emit and listen to custom events, we''re going to
    move on to creating two events that we''ll actually use in the chat app. These
    are going to be `newMessage` and `createMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/659b8cff-cdef-4a5a-8117-0694c4a5378e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, for the chat app, we once again have our server, which is going to be the
    server we build; and we have our client, which is going to be a user who is in
    the chat app. There are most likely going to be multiple users who all want to
    communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the first event we''ll have is a `newMessage` event. This is going to
    be emitted by the server and listened to on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1be19315-6b2b-4499-ba4d-3e3c0d181df5.png)'
  prefs: []
  type: TYPE_IMG
- en: When a new message comes in, the server will send it to everyone connected to
    the chat room, so they can display it to the screen and a user can go ahead and
    respond to it. The `newMessage` event is going to require some data. We're going
    to need to know who the message was from; a string of someone's name, such as
    `Andrew`, the text of the message, something like, `hey, can you meet up at six`,
    and a `createdAt` timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: All of this data is going to get rendered inside our chat application in the
    browser. We'll be doing that for real in a little bit, but for now we'll just
    print it to the console. So, this is the first event I want you to create. You'll
    make this `newMessage` event, emit it from the server—for now, you can simply
    emit it when a user connects—and you'll listen to it on the client. For now, on
    the client, you can just print with `console.log` a little message when you get
    the data. You can say something like `got new message`, printing the object that
    was passed with this data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, the second event we''ll work with is `createMessage`. This will come
    from the client to the server. So if I''m user 1, I''ll fire a `createMessage`
    event from my browser. This will go to the server, and the server will fire `newMessage`
    events to everyone else so they can see my message, which means the `createMessage`
    event is going to get emitted from the client and the server is going to be the
    one who''s listening for the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82e574bd-553e-43e4-bfa1-020918b7a805.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, this event will require some data. We''ll need to know who the message
    was from and also the text: what did they want to say? We need both of these pieces
    of information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, notice a discrepancy here: we''re sending the `from`, `text`, and `createdAt`
    properties to the client, but we''re not asking for a `createdAt` property from
    the client when they create a message. This `createdAt` property is actually going
    to get created on the server. This is going to prevent the user from being able
    to spoof the time a message was created at. There are certain properties we''re
    going to trust the user to provide us with; there''s others that we will not trust
    them to provide us with, and one of those is going to be `createdAt`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, for `createMessage`, all you have to do is set up an event listener on
    the server that waits for this to fire, and once again, you can simply print a
    message, for example, `create message`, and then you can provide the data that
    was passed along to `console.log`, printing it to the Terminal. Now, once you
    have that listener in place, you'll want to emit it. You can emit it when you
    user first connects, and you can also fire a couple of `socket.emit` calls from
    Chrome Developer Tools, making sure that all of the messages show up in the Terminal,
    listening for the `createMessage` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to get started inside `server.js` by listening for that `createMessage`
    event, and this is going to happen down below the `socket.emit` function in `server.js`.
    Now, we have an old event listener from `createEmail`; we can remove that, and
    we can call `socket.on` to listen to our brand new event, `createMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createMessage` event is going to require a function to call when the event
    actually happens. We''ll want to do something with the message data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'For the moment, all you need to do is use `console.log` to print it to the
    Terminal so we can verify that everything works as expected. We''ll get our message
    data, which will include a `from` property and a `text` property, and we''ll print
    it to the screen. You don''t have to specify the exact message I used; I''ll just
    say `createMessage`, and the second argument will be the data that was passed
    from the client to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our listener in place, we can go ahead and emit this inside
    the client in `index.js`. Now, we currently have an emit call for the `createEmail`
    event. I''ll remove this `emit` call. We''ll call `socket.emit` first and then
    `emit(''createMessage'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll emit `createMessage` with the necessary data.
  prefs: []
  type: TYPE_NORMAL
- en: Remember when you're emitting a custom event that the first argument is the
    event name and the second is the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the data, we''ll provide an object with two properties: `from`, this one''s
    from `Andrew`; and `text`, which is the actual text of the message, which could
    be something like `Yup, that works for me`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to be the event we emit. I''m going to save `index.js`, head
    over to the browser, and we should be able to refresh the app and see the data
    in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98277517-b201-4820-bd7c-8b525aeb1b1b.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, inside the Terminal we have `createMessage`
    with the `from` property that we specified, and the text, `Yup, that works for
    me`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can also emit events from Chrome Developer Tools to play around with
    Socket.io. We can add `socket.emit`, and we can emit any event we like, passing
    in some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The event we''ll emit is `createMessage`, and the data is a `from` attribute;
    this one''s from `Jen` and a text attribute, `Nope`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c85e450-ed3d-42b2-bc66-a6e92e08d942.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When I send this off, the message shows up on the server in real time, and
    as shown in the following screenshot, you can see it''s from `Jen`, the text is
    `Nope`, and everything is working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2d5b142-317f-4c4b-9048-e17438974b18.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, that's the first event; the other one is the `newMessage` event, which
    is going to be emitted by the server and listened to by the client.
  prefs: []
  type: TYPE_NORMAL
- en: The newMessage event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with this one, we''ll add our event listener inside `index.js`.
    We have the old event listener for `newEmail`. I''m going to go ahead and remove
    that, and we''ll call `socket.on` to listen to the new event, `newMessage`. The
    `newMessage` event is going to require a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'For the moment, we''ll use `console.log` to print the message to the console,
    but later, we''ll be taking this message and adding it to the browser so a user
    can actually see it on the screen. Now, we are going to get the message data.
    I''ll create an argument called `message` for the moment, and we can go ahead
    and simply log it to the screen using `console.log`, printing the name of the
    event so it''s easy to track in the Terminal, and the actual data that was passed
    from server to client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the last thing we need to do is simply emit `newMessage` from the server,
    making sure it shows up in the client. Inside `server.js`, instead of emitting
    `newEmail`, we will call `socket.emit`, emitting our custom event, `newMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will need some data—that message data. We''ll also provide that as
    the second argument. It''ll be an object with a `from` property. It could be from
    whoever you like; I''ll go with `John`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll provide the `text` property. This can be anything as well,
    such as `See you then`, and finally we''ll provide the `createdAt` property. This
    will be generated by the server later so a user can''t spoof the time a message
    was created at, but for now, we''ll just use some sort of random number, such
    as `123123`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as soon as a user connects to the server, we''ll be emitting that event.
    Inside the browser, I can go ahead and refresh things. We have our `newMessage`
    event showing up and the data is exactly as we specified it in our `server.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53484234-07b0-4d98-9fa2-f2bf1522d640.png)'
  prefs: []
  type: TYPE_IMG
- en: We have our `createdAt` timestamp, our `from` property, and our `text` property.
    In future, we'll be literally taking this data and rendering it into the browser
    so it shows up and someone can read it and respond to it, but for now we are done.
    We have our event listener on the server for `createMessage`, and our event listener
    on the client for `newMessage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is it for this section! Since we are done, we will be making a quick commit.
    I''ll shut down the server and run the `git status` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96400b89-9804-4600-935d-ff23fe25d419.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, we have quite a few changes here. We
    have our new `js` file in the `public.js` folder, and we''ve also changed `server.js`
    and `index.html`. I''ll run the `git add .` command to add all of that to the
    next commit, and then I''ll create a commit using `git commit` with the `-m` flag.
    A good message for this one is `Add newMessage and createMessage events`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we can now push our code up to GitHub. There's no need to
    do anything with Heroku since we don't have anything visual just yet; we'll hold
    off on that until later.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we're going to wire up messages, so when tab 1 emits a
    message, it's visible by tab 2\. This is going to bring us one step closer to
    actually communicating in real time between different browser tabs.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our custom event listeners and emitters in place, it's time
    to actually wire up the message system so when one user sends a message to the
    server, it actually gets sent to every connected user. If I have two tabs open
    and I emit a `createMessage` event from one tab, I should see the message arrive
    in the second one.
  prefs: []
  type: TYPE_NORMAL
- en: To test things locally, we'll be using separate tabs, but the same would work
    on Heroku with separate browsers on separate networks; as long as everyone has
    the same URL on their browser, they will be connected, regardless of which machine
    they're on. Now, for localhost, we obviously don't have the right privilege, but
    as we deploy to Heroku, which we will be doing in this section, we'll be able
    to test this out between, say, your phone and the browser running on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the createMessage listener for all users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we''ll update the `createMessage` listener. Currently, all
    we do is log the data to the screen. But here, instead of just logging it, we
    actually want to emit a new event, a `newMessage` event, to everybody, so each
    connected user gets the message that was sent from a specific user. In order to
    get that done, we''ll call a method on `io`, which will be `io.emit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '`Socket.emit` emits an event to a single connection, whereas `io.emit` emits
    an event to every single connection. Here, we are going to emit the `newMessage`
    event, specifying it as our first argument. The second argument, as with `socket.emit`,
    is the data you want to send:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we know we''ll get a `from` property and a `text` property from the client—those
    appear in `socket.emit` for the `createMessage` event in `index.js`—which means
    what we need to do is pass those along, setting `from` equal to `message.from`,
    and setting `text` equal to `message.text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, along with `from` and `text`, we''ll also specify a `createdAt` property,
    which will be generated by the server to prevent a specific client from spoofing
    the time a message was created. The `createdAt` property is set equal to `new
    Date`, and we''ll call the `getTime` method to get that timestamp back, which
    we''ve done before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this in place, we actually have messaging wired up. We can
    go ahead and remove our emit calls—the `newMessage` emit call and the `createMessage`
    emit call—from `server.js` and `index.js`, respectively, making sure to save both
    files. With this in place, we can go ahead and test this by opening up two connections
    to the server and emitting some events.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the messaging events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to start up the server inside the Terminal using the `nodemon server/server.js`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f0192c1-36b7-4667-b655-74be87037ef3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the browser, we can now open up two tabs, both at `localhost:3000`.
    For both tabs, I am going to open up Developer tools, since that''s currently
    the graphic user interface for our application. We don''t have any forms just
    yet, which means we need to use the Console tab to run some statements. We''ll
    do the same thing for a second tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b76c60f-3aaa-465c-8791-6ed308ea1629.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that as soon as we open the tabs, we''ll get `New user connected` messages
    in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3134c5a-c8dd-4d7f-8a1f-24f27e9561da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our two tabs open, we can go ahead and emit a `createMessage`
    event from either one. I''ll emit it from the second tab by calling `socket.emit`,
    emitting a custom event. The event name is `createMessage`, and it takes those
    two properties we just discussed—the `from` property and the `text` property—both
    of which I''ll specify in the `socket.emit` object. The `from` property will be
    set equal to the first name, `Andrew`, and the `text` property will get set equal
    to `''This should work''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can now emit my event from the browser. It will go to
    the server, which will send the message to every connected user, including the
    currently connected user who sent the message. We''re going to hit *enter*, it
    fires it off, and we see that we get `newMessage`. We have the message we just
    created, but the cool thing is that over in the other tab, we also have the message:
    a message from one user has reached another user in a separate tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c1a7d6e-35a8-4369-8009-094e6d4a6f74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With this in place, we now have a very basic messaging system set up: a user
    emits an event, it goes to the server, and the server sends it to everyone else
    who is connected. With this in place, I''d like to make a commit and deploy to
    Heroku so we can test it out.'
  prefs: []
  type: TYPE_NORMAL
- en: Committing and deploying messaging to Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If I run the `git status` command in the Terminal, I see I have my two changed
    files as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4f5767e-22b4-4d24-8774-ffb6a27bb40c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I can then run the `git commit` command with the `-am` flag to specify a message
    for this commit—something like `Emit newMessage on createMessage` will get the
    job done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: I can then go ahead and actually make the commit, pushing it up to both GitHub
    and Heroku. The `git push` command is going to get it on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The `git push heroku master` command is going to deploy it live to the web.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be able to open up our chat application and make sure it works regardless
    of the browser, computer, or any other variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46fcc142-6d27-444c-b117-fc868a0a2157.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, we are compressing and launching the
    app. It looks like everything is done. I''ll use the `heroku open` command to
    open it up. This will open it up in my default browser, and as shown in the following
    screenshot, you''ll see that we have `Welcome to the chat app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59853981-8d91-4aef-a24a-713307e74816.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing messaging in a Firefox browser using Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, to demonstrate this, what I''ll open up a separate browser. I''ll open
    up Firefox and type in the exact same URL. Then, I''ll copy this URL and grab
    the Firefox browser, making it smaller so we can quickly switch between the two,
    opening up the Heroku app here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5473cdad-dee3-4f40-aaed-23b924882cff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, Firefox also has Developer Tools available via the menu in the top-right
    corner. There, we have a Web Developer section; we''re looking for Web Console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cec09cd5-77a7-400b-b0af-405d042bb09f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have this open, we can go into Developer tools for our Chrome tab
    connected to the Heroku application, and what we''ll do is emit an event using
    `socket.emit`. We''ll emit a `createMessage` event. We''ll specify our custom
    properties inside of the object, then we can go ahead and have `from` set to `Mike`,
    and we can set the `text` property equal to `Heroku`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when I go ahead and emit this event, everything should work as expected.
    We''re calling `socket.emit` and emitting `createMessage`. We have our data, which
    means it will go to the Heroku server, which will send it over to Firefox. We''ll
    send this off, which should mean we get `newMessage` in Chrome Developer tools.
    Then, inside Firefox, we also have the message. It''s from `Mike`, the text is
    `Heroku`, and we have the `createdAt` timestamp added by our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0df6017-f242-4a88-96c9-8e31161dd1be.png)'
  prefs: []
  type: TYPE_IMG
- en: With this in place, we have a messaging system—not only working locally, but
    also on Heroku—which means anybody in the world can visit this URL; they can emit
    the event, and everyone else connected is going to see that event in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've tested it out across browsers, I will close Firefox, and we'll
    move on to the second part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting events to other users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this part of the section, we''ll talk about a different way to emit events.
    Some events you want to send to everybody: a new message should go to every single
    user, including the one who sent it so it can show up inside the list of messages.
    Other events, on the other hand, should only go to other people, so if user one
    emits an event, it shouldn''t go back to user one, but instead go only to users
    two and three.'
  prefs: []
  type: TYPE_NORMAL
- en: A good example of this is when a user joins a chatroom. I want to print a little
    message, like `Andrew joined`, when someone joins, and I want to print a message,
    like `welcome Andrew`, for the actual user who joined. So, in the first tab I
    would see `welcome Andrew`, and in the second tab I would see `Andrew joined`.
    In order to get that done, we'll look at a different way to emit events in the
    server. This will be done via broadcasting. Broadcasting is the term for emitting
    an event to all but one specific user.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll start up the server once again using the `nodemon server/server.js` command,
    and inside Atom, we can now tweak how we emit the event in the `io.emit` method
    in `server.js`. Now, this is going to be the final way we do things, but we''ll
    play around with broadcasting as well, which means I''ll comment this out as opposed
    to removing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'To broadcast, we have to specify the individual socket. This lets the Socket.io
    library know which users shouldn''t get the event. In this case, the user that
    we call here is not going to get the event, but everyone else will. Now, we need
    to call `socket.broadcast`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Broadcast is an object that has its own emit function, and it's the exact same
    syntax as `io.emit` or `socket.emit`. The big difference is who it gets sent to.
    This will send the event to everybody but the mentioned socket, which means if
    I fire a `createMessage` event, the `newMessage` event will fire to everybody
    but myself, and that's exactly what we can do here.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s going to be identical, which means we can go ahead and pass in the message
    event name. The arguments will be identical: the first one will be `newMessage`,
    and the other one will be the object with our properties, `from: message.from` and `text:
    message.text`. Last up,we have `createdAt` equal to a new timestamp, `new Date().getTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we will not see the messages we send, but everybody else
    will. We can prove this by heading over to Google Chrome. I''ll give both tabs
    a refresh, and from the second tab, once again, we will emit an event. We can
    actually use the up arrow key inside the web developer console to rerun one of
    our previous commands, and that''s exactly what we''ll do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re emitting a `createMessage` event with a `from` property set to
    `Andrew` and a `text` property equal to `This should work`. If I hit *enter* to
    send this off, you''ll notice that this tab no longer receives the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2355f90-e4e6-4efa-b16b-9d7b1c43e29a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if I go to `localhost:3000`, we will get `newMessage` showing up with
    the message data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ed3ea24-b881-4894-8ca8-9642376e2aff.png)'
  prefs: []
  type: TYPE_IMG
- en: This is because tab two broadcasts the event, which means it was only received
    by other connections, such as tab one or any other connected user.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting two events when a user connects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With broadcasting in place, let''s get into the final way we emit messages.
    We''ll emit two events in `socket.io`, right when a user connects. Now, we''ll
    not actually use broadcasting in this context, so we''ll comment the broadcast
    object out and uncomment our old code. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: You'll first call `socket.emit` to emit a message to the user who joins. Your
    message should come from the admin, `from Admin`, and the text should say something
    like `Welcome to the chat app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, along with `socket.emit`, you''ll also call `socket.broadcast.emit`, which
    will get sent to everybody but the user who joined, which means you can go ahead
    and set `from` equal to `Admin` once again, and you can set `text` equal to `New
    user joined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: This means that when we join a chatroom, we'll see a message greeting us, and
    everyone else is going to see a message letting them know that someone else has
    joined. Both of these events are going to be `newMessage` events. We'll have to
    specify `from` (which is `Admin`), the `text` (which is whatever we said it should
    be), and `createdAt`.
  prefs: []
  type: TYPE_NORMAL
- en: Greeting an individual user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To kick things off, we''ll fill out the first call. This is a call to `socket.emit`,
    and this call will be responsible for greeting the individual users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We will still send an event of `newMessage` type and the exact same data from
    `text` and `createdAt`. The only difference here is that we''ll be generating
    all the properties as opposed to getting some of them from the user as we did
    earlier. Let''s get started with `from`. This one will be from `Admin`. Any time
    we send a message via the server, we''ll call `Admin` and the text will be our
    little message, `Welcome to the chat app`. Next, we''ll add `createdAt`, which
    will be set equal to `new Date` by calling the `Date().getTime` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Later on, we'll greet them by name. We don't have that information for the moment,
    so we'll stick with a generic greeting. With this call in place, we can remove
    the comment and we can move on to the second one. This is the broadcast call that's
    going to alert every other user, except for the one who joined, that someone new
    is here.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting a new user in the chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To broadcast a new user in the chat, we''ll use `socket.broadcast.emit` and
    we''ll emit a `newMessage` event, providing our props. The `from` property, once
    again, will be set equal to the `Admin` string; `text` is going to be set equal
    to our little message, `New user joined`; and last up is `createdAt`, which is
    going to be set equal to `new Date` by calling the `Date().getTime` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Now we can remove our comment for the second call and everything should work
    as expected. The next thing you need to do is test out that all of this is working
    as expected by heading into the browser. There's a couple ways you could have
    done it; as long as you got it done, it doesn't really matter.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the user connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''ll close both of my old tabs and open up Developer tools before ever visiting
    the page. Then, we can go to `localhost:3000` and we should see a little message
    in Developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edd24c86-928c-46a7-bbef-28fb3bca952d.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we see a new message, `Welcome to the chat app`, printing, which is fantastic!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we want to test that the broadcast is working as expected. For the
    second tab, I''ll also open up Developer tools and go to `localhost:3000` once
    again. Once again, we get our little message, `Welcome to the chat app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/981514a6-2843-4033-bd4d-5af4c8a316b8.png)'
  prefs: []
  type: TYPE_IMG
- en: If we go to the first tab, we also see that a new user joined, and this is fantastic
    too!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I will make a commit to save these changes. Let''s go ahead and shut down
    the server and use `git status` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/351f2f54-3ca8-43fb-8482-c79c6892da6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we can go ahead and run the `git commit` command with the `-am` flag
    and specify a message, `Greet new user and alert others`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Once the commit is in place, we can use the `git push` command to push it up
    to GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: There's no need to deploy to Heroku right now, although you could easily deploy
    and test if you feel so inclined. With this in place, we are now done!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked into Socket.io and WebSockets to enable two-way communication
    between the server and client. We worked on setting up a basic Express server,
    a backend and a frontend, and we committed it up on GitHub and on Heroku. Next,
    we looked into adding `socket.io` to the app to set up communication between the
    server and client.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked into emitting and listening to custom events inside our application.
    Lastly, we wired up the message system by broadcasting the events such that when
    one user sends a message to the server, it actually gets sent to every connected
    user excluding the user who sends the message.
  prefs: []
  type: TYPE_NORMAL
- en: With all this in place, we now have a rudimentary—but working—messaging system,
    which is a great place to start! We're going to continue on in the next chapter
    by adding more features and building out the UI.
  prefs: []
  type: TYPE_NORMAL
