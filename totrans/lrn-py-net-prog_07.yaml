- en: Chapter 7. Programming with Sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you have interacted with various clients/servers in Python, you will be
    keen to create your own custom clients and servers for any protocol of your choice.
    Python provides a good coverage on the low-level networking interface. It all
    starts with BSD socket interface. As you can assume, Python has a `socket` module
    that gives you the necessary functionality to work with the socket Interface.
    If you have ever done socket programming in any other language like C/C++, you
    will love the Python `socket` module.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the socket module by creating a diverse range
    of Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the highlights of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics of sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with TCP sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with UDP sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP port forwarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-blocking socket I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing sockets with SSL/TLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom SSL client/server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network programming in any programming language can begin with sockets. But
    what is a socket? Simply put, a network socket is a virtual end point where entities
    can perform inter-process communication. For example, one process sitting in a
    computer, exchanges data with another process sitting on the same or another computer.
    We typically label the first process which initiates the communication as the
    client and the latter one as the server.
  prefs: []
  type: TYPE_NORMAL
- en: Python has quite an easy way to start with the socket interface. In order to
    understand this better, let's see the big picture first. In the following figure,
    a flow of client/server interaction is shown. This will give you an idea of how
    to use the socket API.
  prefs: []
  type: TYPE_NORMAL
- en: '![Basics of sockets](graphics/B03711_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: client/server interaction through socket
  prefs: []
  type: TYPE_NORMAL
- en: In the interaction between a typical client and a server, the server process
    has to work a bit more, as you may have thought. After creating a socket object,
    the server process binds that socket to a particular IP address and port. This
    is much like a telephone connection with an extension number. In a corporate office,
    after a new employee has been allocated with his desk phone, usually he or she
    will be assigned to a new extension number. So, if anybody makes a phone call
    to this employee, the connection can be established using his phone number and
    extension. After the successful binding, the server process will start listening
    for a new client connection. For a valid client session, the server process can
    accept the request of the client process. At this point, we can say that the connection
    between the server and the client has been established.
  prefs: []
  type: TYPE_NORMAL
- en: Then the client/server enters into the request/response loop. The client process
    sends data to the server process, and the server process processes the data and
    returns a response to the client. When the client process finishes, it exits by
    closing down the connection. At that moment, the server process probably goes
    back to the listening state.
  prefs: []
  type: TYPE_NORMAL
- en: The above interaction between client and server is a very simplified representation
    of the actual reality. In practice, any production server process has multiple
    threads or subprocesses to handle concurrent connections from thousands of clients
    over respective virtual channels.
  prefs: []
  type: TYPE_NORMAL
- en: Working with TCP sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a socket object in Python is very straightforward. You just need to
    import the `socket` module and call the `socket()` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Traditionally, the class takes plenty of parameters. Some of them are listed
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Socket family**: This is the domain of socket, such as `AF_INET` (about 90
    percent of the sockets of the Internet fall under this category) or `AF_UNIX,`
    which is sometimes used as well. In Python 3, you can create a Bluetooth socket
    using `AF_BLUETOOTH`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Socket type**: Depending on your need, you need to specify the type of socket.
    For example, TCP and UDP-based sockets are created by specifying `SOCK_STREAM`
    and `SOCK_DGRAM,` respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protocol**: This specifies the variation of protocol within a socket family
    and type. Usually, it is left as zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For many reasons, socket operations may not be successful. For example, if you
    don't have permission to access a particular port as a normal user, you may not
    be able to bind to a socket. This is why it is a good idea to do proper error
    handling when creating a socket or doing some network-bound communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to connect a client socket to a server process. The following code
    is an example of TCP client socket that makes a connection to server socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding TCP client, an output similar to the following will
    be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if socket creation has failed for some reason, such as invalid DNS,
    an output similar to the following will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s exchange some data with the server. The following code is an example
    of a simple TCP client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look carefully, you can see that the preceding code actually created
    a raw HTTP client that fetches a web page from a web server. It sends an HTTP
    `GET` request to pull the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting the client/server communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The interaction between the client and server through the exchange of network
    packets can be analyzed using any network packet capturing tool, such as Wireshark.
    You can configure Wireshark to filter packets by port or host. In this case, we
    can filter by port 80\. You can get the options under the **Capture** | **Options**
    menu and type `port 80` in the input box next to the **Capture Filter** option,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting the client/server communication](graphics/B03711_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the **Interface** option, we choose to capture packets passing through any
    interface. Now, if you run the preceding TCP client to connect to [www.linux.org](http://www.linux.org/),
    you can see the sequence of packets exchanged in Wireshark, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting the client/server communication](graphics/B03711_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the first three packets establish the TCP connection by a three-way
    handshake process between the client and server. We are more interested in the
    fourth packet that makes an HTTP `GET` request to the server. If you double-click
    the selected row, you can see the details of the HTTP request, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting the client/server communication](graphics/B03711_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the HTTP `GET` request has other components such as `Request
    URI`, version, and so on. Now you can check the HTTP response from the web server
    to your client. It has come after the TCP acknowledgment packet, that is, the
    sixth packet. Here, the server typically sends an HTTP response code (in this
    case `200`), content length, and the data or web page content. The structure of
    this packet is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting the client/server communication](graphics/B03711_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding analysis of the interaction between the client and server,
    you can now understand, at a basic level, what happens behind the scenes when
    you visit a web page using your web browser. In the next section, you will be
    shown how to create your own TCP server and examine the interactions between your
    personal TCP client and server.
  prefs: []
  type: TYPE_NORMAL
- en: TCP servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you understood from the very first client/server interaction diagram, the
    server process needs to carry out a bit of extra work. It needs to bind to a socket
    address and listen for incoming connections. The following code snippet shows
    how to create a TCP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify our previous TCP client to send arbitrary data to any server.
    The following is an example of an enhanced TCP client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding TCP server in one console and the TCP client in another
    console, you can see the following interaction between the client and server.
    After running the TCP server script you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When you will run the TCP client script on another terminal then you will get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting client/server interaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, once again, you can configure Wireshark to capture packets, as discussed
    in the last section. But, in this case, you need to specify the port that your
    server is listening on (in the preceding example it''s `12345`), as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting client/server interaction](graphics/B03711_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we are capturing packets on a non-standard port, Wireshark doesn't decode
    it in the **Data** section (as shown in the middle pane of the preceding screenshot).
    However, you can see the decoded text on the bottom pane where the server's timestamp
    is shown on the right side.
  prefs: []
  type: TYPE_NORMAL
- en: Working with UDP sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike TCP, UDP doesn't check for errors in the exchanged datagram. We can create
    UDP client/servers similar to the TCP client/servers. The only difference is you
    have to specify `SOCK_DGRAM` instead of `SOCK_STREAM` when you create the socket
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create a UDP server. Use the following code to create the UDP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can create a UDP client to send some data to the UDP server, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, the UDP client sends a single line of text `Hello
    UDP server` and receives the response from the server. The following screenshot
    shows the request sent from the client to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with UDP sockets](graphics/B03711_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following screenshot shows the server's response sent to the client. After
    inspecting UDP client/server packets, we can easily see that UDP is much simpler
    than TCP. It's often termed as a connectionless protocol as there is no acknowledgment
    or error checking involved.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with UDP sockets](graphics/B03711_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: TCP port forwarding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the interesting experiments we can do with TCP socket programming is
    to set up a TCP port forwarding. This has very good use cases. Say, for example,
    if you are running an insecure program like FTP in a public server that doesn't
    have any SSL capability to do secure communication (FTP passwords can be seen
    clear-text over the wires). Since this server is accessible from Internet, you
    must not login with your password to the server without ensuring that the passwords
    are encrypted. One way of doing this is to use Secure FTP or SFTP. We can use
    a simple SSH tunnel in order to show how this approach works. So, any communication
    between your local FTP client and remote FTP server will happen via this encrypted
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: Let us run the FTP program to the same SSH server host. But create an SSH tunnel
    from your local machine that will give you a local port number and will directly
    connect you to the remote FTP server daemon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has a third party `sshtunnel` module that is a wrapper around the Paramiko''s
    `SSH` library. The following is a code snippet of TCP port forwarding that shows
    how the concept can be realized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us capture the packet transfer from the local machine `192.168.0.102` to
    the remote machine `192.168.0.101`. You will see all network traffic is encrypted.
    When you run the preceding script, you will get a local port number. Use the `ftp`
    command to connect to that local port number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding command, then you will get the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TCP port forwarding](graphics/B03711_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you cannot see any FTP traffic. As you can see,
    first we connect to local port `5815` (see the first three packets) and suddenly
    an encrypted session started with the remote host. You can continue watching the
    remote traffic, but there is no trace of FTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can also capture packets on your remote machine (`192.168.56.101`),
    you could see FTP traffic, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TCP port forwarding](graphics/B03711_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Interestingly, you can see your FTP password sent from the local machine (over
    SSH tunnel) as clear-text only on your remote box, not over the network, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TCP port forwarding](graphics/B03711_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, in this way, you can hide any sensitive network traffic in an SSL tunnel.
    Not only the FTP, you can also pass remote desktop session encrypted over an SSH
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: A non-blocking socket I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see a small example code snippet to test a non-blocking
    socket I/O. This is useful if you know that the synchronous blocking connection
    is not necessary for your program. The following is an example of non-blocking
    I/O:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This script will run a socket server and listen in a non-blocking style. This
    means you can connect more clients who won't be necessarily blocked for I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Securing sockets with TLS/SSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have probably come across the discussion around secure web communication
    using **Secure Socket Layer** (**SSL**), or more precisely **Transport Layer Security**
    (**TLS**), which is adopted by many other high-level protocols. Let us see how
    we can wrap a plain sockets connection with SSL. Python has the built-in `ssl`
    module, which serves this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we would like to create a plain TCP socket and connect to
    an HTTPS enabled web server. Then, we can wrap that connection using SSL and check
    the various properties of the connection. For example, to check the identity of
    the remote web server, we can see if the hostname is same in the SSL certificate
    as we expect it to be. The following is an example of a secure socket-based client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding example, you will see the details of the SSL certificate
    of a remote web server such as [http://www.google.com](http://www.google.com).
    Here we have created a TCP socket and connected it to HTTPS port `443`. Then that
    socket connection is wrapped into SSL packets using our `ssl_wrap_socket()` function.
    This function takes the following parameters as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sock`: TCP socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keyfile`: SSL private key file path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`certfile`: SSL public certificate path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cert_reqs`: Confirmation if certificate is required from other side to make
    connection and if validation test is required'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ca_certs`: Public certificate authority certificate path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server_hostname`: The target remote server''s hostname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssl_version`: The intended SSL version to be used by the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the beginning of the SSL socket wrapping process, we have created an SSL
    context using the `SSLContext()` class. This is necessary to set up the SSL connection
    specific properties. Instead of using a custom context, we could also use a default
    context, supplied by default with the `ssl` module, using the `create_default_context()`
    function. You can specify whether you''d like to create client or server side
    sockets using a constant. The following is an example for creating a client side
    socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `SSLContext` object takes the SSL version argument, that in our example
    is set to `PROTOCOL_TLSv1`, or you should use the latest version. Note that SSLv2
    and SSLv3 are broken and must not be used in any production code for serious security
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, `CERT_REQUIRED` indicates that server certificate
    is necessary for the connection to continue, and this certificate will be validated
    later.
  prefs: []
  type: TYPE_NORMAL
- en: If the CA certificate parameter has been presented with a certificate path,
    the `load_verify_locations()` method is used to load the CA certificate files.
    This will be used to verify the peer server certificates. If you'd like to use
    the default certificate path on your system, you'd probably call another context
    method; `load_default_certs(purpose=Purpose.SERVER_AUTH)`.
  prefs: []
  type: TYPE_NORMAL
- en: When we operate on server side, usually the `load_cert_chain()` method is used
    to load the key and certificate file so that clients can verify the server's authenticity.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `wrap_socket()` method is called to return an SSL wrapped socket.
    Note that, if `OpenSSL` library comes with **Server Name Indication** (**SNI**)
    support enabled, you can pass the remote server's host name while wrapping the
    socket. This is useful when the remote server uses different SSL certificates
    for different secure services using a single IP address, for example, name-based
    virtual hosting.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the preceding SSL client code, you will see the various properties
    of the SSL certificate of the remote server, as shown in the following screenshot.
    This is used to verify the authenticity of the remote server by calling the `getpeercert()`
    method and comparing it with the returned hostname.
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing sockets with TLS/SSL](graphics/B03711_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Interestingly, if any other fake web server wants to pretend to be the Google's
    web server, it simply can't do that, provided that you check the SSL certificate
    that is signed by an accredited certificate authority, unless an accredited CA
    has been compromised/subverted. This form of attack to your web browser is commonly
    referred to as the **man in the middle** (**MITM**) attack.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting standard SSL client/server communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot shows the interaction between the SSL client and the
    remote server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting standard SSL client/server communication](graphics/B03711_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let us examine the SSL handshake process between the client and the server.
    In the first step of a SSL handshake, the client sends a `Hello` message to the
    remote server saying what it is capable of, in terms handling key files, encrypting
    messages, doing message integrity checks, and so on. In the following screenshot,
    you can see that the client is presenting a set of `38` cipher suites to the server
    to choose relevant algorithms. It also sends the TLS version number `1.0` and
    a random number to generate a master secret for encrypting the subsequent message
    exchanges. This is helpful for preventing any third party to look inside the packets.
    The random numbers seen in the hello messages are used to generate the pre-master
    secret, which both ends will process further to arrive at the master secret, and
    then use that to generate the symmetric key.
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting standard SSL client/server communication](graphics/B03711_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the second packet from server to client, the server selects the cipher suite
    `TLS_ECDHE_RSA_WITH_RC4_128_SHA` for the purpose of connecting to the client.
    This roughly means the server wants to use the RSA algorithm for key handling,
    RC4 for encryption, and SHA for integrity checking (hashing). This is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting standard SSL client/server communication](graphics/B03711_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the second phase of the SSL handshake, the server sends an SSL certificate
    to the client. This certificate is issued by a CA, as mentioned earlier. It contains
    a serial number, public key, validity period, and the details of the subject and
    the issuer. The following screenshot show the remote server certificate. Can you
    locate the server's public key inside the packet?
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting standard SSL client/server communication](graphics/B03711_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the third phase of the handshake, the client exchanges a key and calculates
    a master secret to encrypt the messages and continue further communications. Client
    also sends the request to change the cipher specification that was agreed on the
    previous phase. It then indicates to start encrypting the message. The following
    screenshot shows this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting standard SSL client/server communication](graphics/B03711_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the final task of the SSL handshake process, a new session ticket is generated
    by the server for the client''s particular session. This happens due to a TLS
    extension where the client advertises its support by sending an empty session
    ticket extension in the client `Hello` message. The server answers with an empty
    session ticket extension in its server `Hello` message. This session ticket mechanism
    enables the client to remember the whole session state, and the server becomes
    less engaged in maintaining a server-side session cache. The following screenshot
    shows an example for presenting an SSL session ticket:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting standard SSL client/server communication](graphics/B03711_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a custom SSL client/server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been dealing more with the SSL or TLS client. Now, let us have
    a look at the server side briefly. As you are already familiar with the TCP/UDP
    socket server creation process, let''s skip that part and just concentrate on
    the SSL wrapping part. The following code snippet shows an example of a simple
    SSL server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the server socket is wrapped with the `wrap_socket()` method,
    which uses some intuitive parameters such as `certfile`, `keyfile`, and `SSL`
    version number. You can easily generate the certificate by following any step-by-step
    guide found on the Internet. For example, [http://www.akadia.com/services/ssh_test_certificate.html](http://www.akadia.com/services/ssh_test_certificate.html)
    suggests to generate the SSL certificate in a few steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make a simplified version of a SSL client to talk with the above
    SSL server. The following code snippet shows an example of a simple SSL client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Running the client/server will show output similar to the following screenshot.
    Can you see any difference in comparison to our last example client/server communication?
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a custom SSL client/server](graphics/B03711_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inspecting interaction between a custom SSL client/server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us inspect the SSL client/server interaction once again in order to observe
    the differences. The first screenshot shows the entire communication sequence.
    In the following screenshot we can see that the server's `Hello` and certificate
    are combined in the same message.
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting interaction between a custom SSL client/server](graphics/B03711_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The client''s **Client Hello** packet looks pretty similar to our previous
    SSL connection, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting interaction between a custom SSL client/server](graphics/B03711_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The server''s **Server Hello** packet is a bit different. Can you identify
    the differences? The cipher specification is different that is `TLS_RSA_WITH_AES_256_CBC_SHA`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting interaction between a custom SSL client/server](graphics/B03711_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Client key exchange** packet also looks very familiar, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting interaction between a custom SSL client/server](graphics/B03711_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the **New Session Ticket** packet offered in
    this connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting interaction between a custom SSL client/server](graphics/B03711_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let's have a look at the application data. Is that encrypted? For the captured
    packet, it looks like garbage. The following screenshot shows the encrypted message
    that hides the real data. This is what we want to achieve using SSL/TLS.
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting interaction between a custom SSL client/server](graphics/B03711_07_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed basic TCP/IP socket programming using Python's
    `socket` and `ssl` module. We demonstrated how simple TCP sockets can be wrapped
    with TLS and used to carry encrypted data. We also found the ways to validate
    the authenticity of a remote server using SSL certificates. Some other minor issues
    around socket programming, such as non-blocking socket I/O were also presented.
    The detailed packet analysis in each section helps us to understand what happens
    under the hood in our socket programming exercises.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the socket server design, particularly
    the popular multithreaded and event-driven approaches will be touched upon.
  prefs: []
  type: TYPE_NORMAL
