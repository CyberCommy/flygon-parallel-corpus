- en: Combining Node.js with the Frontend
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about frontend frameworks and Node.js, let's wire together
    both the ends. We'll build three small applications for (almost) full-stack functionality
    to demonstrate our knowledge. After all, the frontend and backend want to know
    each other! It's going to be our first foray into working with these technologies
    together, so be sure to give yourself space and time to learn, because these are
    heavy but extremely important topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the architecture handshake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The frontend and Node.js: React and image upload'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a recipe book with APIs and JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a restaurant database with Yelp and Firebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Be prepared to work with the code provided in the `Chapter-15` directory of
    the repository: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15).
    As we''ll be working with command-line tools, also have your Terminal or command-line
    shell available. We''ll need a modern browser and a local code editor.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the architecture handshake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've had experience with JavaScript both on the frontend and the backend
    with Node.js, let's discuss what it really *means* to have the two halves tied
    together. We know that JavaScript on the frontend is great for user interactions,
    visuals, data validation, and other user-experience related pieces. Node.js on
    the backend is a powerful server-side language that helps us do pretty much anything
    we need from most other server-side languages. So, what does combining these two
    ends look like in theory?
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering why there even *are *two ends of an application. We understand
    that PythonNode.js, and JavaScript all do different tasks and act in either the
    frontend or the backend, but what is the theory behind this? The answer is this:
    there is a principle of software engineering known as the *separation of concerns*,
    which basically states that each piece of a program should do one or a few tasks
    and do them well. Instead of a monolithic application, the idea of a modular system
    that reacts well to scale is, in practice, a more efficient system. In this chapter,
    we''ll be creating three applications that use this principle.'
  prefs: []
  type: TYPE_NORMAL
- en: The frontend and Node.js - React and image upload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin with tying together React and Node. Be prepared to follow along
    with the solution code at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15/photo-album](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15/photo-album).
    We''re going to build a photo album app that will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/56812bfe-0905-4732-8d60-6ba855c16ae1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 - Our photo gallery
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by exploring the architectural layout, then we'll review the React
    code, and finally we'll examine the Express backend.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This application will be built using Node.js on the backend to store our uploaded
    files and React on the frontend. But how do we do that? Conceptually, we need
    to tell React to use an Express app to feed React information and to consume the
    files that we have sent. To accomplish this, we use a *proxy* as defined in the
    `package.json` file. It basically looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c279a2d6-5c0c-49da-8b52-784590d62225.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 - Proxying
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re not familiar with the idea of a proxy, essentially it means, in
    computing, the same thing that it does in English: an actor that does an action
    on behalf of another actor. It''s, in essence, a middleman, and as this diagram
    shows it can be thought of as a middleman for our purposes. Since React and frontend
    JavaScript can''t interact with the filesystem or do the other important things
    we learned about in [Chapter 12](e48b0352-8340-4645-8a70-8ca96199a6fa.xhtml),
    *Node.js vs Python*, and [Chapter 13](57b3ea57-b927-47f6-b07e-d1dd11796e1a.xhtml), *Using
    Express,* we need to use our abilities to tie *together* the frontend and backend.
    Hence, the idea of a proxy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at one line in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What this is telling React to do is route certain requests to our Express application.
    If you''re following along with the code from GitHub, this means that we actually
    have to execute a few different `npm` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the packages for Express. Start in the `photo-album` directory:
    `npm install`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Begin the Express server: `npm start`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In another terminal window, `cd` into the `client` directory and run `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, begin the React app with `npm start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we access `http://localhost:3000`, we have our Photo Album app ready to
    use. Try uploading a photo by selecting a file and clicking Upload. The UI will
    also refresh and display the photo you just uploaded. Congratulations! It's an
    end-to-end application!
  prefs: []
  type: TYPE_NORMAL
- en: So what is this code doing? Let's dissect it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll look at the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating the React JSX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open `client/src/components/upload/Upload.jsx`. We''ll start by examining the
    contents of the `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, it''s a basic HTML form. The only parts of this that are React-specific
    are the click handlers. Let''s look at the `onClick` method for the form: `this.uploadForm`.
    If we look at that method, we''ll see the real functionality of our upload form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Are you ready to look at the Node.js Express routes?
  prefs: []
  type: TYPE_NORMAL
- en: Deciphering the Express application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open `routes/upload.js`. It''s fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To make our lives a little easier, we're using a form handler package called
    Formidable. When a POST request comes through to the `/upload` endpoint, it's
    going to run this code. When a form is received via Ajax, our promises are listening
    for files and will trigger the `fileBegin` and `file` events that will write the
    file to disk and then signal success, respectively. This is the method that our
    upload form used in `Upload.jsx` and how the two sides of our application are
    tied together to do something that JavaScript on the frontend can't do alone—access
    the filesystem of a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upload a few images with the frontend. You''ll notice that they''ll be stored
    in `public/images`, just as we read in our code. Note that this system is very
    simplistic: it does not check to see if it''s an image file and blindly accepts
    what we send to it and stores it in the filesystem. In practice, **this is dangerous**.
    When working with user input, it is *always* necessary to anticipate attacks and
    possibly malicious files. While the methods of securing your web application are
    somewhat out of the scope of this book, a general tenet to keep in mind is: *don''t
    trust the user*. We''ve examined methods to validate input on the frontend, and
    while that''s useful, it''s vital to also check it on the backend. Some possible
    methods of threat reduction would be to whitelist certain file extensions, blacklist
    others, and use a sandboxed environment to run analysis code on the uploaded file
    to determine if, in fact, it is a harmless image file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve uploaded our image, let''s move on to the retrieval aspect
    of our application. Open `routes/gallery.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, this isn't too difficult to decipher. In our GET route, we're first
    examining the filesystem to see if there are files that we have access to. If
    there's an error for some reason, such as incorrect permissions, we're going to
    send an error to the frontend and abort. Otherwise, we're going to format our
    return data and send it! Easy peasy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next method defines the DELETE functionality, and it''s a simple filesystem
    unlink method. The frontend for this isn''t very sophisticated: if you click an
    image in our gallery, it will delete the photo. Of course, in practice, you''d
    want some sort of better user interface and confirmation messages, but for our
    purposes, this is sufficient.'
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to your first end-to-end application!
  prefs: []
  type: TYPE_NORMAL
- en: Onward to our next application!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a recipe book with APIs and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Part of the beauty of using a backend is to facilitate communication between
    your application, the filesystem, and APIs. Previously, all the work we did was
    constrained to the frontend with no persistence. We''ll now make a recipe book
    application that saves our information in JSON format. Don''t worry, we''ll get
    to using databases in [Chapter 18](b36b27d1-f6cf-4382-ac73-f21a1aeabd3d.xhtml),
    *Node.js and MongoDB*. For now, we''ll use local files. Here''s what we''re going
    to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9a54d97b-58a7-4f23-8ffa-b4afb26f54c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 - Our recipe book
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we'll be setting up credentials using a third-party API and
    then forge onward with the code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clone the starter code at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15/recipe-book/](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15/recipe-book/).
    Be sure to execute `npm install` both in that directory and inside `client`. We'll
    also need to do a few setup pieces to access our API. To access the Edamam API,
    sign up for a free API key at [https://developer.edamam.com/](https://developer.edamam.com/)
    for the Recipe Search API.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the root level of our project, create a `.env` file and populate it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that these are constructed as environment variables and don't have semicolons
    or spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step we''ll do is ensure our application can read these variables.
    Near the end of `app.js`, you''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This construction of `process.env.<variable name>` is how we access the environment
    variables in `.env`. The mechanism that provides this access is the `dotenv` package;
    you can see that it's included in `package.json`; environment variables in a file
    aren't included by default.
  prefs: []
  type: TYPE_NORMAL
- en: Why are we using an environment file? As we'll learn in [Chapter 17](655b37ac-84df-4d2b-abda-b9c88fe9f6f2.xhtml),
    *Security and Keys*, we don't want to expose our API keys in our code that we
    may commit to GitHub or similar, because that would allow anyone to use (and abuse)
    our keys. We must keep them secure, and if you noticed in the `.gitignore` file,
    I've listed the `.env` to *not* be committed in Git, which is why you had to create
    the file yourself. This is a best practice for sensitive information. While it
    can make sharing code between developers a bit trickier, it's always best to keep
    sensitive information separate from our code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test our API.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you read through `routes/tests.js`, you can see what exactly we''re doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our `fetch` call is hardcoded to search `cheesecake` (my favorite dessert… ask
    me for my recipe) and if we run it with `node routes/tests.js`, we'll see a bunch
    of JSON returned in the console. If you have any problems, be sure to check your
    API key.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know our API calls are working, let''s switch over to our frontend.
    Take a peek at `client/src/components/search/Search.jsx` and its `render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a simple form so far. Next, let''s look at the `submitSearch` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we''re going to use our proxy to submit our search from the form. After
    we get our results, we''re passing the JSON to the `handleSearchResults` method
    from the `props` that come from the parent component: `RecipeBook`. We''ll take
    a look at that later, but for now, let''s switch back to the Express application
    to look at what our search route is doing. Take a peek at `routes/search.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GET route is quite simple, actually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This should look a little similar to our test file. We''re using our `.env`
    file again for our search queries but this time we''re passing in the query string
    parameter for our search and handling errors. Our `data.on("end")` handler passes
    our results back to React to be used in `RecipeBook.jsx` in the `handleSearchResults`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We're parsing out the necessary data for our application and assigning it to
    the component's state. So far so good!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the recipe book''s `render` method for displaying our search results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We're using another ternary operator to conditionally render our results, if
    there are any, as a `<Recipe>` component. Our key attribute is simply a unique
    identifier that React wants items to have, but the `refresh` prop is an interesting
    one. Let's see where it's used by looking at the `Recipe` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render` method of our `Recipe` component is fairly standard: it uses a
    few Bootstrap components to render our nice little cards, but other than that
    it is unremarkable. The `save` method is what we really want to investigate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `const recipe` declaration may look a little strange, so let's unpack it.
    This is creating an object key/value pair, and for the key, we're using the recipe's
    title. Because it's a variable, we want to use square brackets to denote that
    it should be interpreted. We can't use a dot-property as a key, so our title will
    be a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of what a recipe in that construction may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It has all the information we specified before when we mapped together our object
    in `RecipeBook.jsx`. The next step in our process is saving the recipe to the
    filesystem with another `fetch` request to the Express server.
  prefs: []
  type: TYPE_NORMAL
- en: Back to Express we go, this time to `routes/recipes.js`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the file part by part. Outside of our Express methods, we have
    a `readData` method, which checks to see if our `recipes.json` file exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If it does not, it creates a file containing an empty array. Then it returns
    the contents of the file, whether empty or not, to the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our GET method consumes the data from `readData` and sends it in the response,
    in this case to `RecipeBook.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The second part of the `RecipeBook.render` method (which we didn't look at)
    is similar to the search results JSX, and it consumes this JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `save` method has a resemblance to our `readData` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it's also sending the JSON to the response so that when the item
    is saved, it also populates the saved recipes in `RecipeBook.jsx`. It probably
    goes without saying, but notice that we're using the `readData` method again instead
    of rewriting the same logic, keeping our code DRY.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that''s the logic of our application! We''ve successfully combined an API,
    Node.js, Express, and React for an end-to-end application. Next, we''ll create
    an application that is a bit more true to life: we''re going to create a restaurant
    searching application that saves to a cloud database that''s accessible through
    JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Making a restaurant database with Yelp and Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our applications up to this point have been fairly simple, storing information
    on the filesystem. However, in most cases you'll want it to be some sort of database
    instead of static files. We're going to be using Firebase, a cloud-based NoSQL
    database that plays well with JavaScript, but first, let's set up our React scaffold.
  prefs: []
  type: TYPE_NORMAL
- en: The starting line - creating a React app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve gone through this setup a few times before, so it should be no surprise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new React application with `npx create-react-app restaurant-finder`
    and we're ready to go!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your setup with `npm start` and access `http://localhost:3000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting set up with Firebase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we want to do is set up our Firebase account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please keep in mind that the user interface for Firebase (as with most websites)
    does change periodically, so I won''t be showing you screenshots for the signup
    process. If you run into any problems with the setup process, you can consult
    the documentation. Here''s the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://firebase.google.com](https://firebase.google.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't already have a Google account, you'll need to create one and then
    access the Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new project called `restaurant-database`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can choose to enable Google Analytics for the project; it's up to you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Project Overview page, we're going to use the </> button to access the
    setup instructions for a web app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, create an app nickname (you can use `restaurant-database`
    again) and you won't need to set up Firebase Hosting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next screen will present you with code that contains your Firebase configuration,
    but *we''re not going to follow the instructions to the letter* because we can
    use Node modules to help us! Do copy the information in the `firebaseConfig` variable,
    though: we''ll need it later.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When your database is created, go to the Database tab in the UI, select Realtime
    Database, and start it in **test mode**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should then see a screen similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/632bcc84-7961-490e-95f8-7b546c4edea7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 - Firebase's base test mode view
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re going to return to our command line and get ready to work with
    Firebase. Install the Firebase toolkit: `npm install firebase`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it for installation! Easy! Next, create a `.env` file at the root of
    our project and enter the credentials that you previously copied from `firebaseConfig`,
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note the prefix of `REACT_APP_`, the equals signs, quotes, and lack of trailing
    commas. Fill in your configuration similarly.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move further, let's test our database.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we''re going to create a couple React components. Create a `components`
    directory in `src` and within that, two directories named `database` and `finder`.
    We''ll start by creating our database reference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the database directory, create a `database.js` file. Note that it''s `js`,
    not `jsx`, because we''re not actually going to render any data. Instead, we''re
    going to return a variable to a `jsx` component. Your file should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note the prefix of `process.env` on each variable as well as the trailing commas. `process.env`
    specifies that the application should look at environment variables provided by `dotenv`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have`Finder.jsx`. Create this file in the `finder` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `App.js` file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, since we've just created our environment variables, we'll need to stop
    and start our React application again. This is not necessary for most of our React
    work, but it is necessary here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go ahead and access the app at `http://localhost:3000`. We should see just
    Let''s find some restaurants on the page, but if we go to Firebase, we''ll see
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/960f56b9-f09c-454b-9771-c6634fc3f876.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 - We have data in Firebase!
  prefs: []
  type: TYPE_NORMAL
- en: The data appears to be truncated, but you can click on it and see the whole
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Huzzah! We have Firebase working. Now for the rest of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can remove the test insertion from `Finder.jsx`. Here''s what we''re going
    to be making:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9e9c5a56-053f-4a6d-a7c5-c970353ec85b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 - Restaurant finder
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, we're going to be using the Yelp API. First of all, you'll
    need to go to [https://www.yelp.com/developers](https://www.yelp.com/developers)
    and sign up for a Yelp Fusion API key. Once you have it, we're going to store
    it in a new `.env` file in a new `api` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The Yelp Fusion API is not available in all countries, so if you cannot access
    it, please look in `Chapter-15` folder on GitHub for an alternative API usage
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Yelp API is a REST API and doesn''t allow connections from frontend JavaScript
    in order to protect your keys. So, like our recipe book, we''re going to create
    a small API layer to handle our requests. Unlike our recipe book, this will be
    fairly simple, so we''re not going to use Express. Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the root level of your project, we''re going to install a few tools for
    us to use: `npm install yelp-fusion dotenv react-bootstrap`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directory at the root level of your project called `api` and create
    an `api.js` file within it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re going to have a `.env` file inside our `api` directory as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you're using Git, *don't forget to add this to your* `.gitignore` *entries*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our `api.js` file will be fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, a lot of this should be familiar: we''re going to include a few packages
    such as the Yelp API in the way we''ve done before, and we''re going to define
    a few variables to help us. Next, we''re going to use the `createServer` method
    of `http` to create a very, very simple server to respond to our API requests.
    Inside it, we''re going to use the `parse` method of `url` to get our query string
    parameters which we will be passing to our API.'
  prefs: []
  type: TYPE_NORMAL
- en: The next piece, `client.search`, will be unfamiliar. This is pulled from the
    Yelp documentation and is specifically crafted to adhere to their API's requirements.
    Once we have an asynchronous response, we send it back to our requesting application.
    Don't forget to handle errors! Then we start the server on port `3001`. You can
    go ahead and start this server with `node api.js` and you'll see the console error
    message about it running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now turn our attention to the React portion of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `src` directory, we''ll have this file structure when we''re complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Many of these files were already created when we previously scaffolded our application,
    but some parts of the `components` directory are new.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create these files, and we''ll begin by exploring `Restaurant.jsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this isn''t new, and our recipe book''s structure can help us reason
    through this. We should break apart the `saveRestaurant` method, though, because
    it uses a few interesting pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we can deduce we'll be getting data from our component's `props`
    of the restaurant. This will be directly from our search results. Because of that,
    we'll need to massage our data just a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what a search result may look like from our `props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We save it to Firebase with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We're using the *spread operator* (the triple dots) to expand the object into
    its constituent key/value pairs so that we avoid a nested object in our database.
    We also have just a little touch of CSS to format our cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s turn our attention to the `Search` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In our constructor, we're doing something a little fun: *browser geolocation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you seen those little alert windows on certain websites when they ask
    to know your location? This is how those sites do it. If the browser supports
    geolocation, we''re going to use it and set our latitude and longitude from our
    browser. Otherwise, we''ll simply set it to `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The construction of the search endpoint should look familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you progress through our code, if you get a null value for latitude or longitude,
    you may need to fully exit the React application and restart it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to how our recipe book called to our Express application over a proxy,
    don''t forget to add this line to your `package.json` file: `"proxy": "http://localhost:3001"`.
    This is so that we can use `fetch`. These are the values we passed into `api.js`
    for our request to the Yelp API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re almost done with our application! Next up is the `Finder` component
    that we started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have some pretty standard pieces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As a new piece, let''s examine how we''re retrieving information from Firebase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: One of the interesting things about Firebase is that it's a real-time database;
    you don't always have to execute queries against it to retrieve the latest data.
    In this construction, we're telling the database to continually update the state
    of our component as the value of `/restaurants` changes. When we save a new restaurant
    and go to our Saved! tab, we'll see our new entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re bringing it full circle by using our other components here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When all is complete, we'll keep our `api.js` file running and start our React
    app with `npm start` and our app is complete!
  prefs: []
  type: TYPE_NORMAL
- en: It's time to wrap up this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve covered a *lot* of ground in this chapter. The power of JavaScript on
    both the frontend and the backend shows us that we can truly replace Python for
    many of our application needs. We''ve used a lot of React, but keep in mind that
    any frontend can be substituted here: Vue, Angular, and even frameworkless HTML,
    CSS, and JavaScript are at our disposal to create powerful web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the things to note when using JavaScript and APIs is that there are cases
    when we need a middleware layer, for example, when saving files or accessing REST
    APIs with keys. Combining Express for powerful routing with a basic Node.js script
    to interact with an API is just the beginning of what we can accomplish with JavaScript
    and Node.js tied together.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore webpack, a utility that allows us to logically
    combine and package our JavaScript application for deployment.
  prefs: []
  type: TYPE_NORMAL
