- en: Chapter 6. Architectural Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architectural patterns, sometimes referred to as an architectural style, provide
    solutions to recurring problems in software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Though similar to software design patterns, they have a broader scope, addressing
    various issues in software engineering as opposed to simply the development of
    software itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Model-View-Controller (MVC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service-oriented architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous queuing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message Queue pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model-View-Controller (MVC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MVC is the most common type of Architectural pattern that PHP developers encounter.
    Fundamentally, MVC is an Architectural pattern for implementing user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'It largely works around the following methodology:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This supplies the data to the application, whether it''s from a
    MySQL database or any other data store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: A Controller is essentially where the business logic is. The
    Controller handles whatever queries the View provides, using the Model to assist
    it in this behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: The actual content that is supplied to the end-user. This commonly
    is an HTML template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business logic for one interaction isn't strictly separated from another interaction.
    There is no formal separation between the different classes of an application.
  prefs: []
  type: TYPE_NORMAL
- en: It is critical to consider that the MVC pattern is principally a UI pattern,
    so it doesn't scale well throughout an application. That said, the rendering of
    UIs is increasingly being done via JavaScript applications, a single page JavaScript
    HTML app that simply consumes a RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using JavaScript, you may use a framework such as Backbone.js (Model-View-Presenter),
    React.js, or Angular to communicate with your backend APIs, though this will of
    course, require a JavaScript enabled web browser, which some of us can take for
    granted from our users.
  prefs: []
  type: TYPE_NORMAL
- en: In the event you exist in an environment where you cannot use a JavaScript app
    and must instead serve rendered HTML, it often is a good idea for your MVC app
    to simply consume a REST API. The REST API performs all the business logic, but
    the rendering of markup is done in the MVC app. Although this increases complexity,
    it offers a greater separation of responsibilities and as a result, you don't
    have HTML being merged with core business logic. That said, even within this REST
    API you need some form of separation of concerns, you need to be able to separate,
    the rendering of the markup from the actual business logic.
  prefs: []
  type: TYPE_NORMAL
- en: A key element to choosing an Architectural pattern suitable for an app is whether
    the complexity is appropriate for the size of the app. Thus, choosing an MVC framework
    should also be based on the complexity of the app itself and its intended complexity
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: Given the growth of infrastructure as code, it is possible to deploy the infrastructure
    of multiple web services in an entirely orchestrated fashion. Indeed, using containerization
    technology such as Docker, it is possible to deploy multiple architectures (such
    as an MVC application with a separate API service) with little overhead (no need
    to spin up a new server for each service).
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns is a vital trait when developing great architectures,
    which includes separating UI from business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'When thinking in terms of an MVC pattern, it is important to remember the interactions
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Model stores data, which is retrieved according to the query put by the
    Model and displayed by the View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The View generates outputs based on changes to the Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Controller sends the command to update the Model's state; it can also update
    the View associated to it to alter how a given Model is presented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or, it is commonly expressed using the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model-View-Controller (MVC)](graphics/image_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Don't use an MVC framework for the sake of using one, understand why they exist
    and where they can fit well into a use case. Remember that when you take on a
    bloated framework with lots of functionality, you are taking responsibility for
    maintaining the whole thing going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling in the components as you need them (that is, through Composer) is a
    far more practical approach to developing software with considerable business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service-oriented architectures largely consist of business logic in services
    that communicate with data repositories.
  prefs: []
  type: TYPE_NORMAL
- en: These services can be derived in different forms to build applications. These
    applications adopt these services in different formats to build various applications.
    Consider the services as Lego blocks that can be put together to build an application
    in a given format.
  prefs: []
  type: TYPE_NORMAL
- en: 'This description is rather crude; let me clarify further:'
  prefs: []
  type: TYPE_NORMAL
- en: Boundaries for services are explicit (they may separate web services on different
    domains, and so on.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services can inter-communicate using a common communication protocol (for example
    all use RESTful APIs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services are autonomous (they are decoupled and not related to another service
    in any way)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message processing mechanism and the schema are understandable by every
    other microservice (and therefore are often the same), but the programming environment
    can be different
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service-oriented architectures are inherently distributed, thus they can have
    higher up-front complexity than other architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservices architecture can be considered a subset of service-oriented
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, microservices form complex applications by composing them of
    small independent process which intercommunicate over a language-agnostic API
    that makes each services accessible to each other. Microservices can be individually
    deployed as services.
  prefs: []
  type: TYPE_NORMAL
- en: In microservices, the business logic is separated into self-contained loosely-coupled
    services. A key tenet of microservices is that each database should have their
    own database, which is vital to ensure that the microservices do not become tightly
    coupled to each other.
  prefs: []
  type: TYPE_NORMAL
- en: By reducing the complexity of a single service, we can aim to reduce the amount
    of points at which this service will fail. In theory, by having a single service
    comply with the Single Responsibility Principle, it is easier to debug and reduce
    chances of failure in our application as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, the CAP theorem dictates that it is impossible to guarantee
    consistency, availability, and partition tolerance concurrently in a given distributed
    computer system.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine two distributed databases both containing the e-mail address of a user.
    If we want to update this e-mail address, there is no way we can do so in a way
    that is instantaneously available across both databases with the e-mail consistently
    updated at the same time while not bringing the two datasets back together. In
    a distributed system we would have to either delay the access to the data to validate
    the data is consistent or present a non-updated copy of the data.
  prefs: []
  type: TYPE_NORMAL
- en: This makes traditional database transaction difficult. Thus, the best way to
    address data handling in a microservices architecture is to use an eventually
    consistent, event-driven architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Each service publishes an event whenever there is a change, and other services
    may subscribe to this. When an event is received, the data is accordingly updated.
    Thus, the application is able to maintain data consistency across multiple services
    without needing to use distributed transactions.
  prefs: []
  type: TYPE_NORMAL
- en: In order to see how such an architecture for inter-process communication can
    be implemented for communication between microservices, please see the *Message
    Queue pattern (Getting started with RabbitMQ)* section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, one simple way to mitigate against this restriction is simply
    by using a time verification system in order to verify the data is consistent.
    Thus, we surrender availability for consistency and partition tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: If you can foresee this as a problem in a given microservices architecture,
    it is often best to group the services that need to satisfy the CAP theorem together
    into a single service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a pizza delivery web application that consists of the following
    microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: User
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Billing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restaurant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pizza
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviews
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we could have the following user journey:'
  prefs: []
  type: TYPE_NORMAL
- en: The user is authenticated using the User microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user can select offers using the Deals microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user selects the pizza they want to order using the Recipe microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selected pizza(s) are added to the cart using the Cart microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Billing credentials optimated through the Billing microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user pays using the Payments microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The order is sent to the restaurant using the Restaurant microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the Restaurant has cooked the food, the Delivery microservice sends a driver
    to collect the food and deliver it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the Delivery microservice indicates the food has been delivered, the user
    is invited to complete a review using the Review microservice (which notifies
    the user using the User microservice).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The web front of this is wrapped together using the Frontend microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Frontend microservice can simply be a microservice that consumes the other
    microservices and presents the content to the web frontend. This frontend may
    communicate with the other microservices over REST, perhaps implemented in a JavaScript
    client in the browser, or a PHP app that merely acts as a consumer of other microservice
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, it is often a good idea to place a gateway between the frontend
    consumer of your API and the backend. This allows us to put some middleware before
    communication to microservices is ascertained; for example, we can use the gateway
    to query the User microservice to check that a user is authorized before allowing
    access to the Cart microservice.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using JavaScript to communicate directly with the microservices, you
    may find cross-origin issues when your web frontend tries to communicate with
    microservices on different hostnames/ports; a microservice gateway can help prevent
    this by putting the gateway on the same origin as the web frontend itself.
  prefs: []
  type: TYPE_NORMAL
- en: In exchange for this convenience of a gateway, you'll likely feel the drawbacks
    in terms of the fact that you will have another system to worry about and additional
    response time (though you can add caching at the gateway level should you want
    to improve performance there).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the addition of a gateway, our architecture could now look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices](graphics/image_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Increasingly emerging in PHP are micro-frameworks such as Lumen, Silex, and
    Slim; these are API-oriented frameworks that make it easy to build microservices
    to support our applications. That said, you may often be better to adopt an even
    more lightweight approach and merely pull in the components you require through
    Composer as and when you need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that adding another technology or framework adds additional complexity
    to your overall situation. Think not only of the technical reasons of implementing
    a new solution but also how this will benefit the customer and the architecture.
    Microservices aren''t an excuse to add unnecessary complexity: *Keep It Simple,
    Stupid*.'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous queueing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message queues provide an asynchronous communication protocol. In an asynchronous
    communication protocol, the sender and the receiver need not interact with the
    message queue simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Typical HTTP, on the other hand, is a synchronous communication protocol, meaning
    that the client is blocked until the operation is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this; you call someone on the phone, then you wait for the phone to
    ring and the person you talk to listens to whatever you have to say then and there.
    At the end of the communication you say *goodbye* and that is acknowledged by
    someone on the other end saying *goodbye* back. This can be considered synchronous
    as you don't do anything until you get a response from the person you're communicating
    with to end the communication.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you were to send a text message to someone instead, after you send
    that message you can go off and do whatever behavior you please; you can receive
    a message in return to the one you sent when they want to communicate back to
    you. While someone is drafting the response to send back, you can go off and do
    whatever you want. While you don't communicate directly with the sender, you do
    still maintain synchronous communication with your phone, which notifies you when
    you get a new message (or simply check your phone every few minutes); but the
    communication with the other party itself is asynchronous. Neither party needs
    to know anything about the other party, they just merely are looking out for their
    own text messages in order to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Message Queue pattern (Getting started with RabbitMQ)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RabbitMQ is a message broker; it accepts and forwards messages. Here, let's
    configure it so that we can send messages from one PHP script to another.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we are giving a package to a courier in order for them to give to the
    client; RabbitMQ is the courier, while the scripts are the individuals receiving
    and sending the packages respectively.
  prefs: []
  type: TYPE_NORMAL
- en: As the first step, let's install RabbitMQ; I'm going to demonstrate this on
    an Ubuntu 14.04 system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we need to add the RabbitMQ APT repository to our `/etc/apt/sources.list.d`
    folder. This can fortunately be actioned with a command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the repository may be liable to change; if it does, you can find the
    latest details at [https://www.rabbitmq.com/install-debian.html](https://www.rabbitmq.com/install-debian.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can optionally also add the RabbitMQ public key to the trusted key list
    to avoid any warnings indicating packages are unsigned when we install or upgrade
    the packages through the `apt` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, let''s just run an `apt-get update` command to fetch the packages from
    the new repository we''ve included. After this is done we can get around to installing
    the package we need using the `apt-get install rabbitmq-server` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Be sure to accept the various prompts when asked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After installation, you may run `rabbitmqctl status` to check the status of
    the application to check it''s running OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make our lives easier for a second. We can use a web GUI to manage RabbitMQ;
    simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now see an admin interface at  `<your server IP here>:15672`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But before we can log in, we're going to have to create some login credentials.
    In order to do this we're going to have to head back to the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we''ll need to set a new account with a username of `junade` and a
    password of `insecurepassword`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can add some admin privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning to the login page, we can now see our cool admin interface after
    we enter in these credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the web interface for the RabbitMQ service, accessible through our web
    browser
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can test what we''ve installed. Let''s start off by writing a `composer.json`
    file for this new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: RabbitMQ uses the **advanced message queuing protocol** (**AMQP**), which is
    why we're installing a PHP library that will essentially help us communicate with
    it over this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we can write some code to send a message using the RabbitMQ message
    broker we just installed:'
  prefs: []
  type: TYPE_NORMAL
- en: This assumes the port is `5672` and the install is on `localhost`, which may
    change depending on your circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a little PHP script to utilize this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So let's break this down a little bit. In the first few lines, we just include
    the library from the Composer `autoload` and `state` which namespaces we're going
    to use. When we instantiate the `AMQPStreamConnection` object we actually connect
    to the message broker; we can then create a new channel object that we then use
    to declare a new queue on. We declare a queue by calling the `queue_declare` message.
    The durable option allows messages to survive reboots in RabbitMQ. Finally, we
    just go ahead and send out our message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now run this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you now go to the web interface for RabbitMQ, click the queues tab and toggle
    the Get Message(s) dialog; you should be able to pull in the message we just sent
    to the broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using this web page in the interface, we can extract messages from the queue
    so we can look at their contents
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is just half the story. We now need to actually retrieve this
    message using another app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a `receive.php` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that the first few lines are identical to our sending script; we even re-declare
    the queue in case this receive script is run before the `send.php` script is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our `receive.php` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In another bash Terminal, let''s run the `send.php` script a few times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Accordingly, in the `receive.php` Terminal tab, we can now see we''ve received
    the messages we''ve been sending:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The RabbitMQ documentation uses the following diagram to describe the basic
    accepting and forwarding of messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Publish-Subscriber pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Publish-Subscriber pattern (or Pub/Sub for short) is a design pattern whereby
    messages aren't directly sent from publisher to subscribers; instead, publishers
    push out the message without any knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: In RabbitMQ, the *producer* never sends any messages directly to the queue.
    Quite often, the producer doesn't even know if the message will end up in a queue
    at all. Instead, the producer must send messages to an *exchange*. It receives
    messages from producers then pushes them out to queues.
  prefs: []
  type: TYPE_NORMAL
- en: The *consumer* is the application that will receive the messages.
  prefs: []
  type: TYPE_NORMAL
- en: The exchange must be told exactly how to handle a given message, and which queue(s)
    it should be appended to. These rules are defined by the *exchange type*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RabbitMQ documentation describes a Publish-Subscriber relationship (connecting
    the publisher, exchange, queue, and consumer) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publish-Subscriber pattern](graphics/image_06_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A *direct* exchange type delivers messages based on a routing key. It can be
    used both for one-to-one and one-to-many forms of routing, but it is best suited
    to a one-to-one relationship.
  prefs: []
  type: TYPE_NORMAL
- en: A *fanout* exchange type routes messages to all queues that are bound to it and
    the routing key is completely ignored. Effectively, you cannot differentiate between
    which workers messages will be distributed to based on the routing key.
  prefs: []
  type: TYPE_NORMAL
- en: A *topic* exchange type works by routing messages to one or many queues on the
    basis of a messaging routing queue and the pattern that was used to bind a queue
    to an exchange. This exchange has the potential to work well when are multiple
    consumers/applications that want to choose the type of messages they want to receive,
    usually in a many-to-many relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The *headers* exchange type is commonly used to route on a set of attributes
    that are better expressed in message headers than the routing queue. Instead of
    using routing keys, the attributes to the route are based on the headers attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test a Pub/Sub queue, we will be using the following scripts. They
    are similar to the one in the example earlier, except I have modified them so
    that they use exchanges. Here is our `send.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our `receive.php` file. Like before, I have modified this script so
    that it also uses exchanges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's test these scripts. We'll first need to have our `receive.php` script
    running, then we can send messages across using our `send.php` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s trigger our `receive.php` script so that it starts running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publish-Subscriber pattern](graphics/image_06_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After this is complete we can then move on to sending messages by running our
    `send.php` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publish-Subscriber pattern](graphics/image_06_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will now populate our Terminal running `receive.php` with the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publish-Subscriber pattern](graphics/image_06_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Architectural patterns. Starting with MVC,
    we learned the benefits and challenges of using UI frameworks and discussed how
    we can decouple our UI from our business logic in a stricter fashion.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved onto SOA and learned how this compared to microservices and where
    such architectures make sense, given the challenges distributed systems pose.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we did an in-depth tour of queuing systems, where they are appropriate,
    and how you can implement them in RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: In the next, and then the final chapter, we'll cover the best practice use conditions
    of Architectural patterns.
  prefs: []
  type: TYPE_NORMAL
