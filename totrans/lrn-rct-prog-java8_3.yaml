- en: Chapter 3. Creating and Connecting Observables, Observers, and Subjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxJava's `Observable` instances are the building blocks of reactive applications,
    and this advantage of RxJava is beneficial. If we have a source `Observable` instance,
    we could chain logic to it and *subscribe* for the result. All we need is this
    initial `Observable` instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the browser or in a desktop application, user input is already represented
    by events that we can handle and forward through `Observable` instances. But it
    would be great to turn all of our data changes or actions into `Observable` instances,
    not just user input. For example, when we read data from a file, it would be neat
    to look at every line read or every sequence of bytes as a message that can be
    emitted through an `Observable` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look in detail at how different data sources can be transformed into `Observable`
    instances; it doesn't matter if they are external (files or user input) or internal
    (collections or scalars). What's more, we'll learn about the various types of
    `Observable` instances, depending on their behavior. Another important thing that
    we'll learn is how and when to unsubscribe from `Observable` instances and how
    to use subscriptions and `Observer` instances. Additionally, we'll present Subject
    type and its usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Observable` factory methods—`just`, `from`, `create`, and others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observers and subscribers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot and cold observables; connectable observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What subjects are and when to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable` creation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of ways to create `Observable` instances from different sources.
    In principle, an `Observable` instance could be created using the `Observable.create(OnSubscribe<T>)`
    method, but there are many simple methods, implemented with the idea of making
    our life better. Let's look at some of them.
  prefs: []
  type: TYPE_NORMAL
- en: The Observable.from method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Observable.from` method can create an `Observable` instance from different
    Java structures. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This piece of code creates an `Observable` instance from a `List` instance.
    When the `subscribe` method is called on the `Observable` instance, all of the
    elements contained in the source list are emitted to the subscribing method. For
    every call to the `subscribe()` method, the whole collection is emitted from the
    beginning, element by element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will print the colors twice with different formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The true signature of this version of the `from` method is `final static <T>
    Observable<T> from(Iterable<? extends T> iterable)`. This means that an instance
    from any class, implementing the `Iterable` interface can be passed to this method.
    These include any Java collection, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This turns the contents of a folder to events to which we can subscribe. That's
    possible because the `DirectoryStream` parameter is an `Iterable` instance. Note
    that on every call to the `subscribe` method of this `Observable` instance, its
    `Iterable` source's `iterator()` method is called to obtain a new `Iterator` instance
    to be used to traverse the data from the beginning. With this example, a `java.lang.IllegalStateException`
    exception will be thrown on the second call to the `subscribe()` method, because
    the `iterator()` method of the `DirectoryStream` parameter can be called only
    once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another overload of the `from` method used to create `Observable` instances
    from arrays is `public final static <T> Observable<T> from(T[] array)`, and an
    example of using `Observable` instances is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Observable.from()` method is very useful for creating the `Observable`
    instances from collections or arrays. But there are cases when we need to create
    the `Observable` instance from a single object; for these, the `Observable.just()`
    method can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for the examples of using the `Observable.from()` method can
    be viewed and downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesWithFrom.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesWithFrom.java).
  prefs: []
  type: TYPE_NORMAL
- en: The Observable.just method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `just()` method emits its parameter(s) as `OnNext` notifications, and after
    that, it emits an `OnCompleted` notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, one letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or a sequence of letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first piece of code prints `S` and a new line, and the second prints the
    letters on a single line and adds a new line on completion. The method allows
    up to nine arbitrary values (objects of the same type) to be observed through
    reactive means. For example, say we have this simple `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print the full name of a `User` instance like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is not very practical but showcases putting data in the `Observable` instance
    context and taking advantage of the `map()` method. Everything can become an event.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few more convenient factory methods, usable in all kinds of situations.
    Let's take a look at them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code of the example of the `Observable.just()` method can be viewed/downloaded
    at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesUsingJust.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesUsingJust.java).
  prefs: []
  type: TYPE_NORMAL
- en: Other Observable factory methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will inspect a few methods that can be used in combination with transforming
    operators such as flatMap or combining operators such as `.zip` file (more about
    this in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to examine their results, we will use the following method for creating
    subscriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The idea of the preceding method is to *subscribe* to an `Observable` instance
    and label it with a name. On *OnNext*, it prints the value prefixed with the name;
    on *OnError*, it prints the error together with the name; and on *OnCompleted*,
    it prints `'ended!'` prefixed with the name. This helps us debug the results.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code of the preceding method can be found at [https://github.com/meddle0x53/learning-rxjava/blob/4a2598aa0835235e6ef3bc3371a3c19896161628/src/main/java/com/packtpub/reactive/common/Helpers.java#L25](https://github.com/meddle0x53/learning-rxjava/blob/4a2598aa0835235e6ef3bc3371a3c19896161628/src/main/java/com/packtpub/reactive/common/Helpers.java#L25).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code introducing the new factory methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what''s happening in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Observable<Long> Observable.interval(long, TimeUnit, [Scheduler])`: This method
    creates an `Observable` instance that will emit sequential numbers at given intervals.
    It can be used to implement periodic polling, or continuous status logging, by
    just ignoring the number emitted and emitting useful messages. What''s special
    about this method is that it''s running on a *computation thread* by default.
    We can change that by passing a third argument to the method—a `Scheduler` instance
    (more about `Scheduler` instances in [Chapter 6](ch06.html "Chapter 6. Using Concurrency
    and Parallelism with Schedulers"), *Using Concurrency and Parallelism with Schedulers*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable<Long> Observable.timer(long, long, TimeUnit, [Scheduler])`: The
    `interval()` method begins emitting numbers only after it has waited for the specified
    time interval to pass. What if we want to tell it at what time exactly to begin
    working? We can do this using this `timer()` method. Its first argument is the
    starting time, and the second and the third are for interval setup. Again, it
    is executed on the *computation thread* by default, and again, this is configurable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable<Long> Observable.timer(long, TimeUnit, [Scheduler])`: This one
    just emits the output `''0''` after a given amount of time on the *computation
    thread* (by default). After that, it emits a *completed* notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<T> Observable<T> Observable.error(Throwable)`: This emits just the error
    passed to it as an *OnError* notification. This is similar to the ''`throw`''
    keyword in the classical, imperative Java world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<T> Observable<T> Observable.empty()`: This one emits no items, but it emits
    a `OnCompleted` notification immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<T> Observable<T> Observable.never()`: This does nothing. It sends no notifications
    to its `Observer` instances, and even the `OnCompleted` notification is not sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable<Integer>` `Observable.range(int, int, [Scheduler])`: This method
    sends sequential numbers beginning with the first parameter passed. The second
    parameter is the number of the emissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This program will print the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `interval Observable` instance doesn't send the *OnCompleted*
    notification. The program ends after two seconds and the `interval Observable`
    instance begins emitting after 500 milliseconds, every 500 milliseconds; thus,
    it emits three *OnNext* notifications. The `timed interval Observable` instance
    begins emitting immediately after its creation and emits every second; thus, we've
    got two notifications from it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code of the preceding example can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesUsingVariousFactoryMethods.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesUsingVariousFactoryMethods.java).
  prefs: []
  type: TYPE_NORMAL
- en: All of these methods are implemented using the `Observable.create()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The Observable.create method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the signature of the method first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It takes a parameter of type `OnSubscribe`. This interface extends the `Action1<Subscriber<?
    super T>>` interface; in other words, this type has only one method, taking one
    argument of type `Subscriber<T>` and returning nothing. This function will be
    called every time the `Observable.subscribe()` method is invoked. Its argument,
    an instance of the `Subscriber` class, is in fact the observer, subscribing to
    the `Observable` instance (here, the `Subscriber` class and Observer interface
    have the same role). We'll be talking about them later in this chapter). We can
    invoke the `onNext()`, `onError()`, and `onCompleted()` methods on it, implementing
    our own custom behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easier to comprehend this with an example. Let''s implement a simple
    version of the `Observable.from(Iterabale<T>)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The method takes an `Iterable<T>` parameter as an argument and returns an `Observable<T>`
    parameter. The behavior is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When an `Observer/Subscriber` instance subscribes to the resulting `Observable`
    instance, an `Iterator` instance is retrieved from the `Iterable` source. The
    `Subscriber` class actually implements the `Observer` interface. It is an abstract
    class, and the `on*` methods are not implemented by it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While there are elements, they are emitted as `OnNext` notifications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And when all the elements are emitted, an `OnCompleted` notification is dispatched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If at any time an error occurs, an `OnError` notification is dispatched with
    the error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a very simple and naive implementation of the behavior of the `Observable.from(Iterable<T>)`
    method. The Reactive Sum described in the first and second chapters is another
    example of the power of the `Observable.create` method (used by `CreateObservable.from()`).
  prefs: []
  type: TYPE_NORMAL
- en: But as we saw, the logic passed to the `create()` method is triggered when the
    `Observable.subscribe()` method is invoked on the `Observable` instance. Until
    now, we were creating `Observable` instances and *subscribing* to them with this
    method. It is time to look at it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing and unsubscribing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Observable.subscribe()` method has many overloads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`subscribe()`: This one ignores all the emissions from the `Observable` instance
    and throws an `OnErrorNotImplementedException` exception if there is an `OnError`
    notification. This can be used to only trigger the `OnSubscribe.call` behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe(Action1<? super T>)`: This only subscribes to `onNext()` method-triggered
    updates. It ignores the `OnCompleted` notification and throws an `OnErrorNotImplementedException`
    exception if there is an `OnError` notification. It is not a good choice for real
    production code, because it is hard to guarantee that no errors will be thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe(Action1<? super T>, Action1<Throwable>)`: This is the same as preceding
    one, but the second parameter is called if there is an `OnError` notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe(Action1<? super T>,Action1<Throwable>, Action0)`: This is the same
    as the preceding one, but the third parameter is called on `OnCompleted` notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe(Observer<? super T>)`: This uses its `Observer` parameter''s `onNext/onError/onCompleted`
    methods to observe the notifications from the `Observable` instance. We used this
    in the first chapter while implementing "The Reactive Sum".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe(Subscriber<? super T>)`: This is the same as the preceding one,
    but the `Subscriber` implementation of the `Observer` interface is used to observe
    notifications. The `Subscriber` class provides advanced functionality, such as
    unsubscription (cancellation) and backpressure (flow control). Actually, all the
    preceding methods call this one; that''s why we will be referring to it when talking
    about `Observable.subscribe` from now on. The method ensures that the `Subscriber`
    instance passed sees an `Observable` instance, complying with the following **Rx
    contract**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*"Messages sent to instances of the Observer interface follow the following
    syntax:*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*onNext* (onCompleted | onError)?*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*This syntax allows observable sequences to send any number (0 or more) of
    `OnNext()` method messages to the Subscriber, optionally followed by a single
    success (`onCompleted`) or failure (`onError`) message. The single message indicating
    that an observable sequence has finished ensures that consumers of the observable
    sequence can deterministically establish that it is safe to perform cleanup operations.
    A single failure further ensures that abort semantics can be maintained for operators
    that work on multiple observable sequences".*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – part of RxJava's JavaDoc.
  prefs: []
  type: TYPE_NORMAL
- en: This is done internally by using a wrapper around the passed `Subscriber` instance—`SafeSubscriber`.
  prefs: []
  type: TYPE_NORMAL
- en: '`unsafeSubscribe(Subscriber<? super T>)`: This is the same as the preceding
    one but without the **Rx contract** protection. It is meant to help implement
    custom operators (see [Chapter 8](ch08.html "Chapter 8. Resource Management and
    Extending RxJava"), *Resource Management and Extending RxJava*) without the additional
    overhead of the `subscribe()` method''s protections; using this method to observe
    an `Observable` instance in general code is discouraged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these methods return results of type `Subscription` that can be used
    for *unsubscribing* from the notifications emitted by the `Observable` instance.
    Unsubscribing usually cleans up internal resources associated with a subscription;
    for example, if we implement an HTTP request with the `Observable.create()` method
    and want to cancel it by a particular time, or we have an `Observable` instance
    emitting a sequence of numbers/words/arbitrary data infinitely and want to stop
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Subscription` interface has two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void unsubscribe()`: This is used for *unsubscribing*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isUnsubscribed()`: This is used to check whether the `Subscription`
    instance is already *unsubscribed*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The instance of the `Subscriber` class, passed to the `Observable.create()`
    method''s `OnSubscribe()` method, implements the `Subscription` interface. So,
    while coding the behavior of the `Observable` instance, *unsubscribing* and checking
    whether `Subscriber` is subscribed can be done. Let''s update our `Observable<T>
    fromIterable(Iterable<T>)` method implementation to react on *unsubscribing*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The new thing here is that the `Subscription.isUnsubscribed()` method is used
    to determine whether the data emission should be terminated. We check whether
    the `Subscriber` is already *unsubscribed* on every iteration, because it can
    *unsubscribe* at any time and we won't need to emit anything after that. After
    everything is emitted, if the Subscriber is already *unsubscribed*, the `onCompleted()`
    method is skipped. If there is an exception , it is only emitted as an `OnError`
    notification if the `Subscriber` instance is still *subscribed*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how *unsubscribing* works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what''s happening in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: The data source is a huge file because we need something that takes some time
    to be iterated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the subscriptions to the `Observable` instance will take place on another
    *thread* because we will want to *unsubscribe* on the main thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `subscribePrint()` method defined in this chapter is used, but it is modified
    to return the `Subscription`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The subscription is used to *unsubscribe* from the `Observable` instance, so
    the whole file won't be printed and there are markers showing when the *unsubscription*
    is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So most of the file's content is skipped. Note that it is possible for something
    to be emitted right after *unsubscribing*; for example, if the `Subscriber` instance
    *unsubscribes* right after the check for *unsubscribing* and the program is already
    executing the body of the `if` statement, checking whether the user is unsubscribed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code of the preceding example can be downloaded/viewed at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/ObservableCreateExample.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/ObservableCreateExample.java).
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that the `Subscriber` instances have a `void add(Subscription
    s)` method. Every subscription passed to it will be automatically *unsubscribed*
    when the `Subscriber` is *unsubscribed*. This way, we can add additional actions
    to the `Subscriber` instance; for example, actions that should be executed at
    *unsubscribing* (similar to the try—finally construction in Java). This is how
    *unsubscribing* works. In [Chapter 8](ch08.html "Chapter 8. Resource Management
    and Extending RxJava"), *Resource Management and Extending RxJava*, we'll be dealing
    with resource management. We'll learn how `Observable` instances can be attached
    to `Subscriber` instances through a `Subscription` wrapper, and how calling *unsubscribe*
    will release any allocated resources.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic we'll be covering in this chapter is related to subscribing behavior.
    We will be talking about hot and cold `Observable` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Hot and cold Observable instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at the previous examples implemented using the `Observable.create()`,
    `Observable.just()`, and `Observable.from()` methods, we can say that until someone
    subscribes to them, they are inactive and don't emit anything. However, each time
    someone subscribes, they start emitting their notifications. For example, if we
    subscribe three times to an `Observable.from(Iterable)` object, the `Iterable`
    instance will be iterated *three* times. The `Observable` instances behaving like
    that are called cold Observable instances.
  prefs: []
  type: TYPE_NORMAL
- en: All of the factory methods we've been using in this chapter return cold Observables.
    Cold Observables produce notifications on demand, and for every Subscriber, they
    produce *independent* notifications.
  prefs: []
  type: TYPE_NORMAL
- en: There are `Observable` instances which, when they start emitting notifications,
    it doesn't matter if there are subscriptions to them or not. They continue emitting
    them until completion. All the subscribers receive the same notifications, and
    by default, when a Subscriber *subscribes*, it doesn't receive the notifications
    emitted before that. These are hot Observable instances.
  prefs: []
  type: TYPE_NORMAL
- en: We can say that cold Observables generate notifications for each subscriber
    and hot Observables are always running, broadcasting notifications to all of their
    subscribers. Think of a hot Observable as a radio station. All of the listeners
    that are listening to it at this moment listen to the same song. A cold Observable
    is a music CD. Many people can buy it and listen to it independently.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned, there are a lot of examples in this book that use cold Observables.
    What about hot Observable instances? If you remember when we implemented 'The
    Reactive Sum' in the first chapter, we had an `Observable` instance that was emitting
    every line the user had typed in the standard input stream. This one was hot,
    and we forked two `Observable` instances from it, one for the collector `a` and
    one for `b`. They received the same input lines and filtered only the ones they
    were interested in. This input `Observable` instance was implemented using a special
    type of `Observable`, called `ConnectableObservable`.
  prefs: []
  type: TYPE_NORMAL
- en: The ConnectableObservable class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These `Observable` instances are inactive until their `connect()` method is
    called. After that, they become hot Observables. The `ConnectableObservable` instance
    can be created from any `Observable` instance by calling its `publish()` method.
    In other words, the `publish()` method can turn any cold Observable into a hot
    one. Let''s look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Nothing will happen until the `connect()` method is called. After that, we'll
    see the same sequential numbers outputted twice—once for each Subscriber. The
    third Subscriber will join the other two, printing the numbers emitted after the
    first 500 milliseconds, but it won't print the numbers emitted before its subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want to receive *all the* notifications that have been emitted before
    our subscription and then to continue receiving the incoming ones? That can be
    accomplished by calling the `replay()` method instead of the `publish()` method.
    It creates a `ConnectableObservable` instance from the source `Observable` instance
    with this little twist: all the subscribers, whenever they subscribe, will receive
    *all the* notifications (the previous notifications will arrive in order and synchronously).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a way to activate an `Observable` instance to become hot without calling
    the `connect()` method. It can be activated *on the first subscription* to it
    and deactivated when every `Subscriber` instance *unsubscribes*. Such an `Observable`
    instance can be created from a `ConnectableObservable` instance by calling the
    `refCount()` method on it (the name of the method comes from ''reference count'';
    it counts the `Subscriber` instances subscribed to the `Observable` instance created
    by it). Here is the preceding example implemented using the `refCount()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Observable` instance will be deactivated when `sub2` *unsubscribes*. If
    someone *subscribes* to it after that, it will begin emitting the sequence from
    the beginning. This is what's happening with `sub3`. There is a `share()` method,
    which is an alias for the `publish().refCount()` call.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code of the preceding example can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/UsingConnectableObservables.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/UsingConnectableObservables.java).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one other way to create a hot Observable: using a `Subject` instance.
    We will introduce them in the next and last section of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The Subject instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Subject` instances are both `Observable` instances and `Observer` instances.
    Like `Observable` instances, they can have multiple `Observer` instances, receiving
    the same notifications. That's why they can be used to turn cold `Observable`
    instances into hot ones. Like `Observer` instances, they give us access to their
    `onNext()`, `onError()`, or `onCompleted()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an implementation of the preceding hot *interval* examples,
    using a `Subject` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The example is slightly different now:'
  prefs: []
  type: TYPE_NORMAL
- en: The interval `Observable` instance is created the same way as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we create a `PublishSubject` instance—a `Subject` instance that emits
    to an `Observer` instance only those items that are emitted by the source `Observable`
    instance subsequent to the time of the subscription. This behavior is similar
    to that of the `ConnectableObservable` instance created by the `publish()` method.
    The new `Subject` instance is subscribed to the interval `Observable` instance
    , created by the interval factory method, which is possible because the `Subject`
    class implements the `Observer` interface. Also, note that the `Subject` signature
    has two generic types—one for the type of notifications the `Subject` instance
    will receive and another for the type of the notifications it will emit. The `PublishSubject`
    class has the same type for its input and output *notifications*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that it is possible to create a `PublishSubject` instance without subscribing
    to a source `Observable` instance. It will emit only the notifications passed
    to its `onNext()` and `onError()` methods and will complete when calling its `onCompleted()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We can subscribe to the `Subject` instance; it is an `Observable` instance after
    all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can emit a custom notification at any time. It will be *broadcast* to all
    the subscribers of the subject. We can even call the `onCompleted()` method and
    close the notification stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third Subscriber will only receive notifications emitted after it subscribes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When everything *unsubscribes*, the `Subject` instance will continue emitting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example's source code can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/SubjectsDemonstration.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/SubjectsDemonstration.java).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four types of subjects that come with RxJava:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PublishSubject`: This is the one we saw in the previous example, behaving
    like `ConnectableObservable`, created using the `publish()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReplaySubject`: This emits to any observer all of the items that were emitted
    by the source `Observable` instance, regardless of when the observer subscribes.
    So, it behaves like `ConnectableObservable`, created using the `replay()` method.
    The `ReplaySubject` class has many factory methods. The default one caches everything;
    keep this in mind, because it can eat up memory. There are **factory methods**
    for creating it with size-bound and/or time-bound buffers. As with the `PublishSubject`
    class, this one can be used without a source `Observable` instance. All of the
    notifications emitted using its `onNext()`, `onError()`, and `onCompleted()` methods
    will be emitted to every Subscriber, even if it is subscribed after invoking the
    `on*` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BehaviorSubject`: When an observer subscribes to it, it emits the item most
    recently emitted by the source `Observable` instance (or a seed/default value
    if none have yet been emitted) and then continues to emit any other items emitted
    later by the source `Observable` instance. The `BehaviorSubject` class is almost
    like the `ReplaySubjects` class with a buffer size of one. The `BehaviorSubject`
    class can be used to implement a stateful reactive instance—a reactive property.
    Again, a source `Observable` instance is not needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsyncSubject`: This emits the last value (and only that) emitted by the source
    `Observable` instance, and only after the source `Observable` instance completes.
    If the source `Observable` instance does not emit any values, the `AsyncSubject`
    instance also completes without emitting any values. This is something like a
    *promise* in RxJava''s world. A source `Observable` instance is not needed; the
    value, the error, or the `OnCompleted` notification can be passed to it by invoking
    the `on*` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using subjects may seem a cool way to solve various problems, but you should
    avoid using them. Or, at least implement them and their behavior in a method that
    returns a result of type `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: The danger with the `Subject` instance is that they give access to the `onNext()`,
    `onError()`, and `onCompleted()` methods, and your logic can get messy (they need
    to be called following the Rx contract, cited earlier in this chapter). They can
    be misused very easily.
  prefs: []
  type: TYPE_NORMAL
- en: Opt for using the `ConnecatableObservable` instance (that is, via the `publish()`
    method) over the `Subject`, when you need to create a hot Observable from a cold
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s look at one good use of a `Subject` instance—the aforementioned
    *reactive properties*. Again, we are going to implement *''The Reactive Sum''*,
    but this time it will be quite different. Here is the class defining it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has three double properties: two settable properties, `a` and `b`,
    and their *sum*, `c`. When `a` or `b` changes, `c` is *automatically updated*
    to their sum. There is a special method that we can use to track the changes to
    `c`. So how does it work?'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReactiveSum` is a normal Java class, defining three private fields of type
    `BehaviorSubject<Double>`, representing the variables `a`, `b`, and `c`, and with
    default values of zero.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor, we subscribe `c` to depend on both `a` and `b` and to be
    equal to their sum, again, using `combineLatest()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The properties `a` and `b` have getters and setters. The getters return their
    current value—the last received value. The setters *emit* the passed value to
    their `Subject` instance, making it the last one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `getValue()` method of the `BehaviorSubject` parameter is used for retrieving
    it. It is available at RxJava 1.0.5.
  prefs: []
  type: TYPE_NORMAL
- en: The property `c` is read-only, so it has only a getter, but it can be listened
    to. This can be done with the `obsC()` method, which returns it as an `Observable`
    instance. Remember, when you use subjects, to always encapsulate them in types
    or methods and return the observables to the outside world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This `ReactiveSum` class can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first value is *emitted* on the `subscribe` `()` method (remember the `BehaviorSubject`
    instances always *emit* their last value on subscribing), and the other two will
    automatically be *emitted* on setting `a` or `b`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for the preceding example can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/ReactiveSumV3.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/ReactiveSumV3.java).
  prefs: []
  type: TYPE_NORMAL
- en: '*Reactive properties* can be used for implementing bindings and counters, so
    they are very useful for desktop or browser applications. But this example is
    far from any functional paradigm.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned many ways of creating different kinds of `Observable`
    instances and other related instances (`Observer`, `Subscriber`, `Subscription`,
    and `Subject`). We've been creating them from timers, values, collections, and
    external sources such as files. Using this knowledge as a base, we can begin building
    logic, by chaining operations to them. Many of the factory methods introduced
    here we'll be coming back in the next chapters. For example, we will be building
    different behaviors using the `Observable.create` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll introduce various **operators**, which will give
    us the power to write real logic using the `Observable` instances. We have already
    mentioned some of them, such as `map()` and `filter()`, but the time has come
    to look at them in depth.
  prefs: []
  type: TYPE_NORMAL
