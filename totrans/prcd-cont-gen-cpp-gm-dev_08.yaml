- en: Chapter 8. Procedural Behavior and Mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, the focus of our efforts has been the procedural creation of resources.
    Let's branch out using what we've learned and procedurally create behavior and
    game mechanics. While the creation of *procedural game behavior* may sound exotic,
    you run into it in every game that you play; **artificial intelligence** (**AI**).
    AI in games is calculating behavior at runtime based on current factors. This
    definitely counts as procedural generation! Previously, when approaching large
    topics, I've commented that a whole book could be dedicated to the subject. Well,
    with AI, you'd need an entire library. For our project, we're going to have a
    look at pathfinding; allowing enemies to intelligently chase the player around
    our levels.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect that we'll look at is the procedural generation of mechanics,
    specifically the generation of unique game goals. A great example of where this
    can be applied is game quests. How many times have you come across a quest that
    said, *Kill X of this animal and bring me Y of its fur?* Probably around a thousand!
    We can use procedural generation to add some variety here. We can generate random
    goals for each room/floor of our dungeon that aren't so static.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The A* pathfinding algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating unique game tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to pathfinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to start by tackling the biggest job: implementing a pathfinding
    algorithm so that the enemies can move intelligently around the map. Before we
    do so, let''s take a look at pathfinding algorithms as a whole, what they do,
    and how they do it! This context will help you make the task ahead clearer and
    show you the wealth of choices that we have.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a pathfinding algorithm?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **pathfinding algorithm** is an algorithm that calculates the best path from
    one position to another. A good algorithm will take into account the terrain and
    several other factors to ensure that the movement is intelligent and won't result
    in any weird behavior. Remember the last time you were playing a game and an NPC
    kept walking into the wall? This is the weird behavior that pathfinding errors
    produce. Every time an enemy runs around an object to get you in a game, it's
    the result of such an algorithm, and they're essential in the creation of a gameplay
    that's challenging and which feels natural.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following diagram, the green circle is an NPC that has
    to get the red circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a pathfinding algorithm?](img/B04920_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, the NPC can''t go directly towards the goal point as it would
    get stuck walking into the wall. Instead, we need to take the wall into account
    and move around it, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a pathfinding algorithm?](img/B04920_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the NPC here intelligently avoided the wall while still reaching
    the goal as efficiently as possible. This is the essence of pathfinding, and it
    is what we'll implement in our game in the first part of this chapter. Let's take
    a look at what's going on behind the arrows.
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra's algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with anything, there are a number of ways in which pathfinding can be implemented,
    and a number of common algorithms can be used to do so. Different algorithms have
    different characteristics, and while their finished product may appear similar,
    they achieve it in different ways. The most common pathfinding algorithm in games
    is **A***, an extension of Dijkstra's algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra's algorithm was created by Edsger Dijkstra in 1959\. It is a best-first
    search algorithm, that is, it visits the node with the least value first in an
    effort to produce the shortest path possible. From its starting point, it radiates
    out, checking every node in turn until it finds its goal. As you can imagine,
    this is both expensive and it can take a long time to find the end node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how, to find the end node, Dijkstra''s algorithm
    has to search most of the available nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dijkstra''s algorithm](img/B04920_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The A* algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A* is an extension of Dijkstra's algorithm. Its aim is to decrease the time
    it takes to find the end node by introducing a heuristic to help guide the search.
    A **heuristic** (or heuristic technique) is simply a way of approaching a problem
    using a practical method that isn't perfect, but it's sufficient. For example,
    trial and error is a fundamental heuristic. While it's not perfect, you'll reach
    the solution to a problem using trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of A*, our heuristic is taking into account the distance that has
    already been travelled to guide the search towards the end node. Take another
    look at the preceding diagram that shows Dijkstra''s algorithm. Now, look at the
    same pathfinding problem that''s solved by A* in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The A* algorithm](img/B04920_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's clear that the A* implementation tended towards the target location and
    thus found the goal node quickly. Also, look at how many nodes each algorithm
    had to look at to find the goal. Dijkstra's algorithm practically visited every
    node, while in A*, thanks to the heuristic, significantly fewer nodes were visited.
  prefs: []
  type: TYPE_NORMAL
- en: A breakdown of A*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start coding our own A* implementation, it will do us good to break
    down the algorithm into its key areas and take an isolated look at each.
  prefs: []
  type: TYPE_NORMAL
- en: Representing a level as nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most important area of understanding when we look at A* is how the
    algorithm will view our level. While we see tiles, the pathfinding algorithm sees
    only nodes. In this context, a node just represents a valid location that an entity
    can move to within the level.
  prefs: []
  type: TYPE_NORMAL
- en: How nodes are defined differs from game to game. For example, in our game, the
    level is already described as a 2D array of tiles. Therefore, each tile in that
    grid will act as a node. In 3D games however, we don't have this grid so navigation
    meshes are used to create a surface that can be represented as nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Valve has a great article on their developer wiki page regarding navigation
    meshes. So head to [https://developer.valvesoftware.com/wiki/Navigation_Meshes](https://developer.valvesoftware.com/wiki/Navigation_Meshes)
    if you want to learn more about this subject.
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows how the level is split into the 2D array of tiles
    that it is at heart. Each of these tiles will be used as a node in the A* algorithm.
    The tiles that are valid locations for players to move to (floor tiles) are marked
    in green, and the tiles that should be avoided (walls, obstacles, and so on) are
    marked in orange.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting green is the valid region of nodes that the algorithm will try
    and find a path through.
  prefs: []
  type: TYPE_NORMAL
- en: '![Representing a level as nodes](img/B04920_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The open and closed list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the nodes have been identified, they are stored into the following two
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The open list**: This list contains all the nodes that are waiting to be
    the subject of the algorithm. This will make more sense when we get into some
    code, but the algorithm operates on one node a time, and the open list is the
    queue for this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The closed list**: This list simply contains all the nodes that have already
    been through the algorithm. Once a node gets added to this list, it''s ignored
    until the algorithm is complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The H, G, and F costs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When reading about the A* pathfinding algorithm, there are 3 letters that you''re
    going to come across: H, G, and F. These are crucial values in the algorithm,
    but they aren''t very descriptive. So let''s take a moment to look at what each
    value is and the role that it plays in calculating a path.'
  prefs: []
  type: TYPE_NORMAL
- en: The H value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The H value, often referred to as the heuristic, is the estimated cost to reach
    the goal node from the current position. Every node in the level has an H value,
    which is calculated at the start of the pathfinding algorithm, and then used in
    later calculations. This value helps guide the search towards the target node
    instead of equally spreading out in all directions. How this value is calculated
    is up to the specific implementation, but a common method is called the **Manhattan
    distance**. We'll cover what this exactly is shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The G value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The G value is the current movement cost from the start node to this node. The
    way this is calculated is again implementation-specific. However, as with the
    H value, a common method and the one that we'll be using is the Manhattan distance.
    As the algorithm iterates, every time a link between two nodes is made, the movement
    cost of that individual movement is added to that of the entire path so far. In
    this way, as the paths build, each node knows how long the entire path before
    it is.
  prefs: []
  type: TYPE_NORMAL
- en: The F value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The F value is simply the sum of the H and G values. This value is used to determine
    which node the algorithm uses next. The lower this value, the lower the estimated
    complete path is. Thus, the algorithm prioritizes these nodes. This behavior is
    what makes Dijkstra's algorithm, and therefore A*, a best-first search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The Manhattan distance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the heart of a pathfinding algorithm lies calculating the distance between
    two points. As mentioned previously, exactly how this is done is implementation-specific,
    but there is a common and cheap method known as Manhattan distance (also known
    as taxicab geometry), which is what we'll be using.
  prefs: []
  type: TYPE_NORMAL
- en: It's formally defined as the distance between two points calculated by taking
    the sum of the absolute difference of their Cartesian coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: That's quite a mouthful, but it's actually pretty simple. Cartesian coordinates
    are simply a way of expressing a position relative to two fixed perpendicular
    axes (even if this seems unfamiliar, we've all covered this at school), and absolute
    simply means that we ignore the sign of a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Manhattan distance](img/B04920_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have two points on the graph: **A(-4,4)** and **B(5,-3)**. The following
    pseudocode calculates the Manhattan distance between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It's as simple as that!
  prefs: []
  type: TYPE_NORMAL
- en: Parenting nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another crucial aspect of pathfinding is the idea of parenting nodes. A* works
    by building up a chain of nodes. Once the goal node is found, we work back through
    this chain to get the final path. When the shortest path between two nodes is
    identified, node A will be assigned as the parent of node B.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following screenshot shows a situation where the skeleton
    enemy has found a valid path to the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parenting nodes](img/B04920_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's imagine a situation where a path between two nodes is found. For example,
    the path between nodes **6** and **7**. Then, the first node is set as the parent
    of the second node, in this case, node **6** is set as the parent of node **7**.
    In this way, each node knows where it came from. When the algorithm finds the
    goal node (in our example, it's node **2**), we can use this parent hierarchy
    to work our way from the goal node to the start node, giving us the final shortest
    path. In this case, the shortest path between the skeleton and the player is **6**,
    **7**, **5**, **2**.
  prefs: []
  type: TYPE_NORMAL
- en: The pseudo-algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To wrap up the breakdown of the algorithm, let''s look at a pseudo-implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute the H values beforehand, if possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the start node to the open list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the node with the lowest F value in the open list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove that node from the open list and add it to the closed list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For all adjacent nodes, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the node is the goal node, set its parent to the current node and store the
    final path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the node is in the closed list, ignore it and go to step 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the node is not in the closed list and the open list, set its parent to the
    current node and calculate its G and F value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the node is not in the closed list but is in the open list, check whether
    the path between it and the current node is quicker than its current path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a simplified look at the A* algorithm. Hopefully, this breakdown has
    given context to some of these steps. Let's get it coded!
  prefs: []
  type: TYPE_NORMAL
- en: Coding the A* pathfinding algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With an understanding of the fundamentals of A*, let's start implementing it
    in our game. This will allow the enemies to follow our player around the level
    regardless of its topology.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a complex algorithm such as this, having a visual representation of what''s
    happening is really helpful. Wherever it''s appropriate, we will take a look at
    a visual representation of what''s happening using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the A* pathfinding algorithm](img/B04920_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Tile datatype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by taking a quick look at the `Tile` struct that was defined in
    `Level.h`. As we''ve seen, a node contains quite a few values. In the implementation,
    it''s the level tiles that will act as nodes. As such, all the information that''s
    required by a node is defined in its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For the rest of the chapter, a node is synonymous with a tile. So don't worry
    if they're used interchangeably. However, remember that this will not be the case
    in every A* implementation, as what you use as nodes will depend on the game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating supporting functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we implement the algorithm itself, we need to create some supporting
    functions and variables that the algorithm will require. Note that these are specific
    to the implementation and are not a part of the A* algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The Level class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first class that we need to do some groundwork in is the `Level` class.
    We're going to need a function that resets all the variables in the nodes/tiles,
    as we need these values to be reset back to their defaults every time we run the
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function declaration to `Level.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the following definition in `Level.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can see that all that we're doing here is iterating over each tile in the
    level grid and resetting all the variables that we'll use in the A* calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The Enemy class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we need to create a function that will run the algorithm in the `Enemy`
    class. Add the following function declaration in `Enemy.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this function takes a reference to the level, the main player
    position, and is public. We need the function to be public so that we can call
    it from the main game class. This is for efficiency and it will become clearer
    why later. We will pass a reference to the level object, as the enemy will need
    to access the level information, and the player location is needed to calculate
    the target position.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add the following variables in `Enemy.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With this work done, we can add the empty function definition for `Enemy::UpdatePathFinding`
    in `Enemy.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All code from this point onwards will be appended to this function. There's
    quite a bit to it!
  prefs: []
  type: TYPE_NORMAL
- en: Variable declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in the function is going to be the declarations of all the variables
    that we''ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `openList` and `closedList` variables are used to manage the nodes. Nodes
    in the `openList` variable are waiting to be checked, and nodes in the `closedList`
    variable have already been checked and should be ignored from now on. This will
    be explained in detail when we come across them in the implementation. The `pathList`
    variable will store all the nodes in the final path.
  prefs: []
  type: TYPE_NORMAL
- en: The position variable is an iterator that will be used to find and remove values
    from our vectors. Finally, the `currentNode` variable is used to keep track of
    the node that we're currently working with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to reset all the nodes. Every time we run the function, we
    need the nodes to have their default values. To achieve this we''ll make a call
    to the `Level::ResetNodes` function that we just created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step in the setup will be to identify the start and end nodes, marking
    the start and end of the path that we''re looking for. The start node is going
    to be the position of the enemy. The end node, which is our goal, is the position
    of the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Level::GetTile` function returns the tile at a given location, so we can
    use this to get the nodes. Once we''ve identified these, we''re going to perform
    a quick check to ensure that they are not the same nodes. If they are, there is
    no valid path between them and we can simply clear the current path and exit the
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have declared all the variables that we'll be using, reset
    all the nodes to their default values, and identified that we're working with
    a valid path. It's time to jump into the bulk of the algorithm!
  prefs: []
  type: TYPE_NORMAL
- en: Precalculating the H values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step in our A* algorithm implementation is to calculate the H value
    for every node in the level. Remember that the H value is the estimated cost of
    the path from the start node to the goal node.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to use the Manhattan distance for this. So, for every tile in
    the level, we need to calculate this distance to the goal node, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Defining the main loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re now going to define the main loop in which the algorithm actually takes
    place, but before we do so, we need to quickly add the start node to the list
    of open nodes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The open list is a list of all the nodes that the algorithm has left to check.
    While this list has values in it, the algorithm should run. Therefore, we''ll
    define this behavior to create the main loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step in the algorithm is to decide which node we''re going to operate
    on next. You may remember that the F value is used for this purpose. The open
    list contains all the nodes that are waiting to be checked. So we need to iterate
    over this vector and find the node with the lowest F (the estimated cost of the
    complete path) value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. We initially set `lowestF` to `INT_MAX`,
    a macro that contains the maximum value of an `int`, as we can be sure that no
    F value will come anywhere near that. When we identify a node with a smaller F
    value, we update the `lowestF` value and mark that node as the node that needs
    to be operated on next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have identified the node with the lowest F value, we remove it from
    `openList` and add it to the `closedList` vector to ensure that we don''t operate
    on the same node again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is where the iterator variable comes into play. An iterator is simply an
    object with the ability to iterate through a range of elements. To remove an item
    from a vector, we make a call to `std::find()`, passing the start of the vector,
    the end, and the value that we are looking for. If the value is found, `std::find()`
    will return an iterator to that element. If the value is not found, it returns
    an iterator that refers to an imaginary element, which will follow the last element
    in the vector. Then, we call erase in `openList`, passing this iterator value
    to get to the right element.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the adjacent nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the next node is selected and assigned to the `currentNode` variable,
    it's time to identify all the adjacent nodes. This is another area that will differ
    depending on each specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the level is defined as a 2D grid. Therefore, it''s easy for us
    to get the surrounding nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the adjacent nodes](img/B04920_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see from the preceding diagram how the column and row indices, `i` and
    `j` respectively, range from -1 to 1 surrounding the middle tile. We can use this
    to get the nodes around us that we want to check. We're only interested in valid
    floor nodes, so while we're fetching them, we can perform these checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this in the function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we got the 4 nodes around us, ensuring that they''re both valid
    and are floor tiles. Only then are they added to the list of adjacent nodes that
    need to be checked. With these identified, we now need to loop over each node.
    A `for` loop will allow us to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The algorithm is over when we reach the goal node. Therefore, every time we
    select an adjacent node, we can check whether we''ve done so. With the goal node
    stored in a variable, this is a simple check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we select nodes by the lowest F value, the first time we reach the goal
    node, we know that we will have travelled the shortest possible path. Before we
    move on to finding this path, we first need to make the parent of the goal node
    the current node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have to construct a list of all the nodes that made up the path, from
    the start node to the goal node. There is no set way to do this, but we''ll use
    a `while` statement. While the node has a parent, add the node to the list and
    then set the node to its parent. Let''s add the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we build a complete path from the goal node to the start node.
    Note that the resulting path is backwards, but we'll sort this out later!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the final step is to exit the main loop. We''re currently nested within
    a `while` loop and a `for` loop. To exit this, we need to empty the open list
    and call `break`. The `break` component kicks us out of the `for` loop, and with
    the open list now empty, we exit the `while` loop too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that this is done, we have found the goal node, stored the path of nodes
    from the start to the goal, and exited the main loop. This was all the result
    of finding the goal node. We now need to turn our attention to the case where
    we didn't find the goal node.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the G and F costs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a node is in the closed list then it''s already been the subject of the
    algorithm. All the adjacent nodes have been checked and had their G and F values
    calculated. If this is the case, we can simply ignore the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After insuring that the node is not in the closed list, we next check the open
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the previous check, if our node is in the open list, we do not ignore
    it. If the node is not in the open list, then it''s the first time that the algorithm
    has encountered it. If this is the case, we need to perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the node to the open list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `parent` to `currentNode` (it's the last node when checking the F values).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate its G value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate its F value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll start by adding it to the open list and setting its parent node; these
    are quick and easy tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the G and F cost
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may remember that the G cost is the total cost of movement from the start
    node to this node. In our grid, we can move in all the four directions, we don't
    move diagonally, so each movement costs `10`. This value is specific to the implementation
    and not the algorithm. It's the cost of movement between two nodes, and `10` is
    simply a nice value to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not using diagonals only for the sake of an easier presentation. One
    of the exercises at the end of the chapter is to add diagonal movement and I highly
    suggest that you give it a go!
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we know that the movement cost between the nodes is `10`, we now need
    to add the G cost of `currenNode` to it to arrive at the final value. The G cost
    of `currentNode` is the cost of that path far, so adding the last movement cost
    to it gives the new node the total cost of the path from the start node to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to calculate the F cost of the node, which is simply the sum
    of its G and H costs. We just calculated the G cost, and we precalculated the
    H costs at the start of the algorithm. All that is needed is a simple addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Checking for superior paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final step of the algorithm is the condition where we check whether the
    node is already in the open list, and it is. If this is the case, we've already
    generated its G and F values. We now however need to check whether they are the
    lowest possible values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following image, node **7** is the parent to node **8**, and node **8**
    is the parent to node **5**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking for superior paths](img/B04920_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This has resulted in a movement cost of `30` from node **7** – **8** – **5**.
    However, this is not the shortest path. The movement cost from **7** to **5**,
    assuming that we allowed diagonal movement, is `14`. If we drop **8** from the
    path, the total movement cost is `24`, which is lower than its current value of
    30\. When this is the case, we make 7 the parent of **5** instead of **8**. Since
    we don't use diagonal movements, this exact example won't apply unless you add
    them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hopefully however, it demonstrates that we''re looking for superior paths as
    shown the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking for superior paths](img/B04920_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see here that the movement cost of node **5** is lower and it is parented
    to **7**. This has created a diagonal path that is shorter than the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s append some code to the function to include this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Creating the final path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final part of the A* implementation is to turn the list of nodes into a
    valid path that the enemy can follow. In the work that we did to prepare for the
    A* implementation, we added the following variable to the `Enemy` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This vector is going to hold a list of target locations that we''ll get from
    the nodes in the final path. However, before we do so, we need to ensure that
    we clear it. This is done so that every time the pathfinding algorithm is run,
    the player has a fresh set of coordinates to move to. Let''s clear the vector.
    Again, this code is just appended to the `Enemy::UpdatePathFinding` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to convert the tiles into target locations we will iterate over the vector
    of the final nodes, get their actual positions, and add them to the `m_targetPositions`
    vector, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s one last thing that we need to do and which is easy to overlook. When
    we find the goal node and create the final path list, we store them from the goal
    node back to the start node. This means that the final path is backwards. The
    final step in the `Enemy::UpdatePathFinding` function is to reverse the `m_targetPositions`
    vector to correct this and add the final closing brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We're done. The A* algorithm is complete. The base enemy class has
    a function that will create a vector of target locations and take the enemy to
    the player in the quickest path possible. The next step is to enable the enemy
    to follow this path!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to explore pathfinding further, head over to [https://qiao.github.io/PathFinding.js/visual/](https://qiao.github.io/PathFinding.js/visual/).
    It's a fantastic app that visualizes a range of popular pathfinding algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing A* in the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the function that can calculate the shortest path, we need
    to incorporate this behavior into the game.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the enemy to follow a path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now need to make the enemies follow the vector of target locations that the
    pathfinding algorithm generates. We need the enemy to constantly follow this path,
    so we'll override its base classes' `Update` function, as it's called during every
    game's tick. The code that will do this is fairly simple; if there is a location
    in the vector, move towards it at a fixed pace. When the position is reached,
    we simply remove it from the vector. When the vector is empty, we know that the
    enemy has reached its goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding the function declaration to `Enemy.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add the code to follow the path. Like we just said, if there is a
    value in the vector of the target positions, move towards it at a fixed pace.
    We do this by creating and normalizing a movement vector.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We won't cover the mathematics behind this movement. So, if you want to read
    more about it, check out [http://www.fundza.com/vectors/normalize/](http://www.fundza.com/vectors/normalize/)
    for an overview.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used for the creation and normalization of a movement
    vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can also see that at the end of the function we call `Entity::Update`. The
    animation code lies in this function. We need to ensure that it still gets called!
  prefs: []
  type: TYPE_NORMAL
- en: Calling the pathfinding behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final step in incorporating pathfinding into the game is to call the `Enemy::UpdatePathFinding`
    function when we want to generate a new path. The enemies are updated with each
    game update, but we don't want to update the path that frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although A* is an efficient algorithm, we still want to call it as seldom as
    possible. The path will only change when the player moves to a new tile, so there''s
    no point in updating the pathfinding until this happens. In order to achieve this,
    we need to be able to tell which tile the player was on during the last update,
    and which tile the player is on this update. Let''s add the following variable
    to `Game.h` and ensure that we give it a default value in the class initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Game::Update` function, we can now check whether the player has moved
    to a tile, and if that''s the case, call the `Enemy::UpdatePathFinding` function
    of all the enemies in the level, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! We can now test the game. We should see the enemies following us
    around the level instead of standing like stationary objects as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calling the pathfinding behavior](img/B04920_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing our path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the code working, which is great, but let's add some debug code so that
    we can see the path that the enemy is generating. I'm not going to cover this
    code in detail, as it's just for the purpose of demonstration. It basically just
    draws a sprite at each point in the target location's vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Enemy.h`, we''ll declare the following variables and function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Enemy::Enemy`, we''ll set up the debug sprites and font, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we''ll add a body for the new draw function named `Enemy::Draw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will show us the paths that the enemies'' A* algorithm find, helping
    us visualize what the A* algorithm is doing. Let''s run the game and take a look.
    Remember that you need to delete this debug code when you''re done as it''s going
    to have an impact on the performance. The following screenshot shows our enemies''
    paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing our path](img/B04920_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Procedurally generated level goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final system that we're going to build in this chapter is one that will
    generate randomized level goals. In each level, we have to find the key, find
    the exit, and kill all enemies that get in our way. Let's add more gameplay and
    challenge by adding random goals that the player can also complete. Every time
    a level is entered, we'll potentially give the player an optional task that, if
    completed, will yield a random reward.
  prefs: []
  type: TYPE_NORMAL
- en: The variable and function declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in creating this system is to declare the variables and functions
    that we''re going to need. We''ll encapsulate the behavior to generate a goal
    in its own function. For starters, we need to declare the following `private`
    function in `Game.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the type of goals that we want to generate (killing enemies, collecting
    gold, and collecting gems), we need variables to hold these values. Let''s also
    declare the following `private` variables in `Game.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''re going to want to be able to tell whether we have an active
    goal or not and draw the goal to the screen. We''ll declare a Boolean value to
    track whether we have a goal, and a string object to store the description of
    the current goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Generating a random goal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can generate the random goal. We have three types available, namely gold,
    gems, and enemies. So for a start, we need to choose which of these goals we're
    going to create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give `Game::GenerateLevelGoal` a body in `Game.cpp` by adding the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We started by defining a stream object that we'll use later, and resetting the
    goal variables to `0`. This is done to ensure that the goals start fresh every
    time this function is called. Then, we generate a number between `0` and `2` and
    use it in a `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each case we need to generate a random number as the goal value and set
    it to the appropriate variable. We also need to construct a string that describes
    the goal and store it in the `m_goalString` variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With this complete, our goals are essentially created. We now need to activate
    the goal by setting the `m_activeGoal` variable to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll hook up this function properly in the next chapter when we turn our
    attention to the level, but for now, we can test it by making a call to it in
    `Game::Game`. Add the following debug code so that we can test the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Checking whether a goal is complete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now generate a random level goal at the call of a function. We now need
    to hook gameplay into these goals so that we can tell when one of them has been
    accomplished. Whenever we process an action that is related to a goal, we need
    to check whether we have an active goal and respond accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the kill count, when we determine that an enemy has been killed,
    we check whether we have an active goal, and if this is the case, we decrement
    the `m_killGoal` variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The same approach is taken for other level goals. In the object pickup code,
    when we have picked up either gold or a gem, we''ll check whether we have an active
    level goal, and if this is the case, we decrement the appropriate values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: With this complete, the actions in the game are now hooked up to the goal counters.
    Next, we need to actually check whether we've achieved the goal. We'll put this
    code right at the end of `Game::Update` so that we can ensure that all the other
    actions have been executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking whether we''ve achieved our goal is simple. First, we check whether
    we have an active goal. Then, we check whether all the counter variables are less
    than or equal to `0`. If that''s the case then we know that we''ve decremented
    the appropriate counter to `0`. With this approach the other values will dip to
    negative values, but we won''t be collecting enough loot for that to be a problem.
    Let''s add this code at the end of `Game::Update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: With this complete, the majority of the goal system is set up. You can see that
    if we determine that a goal is active, and all counters are 0 or lower, we reward
    the player. We also set the `m_activeGoal` variable to `false` to show that the
    goal has now been achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the goal on the screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final step now is to draw our goal on screen! We have a `bool` variable
    that denotes when we have an active goal, and when we generate that goal, we store
    its descriptor in a string variable. Drawing it is as simple as making a call
    to `Game::DrawText` and passing the description, but we'll only do this when the
    `m_activeGoal` variable is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to finish this system by adding the following to `Game::Draw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run the game, you will see that a unique goal is shown every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the goal on the screen](img/B04920_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We could call it a day here, but we can do better! Since the string that defines
    the level goal is stored only once, when we create it, it doesn't update itself
    as we work towards achieving it. Let's fix this! If we jump back to `Game::Update`
    and find where we check whether we achieved our goal, we can make some modifications
    here to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, we check whether we''ve achieved the active goal, but we only do
    something if we have achieved it. This is our opportunity to update the string.
    All we have to do it determine which type of goal is set, which we can do by checking
    the values of our goal variables, and rebuild the string in the same way we do
    in `Game::GenerateLevelGoal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we have an active goal, the string on the screen is updated as we
    work towards it!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help you test your knowledge of this chapter''s content, here are a few
    exercises that you should work on. They are not imperative to the rest of the
    book, but working on them will help you assess your strengths and weaknesses in
    the material covered:'
  prefs: []
  type: TYPE_NORMAL
- en: When calculating pathfinding, we currently do not allow diagonal movement. Update
    the algorithm so that this is now allowed. To get you started, when calculating
    the G cost, you'll need to determine whether we moved diagonally or straight.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Currently, the enemies will chase us throughout the entire level. Amend the
    function so that the enemy will only chase the player if they are within a certain
    distance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Currently our enemies move at a fixed speed and don't take into account the
    speed variable that we generated in an earlier chapter. Incorporate the speed
    variable in the game so that the enemies move at their correct speeds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we extended our efforts to procedural behavior and mechanics
    as opposed to just resources. Specifically, we implemented A* pathfinding algorithm
    to give the enemies some intelligence and natural movement around our levels and
    created random level goals. Hopefully, this has been a good demonstration of the
    fact that procedural generation isn't limited to just resources; it can be put
    to use for every aspect of a game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''re going to implement what is perhaps the most iconic
    feature of roguelike games: procedurally generated levels. Up until now we''ve
    been working with the same fixed level, so it''s about time we started generating
    them procedurally! We''ll also create some variance between the levels and implement
    the goal generator that we just created!'
  prefs: []
  type: TYPE_NORMAL
