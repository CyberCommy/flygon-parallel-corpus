- en: Chapter 2. Introducing ImpactJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have gathered all the necessary tools and got the first game up
    and running, it's time to learn more about how Impact actually works.
  prefs: []
  type: TYPE_NORMAL
- en: However, before diving into the code, we should first copy the code from the
    `chapter 2` folder to the correct locations.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to what we have done in [Chapter 1](ch01.html "Chapter 1. Firing Up
    Your First Impact Game"), *Firing Up Your First Impact Game*, we just need to
    overwrite the `main.js` and `index.html` files and the `entities`, `levels`, `plugins`,
    and `media` folders of the `myfirstawesomegame` project.
  prefs: []
  type: TYPE_NORMAL
- en: We are now set to go and explore the intricate workings of the ImpactJS engine!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following processes:'
  prefs: []
  type: TYPE_NORMAL
- en: The Weltmeister tool in ImpactJS and the consequences of changing certain parameters
    in a level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The manner in which level layers impact level design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How collision is handled in ImpactJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ImpactJS entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The properties of an ImpactJS entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How a playable entity differs from a non-playable one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to spawn or kill a character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up player controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to change the game's graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to play sound effects when triggered and a background tune
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add physics to a game using Box2D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While designing a game, you would want to create the setting and the place where
    it all happens. Many games are divided into levels, often getting more difficult
    with each level upgradation. For some other games such as **RPGs** (**Role Playing
    Games**), there is no such thing as a level because it implies a certain cutoff
    with often no way back. Throughout the book, a space that can be saved as a single
    file in the Weltmeister will be referred to as a level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Weltmeister is literally the tool to master your world in ImpactJS. If
    you installed ImpactJS correctly you should be able to access the level editor
    shown in the next screenshot by placing the following address in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost/myfirstawesomegame/weltmeister.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building your own levels](img/4568_2_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating, loading, and saving levels in Weltmeister
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating levels for a game is one of the most enjoyable things to do in game
    design. The Weltmeister is so well put together that you will spend hours messing
    around with it just because you can.
  prefs: []
  type: TYPE_NORMAL
- en: On opening Weltmeister (by default), it starts with a clean slate; there is
    a vast amount of emptiness for you to fill. Soon we will get to building a level
    from scratch but for now we should load the `level1` level. Press the **Load**
    button in the top-right corner of your Weltmeister and select it in the `levels`
    folder. If you copied it in the beginning of the chapter it should be right there,
    otherwise copy it to the Weltmeister now.
  prefs: []
  type: TYPE_NORMAL
- en: '`Level1` is a rather original name for a first level but let''s personalize
    it a bit by saving it as `myfirstepiclevel`. Press the **Save As** button in the
    top-right corner and save it in the same directory. Now we have a copy to work
    on and mess around with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we actually use the level called `myfirstepiclevel`, we will need to
    make a change in the `main.js` script''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `main.js` script in your preferred script editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main.js` script, you will see a call to the `loadLevel()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This call is situated in the `init()` function of the game (`ig.game.init`).
    This means one of the first things the `main.js` script will do (at *initiation*,
    thus `init`) is load the level, `Level1`. Obviously, we don''t want that anymore,
    as we have our own level called `myfirstepiclevel` now. In order to let the game
    know that it has to include this level, you will need to add it to the `.requires()`
    function as shown in the following code lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, change the call to the `loadLevel()` function so it calls the level,
    `myfirstepiclevel`, instead of `Level1` as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you might have noticed, you always have to put the word `Level` before your
    actual level name. In addition you will always need to write both `Level` and
    your level name with a capital letter. Failure to comply with either of those
    will result in an epic crash at game load. Putting `Level` in front of the actual
    level name is a rather odd convention, especially since functions like `loadlevel()`
    are built to expect a level file. It is possible that this mandatory prefix is
    removed in the future versions of ImpactJS. But for now, failing to insert the
    word `Level` before your actual level name or writing both `Level` and your level
    name with a capital letter will result in the display of the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating, loading, and saving levels in Weltmeister](img/4568_2_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The other buttons in the Weltmeister are **Save**, **New**, and **Reload** **Images**.
    The **Save** button just saves the file you are working on, and the **New** button
    will open a new and empty file. The **Reload** **Images** button is a refresh
    button for your tilesets. The tilesets of a game are collections of images. All
    the graphics of a single theme can be on a single tileset, for example, the `outdoor`
    tileset. Because several images are stored in a single overall image called a
    tileset, it is easier to create your level while working in the Weltmeister. You
    can look at it as the color palette of an artist, but as a level creator you have
    as many palettes at your disposal as you have tilesets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up everything we came across, we can conclude that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the Weltmeister by typing the following address in your browser
    while your server is turned on: `localhost/myfirstawesomegame/weltmeister.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open `level1` by using the **Load** button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save it again as `myfirstepiclevel` with the **Save As** button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include the new level in the `main.js` script by adding `myfirstepiclevel` to
    the `include()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layers and the z axis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the level opened, you can see the different elements and layers of which
    it is comprised. Let's first have a look at the **Layers** menu on the right-hand
    side of the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Select the **collision** layer and you will see the standard properties that
    need to be filled out for a layer in order to exist. All layers (except for the
    **entities** layer) have a name, tileset, tilesize, dimensions, and distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tilesets are basically chains of square-formed images, which when put together
    well enough, form your idyllic looking landscape or scary dungeon. The tilesize
    is the width and height of one tile measured in pixels. Since all tiles are squares,
    you only need to fill out a number. The dimensions of a layer are the width and
    height of the entire map on which the layer needs to be present, measured in number
    of tiles. So a layer with a tilesize of 8, a width of 20, and a height of 30 is
    composed of 4800 (8 x 20 x 30) pixels. Take this into account while working with
    mobile devices. A level with a resolution of 160 (8 x 20) x 240 (8 x 30) will
    fit most devices. However, if the tilesize is 32 you will need a viewport that
    automatically follows your playable character in order to show off your level.
    This view-port is rather easy to incorporate and will be explained later in this
    chapter. To create a new tileset follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Try creating a new layer by clicking on the plus (**+**) sign at the top of
    the layer selection menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in a name for the layer; let's say `astonishinglayer` or `tree`, whatever
    you like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now select the tree tileset from the `media` folder by clicking the empty box
    next to the **Tileset** field. If you can't reach it by using the Weltmeister
    menu, you just type `media/Tree.png` in the tileset box. Set the tilesize to `32`
    and the dimensions to `30 x 20` (width x height). You can see the border of your
    layer change accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a common mistake to have one layer smaller than the other and then not
    be able to add objects on one part of your map. So let's say you intend your level
    to be a map with dimensions of 30 x 20 and a tilesize of 32, and you add a layer
    like this, and fill it with grass. You want to add a bench on the grass so you
    add another layer and make the dimensions 30 x 20\. Because your bench is a 32
    x 16 image, you set the tilesize to 16\. If you do this you will be able to draw
    your bench quite accurately but only in the top-left corner of your level. You
    will need to change the dimensions to 60 x 40 in order to occupy the same space
    as the grass layer does.
  prefs: []
  type: TYPE_NORMAL
- en: Distance is the speed at which the layer moves relative to your game's screen
    position. A value of `1` in the **Distance:** field means it moves at an equal
    speed, whereas the value `2` means the layer moves at half the speed. By setting
    this parameter higher than `1`, it becomes possible to make things appear further
    away; this is ideal for your nice cloudy background in a side scrolling (or parallax)
    game, such as Mario. Go to your game and walk your character from the far left
    edge of the game towards the right boundary to observe the effect of altering
    the value of the **Distance:** field.
  prefs: []
  type: TYPE_NORMAL
- en: Now return to the Weltmeister and try setting the value of the **Distance:**
    field to `2`. Save and reload the game, run your character from one edge to another
    edge of the level, and see what happens. Part of the game will appear to move
    slower than the rest. This is useful in side scroller games as a background, but
    it is also used in top-down games to create the impression of a terrifying abyss.
    Underneath, you have the options **Is Collision Layer**, **Pre-Render in Game**,
    **Repeat**, and **Link with Collision**. Turning them on and off can be done by
    clicking on the white squares (which turn black to indicate the option is switched
    off).
  prefs: []
  type: TYPE_NORMAL
- en: The **Is collision layer** option will tell the level editor that the objects
    in the layer you are drawing are impenetrable. Pre-rendering a layer will cause
    the game to cluster tiles while loading. This will increase the initial load time
    but decrease the number of draws the game requires and, thus, increase performance
    while running.
  prefs: []
  type: TYPE_NORMAL
- en: The **Repeat** option is used for background layers. For example, your background
    clouds can be repeated over and over again if they are a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finally the **Link with Collision** option will make sure that, for every object
    you draw, collision squares are added to the **collision** layer. You can delete
    them from the **collision** layer later on, but it is a useful tool to speed up
    the drawing of walls and other impassable terrain.
  prefs: []
  type: TYPE_NORMAL
- en: Layers can be rearranged within the **Layers** menu by dragging them up or down
    the list. By dragging a layer to the top or down to the bottom of the list, you
    define its place on the z axis. You should look at the z axis as the level's third
    dimension, just as the world we live in has an x axis (width), a y axis (height),
    and a z axis (depth). The game you build is not really 3D in the conventional
    sense, but since the 2D graphics are layers stacked on top of one another, there
    is an actual third dimension at work here. The graphical layer at the top of the
    list will always be visible and will even hide entities. The bottom layer can
    only be visible when nothing else is on the way. The **collision** layer is never
    visible but dragging it to the top will enable you to make modifications to it
    more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Try rearranging the layers and check out what happens. Save your game and reload.
    Depending on what crazy stuff you did with the layers, the world is now a very
    different place indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of dragging a layer to the top of the stack in order to be able to view
    it, you can also turn layers on and off. This is done by clicking on the square
    in front of the layer name. This will not have any effect in the actual game;
    it is visible only in Weltmeister. This is very useful for the **collision** layer.
    Try dragging the **collision** layer to the top of the stack and turn it on and
    off at your will. You will notice that this is the best place for the **collision**
    layer to be while working with the Weltmeister. This is because the **collision**
    layer itself doesn't actually have graphics while playing the game, so it can't
    obscure anything else.
  prefs: []
  type: TYPE_NORMAL
- en: '![Layers and the z axis](img/4568_2_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Summing up the details we came across, we conclude that:'
  prefs: []
  type: TYPE_NORMAL
- en: A level is made up of different layers with properties such as tilesize, distance,
    and whether it is a **collision** layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new layer using the (**+**) sign in the **Layers** menu and give it the
    name `astonishinglayer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a tileset `media/tree.png` to the layer. Set its dimension to `30 x 20`
    and its tilesize to `32`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try messing around with all the properties you can find on the layer including
    dragging the layer up or down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the level and reload your game in the browser every time you adjust a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and removing entities and objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three big types of layers: **entities**, **collision**, and any other
    layer. For entities and dead objects, the entities and graphical layers are of
    interest.'
  prefs: []
  type: TYPE_NORMAL
- en: The **entities** layer holds all the entities that are present in the `entity`
    folder and are called upon by the `main.js` script. An entity can be anything,
    from the character the player uses, to an invisible trap that kills everything
    that dares to come close. All functionalities and the level's AI are in these
    entities. It can hold enemies, triggers, level changes, randomly flying objects,
    fireable projectiles, and everything that can be interacted with.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have critical bugs in these entities or some non-existing ones are included
    in your `main.js` script, the Weltmeister will not even load. So make sure at
    all times that these entities are bug-free (or not included) when you want to
    build a level.
  prefs: []
  type: TYPE_NORMAL
- en: Some entities, such as the player, are already present in the level. First select
    the **entities** layer in the **Layers** menu and then select the player entity
    in order to see its properties. The **x:** and **y:** properties are its current
    location and are always present while putting a new entity in the level.
  prefs: []
  type: TYPE_NORMAL
- en: Try moving the player entity around by selecting him and dragging him somewhere
    else. The **x:** and **y:** coordinates now change.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add an **enemy** entity to the level. Select the **entities** layer and
    press the Space bar while your mouse hovers over the level. A menu will appear
    next to your mouse; select the **enemy** entity in this menu. An enemy just appeared
    at your mouse's location! You will now be able to go crazy and basically paint
    every square with enemy entities, but this might be a little bit of overkill,
    so let's just place one enemy for now. Save and reload your game. Now tremble
    in fear as your enemy attacks you or stare at it unimpressed, your choice.
  prefs: []
  type: TYPE_NORMAL
- en: If you added too many enemies to safely roam about, remove them from the game
    by first selecting the **entities** layer in Weltmeister, then the enemies you
    want to get rid of and simply press the *Delete* key.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's a good habit to have both the game and the Weltmeister open to check the
    changes you made. If, for some reason, an entity you added is corrupt and the
    game refuses to load, at least you know the problem lies in the last changes that
    you made. Of course, you still have the Chrome or Firefox debuggers that will
    also point you in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: Adding objects is different from adding entities. Dead objects, which cannot
    be interacted with but are just a graphical thing, can simply be painted, for
    example, a square patch of grass, a fountain, or a castle wall. Complex interactions
    with these objects can be done but only with the use of entities. Here we will
    have a look at how to add a simple object, without interaction, to a level.
  prefs: []
  type: TYPE_NORMAL
- en: Although the level looks pretty neat, we will need to give it a makeover. Let's
    select the grass layer from the **Layers** menu. Hover your mouse over the map
    and press the Space bar key. A tileset will appear; you can make it disappear
    by tapping the Space bar key again. If this tileset does not fit your screen you
    can either hover your mouse to a more central location and bring it up there or
    zoom out with the scroll wheel of your mouse. If you do not have a scroll wheel,
    you can use the *Ctrl* + *-* (minus) key combination to zoom out and the *Ctrl*
    key with the plus sign key (*+*) to zoom back in. Now you can see your entire
    grass tileset. Select the grass and start painting it everywhere by clicking and
    holding the left mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A little trick for painting large areas with a single tile is to first paint
    only a small area on the map. Then click on the *Shift* + left mouse button and
    select this freshly drawn bigger area of tiles from the level itself. You can
    now paint with this new selection of tiles and cover more area in less time.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to delete something from a given layer, simply select an empty square
    that is empty for that particular layer. If you already have graphics from other
    layers on a certain spot, but not from the layer you are currently working on,
    that square can be considered empty. Now paint with this empty square and the
    formerly chosen tiles will magically disappear. Try deleting some of your grass
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Grass is at the bottom of everything. If you have an object, any object, it
    will always be on top of the grass, never underneath (except maybe in some crazy
    mole world). To make it so, you must drag your grass layer to the bottom of the
    layer stack.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add something else to the scene. We still have the layer that we created,
    `astonishinglayer`, ready to go, so let's draw a tree with it. In order to select
    the entire tree at once, select the tree by clicking on the *Shift* + left mouse
    button key combination. Depending on where you have put your layer, the tree will
    now always appear either in front of or behind the player. If you dragged the
    layer to the bottom of the list, it might even be invisible. It's a strange result
    and we will deal with this later. Save your level and reload to check out your
    first level creativity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding and removing entities and objects](img/4568_2_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Summing up the process of adding and removing entities and objects, we conclude
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: The entity layer provides the choice of all your game entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add some of the present entities to the level, and then save and reload
    the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collision layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **collision** layer is a special layer that is not predefined when you open
    the Weltmeister from scratch. It is special because it is an invisible layer that
    marks impassable areas. For example, if you draw a wall on your map by using a
    graphical layer, all your entities will be able to go right through it as if it
    isn't even there. If you want a wall that is actually capable of stopping the
    player and his enemies, draw a line in the **collision** layer where the wall
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Your game is still open; try drawing a wall (or any other object) and then running
    through it at the bottom of the level. You should find it peculiarly easy to just
    stroll through something that looks this solid. Select the **collision** layer,
    drag it to the top of the list if it isn't already done and make sure it's **visibility**
    option is turned on. All tiles are now clearly visible and as you can see, there
    are none at the bottom wall. Hover your mouse over the level's canvas and press
    the Space bar in order to bring up the collision tileset. Select a square and
    draw a line where the wall is. Deleting collision blocks is just like deleting
    graphics. Select an area on the map (with or without holding the *Shift* key)
    where no collision blocks are present and use this selection to delete the ones
    that are present. Save the level and reload the game. Now try walking through
    the wall again; it has become quite impossible; hurray for that!
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the previous process:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **collision** layer in the Welmeister
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw some tiles with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save and reload the game to see what happens if you want to walk where you drew
    the collision tiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting two different levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a sense of how to build a level by adding some graphics such
    as grass, trees, a player, and some enemies, it is time to have a look at how
    levels get connected.
  prefs: []
  type: TYPE_NORMAL
- en: For this, load the inside level into the Weltmeister. The inside level is situated
    inside a building (didn't see that coming, did you?). As we had to do with `myfirstepiclevel`,
    we need to change the call to the `loadlevel()` function in the `main.js` script,
    as shown in the next code snippet. This time, however, the level itself is already
    included in the `main.require` script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Again, don't forget the capital letters.
  prefs: []
  type: TYPE_NORMAL
- en: Load both the Weltmeister and the game itself to see if everything has been
    set up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Weltmeister, have a look at the level''s entities by selecting the **entities**
    layer. If you can''t get a good view on the entities present in the map, feel
    free to turn off the other layers by clicking on their white square. Alternatively
    you can press the Space bar while hovering over the map to bring up the entities
    selection menu. As always, we have a player entity so we can move around the place,
    but in the menu you should notice some extra entities such as **Void**, **Trigger**,
    and **Levelchange**:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Void** entity is a rather simple one; it is nothing but a box with a name
    and some coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Trigger** entity will trigger the code of any other entity to which it
    is linked if a certain type of entity (such as the player) collides with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **LevelChange** entity will make the game load another level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By intelligently combining these three entities you can connect levels, so
    let''s do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the **entities** layer is one of the top ones, so you can see what
    you add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start by selecting the **Trigger** entity and place it on the map near the door.
    It will be nothing but a small square at first, so make it a bit bigger so as
    to fit the exit. You do this by selecting the box, moving your mouse to one of
    its edges until you see a double arrow (double arrow symbol), and dragging it
    to make it bigger (the same way you would resize any window object on your PC).
    In choosing your size, your goal is to detect the player when he wants to use
    the door to get out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add a **Levelchange** entity. If you select the **Levelchange** entity,
    you will see its properties on the right-hand side. For now, this is just its
    location on the map (x and y coordinates) and its dimensions, in case you reshaped
    the box. Give the **Levelchange** entity a name by typing `name` in the key box
    and **ToOutside** as its value. Press the *Enter* key to confirm. Now you will
    see that the entity has an extra attribute (a name) with the value of **ToOutside**.
    Only by giving it a name can it be uniquely identified and that's what we need.
    We also need to tell him what level is needed to be loaded. Add the key **level**
    with a value **outside** and press the *Enter* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Trigger** and **Levelchange** entities are now both in the level but they
    are unaware of each other's existence yet; that's pretty important if we want
    them to cooperate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the trigger entity and give it a target. You do this by typing `target.1`
    as a key and **ToOutside** as a value. Notice the dot (`.`) after the word `target`;
    without it, it will not work. Now press the *Enter* key and watch as the two pretty
    squares get linked to each other by a white line as shown in the next figure.
    The **Trigger** entity now knows it is the **Levelchange** entity; it will have
    to trigger when touched by a player.![Connecting two different levels](img/4568_2_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save this and load the level. Walk your player towards the trigger location;
    the location of your **Levelchange** entity is irrelevant. If everything goes
    well, you should now be able to move to the next level by walking up to the door!
  prefs: []
  type: TYPE_NORMAL
- en: Strangely enough, when you enter the outside world, you are not placed next
    to the building. That is simply odd, even for a video game. Also, there is no
    way to go back inside when reaching for the door, you are stuck outside forever,
    or until you reload.
  prefs: []
  type: TYPE_NORMAL
- en: This is because no **spawnpoint**, **Trigger**, or **Levelchange** entities
    were added to the outside level. We will make up for that, but let's first add
    a spawn-point to the inside level.
  prefs: []
  type: TYPE_NORMAL
- en: To do this we will need the **Void** entity. Add the **Void** entity to the
    level and put it in front of the door, but past the trigger. Putting it too close
    to (or on top of) the trigger will cause the player to be zapped back outside.
    Although it's fun to make an eternal loop that zaps the player back and forth
    between levels, eternal loops (like dividing by zero) have a chance of destroying
    the world. Name the **Void** entity `insideSpawn`. Select the **Levelchange**
    entity and add the key **spawn** with value **OutsideSpawn**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting two different levels](img/4568_2_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are done with the inside level but now need to set up the outside level as
    its mirror opposite. So again, add a **Void**, **Levelchange**, and **Trigger**
    entity. Name the **Void** entity `OutsideDoor` since the **Levelchange** entity
    will look for this. Name the **Levelchange** entity `ToInside` and target the
    trigger to it. Also add the **Level** and **spawn** properties to the **Levelchange**
    entity. The values for these are (as you probably guessed) **Inside** for the
    **Level** property and **InsideDoor** for the **spawn** property.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting two different levels](img/4568_2_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Save and reload the game. If everything goes well you should now be able to
    move between both levels like a real pro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the complete process of connecting two levels:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the level inside in the Weltmeister
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add three entities to the level, **Trigger**, **Levelchange**, and **Void**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give every entity a name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the trigger point to the **Levelchange** entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add this information to the **Levelchange** entity: the level it needs to load
    and the spawnpoint it will have to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save inside, load the level outside, and repeat the exercise there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure both levels are saved and reload the game in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects – playable and non-playable characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have had a look at how to build a level, it is time to zoom into
    the code behind the entities we have been playing with. Though there is no official
    classification, things can be simplified by distinguishing three types of entities:
    dead objects, non-playable characters, and the player entity itself. These three
    types of entities are ordered in rising level of complexity and interactivity.
    In the first part of this chapter we took a look at the graphical layers of a
    game. Pure graphics have no element of interactivity at all; they are just present
    as stable elements. To get a bit of feedback from the game you are playing (building),
    you need entities. The least complex of these entities are the dead objects, which
    have no artificial intelligence whatsoever but can be interacted with, for example,
    pick-up items such as coins and potions. A type of entity we have already investigated
    is the **Trigger** entity, which itself is invisible but can be placed in the
    same level as graphics and can indicate what will happen further in the game.
    The graphics of lava will not kill you. An entity carefully placed underneath
    the lava, which tells the game to destroy everything that enters that area, can
    certainly kill you. A little bit up the scale of complexity are the **NPC''s**
    (**non-playable characters**). These are your enemies, your friends, everything
    you as a player will kill or defend, or just ignore if you feel like. They can
    range from mindless zombies to complex and very calculated opponents such as a
    chess computer. The last and most complex entity of the game is you, or at least
    your avatar(s). The playable character is by far the most versatile one and well
    worth elaborating on later in this chapter. Before we do so, we will first have
    to take a look at what makes an ImpactJS entity what it is.'
  prefs: []
  type: TYPE_NORMAL
- en: The ImpactJS entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to explain the basics of entities, it is best to first have a look
    at the dead objects. These entities have no complex behavioral patterns like non-playable
    characters or the player, but are certainly more complex than plain graphics.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this is the **Void** entity, a good friend we encountered while
    setting up the level transition earlier in this chapter. Open the `void.js` file
    in your script editor so we can have a look at it. The following code snippet
    is an example of the **Void** entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Every entity will at least call the `ig.module`, .`requires()`, and .`defines()`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ig.module` function, you define the **Void** entity as a module. The
    `ig.module` function call defines the **Void** entity as a new module. The module
    name should be the same as the script's name. The `void.js` file put in the `entities`
    folder within the `game` folder becomes the `game.entities.void` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `requires()` function will call the code on which this entity depends. Like
    all entities, the void entity depends on the entity prototype code from the Impact
    Engine, hence the name `impact.entity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `defines()` function enables you to define what this specific module is
    all about. Take a look at what is inside the `defines()` function. We see the
    `EntityVoid` module being defined as an extension of the entity class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Always add `Entity` in front of the entity name and don''t forget the capital
    letters. Weltmeister will not like it if you don''t and you will get an error
    message saying that it is expecting an entity with a different name. The following
    error will be generated by Weltmeister:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ImpactJS entity](img/4568_2_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Void** entity is a special entity because it is invisible in the game;
    this is apparent from the fact that the code does not point to a certain image
    from the `media` folder. Instead it has three properties that apply to the Weltmeister:
    `_wmDrawBox`, `_wmBoxColor`, and `_wmScalable`. The `_wm` prefix property indicates
    they are important for the Weltmeister.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet tells Weltmeister that it has to draw a box when the
    entity is inserted into a level. By setting this property to `false`, the color
    from the `_wmBoxColor` property will not be applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet defines the color of this box in an RGBA color scheme.
    For the **Void** entity, at present, the color is purple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet will allow you to make the box bigger or smaller.
    This is especially useful for things such as the **Trigger** entity, which you
    probably turned into a small but fairly long rectangle when previously connecting
    the two levels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, the `size` property is the default size of the
    entity. Since this one is scalable, you can change it in the Weltmeister.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally the `update()` function. Every entity calls this function once per frame,
    regardless of whether you explicitly mention the call to this function or not,
    as shown in the previous code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Try changing the default parameters of the **Void** entity and reload the Weltmeister
    to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: The **Void** entity is a simple and useful one, but let's face it, it's rather
    boring too. Let's have a look at something more interesting, such as coins. Let's
    say you want your player to grow richer every time he or she picks up a coin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a **Coin** entity example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this you will need a **Coin** entity, so let''s open the `coin.js` file
    in the editor. Similar to the **Void** entity, it has a name (coin), it requires
    the `impact.entity` library, is an extension of the prototype entity, and has
    a size. There are, however, some additional interesting properties in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `type`, `collides`, and `checkAgainst` properties are all about the coin''s
    behavior regarding collision with other entities. The `type` parameter tells the
    game that a coin belongs to type `B` when it has to evaluate collision. The coin
    never actually collides with anything because its `collides` property is set to
    `NEVER`. Other possibilities here are: `LITE`, `PASSIVE`, `ACTIVE`, and `FIXED`.
    The `LITE` and `PASSIVE` entities don''t collide with each other. The `FIXED`
    entities cannot be moved and `LITE` entities can be moved by the `ACTIVE` entities.
    In case an `ACTIVE` entity collides with another `ACTIVE` or `PASSIVE` entity,
    both entities move.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first it sounds tricky but it is worth experimenting with. Open the `player.js`
    file and make sure the `collides` property is set to `ACTIVE`. Now add a coin
    to the game, close to the player''s starting point, using the Weltmeister. Put
    the `checkAgainst` property of the coin in comments by adding two dashes(`//`)
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you set the mode of the **coin** entity to `FIXED` you will be unable to
    move the coin. When you set its mode to `PASSIVE` or `ACTIVE`, you can move the
    coin but it will be difficult because the coin pushes back. However, a **coin**
    entity set to the `LITE` property will be very easy to move about. Finally when
    the **coin** entity is set back to the property `NEVER`, the player goes straight
    through the coin as if it isn't there. We used the Weltmeister to add collision
    tiles to a wall; these tiles can be regarded as `FIXED` and thus will not be moved
    by an entity.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the dashes from the `checkAgainst` property for it to work again because
    this tells the **coin** entity to check if an entity of type `A` touches it (the
    player entity is set to `A`).
  prefs: []
  type: TYPE_NORMAL
- en: While the **Void** entity is visible, the coin has in-game graphics and they
    are in an **AnimationSheet** frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This `AnimationSheet` frame, however, is nothing but a 16-pixel square image,
    so it isn't really capable of real animation. For this you would need a single
    PNG file with at least two different images.
  prefs: []
  type: TYPE_NORMAL
- en: We can, however, replace this coin with the second one. Do this by changing
    `COIN.png` to `COIN2.png` (save and reload).
  prefs: []
  type: TYPE_NORMAL
- en: The `init()` function of every entity will define their standard properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since a **coin** entity doesn't have many properties, the `init()` method is
    rather empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we do have is a call to the parent entity, which in this case is just
    `entity`. The `this.addAnim()` function is an impact function capable of animating
    the coin. It has three inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: The status of the entity (`idle`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The speed between switching from one animation to another (`1` second)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The images on the tileset it has to go through (image `0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously since there is only one image, there is no real animation going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `check()` function is a very interesting method for every entity. The following
    example code explains the `check()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It checks whether there is an overlap with another entity and, if so, will do
    what is stated within the function. The `check()` method is tied to the `checkagainst`
    property; the only relevant overlap will be the ones with the type of entity stated
    there. In this case the `check()` function will go off when the player touches
    the coin. This will result in firing the function `ig.game.addCoin()` and then
    removing the coin from the game with the `this.kill()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Dead objects are often very simple entities with just a few lines of code, non-playable
    characters with even a simple AI, and playable characters are a different ballgame
    altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the creation of playable and non-playable characters, we can conclude
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to pure graphics, the ImpactJS entity is an interactive game element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dead objects are the least complex entities; two examples of this are the **Void**
    and **coin** entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Void** entity is invisible in the game but is visible in the Weltmeister
    because of its special Weltmeister properties. We used it as a spawn-point previously
    in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **coin** entity is visible in the game because it has an animation sheet.
    It can also be picked up by a player because of collision detection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Collision detection can take on several forms: entities can kill, block, push
    away, or simply ignore each other depending on its collision properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try messing around with all the explained parameters in the **Void** and **coin**
    entities to see what happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up player controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nothing is more interesting than the actual player and the enemies he or she
    sends to oblivion.
  prefs: []
  type: TYPE_NORMAL
- en: If you open the `player.js` and `enemy.js` files, you will see there is quite
    a lot to discuss about these entities. From animation over controls to sound effects
    and beyond, they are complex indeed. All these things will be gradually unraveled
    during the remaining pages of this chapter. But first things first, how does ImpactJS
    know the difference between a playable and non-playable character?
  prefs: []
  type: TYPE_NORMAL
- en: The fact that you called an entity player does not automatically make it so;
    ImpactJS does not have a reserved name for this entity in order to recognize what
    can be controlled and what is not player-controlled. This would be very limiting
    indeed since **RTS** (**Real Time Strategy**) games depend on the capability of
    moving different playable objects at the same time. This means the only element
    that differentiates the two entities is whether they are controllable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `player.js` file and scroll to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In here, we can see the player entity will react to input. When the input command
    `up` is given, the avatar will move upwards and show an animation. These `up`,
    `down`, `left`, and `right` states are not ImpactJS keywords. They are in fact
    defined in the main script. Open the `main.js` file and take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see which key is being associated to which input state. Also notice
    the `if` statementbefore the key bindings. First a check is done on whether you
    are dealing with a mobile device or not. This is because keys, such as the Space
    bar and the directional arrow, do not exist on iPads and iPhones. Try binding
    the attack state to your left mouse button instead of the Space bar with the code
    snippet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All the possible combinations can be found on the ImpactJS website.
  prefs: []
  type: TYPE_NORMAL
- en: Save and reload the game and notice how your trigger finger has moved from the
    Space bar to your left mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how these initial key binding definitions are in the `init()` function
    of the `main.js` script while it is waiting for input in the `player.js` script
    within its update function. This is because the actual binding of keys needs to
    be done only once (at game initiation), while your player needs to be controlled
    at all times. The `update` function is called every time the game goes through
    a full game cycle, which is the same as your framerate. Let's assume you have
    a framerate of 60fps (60 frames per second); the update function will, in this
    case, check for user input 60 times per second.
  prefs: []
  type: TYPE_NORMAL
- en: Things are a bit different when dealing with mobile devices. Since almost no
    keys are present, you will need to add artificial buttons by using HTML objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `index.html` file and type the following code for adding artificial
    buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When loading an ImpactJS game into the browser, it is this page that is actually
    loaded and the game itself is only shown in a canvas element within the page.
    This means that next to this canvas element, other things can be added, such as
    HTML buttons. Since every button can be pressed with a touchpad, an unlimited
    number of interactive functionalities can be added to the game by the smart use
    of these buttons. You can find the following button definitions in the `index.html`
    file, as shown in the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The buttons are `<div>` elements in which `div` is the short form for division.
    The <`div`> elements are used together with CSS code to lay out a webpage. In
    this case they provide us with four arrows to press for choosing the direction.
  prefs: []
  type: TYPE_NORMAL
- en: A `<div>` element has several attributes; among them, the `id` attribute is
    of particular interest to us since it uniquely identifies the `<div>` elements
    and enables us to link to the JavaScript code. This can be seen in the `bindTouch`
    method within the `main.js` script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Its first argument is the `<div>` element's unique ID preceded by a `#` symbol;
    this way JavaScript knows it needs to look for an ID. The second argument is the
    input state that we call `tbleft` (touchbound left).
  prefs: []
  type: TYPE_NORMAL
- en: If you have an iPad or any other mobile device, you would be able to load your
    game there if you had it on an online server.
  prefs: []
  type: TYPE_NORMAL
- en: Now the input keys (whether really on your keyboard or virtual ones) are bound
    to an ImpactJS state; these states can be used to follow player control. An example
    of this is of course moving in a certain direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the procedure for setting up the player controls:'
  prefs: []
  type: TYPE_NORMAL
- en: Having control over an entity is what separates the playable character from
    the non-playable characters (NPCs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The link between the keyboard and an action name is defined once in the main
    script. You should try changing these controls to accommodate your own preferences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The link between an action name and actually performing the action can be found
    in the player entity itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On mobile devices you are somewhat restricted to the touchscreen. Virtual buttons
    can be implemented using the HTML `<div>` tags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Position, acceleration, and speed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything has a location, and some things are on route to somewhere. Positioning
    in the ImpactJS world is done by the x and y coordinates and a third, less intuitive,
    z index.
  prefs: []
  type: TYPE_NORMAL
- en: The x and y coordinates are the distances to the top-left corner of the level,
    measured in pixels. The x coordinate is the position of any object on the horizontal
    axis, counted from left to right. The y coordinate is the position on the vertical
    axis, counted from top to bottom. This y coordinate is a bit counter-intuitive
    for people who are used to looking at graphs; the y coordinate is always 0 at
    the bottom and higher while moving upwards. Mind you, the top-left corner of a
    level is not always the same as the top-left corner of the canvas! The canvas
    through which you can see the game is only your window on the world. This is really
    evident with strategy games where you never see the entire world and often get
    a mini map in order to navigate faster from battle to battle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Position, acceleration, and speed](img/4568_2_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Every entity has an x and y coordinate and when you use Weltmeister, you see
    this change while dragging the entity over the map. Within the entity code, you
    can refer to (and change) its position like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is nice if you want things to teleport around, but often you just want
    them to move more subtly. For this we can adjust properties such as velocity and
    acceleration. Setting a velocity to a number different from `0` will make the
    entity's position change over time. Setting the acceleration will change the velocity
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We already saw this piece of code while discussing the player controls. The
    `this.vel.x = -100` command will make the player move upwards at a speed of 100
    px per second. You need the velocity to be negative to go up because, as we saw
    earlier, the y axis is inversed. The speed can be set separately for every direction.
    For example, you can create an area where strong winds make the hero move slower
    when going against them but remain unaffected when moving under a 90 degree angle
    and the player might even move faster with the wind in his/her back with the help
    of this command. Try changing the speeds to simulate a strong wind from the north
    with the use of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Acceleration in turn affects speed over time. Acceleration is a bit tricky,
    since slowing down does not naturally end up in stopping but in moving in the
    opposite direction, at which point slowing down actually becomes accelerating
    and vice versa. To introduce the acceleration factor, we insert the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure accelerating does not make your entity go at the speed of light,
    given enough time and button mashing, you can set a maximum velocity using the
    following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Try adding this code snippet to the `player.js init()` function or as a property.
    If your wind effect is still in place, it should be less strong downwind than
    it was before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the x and y coordinates, a third dimension is at play. To add a
    sense of depth to the game, entities can be placed in front of each other. For
    graphical layers, this can simply be done by shifting them up and down in the
    Weltmeister **Layers** menu. There you could put layers permanently in front of
    or behind each other and all entities. However, how entities are resolved among
    each other is not set in the Weltmeister, but by their respective z indexes. The
    z index of an entity is actually its place in the array of entities. To get a
    better grasp of what this means, have a look at the following Firebug representation
    of the game''s DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Position, acceleration, and speed](img/4568_2_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Entities that are at the end of the array will get drawn last by the game''s
    `draw()` method. Getting drawn last means you will be drawn on top of all the
    other ones and thus appear as if in front of them. All newly spawned entities
    get appended to the end of the list. The younger the entity, the closer it will
    appear when put above others. This can be avoided by manually setting the z index
    and using the game''s `sortEntitiesDeferred()` method in the `main.js` update
    function of the `player.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `main.js update()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Your player can move, but how does it move so gracefully instead of just gliding
    from point A to B? This all has to do with sprites and animation sheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the position, acceleration, and speeding procedure, we conclude:'
  prefs: []
  type: TYPE_NORMAL
- en: Every entity has a position, a velocity, and acceleration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try changing the player's velocity in order to change his/her position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try changing the acceleration in order to change the velocity and consequently
    the player's position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every entity has a z coordinate, which indicates whether the entity should be
    drawn in front of or behind the other entities. Try changing the z coordinate
    for the player to a very high number. Now the playable character will be drawn
    behind all other entities in the level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The game''s graphics: sprites and animation sheets'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A sprite is a drawing, which is put on a transparent background and then saved
    in a file format that can keep that background transparent like a `.png` or `.gif`
    format. JPEG, for instance, cannot have transparent parts. Having one drawing
    of a character, let's say a red whale with nuclear claws, is nice. However, for
    animation you need more than one of these drawings, preferably from different
    angles. All these drawings are then put together in one file (again, not a `.JPEG`
    format) where they form an animation sheet.
  prefs: []
  type: TYPE_NORMAL
- en: '![The game''s graphics: sprites and animation sheets](img/4568_2_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Good sprites and animation sheets are not all that easy to come by and the ones
    you can find on the Internet are often licensed and prohibited for game publishing.
    You can either draw them yourself or buy them on websites such as [www.sprites4games.com](http://www.sprites4games.com).
  prefs: []
  type: TYPE_NORMAL
- en: The animation sheets are typically placed in the `media` folder, though it's
    not mandatory and entirely up to you on how you structure them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You assign an animation sheet to an entity by calling the `AnimationSheet()`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the location and name of your animation sheet. Never forget,
    a location is always specified relative to its root folder, which should now be
    the `myfirstawesomegame` folder. The fact that it is stored in the `htdocs` folder
    of the XAMP file structure does not count. The second and third arguments are
    respectively the width and height of every animation in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the animation sheet is linked to the player, all the possible statuses
    a player can take need to be linked to a certain sequence of images. The entity''s
    `addAnim()` method allows you to link the possible statuses to a certain sequence
    of images as shown in the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At player initiation (the `init()` function), a few sequences are defined and
    given a name. The simplest one is `idle`. The player simply does nothing and only
    requires one image, which is at position 0 (`[0]`) on the animation sheet. All
    JavaScript arrays start at index 0 and so does the animation sheet array for ImpactJS.
    A 128 x 192 pixel animation sheet can hold 16 images of 32 x 48 pixels, numbered
    0 to 15\. The numbering starts at the top-left corner of the sheet and stops at
    the bottom-right corner, just like you would read the pages of this book (except
    maybe if you are Chinese).
  prefs: []
  type: TYPE_NORMAL
- en: 'Walking to the left requires only three distinct images: looking to the left,
    sticking out the right leg, and sticking out the left leg. While animating, looking
    to the left is repeated in between the switching of legs, which gives it the impression
    of someone walking, if the speed is set correctly. Here the speed in between switching
    images is set at `0.1` second, which is quiet hasty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try setting the speed to `100` seconds for the idle animation and `0.5` seconds
    for the walking animations as shown in the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice how setting the speed for an idle animation to `100` seconds didn't affect
    it at all because there is no real animation, it's just one image anyway. Quintupling
    the time between images for walking does have a big visual impact though. The
    player now looks like he's floating, a bit like a ghost.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you need to update the entity property `currentAnim` with the animation
    needed at the time. Updating this entity property with the animation needed changes
    the animation sequence when speed and direction by user input are changed.
  prefs: []
  type: TYPE_NORMAL
- en: You could mess around with this too. For instance try setting the animation
    to right when the player walks left and vice versa. Combine this with a pretty
    slow animation and oh yes, you're moonwalking!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Summing up the procedure of boosting the game''s graphics using sprite and
    animation sheets, we can conclude that:'
  prefs: []
  type: TYPE_NORMAL
- en: Every visible entity has an animation sheet. The animation sheet is a composition
    of all the different ways an entity can look. Try changing the animation sheet
    for the player entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The animation sequence will tell the game which images should follow each other
    while a certain action is performed. Playing around with the sequence and speed
    of animation can create interesting effects. Try replicating a ghost or a moonwalking
    character using only the `addAnim()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning, health, and death
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every being has a beginning, life, and death. It would be kind of harsh to say
    you spawned from your mother's womb all these years ago. But in game terms, that
    is what you did.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, there is no limit to the number of entities that can be spawned in
    a single game; in practice this is limited by performance issues, especially on
    mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at an entity that is regularly spawned and destroyed: the
    projectile.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The projectile is spawned by the player when he feels his trigger finger itching.
    In the `player.js` update function you will find the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Spawning is done by the `ig.game.spawnEntity` method. All that is really required
    for this method to work is the entity type and the location where it needs to
    be spawned. The fourth argument, which is a set of extra settings you might want
    to add, is optional, but is used now to tell the bullet in which direction it
    is fired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anything can spawn an entity. The same way the player spawns a projectile,
    the **Levelchange** entity will spawn the player. In the `levelchange.js` file
    you will find the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: What this piece of code does is it detects whether a spawnpoint is present in
    the level to which the player wants to travel and if so, kills the player that
    might be preset. In Weltmeister you can add a player entity to the level; this
    way you can test it separately without going through the fuss of walking through
    all the other ones that might come before it. This preset player entity is killed
    and replaced by a new one at the location of the appropriate spawnpoint. Then
    the `ig.game.player` variable is set to the first preset (`[0]`) player entity
    he finds. This last part is not mandatory but it's sometimes handy to have a direct
    link to the player entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The projectile itself doesn''t really have a specified health in this case,
    but it can be killed with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the projectile can only live for 100 frames. You could also control the
    lifetime of an entity with real timers or destroy it when it hits something on
    which it can inflict damage. Change the value from `100` to `1000` to see the
    projectile''s range increase drastically. Alternatively you could add a new property
    to the projectile called `range`, and replace the lifetime check with this one.
    Add the range property in the `init()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the check function replace the value `100` by `this.range`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! Your code has again become a bit more readable and flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The projectile can also be destroyed when it hits an enemy using the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Killing an entity is simply done by calling the `kill()` method but the entities
    `receiveDamage()` method will also call the `kill()` method if health reaches
    the value 0.
  prefs: []
  type: TYPE_NORMAL
- en: So what happens in this projectile check function? If the projectile collides
    with an enemy, it will receive damage equal to `100` by `this` (the projectile).
    If this happens, the projectile is destroyed in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spawning and death are simple things in ImpactJS, health even more so. While
    you spawn or kill an entity with a method, health is nothing but a property you
    can set and change at will. In the `player.js` file you will see that the player
    has a health of `400` if the following code has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Deducting health is built into the Impact Engine by means of the `receiveDamage()`
    method; you can increase health with the same method. Try setting the damage in
    the `receiveDamage()` method to a negative amount and you just invented the healing
    projectile!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Summing up the complete process of spawning, heath, and death, we can conclude
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: Every ImpactJS entity can spawn, lose, gain health, and get killed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try changing the spawn position of the projectile entity to make him spawn closer
    or further away from the player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The projectile causes damage to other entities; try inversing the effect to
    create a healing arrow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The camera view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the world you explore is small and cozy, it's easy to keep an overview
    at all times. This does not remain the case with bigger levels and smaller screens.
    If it is your goal to ever release a game for a mobile phone, you must master
    the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Your camera is nothing but your window to the world. When your world is big,
    you will need to adjust your window regularly to keep track of things. There are
    several types of cameras but the two most important ones are the free to move
    camera and the automatic camera.
  prefs: []
  type: TYPE_NORMAL
- en: However, before diving into the camera itself, it is best to have a look at
    the canvas element and the way it is set up in an Impact game.
  prefs: []
  type: TYPE_NORMAL
- en: The game canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you open both `main.js` and `html.index`, you should find all the canvas
    code you need since this is such a high-level game component. Within the body
    tags of the HTML document you will find the canvas that holds the cinema screen
    of your game. The canvas element has an ID called `"canvas"`, which makes it possible
    to link it to JavaScript by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main.js` file you can find the `main` method of the `ig` object. This
    method links the entire game to the canvas by looking up its ID. If JavaScript
    needs to look up an HTML ID, it is always preceded by the `#` symbol as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `ig.main()` method has 6 parameters. The first one is the canvas ID, then
    the name of the game as specified earlier in the `main.js` file. The third parameter
    indicates the frames per second at which the game needs to run; however, this
    one has become obsolete and will probably be removed entirely in future versions.
    Nowadays, the engine itself decides the optimal framerate, so manual setting has
    become impossible.
  prefs: []
  type: TYPE_NORMAL
- en: The last three parameters are the width and height of the canvas and the zoom
    you want to use. Zoom is something peculiar because it upscales everything by
    the factor you put down.
  prefs: []
  type: TYPE_NORMAL
- en: 'A canvas with dimensions 640 x 480 and a zoom value of 1 will really be 640
    x 480 pixels big and every character in it will have its original dimensions.
    If, however, you put the value of zoom as `2`, dimensions will be multiplied by
    2 and so will everything in the game. If, for instance, you have only 640 x 480
    pixels available, but you can barely see your main character, divide the dimensions
    by a value of 2 and set the zoom value to `2` as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Try setting the zoom value to `6` for extreme eye pain and blurriness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up canvas characteristics, we can conclude that:'
  prefs: []
  type: TYPE_NORMAL
- en: The game canvas is your window to the game world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several elements of this window can be changed; size and zoom are the most important
    ones. Try changing them both in order to adjust perfectly to your own screen resolution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free to move camera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A free to move camera, as the name states, is free to move by the player himself.
    These viewports are used typically in RTS games because many things are under
    the player''s command. For example, in the famous game Red Alert, you have dozens
    of tanks, airplanes, soldiers, and crazy submarines roaming about. Good players
    have theirs dispersed all over the map, attacking various targets at once. Camera
    controls in such a game are more sophisticated than the simple introduction we
    are going to explore here, but you have to start somewhere. Find the free to move
    camera''s code in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The screen object represents the part of your game that you can see, that is,
    the earlier mentioned view-port. Here, the screen is assigned to a local variable
    called `gameviewport` so that it can be manipulated with the buttons. For example,
    every time the player hits the `camera_right` button, the window is changed to
    the right by 2 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the camera movement procedure, we can conclude that:'
  prefs: []
  type: TYPE_NORMAL
- en: The free to move camera will adjust the window only when manually told to do
    so
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can try moving the camera around in the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically following camera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Making an automatically following camera might sound a lot more difficult but
    it does not need to be. We can see the simple process of adding an automatically
    following camera in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here an extra element is introduced: the canvas itself. The `ig.system` object
    makes sure the game loops and is also responsible for the input. The `ig.system`
    object is usually called through the `ig.main()` function, which we saw when looking
    at the canvas and thus takes the same arguments. Here it is assigned to a local
    variable `gamecanvas` and we need it to get the actual dimensions of the view-port
    we are handling. The player entity is also assigned to a local variable `player`.
    As you might have noticed, the first player entity is taken (index 0 of the array).
    So, in case there are multiple player entities, only the first will be focused
    upon. This makes it an automatically following camera, rather unsuitable for games
    with several playable entities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The game window is constantly updated with the position of the player (for
    both x and y axes) and the map width is divided by 2\. This last deduction is
    to keep the player firmly centered. Try leaving out this last part and watch what
    happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The view-port will be updated to keep the player on the screen but the player
    is placed on the top-left corner. It will always be on the top-left corner since
    coordinates for the x axis are counted left to right and coordinates for the y
    axis increase from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the procedure of creating an automatically following camera, we
    can conclude that:'
  prefs: []
  type: TYPE_NORMAL
- en: The automatically following camera tries to keep the player in the middle of
    the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can try changing the code so that the player is kept in the top-left corner
    of the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding music and sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are good games and there are truly, epically memorable games. Any game
    can hold itself just on a great gameplay and some decent graphics alone; you don't
    always need music. Minecraft is a great example of this type of game; you don't
    actually play it for its refreshing music. But for those who played Zelda Ocarina
    of Time and any Final Fantasy, you know that music is what puts the icing on the
    cake. It has to be said in advance, music can sometimes be a buggy thing on mobile
    devices. Concurrently playing two sounds is often impossible. This is something
    rather basic since background music and sound effects always overlap. Because
    of its unruly nature on mobiles and for the sake of reproducibility, we will only
    look at desktop versions here.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main types of sound: the real music and the sound effects. The
    real music consists of composed songs; for modern (and expensive) games these
    are often orchestrated. The sound effects are the grunts of your enemies, the
    clashing of swords, the sound of your footsteps, and a gust of wind. If you want
    to get yourself some actual music, you can compose it yourself or buy it. When
    you need sound effects, you only need to get yourself an audio recorder and a
    list of sounds you need and organize a recording session with some of your best
    friends.'
  prefs: []
  type: TYPE_NORMAL
- en: Playing background music
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `main.js` file you should find the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The first important element you see here is `ig.music`, which is (as you probably
    guessed) the object that takes care of all music. The music array forms the list
    of all the music you will want to use, and adding a song is done the same way
    you add something at the end of any array, that is, using the `.add()` method.
    The method needs only one parameter: the music file you want to use with its location
    relative to the game''s root folder. You can set the volume with the volume property.
    The volume can range from value `0` to `1`. Of course you can set the volume to
    `1` as much as you want, there will be no sound if you don''t activate the music.
    This is done with the .`play()` method. Try setting the music volume to 1 and
    reload the game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether the player wants to hear your music or not should really be up to her
    or him. Let''s say they are playing your game during class; you don''t want them
    to get caught do you; that would be evil. For this purpose, you will find the
    following code in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It basically checks whether the sound buttons (which you have defined earlier)
    are pressed and if so, volume is increased, reduced, or just turned off entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the entire process of adding music and sound effect, we can conclude
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: Music can be added to the game in either the `.mp3` or `.ogg` format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `music` class is especially useful for entire tracks of music since it has
    several functions equivalent to a standard radio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can try changing the volume and turning the music on and off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing sound effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Music is a continuous thing and not really dependent on the game events (except
    maybe some more nervous music when your player is almost dead). Sound effects
    on the other hand can be added to almost anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `player.js` file and find the following code in its `init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Another new object, `ig.sound`, will be able to handle any sound you offer it,
    including background music. It is, however, still better to attribute your music
    to the `ig.music` object because of the extra options you have for handling music
    tracks. For example, with the `ig.music` object, you can shuffle your tracks (`.random`)
    or add a fade out effect (`.fadeOut`) if not already included in your MP3 file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The walk sound is added as a new sound to the player entity (`this`) and its
    volume is set to `1`. We have a sound to add for the footsteps but it wouldn''t
    make much sense to hear footsteps when he is not actually walking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When the player is not strolling around, all is quiet. If he starts walking
    again, the sound of footsteps resumes. There are many more examples for adding
    sound effects, but for now we will end it at this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the complete procedure to add sound effects, we can conclude that:'
  prefs: []
  type: TYPE_NORMAL
- en: A sound effect is a short sound that is usually only played when a certain action
    happens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sound effect will only play once by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can try activating the snow-walk sound effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game physics with Box2D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To end the exploratory chapter, we will have a look at the physics engine of
    ImpactJS: Box2D. Physics engines are game engines capable of simulating many of
    the visible forces at play on earth like gravity and pressure forces (impact).
    One of the most famous games with a physics engine is, of course, Angry Birds.
    Physics was used in lots of games before this 2D world hit (such as Half-life
    and games even way before this one). Angry Birds should, however, be an example
    of how a simple game (combined with a considerable marketing machine) can reap
    enormous success.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The engine is not an invention of Dominic (maker of ImpactJS) but a port from
    Flash ActionScript to JavaScript. As such, a full description of all the Box2D
    capabilities is not available on the Impact website (as it is for the Impact Engine),
    but it is available on the following website: [http://www.box2dflash.org/docs/2.0.2/manual.php](http://www.box2dflash.org/docs/2.0.2/manual.php).'
  prefs: []
  type: TYPE_NORMAL
- en: The documentation on combining ImpactJS and Box2D, however, is fragmentary at
    best. You need a totally different way of thinking when building a game with physics
    versus one without and that is why the source code is also separate from the standard
    package. As mentioned in [Chapter 1](ch01.html "Chapter 1. Firing Up Your First
    Impact Game"), *Firing Up Your First Impact Game*, you can get your Box2D source
    code from a downloadable file called `physics` when you buy ImpactJS. The folder
    called `Box2D` should be placed under the `plugins` folder in order to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the Box2D code, load up a game and press the *Shift* + *F9*
    key combination. You are now magically teleported to the bizarre world of Box2D,
    where things can fly and gravity soaks everything back down. Try pushing the coins
    around and see how they react to well placed headbutts from different directions.
  prefs: []
  type: TYPE_NORMAL
- en: Gravity and force
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you open the `main.js` file, you will stumble upon a new game definition.
    This time it is not an extension of the standard `ig.game` function, but `ig.Box2DGame`.
    Yes, it is possible to define different games in a single file and often this
    technique is used for making game over screens, splash screens, and the sort using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Right from the beginning we can define the gravity of the world as a property
    of the `BouncyGame` variable. Feel free to change it and watch the difference
    in gravity take effect in the game. Gravity does not need to be a positive force
    either. Try setting it to a negative number such as `-100` and you will see everything
    being drawn towards the ceiling.
  prefs: []
  type: TYPE_NORMAL
- en: The stronger the gravity, the more force you will need to overcome it. With
    a gravity value of `300` (or `-300`) your movement becomes restricted to left
    and right.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be changed in the player entity itself. Open the `boxPlayer.js` file
    to find a special instance of the player entity. Special, because it is not an
    extension of the normal player entity, but the other entity called the `Box2DEntity`,
    as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Also notice that we needed to include the Box2D entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the normal Impact Engine makes use of velocity, Box2D uses vectors. As
    you might remember from physics and mathematics, a vector is a line with both
    direction and magnitude; let''s take a look at how it is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: For example, for going upwards you apply force with your own body on the position
    of your body. The force you output has a magnitude of `200` as shown in this example.
    We changed the value of gravity to `300` so we don't have enough to overcome it
    with a force of 200\. Try setting its value to `500` and you will be able to gradually
    overcome gravity again. Set its value to `1000` and even though you will still
    fall like a brick, overcoming gravity by pressing the up button becomes a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the concept of gravity and force, we can conclude that:'
  prefs: []
  type: TYPE_NORMAL
- en: Box2D is a physics engine, not officially part of ImpactJS, but fairly integrated
    with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Box2D is vector-based. All movements translate in a combination of force and
    direction. Gravity is just a specific case, always having a vertical direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try changing the game's gravity to make things float upwards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the force that is applied to the player when pressing the up button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision impact and bounciness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While hitting another object like a coin, it can be moved by the force of the
    impact. You probably tried doing that already. The force the player exerts is
    applied to the coin and it goes flying. Eventually the coin is brought to rest
    again by gravity but you are free to hit it again of course.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coin also has a certain amount of bounciness, which in Box2D is called
    restitution. The value of restitution can be set on a scale from `0` to `1`. Since
    force decreases over time, an object will never bounce back at the same speed
    with which it hit the wall. You can set the bounciness of the coin yourself in
    the `boxcoin.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Try setting the value of restitution to `0` and see if the coins still bounce
    off the walls.
  prefs: []
  type: TYPE_NORMAL
- en: This was a very short introduction to Box2D. In the next chapter we will build
    up a small RPG from the ground up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the collision impact and bounciness concept, we can conclude that:'
  prefs: []
  type: TYPE_NORMAL
- en: Collision between two bodies in a Box2D environment will translate in each body
    exerting a certain force on the other body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A body can have a certain amount of elasticity when hitting a solid object;
    this is called restitution or bounciness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can try changing the restitution of the coin entity and observe the small
    difference in bounciness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of this chapter was to grant a quick insight into each of the important
    components of an Impact game by exploring a pre-made example. We first used the
    Weltmeister tool to open an existing level and gain a deeper insight into how
    it is built up out of layers and entities. We took a look at a playable character
    and how it differs from a non-playable character. By adapting some entity parameters
    we could change things like health, movement speed, and even the way our entities
    look. Since in most games you can't see your entire playing field on a single
    screen, we took a look at a manual and automatically following camera. We added
    a background tune and sound effects as part of the atmosphere of a game.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we took a quick peek at the Box2D physics engine. While in this chapter
    we have only been tweaking parameters, in the next chapter we will build a game
    from the ground up.
  prefs: []
  type: TYPE_NORMAL
