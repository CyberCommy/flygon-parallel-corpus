- en: Chapter 4. Securing Your Backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we built a rudimentary but functional backend layer
    by layer to provide basic services for a basic shop-like app. So far, we haven't
    been paying too much attention to security; everyone with access to the server
    can execute any command exposed by our API, even if it involves deleting the whole
    product database!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to remedy this by building a basic security mechanism
    in order to control user access. Specifically, we will deal with token-based authentication
    and show you how this makes it easy to limit access to your backend. By doing
    this, we will introduce the concept of roles and how they figure in our authentication
    scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the outcomes of token-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you will understand what token-based authentication
    is and how it can be used to limit the functionality of an API based on a user's
    status. You will further understand what roles are and how they affect authentication.
    Finally, you will know how to implement this authentication mechanism using only
    the technologies that we have introduced so far.
  prefs: []
  type: TYPE_NORMAL
- en: The theoretical bit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start writing code, let's have an overview of the concepts involved
    and how they relate both to security and one another.
  prefs: []
  type: TYPE_NORMAL
- en: A small token of trust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security has always been one of the most pressing concerns in all areas of software
    development. It is almost never enough to have a system that is fast, scalable,
    and robust if it doesn't have an adequate mechanism to protect it from malicious
    users.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of publicly accessible servers such as ours, security is all
    the more pressing since our API will be exposed to an entire planet of potentially
    nasty people. Somehow, we need to make sure that the people who request services
    from it are who they say they are and are allowed to do what they want to do.
  prefs: []
  type: TYPE_NORMAL
- en: A simple yet powerful technique that has emerged to accomplish this is **token-based
    authentication**. In this, each legitimate user is given an access token (usually
    a hash), which uniquely identifies the user of a server. The user needs to submit
    the token along with every request that requires authentication, and the server
    in turn validates the token in order to determine whether access should be granted.
  prefs: []
  type: TYPE_NORMAL
- en: In order to obtain an access token, the user will first need to initially authenticate
    themselves to the server in some way. Commonly, this is done via a normal username-password
    check. If a correctly matching username and password is provided, the server responds
    by generating an access token, certifying that the user is authenticated to access
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: Playing your role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most software systems, not all users are created equal. Some, such as the
    administrators, are intended to have broader access to the system than the common
    users. There are several schemes that allow us to limit what functions within
    a system a user can access, but the most common one probably is to use roles.
    Put simply, a role is an attribute that grants its holder a certain level of access
    to the system. For example, a user with the role of **administrator** may have
    full access to read and write system records, whereas a user with the role of
    **reader** may just be able to read them. Further more, a user with the role of
    **BookWorm** may only have access to read data records classified as **books**,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, it is probably apparent how roles and tokens figure in the authentication
    scheme that we want to create. The lifetime of an authenticated request will proceed
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: The server receives an API request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server checks whether a token is provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is not provided, it returns a *403* (that is, **forbidden**).
  prefs: []
  type: TYPE_NORMAL
- en: The server checks whether the token is in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is not in the database, it returns a *403*.
  prefs: []
  type: TYPE_NORMAL
- en: The server retrieves the user's role.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server verifies that the user's role matches the requirements of the API
    call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it does not match them, it returns a *403*.
  prefs: []
  type: TYPE_NORMAL
- en: The server handles the request and returns an appropriate response to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to write a functional implementation of the authentication
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is expand our database to accommodate the
    necessary documents. In particular, we need to add the following three new collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Users**: These are the users who can access the server via the API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roles**: These are the roles that can be assigned to users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access Tokens**: These are the access tokens for authenticated users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also need to add some rudimentary logic to our API to register users
    and enable them to log in.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the new collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open your MongoDB shell and execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the necessary collections that we need to store users and
    their roles and tokens. The new documents will have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, we will not add any users or tokens (this comes later when we extend
    the API), but we will add the roles that we are going to use. To keep it simple,
    we will just have two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Producer**: This is the user who sells goods in the shop and who can add
    additional products to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer**: This is the user who buys things from the shop and who can create
    orders and retrieve information about products as well as orders that were created
    by the current user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is understood that default `ObjectID` generated by MongoDB will be included
    in the preceding code. For the access token entity, we simply use `ObjectID` as
    the hash of the token, since this value is guaranteed to be unique with respect
    to the database that we are working with.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an authentication module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To maintain modularity and simplify the authentication process, we will create
    a separate module to validate the access privileges of a given user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your project directory, add the following file named `authentication.js`.
    Open the file and insert the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, import the module into your entry module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating functions to register and help users log in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will need to add endpoints to our API for the purpose of both creating and
    authenticating users who wish to interact with it. In light of what we have done
    thus far, this is easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: Registering users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We begin by adding a URL endpoint for adding users. This will be very familiar
    in terms of what we already did when creating the REST API in the previous chapter;
    all that we are going to do is create a `POST` method for the `user` collection.
    First, add the following utility method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify your router to include the following `case` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need to register users. Registrations can now be handled through
    a simple `POST` request to the `/api/users/register` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling users to log in
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enable users to log in via our API, we will need to accomplish the following
    three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the user exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that a matching password was provided by the the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return an access token, which can be used by the user for future access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, all but the first of the preceding list are taken care of by the authentication
    module that we designed earlier. All that we need to do is plug it into our router.
    To do this, we will also need to design a new endpoint for the login part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `case` to your router configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we added the following simple method in order to handle
    the looking up of a user by e-mail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That's all we need as far as user management is concerned for now. Now, let's
    add the finishing touch and set up the actual security for our endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Extending our API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready to modify our API in order to add the authentication features
    that we have developed so far. First, let''s determine exactly how the access
    policies should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Customers** should be able to create (`insert`) orders and retrieve (`get`)
    information about products and nothing else'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Producers** should be able to retrieve information about orders and products
    and also insert new products'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will accomplish this by placing a simple token and role check on each endpoint.
    The check will simply verify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The token is legitimate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user associated with the token has the role that is necessary to perform
    the requested action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start, we will add a new function to the `authentication` module, which
    will be responsible for checking whether a given token is associated with a given
    role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This method is all that we need to verify the roles for the token provided (implicitly
    checking whether the user who owns the token has the specified role).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we simply need to make use of this in our router. For example, let''s
    secure the `POST` endpoint for our product API. Make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Implementation for the other endpoints is the same, and we will provide
    you with the full example source code for them.
  prefs: []
  type: TYPE_NORMAL
- en: Though I have covered some basics here, security remains one of the largest
    and most diverse areas of contemporary software development. We believe that token-based
    authentication will address a majority of the cases that you are bound to come
    across in your career. I would like to offer some suggestions for future study
    as well as complements to the topics that you have studied here.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common authentication standards offered by modern web apps is
    **OAuth** (**Open Authentication Standard**), its second version (**OAuth2**)
    in particular. OAuth makes heavy use of access tokens and is used by (among others)
    Facebook, Google, Twitter, Reddit, and StackOverflow. Part of what makes the standard
    powerful is that it allows users to sign in with their Google or Facebook accounts,
    or even some other account that supports OAuth2, when using your services.
  prefs: []
  type: TYPE_NORMAL
- en: There are several mature NPM packages for using OAuth2 with Node.js. In particular,
    we recommend you to study the node-oauth2-server package ([https://github.com/thomseddon/node-oauth2-server](https://github.com/thomseddon/node-oauth2-server)).
  prefs: []
  type: TYPE_NORMAL
- en: Time-stamped access tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To keep things simple and focus on the main concepts, we have allowed our access
    tokens in this example to be permanent. This is a very bad security practice since
    tokens, like passwords, can be compromised and used to grant unauthorized users
    access to the system.
  prefs: []
  type: TYPE_NORMAL
- en: A common way to reduce this danger is to impose a **Time To Live** (**TTL**)
    value on each access token, indicating how long the token can be used until the
    user has to authenticate themselves again in order to get a new token.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, we allowed passwords in this example to be stored
    and retrieved as plain text. Needless to say, this is an abysmal security practice
    and nothing that you should ever do on a production server. Mature Node.js frameworks
    such as Express.js provide built-in mechanisms for hashing passwords, and you
    should always choose those when available. In the event that you need to hash
    passwords on your own, choose the `bcrypt` module in order to both hash and compare.
    Here''s an example of the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about token-based authentication and saw how it
    can work in practice to reinforce the backend. To put it into practice, we wrote
    a simple token-based access system to protect access to a set of backend data.
    Our server is now almost complete, but we must still deal with some other pressing
    concerns that modern apps need to face.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to address one of these most important
    concerns.
  prefs: []
  type: TYPE_NORMAL
