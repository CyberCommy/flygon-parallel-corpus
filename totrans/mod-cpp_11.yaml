- en: Standard Library Containers, Algorithms, and Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using vector as a default container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using bitset for fixed-size sequences of bits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using vector<bool> for variable-size sequences of bits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding elements in a range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting a range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing a range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using set operations on a range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using iterators to insert new elements in a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own random access iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container access with non-member functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using vector as a default container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard library provides various types of containers that store collections
    of objects; the library includes sequence containers (such as `vector`, `array`,
    or `list`), ordered and unordered associative containers (such as `set` and `map`),
    and container adapters that do not store data but provide an adapted interface
    towards a sequence container (such as `stack` and `queue`). All of them are implemented
    as class templates, which means they can be used with any type (providing it meets
    the container requirements). Though you should always use the container that is
    the most appropriate for a particular problem (which not only provides good performance
    in terms of speed of inserts, deletes, access to elements, and memory usage but
    also makes the code easy to read and maintain), the default choice should be `vector`.
    In this recipe, we will see why `vector` should be the preferred choice for a
    container and what are the most common operations with `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reader is expected to be familiar with C-like arrays, both statically and
    dynamically allocated.
  prefs: []
  type: TYPE_NORMAL
- en: The class template `vector` is available in the `std` namespace in the `<vector>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To initialize a `std::vector` class template, you can use any of the following
    methods, but you are not restricted to only these:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize from an initialization list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize from a C-like array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize from another container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize from a count and a value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To modify the content of `std::vector`, use any of the following methods, but
    you are not restricted to only these:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an element at the end of the vector with `push_back()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove an element from the end of the vector with `pop_back()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert anywhere in the vector with `insert()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an element by creating it at the end of the vector with `emplace_back()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert an element by creating it anywhere in the vector with `emplace()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To modify the whole content of the vector, use any of the following methods,
    but you are not restricted to only these:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign from another vector with `operator=`; this replaces the content of the
    container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign from another sequence defined by a begin and end iterator with the `assign()` method;
    this replaces the content of the container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Swap the content of two vectors with the `swap()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove all the elements with the `clear()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove one or more elements with the `erase()` method (which requires either
    an iterator or a pair of iterators that define the range of elements from the
    vector to be removed):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the address of the first element in a vector, usually to pass the content
    of a vector to a C-like API, use any of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `data()` method, which returns a pointer to the first element, providing
    direct access to the underlying contiguous sequence of memory where the vector
    elements are stored; this is only available since C++11:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the address of the first element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the address of the element referred by the `front()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the address of the element pointed by the iterator returned from `begin()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::vector` class is designed to be the C++ container most similar to
    and inter-operable with C-like arrays. A vector is a variable-sized sequence of
    elements, guaranteed to be stored contiguously in memory, which makes the content
    of a vector easily passable to a C-like function that takes a pointer to an element
    of an array and, usually, a size. There are many benefits of using a vector instead
    of C-like arrays and these benefits include:'
  prefs: []
  type: TYPE_NORMAL
- en: No direct memory management is required from the developer, as the container
    does this internally, allocating memory, reallocating, and releasing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that a vector is intended for storing object instances. If you need to
    store pointers, do not store raw pointers but smart pointers. Otherwise, you need
    to handle the lifetime management of the pointed objects.
  prefs: []
  type: TYPE_NORMAL
- en: The possibility of modifying the size of the vector.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple assignment or concatenation of two vectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct comparison of two vectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vector` class is a very efficient container, with all implementations providing
    a lot of optimizations that most developers are not capable of doing with C-like
    arrays. Random access to its elements and insertion and removal at the end of
    a vector is a constant *O(1)* operation (provided that reallocation is not necessary),
    while insertion and removal anywhere else is a linear *O(n)* operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to other standard containers, the vector has various benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It is compatible with C-like arrays and C-like APIs; the content of other containers
    (except for `std::array`) needs to be copied to a vector before being passed to
    a C-like API expecting an array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the fastest access to elements of all containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has no per-element memory overhead for storing elements, as elements are
    stored in a contiguous space, like a C array (and unlike other containers such
    as `list` that requires additional pointers to other elements, or associative
    containers that require hash values).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` is very similar in semantics to C-like arrays but has a variable
    size. The size of a vector can increase and decrease. There are two properties
    that define the size of a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Capacity* is the number of elements the vector can accommodate without performing
    additional memory allocations; this is indicated by the `capacity()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Size* is the actual number of elements in the vector; this is indicated by
    the `size()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Size is always smaller or equal to capacity. When size is equal to capacity
    and a new element needs to be added, the capacity needs to be modified so that
    the vector has space for more elements. In this case, the vector allocates a new
    chunk of memory and moves the previous content to the new location and then frees
    the previously allocated memory. Though this sounds time-consuming (and it is),
    implementations increase the capacity exponentially, by doubling it each time
    it needs to be changed. As a result, on average, each element of the vector only
    needs to be moved once (that is because all the elements of the vector are moved
    during an increase of capacity, but then an equal number of elements can be added
    without incurring more moves, given that insertions are performed at the end of
    the vector).
  prefs: []
  type: TYPE_NORMAL
- en: If you know beforehand how many elements will be inserted in the vector, you
    can first call the `reserve()` method to increase the capacity to at least the
    specified amount (this method does nothing if the specified size is smaller than
    the current capacity) and only then insert the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you need to free additional reserved memory, you can
    use the `shrink_to_fit()` method to request this, but it is an implementation
    decision whether to free any memory or not. An alternative to this non-binding
    method, available since C++11, is to do a swap with a temporary, empty vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `clear()` method only removes all the elements from the vector but
    does not free any memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that the vector implements operations specific to other
    types of containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stack`: With `push_back()` and `emplace_back()` to add at the end and `pop_back()`
    to remove from the end. Keep in mind that `pop_back()` does not return the last
    element that has been removed. You need to access that explicitly, if that is
    necessary, for instance, using the `back()` method before removing the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list`: With `insert()` and `emplace()` to add elements in the middle of the
    sequence and `erase()` to remove elements from anywhere in the sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rule of thumb for C++ containers is: use `std::vector` as the default container unless
    you have good reasons to use another one.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using bitset for fixed-size sequences of bits*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using vector<bool> for variable-size sequences of bits*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using bitset for fixed-size sequences of bits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not uncommon for developers to operate with bit flags; this can be either
    because they work with operating system APIs, usually written in C, that take
    various types of arguments (such as options or styles) in the form of bit flags,
    or because they work with libraries that do similar things, or simply because
    some types of problems are naturally solved with bit flags. One can think of alternatives
    to working with bits and bit operations, such as defining arrays having one element
    for every option/flag, or defining a structure with members and functions to model
    the bit flags, but these are often more complicated, and in case you need to pass
    a numerical value representing bit flags to a function you still need to convert
    the array or the structure to a sequence of bits. For this reason, the C++ standard
    provides a container called `std::bitset` for fixed-size sequences of bits.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you must be familiar with bitwise operations (and, or, xor,
    not, and shifting).
  prefs: []
  type: TYPE_NORMAL
- en: The `bitset` class is available in the `std` namespace in the `<bitset>` header.
    A bitset represents a fixed-size sequence of bits, with the size defined at compile
    time. For convenience, in this recipe, all examples will be with bitsets of 8
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To construct an `std::bitset` object, use one of the available constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An empty bitset with all bits set to 0:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A bitset from a numerical value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A bitset from a string of `''0''` and `''1''`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A bitset from a string containing any two characters representing `''0''` and
    `''1''`; in this case, we must specify which character represents a 0 and which
    character represents a 1:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To test individual bits in the set or the entire set for specific values, use
    any of the available methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count()` to get the number of bits set to 1:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`any()` to check whether there is at least one bit set to 1:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`all()` to check whether all the bits are set to 1:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`none()` to check whether all the bits are set to 0:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`test()` to check the value of an individual bit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`operator[]` to access and test individual bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To modify the content of a bitset, use any of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Member operators `|=`, `&=`, `^= `, and `~` to perform binary or, and, xor,
    and not operations, or non-member operators `|`, `&`, and `^`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Member operators `<<=`, `<<`, `>>=`, `>>` to perform shifting operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`flip()` to toggle the entire set or an individual bit from 0 to 1 or from
    1 to 0:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`set()` to change the entire set or an individual bit to `true` or the specified
    value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`reset()` to change the entire set or an individual bit to false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert a bitset to a numerical or string value, use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`to_ulong()` and `to_ullong()` to convert to `unsigned long` or `unsigned long
    long`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`to_string()` to convert to `std::basic_string`; by default the result is a
    string containing `''0''` and `''1''`, but you can specify a different character
    for these two values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve ever worked with C or C-like APIs, chances are you either wrote
    or at least have seen code that manipulates bits to define styles, options, or
    other kinds of values. This usually involves operations, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the bit flags; these can be enumerations, static constants in a class,
    or macros introduced with `#define` in the C style. Usually, there is a flag representing
    no value (style, option, and so on). Since these are supposed to be bit flags,
    their values are powers of 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and removing flags from the set (that is, a numerical value). Adding
    a bit flag is done with the bit-or operator (`value |= FLAG`) and removing a bit
    flag is done with the bit-and operator, with the negated flag (`value &= ~FLAG`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing whether a flag is added to the set (`value & FLAG == FLAG`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling functions with the flags as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following shows a simple example of flags defining the border style of
    a control that can have a border on the left, right, top, or bottom side, or any
    combination of these, including no border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard `std::bitset` class is intended as a C++ alternative to this C-like
    working style with sets of bits. It enables us to write more robust and safer
    code because it abstracts the bit operations with member functions, though we
    still need to identify what each bit in the set is representing:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing flags is done with the `set()` and `reset()` methods, which set
    the value of a bit indicated by its position to 1 or 0 (or `true` and `false`);
    alternatively, we can use the index operator for the same purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing if a bit is set is done with the `test()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversion from an integer or a string is done through the constructor, and
    conversion to an integer or string is done with member functions so that the values
    from bitsets can be used where integers are expected (such as arguments to functions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these mentioned operations, the `bitset` class has additional
    methods for performing bitwise operations on bits, shifting, testing, and others
    that have been shown in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, `std::bitset` is a representation of a numerical value that enables
    you to access and modify individual bits. Internally, however, a bitset has an
    array of integer values on which it performs bit operations. The size of a bitset
    is not limited to the size of a numerical type; it can be anything, except that
    it is a compile-time constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example with the control border styles from the previous section can be
    written using `std::bitset` in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bitset can be created from an integer and can convert its value to an integer
    using the `to_ulong()` or `to_ullong()` methods. However, if the size of the bitset
    is larger than the size of these numerical types and any of the bits beyond the
    size of the requested numerical type is set to `1`, then these methods throw an `std::overflow_error` exception because
    the value cannot be represented on `unsigned long` or `unsigned long long`. In
    order to extract all the bits, we need to do the following operations, as shown
    in the next code:'
  prefs: []
  type: TYPE_NORMAL
- en: Clear the bits beyond the size of `unsigned long` or `unsigned long long`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert the value to `unsigned long` or `unsigned long long`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shift the bitset with the number of bits in `unsigned long` or `unsigned long
    long`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do this until all the bits are retrieved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: For cases where the size of the `bitset` cannot be known at compile time, the
    alternative is `std::vector<bool>`, which we will cover in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using vector<bool> for variable-size sequences of bits*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using vector<bool> for variable-size sequences of bits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at using `std::bitset` for fixed-size sequences
    of bits. Sometimes, however, an `std::bitset` is not a good choice because you
    do not know the number of bits at compile time, and just defining a set of a large
    enough number of bits is not a good idea because you can get into a situation
    when the number is not actually large enough. The standard alternative for this
    is to use the `std::vector<bool>` container that is a specialization of `std::vector`
    with space and speed optimizations, as implementations do not actually store Boolean
    values, but individual bits for each element.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, however, `std::vector<bool>` does not meet the requirements
    of a standard container or sequential container, nor does `std::vector<bool>::iterator` meet
    the requirements of a forward iterator. As a result, this specialization cannot
    be used in generic code where a vector is expected. On the other hand, being a
    vector, it has a different interface from that of `std::bitset` and cannot be
    viewed as a binary representation of a number. There are no direct ways to construct `std::vector<bool>`
    from a number or string nor to convert to a number or string.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes you are familiar with both `std::vector` and `std::bitset`.
    If you didn’t read the previous recipes, *Using vector as a default container* and
    *Using bitset for fixed-size sequences of bits*, you should do that before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: The `vector<bool>` class is available in the `std` namespace in the `<vector>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To manipulate an `std::vector<bool>`, use the same methods you would use for
    an `std::vector<T>`, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an empty vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding bits to the vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the values of individual bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Using generic algorithms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing bits from the vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::vector<bool>` is not a standard vector because it is designed to provide
    space optimization by storing a single bit for each element instead of a Boolean
    value. Therefore, its elements are not stored in a contiguous sequence and cannot
    be substituted for an array of Booleans. Due to this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The index operator cannot return a reference to a specific element because
    elements are not stored individually:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Dereferencing an iterator cannot produce a reference to `bool` for the same
    reason as mentioned earlier:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There is no guarantee that individual bits can be manipulated independently
    at the same time from different threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vector cannot be used with algorithms that require forward iterators, such
    as `std::search()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vector cannot be used in some generic code where `std::vector<T>` is expected
    if such code requires any of the operations mentioned in this list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative to `std::vector<bool>` is `std::dequeu<bool>`, which is a standard
    container (a double-ended queue) that meets all container and iterator requirements
    and can be used with all standard algorithms. However, this will not have the
    space optimization that `std::vector<bool>` is providing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::vector<bool>` interface is very different from `std::bitset`. If
    you want to be able to write code in a similar manner, you can create a wrapper
    on `std::vector<bool>`, which looks like `std::bitset`, where possible. The following
    implementation provides members similar to what is available in `std::bitset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is only a basic implementation, and if you want to use such a wrapper,
    you should add additional methods, such as bit logic operations, shifting, maybe
    reading and writing from and to streams, and so on. However, with the preceding
    code, we can write the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using vector as a default container*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using bitset for fixed-size sequences of bits*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding elements in a range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common operations we do in any application is searching through
    data. Therefore, it is not surprising that the standard library provides many
    generic algorithms for searching through standard containers or anything that
    can represent a range and is defined by a start and a past-the-end iterator. In
    this recipe, we will see what these standard algorithms are and how they can be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For all the examples in this recipe, we will use `std::vector`, but all algorithms
    work with ranges defined by a begin and past-the-end, either input or forward
    iterators, depending on the algorithm (for more information about the various
    types of iterators, see the recipe, *Writing your own random access iterator*).
    All these algorithms are available in the `std` namespace in the `<algorithm>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of algorithms that can be used for finding elements
    in a range:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `std::find()` to find a value in a range; this algorithm returns an iterator
    to the first element equal to the value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::find_if()` to find a value in a range that meets a criterion from
    a unary predicate; this algorithm returns an iterator to the first element for
    which the predicate returns `true`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::find_if_not()` to find a value in a range that does not meet a criterion
    from a unary predicate; this algorithm returns an iterator to the first element
    for which the predicate returns `false`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::find_first_of()` to search for the occurrence of any value from a
    range in another range; this algorithm returns an iterator to the first element
    that is found:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::find_end()` to find the last occurrence of a subrange of elements
    in a range; this algorithm returns an iterator to the first element of the last
    subrange in the range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::search()` to search for the first occurrence of a subrange in a range;
    this algorithm returns an iterator to the first element of the subrange in the
    range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::search()` with a *searcher*, which is a class that implements a searching
    algorithm and meets some predefined criteria. This overload of `std::search()` was
    introduced in C++17, and available standard searchers implement the *Boyer-Moore*
    and the *Boyer-Moore-Horspool* string searching algorithms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::search_n()` to search for *N* consecutive occurrences of a value
    in a range; this algorithm returns an iterator to the first element of the found
    sequence in the range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::adjacent_find()` to find two adjacent elements in a range that are
    equal or satisfy a binary predicate; this algorithm returns an iterator to the
    first element that is found:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::binary_search()` to find whether an element exists in a sorted range;
    this algorithm returns a Boolean value to indicate whether the value was found
    or not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::lower_bound()` to find the first element in a range not less than
    a specified value; this algorithm returns an iterator to the element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::upper_bound()` to find the first element in a range greater than
    a specified value; this algorithm returns an iterator to the element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::equal_range()` to find a subrange in a range whose values are equal
    to a specified value. This algorithm returns a pair of iterators defining the
    first and the one-past-end iterators to the subrange; these two iterators are
    equivalent to those returned by `std::lower_bound()` and `std::upper_bound()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way these algorithms work is very similar: they all take as arguments iterators
    that define the searchable range and additional arguments that depend on each
    algorithm. Except for `std::search()`, which returns a Boolean, and `std::equal_range()`,
    which returns a pair of iterators, they all return an iterator to the searched
    element or to a subrange. These iterators must be compared with the end iterator
    (that is, the past-last-element) of the range to check whether the search was
    successful or not. If the search did not find an element or a subrange, then the
    returned value is the end iterator.'
  prefs: []
  type: TYPE_NORMAL
- en: All these algorithms have multiple overloads, but in the *How to do it...* section,
    we only looked at one particular overload to show how the algorithm can be used.
    For a complete reference of all overloads, you should see other sources.
  prefs: []
  type: TYPE_NORMAL
- en: In all the preceding examples, we used constant iterators, but all these algorithms
    work the same with mutable iterators and with reverse iterators. Because they
    take iterators as input arguments, they can work with standard containers, C-like
    arrays, or anything that represents a sequence and has iterators available.
  prefs: []
  type: TYPE_NORMAL
- en: 'A special note on the `std::binary_search()` algorithm is necessary: the iterator
    parameters that define the range to search in should at least meet the requirements
    of the forward iterators. Regardless of the type of the supplied iterators, the
    number of comparisons is always logarithmic on the size of the range. However,
    the number of iterator increments is different if the iterators are random access,
    in which case the number of increments is also logarithmic, or are not random
    access, in which case, it is linear and proportional to the size of the range.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All these algorithms, except for `std::find_if_not()`, were available before
    C++11\. However, some overloads of them have been introduced in the newer standards.
    An example is `std::search()` that has several overloads introduced in C++17\.
    One of these overloads has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This overload searches for the occurrence of a pattern defined by a searcher
    function object for which the standard provides several implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default_searcher` basically delegates the searching to the standard `std::search()`
    algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boyer_moore_searcher` implements the Boyer-Moore algorithm for string searching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boyer_moore_horspool_algorithm` implements the Boyer-Moore-Horspool algorithm
    for string searching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many standard containers have a member function `find()`, for finding elements
    in the container. When such a method is available and suits your needs, it should
    be preferred to the general algorithms because these member functions are optimized
    based on the particularities of each container.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using vector as a default container*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initializing a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using set operations on a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sorting a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting a range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at the standard general algorithms for searching
    in a range. Another common operation we often need to do is sorting a range because many
    routines, including some of the algorithms for searching, require a sorted range.
    The standard library provides several general algorithms for sorting ranges, and
    in this recipe, we will see what these algorithms are and how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sorting general algorithms work with ranges defined by a start and end iterator
    and, therefore, can sort standard containers, C-like arrays, or anything that
    represents a sequence and has random iterators available. However, all the examples
    in this recipe will use `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of standard general algorithms for searching a range:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `std::sort()` for sorting a range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::stable_sort()` for sorting a range but keeping the order of the equal
    elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::partial_sort()` for sorting a part of a range (and leaving the rest
    in an unspecified order):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::partial_sort_copy()` for sorting a part of a range by copying the
    sorted elements to a second range and leaving the original range unchanged:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::nth_element()` for sorting a range so that the *N*th element is the
    one that would be in that position if the range was completely sorted, and the
    elements before it are all smaller and the ones after it are all greater, without
    any guarantee that they are also ordered:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::is_sorted()` to check whether a range is sorted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::is_sorted_until()` to find a sorted subrange from the beginning of
    a range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the preceding general algorithms take random iterators as arguments to define
    the range to be sorted and, some of them additionally take an output range. They
    all have overloads, one that requires a comparison function for sorting the elements,
    and one that does not and uses `operator<` for comparing the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'These algorithms work in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::sort()` modifies the input range so that its elements are sorted according
    to the default or the specified comparison function; the actual algorithm for
    sorting is an implementation detail.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::stable_sort()` is similar to `std::sort()`, but it guarantees to preserve
    the original order of elements that are equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::partial_sort()` takes three iterator arguments indicating the first,
    middle, and last element in a range, where middle can be any element, not just
    the one at the natural middle position. The result is a partially sorted range
    so that that first `middle - first` smallest elements from the original range,
    that is, `[first, last)`, are found in the `[first, middle)` subrange and the
    rest of the elements are in an unspecified order, in the `[middle, last)` subrange.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::partial_sort_copy()` is not a variant of `std::partial_copy()`, as the
    name may suggest, but of `std::sort()`. It sorts a range without altering it by
    copying its elements to an output range. The arguments of the algorithm are the
    first and last iterators of the input and output ranges. If the output range has
    a size *M* that is greater than or equal to the size *N* of the input range, the
    input range is entirely sorted and copied to the output range; the first *N* elements
    of the output range are overwritten, and the last *M - N* elements are left untouched.
    If the output range is smaller than the input range, then only the first *M* sorted
    elements from the input range are copied to the output range (which is entirely
    overwritten in this case).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::nth_element()` is basically an implementation of a selection algorithm,
    which is an algorithm for finding the *N*th smallest element of a range. This
    algorithm takes three iterator arguments representing the first, *N*th, and last
    element, and partially sorts the range so that after sorting, the *N*th element
    is the one that would be in that position if the range had been entirely sorted.
    In the modified range, all the *N-1* elements before the *n*th one are smaller
    than it, and all the elements after the *n*th element are greater than it. However,
    there is no guarantee on the order of these other elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_sorted()` checks whether the specified range is sorted according to
    the specified or default comparison function and returns a Boolean value to indicate
    that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_sorted_until()` finds a sorted subrange of the specified range, starting
    from the beginning, using either a provided comparison function or the default
    `operator<`. The returned value is an iterator representing the upper bound of
    the sorted subrange, which is also the iterator of the one-past-last sorted element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some standard containers, `std::list` and `std::forward_list`, provide a member
    function, `sort()`, which is optimized for those containers. These member functions
    should be preferred over the general standard algorithm, `std::sort()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using vector as a default container*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initializing a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using set operations on a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Finding elements in a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing a range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we explored the general standard algorithms for searching
    in a range and sorting a range. The algorithms library provides many other general
    algorithms and among them are several that are intended for filling a range with
    values. In this recipe, you will learn what these algorithms are and how they
    should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the examples in this recipe use `std::vector`. However, like all the general
    algorithms, the ones we will see in this recipe take iterators to define the bounds
    of a range and can therefore be used with any standard container, C-like arrays,
    or custom types representing a sequence that have forward iterators defined.
  prefs: []
  type: TYPE_NORMAL
- en: Except for `std::iota()`, which is available in the `<numeric>` header, all
    the other algorithms are found in the `<algorithm>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To assign values to a range, use any of the following standard algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::fill()` to assign a value to all the elements of a range; the range is
    defined by a first and last forward iterator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`std::fill_n()` to assign values to a number of elements of a range; the range
    is defined by a first forward iterator and a counter that indicates how many elements
    should be assigned the specified value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '`std::generate()` to assign the value returned by a function to the elements
    of a range; the range is defined by a first and last forward iterator, and the
    function is invoked once for each element in the range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`std::generate_n()` to assign the value returned by a function to a number
    of elements of a range; the range is defined by a first forward iterator and a
    counter that indicates how many elements should be assigned the value from the
    function that is invoked once for each element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`std::iota()` to assign sequentially increasing values to the elements of a
    range; the range is defined by a first and last forward iterator, and the values
    are incremented using the prefix `operator++` from an initial specified value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::fill()` and `std::fill_n()` work similarly but differ in the way the
    range is specified: for the former by a first and last iterator, for the latter
    by a first iterator and a count. The second algorithm returns an iterator, representing
    either the one-past-last assigned element if the counter is greater than zero,
    or an iterator to the first element of the range otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::generate()` and `std::generate_n()` are also similar, differing only
    in the way the range is specified. The first takes two iterators, defining the
    range''s lower and upper bounds, and the second, an iterator to the first element
    and a count. Like `std::fill_n()`, `std::generate_n()` also returns an iterator,
    representing either the one-past-last assigned element if the count is greater
    than zero, or an iterator to the first element of the range, otherwise. These
    algorithms call a specified function for each element in the range and assign
    the returned value to the element. The generating function does not take any argument,
    so the value of the argument cannot be passed to the function as this is intended
    as a function to initialize the elements of a range. If you need to use the value
    of the elements to generate new values, you should use `std::transform()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::iota()` takes its name from the ι (iota) function from the APL programming
    language, and though it was a part of the initial STL, it was only included in
    the standard library in C++11\. This function takes a first and last iterator
    to a range and an initial value that is assigned to the first element of the range
    and then used to generate sequentially increasing values using the prefix `operator++`
    for the rest of the elements in the range.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using vector as a default container*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sorting a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using set operations on a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Finding elements in a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Generating pseudo-random numbers* recipe of [Chapter 9](9830e5b8-a9ca-41e8-b565-8800a82d9caa.xhtml),
    *Working with Numbers and Strings*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initializing all bits of internal state of a pseudo-random number generator*
    recipe of [Chapter 9](9830e5b8-a9ca-41e8-b565-8800a82d9caa.xhtml), *Working with
    Numbers and Strings*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using set operations on a range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard library provides several algorithms for set operations that enable
    us to do unions, intersections, or differences of sorted ranges. In this recipe,
    we will see what these algorithms are and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The algorithms for set operations work with iterators, which means they can
    be used for standard containers, C-like arrays, or any custom type representing
    a sequence that has input iterators available. All the examples in this recipe
    will use `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all the examples in the next section, we will use the following ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following general algorithms for set operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::set_union()` to compute the union of two ranges into a third range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`std::merge()` to merge the content of two ranges into a third one; this is
    similar to `std::set_union()` except that it copies the entire content of the
    input ranges into the output one, not just their union:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '`std::set_intersection()` to compute the intersection of the two ranges into
    a third range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`std::set_difference()` to compute the difference of two ranges into a third
    range; the output range will contain elements from the first range, which are
    not present in the second range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '`std::set_symmetric_difference()` to compute a dual difference of the two ranges
    into a third range; the output range will contain elements that are present in
    any of the input ranges, but only in one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '`std::includes()` to check if one range is a subset of another range (that
    is, all its elements are also present in the other range):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the set operations that produce a new range from two input ranges, in fact,
    have the same interface and work in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: They take two input ranges, each defined by a first and last input iterator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They take an output iterator to an output range where elements will be inserted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have an overload that takes an extra argument representing a comparison
    binary function object that must return `true` if the first argument is less than
    the second. When a comparison function object is not specified, `operator<` is
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They return an iterator past the end of the constructed output range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input ranges must be sorted using either `operator<` or the provided comparison
    function, depending on the overload that is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output range must not overlap any of the two input ranges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will demonstrate the way they work with additional examples using vectors
    of a POD type `Task` that we also used in a previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The particular way each algorithm produces the output range is described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::set_union()` copies all the elements present in one or both of the input
    ranges to the output range, producing a new sorted range. If an element is found
    *M* times in the first range and *N* times in the second range, then all the *M*
    elements from the first range will be copied to the output range in their existing
    order, and then the *N-M* elements from the second range are copied to the output
    range if *N > M*, or 0 elements otherwise:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '`std::merge()` copies all the elements from both the input ranges into the
    output range, producing a new range sorted with respect to the comparison function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`std::set_intersection()` copies all the elements that are found in both the
    input ranges into the output range, producing a new range sorted with respect
    to the comparison function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '`std::set_difference()` copies to the output range all the elements from the
    first input range that are not found in the second input range. For equivalent
    elements that are found in both the ranges, the following rule applies: if an
    element is found *M* times in the first range and *N* times in the second range,
    and if *M > N*, then it is copied *M-N* times; otherwise it is not copied:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '`std::set_symmetric_difference()` copies to the output range all the elements
    that are found in either of the two input ranges but not in both of them. If an
    element is found *M* times in the first range and *N* times in the second range,
    then if *M > N,* the last *M-N* of those elements from the first range are copied
    into the output rage, else, the last *N-M* of those elements from the second range
    will be copied into the output range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, `std::includes()` does not produce an output range; it only
    checks whether the second range is included in the first range. It returns a Boolean
    value that is `true` if the second range is empty or all its elements are included
    in the first range, or `false` otherwise. It also has two overloads, one of them
    specifying a comparison binary function object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using vector as a default container*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sorting a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initializing a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using iterators to insert new elements in a container*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Finding elements in a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using iterators to insert new elements in a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you’re working with containers, it is often useful to insert new elements
    at the beginning, end, or somewhere in the middle. There are algorithms, such
    as the ones we saw in the previous recipe, *Using set operations on a range*,
    that require an iterator to a range to insert into, but if you simply pass an
    iterator, such as the one returned by `begin()`, it will not insert but overwrite
    the elements of the container. Moreover, it’s not possible to insert at the end
    by using the iterator returned by `end()`. In order to perform such operations,
    the standard library provides a set of iterators and iterator adapters that enable
    these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The iterators and adapters discussed in this recipe are available in the `std`
    namespace in the `<iterator>` header. If you include headers such as, `<algorithm>`,
    you do not have to explicitly include `<iterator>`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following iterator adapters to insert new elements in a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::back_inserter()` to insert elements at the end, for containers that have
    a `push_back()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '`std::front_inserter()` to insert elements at the beginning, for containers
    that have a `push_front()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '`std::inserter()` to insert anywhere in a container, for containers that have
    an `insert()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::back_inserter()`, `std::front_inserter()`, and `std::inserter()` are
    all helper functions that create iterator adapters of types, `std::back_insert_iterator`,
    `std::front_insert_iterator`, and `std::insert_iterator`. These are all output
    iterators that append, prepend, or insert into the container for which they were
    constructed. Incrementing and dereferencing these iterators does not do anything.
    However, upon assignment, these iterators call the following methods from the
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::back_insterter_iterator` calls `push_back()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::front_inserter_iterator` calls `push_front()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::insert_iterator` calls `insert()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the over-simplified implementation of `std::back_inserter_iterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of the way the assignment operator works, these iterators can only
    be used with some standard containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::back_insert_iterator` can be used with `std::vector`, `std::list`, `std::deque`,
    and `std::basic_string`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::front_insert_iterator` can be used with `std::list`, `std::forward_list`,
    and `std:deque`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::insert_iterator` can be used with all the standard containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example inserts three elements with the value 0 at the beginning
    of an `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::inserter()` adapter takes two arguments: the container, and the iterator
    where an element is supposed to be inserted. Upon calling `insert()` on the container,
    the `std::insert_iterator` increments the iterator, so upon being assigned again,
    it can insert a new element into the next position. Here is how the assignment
    operator is implemented for this iterator adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These iterator adapters are intended to be used with algorithms or functions
    that insert multiple elements into a range. They can be used, of course, to insert
    a single element, but that is rather an anti-pattern, since simply calling `push_back()`,
    `push_front()`, or `insert()` is much simpler and intuitive in this case. The
    following examples should be avoided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using set operations on a range*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own random access iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml), *Learning Modern
    Core Language Features*, we saw how we can enable range-based for loops for custom
    types by implementing iterators and free `begin()` and `end()` functions to return
    iterators to the first and one-past-the-last element of the custom range. You might
    have noticed that the minimal iterator implementation that we provided in that
    recipe does not meet the requirements for a standard iterator because it cannot
    be copy constructible or assigned and cannot be incremented. In this recipe, we
    will build upon that example and show how to create a random access iterator that
    meets all requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you should know the types of iterators the standard defines
    and how they are different. A good overview of their requirements is available
    at [http://www.cplusplus.com/reference/iterator/](http://www.cplusplus.com/reference/iterator/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To exemplify how to write a random access iterator, we will consider a variant
    of the `dummy_array` class used in the *Enabling range-based for loops for custom
    types* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml), *Learning
    Modern Core Language Features*. This is a very simple array concept, with no practical
    value, other than serving as a code base for demonstrating iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: All the code shown in the next section, the iterator classes, `typedef`s, and
    the `begin()` and `end()` functions, will be a part of this class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To provide mutable and constant random access iterators for the `dummy_array`
    class shown in the previous section, add the following members to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An iterator class template, which is parameterized with the type of elements
    and the size of the array. The class must have the following public `typedef`s
    that define standard synonyms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Private members for the iterator class: a pointer to the array data and a current
    index into the array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Private method for the iterator class to check whether two iterator instances
    point to the same array data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'An explicit constructor for the iterator class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterator class members to meet common requirements for all iterators: copy-constructible,
    copy-assignable, destructible, prefix, and postfix incrementable. In this implementation,
    the post increment operator is implemented in terms of the pre-increment operator
    to avoid code duplication:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterator class members to meet input iterator requirements: test for equality/inequality,
    dereferenceable as rvalues:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterator class members to meet forward iterator requirements: default constructible:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterator class members to meet bidirectional iterator requirements: decrementable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterator class members to meet random access iterator requirements: arithmetic
    add and subtract, comparable for inequality with other iterators, compound assignments,
    and offset dereferenceable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `typedef`s to the `dummy_array` class for mutable and constant iterator
    synonyms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the public `begin()` and `end()` functions to the `dummy_array` class to
    return the iterators to the first and one-past-last elements in the array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard library defines five categories of iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Input iterators*: These are the simplest category and guarantee validity only
    for single-pass sequential algorithms. After being incremented, the previous copies
    may become invalid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Output iterators*: These are basically input iterators that can be used to
    write to the pointed element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Forward iterators*: These can read (and write) data to the pointed element. They
    satisfy the requirements for input iterators and, in addition, must be default
    constructible and must support multi-pass scenarios without invalidating the previous
    copies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bidirectional iterators*: These are forward iterators that, in addition, support
    decrementing, so they can move in both directions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Random access iterators*: These support access to any element in the container
    in constant time. They implement all the requirements for bidirectional iterators,
    and, in addition, support arithmetic operations `+` and `-`, compound assignments `+=`
    and `-=`, comparisons with other iterators with `<`, `<=`, `>`, `>=`, and the
    offset dereference operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward, bidirectional, and random access iterators that also implement the
    requirements of output iterators are called *mutable iterators*.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we saw how to implement random access iterators, with
    a step-by-step walkthrough of the requirements of each category of iterators (as
    each iterator category includes the requirements of the previous category and
    adds new requirements). The iterator class template is common for both constant
    and mutable iterators, and we have defined two synonyms for it called `iterator`
    and `constant_iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: After implementing the inner iterator class template, we also defined the `begin()`
    and `end()` member functions that return an iterator to the first and the one-past-last
    element in the array. These methods have overloads to return mutable or constant
    iterators, depending on whether the `dummy_array` class instance is mutable or
    constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this implementation of the `dummy_array` class and its iterators, we can
    write the following samples. For more examples, check the source code that accompanies
    this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from `begin()` and `end()`, a container may have additional methods such
    as `cbegin()`/`cend()` (for constant iterators), `rbegin()`/`rend()` (for mutable
    reverse iterators), and `crbegin()`/ `crend()` (for constant reverse iterators).
    Implementing this is left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in modern C++, these functions that return the first and
    last iterators do not have to be member functions but can be provided as non-member
    functions. In fact, this is the topic of the next recipe, *Container access with
    non-member functions*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Enabling range-based for loops for custom types* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml),
    *Learning Modern Core Language Features*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating type aliases and alias templates* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml),
    *Learning Modern Core Language Features*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container access with non-member functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standard containers provide the `begin()` and `end()` member functions for retrieving
    iterators to the first and one-past-last element of the container. There are actually
    four sets of these functions. Apart from `begin()`/`end()`, containers provide
    `cbegin()`/`cend()` to return constant iterators, `rbegin()`/`rend()` to return
    mutable reverse iterators, and `crbegin()`/`crend()` to return constant reverse
    iterators. In C++11/C++14, all these have non-member equivalents that work with
    standard containers, C-like arrays, and any custom type that specializes them.
    In C++17, even more non-member functions have been added; `std::data()`--that
    returns a pointer to the block of memory containing the elements of the container,
    `std::size()`--that returns the size of a container or array, and `std::empty()`--that
    returns whether the given container is empty.  These non-member functions are
    intended for generic code but can be used anywhere in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use as an example, the `dummy_array` class and its iterators
    that we implemented in the previous recipe, *Writing your own random access iterator*.
    You should read that recipe before continuing with this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-member `begin()`/`end()` functions and the other variants, as well as non-member
    `data()`, `size()` and `empty()` are available in the `std` namespace in the `<iterator>` header,
    which is implicitly included with any of the following headers: `<array>`, `<deque>`,
    `<forward_list>`, `<list>`, `<map>`, `<regex>`, `<set>`, `<string>`, `<unordered_map>`,
    `<unordered_set>`, and `<vector>`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will refer to the `std::begin()`/`std::end()` functions,
    but everything discussed also applies to the other functions: `std::cbegin()`/`std::cend()`,
    `std::rbegin()`/`std::rend()`, and `std::crbegin()`/`std::crend()`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the non-member `std::begin()`/`std::end()` function and the other variants,
    as well as `std::data()`, `std::size()` and `std::empty()`  with:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard containers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '(C-like) arrays:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Custom types that provide corresponding member functions, `begin()`/`end()`,
    `data()`, `empty()`, or `size()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Generic code where the type of the container is not known:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These non-member functions were introduced in different versions of the standard,
    but all of them were modified in C++17 to return `constexpr auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::begin()` and `std::end()` in C++11'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::cbegin()`/`std::cend()`, `std::rbegin()`/`std::rend()`, and `std::crbegin()`/`std::crend()`
    in C++14'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::data()`, `std::size()`, and `std::empty()` in C++17'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `begin()`/`end()` family of functions have overloads for container classes
    and arrays, and all they do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return the results of calling the container-corresponding member function for
    containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a pointer to the first or one-past-last element of the array for arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The actual typical implementation for `std::begin()`/`std::end()` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Custom specialization can be provided for containers that do not have corresponding
    `begin()`/`end()` members but can still be iterated. The standard library actually
    provides such specializations for `std::initializer_list` and `std::valarray`.
  prefs: []
  type: TYPE_NORMAL
- en: Specializations must be defined in the same namespace where the original class
    or function template has been defined. Therefore, if you want to specialize any
    of the `std::begin()`/`std::end()` pairs you must do it in the `std` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other non-member functions for container access, that were introduced in
    C++17, have also several overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::data()` has several overloads; for a class `C` it returns `c.data()`,
    for arrays it returns the `array`, and for `std::initializer_list<T>` it returns
    the `il.begin()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '`std::size()` has two overloads; for a class `C` it returns `c.size()`, and
    for arrays it returns the size `N`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '`std::empty()` has several overloads; for a class `C` it returns `c.empty()`,
    for arrays it returns `false`, and for `std::initializer_list<T>` it returns `il.size()
    == 0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These non-member functions are mainly intended for template code where the container
    is not known and can be a standard container, a C-like array, or a custom type.
    Using the non-member version of these functions enables us to write simpler and
    less code that works with all these types of containers.
  prefs: []
  type: TYPE_NORMAL
- en: However, the use of these functions is not and should not be limited to generic
    code. Though it is rather a matter of personal preference, it can be a good habit
    to be consistent and use them everywhere in your code. All these methods have
    lightweight implementations that will most likely be inlined by the compiler,
    which means that there will be no overhead at all over using the corresponding
    member functions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Writing your own random access iterator*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
