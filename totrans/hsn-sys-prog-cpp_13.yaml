- en: Error – Handling with Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we will learn how to perform error handling while system
    programming. Specifically, three different methods will be presented. The first
    method will demonstrate how to use POSIX-style error handling, while the second
    method will demonstrate how to use the standard C-style set jump exceptions. The
    third method will demonstrate how to use C++ exceptions, and the pros and cons
    of each approach will be discussed. Finally, this chapter will conclude with an
    example that demonstrates how C++ exceptions outperform POSIX-style error handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: POSIX-style error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception support in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example with Exception Benchmark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCC 7+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.6+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To download all of the code in this chapter, including the examples, and code
    snippets, please see the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Error handling POSIX-style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'POSIX-style error handling provides the most basic form of error handling possible,
    capable of being leveraged on almost any system, in almost any program. Written
    with standard C in mind, POSIX-style error handling takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, each function called either returns `0` on `success` or `-1` on
    failure, and stores the error code into a global (non-thread safe) implementation-defined
    macro, called `errno`. The reason `0` is used for `success` is that on most CPUs,
    comparing a variable to `0` is faster than comparing a variable to any other value,
    and the `success` case is the expected case. The following example demonstrates
    how this pattern is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a function called `myfunc()`, which takes an integer
    and returns an integer. The function accepts any value as its parameter as *valid* except
    for `42`. If `42` is provided as the input function, the function returns `-1`
    and sets `errno` to `EINVAL`, which states that the function was provided an invalid
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` function, we call `myfunc()`, both with a valid input, and an
    invalid input and test, to see whether an error has occurred, resulting in `success` for
    the valid input and `failure: Invalid argument` for the invalid input. It should
    be noted that we leverage the `strerror()` function, which converts POSIX-defined
    error codes into their string equivalent. It should also be noted that this simple
    example will be leveraged throughout this chapter as we build and improve upon
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first issue that arises from this simple example is that the output of
    the function is leverage for error handling, but what if the function needs to
    output a value other than an error code? There are two ways to handle this. The
    first way to handle this is to constrain valid output of the function (that is,
    not all outputs are considered valid). This is generally how POSIX handles this
    problem. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create a `myfunc()` function that returns a `handle` given
    valid input, and `0` given invalid input. This is similar to a lot of POSIX functions
    that return file handles. In this case, the notion of `success` is reversed, and,
    in addition, a handle may never take on a value of `0`, as this is used to represent
    an error. Another possible method for providing error handling while also providing
    function output is to return more than one value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we return `std::pair{}` (which is really just a struct
    with two values). The first value in the pair is our handle, while the second
    value in our pair determines whether the handle is valid. Using this mechanism,
    `0` could be a valid handle as we have a way to tell the user of this function
    whether it is valid. Another way to do this is to provide the function with an
    argument that acts as an *output* and not as an *input*, a practice that is discouraged
    by the C++ Core Guidelines. This is depicted by means of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `myfunc()` takes two arguments, with the second argument accepting
    an integer intended to store an error. If the error integer remains at `0`, no
    error has occurred. If, however, the error integer is set, an error has occurred,
    which we detect and output the failure as a result. Although this method is discouraged
    by the C++ Core Guidelines (mainly because there are better ways to perform error
    handling in C++), this method has the added benefit that the error integer is
    thread-safe, unlike the use of `errno`, which is not thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the verbosity of POSIX-style error handling and a tendency for error
    values to be ignored, the biggest issue with POSIX-style error handling is the
    numerous branch statements that must be executed continuously in the unlikely
    event that an error might occur. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create the same `myfunc()` function that returns an error
    if the input provided is `42`. We then call this function from a function that
    is called by another function (that is, we are making nested calls to our `myfunc()`,
    a practice that is highly likely to occur while system programming). Since `myfunc()`
    might return an error, and our nested functions are unable to handle the error,
    they must also return an error code, which, in turn, must also be checked. The
    bulk of the code in this example provides nothing more than error handling logic,
    designed to forward the results of an error to the next function in the hope that
    the next function is capable of handling the error.
  prefs: []
  type: TYPE_NORMAL
- en: This nested error forwarding may be referred to as `stack unwinding`. Each time
    we call a function that could return an error, we check whether an error has occurred
    and we return the result to the next function in the stack. This process of unwinding
    the call stack is repeated until we get to a function in the call stack that is
    capable of handling the error. In our case, this is the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with POSIX-style error handling is that stack unwinding must be
    performed manually, and thus, this code is executed continuously in the `success` case,
    resulting in poor-performing, verbose code, as demonstrated by the preceding example,
    which checks a simple integer value in only three nested calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it should be noted that POSIX-style error handling does support **Resource
    Acquisition Is Initialization** (**RAII**), meaning objects defined in the scope
    of a function are destroyed properly the function exits in both the `success`
    case and the error case, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a simple class that outputs a string to
    `stdout` on destruction and creates an instance of this class in our `myfunc()`
    function. When `myfunc()` is called, both on `success` and failure, the destructor
    of the class is called properly on exit. In our next error handling mechanism,
    called set jump, we will demonstrate how a lot of the issues with POSIX-style
    error handling are addressed while also demonstrating that the key limitation
    with set jump is a lack of RAII support, possibly resulting in undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about set jump exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Set jump exceptions may be viewed as C-style exceptions. Like C++-style exceptions,
    set jump exceptions provide the user with the ability to set a place in the code
    to return to in the event of an error, and a method for generating the exception
    that performs the jump. The following code example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create our `myfunc()` function, but instead of returning
    an error code, we execute a long jump, which acts like a *goto*, jumping to the
    last place in the call stack that a call to `setjmp()` was made. In our `main`
    function, we first call `setjmp()` to place our return point, and then we make
    calls to our `myfunc()` function with both a valid input and an invalid input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately, we have addressed several issues with POSIX-style error handling.
    As can be seen in the preceding example, the code is far less complicated, removing
    the need to check for error conditions. In addition, `myfunc()` returns a void,
    as no error code needs to be returned, meaning there is no longer a need to constrain
    the output of a function to support an error case, as can be seen in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `myfunc()` returns a *handle*, and the error case is handled
    using a set jump exception. As a result, `myfunc()` may return any value, and
    the user of the function knows whether a handle is valid based on whether a long
    jump was called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a return value of `myfunc()` is no longer needed, we also no longer need
    to check the return value of `myfunc()`, meaning our nested example is greatly
    simplified, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, the only error logic in this example exists in `myfunc()` checking
    to ensure the input is valid. The remaining error logic has been removed. Not
    only does this result in code that is easier to read and maintain, but the resulting
    code also performs better, as we are no longer executing branch statements, but
    manually unwinding the call stack by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another benefit of using set jump exceptions is that it is possible to create
    thread-safe error handling. In our previous example, we set `errno` in the event
    of an error, which is then read when we reach the code that is capable of handling
    the error. With set jump, `errno` is no longer needed as we can return the error
    code in the long jump itself, using the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, instead of setting `errno` and returning `-1` in our
    long jump, we return the error code in our long jump, and, using the C++17 syntax,
    store the value from the long jump in our call to set jump and make sure this
    value is greater than `0`. The first time set jump is called, it returns `0` as
    no error has occurred yet, meaning the branch is not taken. If, however, set jump
    is called a second time (when our long jump is called), the value that is placed
    in the call to our long jump is returned instead, resulting in the branch being
    taken and an error reported in a thread-safe manner.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the only modification we need to make to our example is that we must
    pass the jump buffer of every function, which is highly inconvenient, especially
    in the case of nested function calls. In our previous examples, the jump buffer
    was stored globally, which is not thread-safe, but is more convenient, and results
    in cleaner code.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to an awkward mechanism for providing thread safety, the main disadvantage
    to using set jump for error handling is a lack of support for RAII, meaning objects
    created in the scope of a function may not have their destructors called on exit
    (a problem that is actually implementation-specific). The reason destructors are
    not called is that the function never technically exits. set jump/long jump stores
    the instruction pointer and non-volatile registers in the jump buffer on a call
    to set jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a long jump is performed, the application overwrites the instruction pointer
    and CPU registers with the values stored in the jump buffer and then continues
    execution as if the code after the call to `setjump()` was never executed. For
    this reason, the destructors of an object are never executed, as demonstrated
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a simple class that outputs a string to `stdout`
    when the class is destroyed. We then create an instance of this class in `myfunc()`.
    In the `success` case, the destructor is called as `myfunc()` exits, resulting
    in the destructor being called. In the failure case, however, `myfunc()` never
    exits, resulting in the destructor not being called.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will talk about C++ exceptions that build upon set jump
    exceptions to not only provide support for RAII, but also provide the ability
    to return complex data types in the event of an error.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding exception support in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ exceptions provide a mechanism for reporting errors in a thread-safe manner,
    without the need to manually unwind the call stack, while also providing support
    for RAII and complex data types. To better understand this, refer to the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, our `myfunc()` function has been greatly simplified
    compared to its POSIX-style equivalent. Just like our previous examples, if the
    input provided to the function is `42`, the error is returned (in this case, it
    is actually thrown). If the input provided is not `42`, the function returns successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Like set jump, calls to `myfunc()` no longer need to check the return value
    of the function as no return value is provided. To handle the error case, we wrap
    our call to `myfunc()` in a `try...catch` block. If any of the code in the `try{}`
    block results in an exception being thrown, the `catch[}` block will be executed.
    As with most C++, the `catch` block is type-safe, meaning you must state what
    type of return data you plan to receive in the event of an exception being thrown.
    In this case, we throw `EINVAL`, which is an integer, so we catch an integer and
    output the result to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to set jump, `myfunc()` no longer needs to return an error code, which
    means it is free to output any value it wants (meaning the output is not constrained),
    as shown in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `myfunc()` returns a handle, which may take on any
    value, since the user of this function will know whether the handle is valid if
    an exception has been thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to set jump, our nested case is greatly simplified compared to our
    POSIX-style error handling example, as we no longer need to manually unwind the
    call stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is similar to our set jump example, the main difference
    being that we throw an exception instead of performing a long jump, and we catch
    the exception using the `try...catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike set jump, C++ exceptions support RAII, meaning objected defined within
    the scope of a function are properly destroyed as the function exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the preceding example, the destructor is called in both the
    `success` case and the failure case. To accomplish this, C++ includes a stack
    unwinder, which is capable of automatically unwinding the stack, similar to how
    we manually unwound the call stack using POSIX-style error handling, but automatically
    and without the need to execute branch statements through the code, resulting
    in optimal performance (as if error checking was not taking place). This is called
    **zero-overhead exception handling**.
  prefs: []
  type: TYPE_NORMAL
- en: The details of how the unwinder automatically unwinds the call stack without
    incurring any performance overhead, while still supporting RAII in a thread-safe
    manner, is outside the scope of this book, since this process is extremely complicated.
    However, a brief explanation follows.
  prefs: []
  type: TYPE_NORMAL
- en: When C++ exceptions are enabled and your code is compiled, a set of stack-unwinding
    instructions are also compiled for each function and placed the executable in
    a place where the C++ exception unwinder can find them. The compiler then compiles
    the code as if error handling is not taking place, and the code executes as such.
    If an exception is thrown, a thread-safe object is created that wraps the data
    being thrown and is stored. From there, the execution of the function is reversed
    using the call stack-unwinding instructions that were previously saved in the
    executable, eventually resulting in the function that threw the exception being
    exited to its caller. Before the function exits, all destructors are executed,
    and this process is continued for each function that was called in the call stack
    until a `catch{}` block is encountered that is capable of handling the data that
    was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key points to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The unwind instructions are stored in a table in the executable. Each time a
    function's execution needs to be reversed (from a register point of view), the
    unwinder must look up these instructions for the next function in the table. This
    operation is slow (although some optimizations have been added, including the
    use of a hash table). For this reason, exceptions should never be used for control
    flow as they are slow and inefficient in the error case, while extremely efficient
    in the `success` case. C++ exceptions should only be used for error handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The more functions you have in a program, or the larger the functions are (that
    is, the more the function touches the CPUs registers), the more information that
    must be stored in the unwind instructions table, resulting in a larger program.
    If C++ exceptions are never used in your program, this information is still compiled
    and stored in the application. For this reason, exceptions should be disabled
    if they are not used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to being thread-safe, performant, and capable of supporting RAII,
    C++ exceptions all support complex data types. The typical data type that is used
    by C++ includes strings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we throw a `std::runtime_error{}` exception. This
    exception is one of many, provided by C++, that inherits `std::exception`, which
    supports the ability to store a string in addition to the exception type itself.
    In the preceding example, we store `invalid val`. The preceding code is capable
    of not only detecting the provided string but also the fact that `std::runtime_exception{}`
    was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, you might not know what type of exception is being thrown. This
    is usually the case when an exception that doesn''t inherit `std::exception` is
    thrown, such as raw strings and integers. To catch any exception, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we throw an integer and we catch it using the `...` syntax,
    which states that we wish to catch all exceptions. It''s always good practice
    to have this type of catch statement at least somewhere in your code to ensure
    that all exceptions are being caught. In all of our examples throughout this book,
    we have included this `catch` statement for that very reason. The major disadvantage
    to this type of `catch{}` block is that we must use `std::current_exception()`
    to get the exception, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we throw `std::runtime_error()` from `myfunc1()`.
    In `myfunc2()`, we catch the exception using the `...` syntax, stating that we
    wish to catch all exceptions. To get the exception, we must use `std::current_exception()`,
    which returns `std::exception_ptr{}`. `std::exception_ptr{}` is an implementation-specific
    pointer type that can be re-thrown using `std::rethrow_exception()`. Using this
    function, we can then catch the exception using the preceding standard method
    and output the message within. It should be noted that if you wish to catch an
    exception, `std::current_exception()` is not the recommended way, as you would
    need to re-throw the exception to get the `what()` from it since `std::exception_ptr`
    does not provide an interface for getting `what()`. It should also be noted that
    `std::current_exception()` will not help if an exception was thrown that is not
    a subclass of `std::exception{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it''s possible to replace `subclass std::exception` with your own,
    custom data. To do this, refer to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we subclass `std::exception` to create our own exception
    that is capable of storing an error number. As with all subclasses of `std::exception{}`,
    the `what()` function should be overloaded to provide a message that uniquely
    identifies your custom exception. In our case, we also provide a function to retrieve
    the error code that was stored when the exception was created and thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common task is to create a custom string for your exception. This,
    however, can lead to a common mistake, which is to return a constructed string
    in the `what()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code produced undefined behavior, and a hard-to-find bug. In the
    preceding code, we store an error code just like we did in the previous example,
    but instead of returning it, we return the error code in a string in the `what()`
    function. To do this, we leverage the `std::to_string()` function to convert our
    error code into a `std::string`. We then prepend `error:`, and return the resulting
    standard C string.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the preceding example is that a pointer to the standard C string
    is returned and then `std::string{}` is destroyed when the `what()` function exits.
    The code that attempts to use the string returned by this function will end up
    reading deleted memory. The reason this is hard to find is that in some cases,
    this code will execute as expected, only because the contents of memory likely
    didn't change fast enough. Given enough time, however, this code will likely lead
    to corruption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, to create a string that outputs the same message, put the resulting
    error code in the constructor of an existing exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we subclass `std::runtime_error{}` instead of `std::exception`
    directly, and create our `what()` message during the construction of the exception.
    This way, when `what()` is called, the exception information is available without
    corruption.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will end this chapter with a note about the only real addition to C++17
    with respect to exception support. Throwing an exception while an exception is
    already thrown is generally discouraged. To accomplish this, you must throw an
    exception from the destructor of a class that has been marked as `except()`, and
    that is destroyed during stack-unwinding. Prior to C++17, a destructor could detect
    whether this was about to happen by leveraging the `std::uncaught_exception()`
    function, which would return true if an exception was in the process of being
    thrown. To support throwing an exception while an exception is already being thrown,
    C++17 changed this function to return an integer that represents the total number
    of exceptions currently being thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a class that outputs to `stdout`, the total
    number of exceptions currently being thrown. This class is then instantiated in
    `myfunc()`. In the success case, no exceptions are in the process of being thrown
    when the class is destroyed. In the error case, one exception is reported as being
    thrown when the class is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Studying an example on exception benchmark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final example, we will demonstrate that C++ exceptions outperform POSIX-style
    exceptions (a claim that is largely dependent on the hardware you're executing
    on, as compiler optimizations and aggressive branch prediction can improve the
    performance of POSIX-style error handling).
  prefs: []
  type: TYPE_NORMAL
- en: POSIX-style error handling requires the user to check the result of a function
    each time it is executed. When function nesting occurs (which will almost certainly
    happen), this issue is exacerbated even further. In this example, we will take
    this case to the extreme, creating a recursive function that checks the results
    of itself thousands of times, while executing the test hundreds of thousands of
    times. Each test will be benchmarked and the results will be compared.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of factors that could change the results of this test, including
    branch prediction, optimizations, and the operating system. The goal of this test
    is to take the example so far to the extreme that most of these issues are washed
    out in the noise, and any performance-related issues with any approach are easily
    identifiable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we will need the following includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need the following globally-defined jump buffer, as we will be
    comparing C++ exceptions to set jump and POSIX-style error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also use the same benchmark code we have used in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first recursive function will return an error using POSIX-style error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, the return value of the function is compared as expected. The second
    function will return an error using set jump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, this function is less complicated, since no return value needs
    to be returned or compared. Finally, the third function will return an error using
    C++ exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As expected, this function is almost identical to set jump, with the use of
    C++ exceptions being the only difference. Since we are not testing RAII, we would
    expect C++ exceptions to be as fast to execute as set jump, since both do not
    need to perform a comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally in our protected `main` function, we will execute each function the
    same way we have in our previous examples, to demonstrate that each function executes
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first test function tests the C-style error handling logic to ensure that
    the function returns both success and failure as expected. We then execute the
    success case several times and time how long it takes to execute, outputting the
    results to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, we also ensure that the second, C-style exceptions example also returns
    success and failure as expected. Then, we execute the success case several times
    to see how long it takes to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We do the same thing with our C++ exceptions example. We complete our `protected_main()`
    function by executing each test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the benchmark are output to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As with all of our examples, the `protected_main()` function is executed by
    the `main()` function, which catches exceptions should they occur.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter13/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter13/CMakeLists.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, we can compile this code using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the example, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, C++ exceptions outperformed POSIX-style
    error handling, and set jump exceptions were comparable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned three different methods for performing error handling
    when system programming. The first method was POSIX-style error handling, which
    involves returning an error code from every function executed and the results
    of each function being checked to detect an error. The second method involved
    the use of standard C-style exceptions (that is, set jump), demonstrating how
    this form of exception-handling solves a lot of issues with POSIX-style error
    handling, but introduces issues with RAII support and thread safety. The third
    example discussed the use of C++ exceptions for error handling, and how this form
    of error handling solves most of the issues discussed in this chapter, with the
    only disadvantage being an increase in the size of the resulting executable. Finally,
    this chapter concluded with an example that demonstrated how C++ exceptions outperform
    POSIX-style error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do C++ exceptions outperform POSIX-style error handling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a function return an output with POSIX-style error handling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why doesn't set jump support RAII?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you catch any exception using a `catch{}` block?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do C++ exceptions increase the size of an executable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should C++ exceptions not be used for control flow?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
