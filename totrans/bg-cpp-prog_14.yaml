- en: Chapter 14. Building Playable Levels and Collision Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will probably be one of the most satisfying of this project. The
    reason for this is that by the end of it, we will have a playable game. Although
    there will still be features to implement (sound, particle effects, HUD, and shader
    effects), Bob and Thomas will be able to run, jump, and explore the world. Furthermore,
    you will be able to create your very own level designs of almost any size or complexity
    by simply making platforms and obstacles in a text file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will achieve all this by covering following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring how to design levels in a text file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a `LevelManager` class that will load levels from a text file, convert
    them into data our game can use, and keep track of the level details, such as
    spawn position, current level, and allowed time limit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the game engine to use `LevelManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding a polymorphic function to handle the collision detection for both Bob
    and Thomas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing some levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember our sprite sheet that we introduced in [Chapter 12](ch12.html "Chapter 12. Abstraction
    and Code Management – Making Better Use of OOP"), *Abstraction and Code Management
    - Making Better Use of OOP.* Here it is again, annotated with numbers that represent
    each tile that we will build our levels from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing some levels](img/image_14_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I placed the screenshot on a gray background so you could see clearly the different
    details of the sprite sheet. The checkered background represents the level of
    transparency. So, all of the tiles except for number 1 will reveal at least a
    little of the background behind them:'
  prefs: []
  type: TYPE_NORMAL
- en: Tile 0 is completely transparent and will be used to fill in the gaps where
    there aren't any other tiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tile 1 is for the platforms that Thomas and Bob will walk on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tile 2 is for fire tiles and tile 3 is for water tiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tile 4 you might need to look quite closely to see. It has a white, square outline.
    This is the goal of the level where Thomas and Bob must get to together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep this screenshot in mind as we discuss designing the levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will enter combinations of these tile numbers into text files to design
    the layouts. An example will help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code translates to the following level layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing some levels](img/image_14_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that to get the view shown in the previous screenshot, I had to zoom out
    the `View`. Also, the screenshot is cropped. The actual start of the level would
    look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing some levels](img/image_14_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The point of showing you these screenshots is two fold. Firstly, you can see
    how you can quickly construct level designs using a simple and free text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just make sure you use a monospace font so that all the numbers are the same
    size. This makes designing the levels much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, the screenshots demonstrate the gameplay aspects of the design. From
    left to right in the level, Thomas and Bob first need to jump a small hole or
    they will fall to their deaths (re-spawn). Then they have a large expanse of fire
    to traverse. It is actually impossible for Bob to jump that many tiles. The players
    will need to work together for the solution. The only way that Bob will clear
    the fire tiles is by standing on Thomas''s head and jumping from there, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing some levels](img/image_14_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is then quite simple to get to the goal and move on to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I strongly encourage you to complete this chapter and then spend some time designing
    your own levels.
  prefs: []
  type: TYPE_NORMAL
- en: I have included a few level designs to get you started. They are in the `levels`
    folder that we added to the project back in [Chapter 12](ch12.html "Chapter 12. Abstraction
    and Code Management – Making Better Use of OOP"), *Abstraction and Code Management
    - Making Better Use of OOP*.
  prefs: []
  type: TYPE_NORMAL
- en: What follows are some zoomed out views of the game, along with a screenshot
    of the code of the level design. The screenshot of the code is probably more useful
    than reproducing the actual textual content. If you do want to see the code, just
    open up the files in the `levels` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing some levels](img/image_14_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is level layout that the previous code will produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing some levels](img/image_14_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This level is the "leap of faith" level I referred to in [Chapter 12](ch12.html
    "Chapter 12. Abstraction and Code Management – Making Better Use of OOP"), *Abstraction
    and Code Management - Making Better Use of OOP*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing some levels](img/image_14_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I have highlighted the platforms, as they are not very clear in the zoomed-out
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing some levels](img/image_14_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The provided designs are simple. The game engine will be able to handle very
    large designs, however. You have the freedom to use your imagination and build
    some really big and hard-to-complete levels.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these designs won't actually do anything until we learn how to load
    them and convert the text into a playable level. Additionally, it won't be possible
    to stand on any platforms until we have implemented the collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's handle loading the level designs.
  prefs: []
  type: TYPE_NORMAL
- en: Building the LevelManager class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It will take several phases of coding to make our level designs work. The first
    thing we will do is code the `LevelManager` header file. This will allow us to
    look at and discuss the member variables and functions that will be in the `LevelManger`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will code the `LevelManager.cpp` file, which will have all the function
    definitions in it. As this is a long file, we will break it up into several sections,
    to code and discuss them.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `LevelManager` class is complete, we will add an instance of it to
    the game engine (`Engine` class). We will also add a new function to the `Engine`
    class, `loadLevel`, which we can call from the `update` function whenever a new
    level is required. The `loadLevel` function will not only use the `LevelManager`
    instance to load the appropriate level but it will also take care of aspects such
    as spawning the player characters and preparing the clock.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, let's get an overview of `LevelManager` by coding the
    `LevelManager.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: Coding LevelManager.h
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File (** `.h` **)** and then in the **Name** field, type `LevelManager.h`.
    Finally, click the **Add** button. We are now ready to code the header file for
    the `LevelManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following include directives and private variables, and then we will
    discuss them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code declares `Vector2i` `m_LevelSize` to hold two integer values that will
    hold the horizontal and vertical number of tiles that the current map contains. `Vector2f`, `m_StartPosition`
    contains the coordinates in the world where Bob and Thomas should be spawned.
    Note that this is not a tile position relatable to `m_LevelSize` units, but a
    horizontal and vertical pixel position in the level.
  prefs: []
  type: TYPE_NORMAL
- en: The `m_TimeModifier` member variable is a float that will be used to multiply
    the time available in the current level. The reason we want to do this is so that
    by changing (decreasing) this value, we will shorten the time available each time
    the player attempts the same level. As an example, if the player gets 60 seconds
    for the first time they attempt level one then 60 multiplied by 1 is, of course,
    60\. When the player completes all the levels and comes back to level 1 for the
    second time, `m_TimeModifier` will have been reduced by 10 percent. Then, when
    the time available is multiplied by 0.9, the amount of time available to the player
    will be 54 seconds. This is 10 percent less than 60\. The game will get steadily
    harder.
  prefs: []
  type: TYPE_NORMAL
- en: The float variable, `m_BaseTimeLimit`, holds the original, unmodified time limit
    we have just been discussing.
  prefs: []
  type: TYPE_NORMAL
- en: You can probably guess that `m_CurrentLevel` will hold the current level number
    that is being played.
  prefs: []
  type: TYPE_NORMAL
- en: The `int` `NUM_LEVELS` constant will be used to flag when it is appropriate
    to go back to level one again and reduce the value of `m_TimeModifier`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following public variables and function declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, there are two constant `int` members. `TILE_SIZE` is a
    useful constant to remind us that each tile in the sprite sheet is fifty pixels
    wide and fifty pixels high. `VERTS_IN_QUAD` is a useful constant to make our manipulation
    of a `VertexArray` less error-prone. There are, in fact, four vertices in a quad.
    Now we can't forget it.
  prefs: []
  type: TYPE_NORMAL
- en: The `getTimeLimit`, `getStartPosition`, `getLevelSize`, and `getCurrentLevel` functions
    are simple getter functions, that return the current value of the private member
    variables we declared in the previous block of code.
  prefs: []
  type: TYPE_NORMAL
- en: A function that deserves a closer look is `nextLevel`. This function receives
    a `VertexArray` reference, just like we used in the Zombie Arena game. The function
    can then work on the `VertexArray`, and all the changes will be present in the
    `VertexArray` from the calling code. The `nextLevel` function returns a pointer
    to a pointer, which means we can return an address that is the first element of
    a two-dimensional array of `int` values. We will be building a two-dimensional
    array of `int` values that will represent the layout of each level. Of course,
    these int values will be read from the level design text files.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the LevelManager.cpp file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `LevelManager.cpp`.
    Finally, click the **Add** button. We are now ready to code the `.cpp` file for
    the `LevelManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: As this is quite a long class, we will break it up to discuss it in six chunks.
    The first five will cover the `nextLevel` function, and the sixth, all the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following include directives and the first (of five) part of the `nextLevel`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After the include directives, the code initializes `m_LevelSize.x` and `m_LevelSize.y`
    to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `m_CurrentLevel` is incremented. The `if` statement that follows checks
    whether `m_CurrentLevel` is greater than `NUM_LEVELS`. If it is, `m_CurrentLevel`
    is set back to `1` and `m_TimeModifier` is reduced by `.1f` in order to shorten
    the time allowed for all levels.
  prefs: []
  type: TYPE_NORMAL
- en: The code then switches based on the value held by `m_CurrentLevel`. Each `case`
    statement initializes the name of the text file, which holds the level design
    and the starting position for Thomas and Bob, as well as `m_BaseTimeLimit`, which
    is the unmodified time limit for the level in question.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you design your own levels, add a `case` statement and the appropriate values
    for it here. Also edit the `NUM_LEVELS` constant in the `LevelManager.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the second part of the `nextLevel` function, as shown. Add the code
    immediately after the previous code. Study the code as you add it so we can discuss
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previous (second part) we have just coded, we declare an `ifstream` object
    called `inputFile`, which opens a stream to the filename contained in `levelToLoad`.
  prefs: []
  type: TYPE_NORMAL
- en: The code loops through each line of the file using `getline`, but doesn't record
    any of its content. All it does is count the number of lines by incrementing `m_LevelSize.y`.
    After the `for` loop, the width of the level is saved in `m_LevelSize.x` using
    `s.length`. This implies that the length of all the lines must be the same or
    we would run in to trouble.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we know and have saved the length and width of the current level
    in `m_LevelSize`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the third part of the `nextLevel` function, as shown. Add the code
    immediately after the previous code. Study the code as you add it so we can discuss
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we clear `inputFile` using its `clear` function. The `seekg` function
    called with the `0, ios::beg` parameters resets the stream back to before the
    first character.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a pointer to a pointer called `arrayLevel`. Note that this
    is done on the free store/heap using the `new` keyword. Once we have initialized
    this two-dimensional array, we will be able to return its address to the calling
    code and it will persist until we either delete it or the game is closed.
  prefs: []
  type: TYPE_NORMAL
- en: '`for` loops from 0 to `m_LevelSize.y -1`. In each pass, it adds a new array
    of `int` values to the heap to match the value of `m_LevelSize.x`. We now have
    a perfectly configured (for the current level) two-dimensional array. The only
    problem is that there is nothing in it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the fourth part of the `nextLevel` function, as shown. Add the code
    immediately after the previous code. Study the code as you add it so we can discuss
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, the code initializes a `string`, called `row`, which will hold one row
    of the level design at a time. We also declare and initialize an `int` called
    `y` that will help us count the rows.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop executes repeatedly until `inputFile` gets past the last row.
    Inside the `while` loop there is a `for` loop, which goes through each character
    of the current row and stores it in the two-dimensional array, `arrayLevel`. Notice
    that we access exactly the right element of the two-dimensional array with `arrayLevel[y][x]
    =`. The `atoi` function converts `char val` to `int`. This is what is required,
    because we have a two-dimensional array for `int`, not `char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the fifth part of the `nextLevel` function, as shown. Add the code
    immediately after the previous code. Study the code as you add it so we can discuss
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Although this is the longest section of code from the five sections we divided
    `nextLevel` into, it is also the most straightforward. This is because we have
    seen very similar code in the Zombie Arena project.
  prefs: []
  type: TYPE_NORMAL
- en: What happens is that the nested `for` loop loops from zero through to the width
    and height of the level. For each position in the array, four vertices are put
    into `VertexArray` and four texture coordinates are assigned from the sprite sheet.
    The positions of the vertices and texture coordinates are calculated using the
    `currentVertex` variable, the `TILE SIZE`, and `VERTS_IN_QUAD` constants. At the
    end of each loop of the inner `for` loop, `currentVertex` is increased by `VERTS_IN_QUAD`,
    moving nicely on to the next tile.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to remember about this `VertexArray` is that it was passed
    into `nextLevel` by reference. Therefore, the `VertexArray` will be available
    in the calling code. We will call `nextLevel` from the code in the `Engine` class.
  prefs: []
  type: TYPE_NORMAL
- en: Once this function has been called, the `Engine` class will have a `VertexArray`
    to represent the level graphically, and a two-dimensional array of `int` values
    as a numerical representation of all the platforms and obstacles in the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the `LevelManager` functions are all simple getter functions, but
    do take the time to familiarize yourself with what private value is returned by
    which function. Add the remaining functions from the `LevelManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `LevelManager` class is complete, we can move on to using it. We
    will code another function in the Engine class to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the loadLevel function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be clear, this function is part of the `Engine` class, although it will delegate
    much of its work to other functions, including those of the `LevelManager` class
    that we just built.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add the declaration for the new function, along with some other
    new code, to the `Engine.h` file. Open the `Engine.h` file and add the highlighted
    lines of code shown in the following abbreviated snapshot of the `Engine.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the following in the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: We included the `LevelManager.h` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added an instance of `LevelManager` called `m_LM`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a `VertexArray` called `m_VALevel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a pointer to a pointer to an `int` that will hold the two-dimensional
    array that is returned from `nextLevel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a new `Texture` object for the sprite sheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the declaration for the `loadLevel` function that we will write now
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `LoadLevel.cpp`.
    Finally, click the **Add** button. We are now ready to code the `loadLevel` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code for the `loadLevel` function to the `LoadLevel.cpp` file, and
    then we can discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we set `m_Playing` to false to stop parts of the update function from
    executing. Next, we loop through all the horizontal arrays within `m_ArrayLevel`
    and delete them. After the `for` loop, we delete `m_ArrayLevel`.
  prefs: []
  type: TYPE_NORMAL
- en: The code, `m_ArrayLevel = m_LM.nextLevel(m_VALevel)`, calls `nextLevel` and
    prepares both the `VertexArray` and `m_VALevel`, as well as the two-dimensional `m_ArrayLevel` array.
    The level is set up and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: '`m_TimeRemaining` is initialized by calling `getTimeLimit`, and Thomas and
    Bob are spawned using the `spawn` function along with the value returned from
    `getStartPosition`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `m_NewLevelRequired` is set to `false`. As we will see in a few page's
    time, `m_NewLevelRequired` being set to `true` is what causes `loadLevel` to be
    called. We only want to run this function once.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `Engine.cpp` file and add the highlighted code to load the sprite
    sheet texture at the end of the `Engine` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All we do in the previous code is load the sprite sheet into `m_TextureTiles`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Update.cpp` file and make the following highlighted changes and additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Actually, you should delete, rather than comment out, the lines we are no longer
    using. I have just shown it to you this way so that the changes are clear. All
    there should be in the previous `if` statement is the call to `loadLevel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, before we can see the results of the work so far this chapter, open
    the `Draw.cpp` file and make the following highlighted additions to draw the vertex
    array that represents a level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice we need to draw the `VertexArray` for all screen options (full, left,
    and right.)
  prefs: []
  type: TYPE_NORMAL
- en: Now you can run the game. Unfortunately, however, Thomas and Bob fall straight
    through all our lovingly-designed platforms. For this reason, we can't try and
    progress through the levels and beat the clock.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will handle collision detection using rectangle intersection and the SFML
    intersects function. What will be different in this project is that we will abstract
    the collision detection code into its own function and Thomas and Bob, as we have
    already seen, have multiple rectangles (`m_Head`, `m_Feet`, `m_Left`, `m_Right`)
    that we need to check for collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the detectCollisions function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be clear, this function is part of the Engine class. Open up the `Engine.h`
    file and add a declaration for a function called `detectCollisions`. This is shown
    highlighted in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice from the signature that the `detectCollision` function takes a polymorphic
    argument, a `PlayerCharacter` object. As we know, `PlayerCharacter` is abstract
    and can never be instantiated. We do, however, inherit from it with the `Thomas`
    and `Bob` classes. We will be able to pass either `m_Thomas` or `m_Bob` to `detectCollisions`.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `DetectCollisions.cpp`.
    Finally, click the **Add** button. We are now ready to code the `detectCollisions`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `DetectCollisions.cpp`. Note that this is just the
    first part of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that happens is that we declare a Boolean called `reachedGoal`.
    This is the value that the `detectCollisions` function returns to the calling
    code. It is initialized to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Next we declare a `FloatRect` called `detectionZone` and initialize it with
    the same rectangle that represents the entire rectangle of the character sprite.
    Note that we will not actually do intersection tests with this rectangle. After
    that, we declare another `FloatRect` called `block`. We initialize `block` as
    a 50 by 50 rectangle. We will see `block` in use shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Next we see how we will use `detectionZone`. We initialize four `int` variables,
    `startX`, `startY`, `endX`, and `endY` by expanding the area around `detectionZone`
    a few blocks. In the four `if` statements that follow, we check that it is not
    possible to try and do collision detection on a tile that does not exist. We achieve
    this by making sure we never check positions less than zero or greater than the
    value returned by `getLevelSize().x` or `.y`.
  prefs: []
  type: TYPE_NORMAL
- en: What all this previous code has done is to create an area with which to do collision
    detection. There is no point doing collision detection on a block that is hundreds
    or thousands of pixels away from the character. In addition, if we try and do
    collision detection where an array position doesn't exist (less than zero or greater
    than `getLevelSize()...`), the game will crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add this code, which handles the player falling out of the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For a character to stop falling, it must collide with a platform. Therefore,
    if the player moves out of the map (where there are no platforms) it will continuously
    fall. The previous code checks whether the character *does not* intersect with
    the `FloatRect`, `level`. If it does not, then it has fallen out of the level
    and the `spawn` function sends it back to the start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following, quite large code, and then we will go through what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code does three things using the same techniques. It loops through
    all the values contained between startX, endX and startY, endY. For each pass,
    it checks and does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Has the character burned or drowned? The code `if (m_ArrayLevel[y][x] == 2 ||
    m_ArrayLevel[y][x] == 3)` determines if the current position being checked is
    a fire or a water tile. If the character's head intersects with one of these tiles,
    the player is re-spawned. We also code an empty `if…else` block in preparation
    for adding sound in the following chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has the character touched a regular tile? The code `if (m_ArrayLevel[y][x] ==
    1)` determines if the current position being checked holds a regular tile. If
    it intersects with any of the rectangles that represent the various body parts
    of the character, the related function is called (`stopRight`, `stopLeft`, `stopFalling`,
    and `stopJump`). The value that is passed to each of these functions and how the
    function uses the value to reposition the character is quite nuanced. While it
    is not necessary to closely examine these values to understand the code, you might
    like to look at the values passed in and then refer back to the appropriate function
    of the `PlayableCharacter` class in the previous chapter. This will help you appreciate
    exactly what is going on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has the character touched the goal tile? This is determined with the code `if
    (m_ArrayLevel[y][x] == 4)`. All we need to do is set `reachedGoal` to `true`.
    The `update` function of the `Engine` class will keep track of whether both characters
    (Thomas and Bob) have reached the goal simultaneously. We will write this code
    in `update` in just a minute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the last line of code to the `detectCollisions` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous line of code returns `reachedGoal` so that the calling code can
    keep track and respond appropriately if both characters reach the goal simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do now is call the `detectCollision` function once per character
    per frame. Add the following highlighted code in the `Update.cpp` file within
    the `if(m_Playing)` block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous code calls the `detectCollision` function and checks if both Bob
    and Thomas have simultaneously reached the goal. If they have, the next level
    is prepared by setting `m_NewLevelRequired` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the game and walk on the platforms. You can reach the goal and start
    a new level. Also, for the first time, the jump buttons (*W* or Arrow Up) will
    work.
  prefs: []
  type: TYPE_NORMAL
- en: If you reach the goal, the next level will load. If you reach the goal of the
    last level, then the first level will load with a 10% reduced time limit. Of course,
    there is no visual feedback for the time or the current level because we haven't
    built a HUD yet. We will do so in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the levels, however, require Thomas and Bob to work as a team. More
    specifically, Thomas and Bob need to be able to climb on each other's heads.
  prefs: []
  type: TYPE_NORMAL
- en: More collision detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add this code just after the previous code you added in the `Update.cpp` file,
    within the `if (m_Playing)` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the game again and stand on the heads of Thomas and Bob to get
    to the hard-to-reach places that were previously not attainable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More collision detection](img/image_14_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was quite a lot of code in this chapter. We learned how to read from a
    file and convert strings of text into char and then `int`. Once we had a two-dimensional
    array of `int`, we were able to populate a `VertexArray` to actually show the
    level on the screen. We then used exactly the same two-dimensional array of int
    to implement collision detection. We used rectangle intersection, just as we did
    in the Zombie Arena project, although this time, for more precision, we gave each
    character four collision zones, one each to represent their head, feet, and their
    left and right sides.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the game is totally playable, we need to represent the state of the
    game (score and time) on the screen. In the following chapter, we will implement
    the HUD, along with some much more advanced sound effects than we have used so
    far.
  prefs: []
  type: TYPE_NORMAL
