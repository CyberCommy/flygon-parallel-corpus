- en: Containerizing Your Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are becoming one of the key factors of software development, changing
    the way that developers are writing and deploying IT systems. These are mainly
    used to solve problems related to setup environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with containers can be overwhelming when you have to manage multiple
    containers and multi-instance environments. However, some really cool tools have
    been released that are designed to accomplish these container orchestration tasks.
    We are going to look at these tools throughout this chapter, along with the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Containers**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containerizing Applications**: Docker Gradle plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Registries**: Publishing images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provisioning multiple-container environments**: Docker Compose'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container orchestration with Kubernetes**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replication controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Containers provide a lightweight approach to virtualization that consists of
    providing the bare minimum that an application requires in order to work. In the
    old days, VMs used to be the main choice for provisioning environments and running
    applications. However, they require a complete OS in order to work. Containers,
    on the other hand, reuse the host OS to run and provision the required environments.
    Let''s learn more about this concept by looking at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efbb30f8-49cd-4d73-b325-67db986da2ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Virtual machines and containers
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see the **Virtual Machines** (**VMs**) on the
    left side and the **containers** on the right side. Let's start by learning how
    a Vm works.
  prefs: []
  type: TYPE_NORMAL
- en: VMs require their own OS using the hardware assigned to the VM, which is supported
    by the hypervisor. The preceding diagram shows three VMs, which means that we
    need to have installed three OSes, one per VM. When you're running applications
    within VMs, you have to consider the resources that will be consumed by the application
    and the OS.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, containers use the kernel provided by the OS host, which
    also supplies the basic services for all containers using virtual-memory support
    for isolation. In this case, there is no need to install a whole OS for each container;
    this is an effective approach in terms of memory and storage usage. When you're
    running applications using containers, you only have to consider the resources
    consumed by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are small and can be measured in tens of megabytes, taking only a
    few seconds to be provisioned. In contrast, VMs are measured in tens of gigabytes,
    but they can take a few minutes to even start working. You should also consider
    OS licensing—when you're using VMs, you'll have to pay for the licenses of each
    installed OS. When using containers, you only need one OS that all the containers
    will use to function.
  prefs: []
  type: TYPE_NORMAL
- en: There are different containers currently available on the market, but Docker
    is the most popular implementation these days. For this reason, we are going to
    choose this option to explain all the concepts in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Basic concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to review some basic concepts and commands that
    you'll commonly use on a daily basis. This should help you to understand the rest
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Containers and images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When talking about Docker, people often use the terms *containers* and *images*.
    The difference between these two terms is simple: a container is an instance of
    an image, while an image is an immutable file that''s essentially a snapshot of
    a container. In terms of **object-oriented programming** (**OOP**), we can say
    that images are like classes and containers are instances of these classes. For
    example, let''s say you have a Docker image that is comprised of CentOS and Java
    8\. Using this image, you can create a container to run a Spring Boot application
    and another container to run a JEE application, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c98cbae-61e1-45f2-9857-9b537399823a.png)'
  prefs: []
  type: TYPE_IMG
- en: Docker images and containers
  prefs: []
  type: TYPE_NORMAL
- en: Basic commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker has a large set of commands to execute different operations using containers
    and images. However, there is no need to be familiar with all of them. We will
    now review some of the most common commands that you need to know in order to
    work with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Running containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We mentioned earlier that containers are instances of images. When you want
    to run a Docker container, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are plenty of Docker images available on the internet. Before creating
    a custom image, you should first review the list of images available on Docker
    Hub ([https://hub.docker.com/](https://hub.docker.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub is a cloud-based registry service that allows you to link to code
    repositories, build your images, and test them. It also stores manually pushed
    images and links to Docker Cloud so that you can deploy images to your hosts.
    Docker Hub provides a centralized resource for container and image discovery,
    distribution, and change management; user and team collaboration; and workflow
    automation throughout the development pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that you want to run a container using `nginx`. In this case, all
    that you need to do is execute the following command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you run this command, Docker will try to find the image locally. If it''s
    unable to find it there, it will look for the image using all the registries available
    (we will talk about registries later on). In our case, this is Docker Hub. The
    first thing you should see in the terminal is an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After executing this operation, you will get a string similar to `d38bbaffa51cdd360761d0f919f924be3568fd96d7c9a80e7122db637cb8f374` that
    represents the image ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some useful flags for running containers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-d` flag runs the image as a daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-p` flag connects the image ports to the host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following command makes it possible to run `nginx` as a daemon
    and maps port `80` from the container to port `32888` on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you will have control of the terminal again, and you can see the `nginx` homepage
    in the `http://localhost:32888/` URL, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17afc51c-8e5b-4a5d-9f68-ef64d827257a.png)'
  prefs: []
  type: TYPE_IMG
- en: Nginx homepage
  prefs: []
  type: TYPE_NORMAL
- en: 'Containers only have the software and services that are strictly necessary for
    them to work, which is why you''ll find that they don''t even include an SSH entry.
    If you want to get into a container, you can use the `-it` flag, which executes
    a command within the container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Working with containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are interested in checking all the containers running on your host,
    you can use the `ps` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will list all the containers running on your host. If
    you also want to check the images that are not running, you can use the `-a` flag.
    After executing the preceding command, you''ll have an output in your terminal
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2483fdc5-fbe5-4f4f-9d8a-578119d6b16f.png)'
  prefs: []
  type: TYPE_IMG
- en: The Docker ps command output
  prefs: []
  type: TYPE_NORMAL
- en: 'The first column of the preceding screenshot explains the information in the
    following list. The most useful part of this output is the CONTAINER ID**,** which
    can be used to perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart the container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Stop the container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These are the most common commands, and they provide all that you need in order
    to start working with Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Working with images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker also has some commands that allow your system to work with images. The
    most commonly used commands are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing all the images available on the host:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing images:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Downloading images:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Building your own images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the internet, we can find many Docker images that are ready to use. These
    images are created using a configuration file called the Dockerfile, which has
    all the instructions for provisioning the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common commands that you will find as part of this file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MAINTAINER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's review all of these commands one by one in order to understand how they
    work.
  prefs: []
  type: TYPE_NORMAL
- en: FROM command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FROM` command is used to specify the base Docker image that will be used
    by the Dockerfile to build the new image. For example, if you want to create a
    custom image based on Debian, you should add the following line as part of your
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: MAINTAINER command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MAINTAINER` command is used entirely for documentation purposes, and this
    has the Dockerfile''s author name, as well as their email, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: RUN command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Dockerfile usually has more than one `RUN` command as part of it. These are
    intended to be executed as part of the system bash commands and are mainly used
    to install packages. For example, the following `RUN` command is used to install
    Java 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command was taken from the Dockerfile provided by an image called
    `oracle-java8` ([https://github.com/dockerfile/java/blob/master/oracle-java8/Dockerfile](https://github.com/dockerfile/java/blob/master/oracle-java8/Dockerfile)).
  prefs: []
  type: TYPE_NORMAL
- en: This command is easy to read, and each line describes how the installation process
    is done. The last two lines remove some directories from the container because
    they are no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: All installations are done as a single line because every `RUN` command generates
    a new layer. For example, in the `RUN` command, we can see that six instructions
    are executed at once. If we run those instructions one by one, we will end up
    having six images, each of which contains the base image plus the `RUN` command
    that was executed. We will not discuss layers in detail in this book, but if you
    feel curious, I highly encourage you to read about them at [https://docs.docker.com/storage/storagedriver/#images-and-layers](https://docs.docker.com/storage/storagedriver/#images-and-layers).
  prefs: []
  type: TYPE_NORMAL
- en: ENV command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ENV` command is used to create environmental variables in the system.
    The following `ENV` command is used as part of the previously mentioned Dockerfile
    in order to define the `JAVA_HOME `variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: EXPOSE command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `EXPOSE` command defines which ports we are going to expose from the container.
    For example, if you want to expose ports `80` and `32777`, you need to add the
    following line to your Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: CMD command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CMD` command is used to specify which command should be executed once
    the container is started. For example, if you want to run a Java application using
    the standard `java -jar` command, you will need to add the following line to the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have completed your Dockerfile, you should run the `build` command
    to create the image locally, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Containerizing applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A dockerized application is a basic deployable unit that can be integrated later
    as part of your whole ecosystem of applications. When you're dockerizing your
    application, you'll have to create your own Dockerfile with all the required instructions
    to make your application work.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the last section, we can create a container using an existing
    base image with the `FROM` command. You can also copy the Dockerfile content of
    the base image, but this practice is highly discouraged because it does not make
    sense to duplicate the code that was already written when the image was created.
  prefs: []
  type: TYPE_NORMAL
- en: It is strongly recommended that you find official images in DockerHub. Since
    the Dockerfile is available, you should always read it in order to avoid security
    issues and fully understand how the image works.
  prefs: []
  type: TYPE_NORMAL
- en: Before dockerizing an application, it is important that you make your system
    use environmental variables instead of configuration files. In this way, you can
    create images that can be reused by other applications. One of the biggest advantages
    of using Spring Framework is the ability to use different approaches to configure
    your applications. This is something that we did in [Chapter 8](7c38500a-5a66-422b-a41b-21f4fd18de51.xhtml),
    *Microservices**, *when we used a configuration server to centralize all the application
    configurations. Spring makes it possible for us to use a local configuration file
    as part of our application, and we can override those configuration values using
    environment variables later.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at how to dockerize a Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, we will create the Dockerfile to run our application. The
    content of this file is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s briefly review the commands listed in the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `FROM java:8` | The base `java:8` image is used |'
  prefs: []
  type: TYPE_TB
- en: '| `WORKDIR` | Default directory within the image filesystem |'
  prefs: []
  type: TYPE_TB
- en: '| `ARG` | We are going to use an argument for the JAR file |'
  prefs: []
  type: TYPE_TB
- en: '| `COPY` | The provided file will be copied inside the container as `app.jar`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EXPOSE` | Port 8080 of the container is exposed |'
  prefs: []
  type: TYPE_TB
- en: '| `ENTRYPOINT` | Run the Java application inside the container |'
  prefs: []
  type: TYPE_TB
- en: 'This Dockerfile should be located in the root of the project. The following
    screenshot shows the project layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/141a309e-e383-4ccb-9b89-c71f6836b836.png)'
  prefs: []
  type: TYPE_IMG
- en: Project layout
  prefs: []
  type: TYPE_NORMAL
- en: 'The application JAR is located under the `PROJECT/build/libs` directory. This
    artifact is generated by running the `bootRepackage` task using the Gradle wrapper,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the artifact has been created, it''s time to create the Docker image by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the command has finished, the image should exist locally. You can check
    this by running the `docker images` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7b2c033-fc34-4564-a8ae-af112d207844.png)'
  prefs: []
  type: TYPE_IMG
- en: Docker images console output
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `java` image is also present. This was downloaded during the
    `spring-boot` image build process. We can then create a container using the recently
    created image by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now visit the application deployed in the container in the `http://localhost:8081/index `URL.
    The following screenshot shows this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a077f67-7dce-4056-be8e-67ba79b15389.png)'
  prefs: []
  type: TYPE_IMG
- en: Application deployed in the container
  prefs: []
  type: TYPE_NORMAL
- en: The build process for the image can and should be automated using your preferred
    build tool. There are plugins for Gradle and Maven that can be integrated as part
    of your application. Let's look at how to integrate a Gradle plugin for this task.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Gradle plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even when generating a Docker image, using Docker commands is not hard or complex;
    it's always a good idea to automate all of these steps as much as we can. The
    Docker Gradle plugin is pretty useful for accomplishing this task. Let's learn
    how to make this part of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to include the repository that contains the plugin and
    the plugin itself as a dependency within the `buildscript` section, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, the plugin should be applied to the project in the same way as any other
    plugin—using its ID. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The image build process can be customized using the parameters described in
    the official documentation at [https://github.com/palantir/gradle-docker](https://github.com/palantir/gradle-docker).
    To keep things simple, we are only going to indicate the image name that is required
    within a `docker` block, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, we are now using the variables that are available in
    the `build.gradle` file, such as the generated JAR name and its version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the plugin has been fully integrated within the project, you can build
    the image by running the following Gradle task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check the recently created image, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/123cf284-aece-4007-864b-8f9c63cd0fbc.png)'
  prefs: []
  type: TYPE_IMG
- en: The docker images console output
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to have all of these steps automated as this provides free documentation
    that can be improved in the future if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, Docker helps us to reproduce the setup used to deploy an application,
    but it also helps us to distribute the application to be used in different environments.
    This task can be performed using registries.
  prefs: []
  type: TYPE_NORMAL
- en: 'A registry is a service that is responsible for hosting and distributing Docker
    images. The default registry used by Docker is Docker Hub. There are other options
    available on the market that can be used as Docker registries, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Quay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Container Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Container Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Hub is really popular because it works in ways that you do not even notice.
    For instance, if you're creating a container and the image doesn't exist in your
    local repository, it will automatically download the image from Docker Hub. All
    the existing images are created by someone else and published in these registries.
    In the same way, we can publish our own images in order to make them available
    to other people within an organization by using private repositories. Alternatively,
    you can publish them in public repositories. You can also self-host a Docker registry
    on your own hardware using solutions such as Nexus, JFrog, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub has a free plan that allows you to create an unlimited number of
    public repositories and one private repository. It also offers another plan that
    enables you to have more private repositories, if necessary. We use Docker Hub
    for Docker in the same way that we use GitHub for Git repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to publish a Docker image in Docker Hub, you will need to create an
    account and then log into Docker Hub using the terminal with the `docker login`
    command. After entering your credentials, you should see an output similar to
    the following code in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you''re logged in, you can push the image into the registry using
    the `docker push` command, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When the tag version is not specified, the `latest `value is used by default.
    In our case, a pretty small change should be applied to the `build.gradle` file
    to append the `docker-hub-username` prefix required by Docker Hub, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After generating the image again, you should log into Docker Hub from the terminal
    using the `docker login` command, and the image can be pushed later, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the image has been pushed, you can pull it and run a container in any
    other computer by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will download the image from Docker Hub and run the application locally.
    In the same way, we can repeat this process to deploy an application in any environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the pushed image looks on Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ba70773-de9d-4ab6-bdd4-aa42efdec445.png)'
  prefs: []
  type: TYPE_IMG
- en: Docker image pushed into Docker Hub
  prefs: []
  type: TYPE_NORMAL
- en: The `push` command should be automated using continuous integration servers.
    A good idea is to execute this command once a branch is merged into a `master` tag
    or a new tag is created in the version control system. You should always avoid
    using the default `latest` tag value. Instead, you should create version numbers
    by yourself using an automatic process, as we did using the Gradle plugin in the
    previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The integrated plugin also has the ability to push images using the `dockerPush`
    Gradle task.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning multiple-container environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the biggest problems that we have when we are working with distributed
    applications is the difficulty of provisioning all the dependencies that an application
    needs in order to work. For example, let''s say that you''re working on an application
    that is persisting information in a MySQL database and using RabbitMQ for sending
    messages, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e15db607-8afa-403e-b7c1-656a45b83ef9.png)'
  prefs: []
  type: TYPE_IMG
- en: Application with RabbitMQ and MySQL dependencies
  prefs: []
  type: TYPE_NORMAL
- en: In this case, all the developers on the team will need to install MySQL and
    RabbitMQ on their computers if they want to have the whole environment working
    locally.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a couple of tools is not so difficult, but as soon as your application
    begins to have more and more dependencies, this task becomes a nightmare. This
    is the exact problem that Docker Compose addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Compose is a tool which lets you define and execute multiple-container
    Docker environments. This means that every dependency in your application will
    be containerized and managed by this tool. Docker Compose was born as an independent
    open source project called **FIG** that was later integrated as part of the Docker
    family. At present, the latest Compose version is 2.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, you need a couple of extra services running: MySQL
    and RabbitMQ.'
  prefs: []
  type: TYPE_NORMAL
- en: When using Docker Compose, instead of installing the aforementioned services
    one by one, you'll able to build your application services in a `docker-compose.yaml`
    file, and then start and stop all of these services using this configuration file.
    This configuration file uses a YAML syntax that makes it easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the required configuration file to get RabbitMQ and MySQL services up
    and running locally is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we can keep adding as many services as we want within the
    configuration file. The use case of the `docker-compose.yaml` file is self-explanatory,
    and it''s worth mentioning that this file has specific configurations that are
    not defined within the Dockerfile, such as port mapping. Running this file is
    not difficult at all: you only have to use the `up` command from Docker Compose,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As a good practice, it is recommended that you provide a `docker-compose.yaml`
    file as part of your project. In this way, the provisioning process can be done easily
    by the team members.
  prefs: []
  type: TYPE_NORMAL
- en: Linking containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you''re running distributed applications, you have to connect different
    services in order to make them work together. To achieve this requirement, you
    need to know the hostnames or IP addresses of the services, among other configuration
    variables. The order in which the services are made available is also important.
    Let''s consider the following simple application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b81c4411-573a-4cfa-9dc1-53d66ddb9ede.png)'
  prefs: []
  type: TYPE_IMG
- en: Services dependencies
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram represents the most simple application; it has only one
    dependency on a database server. In this example, the application needs some database
    configuration parameters, such as the IP address, port, and so on. And of course,
    the database service should be available before starting the application; otherwise,
    the application won't be able to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to solve this simple requirement, you can use the following two options
    as part of your `docker-compose.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`links`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`depends_on`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `links` option can be used to connect various containers by their names.
    This way, you won't need to know their hostnames or IP addresses at all.
  prefs: []
  type: TYPE_NORMAL
- en: depends_on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `depends_on` option, you can specify the order in which the service
    should start. One service can have dependencies on more than one service, if that's
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the following `docker-compose.yaml` file, which uses both of
    these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `depends_on` and `links` options in the preceding code are highlighted in
    bold. It's pretty easy to understand from this that the application connects to
    the database server once the database is up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enriquezrene/docker-compose-banking-app: 1.0` image has a Spring Boot
    application running inside of it. As part of this application, we have the configuration
    file named `application.properties` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that the password and data source URL parameters are already
    provided. However, Spring offers the ability to override these configurations
    by using environment variables, as we did in the `docker-compose.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose is easy to use, and it has the same options as Docker. Let's quickly
    review some commands that will allow us to start using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command allows us to start all the containers listed in the configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `up` command also allows the `-d` flag to run all processes as a daemon.
    If you want to, you can start only one service from the `docker-compose.yaml`
    file specifying the service name. Let''s say we only want to run the database
    server. The command that allows you to perform this action is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this way, you can specify the service name for the other commands available
    in Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the services are up, you can list all the containers that are running
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to stop all the commands that were started, you will need to use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Docker Compose is comprised of a large set of commands. For a complete reference,
    you can visit [https://docs.docker.com/compose/reference/](https://docs.docker.com/compose/reference/).
  prefs: []
  type: TYPE_NORMAL
- en: Container orchestration with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes introduces a new set of concepts for an environment working with
    Docker containers. We could say that Kubernetes does in production what Docker
    Compose does in development, but there is much more to it than that. Kubernetes
    is an open source system originally created for Google Cloud Engine, but you can
    use it with AWS or any other cloud provider. It is intended for remotely managing
    Docker clusters in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes introduces the following main concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replication controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pod is a new concept introduced by Kubernetes. A pod is comprised of a group
    of related containers that represent a specific application. This is the most
    basic unit within Kubernetes; you don't have to keep thinking about containers
    because pods are what you should focus on here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an application called XYZ that stores its information in a
    database that exposes a REST API that is consumed by its UI, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2b2a568-cd2b-4886-8715-3af7e5e93232.png)'
  prefs: []
  type: TYPE_IMG
- en: The XYZ application with its dependencies
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s obvious that we need three separate services to make this application
    work. If we were dealing with Docker, we would say that we need three different
    containers, but from a Kubernetes perspective, all these three containers represent
    a single pod. This abstraction allows us to manage distributed applications more
    easily. In order to create a pod definition, you should create a `.yaml` file
    describing all the containers that are part of the pod. An example of the XYZ
    application that we mentioned earlier is described in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the file is created, you can execute the pod using the following Kubernetes
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As soon as the number of applications grows within an organization, managing
    all of them tends to be a nightmare. Imagine that you only have fifteen microservices
    and two environments: one for staging and the other for production. In this case,
    identifying all of the running pods would be really hard to do, and you would
    need to remember all of the pod names in order to query their statuses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Labels are intended to make this task easier. You can use them to tag pods
    with label names that are easy to remember and which make sense to you. Since
    a label is a key–value pair, you have the chance to use whatever you want, including `environment:<environment-name>`,
    for instance. Let''s review the following `application-xyz-pod.yaml` example file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in bold shows how the label can be created. Here, you can add as many
    labels as you want. Let''s create this pod with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the pod has been created, you can look for it using the labels with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Replication controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first sight, one may think that we should care about pods, but Kubernetes
    recommends using another abstraction called replication controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will never run one pod instance in production. Instead, you will run many
    of them to offer high availability and to support all the traffic. Replication
    controllers are intended to ensure that a specified number of pods are up and
    running. It''s common to have issues with services running in the wild, and sometimes
    a host crashes, making one or more pods unavailable. Replication controllers are
    constantly monitoring the system for such problems, and when a pod crashes, it
    automatically creates a new replica for this pod, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aae89f3e-0546-4a1d-a0ff-c5ef41832e09.png)'
  prefs: []
  type: TYPE_IMG
- en: Replica services and pods
  prefs: []
  type: TYPE_NORMAL
- en: Replica controllers are also useful for rolling out new application versions.
    You can easily turn off all the pods associated with a specific replica and then
    turn the new one on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the following file, which shows an example of a replication controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The content of this file is pretty similar for pods; the main difference is
    the kind of Docker Service that is specified. In this case, it uses the `ReplicaController`
    value. Later, we will define the desired number of replicas and the selector section
    can be used to specify labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this file, the replica can be created by running the `kubectl create`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify how pods are being created when required. You can delete a pod
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then query the available pods with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s common to have many replica services serving applications in production
    in order to offer a good user experience. However, no matter how many hosts or
    images are involved in this process, we need to offer a unique entry point for
    all this functionality: this is what Kubernetes services are intended for.'
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes service acts as both an endpoint and load balancer for a specific
    application. Since a service is located in front of a group of replicated pods,
    it will distribute the traffic across all the available instances.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, pods and Docker containers are ephemeral, and we can't rely on their
    IP addresses. This is why Kubernetes services are important for continuously providing
    a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a configuration file for a Kubernetes service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `kind` configuration entry in line 2 has a new value—in this case, the
    value is `Service`. The selector indicates the replica container associated with
    this service, and the rest of the configuration parameters are self-explanatory.
    Using this file, you can use the `kubectl create` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, if you don''t want to create a file for a service, you can directly
    expose an existing replica controller using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started reviewing the basic concepts of containers and how
    they are applied to Docker, one of the most popular products used for containerizing
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned how to automate this process and made it part of the build process
    for a Java application, using Gradle as a build tool. The main intention behind
    automation is to be aligned to DevOps principles; we are going to talk about DevOps
    in detail in the following chapter. At the end of this chapter, we looked at other
    Docker tools that automate the provisioning process in development environments,
    and we also learned about Kubernetes and how it can be used for production environments.
    In the next chapter, we will review DevOps and release management concepts.
  prefs: []
  type: TYPE_NORMAL
