- en: TCP/IP Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: IP spoofing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SYN flooding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password sniffer with Python over LAN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The transport layer is the layer that provides data delivery, flow control,
    and error recovery services. The two main transport layer protocols are the TCP
    and the UDP. In this chapter, we will discuss some common attacks in the transport
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: IP spoofing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Scapy, we can simply craft packets and send them. So, if we spoof the source
    address and send it, the network accepts and returns the response to the spoofed
    address. Now, we can create a script to ping a system with a spoofed IP.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to create a script for sending ping requests with spoofed
    IP:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `ip-spoof-ping.py` file and open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we have to import the required modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now declare the variables for the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function to send ICMP packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the following packet and start a send/receive loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Start sending the spoofed packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the script with required permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can try to send a spoofed DNS query. For that, create another function, `dnsQuery()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the following packet, and start sending in a send/receive
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then send the DNS query by calling this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we can monitor the victim's `tcpdump`, we can see the DNS responses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SYN flooding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SYN flooding is a type of DOS attack that makes the service unavailable for
    legitimate users. A SYN flood attack makes use of the TCP protocol's *three-way
    handshake*, where a client sends a TCP SYN packet to start a connection to the
    server, and the server replies with a TCP SYN-ACK packet. Then, in a normal operation,
    the client will send an ACK packet followed by the data. This will keep the connection
    open with a `SYN_RECV` state. But, if the client does not respond with an ACK
    packet, the connection will be in a half-opened state.
  prefs: []
  type: TYPE_NORMAL
- en: 'If multiple attackers or systems opened many such half-opened connections to
    the target server, it could fill the server''s SYN buffer and may stop it receiving
    more SYN packets to cause a **Denial-of-Service** (**DoS**) attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can generate SYN flood packets with Scapy for the testing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to create a script to generate a SYN flooding attack:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `syn-flooding.py` file and open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we have to import the required modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, declare the variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function to create and send SYN flooding packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, random values are used to set TTLs and IDs in the packets. This will help
    to obfuscate the identify in case any intrusion detection system is present in
    the server. Also, the source port is a random value created by the `randshort()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a created sample packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now send the packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this script with required permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Password sniffer with Python over LAN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned how to sniff packets with Scapy in the previous recipes.
    Now we can use Scapy to sniff and extract the content in the packets. This can
    be used to get the details of many protocols. We can try to get the credentials
    from these sniffed packets. We can bind this sniffer with our ARP poisoning attack
    to get the details from other machines on the network.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to write a password sniffer over LAN:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `pass-sniffer.py` file and open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the required modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now declare the variables for the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a method to check the username and password in the sniffed content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we search with the keywords in the data, and extract the username and
    passwords, if present in the payload
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a function to parse the packets sniffed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we will ignore the raw packets without the IP layer. Then we get the
    IP layer and extract the payload and pass it to the `get_login_pass()` method
    to extract the credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start sniffing the packets in the provided interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the script with required permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update this script to extract FTP credentials with little modifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will print the FTP data. We could run a regex match on this to get the
    username and password.
  prefs: []
  type: TYPE_NORMAL
