- en: Building Pseudo-Terminals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce pseudo-terminal applications. Many programs (such
    as SQL or SSH clients) are built as pseudo-terminal because it enables interactive
    use from inside a terminal. These types of application are very important because
    they allow us to have control of an application in an environment where there
    is no graphical interface available, such as when connecting via **Secure Shell**
    (**SSH**) to a server. This chapter will guide you through the creation of some applications of
    this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Terminals and pseudo-terminals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic pseudo-terminals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced pseudo-terminals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, you can refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pseudo-terminals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pseudo-terminals, or pseudo teletypes, are applications that run under a Terminal
    or teletype and emulate its behavior. It's a very convenient way of creating interactive
    software that is capable of running inside a Terminal without any graphical interface.
    This is because it uses the Terminal itself to emulate one.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with teletypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Teletype** (**TTY**) or teleprinter is the name for typewriters with an electromechanical
    system that was controlled through a serial port. It was connected to a computer
    that was capable of sending information to the device to print it. The data was
    made by a sequence of finite symbols such as ASCII characters, with a fixed font. These
    devices acted as user interfaces for early computers, so they were—in a sense—precursors
    to the modern screens.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When screens to replaced printers as output devices, their content was organized
    in a similar fashion: a two dimensional matrix of characters. In their early stages
    they were called glass TTY, and the character display was still part of the display
    itself, controlled by its own logic circuits. With the arrival of the first video
    display cards, computers were capable of having an interface that was not hardware-dependent.'
  prefs: []
  type: TYPE_NORMAL
- en: Text-only consoles used as a main interface for operating systems inherit their
    name from TTY and are referred to as consoles. Even if the OS runs a graphical
    environment like on a modern OS, a user can always access a certain number of
    virtual consoles that work as a **Command-Line Interface** (**CLI**), often referred
    to as a shell.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo teletypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many applications are designed to work inside a shell, but some of them are
    mimicking the shell''s behavior. Graphical interfaces have a Terminal emulator
    that is designed for executing shells. These types of applications are called
    **pseudo-teletypes** (**PTY**). In order to be considered a PTY, an application
    needs to be capable of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Accepting input from the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending input to the console and receiving the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing this output to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some examples already in the available Linux utilities, **screen** being
    the most notable. It is a pseudo-terminal application that allows the user to
    use multiple shells and control them. It can open and close new shells, and switch
    between all opened shells. It allows the user to name a session, so that, if it's
    killed for any unexpected reason, the user can resume the session.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic PTY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start with a simple version of a pseudo-terminal by creating an input
    manager, then by creating a command selector, and finally by creating the command
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Input management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard input can be used to receive user commands. We can start by using
    a buffered input to read lines and print them. In order to read a line, there
    is a useful command, `bufio.Scanner`, that already provides a line reader. The
    code will look similar to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this code has no exit point, we can start by creating the first command, `exit`,
    that will terminate the shell execution. We can do a small change in the code
    to make this work, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now the application has an exit point other than the `kill` command. For now,
    it does not implement any command, besides the `exit` one, and all it does is
    print back whatever you type.
  prefs: []
  type: TYPE_NORMAL
- en: Selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to be able to interpret the commands correctly, the message needs
    to be split into arguments. This is the same logic that the operating system applies
    to argument passed to a process. The `strings.Split` function does the trick,
    by specifying a space as a second argument and breaking the string into words,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s possible to execute any sort of check on `cmd`, such as the following
    `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This allows the user to add a new command by defining a function and adding
    a new `case` to the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Command execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that everything is set, it only remains to define what the various commands
    will actually do. We can define the type of the function that executes a command
    and how the switch behaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value tells the application whether it needs to terminate or not
    and allows us to define our `exit` function easily, without it being a special
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We could implement any type of command now, depending on the scope of our application.
    Let''s create a `shuffle` command, which will print the arguments in a shuffled
    order with the help of the `math`/`rand` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We could interact with the filesystem and files by creating a print command
    that will show in the output of the contents of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Some refactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The current version of the pseudo-terminal application could be improved with
    a little refactoring. We could start by defining a command as a custom type, with
    a couple of methods that describe its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the information about each command can be self-contained in a structure. We
    can also start defining commands that depend on other commands, such as a help
    command. If we have a slice or a map of commands defined somewhere in the `var
    cmds []cmd` package, the `help` command will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The part of the main loop that selects the correct command will be slightly
    different; it will need to find the match in the slice and execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that there is a `help` command that shows the list of available commands,
    we can advocate using it each time the user specifies a command that does not
    exist—as we are currently doing when checking whether the index has changed from
    its default value, `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the PTY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to create a basic pseudo-terminal, we will see how
    to improve it with some additional features.
  prefs: []
  type: TYPE_NORMAL
- en: Multiline input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing that can be improved is the relationship between arguments
    and spacing, by adding support for quoted strings. This can be done with `bufio.Scanner` with
    a custom split function that behaves like `bufio.ScanWords` apart from the fact
    that it''s aware of quotes. The following code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The function has a first block that skips spaces and finds the first non-space
    character; if that character is a quote, it is skipped. Then, it looks for the
    first character that terminates the argument, which is a space for normal arguments,
    and the respective quote for the other arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the end of file is reached while in a quoted context, the partial string
    is returned; otherwise, the quote is not skipped and more data is requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at: [https://play.golang.org/p/CodJjcpzlLx](https://play.golang.org/p/CodJjcpzlLx).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use this as our line for parsing the arguments, while using the helper
    structure, `argsScanner`, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This custom slice will allow us to receive lines with quotes and new lines
    between quotes by changing how the loop works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Providing color support to the pseudo-terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pseudo-terminal can be improved by providing colored output. We have already
    seen that, in Unix, there are escape sequences that can change the background
    and foreground color. Let''s start by defining a custom type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This new type can be used to enhance commands with colored output. For instance,
    let''s take the `shuffle` command  and use alternate colors to distinguish between strings,
    now that we support arguments with spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Suggesting commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the specified command does not exist, we can suggest some similar commands.
    In order to do so, we can use the Levenshtein distance formula, which measures
    the similarity between strings by counting deletions, insertions, and substitutions
    needed to go from one string to the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will use the `agnivade/levenshtein` package, which
    will be obtained through the `go get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a new function to call when there is no match with existing
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Extensible commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The current limitation of our pseudo-terminal is its extensibility. If a new
    command needs to be added, it needs to be added directly into the main package.
    We can think of a way of separating the commands from the main package and allowing
    other users to extend the functionality with their commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is creating an exported command. Let''s use an interface to
    define a command, so that the user can implement their own:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can specify a list of commands and a function for other packages to
    add other commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can provide a base implementation of the command, to execute simple functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can provide a function that matches a command to the name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the logic from the previous example to make this function return
    the suggestion command, which will be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can already register a couple of commands in the `exit` and `help` packages.
    Only `help` can be defined here, because the list of commands is private:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach will allow a user to use the `commandBase` struct to create a
    simple command, or to embed it or use a custom struct if their command requires
    it (like a command with a state):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the `MyCmd` struct and the `MyImpl` struct is that one
    can be used as decorator for another command, while the second is a different
    implementation so it can't interact with another command.
  prefs: []
  type: TYPE_NORMAL
- en: Commands with status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have created commands that don't have an internal state. But some
    commands can keep an internal state and change its behavior accordingly. The state
    could be limited to the session itself or it could be shared across multiple sessions.
    The more obvious example is the command history in the Terminal, where all commands
    executed are stored and retained between sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Volatile status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest thing to implement is a status that is not persistent and gets lost
    when the application exits. All we need to do is create a custom data structure
    that hosts the status and satisfies the command interface. The methods will belong
    to the pointer to the type, as otherwise they will not be able to modify the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will create a very basic memory storage that works
    as a stack (first in, last out) with arguments. Let''s start with the push and
    pop functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The strings stored in the stack represent the state of the command. Now, we
    need to implement the methods of the command interface—we can start with the easiest
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to decide how it works internally. There will be two sub-commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`push`, followed by one or more arguments, will push to the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop` will take the topmost element of the stack and it will not need any argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define a helper method, `isValid`, that checks whether the arguments
    are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can implement the command execution method that will use the validity
    check. If this is passed, it will execute the selected command or show a help
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Persistent status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to persist the status between sessions, and this requires
    some action to be executed when the application starts and another one to be executed
    when the application ends. These new behaviors could be integrated with some changes
    on the command interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Startup()` method is responsible for the status and loading it when the
    application starts, and the `Shutdown()` method needs to save the current status
    to the disk before `exit`. We can update the `Base` structure with these methods;
    however, this will not do anything, because there''s no status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The command list is not exported; it is the unexported variable, `commands`.
    We can add two functions that will interact with such a list, and make sure we
    execute these methods, `Startup` and `Shutdown`, on all available commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is using these functions within the main application before
    starting the main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Upgrading the Stack command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want the command we defined before, `Stack`, to be able to save its state
    between sessions. The simplest solution is to save the contents of the stack as
    a text file, with one element per line. We can make this file unique for each
    user, using the OS/user package to place it in the user `home` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start writing; we will create and truncate the file (setting its size
    to `0` using the `TRUNC` flag) and write the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The method used during the shutdown will read the file line by line and will
    add the elements to the stack. We can use `bufio.Scanner`, as we saw in a previous
    chapter, to do this easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through some terminology, in order to understand why
    modern Terminal applications exist and how they evolved.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we focused on how to implement a basic pseudo-terminal. The first step
    was to create a loop that handled input management, then it was necessary to create
    a command selector and finally an executor. The selector could choose between
    a series of functions defined in the package, and we created a special command
    to exit the application. With some refactoring, we went from functions to structs
    containing both the name and action.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to improve the application in various ways. First, we created a support
    for multiline input (using a custom split function for a scanner) that supported
    quoted strings, with new lines. Then, we created some tools to add colored output
    to our functions and used them in one of the commands previously defined. We also
    used Levenshtein distance to suggest similar commands when the user specifies
    a non-existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we separated commands from the main application and created a way of
    registering new commands from the outside. We used an interface because this allows
    better extension and customization, together with a basic implementation of the
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start talking about process properties and child
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a Terminal, and what is a pseudo-terminal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should a pseudo-terminal be able to do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Go tools did we use in order to emulate a Terminal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can my application get instructions from standard input?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of using interfaces for commands?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the Levenshtein distance? Why can it be useful in pseudo-terminals?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
