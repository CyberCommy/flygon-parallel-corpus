- en: Configuration Management with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already covered the two most crucial phases of the Continuous Delivery
    process: the commit phase and the automated acceptance testing. In this chapter,
    we will focus on the configuration management, which connects the virtual containerized
    environment to the real server infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the concept of configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the most popular configuration management tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing Ansible requirements and the installation process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible with ad hoc commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the power of Ansible automation with playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining Ansible roles and Ansible Galaxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a use case of the deployment process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible together with Docker and Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configuration management is a process of controlling configuration changes
    in a way that the system maintains integrity over time. Even though the term did
    not originate in the IT industry, currently it is broadly used to refer to the
    software and the hardware. In this context, it concerns the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application configuration**: This involves software properties that decide
    how the system works, which are usually expressed in the form of flags or properties
    files passed to the application, for example, the database address, the maximum
    chunk size for file processing, or the logging level. They can be applied during
    different development phases: build, package, deploy, or run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure configuration**: This involves server infrastructure and environment
    configuration, which takes care of the deployment process. It defines what dependencies
    should be installed on each server and specifies the way applications are orchestrated
    (which application is run on which server and in how many instances).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an example, we can think of the calculator web service, which uses the Redis
    server. Let's look at the diagram presenting how the configuration management
    tool works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/886430b5-6e25-4fba-925d-5e18c53eea0d.png)'
  prefs: []
  type: TYPE_IMG
- en: The configuration management tool reads the configuration file and prepares
    the environment respectively (installs dependent tools and libraries, deploys
    the applications to multiple instances).
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the **Infrastructure Configuration** specifies that
    the **Calculator** service should be deployed in two instances on **Server 1**
    and **Server 2** and that the **Redis** service should be installed on **Server
    3**. **Calculator Application Configuration** specifies the port and the address
    of the **Redis** server so that the services can communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration can differ depending on the type of the environment (QA, staging,
    production), for example, server addresses can be different.
  prefs: []
  type: TYPE_NORMAL
- en: There are many approaches to configuration management, but before we look into
    concrete solutions, let's comment on what characteristics a good configuration
    management tool should have.
  prefs: []
  type: TYPE_NORMAL
- en: Traits of good configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What should the modern configuration management solution look like? Let''s
    walk through the most important factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automation**: Each environment should be automatically reproducible, including
    the operating system, the network configuration, the software installed, and the
    applications deployed. In such an approach, fixing production issues means nothing
    more than an automatic rebuild of the environment. What''s more, that simplifies
    server replications and ensures that the staging and production environments are
    exactly the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control**: Every change in the configuration should be tracked, so
    that we know who made it, why, and when. Usually, that means keeping the configuration
    in the source code repository either together with the code or in a separate place.
    The former solution is recommended because configuration properties have a different
    lifecycle than the application itself. Version control also helps with fixing
    production issues—the configuration can always be rolled back to the previous
    version and the environment automatically rebuilt. The only exception to the version
    control-based solution is storing credentials and other sensitive information-these
    should be never checked in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incremental changes**: Applying a change in the configuration should not
    require rebuilding the whole environment. On the contrary, a small change in the
    configuration should change only the related part of the infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server provisioning**: Thanks to automation, adding a new server should be
    as quick as adding its address to the configuration (and executing one command).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: The access to both, the configuration management tool and the
    machines under its control, should be well secured. When using the SSH protocol
    for communication, the access to the keys or credentials needs to be well protected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Every member of the team should be able to read the configuration,
    make a change, and apply it to the environment. The properties themselves should
    also be kept as simple as possible and the ones that are not subjected to change
    are better off kept hardcoded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to keep these points in mind while creating the configuration
    and, even before, while choosing the right configuration management tool.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of configuration management tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most popular configuration management tools are Ansible, Puppet, and Chef.
    Each of them is a good choice; they are all open source products with free basic
    versions and paid enterprise editions. The most important differences between
    them are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration Language**: Chef uses Ruby, Puppet uses its own DSL (based
    on Ruby), and Ansible uses YAML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agent-based**: Puppet and Chef use agents for communication, which means
    that each managed server needs to have a special tool installed. Ansible, on the
    contrary, is agentless and uses the standard SSH protocol for communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agentless feature is a significant advantage because it implies no need
    to install anything on servers. What's more, Ansible is quickly trending upwards,
    which is why it was chosen for this book. Nevertheless, other tools can also be
    successfully used for the Continuous Delivery process.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is an open source, agentless automation engine for software provisioning,
    configuration management, and application deployment. Its first release was in
    2012 and its basic version is free for both, personal and commercial use. The
    enterprise version, called Ansible Tower, provides GUI management and dashboards,
    REST API, role-based access control, and some more features.
  prefs: []
  type: TYPE_NORMAL
- en: We present the installation process and a description of how it can be used
    separately as well as together with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible server requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible uses the SSH protocol for communication and has no special requirements
    regarding the machine it manages. There is also no central master server, so it's
    enough to install the Ansible client tool anywhere and we can already use it to
    manage the whole infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The only requirement for the machines being managed is to have the Python tool
    and, obviously, the SSH server installed. These tools are, however, almost always
    available by default on any server.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The installation instructions differ depending on the operating system. In
    the case of Ubuntu, it''s enough to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can find the installation guides for all operating systems on the official
    Ansible page at: [http://docs.ansible.com/ansible/intro_installation.html](http://docs.ansible.com/ansible/intro_installation.html).
  prefs: []
  type: TYPE_NORMAL
- en: After the installation process is completed, we can execute the Ansible command
    to check that everything was installed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Docker-based Ansible client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s also possible to use Ansible as a Docker container. We can do it by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Ansible Docker image is no longer officially supported, so the only solution
    is to use the community-driven version. You can read more on its usage on the
    Docker Hub page.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to use Ansible, first we need to define the inventory, which represents
    the available resources. Then, we will be able to either execute a single command
    or define a set of tasks using the Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Creating inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An inventory is a list of all the servers that are managed by Ansible. Each
    server requires nothing more than the Python interpreter and the SSH server installed.
    By default, Ansible assumes that the SSH keys are used for authentication; however,
    it is also possible to use the username and the password by adding the `--ask-pass` option
    to the Ansible commands.
  prefs: []
  type: TYPE_NORMAL
- en: SSH keys can be generated with the `ssh-keygen` tool and are usually stored
    in the `~/.ssh` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inventory is defined in the `/etc/ansible/hosts` file and it has the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The inventory syntax also accepts ranges of servers, for example, `www[01-22].company.com`.
    The SSH port should also be specified if it's anything other than 22 (the default
    one). You can read more on the official Ansible page at: [http://docs.ansible.com/ansible/intro_inventory.html](http://docs.ansible.com/ansible/intro_inventory.html).
  prefs: []
  type: TYPE_NORMAL
- en: There may be 0 or many groups in the inventory file. As an example, let's define
    two machines in one group of servers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create the configuration with server aliases and specify the remote
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file defines a group called `webservers`, which consists of two
    servers. The Ansible client will log in as the user `admin` to both of them. When
    we have the inventory created, let's discover how we can use it to execute the
    same command on many servers.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible offers a possibility to dynamically pull the inventory from the cloud
    provider (for example, Amazon EC2/Eucalyptus), LDAP, or Cobbler. Read more about
    dynamic inventories at: [http://docs.ansible.com/ansible/intro_dynamic_inventory.html](http://docs.ansible.com/ansible/intro_dynamic_inventory.html).
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest command we can run is a ping on all servers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We used the `-m <module_name>` option, which allows specifying the module that
    should be executed on the remote hosts. The result is successful, which means
    that the servers are reachable and the authentication is configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'A full list of modules available in Ansible can be found on the page: [http://docs.ansible.com/ansible/modules.htm](http://docs.ansible.com/ansible/modules.htm)l.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used `all`, so that all servers would be addressed, but we could
    also call them by the group name `webservers` or by the single host alias. As
    a second example, let's execute a shell command only on one of the servers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `-a <arguments>` option specifies the arguments that are passed to the Ansible
    module. In this case, we didn't specify the module, so the arguments are executed
    as a shell Unix command. The result was successful and `hello` was printed.
  prefs: []
  type: TYPE_NORMAL
- en: If the `ansible` command is connecting to the server for the first time (or
    the server is reinstalled), then we are prompted with the key confirmation message
    (SSH message when the host is not present in `known_hosts`). Since it may interrupt
    an automated script, we can disable the prompt message by uncommenting `host_key_checking
    = False` in the `/etc/ansible/ansible.cfg` file or by setting the environment
    variable `ANSIBLE_HOST_KEY_CHECKING=False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplistic form, the Ansible ad hoc command syntax looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of ad hoc commands is to do something quickly when it is not necessary
    to repeat it. For example, we may want to check if a server is alive or to power
    off all the machines for the Christmas break. This mechanism can be seen as a
    command execution on a group of machines with the additional syntax simplification
    provided by the modules. The real power of Ansible automation, however, lies in
    playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Ansible playbook is a configuration file, which describes how servers should
    be configured. It provides a way to define a sequence of tasks that should be
    performed on each of the machines. A playbook is expressed in the YAML configuration
    language, which makes it human-readable and easy to understand. Let's start with
    a sample playbook and then see how we can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A playbook is composed of one or many plays. Each play contains a host group
    name, tasks to perform, and configuration details (for example, remote username
    or access rights). An example playbook might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration contains one play which:'
  prefs: []
  type: TYPE_NORMAL
- en: Is executed only on the host `web1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gains root access using the `sudo` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Executes two tasks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing the latest version of `apache2`: The Ansible module `apt` (called
    with two parameters `name=apache2` and `state=latest`) checks whether the `apache2` package
    is installed on the server, and if not, then it uses the `apt-get` tool to install
    `apache2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running the `apache2` service: The Ansible module `service` (called with three
    parameters `name=apache2`, `state=started`, and `enabled=yes`) checks whether
    the Unix service `apache2` is started, and if not, it uses the `service` command
    to start it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While addressing the hosts, you can also use patterns, for example, we could
    use `web*` to address both `web1` and `web2`. You can read more about Ansible
    patterns at: [http://docs.ansible.com/ansible/intro_patterns.html](http://docs.ansible.com/ansible/intro_patterns.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note that each task has a human-readable name, which is used in the console
    output such that `apt` and `service` are Ansible modules and `name=apache2`, `state=latest`,
    and `state=started` are module arguments. We have already seen Ansible modules
    and arguments while using ad hoc commands. In the preceding playbook, we defined
    only one play, but there can be many of them and each can be related to different
    groups of hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could define two groups of servers in the inventory: `database` and
    `webservers`. Then, in the playbook, we could specify tasks that should be executed
    on all database-hosting machines and some different tasks that should be executed
    on all the web servers. By using one command, we could set up the whole environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Executing the playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When playbook.yml is defined, we can execute it using the `ansible-playbook` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the server requires entering the password for the `sudo` command, then we
    need to add the `--ask-sudo-pass` option to the `ansible-playbook` command. It's
    also possible to pass the `sudo` password (if required) by setting the extra variable `-e
    ansible_become_pass=<sudo_password>`.
  prefs: []
  type: TYPE_NORMAL
- en: The playbook configuration was executed, and, therefore, the `apache2` tool
    was installed and started. Note that if the task changed something on the server,
    it is marked as `changed`. On the contrary, if there was no change, it's marked
    as `ok`.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to run tasks in parallel using the `-f <num_of_threads>` option.
  prefs: []
  type: TYPE_NORMAL
- en: Playbook's idempotency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can execute the command again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output is slightly different. This time the command didn't change
    anything on the server. That is because each Ansible module is designed to be
    idempotent. In other words, executing the same module many times in a sequence
    should have the same effect as executing it only once.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to achieve idempotency is to always first check if the task
    hasn't been executed yet, and execute it only if it hasn't. Idempotency is a powerful
    feature and we should always write our Ansible tasks this way.
  prefs: []
  type: TYPE_NORMAL
- en: If all tasks are idempotent, then we can execute them as many times as we want.
    In that context, we can think of the playbook as a description of the desired
    state of remote machines. Then, the `ansible-playbook` command takes care of bringing
    the machine (or group of machines) into that state.
  prefs: []
  type: TYPE_NORMAL
- en: Handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some operations should be executed only if some other task changed. For example,
    imagine that you copy the configuration file to the remote machine and the Apache
    server should be restarted only if the configuration file has changed. How to
    approach such a case?
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine that you copy the configuration file to the remote machine
    and the Apache server should be restarted only if the configuration file has changed.
    How to approach such a case?
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible provides an event-oriented mechanism to notify about the changes. In
    order to use it, we need to know two keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`handlers`: This specifies the tasks executed when notified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notify`: This specifies the handlers that should be executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at an example of how we could copy the configuration to the server
    and restart Apache only if the configuration has changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can create the `foo.conf` file and run the `ansible-playbook` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Handlers are executed always at the end of the play and only once, even if triggered
    by multiple tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible copied the file and restarted the Apache server. It's important to understand
    that if we run the command again, nothing will happen. However, if we change the
    content of the `foo.conf` file and then run the `ansible-playbook` command, the
    file will be copied again (and the Apache server will be restarted).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We used the `copy` module, which is smart enough to detect if the file has changed,
    and then in such a case, make a change on the server.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a publish-subscribe mechanism in Ansible. Using it means assigning
    a topic to many handlers. Then, a task notifies the topic to execute all related
    handlers. You can read more about it at: [http://docs.ansible.com/ansible/playbooks_intro.html](http://docs.ansible.com/ansible/playbooks_intro.html).
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the Ansible automation makes things identical and repeatable for multiple
    hosts, it is inevitable that servers may require some differences. For example,
    think of the application port number. It can be different depending on the machine.
    Luckily, Ansible provides variables, which is a good mechanism to deal with server
    differences. Let's create a new playbook and define a variable.
  prefs: []
  type: TYPE_NORMAL
- en: For example, think of the application port number. It can be different depending
    on the machine. Luckily, Ansible provides variables, which is a good mechanism
    to deal with server differences. Let's create a new playbook and define a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The configuration defines the `http_port` variable with the value `8080`. Now,
    we can use it using the Jinja2 syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Jinja2 language allows doing way more than just getting a variable. We can
    use it to create conditions, loops, and many more. You can find more details on
    the Jinja page at: [http://jinja.pocoo.org/](http://jinja.pocoo.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The `debug` module prints the message while executing. If we run the `ansible-playbook` command,
    we can see the variable usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Variables can also be defined in the inventory filing using the `[group_name:vars]` section.
    You can read more about it at: [http://docs.ansible.com/ansible/intro_inventory.html#host-variables](http://docs.ansible.com/ansible/intro_inventory.html#host-variables).
  prefs: []
  type: TYPE_NORMAL
- en: Apart from user-defined variables, there are also predefined automatic variables.
    For example, the `hostvars` variable stores a map with the information regarding
    all hosts from the inventory. Using the Jinja2 syntax, we could iterate and print
    the IP addresses of all hosts in the inventory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can execute the `ansible-playbook` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that with the use of the Jinja2 language, we can specify the flow control
    operations inside the Ansible playbook file.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to the Jinja2 templating language, for the conditionals and
    loops, is to use the Ansible built-in keywords: `when` and `with_items`. You can
    read more about it at: [http://docs.ansible.com/ansible/playbooks_conditionals.html](http://docs.ansible.com/ansible/playbooks_conditionals.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can install any tool on the remote server using Ansible playbooks. Imagine
    we would like to have a server with MySQL. We could easily prepare a playbook
    similar to the one with the `apache2` package. However, if you think about it,
    a server with MySQL is quite a common case and, for sure, someone has already
    prepared a playbook for it, so maybe we could just reuse it? Here comes Ansible
    roles and Ansible Galaxy.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Ansible role is a well-structured playbook part prepared to be included
    in the playbooks. Roles are separate units that always have the following directory
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about roles and what each directory means on the official
    Ansible page at: [http://docs.ansible.com/ansible/playbooks_roles.html](http://docs.ansible.com/ansible/playbooks_roles.html).
  prefs: []
  type: TYPE_NORMAL
- en: In each of the directories, we can define the `main.yml` file, which contains
    the playbook parts that can be included in the `playbook.yml` file. Continuing
    the MySQL case, there is a role defined on GitHub: [https://github.com/geerlingguy/ansible-role-mysql](https://github.com/geerlingguy/ansible-role-mysql).
    This repository contains kind-of task templates that can be used in our playbook.
    Let's look at a part of the `tasks/main.yml` file, which installs the `mysql` package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is only one of the tasks defined in the `tasks/main.yml` file. Others are
    responsible for the MySQL configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The `with_items` keyword is used to create a loop over all the items. The `when` keyword
    means that the task is executed only under a certain condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use this role, then in order to install the MySQL on the server, it''s
    enough to create the following playbook.yml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Such configuration installs the MySQL database to all servers using the `geerlingguy.mysql` role.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Galaxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible Galaxy is to Ansible what Docker Hub is for Docker-it stores common
    roles, so that they can be reused by others. You can browse the available roles
    on the Ansible Galaxy page at: [https://galaxy.ansible.com/](https://galaxy.ansible.com/).
  prefs: []
  type: TYPE_NORMAL
- en: To install the role from Ansible Galaxy, we can use the `ansible-galaxy` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This command automatically downloads the role. In the case of the MySQL example,
    we could download the role by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The command downloads the `mysql` role, which can be later used in the playbook
    file.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to install a lot of roles at the same time, you can define them
    in the `requirements.yml` file and use `ansible-galaxy install -r requirements.yml`.
    Read more about that approach and about Ansible Galaxy at: [http://docs.ansible.com/ansible/galaxy.html](http://docs.ansible.com/ansible/galaxy.html).
  prefs: []
  type: TYPE_NORMAL
- en: Deployment with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered the most fundamental features of Ansible. Let's now forget,
    just for a little while, about Docker and configure a complete deployment step
    using Ansible. We will run the calculator service on one server and the Redis
    service on the second server.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can specify a play in the new playbook. Let''s create the `playbook.yml` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The configuration is executed on one server `web1`. It installs the `redis-server` package,
    copies the Redis configuration, and starts Redis. Note that each time we change
    the content of the `redis.conf` file and re-run the `ansible-playbook` command,
    the configuration is updated on the server and the Redis service is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create the `redis.conf` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This configuration runs Redis as a daemon and exposes it to all network interfaces
    under port number 6379\. Let's now define the second play, which sets up the calculator
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We prepare the calculator web service in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the project to be executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Redis host address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add calculator deployment to the playbook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring a project to be executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to make the build JAR executable, so that it can be easily run
    on the server as a Unix service. In order to do it, it''s enough to add the following
    code to the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Changing the Redis host address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we've hardcoded the Redis host address as `redis`, so now we should
    change it in the `src/main/java/com/leszko/calculator/CacheConfig.java` file to
    `192.168.0.241`.
  prefs: []
  type: TYPE_NORMAL
- en: In real-life projects, the application properties are usually kept in the properties
    file. For example, for the Spring Boot framework, it's a file called `application.properties` or
    `application.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding calculator deployment to the playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we can add the deployment configuration as a new play in the `playbook.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s walk through the steps we defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prepare the environment**: This task ensures that the Java Runtime Environment
    is installed. Basically, it prepares the server environment, so that the calculator
    application would have all the necessary dependencies. With more complex applications,
    the list of dependent tools and libraries can be way longer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure application as a service**: We would like to have the calculator
    application running as a Unix service, so that it will be manageable in the standard
    way. In this case, it''s enough to create a link to our application in the `/etc/init.d/` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy the new version**: The new version of the application is copied into
    the server. Note that if the source file didn''t change, then the file won''t
    be copied and therefore the service won''t be restarted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restart the service**: As a handler, every time the new version of the application
    is copied, the service is restarted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, we can execute the playbook using the `ansible-playbook` command.
    Before that, we need to build the calculator project with Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After the successful deployment, the service should be available and we can
    check it's working at `http://192.168.0.242:8080/sum?a=1&b=2`. As expected, it
    should return `3` as the output.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have configured the whole environment by executing one command.
    What's more, if we need to scale the service, then it's enough to add a new server
    to the inventory and re-run the `ansible-playbook` command.
  prefs: []
  type: TYPE_NORMAL
- en: We have showed how to use Ansible for environment configuration and application
    deployment. The next step is to use Ansible together with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have noticed, Ansible and Docker address similar software deployment
    issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Environment configuration**: Both Ansible and Docker provide a way to configure
    the environment; however, they use different means. While Ansible uses scripts
    (encapsulated inside the Ansible modules), Docker encapsulates the whole environment
    inside a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**: Ansible provides a way to deploy different services on the
    same or different hosts and let them be deployed together. Docker Compose has
    a similar functionality, which allows running multiple containers at the same
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Ansible helps to scale services providing the inventory and
    host groups. Docker Compose has a similar functionality to automatically increase
    or decrease the number of running containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation with configuration files**: Both Docker and Ansible store the
    whole environment configuration and service dependencies in files (stored in the
    source control repository). For Ansible, this file is called `playbook.yml`. In
    the case of Docker, we have Dockerfile for the environment and docker-compose.yml
    for the dependencies and scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Both tools are very simple to use and provide a way to set
    up the whole running environment with a configuration file and just one command
    execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we compare the tools, then Docker does a little more, since it provides the
    isolation, portability, and some kind of security. We could even imagine using
    Docker without any other configuration management tool. Then, why do we need Ansible
    at all?
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible may seem redundant; however, it brings additional benefits to the delivery
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker environment**: The Docker host itself has to be configured and managed.
    Every container is ultimately running on Linux machines, which needs kernel patching,
    Docker engine updates, network configuration, and so on. What''s more, there may
    be different server machines with different Linux distributions and the responsibility
    of Ansible is to make sure the Docker engine is up and running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-Dockerized applications**: Not everything is run inside a container.
    If part of the infrastructure is containerized and part is deployed in the standard
    way or in the cloud, then Ansible can manage it all with the playbook configuration
    file. There may be different reasons for not running an application as a container,
    for example performance, security, specific hardware requirements, Windows-based
    software, or working with the legacy software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inventory**: Ansible offers a very friendly way to manage the physical infrastructure
    using inventories, which store the information about all servers. It can also
    split the physical infrastructure into different environments: production, testing,
    development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GUI**: Ansible offers a (commercial) GUI manager called Ansible Tower, which
    aims to improve the infrastructure management for the enterprises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improve testing process**: Ansible can help with the integration and acceptance
    testing and can encapsulate the testing scripts in a similar way that Docker Compose
    does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can look at Ansible as the tool that takes care of the infrastructure, while
    Docker as a tool that takes care of the environment configuration. The overview
    is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a8d7f1ee-0867-4b62-a53b-0ae730381cd1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Ansible manages the infrastructure: Docker servers, Docker registry, servers
    without Docker, and cloud providers. It also takes care of the physical location
    of the servers. Using the inventory host groups, it can link the web services
    to the databases that are close to their geographic location.'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Docker playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible integrates smoothly with Docker because it provides a set of Docker-dedicated
    modules. If we create an Ansible playbook for Docker-based deployment, then the
    first tasks need to make sure that the Docker engine is installed on every machine.
    Then, it should run a container using Docker or a set of interacting containers
    using Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few very useful Docker-related modules provided by Ansible: `docker_image`
    (build/manage images), `docker_container` (run containers), `docker_image_facts`
    (inspect images), `docker_login` (log into Docker registry), `docker_network`
    (manage Docker networks), and `docker_service` (manage Docker Compose).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can install the Docker engine using the following task in the Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The playbook looks slightly different for each operating system. The one presented
    here is for Ubuntu 16.04.
  prefs: []
  type: TYPE_NORMAL
- en: This configuration installs the Docker engine, enables the `admin` user to work
    with Docker, and installs Docker Compose with dependent tools.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you may also use the `docker_ubuntu` role as described here: [https://www.ansible.com/2014/02/12/installing-and-building-docker-with-ansible](https://www.ansible.com/2014/02/12/installing-and-building-docker-with-ansible).
  prefs: []
  type: TYPE_NORMAL
- en: When Docker is installed, we can add a task, which will run a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Running Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running Docker containers is done with the use of the `docker_container` module
    and it looks very similar to what we presented for the Docker Compose configuration.
    Let's add it to the `playbook.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about all of the options of the `docker_container` module
    on the official Ansible page at: [https://docs.ansible.com/ansible/docker_container_module.html](https://docs.ansible.com/ansible/docker_container_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: We can now execute the playbook to observe that Docker has been installed and
    the Redis container started. Note that it's a very convenient way of using Docker,
    since we don't need to manually install Docker engine on every machine.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible playbook is very similar to the Docker Compose configuration. They
    even both share the same YAML file format. What's more, it is possible to use
    `docker-compose.yml` directly from Ansible. We will show how to do it, but first,
    let's define the `docker-compose.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It is almost the same as what we defined in the previous chapter. This time
    we get the calculator image directly from the Docker Hub registry, and do not
    build it in `docker-compose.yml`, since we want to build the image once, push
    it to the registry, and then reuse it in every deployment step (on every environment),
    to make sure the same image is deployed on each Docker host machine. When we have
    `docker-compose.yml`, we are ready to add new tasks to `playbook.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We first copy the docker-compose.yml file into the server and then execute
    `docker-compose`. As a result, Ansible creates two containers: calculator and
    redis.'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the most important features of Ansible. In the next sections, we
    write a little bit about the infrastructure and application versioning. At the
    end of this chapter, we will present how to use Ansible in order to complete the
    Continuous Delivery pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered the fundamentals of Ansible and the way to
    use it together with Docker. As an exercise, we propose the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the server infrastructure and use Ansible to manage it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a physical machine or run a VirtualBox machine to emulate the remote
    server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure SSH access to the remote machine (SSH keys)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Python on the remote machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an Ansible inventory with the remote machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the Ansible ad hoc command (with the `ping` module) to check that the infrastructure
    is configured correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Python-based "hello world" web service and deploy it in a remote machine
    using Ansible playbook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service can look exactly the same as described in the exercises for the
    chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a playbook, which deploys the service into the remote machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the `ansible-playbook` command and check whether the service was deployed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have covered the configuration management process and its relation to Docker.
    The key takeaway from the chapter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management is a process of creating and applying the configurations
    of the infrastructure and the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible is one of the best trending configuration management tools. It is agentless
    and therefore requires no special server configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible can be used with ad hoc commands, but the real power lies in Ansible
    playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible playbook is a definition of how the environment should be configured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of Ansible roles is to reuse parts of playbooks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Galaxy is an online service to share Ansible roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible integrates well with Docker and brings additional benefits compared
    to using Docker and Docker Compose alone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will wrap up the Continuous Delivery process and complete
    the final Jenkins pipeline.
  prefs: []
  type: TYPE_NORMAL
