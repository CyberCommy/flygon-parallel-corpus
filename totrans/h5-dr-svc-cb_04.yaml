- en: Chapter 4. Using HTML5 Input Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will take a look at some of the great new element types
    added to HTML5\. Topics covered are:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `text` input field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `textarea`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inputting dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inputting time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telephone input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range input filed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color picker input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using single-choice dropdowns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple-choice select lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting geographical location input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using file inputs on client side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using drag-and-drop file area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are part of everyday web application development. We did lot of re-inventions
    to enable various input features. HTML5 adds few new input types and many different
    attributes and extensions to the existing structure. Most of these new stuff are
    already available in modern browsers and make life easier for all of us. For the
    things that are not there yet, we use a fallback that works on legacy systems.
    There is no good reason why you should not start using at least some of the features
    today.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are various ways to determine support for HTML5 features. Many sites provide
    a list of supported features but some of them worth mentioning are [http://caniuse.com/](http://caniuse.com/)
    and [http://html5please.com/](http://html5please.com/). You can often refer to
    them to get up to date information if you are not interested in adding fallback's.
  prefs: []
  type: TYPE_NORMAL
- en: Using the text input field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will take a look at one of the basic examples of using input data with HTML
    `<input type="text">`. This input type automatically removes line breaks from
    the input values, so it''s intended for single line text usage as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the text input field](img/9282OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the body section of the HTML document, we will create a form where the inputs
    with type `text` will be placed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we add the most basic input type `text`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Following that, we add one where audio input will be enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Also add one with the `placeholder` attribute and one with the `autofocus`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, we add `submit` and close the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `<input name="firstname" type="text" >` element is the most basic HTML
    input element, where on submitting the form, the query parameter will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The next input element has an attribute `x-webkit-speech speech` that is, Chrome
    specific attribute allowing speech input, which means you can insert text using
    your microphone.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this will unlikely become standard since it relies on Google server-side
    processing for speech and as such is far from open web. In order to have widespread
    acceptance open speech providers should available.
  prefs: []
  type: TYPE_NORMAL
- en: For the third input element, we used the `placeholder` attribute that adds a
    beautiful hint inside the input field.
  prefs: []
  type: TYPE_NORMAL
- en: One new attribute added in HTML5 is `autofocus`. It is the Boolean valued attributes
    that allow us to specify what form control should have initial focus once the
    page gets loaded. We used the the single word syntax in our case but `autofocus="true"`
    will do the same trick. An additional thing to note here is that this can be appliqued
    on only one form element since that is the element that will get the initial focus
    and also it cannot be applied to `input` `type="hidden"`, since it does not make
    much sense to do so.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we are using our own fallback method for inserting voice data we can simply
    check if there is support for it in the current one in order to support other
    browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also an event being triggered that we can use for the voice input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The open alternative for speech input that is developed is the **Web Speech
    API**. The main goal of it is to provide developers with a means to have speech
    input and output as text to speech. The API definition does not include implementation
    on where the recognition will be done, meaning server-side or client-side implementations
    are up to the vendor. More on the API on [https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html](https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The incubator working group that took care of the initial requirements and
    specification regarding speech integration in HTML5 can be found on: [http://www.w3.org/2005/Incubator/htmlspeech/](http://www.w3.org/2005/Incubator/htmlspeech/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using textarea
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will take a look at the `textarea` element and create a simple
    form to show some of the attributes that can be used. `textarea` is intended for
    use as a multiple line plain-text editing control.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an example `form` to demonstrate some of the uses of the `textarea`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we add a `texarea` element with the `placeholder` attribute set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add a textarea with the `rows` and `cols` attributes set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add one with `maxlength` set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add one with the `title` attribute set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we add `submit` and close the `form`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first example is a regular `<textarea />` element allowing text with multiple
    lines and line breaks. We can additionally use attributes, such as `rows` and
    `cols` to enable some initial size. This can also be achieved by setting initial
    size via CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Most of the new browsers now have a small dragable right corner for a text area,
    enabling the user to resize it. This resizability for the text area can be disabled
    by setting `max-width` and `max-height` in CSS.
  prefs: []
  type: TYPE_NORMAL
- en: We can also limit the number of characters that can be inserted using the `maxlength`
    attribute, like setting it to maximum of 5 characters in our example `maxlength="5"`.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the attribute `title` that can be used to add hint to the user
    about the input filed.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Attributes such as `title`, `maxlength`, and `placeholder` are not exclusive
    to `textarea`, but they can be used in other elements as well. For example, the
    `title` attribute is one of the global ones in HTML5 and can be added on any element.
    We could have the flowing snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: More on the input attributes and the global element attributes can be found
    at the website [http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#global-attributes](http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#global-attributes).
  prefs: []
  type: TYPE_NORMAL
- en: Inputting dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before HTML5 we were forced into creating custom controls that always had some
    missing features or were not compatible with some browsers. Now, there are separate
    input types for dates, and in this recipe we will see how to use them. They are
    unfortunately still not fully implemented across various user agents, but then
    everyone is slowly catching up.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will simply create a basic HTML document and create a form in the body element:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First in the body section add `form` and inside it a `date input` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly we add an input element for `month` and `week`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end we add a simple `submit` and close the `form`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Depending on your browser''s support you will either get an empty input field
    or a full-fledged date input control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On form submit, the parameters being sent by the form are valid strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The creation and numbering on the dates, weeks, and months is in accordance
    to the ISO 8601 that is widely accepted in most programming languages, or at least
    there is a standardized way of representation and access to the data. There is
    also an option to specify the `min` and `max` attributes that should be valid
    date, month, and week strings accordingly, as well as `step` that will define
    the step of the selection control, and is defaulted to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Inputting time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe we will take a look at how to use time input controls and how
    they are combined with date selections. The general idea is to have the user agent
    render a clock that can be used as input. There are options to include the time
    zone and to have plain time representation and will try them out by creating a
    simple form as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inputting time](img/9282OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the other examples, we create a form containing few input elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we start the form and add the `time` input element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a `datetime-local` input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Also we add a `datetime` input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Finally we add submit and close the form
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On form submission, the values selected are added as query parameters in the
    URL, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `time` parameter here has a value of `00:00:00`, where the `%3A` is the
    `:` character URL encoded.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `2012-11-02T12%3A00` value for `datetime-local` is actually `2012-11-02T12:00`
    giving the date and time in the parameters following the `YYYY-MM-DDThh:mm:ss`
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: As for the `datetime` variable the format of the string is `YYYY-MM-DDThh:mm:ssTZD`,
    where we have the additional information about the time zone.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have a correct context for our input elements, when opened on a browser
    that has good support the control will be optimized.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Telephone input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at the input type for telephone numbers.
    Due to the very different telephone number formats between countries, the phone
    input does not require any specific pattern, if not explicitly specified. If we
    are required to have some specific pattern, we can do various types of validations
    as discussed in detail in [Chapter 6](ch06.html "Chapter 6. Data Validation"),
    *Data Validation*.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of using a text input type is to be more semantically correct,
    and as such to bring about more optimization on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the preceding related recipes, we simply add the `input` element in the
    body of the HTML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you try it out on a first look, it seams like it is a regular `input type="text"`
    element. But this one now is more semantically correct. Now why is this important,
    or why should we care about it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Mobile devices will pick this as a phone number and automatically open the
    numeric keyboard like the Android device displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also `input type="url"`, `input type="search"`, and `input type="email"`
    that give semantic to the elements, allowing mobile devices to pick up the correct
    keyboard. They also can have additional validations and logic about how the data
    can be inserted, allowing more type specific functions. Some of them will be covered
    in the validation-related recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In HTML5 for all input types, it was added an attribute called `inputmode`
    that is derived from the term **Input modalities**. These attributes provides
    hints to the browser on what kind of keyboard should be used. The attributes can
    have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**verbatim**: This value specifies alphanumeric characters that can commonly
    be used with the intention to be non-prose text such as usernames, keywords, or
    passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**latin**: This value specifies Latin input in the user''s input in the user''s
    preferred language with typing helpers like text prediction on mobile devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**latin-name**: This value specifies same rules as `latin` but for names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**latin-prose**: This value specifies the same rules as `latin` but with complete
    typing helpers intended to be used in implementations like email, chat, or comments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**full-width-latin**: This value specifies same as `latin-prose`, but for the
    user''s secondary language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kana**, **katakana**: This value specifies **kana** or **romaji** input,
    typically **hiragana** input, using full-width characters, with support for converting
    to **kanji**. As for **katakana**, it is another form related to this. All of
    these are intended for Japanese input text. More about Japanese writing systems
    can be found on: [http://en.wikipedia.org/wiki/Japanese_writing_system](http://en.wikipedia.org/wiki/Japanese_writing_system).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**numeric**: This value specifies numeric characters input for digits 0-9 including
    the user-selected thousand separator and character for indicating negative numbers.
    The purpose for this is to input numeric codes, such as some street numbers or
    credit cards. If we are sure that we use numbers the input `type="number"` should
    be preferred, since it is more semantically correct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tel**, **email**, **url**: This value can be used giving the same hints as
    we have used for the corresponding input types. We should prefer the input types
    in these values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browsers don't provide support for all of the states and have a fallback mechanism.
    Again here the states mostly makes sense for mobile or special purpose devices.
  prefs: []
  type: TYPE_NORMAL
- en: Range input field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We sometimes want to input a value that is something the user picks from a given
    range of values using a "slider". In order to enable this in HTML5 the `<input
    type="range" >` was added allowing imprecise control for setting the element's
    value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With few simple steps, we will create few range controls that use different
    features of HTML5:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by adding an HTML page using the following part of the `body` text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And in order to show one of the sliders vertically, we can add CSS in the `head`
    tag of HTML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also display the value that is selected using JavaScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `type = "range"` is picked up by the browser and the a slider is created
    where the value for `min` is `0` and value for `max` is `100` having a `step`
    of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to display it vertically, set width and height using CSS. To make
    it work on Chrome, since the change of rendering via size is not yet implemented,
    you can add the following code in CSS, forcing it to be displayed vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to have a small display updated directly by changing the slider,
    we can achieve this with JavaScript, by adding an event listener to the input
    range element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also an option to connect the `input type="range"` element with a
    `datalist` that will create ticks with the predefined options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/9282OT_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The options in the `datalist` element can have invalid values or values outside
    the range that is specified with the attributes min and max, and as such will
    be ignored. On the other hand, the values that are valid will add a marker on
    the slider where they are selectable.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is also an optional `label` attribute to the `datalist` that can be added,
    and should render the text next to the markers displayed. This feature with the
    display of labels is not supported by the browsers, but is part of the specification.
  prefs: []
  type: TYPE_NORMAL
- en: There 's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, neither Firefox nor IE had full support for the `type="range"`
    element, and as a workaround, we can use JavaScript to add basic support. There
    is already a utility script allowing a workaround available on [http://frankyan.com/labs/html5slider/](http://frankyan.com/labs/html5slider/)
    and source is also available on [https://github.com/html5-ds-book/html5slider](http://
    https://github.com/html5-ds-book/html5slider) slider. In order to enable it, you
    just include the `html5slider.js`, and the magic happens.
  prefs: []
  type: TYPE_NORMAL
- en: Color picker input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As one of the new input types, we have the the `input type="color"` element,
    which lets you pick a color and the chosen color will have its simple colors representation
    that we are used to. The color representation has a more popular name of hexadecimal
    color representation, and in this recipe, we will see a simple example on how
    to use it by creating a form with color picker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color picker input](img/9282OT_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a simple form where we will have a color picker added in a form
    that is part of the HTML body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The color input type gets picked up and the currently selected color is shown.
    On clicking the color, we can select a menu directly from the systems color picking
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Value selected is represented as a simple color string having a `#` character
    and six character representation that is a case-insensitive hexadecimal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case this is not supported in the browser, we can have a custom way of handling
    it. One of the ways to check for the support is to use the `modenrizer.js` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It allows us to implement a fallback while the other browsers catch up with
    the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using single-choice dropdowns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Single-choice dropdowns are a standard HTML component. Their usage, although
    straightforward, can sometimes be frustrating, both for the developer and the
    user. The browser requires that a "selected" attribute is added to the selected
    item. To set the value of the `select` element programmatically, the code must
    first find the item which is presently selected and remove its "selected" attribute,
    then find the item that has the specified value and add a "selected" attribute
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: However, the developer might want an easier way to specify the value of the
    dropdown field. Simply adding an attribute containing the value should be enough.
    In this recipe, we're going to solve this problem by adding a new attribute to
    dropdowns.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create an HTML page with a dropdown. In HTML, dropdowns are made with
    a `select` element. To add selection options, we add one or more option elements
    inside the `select` element. Normally, we would specify the pre-selected option
    by adding a selected attribute to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this can be inconvenient to generate on the server side or to generate
    with a template on the client side. More often than not, our list elements are
    static––its just the value that changes. To simplify templating, we can do it
    differently in our `index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can set the value in `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in `example.js` runs when the page is loaded. At that point, it finds
    all select elements that have a data-value attribute, and sets the selected option
    using jQuery's versatile function `$.fn.val`. Additionally, it binds a global
    event for all present and future select items that have a data-value attribute,
    which syncs that value to the actual value.
  prefs: []
  type: TYPE_NORMAL
- en: This is a more natural model for single-choice dropdowns.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Its important to note that this code will not work properly with client-side
    generated HTML, which was generated after the page was loaded. To handle this
    case, the `updateDropdowns` method is to be called after new `select` elements
    are added to the page.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple-choice select lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Select lists can be made to allow users to select multiple elements.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple-choice select lists have a special serialization model. In this recipe
    we're going to look at how that model works and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to create a page with a form containing a multiple-choice select
    list. This form will send a `GET` request to another page where we're going to
    extract the selected items via JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using multiple-choice select lists](img/9282OT_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a basic page with a form that has a multiple select list as shown in
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will create the page that receives the list and displays the selected
    values as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `example.js` code snippet that displays the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The address generated by the form submission looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This format breaks many assumptions that popular frameworks make about the nature
    of form data. Often they treat form data as a dictionary, where a single name
    has a single value. In this case however, the data can't be put into such a dictionary
    because multi-select lists generate multiple parameters with the same name and
    different values.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we treat the parameters as a list, which enables us to extract and
    filter both values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting geographical location input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the exciting new features in HTML5 is the geolocation API ([http://www.w3.org/TR/geolocation-API/](http://www.w3.org/TR/geolocation-API/)).
    It allows the developer to ask for the user's location. This API allows the developer
    to get geographic coordinates, such as latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: Before this API developers had to rely on more crude methods, such as GeoIP
    databases. These methods produced results that had poor accuracy. Depending on
    the user's browser, device, and the availability of GPS on it, the geolocation
    API could give results with a few meters accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to display the user's location on a map. To do this,
    we're going to use the **Leaflet** library. The use of this library to show maps
    is covered in the *Displaying a map* recipe, [Chapter 2](ch02.html "Chapter 2. Display
    of Graphical Data"), *Display of Graphical Data*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create a HTML page with a map placeholder, which will include
    the leaflet library (both CSS and JS files) and our code for getting and displaying
    the user''s location, located in `example.js` as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''re going to add the following code in `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The geolocation API is available through the `geolocation` object that can
    be found in the navigator object. There are multiple methods available, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getCurrentPosition`: This method calls its callback function parameter one
    time after a location is obtained'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`watchCurrentPosition`: This method calls its first callback function parameter
    every time the location information is updated and returns a watcher ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clearWatch`: This method removes the watch callback by clearing it using our
    returned watcher ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, we use `watchCurrentPosition`, and provide it with a callback,
    which sets the marker's position. The user will first be asked to give the website
    a permission to access his or her location. After the permission is given and
    a location is found, our callback will be called with a position object.
  prefs: []
  type: TYPE_NORMAL
- en: The position object contains the properties `timestamp` and `coords`. The `coords`
    property is an object containing `latitude` and `longitude` information. The `timestamp`
    property is a UNIX UTC timestamp denoting the time of the location information
    update.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example will not work when opened directly as a file. To view the example,
    a local server must be started in the same directory. For more information on
    how to start a local server, see *Appendix, Installing and using http-server*.
  prefs: []
  type: TYPE_NORMAL
- en: Using file inputs at the client side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML has always lacked a convenient method to read the user's files. Before
    HTML5, the only way to access user files on the client side was to use an input
    element of type file, upload that file to the server then send it back to the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 brings the ability to read user files locally, inside the user's browser
    using JavaScript code. The implementation is an extension of the functionality
    of a file input element with additional API.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to display a text file that is selected by the user
    by using the new HTML5 file API ([http://www.w3.org/TR/FileAPI/](http://www.w3.org/TR/FileAPI/)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an HTML page with a file `input` field and a content `div` to show the
    contents of the selected file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''re going to add the code to read the selected file in `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We can read the selected file from the input element's files property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To read the contents, we use a `FileReader` object. We need to instantiate
    it, tell it what file to read (and in what way it should read it depending on
    its type), then attach an event listener when the reading completes that will
    access the file contents. This is done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: By the time the `onload` function is called, the variable `f` will change to
    be set to the value of the last file for each of the `onload` calls. To avoid
    this, we capture the variable using an anonymous function pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The listener is called with an event, which in its target property contains
    our result or the text of the whole file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML5 file API consists of two new additions:'
  prefs: []
  type: TYPE_NORMAL
- en: The file input element has a files property which contains a list of the selected
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new type of object called `FileReader` exists that allows us to read the selected
    files in different ways by using its methods. Among others there are `readAsBinaryString`,
    `readAsText`, `readAsDataURL`, and `readAsArrayBuffer`. It also provides us with
    event listeners, which we can set to get the file contents when it is loaded or
    when an error occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To display the text file, we use the reader's `readAsText` property. As a result,
    the file data is provided to the `onload` listener of the reader. The content
    of the file is a simple string that we append to the `div` content inside an element
    that displays preformatted text.
  prefs: []
  type: TYPE_NORMAL
- en: For retrieving images, we call `readAsDataURL`, and then easily create a new
    image element whose `src` attribute is set to that data URL. Then we add this
    element inside the content `div`.
  prefs: []
  type: TYPE_NORMAL
- en: If a folder is selected our recipe will display the entire contents of the folder,
    both text and images.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Its possible to specify filters for the file selection dialog, which limits
    the category of the file. For example, adding `accept="image/*"` will tell the
    browser that the input expects images of any type, while adding `accept="image/jpeg"`
    will tell the browser that the input expects only JPEG images. This filter is
    based on media types. More information about available media types can be found
    at [http://www.iana.org/assignments/media-types](http://www.iana.org/assignments/media-types).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although IE9 supports a lot of HTLM5 features, the HTML5 file API is not supported.
    Support was added in IE version 10.
  prefs: []
  type: TYPE_NORMAL
- en: Using a drag-and-drop file area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With HTML5 we have another alternative for reading user files: we can use drag-and-drop
    areas. Often users find drag-and-drop intuitive and prefer it to other editing
    and manipulation methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Drag-and-drop also enable the user to drag elements from a different window
    or tab into ours, meaning they have more uses than regular file upload buttons.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to make a drag-and-drop area for images. It will
    work both with dragged files and with images dragged from a different window or
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about the HTML5 drag-and-drop specification can be found at
    [http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html](http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write the code.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to create an HTML page with a drop area. To make the area easier
    to drop to, we're going to add some padding, margin, and border to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Then we're going to add the code to read the dropped files or images from another
    website in `example.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The default browser action on drop is to navigate to the dropped item. We want
    to prevent this from happening.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We're going to read images as `DataURL`s and text files as text with our file
    reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Capturing each file inside a closure allows us to reference it from the a sync
    `onload` callback. There we append it to the content element as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if the item was dragged from a different window or tab, we need
    to read it from the items property. We''re looking for an item of type `text/html`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first part of `example.js`, we used the standard HTML5 API. You can read
    more about it in the previous recipe *Using file inputs on the client-side*––in
    short, it allows us to read files as text or `DataURL`s and put them in the document.
  prefs: []
  type: TYPE_NORMAL
- en: This part of the code supports both image files and text files.
  prefs: []
  type: TYPE_NORMAL
- en: The second part is slightly different and is called only when dragging elements
    or images from a different website. It works on any `draggable` HTML element—this
    element will also be added to our content page as HTML. The image data will not
    be accessible.
  prefs: []
  type: TYPE_NORMAL
- en: In combination, the API described here is very powerful for use in online rich
    text, UI, or graphic editors. We can combine it with image uploading services
    or with our own panels containing various pre-made elements which we can drop
    inside the drop area.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As can be seen in this recipe, the HTML5 drag-and-drop API is not limited to
    just files. By setting the `draggable="true"` attribute, any element on any page
    can be made dragable.
  prefs: []
  type: TYPE_NORMAL
- en: The `dragstart` event will be fired on the `draggable` element as soon as the
    dragging starts. As we move the element over potential drop targets, the `dragenter`,
    `dragover`, and `dragleave` events will be fired. Finally, the `drop` event that
    we used in this recipe is fired when the element is dropped, as well as `dragend`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to get fine, programmatic control over the content of the dragged
    object, the `DataTransfer` object can be used. For example, the following `dragStart`
    handler placed on a `draggable` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: will cause the browser to place the specified HTML content inside the dragged
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The best feature of custom HTML5 `draggable` elements is the compatibility with
    other applications in the system. Dragable objects can "travel" outside the browser
    into other applications, such as mail clients, image editors, and so on. As a
    result, HTML5 apps are one step closer to becoming first-class citizens inside
    the operating system.
  prefs: []
  type: TYPE_NORMAL
