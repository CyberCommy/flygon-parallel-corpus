- en: Templates, Directives, and Pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates define how your components are displayed, and laid out on your web
    pages. Angular provides several built-in directives that provide developers control
    over the display of their components—from whether to display or hide the component,
    to rendering it multiple times on the page. Built-in directives also provide a
    mechanism for binding classes and styles to your components.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building Angular
    Components*, we looked at the structure of a component and how to break down our
    application into a tree of components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn how to have command over the display of your
    components within their parents'' templates. Specifically, at a high level, here''s
    what we''re going to be covering together:'
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we've seen what component templates are and how to
    create them. However, so far, we've only seen static HTML. In this section, I'd
    like to zoom in a little and take a look at some template syntax with you that
    allows us to create dynamic HTML, which, of course, is one of the main goals of
    Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Templating syntax in Angular provides us with a mechanism to make our HTML dynamic—specifically,
    for data binding, property binding, and event binding. We'll be taking a look
    at these three types of binding in this chapter. The way in which Angular gives
    us the power to create templates that produce dynamic HTML, or to manipulate the
    DOM (more on this in just a little bit), is through a set of symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the six basic symbols that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{ }}` for string interpolation and one-way data binding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[( )]` for two-way data binding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#` for variable declaration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`( )` for event binding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ ]` for property binding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` prepends structural directives, such as `ngFor`, as we''ll see'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The three types of the directives are:  components, attribute directives, and
    structural directives. However we're really only going to cover two of the three
    types of directives— **attribute directives** and **structural directives**. The
    reason for this is because we've already spent an entire chapter covering the
    first type of directive, and that was components. That's right! Components are
    actually directives under cover! Specifically, and stated another way (which illustrates
    how components are differentiated from attribute and structural directives), components
    are directives that have a template. Of course, this must mean that attribute
    and structural directives do not have templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so what exactly are directives, then? Let''s give the term *directives*
    a distinct definition to get rid of any possible confusion that this terminology
    may be causing before we move on to discuss the the next two types of directives.
    The definition we''ll be using is this: *Angular directives are constructs that
    provide specific DOM manipulation operations.* DOM (or HTML DOM) is an acronym
    for Document Object Model, and is not an Angular thing—it is a browser thing.
    All modern browsers create a DOM whenever a web page is loaded, which is a tree
    of objects that is accessible by JavaScript. Without the DOM, Angular (and any
    other web framework that manipulates the DOM) would not exist.'
  prefs: []
  type: TYPE_NORMAL
- en: Components, as we've seen in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    *Building Angular Components*, fit our definition of directives because they are
    indeed constructs that provide specific DOM operations. Not only are their templates
    injected into our page (replacing their custom HTML tags), but they themselves
    contain data, property, and event bindings, which further manipulate the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: We've now fully explained components in various ways, and we'll see them in
    action during the implementation of our wireframes throughout the rest of the
    chapters that follow.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining two types of directives do not inject any HTML templates in our
    pages or views because they do not have any templates. However, they do manipulate
    the DOM—as mandated by our previous definition of directives. Let's now look at
    what each of these types of directives do.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attribute directives manipulate the DOM by changing the appearance or the behavior
    of specific DOM elements. These types of directives are surrounded by brackets,
    and are attributes of an HTML element. The brackets are symbols (one of the five
    types of symbols we listed at the beginning of this chapter), and they signal
    to Angular that it may need to change either the appearance or the behavior of
    the element for which the directive is an attribute of.
  prefs: []
  type: TYPE_NORMAL
- en: 'That last sentence was a mouthful, so let''s take a look at a code example
    of the attribute directive you''re most likely to use. The directive I''m referring
    to is named `hidden`, and will cause Angular to either show or hide its element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we've hidden the `div` element and any embedded HTML from
    all user types that are not admins. Here, `usertype` and `admin` are, of course,
    application-contextual things, and are only used as an example to illustrate what
    Angular can do.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, the `hidden` attribute directive is associated with an expression
    to be evaluated. The expression must evaluate to a Boolean (that is, `true` or
    `false`). If the expression evaluates to `true`, Angular will hide the element
    from the view. Conversely, if the expression evaluates to `false`, Angular will
    leave it alone and it will be displayed in the view.
  prefs: []
  type: TYPE_NORMAL
- en: As I did in previous chapters, I will make sure to point you to the official
    documentation online. As you know by now, I'm not a fan of the approach that a
    lot of other IT books take, which is to regurgitate documentation. While it's
    unavoidable to some extent, some books fill most of their pages with it. So, I
    will continue to stay away from that trap and will continue to add all the value
    I can in better ways.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, the official online documentation for attribute directives
    can be found at [https://angular.io/guide/attribute-directives](https://angular.io/guide/attribute-directives).
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural directives manipulate the DOM by adding or removing specific DOM
    elements. Just as we have syntax we can use to signal to Angular that we have
    an attribute directive to which it needs pay attention to, with the brackets symbol,
    we have the equivalent for structural directives.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax we use to signal to Angular that we have a structural directive it
    needs to pay attention to is the asterisk (*). Structural directives are prefixed
    with an asterisk, which signals to Angular that it may need to add or remove elements
    from the DOM. As I enumerated at the beginning of the chapter, the asterisk is
    another one of the symbols we can use in our template syntax.
  prefs: []
  type: TYPE_NORMAL
- en: NgFor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as we look at a code example of the attribute directive you are most likely
    to use, let''s now take a look at a code example of the structural directive you
    will probably use most often—`NgFor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous `ngFor` code example prints out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things I''d like to point out in the previous code; firstly,
    the `*ngFor` structural directive. Let''s take a look at these in bullet-point
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngFor` takes an iterable, and loops through it, adding elements to the DOM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general form of the directive's syntax is `*ngFor="let <value> of <collection>"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NgFor` (note the capital N) refers to the class that defines the directive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngFor` (note the lower case n) refers to both the attribute name, as well
    as it being an instance of the `NgFor` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the structural directives follow the same casing convention as `NgFor`
    (see the previous two bullet points)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can nest `ngFor` (in much the same way that we can have nested `for each`...i
    n loops)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the collection I've provided to the `ngFor` directive is not indicative
    of how we would normally pass data to the directive. I've coded it this way for
    brevity. The way we'd normally do this is to have the data (that is, our collection)
    defined within our component class and assigned to a variable, and then use that
    variable in the statement attached to the directive.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the index value of the iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll often be interested in having access to the index value of the iteration—maybe
    to grab every *n*th object, or to group things in numbers of *x*, or maybe we
    want to implement some kind of custom pagination. Whatever the need to read the
    current index value of the iteration, we can use the `index` keyword to set the
    index to a variable within our expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some example code demonstrating this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code sample, let's just assume that the cars collection was
    populated elsewhere—such as in the component class.
  prefs: []
  type: TYPE_NORMAL
- en: Also, Angular takes care of updating the index value with each iteration for
    us—and all we have to do is to reference it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use `{{ i + 1 }}` to output the car number. This is because, as
    with most arrays or iterables (in most languages, but certainly in JavaScript
    and TypeScript), the index is zero-based. Also, note that the expression within
    the double curly braces, `i + 1`, is not just a variable. In Angular, whatever
    is inserted within the double curly braces is evaluated. We could even insert
    function calls there if we wanted to.
  prefs: []
  type: TYPE_NORMAL
- en: The official online documentation for structural directives is available at [https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives).
  prefs: []
  type: TYPE_NORMAL
- en: Built-in directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few built-in directives that we have at our disposal. Let''s take
    a peek at these in the sections that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NgFor` (we''ve already covered this one, as the first example of a structural
    directive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NgIf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NgSwitch`, `NgCase`, and `NgDefault`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NgStyle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NgClass`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NgNonBindable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NgIf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want to either display or remove an element from the DOM, we use the
    `NgIf` directive. We pass an expression to the directive, and it must evaluate
    to a Boolean. If it evaluates to `true`, the element will be displayed on the
    view. Conversely, if the expression evaluates to `false`, the element will be
    removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can also bind to the `hidden` property (property binding will be
    described as follows) to achieve the same thing, visually, but there is a difference
    between the property binding method, and using the `NgIf` directive. The difference
    is that using property binding on `hidden` just hides the element, whereas using
    the `NgIf` directive physically removes the element from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what `NgIf` looks like in code (in the context of our car example,
    assume we had a `horsepower` property):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In most traditional programming languages when there are alternate things to
    check for in sequence, as in a series of traditional `if`, `then`, and `else`
    statements, it sometimes makes more sense to use a `switch` statement (if the
    language supports one). Java, JavaScript, and TypeScript are examples of languages
    (and there are, of course, many others) that support this conditional construct.
    Angular gives this power to us as well, so we can be more expressive and efficient
    with our code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how this is accomplished in Angular in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: NgSwitch, NgCase, and NgDefault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In several programming languages, such as Java, JavaScript, and TypeScript,
    the `switch` statement does not work in isolation. It works in concert with other
    statements and keywords—namely, `case` and `default`. Angular's `NgSwitch` directive
    works exactly the same way, in that `NgSwitch` works in concert with `NgCase`
    and `NgDefault`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s flesh out a slightly larger example here by creating a component that
    will contain our car data, our styling, and our template, which makes use of `NgSwitch`,
    with `NgCase` and `NgDefault`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we've constructed a complete component named
  prefs: []
  type: TYPE_NORMAL
- en: '`CarHorsepowerComponent`. Within the parent component template, Angular will
    replace instances of our custom HTML element, `<car-hp>`, with the template we''ve
    created in our `CarHorsepowerComponent` (this is because we assigned `car-hp`
    to the `selector` property of the component annotation of our `CarHorsepowerComponent`
    class).'
  prefs: []
  type: TYPE_NORMAL
- en: We've also included the data for the collection we're passing to the `NgFor`
    directive within our component class, as opposed to it being inline within the
    expression assigned to the `NgFor` directive, as we did in a previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was a simple example whose template iterates through our cars collection,
    and applies one of three styles to the make and model of the cars based on the
    current car''s horsepower—and this is accomplished via the `NgSwitch`, `NgCase`,
    and `NgDefault` directives. Specifically, here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: If the car's horsepower is equal to or greater than 375 HP, we're going to consider
    it to be a supercar and will have the car's make and model rendered in white font
    with a red background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the car's horsepower is equal to or greater than 200 HP, but less than 375
    HP, we're going to consider it to only be a sports car and will have the car's
    make and model rendered in black font with an orange background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the car's horsepower is anything under 200 HP, which is our *default* (or
    *catch-all*) case, we're going to consider it to be a car that is suitably safe
    for a grandmother to drive, and will have the car's make and model rendered in
    black font with a yellow background—because most grandmothers find the color scheme
    of honey bees to be attractive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the grandmother comment was for entertainment value only, and I'm
    not trying to intentionally offend anyone who drives a car that takes a full 8
    seconds, *or more,* to accelerate from 0 to 60 MPH (wink). Truth be told, one
    of my cars (a 2016 Honda Civic) only has 158 HP—and believe me, I've been passed
    on the road going uphill by a grandmother driving an Infinity Q50\. That's why
    I bought something more powerful within the next couple of days after that horrible
    experience (big smile).
  prefs: []
  type: TYPE_NORMAL
- en: One last thing I wanted to point out in this previous example is the way in
    which the `NgSwitch` directive was used. You'll note that I wrote it in a different
    format, namely `[ngSwitch]="car.horsepower"`, instead of `*ngSwitch="car.horsepower"`.
    This is because there is a rule that Angular imposes on us when it comes to structural
    directives, which is that we cannot have more than one structural directive using
    the asterisk symbol prepending the directive's name. To work around this, we used
    the property binding symbol, `[ ]` (a pair of square brackets).
  prefs: []
  type: TYPE_NORMAL
- en: NgStyle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NgStyle` directive is used for setting an element''s style properties.
    Let''s rework our previous `CarHorsepowerComponent` example, which used to demonstrate `NgSwitch`,
    `NgCase`, and `NgDefault`, in order to show how the same desired outcome (that
    is, conditionally styling elements) can be better done using `NgStyle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In our reworking of the original `CarHorsepowerComponent` class, we've lightened
    up our component template by moving the logic into a function within the class.
    We've removed the styles property of the component annotation, and instead created
    a function (that is, `getCarTextStyle`) to return the style text to the calling
    function so that we can set the correct style.
  prefs: []
  type: TYPE_NORMAL
- en: Though this is a cleaner approach, we can do even better. Since we're setting
    a style for the car text, we can just change the style class altogether, as opposed
    to passing the actual style rulesets via text.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, on `NgClass`, we'll rework our code one more time to see
    how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: NgClass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NgClass` directive is similar to the `NgStyle` directive, but is used to
    set the style class (from the CSS rulesets with the styles property of the component
    annotation), instead of setting the style via the raw CSS rulesets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example is the best choice of the last three code examples
    in order to achieve what we want to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've kept our `styles` property for our component annotation, we've kept
    the template light and clean, and our function just returns the name of the CSS
    class to be assigned to our `NgClass` directive.
  prefs: []
  type: TYPE_NORMAL
- en: NgNonBindable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last directive in our list to cover is the `NgNonBindable` directive. `NgNonBindable`
    is used when we want Angular to ignore the special symbols in our template syntax.
    Why would we want to do this? Well, let's say that you and I decided to create
    an online Angular tutorial, and the website itself was to be coded using Angular.
    If we wanted to render the text `{{ my_value }}` to the view, Angular would try
    to find the `my_value` variable within its current scope to bind the value and
    then insert the text in its place. Since this is not what we'd want Angular to
    do, we need a way to instruct Angular, *Hey, by the way, do not try and evaluate
    and string interpolate anything right now—just render the symbols as you would
    with any other normal text*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what this looks like for, say, a `span` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note the placement of the `NgNonBindable` directive within the opening `<span>`
    tag. When Angular sees `ngNonBindable`, it will disregard the double curly braces
    and will not one-way bind anything. Instead, it will let the raw text be rendered
    to the view.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding using the NgModel directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen an example of one-way data binding within our example that demonstrated
    how to use the `NgFor` directive. Namely, one-way data binding is done using the
    double curly braces symbol, `{{ }}`. The variable that we enclose within the double
    curly braces (such as `car.make` and `car.model` from the example) is bound one-way
    (that is, from the component class to the template), converted to a string, and
    rendered to the view. It does not allow for binding any changes back to the component
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In order for us to implement two-way data binding, thereby also allowing the
    binding of changes within the view back to the component class, we have to use
    the `NgModel` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to see this in action when we implement our wireframes, but let
    me show you what this looks like for now. In order to use `NgModel`, we have to
    first import an Angular module named `FormsModule` from the `forms` package, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to use this directive, we''d have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Having this code in place would not only cause the view template to display
    the value of `my_content` in the component class, but any changes to this `div`
    within the view template would be then be bound back to the component class.
  prefs: []
  type: TYPE_NORMAL
- en: Event binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to see a lot of event binding during our implementation of the example
    application's wireframes. To bind an event that we're interested in listening
    for on an element, we enclose the event name within parentheses (which are one
    of our special symbols that we can use in our template syntax). To do so, we assign
    a statement to be run when the event is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a JavaScript alert that will be triggered when someone
    clicks within the `<span>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have attached a `click` event and we invoke an alert
    box with the message.
  prefs: []
  type: TYPE_NORMAL
- en: Property binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen property binding in previous examples, but for completeness, I
    will very briefly give another example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this previous example, we enclose the property we want to set within square
    brackets (which are one of the special symbols that we can use in our template
    syntax). Of course, this is not that useful in this example, because I've hardcoded
    the Boolean to `true` instead of using an expression that is to be evaluated—but
    the point of this example was to focus on the `[hidden]` part.
  prefs: []
  type: TYPE_NORMAL
- en: Custom directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is extensible. Not only can we easily create our own custom components
    (so that we're not restricted to using ready-made components from third parties),
    but we can also create our own attribute directives so that we're not restricted
    to what Angular gives us out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: I'll leave some of the custom things we can do in Angular, such as custom attribute
    directives, custom pipes (we'll see what pipes are in the next section), and custom
    form validation, until [Chapter 14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml),
    *Advanced Angular Topics*. We'll be taking a look at form validation in [Chapter
    10](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml), *Working with Forms*. There's
    a good reason why I chose to lump all of the advanced stuff that is covered in
    this book into one chapter—to give you time to digest the basic stuff first. By
    the time the advanced chapter comes along, near the end of the book, you'll be
    ready and primed to more easily absorb that information.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipes are used for formatting the data in our template views. Pipes will take
    data as input and transform it into our desired format for displaying it to end
    user. We can use the `pipe` property (`|`) in any Angular template or view in
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: Let me give you a quick rundown before we jump into creating our examples. Let's
    say that, from the backend service, we get the price of a product as 100, and
    based on the user's country or preference, we may want to display the value as
    $100 if the user is from the USA, or INR 100 if the user is from India. So, we
    are able to transform the way that we display the price without any major complexity.
    This is thanks to the currency pipe operator.
  prefs: []
  type: TYPE_NORMAL
- en: Angular provides a lot of built-in pipes ready to use directly in our templates.
    Additionally, we can also create our own custom pipes to extend our application's
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the list of all the built-in pipes that Angular provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Lowercase pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uppercase pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currency pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Percent pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimal pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slice pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn about each of the available built-in pipes by doing some fun,
    practical examples. We can make use of any of the existing template files that
    we have created in our Angular project so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need some data that we want to process and transform using our pipes.
    I am going to quickly create a dataset in our `app.component.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have created a sample dataset for products in our app component. Great, now
    we are good to apply our pipes in our `app.component.html` file. We are going
    to keep it simple in our template. We will just create a table and bind the values
    in the table. If you are feeling a little adventurous today, go ahead create a
    layout for our application using Flex-Layout, which we learned in [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml),
    *Flex-Layout – Angular's Responsive Layout Engine:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding sample code, we have created a table and, using the data binding,
    we have bound the data in our template. Now it''s time to use the pipe operator
    in our template. To apply any pipe, we will have to add the pipe operator against
    the data, as shown in the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily transform our product name into uppercase by applying the uppercase
    pipe, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can apply the lowercase pipe as well, which will make all characters
    lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That was very simple, you might say? So it is! Let's keep rolling. In a similar
    way, we will use the number pipe operator to show or hide the decimal points.
  prefs: []
  type: TYPE_NORMAL
- en: 'For displaying product prices, we want to add the currency; no problem, we
    will use the currency pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have transformed the product price by adding the
    currency pipe. The remaining pipe operators I am leaving to you as homework.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `$ currency` is added when we use the currency pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can customize it by parameterizing the currency pipe. We will learn how
    to pass parameters to the pipe operators. We will have to extend the syntax of
    the pipe operator by passing the parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding syntax looks similar to how we learned to define a pipe operator,
    except that now it has two parameters. We can define a pipe operator with any
    number of parameters based on our requirements. We have used the currency operator
    in the previous example, so let''s pass parameters to extend the currency pipe
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are passing the `INR`  parameter to our currency pipe operator. Now, the
    output of the currency pipe operator will not be `$` anymore; instead, it will
    be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6a445fcb-47d2-494e-8ff7-1c9a932b9260.png)'
  prefs: []
  type: TYPE_IMG
- en: We have learned to use built-in pipe operators in this section. Now, we'll learn
    about creating our own custom pipes. .
  prefs: []
  type: TYPE_NORMAL
- en: Custom pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is extensible in this area of custom pipes as well as well as custom
    directives. However, I'm deferring our discussion of custom pipes until [Chapter
    14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml), *Advanced Angular Topics*. I've
    included this section here as a placeholder, and a reminder of later coverage,
    as well as for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we zoomed in on component templates, and on what template syntax
    was available to us for creating them. Our template syntax included symbols, directives,
    and pipes.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen that directives are just templateless components, and they come in
    two main flavors—**attribute directives**, and **structural directives**. Whatever
    their flavor or category, we associate (or attach) directives to HTML elements
    by adding them as attributes of those elements.
  prefs: []
  type: TYPE_NORMAL
- en: We've gone over the following special symbols that we can use in our template
    syntax. We've also covered the built-in directives that we can use in our template
    syntax. Next, we covered event binding, as well as property binding, and finally,
    we covered pipes, which provide us with the means to format our data so that it
    can be rendered to our views in the way we desire.
  prefs: []
  type: TYPE_NORMAL
- en: We know that Angular is extensible and that it provides us with mechanisms to
    create custom directives, as well as custom pipes—but we are deferring our discussion
    of anything custom to [Chapter 14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml),
    *Advanced Angular Topics*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [Chapter 8](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml),
    *Working with NG Bootstrap*, we're going to put our component hats back on our
    heads so that we can explore what `ng-bootstrap` brings to the table for us in
    building our Angular applications.
  prefs: []
  type: TYPE_NORMAL
