- en: Chapter 3. Decision Constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application makes some kind of decisions. In Java there are several programming
    constructs that we can use to make these decisions. These include logical expressions,
    the if statement, and the switch statement. The purpose of this chapter is to
    introduce these tools to you and illustrate how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin with a discussion of logical expressions as they are central to
    making decisions. Logical expressions are expressions that return a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will examine how the logical expressions can be used with the `if`
    statement and the conditional operator. There are numerous variations on how a
    `if` statement can be structured and we will look at their advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: This will be followed up with a discussion of the switch statement. Prior to
    Java 7, switch statements were based on integer or enumeration values. In Java
    7, we can now use `String` values. The use of Strings and their potential pitfalls
    are examined.
  prefs: []
  type: TYPE_NORMAL
- en: The last section addresses general control structure issues along with the impact
    of floating point numbers when making decisions, comparing objects, and a discussion
    of useful ways of organizing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the nature of decision constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the basics of logical expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use the `if` statement and look at its variations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the conditional operator and when it should be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the switch statement and Java 7's use of strings with this statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine how floating point number comparisons impact control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the pitfalls associated with comparing objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow of control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any application, the flow of control within a program is determined by the
    order in which the statements are executed. It is convenient to consider groups
    of statements as blocks whose execution is controlled by decision statements.
    A block can be considered to be an individual statement or several statements
    contained within a block statement. A block statement in Java is a group of statements
    enclosed in open and close curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: Control statement – an overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Control structures are those parts of the language that determine the order
    in which individual statements are executed. Without control structures, statements
    are executed sequentially, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To vary the order in which the statements are executed, control statements
    are used. In Java, these statements include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statement: This statement is frequently used to decide which of two
    branches to take'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conditional operator: This statement is a simplified and limited form of the
    `if` statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `switch` statement: This statement is used to decide which of several branches
    to take'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch` statement uses either an integer, enumeration, or a string value
    to make a decision. To understand the `if` statement requires an understanding
    of the logical expressions. This is covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Logical expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with all expressions, a logical expression consists of operators and operands.
    In Java there are a limited number of logical operators as summarized in the following
    table. It is a subset of the operators listed in [Chapter 2](ch02.html "Chapter 2. Java
    Data Types and Their Usage"), *Java Data Types and Their Usage*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Precedence | Operator | Associativity | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | … |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | Right | Logical complement |'
  prefs: []
  type: TYPE_TB
- en: '| … |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| … |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `<`, `<=`, `>`, and `>=` | Left | Logical |'
  prefs: []
  type: TYPE_TB
- en: '| `instanceof` | Left | Type comparison |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `==` and `!=` | Left | Equality and inequality |'
  prefs: []
  type: TYPE_TB
- en: '| … |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | `&&` | Left | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | `&#124;&#124;` | Left | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | `?:` | Right | Conditional |'
  prefs: []
  type: TYPE_TB
- en: '| … |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: The operands of a logical expression may be of any data type, but a logical
    expression will always evaluate to a `true` or a `false` value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not confuse the bitwise operators, `&`, `^`, and `|` with the corresponding
    logical operators `&&` and `||`. The bitwise operators perform similar operations
    as the logical operators, but do it on a bit-by-bit basis.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The words `true` and `false` are keywords in Java. Their names correspond to
    their values and they can be assigned to Boolean variables. A Boolean variable
    can be declared with the `boolean` keyword followed by the variable name and an
    optional initial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When a logical expression is evaluated, it will return either a `true` or a
    `false` value. Examples of logical expressions include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is a good practice to give a Boolean variable a name that reflects a state
    of `true` or `false`. The `isComplete` variable implies that an operation has
    completed. The variable, `isReady`, if set to true suggests that something is
    ready.
  prefs: []
  type: TYPE_NORMAL
- en: The equality operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The equality operator consists of two equals signs and when evaluated will return
    either a `true` or a `false` value. The assignment operator uses a single equal
    sign and will modify its left operand. To illustrate these operators, consider
    the following example. If a value of a `rate` variable equals `100`, we could
    assume that an error is present. To reflect this error condition we could assign
    a `true` value to the `errorPresent` variable. This can be performed using both
    the assignment and the equality operators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding code snippet is executed we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The logical expression, `rate==100`, compares the value stored in `rate` to
    the integer literal `100`. If they are equal, which is the case here, the expression
    returns `true`. The `true` value is then assigned to `errorPresent`. If the value
    stored in `rate` had not been `100`, then the expression will return a value of
    `false`. We will examine the use of the equality operator in more depth in the
    *Comparing floating point numbers* and *Comparing objects* sections.
  prefs: []
  type: TYPE_NORMAL
- en: Relational operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Relational operators are used to determine the relationship, or relative ordering,
    between two operands. These operators frequently use two symbols. For example,
    greater than or equal to is expressed using the `>=` operator. The ordering of
    the symbols is important. Using `=>` is not legal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relational operators are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Meaning | Simple example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Less than | `age<35` |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Less than or equal | `age<=35` |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Greater than | `age>35` |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Greater than or equal | `age>=35` |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | Equal | `age==35` |'
  prefs: []
  type: TYPE_TB
- en: 'If we wish to determine whether an age is greater than 25 and less than 35,
    we will have to use the `age` variable twice and in combination with the `&&`
    operator, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While the following expression may make sense to us, it is illegal in Java.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The reason that the variable `age` must be used twice, as in the preceding example,
    is because the relational operators are binary operators. That is, each binary
    operator acts on two operands. In the preceding expression, we compared `25` to
    see if it is less than `age`. The operation will return either a `true` or a `false`
    value. Next, the true or false result will be compared to `35` which does not
    make sense and is illegal.
  prefs: []
  type: TYPE_NORMAL
- en: These are the rules of the language. We can't break these rules, therefore it
    is important for us to understand the rules.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we think about how we make decisions, we often use logical constructs such
    as AND and OR. We may make a decision if two conditions are both true, or we may
    decide to do something if either of the two conditions are true. The AND operator
    implies that both conditions must be true while OR implies that only one of the
    conditions need to be true.
  prefs: []
  type: TYPE_NORMAL
- en: These two operations are the basis for most logical expressions. We will often
    decide to do something if some condition is not true. We may decide not to walk
    the dog if it is raining. The NOT is also an operator used to make decisions.
    When used, it changes a true to a false and a false to a true.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three logical operators implementing these logical constructs in
    Java. They are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Meaning | Simple Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | AND | `age > 35 && height < 67` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | OR | `age > 35 &#124;&#124; height < 67` |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | NOT | `!(age > 35)` |'
  prefs: []
  type: TYPE_TB
- en: 'The AND, OR, and NOT operators are based on the following truth tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Logical operators](img/7324_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Some decisions can be more complicated and we express these decision evaluations
    using more complex combinations of the operators, `&&`, `||`, or `!`. We may decide
    to go to the movie if it is not raining and if either we have enough money or
    a friend is going to pay our way.
  prefs: []
  type: TYPE_NORMAL
- en: If (it is not raining) AND
  prefs: []
  type: TYPE_NORMAL
- en: ( (we have enough money) OR (a friend will pay our way)) THEN
  prefs: []
  type: TYPE_NORMAL
- en: We will go to the movie
  prefs: []
  type: TYPE_NORMAL
- en: 'Parentheses can be used to control the order of evaluation of logical operators
    in the same way they control the order of evaluation of arithmetic operators.
    In the following code sequence, the existence of errors is determined by the values
    stored in the `rate` and `period` variables. These statements are equivalent,
    but differ in their use of parentheses. The use of the parentheses in the second
    statement is not strictly needed but it does make it clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following statement, a set of parentheses is used to force the `||`
    operator to be executed before the `&&` operator. As the `&&` operator has higher
    precedence than the `||` operator, we need to use parentheses to change the order
    of evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Parentheses always take precedence over other operators.
  prefs: []
  type: TYPE_NORMAL
- en: Short circuit evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Short** **circuiting** is the process of not completely evaluating a logical
    expression once the result becomes obvious. There are two operators in Java that
    short circuit—the logical `&&` and `||` operators.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the && operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s consider the logical `&&` operator first. In the following example,
    we are trying to determine if `sum` is greater than `1200` and `amount` is less
    than `500`. For the logical expression to return true, both conditions must be
    met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, if the first condition is false then there is no reason to evaluate
    the rest of the expression. Regardless of the value of the second condition, the
    `&&` operator will return false. With short circuiting, the second condition is
    not evaluated, saving some processing time especially if the operation is time
    consuming.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify this behavior by using the following two functions. They both
    return `false` values and display messages as they execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use them in an `if` statement, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the preceding code sequence, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `evaluateThis` method executed and returned `false`. As it returned `false`,
    the `evaluateThat` method was not executed.
  prefs: []
  type: TYPE_NORMAL
- en: Using the || operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The logical `||` operator works in a similar fashion. If the first condition
    evaluates to `true`, there is no reason to evaluate the second condition. This
    is demonstrated in the following code sequence where the `evaluateThis` method
    has been modified to return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this code sequence results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding short circuit evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally, short circuiting an expression is an efficient technique. However,
    if we invoked a method as we did in the last example and the program depended
    on the second method executing it can cause unanticipated problems. Suppose we
    had written the `evaluateThat` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When the logical expression is short circuited, the `state` variable will not
    be changed. If the programmer mistakenly assumed that the `evaluateThat` method
    would always be executed, then this could result in logic error when the value
    assigned to `state` is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: The `evaluateThat` method is said to have a side effect. One can argue whether
    or not it is a good practice to use methods that have side effects. Regardless,
    you may run across code that uses side effects and you need to understand its
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: One alternative to avoid the short circuit of logical expressions is to use
    the bitwise AND (`&`) and OR (`|`) operators. These bitwise operators perform
    the `&&` or `||` operations bit-by-bit for each bit of the operand. As the internal
    representation of the keywords, `true` and `false`, use a single bit, the result
    should be the same as returned by the corresponding logical operators. The difference
    is that the short circuit operation is not performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the previous example, if we use the `&` operator instead of the `&&`
    operator, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output, showing that both methods were executed when
    we execute the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The if statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `if` statement is used to control the flow of execution based on a Boolean
    expression. There are two basic forms that can be used and there are several variations.
    The `if` statement consists of the `if` keyword, followed by a logical expression
    enclosed in parentheses and then by a statement. In the following diagram a graphical
    depiction of a simple `if` statement is presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The if statement](img/7324_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following illustrates this form of the `if` statement where we compare
    `rate` to `100` and if it is equal to `100` we display a message to that effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is not as readable as the following equivalent example where
    we spilt the `if` statement across two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we will see later, it is better to always use a block statement with `if`
    statements. The following is logically equivalent to the previous `if` statement
    but is more readable and maintainable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second form of the `if` statement uses the `else` keyword to designate
    the statement to execute, if the logical expression evaluates to `false`. The
    following diagram graphically illustrates this version of the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The if statement](img/7324_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `if` statement is illustrated as follows, using the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the expression evaluates to `true`, the first block is executed and then
    control passes to the end of the `if` statement. If the expression evaluates to
    `false`, the second block is executed. In this example, each block consists of
    a single statement but it doesn't have to be this way. Multiple statements can
    be used within the blocks. The choice of the number of statements depends on what
    we are trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simpler form of the `if` statement eliminates the `else` clause. Suppose
    we want to display an error message when a certain limit has been exceeded, otherwise
    do nothing. This can be accomplished by not using the `else` clause, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The only time that the message is displayed is when the limit has been exceeded.
    Note the use of the block statement. Even though it includes only a single statement
    it is still a good practice to use it. If we ever decide we need to do something
    more than simply displaying the error message, such as change the limit or reset
    the amount, then we will need a block statement. It is best to be prepared:'
  prefs: []
  type: TYPE_NORMAL
- en: Some developers do not like this simpler form and will always use an else clause.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `Do nothing` comment serves to document the `else` clause. Should we decide
    to actually do something, such as place an order, then this is where we would
    add the code. With the use of the explicit `else` clause, we at least have to
    think about what could, or should, go there.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also encounter the **empty statement** . This statement consists of
    a single semicolon. When executed, it does nothing. It is commonly used as a place
    holder indicating that nothing is to be done. The previous `if` statement is modified
    in the following code snippet to use the empty statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This does not add anything to the `if` statement and it is not a problem to
    use it here. In [Chapter 5](ch05.html "Chapter 5. Looping Constructs"), *Looping
    Constructs*, we will examine how the careless use of an empty statement can cause
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Nested if statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nesting `if` statements within each other provide another technique for making
    decisions. A `if` statement is nested if it is enclosed within the `then` or `else`
    clause of another `if` statement. In the following example, a `if` statement is
    found within the `then` clause of the first `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There is no limit on where the nested `if` can be used. It can be in either
    the `then` or `else` clauses. In addition, there is no limit as to how deeply
    they can be nested. We can place a `if` inside of a `if` inside of a `if` and
    so forth.
  prefs: []
  type: TYPE_NORMAL
- en: The else-if variation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some programming languages there is a `elseif` keyword that provides a way
    of implementing a multiple-select `if` statement. Graphically, the logic of this
    statement is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The else-if variation](img/7324_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Java does not have the `elseif` keyword but the same effect can be achieved
    using nested if statements. Let''s say we want to compute a shipping cost that
    is dependent on which of four regions of the country we are shipping to—East,
    North Central, South Central or West. We can do this using a series of `if` statements
    where each one is effectively nested inside of the `else` clause of the previous
    `if` statement. The first `if` statement that evaluates to true will have its
    body executed and the other `if` statements will be ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This code sequence is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The second example achieves the same result as the first one but requires more
    indention. In the *The switch statement* section, we will demonstrate how to achieve
    the same result using a switch statement.
  prefs: []
  type: TYPE_NORMAL
- en: The if statement – usage issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several issues that you should keep in mind when working with `if`
    statements. In this section we will examine the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Misusing the equality operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Boolean variables instead of logical expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using true or false in a logical expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The perils of not using a block statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dangling else problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Misusing the equality operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One nice feature of the Java language is the inability to write code that accidentally
    uses the assignment operator where the equality operator was meant to be. This
    happens frequently in the C programming language where the code compiles cleanly
    but results in logic errors or worse terminates abnormally at run-time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code snippet compares `rate` to see if it is equal
    to `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we had used the assignment operator instead, as shown in the following
    code snippet, we will generate a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A syntax error similar to the following will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This type of errors is eliminated in Java. The use of the equality operator
    with floating point numbers is covered in the *Comparing floating point numbers*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the error message says it found a `int` value. This is because the
    assignment operator returned a **residual value** . The assignment operator will
    modify the operand to its left and return the value that it assigned to that operand.
    This value is the residual value. It is left over from the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding the concept of residual value explains the error message. It
    also explains why the following expression works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The effect of the expression is to assign `10` to each of the variables. The
    associativity for the assignment is right to left. That is, when there are multiple
    assignment operators in an expression, they are evaluated right to left. The value
    `10` is assigned to `k` and the assignment operator returned a residual value
    of `10`. The residual value is then assigned to `j` and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Using inverse operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using relational operators, there are frequently more ways than one to
    write the expression. For example, the following code sequence determines whether
    someone is of legal age or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this code sequence could have also been written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Which approach is better? In this example, it could be argued that either approach
    will work. However, it is best to use the form which is most natural to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the operations displayed in the following table are inverse operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Inverse Operation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | `>=` |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | `<=` |'
  prefs: []
  type: TYPE_TB
- en: Note the use of the constant, `LEGAL_AGE`. It is preferable to use an identifier
    when possible for values such as a legal age. If we did not and the value was
    used in multiple places, then changing the value only has to be done in one place.
    In addition, it avoids the mistake of accidentally using the wrong number in one
    of its occurrences. Also, making the number constant eliminates the possibility
    of accidentally modifying a value that should not be modified while the program
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: Using Boolean variables instead of logical expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we saw in the *Boolean variables* section, we can declare a Boolean variable
    and then use it as part of a logical expression. We can use a Boolean variable
    to hold the result of a logical expression, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be advantageous for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows us to re-use the result later, if we need to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes the code more readable, if we use a meaningful Boolean variable name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also use the negation operator to change the order of the `then` and
    `else` clauses as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will frequently be more confusing than the previous one. We could
    make it potentially even more confusing by using a poorly worded Boolean variable
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: While this is readable and valid, a general rule is to avoid double negatives
    just as we try to do in the English language.
  prefs: []
  type: TYPE_NORMAL
- en: Using true or false in a logical expression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `true` and `false` keywords can be used in a logical expression. However,
    they are not necessary, are redundant, and clutter up the code with little value
    added. Note the use of the `true` keyword in the following logical `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The explicit use of the sub expression, `== true`, is not necessary. The same
    is true when using the `false` keyword. It is clearer and simpler to use the Boolean
    variable by itself as used in the earlier examples.
  prefs: []
  type: TYPE_NORMAL
- en: The perils of not using the block statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a block statement is considered to be a statement, this allows multiple
    statements to be included with either part of the `if` statement, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Block statements are not actually required when only one statement is needed
    for the `then` or `else` clause, but are encouraged. A similar, but invalid `if`
    statement, would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The block statement was used to group the code together. The indention of the
    print statement does not group code. While it may imply that the first two `println`
    statements are part of the then portion of the `if` statement, the `if` statement
    will, in fact, result in a compile time error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the same code is presented but with different indention. The `if` statement
    has only a `if` clause with a single `println` statement. The second `println`
    statement follows and would be executed regardless of the value of the logical
    expression. This is followed by the else clause which is all by itself. The compiler
    treats this as a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated syntax error will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A general rule of thumb is to always use block statements for the `then` and
    `else` parts of a `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more insidious problem can occur if an extra statement is in the `else` clause.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The third `println` statement is not a part of the else clause. Its indention
    is misleading. The equivalent code using proper indention is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It is clear that the third `println` statement will always be executed. The
    right way of writing this statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The dangling else problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another problem with not using a block statement is the dangling else problem.
    Consider the following series of tests where we need to make a few decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: If `limit` is greater than `100` and the `stateCode` is equal to `45`, we need
    to increase `limit` by `10`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `limit` is not greater than `100`, we need to decrease `limit` by `10`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This logic is implemented below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this example does not properly implement the decision. There are at
    least two problems with this example. First, the indentation of the `else` keyword
    is irrelevant to the evaluation of the statements and is misleading. The `else`
    keyword is always paired with the closest `if` keyword which is, in this case,
    the second one. The compiler does not care how we indent our code. This means
    that the code is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, `stateCode` is only tested if the limit exceeds `100` and then `limit`
    is either increased or decreased by `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind that the compiler ignores whitespaces (blanks, tabs, new line,
    and so on) in any statement. The code sequence could be written without whitespace
    but this makes it harder to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The second problem in this example is the failure to use block statements.
    Block statements not only provide a way of grouping statements but also provide
    a way of more clearly conveying the logic of an application. The problem can be
    resolved, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is much clearer and accomplishes what was intended. It makes the debugging
    of the program easier and the code is more readable, which makes it more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The conditional operator is a condensed, limited form of a `if` statement. It
    is condensed in that the decision is limited to a single expression. It is limited
    because multiple statements cannot be included in the `then` or `else` clauses.
    It is sometimes called the **ternary operator** due to its three components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essential form of the operator is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*LogicalExpression ? ThenExpression : ElseExpression*'
  prefs: []
  type: TYPE_NORMAL
- en: If the *LogicalExpression* evaluates to true, then the result of the *ThenExpression*
    is returned. Otherwise the result of the *ElseExpression* is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The following simple example tests to see if a number is less than 10\. If it
    is, 1 is returned, otherwise 2 is returned. The `then` and `else` expressions
    in the example are trivial integer literals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Consider the process for calculating overtime. If the employee works 40 hours
    or less, pay is computed as the number of hours worked times his pay rate. If
    more than 40 hours are worked, then the employee is paid time and a half for those
    hours over 40.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation can be perfomed using a conditional operator, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: While this solution is more compact, it is not as readable. In addition, the
    `then` and `else` clauses need to be an expression that returns some value. While
    the value does not have to be a number, it cannot be multiple statements unless
    a method is invoked containing those statements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of the conditional operator is discouraged, except in trivial cases,
    primarily due to its readability issues. It is usually more important to have
    readable, maintainable code than to save a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: The switch statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of a `switch` statement is to provide a convenient and simple method
    of making multi-branch selections based upon integer, enumeration, or `String`
    expression. The `switch` statement has the following basic form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'There are usually multiple `case` clauses within the statement block. The basic
    form of the `case` clause uses the `case` keyword followed by a colon, zero or
    more statements, and usually a `break` statement. The `break` statement consists
    of a single keyword, `break`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also an optional default clause that can be used. This will catch
    any values not caught by a `case` clause. This is demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic form of the `switch` statement is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: No two cases within a `switch` statement may have the same value. The `break`
    keyword is used to effectively end the code sequence and exit the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: When the expression is evaluated, control is passed to the case expression that
    matches the corresponding constant expression. If no case matches the value of
    the expression, control is passed to the `default` clause, if present. If the
    default prefix is not present, then none of the statements of `switch` will be
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: We will illustrate the use of the `switch` statement for integer, enumeration,
    and `String` expressions. The use of strings in `switch` statements is new to
    Java 7.
  prefs: []
  type: TYPE_NORMAL
- en: Integer-based switch statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `if` statement can be used for choosing between multiple integer values.
    Consider the following example. A series of `if` statements could be used to calculate
    shipping cost based on an integer `zone` value, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'A `switch` statement could be used for the same purpose, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget that integer data types include `byte`, `char`, `short`, and `int`.
    Any of these data types can be used with an integer switch statement. The data
    type `long` is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The order of the case and default prefixes is unimportant. The only restriction
    is that the constant-expressions must all be unique. If the `break` statement
    is not the last case clause, then it may need a `break` statement, otherwise control
    will pass to the `case` clause that follows it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For readability purposes a natural order is usually maintained which is normally
    sequential. Using this order makes it easier to find a `case` clause and to make
    sure that cases are not left out accidentally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The case and default prefixes do not alter the flow of control. Control will
    flow from one case to the next succeeding case unless the break statement is used.
    As zones 5 and 6 use the same formula to calculate the shipping cost, we could
    use back to back case statements without the use of the break statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Break statements are needed to insure that only those statements associated
    with a case are executed. Break is not necessarily needed at the end of the `default`
    clause as control will normally flow out of the `switch` statement. However, it
    is often included for purposes of completeness, and is necessary if the `default`
    clause is not the last case in the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration-based switch statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enumerations can also be used with a `switch` statement. This can make it more
    readable and maintainable. The following is duplicated from [Chapter 2](ch02.html
    "Chapter 2. Java Data Types and Their Usage"), *Java Data Types and Their Usage*.
    The variable `direction` is used to control the behavior of the `switch` statement,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is executed we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: String-based switch statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate the use of a string with a `switch` statement, we will demonstrate
    the computation of the shipping cost based on a region as used in *The else-if
    variation* section. That implementation is shown as follows, for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Prior to Java 7, only integer variables could be used with a `switch` statement.
    By permitting the use of strings, programs can incorporate more readable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet illustrates how to use a `String` variable with
    a `case` statement. The example provides an alternate implementation of the previous
    nested `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: String issues with the switch statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two other issues that should be considered when using strings with
    a switch statement:'
  prefs: []
  type: TYPE_NORMAL
- en: When null values are encountered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The case-sensitive nature of strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a null value has been assigned to a string variable used within a switch
    statement, a `java.lang.NullPointerException` exception will be thrown. Of course,
    this will happen whenever a method is executed against a reference variable that
    has been assigned a null value. In Java 7, there is additional support for handling
    null values found in the `java.util.Objects` class.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to remember about strings and the switch statement is that
    the comparison made within a `switch` statement is case-sensitive. In the previous
    example, if a string value of `east` had been used, the `East` case would not
    have been matched and the `defa` `ult` case would have been executed.
  prefs: []
  type: TYPE_NORMAL
- en: Control structure issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have identified several types of decision constructs that are available
    in Java. For example, simple decisions are easily handled using a `if` statement.
    Either-or type of decisions can be addressed using a `else if` clause or a `switch`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: The proper use of control structures is paramount in developing good code. However,
    there is more to making decisions than simply choosing between different control
    constructs. We also need to test our assumptions and handle unexpected situations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we will start by addressing a few general issues that you should
    keep in mind when using decision constructs. This will be followed by an examination
    of various floating point issues that can prove troublesome to those unfamiliar
    with floating point number limitations. Next, we will briefly introduce the topic
    of comparing objects and conclude with an overview of three basic coding activities
    that may prove helpful in understanding the nature of programming.
  prefs: []
  type: TYPE_NORMAL
- en: General decision constructs issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several issues that are important in the use of decision constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the decision statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your assumptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning for failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overall structure of a decision making process can be well structured or
    it can be an ad hoc sequence of statements that are hard to follow. A well organized
    approach to this structure can improve the readability and maintainability of
    the decision process.
  prefs: []
  type: TYPE_NORMAL
- en: 'A program may be well structured and yet may not work as intended. This is
    often due to invalid assumptions. For example, if the values for an age are assumed
    to be non-negative, then the code that is used may be well formed, and from a
    logical standpoint may be impeccable. However, if the assumption that good values
    for an age are used is wrong, then the results may not be as expected. For example,
    if the age of a person is entered as negative, then the logic may fail. It is
    important to always test your assumptions or at least make sure the underlying
    data has passed some sort of quality control check. Always expect the unexpected.
    Techniques to assist in this process include:'
  prefs: []
  type: TYPE_NORMAL
- en: Always keep a `else` clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your assumptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throw exceptions (to be covered in [Chapter 8](ch08.html "Chapter 8. Handling
    Exceptions in an Application"), *Handling Exceptions in an Application*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use block statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When all else fails, use debugging techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Floating point number considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Floating point numbers are represented internally using the IEEE 754 Floating
    Point Arithmetic standard ([http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=4610933](http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=4610933)).
    These operations are normally performed in the software, because not all platforms
    provide hardware support for the standard. Performing these operations in the
    software will be slower than those executed directly in the hardware. The advantage
    of performing these operations in the software is that it supports the portability
    of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two floating point types are supported, `float` and `double`, with their precisions
    shown in the following table. In addition, the `Integer` and `Float` classes are
    wrapper classes for these two data types. Wrapper classes are used to encapsulate
    a value, such as an integer or floating point number:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Size (bytes) | Precision |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | 4 | binary digits |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | 8 | binary digits |'
  prefs: []
  type: TYPE_TB
- en: 'Working with floating point numbers can be more complex than working with other
    data types. There are several aspects of floating point numbers that need to be
    considered. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Special floating point values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing floating point numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rounding errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special floating point values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several special floating point values as summarized in the following
    table. They exist so that when error conditions occur there will be a representation
    that can be used to identify the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'These values exist so that error conditions such as arithmetic overflow, taking
    the square root of a negative number, and dividing by 0 can yield a result that
    can be represented within the floating point value without throwing an exception
    or otherwise terminating the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Meaning | May be generated by |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Not A Number | **NaN**: Represents the result of an operation that generated
    an undefined value | Division by zeroTaking the square root of a negative number
    |'
  prefs: []
  type: TYPE_TB
- en: '| Negative infinity | A very small value | A negative number divided by zero
    |'
  prefs: []
  type: TYPE_TB
- en: '| Positive infinity | A very large value | A positive number divided by zero
    |'
  prefs: []
  type: TYPE_TB
- en: '| Negative zero | Negative zero | A negative number is very close to zero but
    cannot be represented normally |'
  prefs: []
  type: TYPE_TB
- en: 'NaN can be represented in code by `Float.NaN` and `Double.NaN`, if necessary.
    Performing an arithmetic operation with a NaN value will result in a NaN result.
    Casting a NaN to an integer will return `0` which could result in an application
    error. The use of NaN is illustrated in the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Infinity is represented in Java using either of the following fields. As their
    names imply, we can represent either a negative or a positive infinity. Negative
    infinity implies a very small number and positive infinity represents a very large
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Float.NEGATIVE_INFINITY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Double.NEGATIVE_INFINITY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float.POSITIVE_INFINITY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Double.POSITIVE_INFINITY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, arithmetic operations involving infinite values will result in
    an infinite value. Those involving NaN will result in a NaN result. Division by
    zero will result in positive infinity. The following code snippet illustrates
    some of these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'A negative zero can be generated by dividing a negative number by positive
    infinity or a positive number divided by negative infinity, as illustrated in
    the following code snippet. The output of both statements will be a negative zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`0` and `-0` are distinct values. However, when compared to each other they
    will be determined to be equal to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Comparing floating point numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Floating point numbers, as represented in a computer, are not actually real
    numbers. That is, there is an infinite number of floating point numbers in the
    numbering system. However, either 32 or 64 bits are used to represent a floating
    point number. This means that only a finite number of floating point numbers can
    be represented exactly. For example, the fraction 1/3 cannot be represented exactly
    in base 10\. If we try, we get something like 0.333333\. Likewise, there are some
    floating point numbers that cannot be represented exactly in base 2 such as the
    fraction 1/10.
  prefs: []
  type: TYPE_NORMAL
- en: 'This implies that comparing floating point numbers can be difficult. Consider
    the following example where we divide two numbers and compare the result to the
    expected quotient of 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The result, when executed, gives us an unexpected value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because these numbers are not represented exactly using the type `double`.
    To get around this problem, we can examine the result of the operation and see
    how much difference there is between what we expect and what we actually get.
    In the following sequence, a difference, `epsilon`, is defined as the maximum
    difference that is acceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is executed we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, when comparing `Float` or `Double` objects using the `compareTo` method,
    remember that these objects are ordered as follows from low to high:'
  prefs: []
  type: TYPE_NORMAL
- en: Negative infinity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Negative numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '-0.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positive numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positive infinity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NaN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following code will return `-1` indicating that a negative
    number is less than `-0.0`. The output will be `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Rounding errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is important in some situations to watch out for rounding errors. Consider
    the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'When this code is executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This is the result of the rounding error whose origins derive from the inaccurate
    representation of the fraction 1/10.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not a good idea to use floating point numbers for exact values. This is
    the case for dollars and cents. Instead, use `BigDecimal` as it provides better
    accuracy and is designed to support this type of operation.
  prefs: []
  type: TYPE_NORMAL
- en: The strictfp keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `strictfp` keyword can be applied to a class, an interface, or a method.
    Prior to Java 2, all floating point calculations were performed in compliance
    with the IEEE 754 specifications. After Java 2, intermediate calculations were
    not restricted to the standard and allowed the use of extra bits available on
    some processors to improve precision. This can result in less portable applications
    due to differences in rounding. By using the `strictfp` keyword, all calculations
    will strictly abide by the IEEE standard.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When comparing objects we need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing object references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing objects with the `equals` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When comparing references, we determine whether two reference variables point
    to the same object or not. If we want to determine whether two reference variables
    that point to two different objects are the same, we use the `equals` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two comparisons are illustrated in the following figure. The three references
    variables `r1`, `r2`, and `r3`, are used to reference two objects. The variables
    `r1` and `r2` reference Object 1 while `r3` references Object 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing objects](img/7324_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, the following conditions are true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r1 == r2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r1 != r3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r2 != r3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r1.equals(r2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, depending on the implementation of the `equals` method for the objects
    and the objects themselves, Object 1 may or may not be equivalent to Object 2\.
    Comparisons of strings are covered in more detail in the *String comparisons*
    section in [Chapter 2](ch02.html "Chapter 2. Java Data Types and Their Usage"),
    *Java Data Types and Their Usage*. Overriding the `equals` method is discussed
    in [Chapter 6](ch06.html "Chapter 6. Classes, Constructors, and Methods"), *Classes,
    Constructors, and Methods*.
  prefs: []
  type: TYPE_NORMAL
- en: Three basic coding activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing code, it can be difficult to determine how to best organize your
    code. To help keep things in perspective, remember these three general coding
    activities:'
  prefs: []
  type: TYPE_NORMAL
- en: What you want to do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to do it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a requirement of the application is to calculate the pay for an hourly employee,
    then:'
  prefs: []
  type: TYPE_NORMAL
- en: The "what" is to calculate pay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "how" determines how to write code to calculate the pay using the hours
    worked and the pay rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "when" involves where to place the code, that is, after the hours worked
    and pay rate have been determined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this may seem simple enough, many beginning programmers will have problems
    with the "when" of programming. This is especially true for event-driven programs
    typified by today's **Graphical User Interface** (**GUI**) based applications.
  prefs: []
  type: TYPE_NORMAL
- en: The goto statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `goto` statement is available in older programming languages and provides
    a powerful yet undisciplined way of transferring control within a program. Its
    use has often resulted in poorly organized programs and is discouraged. In Java,
    the use of the `goto` keyword is restricted. It simply cannot be used at all.
    It has been effectively banished from Java programming altogether.
  prefs: []
  type: TYPE_NORMAL
- en: However, statements with similar functionality to the `goto` statement still
    exist in many languages. For example, the `break` statement causes control to
    immediately be transferred to the end of the switch statement, and as we will
    see later, out of loops. Labels can also be used in conjunction with the break
    statement as we will see in the *Using labels* section in [Chapter 5](ch05.html
    "Chapter 5. Looping Constructs"), *Looping Constructs*. This transfer is immediate
    and unconditional. It is effectively a `goto` statement. However, the `break`
    statement, and in similar fashion the return statement and exception handling,
    are considered to be more structured and safer. Control is not transferred to
    any arbitrary location within the program. It is only transferred to a specific
    location relative to statements at the end of the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decision making is an important aspect of programming. Most programs' utility
    is based on its ability to make certain decisions. The decision making process
    is based on the use of control constructs such as logical expressions, `if` statements,
    and switch statements.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of decisions to be made and are supported in Java
    with different control constructs. The primary ones discussed in this chapter
    included the `if` statement and the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Care must be taken with the use of these statements to avoid the pitfalls possible
    with their use. These include misuse of the comparison operator, not using block
    statements as a matter of habit, and avoiding the dangling else problem. We also
    examined some of the issues that can occur when working with floating point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Decision making in Java can be simple or complex. Simple and complex either-or
    decisions are best handled using the `if then else` statement. For some of the
    simpler decisions, the simple `if` statement or conditional statement can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple choice decisions can be facilitated using either the `if` statement
    or the `switch` statement, depending on the nature of the decision. More complex
    decisions can be handled by the nesting of `if` statements and `switch` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about decision constructs, we are ready to examine how
    to use arrays and collections, which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Certification objectives covered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With regards to certification objectives, we will examine:'
  prefs: []
  type: TYPE_NORMAL
- en: Using operators and decision constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Java relational and logical operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using parentheses to override operator precedence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating if and if/else constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `switch` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the result of the following operation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: a. 0
  prefs: []
  type: TYPE_NORMAL
- en: b. 1
  prefs: []
  type: TYPE_NORMAL
- en: c. 2
  prefs: []
  type: TYPE_NORMAL
- en: d. 3
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following expressions will evaluate to 7?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `2 + 4 * 3- 7`
  prefs: []
  type: TYPE_NORMAL
- en: b. `(2 + 4) * (3 - 7)`
  prefs: []
  type: TYPE_NORMAL
- en: c. `2 + (4 * 3) - 7`
  prefs: []
  type: TYPE_NORMAL
- en: d. `((2 + 4) * 3) - 7)`
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: a. 1
  prefs: []
  type: TYPE_NORMAL
- en: b. 2
  prefs: []
  type: TYPE_NORMAL
- en: c. 4
  prefs: []
  type: TYPE_NORMAL
- en: d. 8
  prefs: []
  type: TYPE_NORMAL
- en: Given the following declarations, which of the following if statements will
    compile without errors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: a. `if(i > j) {}`
  prefs: []
  type: TYPE_NORMAL
- en: b. `if(i > j > k) {}`
  prefs: []
  type: TYPE_NORMAL
- en: c. `if(i > j && i > k) {}`
  prefs: []
  type: TYPE_NORMAL
- en: d. `if(i > j && > k) {}`
  prefs: []
  type: TYPE_NORMAL
- en: What will be printed out when the following code is executed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: a. one
  prefs: []
  type: TYPE_NORMAL
- en: b. default and two
  prefs: []
  type: TYPE_NORMAL
- en: c. one, two, and default
  prefs: []
  type: TYPE_NORMAL
- en: d. Nothing, a compile-time error is generated
  prefs: []
  type: TYPE_NORMAL
