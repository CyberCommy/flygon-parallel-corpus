- en: Chapter 10. Building, Compiling, and Testing with Elixir
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js, Gulp, and Elixir
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Elixir
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining CSS and JavaScript files using Elixir
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests with Elixir
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending Elixir
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating Laravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, many parts of an example application have been built. We
    discussed the steps involved in creating an application. However, there is more
    information available about tools to help with scaffolding, boilerplate templates,
    and building up a RESTful API for a CRUD application. Until recently, not much
    was written about automating some parts of the development process and deployment
    process.
  prefs: []
  type: TYPE_NORMAL
- en: A newer area that has emerged in the last few years in the PHP field is the
    concept of continuous integration and build tools. The popularity of continuous
    integration and continuous delivery enables teams of developers to constantly
    release many small improvements to their application many times a day. In this
    chapter, you will learn how Laravel has a new toolset to empower teams to rapidly
    and effortlessly deploy versions of their software and build, and combine many
    of the software's components automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration and continuous delivery has caused quite an evolution
    in the development process, which has drastically changed the way in which software
    is built. It was not too long ago, however, when the standard deployment process
    involved simply placing the code on the server. A majority of the early adopters
    of PHP were simply web designers with a need to add functionality such as a *forum*
    or *contact us* form. Since most of them were not programmers, most of the practices
    used in web design and graphic design in general made their way into PHP deployment
    as well. These practices often involved using an application such as FileZilla
    to drag-and-drop files from the left-hand side panel (the user's computer) to
    the right (the server's directories). For the more experienced, performing what
    was then cryptic UNIX commands using a terminal emulator such as PuTTY.
  prefs: []
  type: TYPE_NORMAL
- en: The insecure file transfer port 21 was used, and everything was sent uncompressed
    and simply copied to the server. Usually, all of the files were overwritten and
    often the deployment took almost an hour for a large site with many images and
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, source code control systems became pervasive. In the most recent
    years, SVN and Git have become the industry standard for most software projects.
    These tools allowed for deployment directly from a code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Most recently, the arrival of composer has created an easy way to simply include
    entire software packages to add functionality to software applications. The ease
    with which a developer simply needs to add a single line to the configuration
    file is exhilarating!
  prefs: []
  type: TYPE_NORMAL
- en: Automating both the development and deployment processes may involve many steps,
    some of which are listed next.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the functions of the deployment process:'
  prefs: []
  type: TYPE_NORMAL
- en: Copying certain configuration settings that are relevant to the production environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing or compiling any **cascading style sheets** (**CSS**) or JavaScript
    files that were written using a shortcut syntax or preprocessor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying the various assets (source code or images) to mirrors, cluster servers,
    or content delivery networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the read/write/execute permissions and/or ownership of certain files
    or directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining several files into one to reduce the overhead required to perform
    multiple HTTP calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing useless white space and comments (minifying and/or uglifying) in files
    to reduce their size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing existing files on the server with the files from our local environment
    to determine whether or not to overwrite them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tagging and/or versioning the source code to allow for possible code rollbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development or deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the functions of the development or deployment process:'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that code passed all of the unit, functional, and acceptance tests
    written to guarantee its quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running scripts that perform various operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing any migrations, seeding, or other modifications to the database tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining source code control from a hosted source code control system such
    as GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is clear that modern development is very complex. An even more difficult
    aspect of software development is continually recreating the production or final
    environment while developing.
  prefs: []
  type: TYPE_NORMAL
- en: Towards automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tools such as file watchers can run scripts or perform operations every time
    a file is modified. Additionally, IDEs such as PHPStorm will recognize file extensions
    and offer to watch the file for changes and allow the developer to perform certain
    operations. While this approach is acceptable, it is not very portable and each
    developer would have to create and share a configuration file with the various
    watchers within the IDE or text editor. This creates a dependency, relying on
    one single IDE for the entire team.
  prefs: []
  type: TYPE_NORMAL
- en: Also, other approaches such as Bash-shell scripts could be created that run
    at certain intervals. However, using these scripts requires UNIX-shell coding
    knowledge. As has been previously demonstrated, tools like artisan help automate
    many manual tasks. However, most of the default artisan commands were and are
    still designed to be executed manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, two tools that use the Node.js JavaScript platform have emerged: *Grunt*
    and *gulp*. Both Grunt and gulp have had a considerable amount of success, but
    gulp has recently become more popular. However, learning to quickly write tasks
    using gulp is not very easy, especially for a PHP developer who may not be familiar
    with JavaScript syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example code taken from the documentation of gulp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From Gulp to Elixir
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Luckily, the Laravel community is always forward thinking and focuses on reducing
    complexity. An official community tool named **Elixir** has emerged to facilitate
    the use of gulp. Gulp is built on top of Node.js, and Elixir is built on top of
    gulp, creating a wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '![From Gulp to Elixir](graphics/B04559_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Laravel Elixir is not to be confused with the dynamic, functional language with
    the same name. The other Elixir uses the Erlang virtual machine, while Laravel
    Elixir uses gulp and Node.js
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to install Node.js if it is not already installed on the development
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instructions can be found at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://nodejs.org](https://nodejs.org)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a Debian-based operative system such as Ubuntu, installing Node.js could
    be as simple as using the `apt` package manager. From the command line, use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the installation instructions for the correct operating system
    from the Node.js website ([https://nodejs.org](https://nodejs.org)).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Node.js package manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step involves installing gulp, which Elixir will use to run its tasks.
    For this step, the **Node.js package manager** (**npm**) is required. If `npm`
    is not already installed, then the `apt` package installer is to be use. The following
    command will be used to install `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The npm uses a `json` file to manage the project''s dependencies: `package.json`.
    This file is found in the root of the Laravel project directory and has the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Gulp and Laravel Elixir are installed as dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Gulp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following command is used to install `gulp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Installing Elixir
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once Node.js, npm, and gulp are installed, the next step is to install Laravel
    Elixir. By running `npm` install without any arguments, `npm` will read its configuration
    file and Laravel Elixir will be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Running Elixir
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Laravel contains a `gulpfile.js` file that is used by gulp to run
    its tasks. The file contains a `require` method that includes everything needed
    for the tasks to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first mix is shown as an example: `app.less`. To run gulp, simply type
    `gulp` at the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first line indicates that the gulp file was loaded. The following lines
    show each task running. The `less` job deals with the cascading style sheet preprocessor
    `Less`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your development environment is a Vagrant Box, installing `vagrant-notify`
    will allow Laravel Elixir to interact directly with the host and display native
    messages directly in the operating system. To install it, the following command
    should be run from the host operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the screenshot of a notification showing that PHPUnit tests have failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up notifications](graphics/B04559_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The installation instructions depend on each operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information, visit [https://github.com/fgrehm/vagrant-notify](https://github.com/fgrehm/vagrant-notify).
  prefs: []
  type: TYPE_NORMAL
- en: Combining CSS and JavaScript files with Elixir
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Possibly, the single most important step of the deployment process is to combine
    and minify CSS and JavaScript files. Minifying and combining five JavaScript files
    and three CSS files means that instead of eight HTTP requests, there will be only
    one. Also, by minifying the files by removing white space, line breaks, comments,
    and other techniques, such as shortening variable names, the file size will be
    reduced to a fraction of its original size. Despite the advantage, there are still
    many websites that continue to use unminified and uncombined CSS and JavaScript
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elixir provides a simple means to easily combine and minify files. The following
    code illustrates this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The two methods, `scripts()` and `styles()`, will combine all of the JavaScript
    and CSS files into single files, `all.js` and `all.css`, respectively. By default,
    the two functions expect the files to be located at `/resources/assets/js` and
    `/resources/assets/css`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the gulp command has finished, the output will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the output conveniently states which directories were scanned. The
    contents are combined, referred to as merged in this context, but not minified.
    This is because, during development, debugging is too difficult on minified files.
    If only a certain file is to be merged, then the name of the file may be passed
    into the function as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If multiple files are to be merged, then an array of filenames may be passed
    into the function as a first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In a production environment, having minified files is desirable. To have Elixir
    minify both the CSS and JavaScript, add the `--production` option to the gulp
    command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the desired minified output. The default output directory
    is located at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Compiling with Laravel Elixir
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel Elixir is great at performing routine tasks that would otherwise require
    learning scripting languages. The following sections will demonstrate each of
    the various types of compiling that Elixir can perform.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling Sass and Less
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cascading style sheet preprocessors `Less` and `Sass` emerged from the need
    to enhance the capabilities of CSS. It does not contain any variables for example.
    `Less` and `Sass` allow frontend developers take advantage of variables and other
    features that are syntactically familiar. The following code is an example of
    standard CSS. The DOM elements `p` and `li` (paragraph and list item respectively),
    and any element with a `post` class will have a `font-family` Arial, with sans-serif
    as a fallback and black as its color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, using the `Sass` CSS pre-processor, both the font-family and text color
    will be substituted with two variables: `$text-font` and `$text-color`. This allows
    easy maintenance when changes are needed. Also, the variables may be shared. The
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Less` preprocessor uses `@` instead of `$`; therefore, its syntax looks
    more like an annotation than a `php` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There is an extra step that needs to be performed, since it will not be interpreted
    by a browser engine. The added step is to compile the `Less` or `Sass` code into
    real CSS. This introduces extra time in the development phase; thus, Elixir helps
    by automating the process.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous Laravel Elixir example, the `less` function took only the filename,
    `app.less`, as its sole argument. Now, the example should be a bit clearer. Also,
    `less` may take an array of arguments that will be compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `less` method searches in `/resources/assets/less` and the output will
    be placed in `public/css/` by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Compiling CoffeeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CoffeeScript is a programming language that compiles into JavaScript. Like
    Less and Sass, its goal is to simplify or extend the functionality of the language
    that it compiles to. In the case of CoffeeScript, it simplifies Javascript by
    requiring less keystrokes. In the following JavaScript code, two variables—an
    array and an object—are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following CoffeeScript code, the syntax is very similar, but there is
    no semicolon required and there is no need for `var` to create a variable. Also,
    indentation is used to define the object''s attributes. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this CoffeeScript example, there are only a few less characters; however,
    for a programmer, less keystrokes can help increase speed and efficiency. To add
    the coffee compiler to Elixir, simply use the `coffee` function, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A summary of compiler commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table shows the mapping between preprocessor, language, function,
    and where each function expects the source to be. The last column on the right
    shows the directory and/or name of the resultant combined file.
  prefs: []
  type: TYPE_NORMAL
- en: '| processor | Language | function | Source directory | Default Output Location
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Less | CSS | `less()` | `/resources/assets/less/file(s).less` | `/public/css/file(s).css`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sass | CSS | `sass()` | `/resources/assets/sass/file(s).scss` | `/public/css/file(s).css`
    |'
  prefs: []
  type: TYPE_TB
- en: '| N/A | CSS | `styles()` | `/resources/assets/css/` | `/public/css/all.css`
    |'
  prefs: []
  type: TYPE_TB
- en: '| N/A | JavaScript | `scripts()` | `/resources/assets/js/` | `/public/js/all.js`
    |'
  prefs: []
  type: TYPE_TB
- en: '| CoffeeScript | JavaScript | `coffee()` | `/resources/assets/coffee/` | `/public/js/app.js`
    |'
  prefs: []
  type: TYPE_TB
- en: Saving with a different name
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Optionally, each method takes a second parameter that will override the default
    location. To use a different directory, (in this case, a directory called `app`),
    simply add the directory as a second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the files will be saved at `public/app/jsand public/app/css`.
  prefs: []
  type: TYPE_NORMAL
- en: Putting everything together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let''s put everything together to draw an interesting conclusion.
    Since CoffeeScript scripts and `less` and `sass` files are not merged but copied
    into the destination directly, we first save the CoffeeScript, `less`, and `sass`
    files into the directories where Elixir expects the JavaScript and CSS files to
    be. Then, we instruct Elixir to merge and minify all of the JavaScript and CSS
    files into two merged and minified files. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is extremely important to remember that Elixir overwrites files without verifying
    that the file exists, so a unique name would need to be chosen for each of the
    files. When the command is finished, `all.js` and `all.css` will be merged and
    minified in the `public/js` and `public/css` directories.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests with Elixir
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to compiling and sending notifications, Elixir may also be used
    to automate the launching of tests. The following sections will discuss how Elixir
    can be used for both PHPSpec and PHPUnit.
  prefs: []
  type: TYPE_NORMAL
- en: PHPSpec
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step would be to run the PHPSpec tests to automate code testing.
    By adding `phpSpec()` to our `gulpfile.js` as follows, PHPSpec tests will run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot. The PHPSpec output is maintained,
    so the test output is very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PHPSpec](graphics/B04559_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the PHPSpec tests fail, the results are easily readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PHPSpec](graphics/B04559_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of Laravel Elixir's output
  prefs: []
  type: TYPE_NORMAL
- en: In this example, phpspec encountered an error in the **it creates a reservation
    test** line as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: PHPUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, we may add PHPUnit to our suite of tests by adding `phpUnit` to
    the list of tasks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Creating custom tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Elixir gives us the ability to create custom tasks to do virtually anything.
    One example of a custom task that we could write is to scan the controllers for
    annotations. All custom tasks require `gulp` and `laravel-elixir`. It is important
    to remember that the programming language used is JavaScript, so the syntax may
    or may not be familiar, but it is easy enough to learn quickly. If commands will
    be executed from the command-line interface, then we shall also import gulp-shell.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we first extend Elixir and give the method a name, for example,
    `routeScanning`. Then, a gulp task is defined and the first argument to the `task`
    method is the name of the command. The second command is a closure containing
    the code that will be executed and returned.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the task is queued for execution by passing the name of the command
    into the `queueTask` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this script to our chain as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `pipe` function allows chaining of commands, it is easy to add in
    a notification that will alert the notification system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Notification` class is pulled in and a new notification is created
    to send the message `Annotations scanned.` to the notification system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code produces the following output. Notice that the `gulp-notify`
    has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Setting up a file watcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Obviously, running gulp every time we want to compile the cascading style sheets
    or scan for annotations is tedious. Fortunately, a watcher mechanism is built
    into Elixir. To invoke it, simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow any tasks that have been placed into the `gulpfile.js` chain
    to automatically run when certain changes occur. The code necessary to enable
    this in the annotation task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code registers a watch. The first argument is the `routeScanning`
    task. The second command is the directory pattern that will be watched for modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Since we know that route annotations will be inside the controllers, we may
    set the path to look only inside the `app/Http/Controllers/` directory. The regex
    style syntax will match on any file with a `php` extension in any one of the directories
    that are located under controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, whenever a file matching the pattern is modified, the `routeScanning` task,
    as well as any other tasks that are watching files that match the same pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Laravel Elixir tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The npm website provides more than 75 tasks that deal with testing, JavaScript,
    CSS, and more. The `npm` website is located at [http://npmjs.com](http://npmjs.com).
  prefs: []
  type: TYPE_NORMAL
- en: '![Additional Laravel Elixir tasks](graphics/B04559_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the npm website containing many useful Laravel Elixir tasks
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how Elixir's growing task list can help both the
    full-stack developer as well as a team of developers. Some of the tasks are related
    to frontend development, such as compiling, combining, and minifying CSS and JavaScript.
    Other tasks are related to backend development, such as behavior-driven development.
    Integrating these tasks into the daily development workflow will make it easy
    for the entire team to understand the steps that are necessary in the continuous
    integration server, where Elixir will execute its tasks, such as testing and compiling,
    to prepare the files for development into production.
  prefs: []
  type: TYPE_NORMAL
- en: Since Elixir is built upon gulp, the future of the Elixir will continue to be
    enriched as both the gulp and Elixir communities continue to grow and new contributors
    continue contributing to Elixir.
  prefs: []
  type: TYPE_NORMAL
