- en: Containers and Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Counting frequencies—count occurrences of any hashable value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary with fallback—have a fallback value for any missing key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unpacking multiple—keyword arguments—how to use `**` more than once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordered dictionaries—maintaining order of keys in a dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MultiDict—dictionary with multiple values per key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritizing entries—efficiently get the top of sorted entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bunch—dictionaries that behave like objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations—handle a known set of states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has a very easy and flexible set of built-in containers. As a Python
    developer, there is little you can't achieve with a `dict` or a `list`. The convenience
    of Python dictionaries and lists is such that developers often forget that those
    have limits. Like any data structure, they are optimized and designed for specific
    use cases and might be inefficient in some conditions, or even unable to handle
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Ever tried to put a key in a dictionary twice? Well you can't, because Python
    dictionaries are designed as hash tables with unique keys, but the *MultiDict*
    recipe will show you how to do that. Ever tried to grab the lowest/highest values
    out of a list without traversing it whole? The list itself can't, but in the *Prioritized entries* recipe,
    we will see how to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: The limits of standard Python containers are well known to Python experts. For
    that reason, the standard library has grown over the years to overcome those limits,
    and frequently there are patterns so common that their name is widely recognized,
    even though they are not formally defined.
  prefs: []
  type: TYPE_NORMAL
- en: Counting frequencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common need in many kinds of programs is to count the occurrences of
    a value or of an event, which means counting frequency. Be it the need to count
    words in text, count likes on a blog post, or track scores for players of a video
    game, in the end counting frequency means counting how many we have of a specific
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious solution for such a need would be to keep around counters for
    the things we need to count. If there are two, three, or four, maybe we can just
    track them in some dedicated variables, but if there are hundreds, it's certainly
    not feasible to keep around such a large amount of variables and we will quickly
    end up with a solution based on a container to collect all those counters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to track the frequency of words in text; the standard library
    comes to our rescue and provides us with a very good way to track counts and frequencies,
    which is through the dedicated `collections.Counter` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `collections.Counter` object not only keeps track of frequencies, but provides
    some dedicated methods to retrieve the most common entries, entries that appear
    at last once and quickly count any iterable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Any iterable you provide to the `Counter` is "counted" for its frequency of
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The result would be exactly what we expect, a dictionary with the frequencies
    of the words in our phrase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can easily query for the most frequent words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the frequency of a specific word:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, get back the total number of occurrences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can even apply some set operations on counters, such as joining them,
    subtracting them, or checking for intersections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our counting code relies on the fact that `Counter` is just a special kind of
    dictionary, and that dictionaries can be built by providing an iterable. Each
    entry in the iterable will be added to the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a counter, adding an element means incrementing its count; for
    every "word" in our list, we add that word multiple times (one every time it appears
    in the list), so its value in the `Counter` continues to get incremented every
    time the word is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relying on `Counter` is actually not the only way to track frequencies; we already
    know that `Counter` is a special kind of dictionary, so reproducing the `Counter`
    behavior should be quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably every one of us came up with a dictionary in this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever we face a new occurrence of `hello`, `world`, `nice`, or `day`, we
    increment the associated value in the dictionary and call it a day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By relying on `dict.get`, we can also easily adapt it to count any word, not
    just those we could foresee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: But the standard library actually provides a very flexible tool that we can
    use to improve this code even further, `collections.defaultdict`.
  prefs: []
  type: TYPE_NORMAL
- en: '`defaultdict` is a plain dictionary that won''t throw `KeyError` for any missing
    value, but will call a function we can provide to generate the missing value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, something such as `defaultdict(int)` will create a dictionary that provides
    `0` for any key that it doesn''t have, which is very convenient for our counting
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be exactly what we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As for each word, the first time we face it, we will call `int` to get the starting
    value and then add `1` to it. As `int` gives `0` when called without any argument,
    that achieves what we want.
  prefs: []
  type: TYPE_NORMAL
- en: While this roughly solves our problem, it's far from being a complete solution
    for counting—we track frequencies, but on everything else, we are on our own.
    What if we want to know the most frequent entry in our bag of words?
  prefs: []
  type: TYPE_NORMAL
- en: The convenience of `Counter` is based on the set of additional features specialized
    for counting that it provides; it's not just a dictionary with a default numeric
    value, it's a class specialized in keeping track of frequencies and providing
    convenient ways to access them.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary with fallback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with configuration values, it's common to look them up in multiple
    places—maybe we load them from a configuration file—but we can override them with
    an environment variable or a command-line option, and in case the option is not
    provided, we can have a default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can easily lead to long chains of `if` statements like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is annoying, and while for a single value it might be just annoying, it
    will tend to grow into a huge, confusing list of conditions as more options get
    added.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line options are a very frequent use case, but the problem is related
    to chained scopes resolution. Variables in Python are resolved by looking at `locals()`;
    if they are not found, the interpreter looks at `globals()`, and if they are not
    yet found, it looks for built-ins.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this step, you need to go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The alternative for chaining default values of `dict.get`, instead of using
    multiple `if` instances, probably wouldn't improve much the code and if we want
    to add one additional scope, we would have to add it in every single place where
    we are looking up the values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`collections.ChainMap` is a very convenient solution to this problem; we can
    provide a list of mapping containers and it will look for a key through them all.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our previous example involving multiple different `if` instances can be converted
    to something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also get rid of the last `.get` call by combining `ChainMap` with `defaultdict`.
    In this case, we can use `defaultdict` to provide a default value for every key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Print `value` and `value2` will result in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`optname` will be retrieved from the `command_line_options` containing it,
    while `other-option` will end up being resolved by `defaultdict`.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ChainMap` class receives multiple dictionaries as arguments; whenever a
    key is requested to `ChainMap`, it's actually going through the provided dictionaries
    one by one to check whether the key is available in any of them. Once the key
    is found, it is returned, as if it was a key owned by `ChainMap` itself.
  prefs: []
  type: TYPE_NORMAL
- en: The default value for options that are not provided is implemented by having
    `defaultdict` as the last dictionary provided to `ChainMap`. Whenever a key is
    not found in any of the previous dictionaries, it gets looked up in `defaultdict`,
    which uses the provided factory function to return a default value for all keys.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another great feature of `ChainMap` is that it allows updating too, but instead
    of updating the dictionary where it found the key, it always updates the first
    dictionary. The result is the same, as on next lookup of that key, we would have
    the first dictionary override any other value for that key (as it''s the first
    place where the key is checked). The advantage is that if we provide an empty
    dictionary as the first mapping provided to `ChainMap`, we can change those values
    without touching the original container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But even though we changed the population of Japan to 128 million, the original
    population didn''t change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can even use `changes` to find out which values were changed and which
    values were not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to know, by the way, that if the object contained in the dictionary
    is mutable and we directly mutate it, there is little `ChainMap` can do to avoid
    mutating the original object. So if, instead of numbers, we store lists in the
    dictionaries, we will be mutating the original dictionary whenever we append values
    to the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Unpacking multiple keyword arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frequently, you ended up in a situation where you had to provide arguments to
    a function from a dictionary. If you've ever faced that need, you probably also
    ended up in a case where you had to take the arguments from multiple dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, Python functions accept arguments from a dictionary through unpacking
    (the `**` syntax), but so far, it hasn't been possible to use unpacking twice
    in the same call, nor was there an easy way to merge two dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a function, `f`, we want to pass the arguments from two dictionaries, `d1` and
    `d2` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`collections.ChainMap` can help us achieve what we want; it can cope with duplicated
    entries and works with any Python version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python 3.5 and newer versions, you can also create a new dictionary by combining
    multiple dictionaries through the literal syntax, and then pass the resulting
    dictionary as the argument of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the duplicated entries are accepted too, but are handled in reverse
    order of priority to `ChainMap` (so right to left). Notice how `b` has a value
    of `7`, instead of the `6` it had with `ChainMap`, due to the reversed order of
    priorities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This syntax might be harder to read due to the amount of unpacking operators
    involved, and with `ChainMap` it is probably more explicit what's happening for
    a reader.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know from the previous recipe, `ChainMap` looks up keys in all
    the provided dictionaries, so it's like the sum of all the dictionaries. The unpacking operator (`**`)
    works by inviting all keys to the container and then providing an argument for
    each key.
  prefs: []
  type: TYPE_NORMAL
- en: As `ChainMap` has keys resulting from the sum of all the provided dictionaries
    keys, it will provide the keys contained in all the dictionaries to the unpacking
    operator, thus allowing us to provide keyword arguments from multiple dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Python 3.5 through PEP 448, it''s now possible to unpack multiple mappings
    to provide keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution is very convenient, but has two limits:'
  prefs: []
  type: TYPE_NORMAL
- en: It's only available in Python 3.5+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It chokes on duplicated arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you don''t know where the mappings/dictionaries you are unpacking come from,
    it''s easy to end up with the issue of duplicated arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the `b` key is declared in both `d1` and `d2`, and
    that causes the function to complain that it received duplicate arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Ordered dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most surprising aspects of Python dictionaries for new users is that
    their order is unpredictable and can change from environment to environment. So,
    the order of keys you expected on your system might be totally different on your
    friend's computer.
  prefs: []
  type: TYPE_NORMAL
- en: This frequently causes unexpected failures during tests; if a continuous integration
    system is involved, the ordering of dictionary keys on the system running the
    tests can be different from the ordering on your system, which might lead to random
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a snippet of code that generates an HTML tag with some attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It might surprise you that on some systems you end up with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'While on others, the result might be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So, if you expect to be able to compare the resulting string to check whether
    your function did the right thing when generating this tag, you might be disappointed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keys ordering is a very convenient feature and in some cases, it's actually
    necessary, so the Python standard library comes to help and provides the `collections.OrderedDict`
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `collections.OrderedDict`, the keys are always in the order
    they were inserted in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`OrderedDict` stores both a mapping of the keys to their values and a list
    of keys that is used to preserve the order of them.'
  prefs: []
  type: TYPE_NORMAL
- en: So whenever your look for a key, the lookup goes through the mapping, but whenever
    you want to list the keys or iterate over the container, you go through the list
    of keys to ensure they are processed in the order they were inserted in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main problem when using `OrderedDict` is that Python on versions before
    3.6 didn''t guarantee any specific order of keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This would have again introduced a totally random order of keys even though
    `OrderedDict` was used. Not because `OrderedDict` didn't preserve the order of
    those keys, but because it would have received them in a random order.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to PEP 468, the order of arguments is now guaranteed in Python 3.6 and
    newer versions (the order of dictionaries is still not, remember; so far it's
    just by chance that they are ordered). So if you are using Python 3.6 or newer,
    our previous example would work as expected, but if you are on older versions
    of Python, you would end up with a random order.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, this is an issue that is easily solved. Like standard dictionaries,
    `OrderedDict` supports any iterable as the source of its content. As long as the
    iterable provides a key and a value, it can be used to build `OrderedDict`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So by providing the keys and values in a tuple, we can provide them at construction
    time and preserve the order in any Python version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python 3.6 introduced a guarantee of preserving the order of dictionary keys
    as a side effect of some changes to dictionaries, but it was considered an internal
    implementation detail and not a language guarantee. Since Python 3.7, it became
    an official feature of the language so it's actually safe to rely on dictionary
    ordering if you are using Python 3.6 or newer.
  prefs: []
  type: TYPE_NORMAL
- en: MultiDict
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever need to provide a reverse mapping, you have probably discovered
    that Python lacks a way to store more than a value for each key in a dictionary.
    This is a very common need, and most languages provide some form of multimap container.
  prefs: []
  type: TYPE_NORMAL
- en: Python tends to prefer having a single way of doing things, and as storing multiple
    values for the key means just storing a list of values for a key, it doesn't provide
    a specialized container.
  prefs: []
  type: TYPE_NORMAL
- en: The issue with storing a list of values is that to be able to append to values
    to our dictionary, the list must already exist.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Proceed with the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already know, `defaultdict` will create a default value by calling the
    provided callable for every missing key. We can provide the `list` constructor
    as a callable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we insert keys into our multimap by using `rd[k].append(v)` instead of
    the usual `rd[k] = v`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MultiDict` works by storing a list for each key. Whenever a key is accessed,
    the list containing all the values for that key is retrieved.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of missing keys, an empty list will be provided so that values can
    be added for that key.
  prefs: []
  type: TYPE_NORMAL
- en: This works because every time `defaultdict` faces a missing key, it will insert
    it with a value generated by calling `list`. And calling `list` will actually
    provide an empty list. So, doing `rd[v]` will always provide a list, empty or
    not, depending on whether `v` was an already existing key or not. Once we have
    our list, adding a new value is just a matter of appending it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dictionaries in Python are associative containers where keys are unique. A key
    can appear a single time and has exactly one value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to support multiple values per key, we can actually solve the need
    by saving `list` as the value of our key. This list can then contain all the values
    we want to keep around for that key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to add a new translation to `2` (Spanish, for example), we would
    just have to append the entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem arises when we want to introduce a new key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For key `4`, no list exists, so there is nowhere we can append it. So, our
    snippet to automatically reverse the mapping can''t be easily adapted to handle
    multiple values, as it would fail with key errors the first time it tries to insert
    a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Checking for every single entry, whether it's already in the dictionary or not,
    and acting accordingly is not very convenient. While we can rely on the `setdefault`
    method of dictionaries to hide that check, we can get a far more elegant solution
    by using `collections.defaultdict`.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing entries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Picking the first/top entry of a set of values is a pretty frequent need; this
    usually means defining one value that has priority over the other and involves
    sorting.
  prefs: []
  type: TYPE_NORMAL
- en: But sorting can be expensive and re-sorting every time you add an entry to your
    values is certainly not a very convenient way to pick the first entry out of a
    set of values with some kind of priority.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Heaps are a perfect match for everything that has priorities, such as a priority
    queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, our `PriorityQueue` can be used to retrieve entries given a priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PriorityQueue` works by storing everything in an heap. Heaps are particularly
    efficient at retrieving the top/first element of a sorted set without having to
    actually sort the whole set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our priority queue stores all the values in a three-element tuple: `priority`,
    `time.time()`, and `value`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first entry of our tuple is `priority` (lower is better). In the example,
    we recorded `f1` with a better priority than `f2`, which ensures than when we
    use `heap.heappop` to fetch tasks to process, we get `f1` and then `f2`, so that
    we end up with the `hello world` message and not `world hello`.
  prefs: []
  type: TYPE_NORMAL
- en: The second entry, `timestamp`, is used to ensure that tasks that have the same
    priority are processed in their insertion order. The oldest task will be served
    first as it will have the smallest timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the value itself, which is the function we want call for our task.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common approach to sorting is to keep a list of entries in a tuple, where
    the first element is `key` for which we are sorting and the second element is
    the value itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a scoreboard, we can keep each player''s name and how many points they
    got:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Storing those values in tuples works because comparing two tuples is performed
    by comparing each element of the first tuple with the element in the same index
    position in the other tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It's very easy to understand what's going on if you think about strings. `'BB'
    > 'BB'` is the same as `('B', 'B') > ('B', 'A')`; in the end, a string is just
    a list of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this property to sort our `scores` and retrieve the winner of a
    competition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The major problem with this approach is that every time we add an entry to
    our list, we have to sort it again, or our scoreboard would became meaningless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is very inconvenient because it's easy to miss re-sorting somewhere if
    we have multiple places appending to the list, and sorting the whole list every
    time can be expensive.
  prefs: []
  type: TYPE_NORMAL
- en: The Python standard library offers a data structure that is a perfect match
    when we're interested in finding out the winner of a competition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `heapq` module, we have a fully working implementation of a heap data
    structure, a particular kind of tree where each parent is smaller than its children.
    This provides us with a tree that has a very interesting property: the root element
    is always the smallest one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And being implemented on top of a list, it means that `l[0]` is always the
    smallest element in a `heap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed, by the way, that the heap finds the loser of our tournament,
    not the winner, and we were interested in finding the best player, with the highest
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a minor problem we can easily solve by storing all scores as negative
    numbers. If we store each score as `* -1`, the head of the heap will always be
    the winner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Bunch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is very good at shapeshifting objects. Each instance can have its own
    attributes and it's absolutely legal to add/remove the attributes of an object
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Once in a while, our code needs to deal with data of unknown shapes. For example,
    in the case of a user-submitted data, we might not know which fields the user
    is providing; maybe some of our users have a first name, some have a surname,
    and some have one or more middle name fields.
  prefs: []
  type: TYPE_NORMAL
- en: If we are not processing this data ourselves, but are just providing it to some
    other function, we really don't care about the shape of the data; as long as our
    objects have those attributes, we are fine.
  prefs: []
  type: TYPE_NORMAL
- en: A very common case is when working with protocols, if you are an HTTP server,
    you might want to provide to the application running behind you a `request` object.
    This object has a few known attributes, such as `host` and `path`, and it might
    have some optional attributes, such as a `query` string or a `content` type. But,
    it can also have any attribute the client provided, as HTTP is pretty flexible
    regarding headers, and our clients could have provided an `x-totally-custom-header`
    that we might have to expose to our code.
  prefs: []
  type: TYPE_NORMAL
- en: When representing this kind of data, Python developers often tend to look at
    dictionaries. In the end, Python objects themselves are built on top of dictionaries
    and they fit the need to map arbitrary values to names.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will probably end up with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: A side effect of this approach is pretty clear once we have to pass this object
    around, especially to third-party code. Functions usually work with objects, and
    while they don't require a specific kind of object as duck-typing is the standard
    in Python, they will expect certain attributes to be there.
  prefs: []
  type: TYPE_NORMAL
- en: Another very common example is when writing tests, Python being a duck-typed
    language, it's absolutely reasonable to want to provide a fake object instead
    of providing a real instance of the object, especially when we need to simulate
    the values of some properties (as declared with `@property`), so we don't want
    or can't afford to create real instances of the object.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, using a dictionary is not viable as it will only provide access
    to its values through the `request['path']` syntax and not through `request.path`,
    as probably expected by the functions we are providing our object to.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the more we end up accessing this value, the more it's clear that the
    syntax using dot notation conveys the feeling of an entity that collaborates to
    the intent of the code, while a dictionary conveys the feeling of plain data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as we remember that Python objects can change shape at any time, we
    might be tempted to try creating an object instead of a dictionary. Unfortunately,
    we won''t be able to provide the attributes at initialization time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Things don''t improve much if we try to assign those attributes after the object
    is built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a little effort, we can create a class that leverages dictionaries to
    contain any attribute we want and allow access both as a dictionary and through
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Bunch` class inherits `dict`, mostly as a way to provide a context where
    values can be stored, then most of the work is done by `__getattribute__` and
    `__setattr__`. So, for any attribute that is retrieved or set on the object, they
    will just retrieve or set a key in `self` (remember we inherited from `dict`,
    so `self` is in fact a dictionary).
  prefs: []
  type: TYPE_NORMAL
- en: This allows the `Bunch` class to store and retrieve any value as an attribute
    of the object. The convenient feature is that it can behave both as an object
    and as a `dict` in most contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, it is possible to find out all the values that it contains, like
    any other dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also able to access those as attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `bunch` implementation is not yet complete, as it will fail any test for
    class name (it's always named `Bunch`) and any test for inheritance, thus failing
    at faking other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to make `Bunch` able to shapeshift not only its properties,
    but also its name. This can be achieved by creating a new class dynamically every
    time we create `Bunch`. The class will inherit from `Bunch` and will do nothing
    apart from providing a new name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Bunch` function moved from being the class itself to being a factory that
    will create objects that all act as `Bunch`, but can have different classes. Each
    `Bunch` will be a subclass of `BunchBase`, where the `_classname` name can be
    provided when `Bunch` is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow us to create as many kinds of `Bunch` objects as we want, and
    each will have its own custom type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to make our `Bunch` actually look like any other type that
    it has to impersonate. That is needed for the case where we want to use `Bunch`
    in place of another object. As `Bunch` can have any kind of attribute, it can
    take the place of any kind of object, but to be able to, it has to pass type checks
    for custom types.
  prefs: []
  type: TYPE_NORMAL
- en: We need to go back to our `Bunch` factory and make the `Bunch` objects not only
    have a custom class name, but also appear to be inherited from a custom parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand what''s going on, we will declare an example `Person`
    type; this type will be the one our `Bunch` objects will try to fake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifically, we are going to print `Hello Your Name` through a custom `print`
    function that only works for `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to change our `Bunch` factory to accept the class and create a new
    type out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `Bunch` objects will appear as instances of a class named what we
    wanted, and will always appear as a subclass of `_parent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`Bunch` can be a very convenient pattern; in both its complete and simplified
    versions, it is widely used in many frameworks with various implementations that
    all achieve pretty much the same result.'
  prefs: []
  type: TYPE_NORMAL
- en: The showcased implementation is interesting because it gives us a clear idea
    of what's going on. There are ways to implement `Bunch` that are very smart, but
    might make it hard to guess what's going on and customize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possible way to implement the `Bunch` pattern is by patching the `__dict__` class,
    which contains all the attributes of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this form, whenever `Bunch` is created, it will populate its values as a
    `dict` (by calling `super().__init__`, which is the `dict` initialization) and
    then, once all the attributes provided are stored in `dict`, it swaps the `__dict__` object, which
    is the dictionary that contains all object attributes, with `self`. This makes
    the `dict` that was just populated with all the values also the `dict` that contains
    all the attributes of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Our previous implementation worked by replacing the way we looked for attributes,
    while this implementation replaces the place where we look for attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumeration is a common way to store values that can only represent a few states.
    Each symbolic name is bound to a specific value, usually numeric, that represents
    the states the enumeration can have.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations are very common in other programming languages, but until recently,
    Python didn't have any explicit support for enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, enumerations are implemented by mapping symbolic names to numeric
    values; this is allowed in Python through `enum.IntEnum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IntEnum` is an integer, apart from the fact that all possible values are created
    when the class is defined. `IntEnum` inherits from `int`, so its values are real
    integers.'
  prefs: []
  type: TYPE_NORMAL
- en: During the `RequestType` definition, all the possible values for `enum` are
    declared within the class body and the values are verified against duplicates
    by the metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: Also, `enum` provides support for a special value, `auto`, which means *just
    put in a value, I don't care*. As you usually only care whether it's `POST` or
    `GET`, you usually don't care whether `POST` is `1` or `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, enumerations cannot be subclassed if they define at least
    one possible value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IntEnum` values behave like `int` in most cases, which is usually convenient,
    but they can cause problems if the developer doesn''t pay attention to the type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a function might unexpectedly perform the wrong thing if another
    enumeration or an integer value is provided, instead of the proper enumeration
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, invoking `do_request` with `RequestType.POST` or `1` will do
    exactly the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When we want to avoid treating our enumerations as numbers, we can use `enum.Enum`,
    which provides enumerated values that are not considered plain numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: So generally, if you need a simple set of enumerated values or possible states
    that rely on `enum`, `Enum` is safer, but if you need a set of numeric values
    that rely on `enum`, `IntEnum` will ensure that they behave like numbers.
  prefs: []
  type: TYPE_NORMAL
