- en: A Matchmaking App with a Rich UX Using Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create the base functionality for a matchmaking app.
    We won't be rating people, however, because of privacy issues. Instead, we will
    download images from a random source on the internet. This project is for anyone
    who wants an introduction to how to write reusable controls. We will also look
    at using animations to make our application feel nicer to use. This app will not
    be an MVVM application, since we want to isolate the creation and usage of a control
    from the slight overhead of MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to style the app to look like a photo with descriptive text beneath it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animations using Xamarin.Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribing to custom events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing the custom control over and over again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling pan gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to complete this project, you will need to have Visual Studio for
    Mac or Windows installed, as well as the necessary Xamarin components. See [Chapter
    1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction to Xamarin*, for
    more details on how to set up your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many of us have been there, faced with the conundrum to swipe left or right.
    All of a sudden, you may find yourself wondering: how does this work? How does
    the swipe magic happen? Well, in this project, we''re going to learn all about
    it. We will start by defining a `MainPage` file, in which the images of our application
    will reside. After that, we will create the image control and gradually add the
    GUI and functionality to it until we have nailed the perfect swiping experience.'
  prefs: []
  type: TYPE_NORMAL
- en: The build time for this project is about 90 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the matchmaking app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will learn more about creating reusable controls that can
    be added to a XAML page. To keep things simple, we will not be using MVVM, but
    bare-metal Xamarin.Forms without any data binding. What we aim to create is an
    app that allows the user to swipe images, either to the right or the left, just
    like most popular matchmaking applications do.
  prefs: []
  type: TYPE_NORMAL
- en: Well, let's get started by creating the project!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as with the to-do list app in [Chapter 2](17d85c89-a26f-440a-9591-a859915936a8.xhtml), *Building
    our First Xamarin.Forms App,* this chapter will start with a clean File | New
    Project approach. We are going to opt for a .NET Standard approach rather than
    a shared code approach in this chapter; please refer back to [Chapter 2](17d85c89-a26f-440a-9591-a859915936a8.xhtml)*,
    Building our First Xamarin.Forms App* to gain more insight into the differences
    between them if you're not sure why we're doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open up Visual Studio and click on File | New| Project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c4f5dc4-6442-4bb5-b899-ac02fcd8589a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will open up the New Project dialog. Expand the Visual C# node and click
    on Cross-Platform. Select the Mobile App (Xamarin.Forms) item from the list. Complete
    the form by naming your project. We will be calling our application `Swiper` in
    this case. Move on to the next dialog by clicking OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dd491eb-f2d5-4c88-b17d-e476c30252a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to select a project template and a Code Sharing Strategy.
    Select Blank to create a bare minimum Xamarin.Forms app and make sure that the
    Code Sharing Strategy is set to .NET Standard. Finish the setup wizard by clicking
    OK and let Visual Studio scaffold the project for you. This might take a couple
    of minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7b99529-fb5f-4e21-9645-2a0355e5a7f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Just like that, the app is created. Let's move on to updating Xamarin.Forms
    to the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Xamarin.Forms NuGet packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, the Xamarin.Forms version that your project will be created with
    is most likely a bit old. To rectify this, we need to update the NuGet Packages.
    Please note that you should only update the Xamarin.Forms packages and not the
    Android packages; doing the latter might cause your packages to get out of sync
    with each other, resulting in the app not building at all. To update the NuGet
    packages, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on our Solution in the Solution Explorer**.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Manage NuGet Packages for Solution...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/06856d6f-77d3-495c-a68b-027bd539551a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will open the NuGet Package Manager in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4b51aa2-5c58-477b-91ec-c03889265b91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To update Xamarin.Forms to the latest version, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the Updates tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check Xamarin.Forms and click Update**.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept any license agreements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The update takes at most a few minutes. Check the output pane to find information
    about the update. At this point, we can run the app to make sure it works. We
    should see the text Welcome to Xamarin.Forms! in the middle of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f88d39be-89c8-4780-ac84-18b8c6582c74.png)'
  prefs: []
  type: TYPE_IMG
- en: Designing the MainPage  file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A brand new blank Xamarin.Forms app named `Swiper` is created with a single
    page called `MainPage.xaml`. This is located in the .NET Standard Project that
    is referenced by all platform-specific projects. We will need to replace the XAML template
    with a new layout that will contain our `Swiper` control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit the already existing `MainPage.xaml` file by replacing the default
    content with what we need:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainPage.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content of the page with the following XAML code marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The XAML within the `ContentPage` node defines two grids in the application.
    A grid is simply a container for other controls. It positions those controls based
    on rows and columns. The outer grid, in this case, defines two rows that will
    cover the entire available area of the screen. The first row is `400` units high
    and the second row, with `height="*"`, uses the rest of the available space.
  prefs: []
  type: TYPE_NORMAL
- en: The inner grid, which is defined within the first grid, is assigned to the second
    row with the attribute `Grid.Row="1"`. The row and column indexes are zero-based,
    so `"1"` actually refers to the second row. We will add some content to this grid
    later on in the chapter, but we'll leave it empty for now.
  prefs: []
  type: TYPE_NORMAL
- en: Both grids define their padding. You could enter a single number, meaning that
    all sides will have the same padding, or as in this case, enter two numbers. We
    have entered `0,40`, which means that the left and right sides should have zero
    units of padding and the top and bottom should have `40` units of padding. There
    is also a third option with four digits, which sets the padding of the *left*
    side, the *top*, the *right* side, and the *bottom*, in that specific order.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to notice is that we give the outer grid a name, `x:Name="MainGrid"`.
    This will make it directly accessible from the code-behind defined in the `MainPage.xaml.cs`
    file. Since we are not using MVVM in this example, we will need a way to access
    the grid without data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Swiper control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main part of this project involves creating the `Swiper` control. A control
    is a self-contained UI with a code-behind to go with it. It can be added to any
    XAML page as an element or in code in the code-behind file. We will be adding
    the control from code in this project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating the `Swiper` control is a straightforward process. We just need to
    make sure that we select the correct item template, which is the Content View:'
  prefs: []
  type: TYPE_NORMAL
- en: In the .NET Standard library project, create a folder called `Controls`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Controls` folder, select Add, and then click New item....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Visual C# Items and then Xamarin.Forms in the left pane of the Add New
    Item dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Content View (C#) item. Make sure you don't select the C# version;
    this only creates a `C#` file and not an `XAML` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the control `SwiperControl.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Add**:**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b193f73c-c111-45c4-ba8c-bcf13b827ac8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This adds an XAML file for the UI and a C# code-behind file. It should look
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2dfdd5eb-85b8-4b27-a121-856276cff123.png)'
  prefs: []
  type: TYPE_IMG
- en: Defining the main grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set the basic structure of the `Swiper` control:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SwiperControl.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content with the code marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This defines a grid with three columns. The leftmost and the rightmost columns
    will take up `100` units of space and the center will occupy the rest of the available
    space. The spaces on the sides will be areas in which we will add labels to highlight
    the choice that the user has made. We've also added three comments that act as
    placeholders for the XAML to come.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a content view for the photo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now extend the `SwiperControl.xaml` file by adding a definition of
    what we want the photo to look like. Our final result will look like the following
    photo. Since we are going to pull images off the internet, we''ll display a loading
    text to make sure that the user gets feedback on what''s going on. To make it
    look like an instantly printed photo, we add some handwritten text under the photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc24bad2-9388-46f0-b350-a800700d8816.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding photo is what we would like the photo to look like. To make it
    a reality, we need to add some XAML to the `SwiperControl`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `SwiperControl.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the XAML in bold to the following comment: `<!-- ContentView for photo
    here -->`. Make sure that you do not replace the entire `ContentView` for the
    page; just add this under the comment as follows. The rest of the page should
    be untouched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A `ContentView` control defines a new area where we can add other controls.
    One very important feature of a `ContentView` is that it only takes one child
    control. Most of the time, we would add one of the layout controls that are available.
    In this case, we'll use a `Grid` control to lay out the control, as shown in the
    preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The grid defines two rows:'
  prefs: []
  type: TYPE_NORMAL
- en: A row for the photo itself, which takes up all the available space when the
    other rows have been allocated space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A row for the comment, which will be exactly `40` units in height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Grid` itself is set to use a black background and a padding of `1`. This,
    in combination with a `BoxView`, which has a white background, creates the frame
    that we see around the control. The `BoxView` is also set to span both rows of
    the grid (`Grid.RowSpan="2"`), taking up the entire area of the grid, minus the
    padding.
  prefs: []
  type: TYPE_NORMAL
- en: The `Image` control comes next. It has a background color set to a nice gray
    tone (`#AAAAAA`) and a margin of `40`, which will separate it a bit from the frame
    around it. It also has a hardcoded name (`x:Name="image"`), which will allow us
    to interact with it from the code-behind. The last attribute, called `Aspect`,
    determines what we should do if the image control isn't of the same ratio as the
    source image. In this case, we want to fill the entire image area, but not show
    any blank areas. This effectively crops the image either in height or in width.
  prefs: []
  type: TYPE_NORMAL
- en: We finish off by adding two labels, which also have hardcoded names for later
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the DescriptionGenerator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the bottom of the image, we see a description. Since we don''t have any
    general descriptions of the images from our upcoming image source, we need to
    create a generator that makes up descriptions. Here''s how we would do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `Utils` in the .NET Standard project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `DescriptionGenerator` in that folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `using` statement for `System.Linq` (`using System.Linq;`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This class only has one purpose. It takes one random word from the `_adjectives`
    array and combines it with a random word from the `_other` array. By calling the
    `Generate()` method, we get a fresh new combination. Feel free to enter your own
    words in the arrays. Note that the `Random` instance is a static field. This is
    because if we create new instances of the `Random` class that are too close to
    each other in time, they get seeded with the same value and return the same sequence
    of random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a picture class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To abstract all the information about the image we want to display, we''ll
    create a class that encapsulates this information. There isn''t much information
    in our `Picture` class, but it is good coding practice to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `Picture` in the `Utils` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Picture` class has two public properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Uri` of an image, which points to its location on the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The description of that image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the constructor, we create a new **Uniform Resource Identifier** (**URI**),
    which points to a public source of test photos that we can use. The width and
    height are specified in the query string part of the URI. We also append a random
    timestamp to avoid the images being cached by Xamarin.Forms. This generates a
    unique URI each time we request an image.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `DescriptionGenerator` class that we created to generate a random
    description for the image.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the picture to the control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin to wire up the `Swiper` control so that it starts displaying images.
    We need to set the source of an image and then control the visibility of the loading
    label based on the status of the image. Since we are using an image fetched from
    the internet, it might take a couple of seconds to download. This has to be communicated
    to the user to avoid confusion about what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We begin by setting the source of the image. The `image` control (referred to
    as `image` in the code) has a `source` property. This property is of the abstract
    type, `ImageSource`. There are a few different types of image sources that you
    can use. The one we are interested in is the `UriImageSource`, which takes a URI,
    downloads the image, and allows the image control to display it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the `Swiper` control to set the source and description:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Controls/Swiper.Xaml.cs` file (the code-behind for the `Swiper` control).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a using statement for `Swiper.Utils` (`using Swiper.Utils;`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code marked in bold to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We create a new instance of a `Picture` class and assign the description to
    the `descriptionLabel` in the GUI by setting the text property of that control.
    We then set the source of the image to a new instance of a `UriImageSource` class
    and assign the URI from the picture instance. This will start the download of
    the image from the internet and display it as soon as it is downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the loading label
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the image is downloading, we want to show a loading text centered over
    the image. This is already in the XAML file that we created earlier, so what we
    really need to do is hide it once the image is downloaded. We will do this by
    controlling the `IsVisibleProperty` of the `loadingLabel` by setting a binding
    to the `IsLoading` property of the image. Any time the `IsLoading` property is
    changed on the image, the binding changes the `IsVisible` property on the label.
    This is a nice fire-and-forget approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the code needed to control the loading label:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Swiper.xaml.cs` code-behind file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code marked in bold to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `loadingLabel` sets a binding to the `IsVisibleProperty`,
    which actually belongs to the `VisualElement` class that all controls inherit
    from. It tells the `loadingLabel` to listen to changes in the `IsLoading` property
    of whichever object is assigned to the binding context. In this case, this is
    the `image` control.
  prefs: []
  type: TYPE_NORMAL
- en: Handling pan gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A core feature of this app is the pan gesture. A pan gesture is when a user
    presses on the control and moves it around the screen. We will also add a random
    rotation to the `Swiper` control to make it look like there are photos in a stack
    when we add multiple images.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by adding some fields to the `SwiperControl`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SwiperControl.xaml.cs`  file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following fields in the code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first field, `_initialRotation`, stores the initial rotation of the image.
    We will set this in the constructor. The second field is a `static` field containing
    a `Random` object. As you might remember, it's better to create one static random
    object to make sure multiple random objects don't get created with the same seed.
    The seed is based on time, so if we create objects too close in time to each other,
    they get the same random sequence generated, so it wouldn't actually be that random
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we have to do is create an event handler for the `PanUpdated`
    event that we will bind to at the end of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SwiperControl.xaml.cs` code-behind file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnPanUpdated` method to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code is really straightforward. We handle an event that takes a `PanUpdatedEventArgs`
    object as the second argument. This is a standard method of handling events. We
    then have a `switch` clause that checks which status the event refers to.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pan gesture can have three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GestureStatus.Started`: The event is raised once with this state when the
    panning begins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GestureStatus.Running`:The event is then raised multiple times, once for each
    time you move your finger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GestureStatus.Completed`:The event is raised one last time when you let go'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each of these states, we call specific methods that handle the different
    states. We''ll continue with adding those methods now:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SwiperControl.xaml.cs` code-behind file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add these three methods to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's start by looking at `PanStarted()`. When the user starts dragging the
    image, we want to add the effect of it raising up a little bit over the surface.
    This is done by scaling the image by 10%. Xamarin.Forms has a set of excellent
    functions to do this. In this case, we call the `ScaleTo()` method on the image
    control (named `Photo`) and tell it to scale to `1.1`, which corresponds to 10%
    of its original size. We also tell it to do this in a duration of `100` ms. This
    call is also awaitable, which means we can wait for the control to finish animating
    before executing the next call. In this case, we are going to use a fire-and-forget
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have `PanRunning()`, which is called multiple times during the pan
    operation. This takes an argument, which is the `PanUpdatedEventArgs` from the
    event handler that `PanRunning()` is called from. We could also just pass in an
    `X` and a `Y` value as arguments to reduce the coupling of the code. This is something
    that you can experiment with. The method extracts the `X` and `Y` components from
    the `TotalX`/`TotalY` properties of the event and assigns them to the `TranslationX`/`TranslationY`
    properties of the image control. We also adjust the rotation slightly, based on
    how far the image has been moved.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to do is to restore everything to its initial state when the
    image is released. This can be done in `PanCompleted()`. First, we translate (or
    move) the image back to its original local coordinates (`0,0`) in `250` ms. We
    also add an easing function to make it overshoot the target a bit and then animate
    back. We can play around with the different predefined easing functions; these
    are really useful for creating nice animations. We do the same to move the image
    back to its initial rotation. Finally, we scale it back to its original size in
    `250` ms.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now time to add the code in the constructor that will wire up the pan
    gesture and set some initial rotation values:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SwiperControl.xaml.cs` code-behind file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code in bold to the constructor. Note that there is more code in the
    constructor, so don''t copy and paste the whole method, just add the bold text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All Xamarin.Forms controls have a property called `GestureRecognizers`. There
    are different types of gesture recognizers, such as `TapGestureRecognizer` or `SwipeGestureRecognizer`.
    In our case, we are interested in the `PanGestureRecognizer`. We create a new
    `PanGestureRecognizer` and subscribe to the `PanUpdated` event by hooking it up
    to the `OnPanUpdated()` method we created earlier. We then add it to the `Swiper`
    controls, `GestureRecognizers` collection.
  prefs: []
  type: TYPE_NORMAL
- en: We then set an initial rotation of the image and make sure we store it so that
    we can modify the rotation and then rotate it back to the original state.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have all the code written to take the control for a test run:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainPage.xaml.cs.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `using` statement for the `Swiper.Controls` (`using Swiper.Controls;`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code marked in bold to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well with the build, we should end up with an image like the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c04e8f44-09a8-4a7d-9488-46ef907f3e0c.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also drag the image around (pan it). Notice the slight lift effect when
    you begin dragging and the rotation of the image based on the amount of translation,
    which is the total movement. If you let go of the image, it animates back in place.
  prefs: []
  type: TYPE_NORMAL
- en: Creating decision zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A matchmaking app is nothing without those special drop-zones on each side
    of the screen. We want to do a few things here:'
  prefs: []
  type: TYPE_NORMAL
- en: When a user drags an image to either side, text should appear that says *LIKE*
    or *DENY* (the decision zones)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the users drop an image on a decision zone, the app should remove the image
    from the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create the zones by adding some XAML to the `SwiperControl.xaml` file
    and then move on to adding the necessary code to make this happen. It is worth
    noting here that the zones are not actually hotspots for dropping the image, but
    rather for displaying labels on top of the control surface. The actual drop-zones
    are calculated and determined based on how far you drag the image.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Swiper` control has three columns defined. We want to add some kind of
    visual feedback to the user if the image is dragged to either side of the page.
    We will do this by adding a `StackLayout` with a `Label` on each side.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the StackLayout for liking photos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing to do is to add the `StackLayout` for liking photos on the
    right-hand side of the control:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Controls/SwiperControl.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code under the comment `<!-- StackLayout for like here -->`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `StackLayout` is the container of what we want to display. It has a name
    and is assigned to be rendered in the third column (it says `Grid.Column="2"` in
    the code due to the zero indexing). The `Opacity` is set to `0`, making it completely
    invisible, and the `Padding` is adjusted to make it move down a bit from the top.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `StackLayout`, we'll add a `Label`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the StackLayout for denying photos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to add the `StackLayout` for denying photos on the left-hand
    side of the control:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Controls/SwiperControl.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code under the comment `<!-- StackLayout for deny here -->`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The setup for the left-hand side `StackLayout` is the same, except that it should
    be in the first column, which is the default, so there is no need to add a `Grid.Column`
    attribute. We have also specified `HorizontalOptions="End"`, which means that
    the content should be right-justified.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the screen size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to calculate a percentage of how far the user has dragged the image,
    we need to know the size of the control. This is not determined until the control
    is laid out by Xamarin.Forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will override the `OnSizeAllocated()` method and add a field in the class
    called `_screenWidth` to keep track of the current width of the window by following
    these few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `SwiperControl.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the file. Put the field at the beginning of the class
    and the `OnSizeAllocated()` method below the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `_screenWidth` field is used to store the width as soon as we have resolved
    it. We do this by overriding the `OnSizeAllocated()` method that is called by
    Xamarin.Forms when the size of the control is allocated. This is called multiple
    times. The first time it's called is actually before the width and height have
    been set and before the `MainPage` of the current app is set. At this time, the
    width and height are set to `-1` and the `Application.Current.MainPage` is null.
    We look for this state by null checking `Application.Current.MainPage` and returning
    if it is null. We could also have checked for `-1` values on the width. Either
    method would work. If it does have a value, however, we want to store it in our
    `_screenWidth` field for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Forms will call the `OnSizeAllocated()` method any time the frame of
    the app changes. This is most relevant for UWP apps since they are in a window
    that a user can easily change. Android and iOS apps are less likely to get a call
    to this method a second time, since the app will take up the entire screen's real
    estate.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a clamp function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to calculate the state, we need to clamp a value later on. At the
    time of writing, this function is already in Xamarin.Forms, but it''s marked as
    an internal function, meaning that we shouldn''t really be using it. According
    to the rumors, it will soon be made public in later versions of Xamarin.Forms,
    but for now, we need to redefine it ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `SwiperControl.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `static` method to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The method takes a value to clamp, a minimum boundary, and a maximum boundary.
    It returns either the value itself, or the edge value, if it's greater or larger
    than the set boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Adding code to calculate the state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To calculate the state of the image, we need to define what our zones are and
    then create a function that takes the current amount of movement and updates the
    opacity of the GUI decision zones based on how far we panned the image.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a method for calculating the state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the `CalculatePanState()` method to calculate how far we have panned
    the image, and if it should start to affect the GUI, by following these few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Controls/SwiperControl.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the properties at the top and the `CalculatePanState()` method anywhere in
    the class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We define two values as constants:'
  prefs: []
  type: TYPE_NORMAL
- en: The `DeadZone`, which defines that 40% (`0.4`) of the available space on either
    side of the center point is a dead zone when panning an image. If we release the
    image in this zone, it simply returns to the center of the screen without any
    action being taken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next constant is the `DecisionThreshold`, which defines another 40% (`0.4`)
    of the available space. This is used for interpolating the opacity of the `StackLayout`
    on either side of the layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then use these values to check the state of the panning action whenever the
    panning changes. If the absolute panning value of `X` (`panX`) is less than the
    dead zone, we return without any action being taken. If not, we calculate how
    far over the dead zone we have passed and how far into the decision zone we are.
    We calculate the opacity values based on this interpolation and clamp the value
    between `-1` and `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the opacity to this value for both `likeStackLayout` and `denyStackLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the pan state check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the image is being panned, we want to update the state:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Controls/SwiperControl.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code in bold to the `PanRunning()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This addition to the `PanRunning()` method passes the total amount of movement
    on the *x* axis to the `CalculatePanState()` method to determine if we need to
    adjust the opacity of either the `StackLayout` on the right or the left of the
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Adding exit logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, all is good, except for the fact that if we drag an image to the edge
    and let go, the text stays. We need to determine when the user stops dragging
    the image, and, if so, whether or not the image is in a decision zone.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if the image should exit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want a simple function that determines if an image has panned far enough
    for it to count as an exit of that image:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Controls/SwiperControl.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `CheckForExitCritera()` method to the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This function calculates whether we have passed over the dead zone and into
    the decision zone. We need to use the `Math.Abs()` method to get the total absolute
    value to compare it against. We could have used a `<` and `>` operator as well,
    but we are using this approach as it is more readable. This is a matter of code
    style and taste—feel free to do it your own way.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we determine that an image has panned far enough for it to exit, we want
    to animate it off the screen and then remove the image from the page:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Controls/SwiperControl.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Exit()` method to the class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Exit()` method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by making sure that this call is done on the UI thread, which is also
    known as the `MainThread`. This is because only the UI thread can do animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to run this thread asynchronously, so that we can kill two birds
    with one stone. Since this method is all about animating the image to either side
    of the screen, we need to determine in which direction to animate it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do this by determining if the total translation of the image is positive
    or negative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use this value to await a translation through the `photo.TranslateTo()`
    call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We await this call since we don't want the code execution to continue until
    it's done. Once it has finished, we remove the control from the parent's collection
    of children, causing it to disappear from existence forever.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating PanCompleted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The decision on whether the image should disappear or simply return to its
    original state is triggered in the `PanCompleted()` method. Here, we wire up the
    two methods that we created in the previous two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Controls/SwiperControl.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code in bold to the `PanCompleted()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The last step in this section is to use the `CheckForExitCriteria()` method,
    and the `Exit()` method if those criteria are met. If the exit criteria are not
    met, we need to reset the state and the opacity of the `StackLayout` to make everything
    go back to normal.
  prefs: []
  type: TYPE_NORMAL
- en: Adding events to the control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we have left to do in the control itself is to add some events
    that indicate whether the image has been *Liked* or *Denied*. We are going to
    use a clean interface, allowing for a simple use of the control while hiding all
    the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring two events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make the control easier to interact with from the application itself, we''ll
    need to add events for `Like` and `Deny`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Controls/SwiperControl.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two event declarations at the beginning of the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These are two standard event declarations with out-of-the-box event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Raising the events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to add code in the `Exit()` method to raise the events we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Controls/SwiperControl.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code in bold to the `Exit()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we inject the code to check whether we are liking or disliking an image.
    We then raise the correct event based on this information.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the Swiper control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now reached the final part of the chapter. In this section, we are going
    to wire up the images and make our app a closed-loop app that can be used forever.
    We will add 10 images that we will download from the internet when the app starts
    up. Each time an image is removed, we'll simply add another one.
  prefs: []
  type: TYPE_NORMAL
- en: Adding images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by creating some code that will be adding the images to the MainView.
    We will first add the initial images, and then create logic for adding a new image
    to the bottom of the stack each time an image is liked or disliked.
  prefs: []
  type: TYPE_NORMAL
- en: Adding initial photos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make the photos look like they are stacked, we need at least 10 of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainPage.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `AddInitalPhotos()` method and the `InsertPhotoMethod()` to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a method called `AddInitialPhotos()` that will be called upon
    startup. This method simply calls the `InsertPhoto()` method `10` times and adds
    a new `SwiperControl` to the `MainGrid` each time. It inserts the control at the
    first position in the stack, effectively putting it at the bottom of the pile,
    since the collection of controls is rendered from the beginning to the end.
  prefs: []
  type: TYPE_NORMAL
- en: Making the call from the constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to call this method in order for the magic to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainPage.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code in bold to the constructor and make sure it looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There isn't much to say here. After the `MainPage` is initialized, we call the
    method to add 10 random photos that we will download from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Adding count labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to add some values to the app as well. We can do this by adding two
    labels below the collection of `Swiper` controls. Each time a user rates an image,
    we will increment one of two counters and display the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add the XAML needed to display the labels:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainPage.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the comment `<!-- Placeholder for later -->` with the code marked in
    bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code adds a new `Grid` with four auto-height rows. This means that we calculate
    the height of the content of each row and use this for the layout. It is basically
    the same thing as a `StackLayout`, but we wanted to demonstrate a better way of
    doing this.
  prefs: []
  type: TYPE_NORMAL
- en: We add a `Label` in each row and name two of them as `likeLabel` and `denyLabel`.
    The two named labels will hold how many images have been liked and how many have
    been denied.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last step is to wire up the `OnLike` and `OnDeny` events and display the
    total count to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Adding methods to update the GUI and respond to events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need some code to update the GUI and to keep track of the count:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainPage.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The two fields at the top keep track of the number of likes and denies. Since
    they are value-type variables, they default to zero.
  prefs: []
  type: TYPE_NORMAL
- en: To make the changes of these labels propagate to the UI, we've created a method
    called `UpdateGui()`. This takes the value of the two aforementioned fields and
    assigns it to the `Text` properties of both labels.
  prefs: []
  type: TYPE_NORMAL
- en: The two methods that follow are the event handlers that will be handling the `OnLike`
    and `OnDeny` events. They increase the appropriate field, add a new photo, and
    then update the GUI to reflect the change.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each time a new `SwiperControl` is created, we need to wire up the events:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainPage.xaml.cs.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code in bold to the `InsertPhoto()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The added code wires up the event handlers that we defined earlier. The events
    really make it easy to interact with our new control. Try it for yourself and
    have a play around with the app that you have created.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good job! In this chapter, we have learned how to create a reusable, good-looking
    control that can be used in any Xamarin.Forms app. To enhance the **User Experience**
    (**UX**) of the app, we used some animations that give the user more visual feedback. We
    also got creative with the use of XAML to define a GUI of the control that looks
    like a photo with a hand-written description.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we used events to expose the behavior of the control back to the
    `MainPage` to limit the contact surface between your app and the control. Most
    importantly of all, we touched on the subject of `GestureRecognizers`, which can
    make our life much easier when dealing with common gestures.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at how to use track the location of
    a user in the background on an iOS and Android device. To visualize what we are
    tracking, we will use the map component in Xamarin.Forms.
  prefs: []
  type: TYPE_NORMAL
