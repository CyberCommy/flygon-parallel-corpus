- en: Unit Testing in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hard work of the previous chapters has materialized into a working application
    we can be proud of. But how can we ensure a painless maintainability in the future?
    A comprehensive automated testing layer will become our lifeline once our application
    begins to scale up and we have to mitigate the impact of bugs, caused by new functionalities
    colliding with the already existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Testing (and more specifically, unit testing) is meant to be carried out by
    the developer as the project is being developed. However, we will cover all the
    intricacies of testing Angular modules in brief in this chapter, now that the
    project is at a mature stage.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will see how to implement testing tools to perform proper
    unit testing of your application classes and components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at the importance of testing and, more specifically, unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a test spec testing a pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design unit tests for components, with or without dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put our routes to the test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement tests for services, mocking dependencies, and stubs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intercept XHR requests and provide mocked responses for refined control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how to test directives as components with no view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce other concepts and tools such as Karma, code coverage tools,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and **end-to-end** (**E2E**) testing
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need tests?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a unit test? If you're familiar already with unit testing and test-driven
    development, you can safely skip to the next section. If not, let's say that unit
    tests are part of an engineering philosophy that takes a stand for efficient and
    agile development processes, by adding an additional layer of automated testing
    to the code, before it is developed. The core concept is that each piece of code
    is delivered with its own test, and both pieces of code are built by the developer
    who is working on that code. First, we design the test against the module we want
    to deliver, checking the accuracy of its output and behavior. Since the module
    is still not implemented, the test will fail. Hence, our job is to build the module
    in such a way that it passes its own test.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is quite controversial. While there is a common agreement about
    how beneficial test-driven development for ensuring code quality and maintenance
    over time is, not everybody undertakes unit testing in their daily practice. Why
    is that? Well, building tests while we develop our code can feel like a burden
    sometimes, particularly when the test winds up being bigger in size than the piece
    of functionality it aims to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the arguments favoring testing outnumber the arguments against it:'
  prefs: []
  type: TYPE_NORMAL
- en: Building tests contributes to better code design. Our code must conform to the
    test requirements and not the other way around. In that sense, if we try to test
    an existing piece of code and we find ourselves blocked at some point, chances
    are that the piece of code we aim to test is not well designed and shows off a
    convoluted interface that requires some rethinking. On the other hand, building
    testable modules can help with early detection of side effects on other modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring tested code is the lifeline against introducing bugs in later stages.
    Any development is meant to evolve with time, and on every refactor the risk of
    introducing a bug, that will only pop up in another part of our application, is
    high. Unit tests are a good way to ensure that we catch bugs at an early stage,
    either when introducing new features or when updating existing ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building tests is a good way to document our code APIs and functionalities.
    And this becomes a priceless resource when someone not acquainted with the code
    base takes over the development endeavor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are only a few arguments, but you can find countless resources on the
    web about the benefits of testing your code. If you do not feel convinced yet,
    give it a try. Otherwise, let's continue with our journey and see the overall
    form of a test.
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of a unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different ways to test a piece of code, but in this chapter we
    will look at the anatomy of a test, what it is made up of. The first thing we
    need, for testing any code, is a test framework. The test framework should provide
    utility functions for building test suites, containing one or several test specs
    each. So what are these concepts?
  prefs: []
  type: TYPE_NORMAL
- en: '**Test suite**: A suite creates a logical grouping for a bunch of tests. A
    suite can, for example, be all the tests for a product page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test spec**: This is another name for a unit test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following shows what a test file can look like where we are using a test
    suite and placing a number of related tests inside. The chosen framework for this
    is Jasmine. In Jasmine, the `describe()`function helps us to define a test suite.
    The `describe()`method takes a name as the first parameter and a function as the
    second parameter. Inside of the `describe()` function are a number of invocations
    to the `it()`method. The `it()` function is our unit test; it takes the name of
    the test as the first parameter and a function as the second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each test spec checks out a specific functionality of the feature described
    in the suite description argument and declares one or several expectations in
    its body. Each expectation takes a value, which we call the expected value, and
    is compared against an actual value by means of a matcher function, which checks
    whether expected and actual values match accordingly. This is what we call an
    assertion, and the test framework will pass or fail the spec depending on the
    result of such assertions. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, `add(1,1)` will return the actual value that is supposed
    to match the expected value declared in the `toBe()` matcher function.
  prefs: []
  type: TYPE_NORMAL
- en: Worth noting from the previous example is the addition of a second test that
    tests our `subtract()`function. We can clearly see that this test deals with yet
    another mathematical operation, thus it makes sense to group both these tests
    under one suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have learned about test suites and how to group tests according
    to their function. Furthermore, we have learned about invoking the code you want
    to test and asserting that it does what you think it does. There are, however,
    more concepts to a unit test worth knowing about, namely setup and tear-down functionality.
    A setup functionality is something that sets up your code before the test is run
    usually. It''s a way to keep your code cleaner so you can focus on just invoking
    the code and asserting. A tear-down functionality is the opposite of a setup functionality
    and is dedicated to tearing down what you set up initially; essentially it''s
    a way to clean up after the test. Let''s see how this can look in practice with
    a code example, using the Jasmine framework. In Jasmine, the `beforeEach()`method
    is used for setup functionality; it runs before every unit test. The `afterEach()`
    method is used to run tear-down logic. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding code how the `beforeEach()` function is responsible
    for instantiating the `productService`, which means the test only has to care
    about invoking production code and asserting the outcome. This makes the test
    look cleaner. It should be said, though, in reality, tests tend to have a lot
    of setup going on and having a `beforeEach()`function can really make the tests
    look cleaner; above all, it tends to make it easier to add new tests, which is
    great. What you want at the end of the day is well-tested code; the easier it
    is to write and maintain such code, the better for your software.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to testing in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the section *The anatomy of a unit test*, we gained familiarity with unit
    testing and its general concepts, such as test suites, test specs, and assertions.
    Armed with that knowledge, it is now time to venture into unit testing with Angular.
    Before we start writing tests for Angular, though, we will first give an introduction
    to the tooling that exists within the Angular CLI to make unit testing a nice
    experience. When venturing into unit testing in Angular, it''s important to know
    what major parts it consists of. In Angular these are:'
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine, the testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular testing utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Karma, a test runner for running unit tests, among other things
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protractor, Angular's framework for E2E testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration and setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In terms of configuration, when using the Angular CLI, you don''t have to do
    anything to make it work. You can, as soon as you scaffold a project, run your
    first test and it will work. As you venture deeper into unit testing in Angular,
    you will need to be aware of a few concepts that leverage your ability to test
    different constructs, such as components and directives. The Angular CLI is using
    Karma as the test runner. What we need to know about Karma is that it uses a `karma.conf.js`
    file, a configuration file, in which a lot of things are specified, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The various plugins that enhance your test runner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where to find the tests to run?  It should be said that there is usually a files
    property in this file specifying where to find the application and the tests.
    For the Angular CLI, however, this specification is found in another file called
    `src/tscconfig-spec.json`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup of your selected coverage tool, a tool that measures to what degree your
    tests cover the production code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporters, report every executed test in a console window, to a browser, or
    through some other means.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Browsers to run your tests in: for example, Chrome or PhantomJS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Angular CLI, you most likely won't need to change or edit this file
    yourself. It is good to know that it exists and what it does for you.
  prefs: []
  type: TYPE_NORMAL
- en: Angular testing utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Angular testing utilities help to create a testing environment that makes
    writing tests for your various constructs really easy. It consists of the `TestBed`
    class and various helper functions, found under the `@angular/core/testing` namespace.
    We will learn what these are and how they can help us to test various constructs
    as this chapter progresses. We will shortly introduce the most commonly used concepts
    so that you are familiar with them as we present them more deeply further on:'
  prefs: []
  type: TYPE_NORMAL
- en: The `TestBed`class is the most important concept and creates its own testing
    module. In reality, when you test out a construct to detach it from the module
    it resides in and reattach it to the testing module created by the `TestBed`.
    The `TestBed` class has a `configureTestModule()`helper method that we use to
    set up the test module as needed. The `TestBed` can also instantiate components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComponentFixture`is a class wrapping the component instance. This means that
    it has some functionality on it and it has a member that is the component instance
    itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DebugElement`, much like the `ComponentFixture`, acts as a wrapper. It,
    however, wraps the DOM element and not the component instance. It's a bit more
    than that though, as it has an injector on it that allows us to access the services
    that have been injected into a component. More on this topic later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This was a brief overview to our testing environment, the frameworks and libraries
    used, as well as some important concepts that we will use heavily in the upcoming
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to component testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our usual method of operation for doing anything Angular by now, is to use the Angular
    CLI. Working with tests is no different. The Angular CLI lets us create tests,
    debug them, and run them; it also gives us an understanding of how well our tests
    cover the code and its many scenarios. Let's have a quick look at how we can get
    going with some unit testing using the Angular CLI, and try to understand what
    is given to us by default.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to code along with this chapter, you can either take an old Angular
    project and add tests to it or create a new standalone project, if you want to
    focus on practice testing only. The choice is yours.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you opt for creating a new project, then type the following to scaffold
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Angular CLI comes with testing already set up, so the only thing we need
    to do is follow in its footsteps and add more tests, but let's first examine what
    we've got and learn some neat commands to make it easier to work with testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Investigate the tests that the Angular CLI has given us
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By looking in the scaffolded `directory/app`, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We see a component being declared, together with a unit test. This means we
    get tests with our components, which is very good news as it saves us a bit of
    typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the test that was given to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s a lot of code, but we will break it down. We see the testing setup,
    at the beginning of the file, with three different tests being written. Let''s
    have a look at the setup phase first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we are calling `beforeEach()`, as we normally do in a Jasmine test, to
    run code before each test actually happens. Inside of the `beforeEach()`, we call
    the `TestBed.configureTestingModule()`method, with an object as an argument. The
    object resembles the object that we give the `NgModule` as an argument. This means
    we can take our knowledge of `NgModule` and how to set up Angular modules and
    apply that to how to set up testing modules, because it is really one and the
    same. Looking at the code, we can see that we specify a declarations array with
    the `AppComponent` as an item in that array. For `NgModule`, this means that the `AppComponent`belongs
    to that module. Lastly, we call the `compileComponents()` method and the setup
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: So what does the `compileComponents()`do? As per its name, it compiles components
    that are configured in the testing module. In the compilation process, it also
    inlines external CSS files as well as external templates. By calling `compileComponents()`,
    we also close down the possibility to further configure the testing module instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of our test files are the tests. Look at the first test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that we call `TestBed.createComponent(AppComponent)`, this returns an
    object of type `ComponentFixture<AppComponent>`. We are able to interact with
    this object further by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a component instance, which is what we get when we instantiate
    an object from the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first test just wants to verify that we are able to create a component and
    the `expect` condition tests just that, that `expect(app)`  is truthy, meaning
    is it declared; and in truth it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second test, we actually try to investigate whether our component contains
    the properties and values we think; so the test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, this test creates a component but it also calls `fixture.detectChanges`,
    which tells Angular to force change detection. This will make sure that the code
    in the constructor and any `ngInit()`, if it exists, is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a component specification we expect that the `title` property should get
    set when the component is created, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That is exactly what the second test is testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how this works by extending our `app.component.ts` with one more
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the description field and also initialized it with a value; we will
    test whether this value is set to our property. Therefore, we need to add an extra
    `expect` condition in our test, so the test now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have an extra `expect` condition and the test passes as
    it should. Don''t take our word for it though; let''s run our test runner using
    a node command. We do that by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute the test runner and it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c1d52a8b-e0d5-421b-9c89-baf25a27f352.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that we understand how to extend our component and test for it.
    As a bonus, we now also know how to run our tests. Let''s have a look at the third
    test. It is a bit different as it tests the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Instead of talking to `fixture.debugElement.componentInstance`, we now talk
    to `fixture.debugElement.nativeElement`. This will allow us to verify that the
    expected HTML markup is what we think it is. When we have access to the `nativeElement`,
    we can use the `querySelector` and find the elements we defined in our template
    and verify their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve gained quite a lot of insight just by looking at the test we were given.
    We now know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We set up the test by calling `TestBed.configureTestingModule()` and pass it
    an object that looks like the object we pass to `NgModule`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `TestBed.createComponent(<Component>)` to get a reference to a component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `debugElement.componentInstance` on our component reference to get to
    the actual component and we can test for the existence and values of properties
    that should exist on our component object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `debugElement.nativeElement`to get a reference to the `nativeElement`
    and can now start verifying the resulting HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also learned how to run our tests in the browser by typing `npm test`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixture.debugElement.nativeElement`points to the HTML element itself. When
    we use the `querySelector()` method, we are in fact using a method available in
    the Web API; it''s not an Angular method.'
  prefs: []
  type: TYPE_NORMAL
- en: Component testing with dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned a lot already, but let''s face it, no component that we build
    will be as simple as the one we wrote in the preceding section. There will almost
    certainly be at least one dependency, looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have different ways of dealing with testing such a situation. One thing
    is clear though: if we are testing the component, then we should not test the
    service as well. This means that when we set up such a test, the dependency should
    not be the real thing. There are different ways of dealing with that when it comes
    to unit testing; no solution is strictly better than the other:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a stub means that we tell the dependency injector to inject a stub that
    we provide, instead of the real thing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting the real thing, but attaching a spy, to the method that we call in
    our component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of the approach, we ensure that the test is not performing a side
    effect such as talking to a filesystem or attempting to communicate via HTTP;
    we are, using this approach, isolated.
  prefs: []
  type: TYPE_NORMAL
- en: Using a stub to replace the dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using a stub means that we completely replace what was there before. It is
    as simple to do as instructing the `TestBed` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We define a `providers` array like we do with the `NgModule`, and we give it
    a list item that points out the definition we intend to replace and we give it
    the replacement instead; that is our stub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now build our `DependencyStub` to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like with an `@NgModule`, we are able to override the definition of our
    dependency with our own stub. Imagine our component looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we pass an instance of the dependency in the constructor. With our testing
    module correctly set up, with our stub, we can now write a test that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The test looks normal, but at the point when the dependency would be called
    in the component code, our stub takes its place and responds instead. Our dependency
    should be overridden, and as you can see, the `expect(app.title).toEqual('stub')`assumes
    the stub will answer, which it does.
  prefs: []
  type: TYPE_NORMAL
- en: Spying on the dependency method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previously-mentioned approach, using a stub, is not the only way to isolate
    ourselves in a unit test. We don''t have to replace the entire dependency, only
    the parts that our component is using. Replacing certain parts means that we point
    out specific methods on the dependency and assign a spy to them. A spy is an interesting
    construct; it has the ability to answer what you want it to answer, but you can
    also see how many times it is being called and with what argument/s, so a spy
    gives you a lot more information about what is going on. Let''s have a look at
    how we would set a spy up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now as you can see, the actual dependency is injected into the component. After
    that, we grab a reference to the component, our fixture variable. This is followed
    by us using the `TestBed.get('Dependency')`to get hold of the dependency inside
    of the component. At this point, we attach a spy to its `getData()` method through
    the `spyOn( dependency,'getData')` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not enough, however; we have yet to instruct the spy what to respond
    with when being called. Let us do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now write our test as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This works as expected, and our spy responds as it should. Remember how we
    said that spies were capable of more than just responding with a value, that you
    could also check whether they were invoked and with what? To showcase this, we
    need to improve our tests a little bit and check for this extended functionality,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can also check for the number of times it was called, with `spy.callCount`,
    or whether it was called with some specific arguments: `spy.mostRecentCalls.args` or `spy.toHaveBeenCalledWith('arg1',
    'arg2')`. Remember if you use a spy, make sure it pays for itself by you needing
    to do checks like these; otherwise, you might as well use a stub.
  prefs: []
  type: TYPE_NORMAL
- en: Spies are a feature of the Jasmine framework, not Angular. The interested reader
    is urged to research this topic further at [http://tobyho.com/2011/12/15/jasmine-spy-cheatsheet/](http://tobyho.com/2011/12/15/jasmine-spy-cheatsheet/).
  prefs: []
  type: TYPE_NORMAL
- en: Async services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very few services are nice and well-behaved, in the sense that they are synchronous.
    A lot of the time, your service will be asynchronous and the return from it is
    most likely an observable or a promise. If you are using RxJS with the `Http`service
    or `HttpClient`, it will be an observable, but if using the `fetch`API, it will
    be a promise. These are two good options for dealing with HTTP, but the Angular
    team added the RxJS library to Angular to make your life as a developer easier.
    Ultimately it's up to you, but we recommend going with RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular has two constructs ready to tackle the asynchronous scenario when testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`async()` and `whenStable()`: This code ensures that any promises are immediately
    resolved; it can look more synchronous though'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fakeAsync()` and `tick()`: This code does what the async does but it looks
    more synchronous when used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s describe the `async()` and `whenStable()`approaches. Our service has
    now grown up and is doing something asynchronous when we call it like a timeout
    or a HTTP call. Regardless of which, the answer doesn''t reach us straightaway.
    By using `async()` in combination with `whenStable()`, we can, however, ensure
    that any promises are immediately resolved. Imagine our service now looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to change our spy setup to return a promise instead of returning a
    static string, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We do need to change inside of our component, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, it''s time to update our tests. We need to do two more things.
    We need to tell our test method to use the `async()` function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to call `fixture.whenStable()` to make sure that the promise will
    have had ample time to resolve, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of doing it works as it should, but feels a bit clunky. There
    is another approach using `fakeAsync()` and `tick()`. Essentially, `fakeAsync()` replaces
    the `async()` call and we get rid of `whenStable()`. The big benefit, however,
    is that we no longer need to place our assertion statements inside of the promise''s `then()`callback.
    This gives us synchronous-looking code. Back to `fakeAsync()`, we need to make
    a call to `tick()`, which can only be called within a `fakeAsync()` call , like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this looks a lot cleaner; which version you want to use for
    async testing is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Testing pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pipe is basically a class that implements the `PipeTransform` interface,
    thus exposing a `transform()` method that is usually synchronous. Pipes are therefore
    very easy to test. We will begin by testing a simple pipe, creating, as we mentioned,
    a test spec right next to its code unit file. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code is very simple; we take a value and add `banana` to it. Writing a
    test for it is equally simple. The only thing we need to do is to import the pipe
    and verify two things:'
  prefs: []
  type: TYPE_NORMAL
- en: That it has a transform method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That it produces the expected results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code writes a test for each of the bullet points listed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In our `beforeEach()`method, we set up the fixture by instantiating the pipe
    class. In the first test, we ensure that the `transform()`method exists. This
    is followed by our second test that asserts that the `transform()` method produces
    the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking HTTP responses with HttpClientTestingController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is super simple to get started with mocking HTTP, once you understand how
    to. Let''s first have a look at the service we mean to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two important players when it comes to testing our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpTestingController`, we can instruct this class to listen for specific
    URLs and how to respond when it is being called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our service, this is the service we want to test; the only thing we really want
    to do with it is to invoke it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As with all tests, we have a setup phase. Here we need to import the module, `HttpClientTestingModule`,
    that contains our `HttpTestingController`. We also need to tell it to provide
    us with our service, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to set up the test, and by set up we mean that we need to
    get an instance of our service as well as `HttpTestingController`. We also need
    to instruct the latter what type of API calls to expect and give it suitable mock
    data to respond with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We have provided inline comments for the preceding code snippet, but just to
    describe what happens one more time ,we have three phases to our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: This is where we grab an instance of the `JediService`as well
    as an instance of the `HttpTestingController`. We also define our mock data by
    setting the `expected ` variable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Act**: We carry out the test by calling `jediService.getJedis()`. This is
    an observable so we need to subscribe to its content.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Assert**: We resolve the asynchronous code by calling `flush(expected)` and
    we assert that we get the right data back by carrying out our assertion `expect(actual).toEqual(expected)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, faking calls to the HTTP is quite easy. Let''s show the entire
    unit test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Input and outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have tested components in the sense that we have tested simple properties
    on the component and also how to tackle dependencies, synchronous as well as asynchronous,
    but there is more to a component than that. A component can also have input and
    outputs that should be tested as well. Because our context is Jedis, we know Jedis
    normally have ways to either the light side or the dark side. Imagine that our
    component is used within the context of a Jedi management system; we want to have
    the ability to turn a Jedi dark as well as bring it back to the light side again.
    What we are talking about is, of course, a toggle functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine, therefore, that we have a component that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing such a component should be done in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: We should verify that our input binding gets correctly set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should verify that our output binding triggers properly and that what it
    emits is received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Starting with the `@Input`, a test for it would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Worth noting here is our call to `fixture.detectChanges()`, this ensures that
    the binding happens in the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now have a look at how to test `@Output`. What we need to do is to trigger
    it somehow. We need to click the div defined in our template. To receive the value
    the `switchSide` property emits, we need to subscribe to it, so we need to do
    two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the `div` element and trigger a click on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribe to the emission of the dataand verify that we receive our `jedi` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As for getting a reference to the div, it is quite easily done, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second part, we need to subscribe to the `switchSide` Observable and
    capture the data, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we are able to trigger an outputs emit indirectly, through the
    click event and listen to the output, through a subscribe.
  prefs: []
  type: TYPE_NORMAL
- en: Testing routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like components, routes play an important role in the way our applications
    deliver an efficient user experience. As such, testing routes becomes paramount
    to ensuring a flawless performance. There are different things we can do with
    routing and we need to test for the different scenarios. These scenarios are:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that the navigation targets the right route address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that the correct parameters are made available so you can fetch the
    correct data for the component, or filter the dataset the component needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that a certain route ends up loading the intended component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at the first bullet point. To load a specific route, we
    can call a `navigateToUrl(url)` method on the `Router`class. A good test is to
    ensure that such a method is being called when a certain state happens in a component.
    There could, for example, be a create component page, that after saving should
    navigate back to a list page, or a missing route parameter should lead to us back
    to a home page. There is more than one good reason for programatically navigating
    inside of a component. Let''s look at some code in a component, where such a navigation
    takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see that invoking the `back()`method will perform a navigation.
    Writing a test for this is quite simple. The test should test whether the `navigateToUrl()`method
    is being called. Our approach will consist of stubbing the router service in combination
    with adding a spy to the `navigateToUrl()`method itself. First off, we define
    a stub and then we instruct our testing module to use the said stub. We also ensure
    that we create an instance of the component so that we may later invoke the `back()` method
    on it,  like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to do is to define our test and inject the router instance.
    Once we have done so, we can set a spy on the `navigateToUrl()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now at this point, what we want the test to test for is whether the method
    is called at all. Writing such a test can be seen as defensive. As important as
    it is to test for correctness, it is also important to write tests to make sure
    that another developer, or yourself, doesn''t remove a behavior that should work.
    So let''s add some verification logic that ensures that our spy is being called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire test is now replacing the original router service for a stub. We
    are attaching a spy to the `navigateByUrl()` method on the stub and we are lastly
    asserting that spy is called as intended, when we invoke the `back()` method on
    the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Testing routes by URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have tested routing by placing a spy on the navigation method and
    in the case with routing parameters, we had to build a mock for an Observable.
    There is another approach, though, and that is to let the routing happen and afterwards
    investigate where we ended up. Let''s say we have the following scenario: we are
    at a list component and want to navigate to a detail component. After navigation
    has taken place, we want to investigate what state we are in. Let us first define
    our list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have a `goToDetail()`method that, if invoked, will navigate
    you to a new route. For this to work, however, we need to have had routing set
    up properly in the module file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The important part here is the definition of `appRoutes` and calling`RouterModule.forRoot()` in
    the imports array.
  prefs: []
  type: TYPE_NORMAL
- en: The time has come to define the test for this. We need to interact with a module
    called `RouterTestingModule` and we need to provide that module with the routes
    it should contain. `RouterTestingModule`is a very qualified stub version of the
    routing, so in that sense, there isn't much difference in principle from creating
    your own stub. Look at it this way though, you can create your own stub, but as
    you use more and more advanced functionality, using an advanced stub quickly pays
    off.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start off by instructing our `RouterTestingModule` that it should load
    the `DetailComponent` when the `detail/:id`route is being hit. This doesn''t really
    differ from how we would set up the routing from our `root` module. The benefit
    is that we only need to set up the routes we need for our test, rather than every
    single route in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have done the setup, we need to grab a copy of the component in our
    test so that we can invoke the method that navigates us away from the list component.
    Your test should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The important part here is the invocation of the method that makes us navigate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And the assertion where we verify that our router has indeed changed state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Testing route parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will have some component that does routing and some components that are
    being routed to. Sometimes components that are being routed to have a parameter,
    and typically their route looks something like this: `/jedis/:id`. The component
    then has the mission of digging out the ID parameter and doing a lookup on the
    specific Jedi that matches this ID. So, a call to a service will be made and the
    response should populate  a suitable parameter in our component that we then can
    show in the template. Such a component will typically look like this, in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Worth highlighting is how we get hold of the parameter in the router. We interact
    with the `ActivatedRouter`instance, that we named as `route` and its`paramMap` property,
    which is an observable, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: So what do we want to test for? We would like to know that if a certain route
    contains an ID parameter, then our `jedi`property should be properly populated,
    through our service. We don't want to do an actual HTTP call, so our `JediService`will
    need to be mocked somehow and there is another thing complicating it, namely that
    `route.paramMap` will need to be mocked as well and that thing is an observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we need a way to create a stub of an observable. This might sound
    a bit daunting but it really isn''t; thanks to a `Subject`, we can make this quite
    easy for ourselves. A `subject` has the nice ability of being something we can
    subscribe to, but we can also pass it values. With that knowledge, let''s start
    to create our `ActivatedRouteStub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s explain this code, we add the `sendValue()`method so it can pass
    the value we give it to the subject. We expose the `paramMap` property, as an
    observable, so we can listen to the subject when it emits any values. How does
    this correlate to our test though? Well, calling `sendValue` on the stub is something
    we want to do in the setup phase, that is inside of a`beforeEach()`. This is a
    way for us to simulate reaching our component through routing while passing a
    parameter. In the test itself, we want to listen for when a router parameter is
    being sent to us so we can pass it on to our `jediService`. So, let''s start sketching
    on the test. We will build the test in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to support the mocking of the `ActivatedRoute`by passing the
    `ActivatedRouteStub`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step is to set up the mocking of the `jediService`, ensuring that
    all HTTP calls are intercepted, and that we are able to respond with mock data
    when an HTTP call occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the first step, we set up the test as we have done so far by calling `TestBed.configureTestingModule()`
    and passing it an object. We mentioned that we built a stub for an activated route
    already and we need to make sure that we provide this instead of the real `ActivatedRoute`.
    This looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that when our component gets the `ActivatedRoute` dependency injected
    in its constructor, it will instead inject `ActivatedRouteStub`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on with our test, we need to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate the component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feed a route parameter to our `ActivatedRouteStub` so that a routing parameter
    is emitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribe to the `ActivatedRouteStub` so we can assert that a parameter is indeed
    emitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add these to our test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have set up the fixture, the component, and our `activatedRouteStub`.
    The next step is to feed the `activatedRouteStub`the actual routing parameter,
    and to set up a `subscribe` of the`activatedRouteStub`so we know when we receive
    a new routing parameter. We do this inside the test itself, instead of the `beforeEach()` method,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'So what does this mean for our component? How much of our component have we
    tested at this stage? Let''s have a look at our `DetailComponent` and highlight
    the code covered by our test so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have, in the test, covered the mocking of the `activatedRoute`and
    managed to subscribe to it. What is missing on both the component and test is
    to account for there being a call to a service that in turn calls HTTP. Let''s
    start with adding that code to the component, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code, we added the `Jedi` field as well as a call to`this.jediService.getJedi()`.
    We subscribed to the result and assigned the result of the operation to the `Jedi`
    field. Adding testing support for this part is something we have already covered
    in the previous section on mocking the HTTP. It''s good to repeat this, so let''s
    add the necessary code to the unit test, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'What we did here is to get a copy of our `JediService` by asking for it from
    the`TestBed.get()`method. Furthermore, we asked for an instance of the   `HttpTestingController`.
    We move on by defining the expected data that we want to respond with, and we
    instruct the instance of the `HttpTestingController` that it should expect a call
    to `/api/jedis/1`, and when that happens then the expected data should be returned.
    So now we have a test that covers both the scenario of testing for the `ActivatedRoute`
    parameters, as well as the HTTP call. The full code of the test looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: So what have we learned from testing route parameters? It is a bit more cumbersome
    as we need to create our `ActivatedRouteStub`, but all in all, it is quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Testing directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last leg of our journey into the world of unit testing Angular elements
    will cover directives. Directives will usually be quite straightforward in their
    overall shape, being pretty much components with no view attached. The fact that
    directives usually work with components gives us a very good idea of how to proceed
    when testing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A directive can be simple in the sense that it has no external dependencies.
    It looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing is easy, you just need to instantiate an object from the `SomeDirective`class.
    However, it is likely that your directive will have dependencies and in those
    cases, we need to test the directive implicitly through it being attached to the
    component. Let''s have a look at such an example. Let''s first define the directive,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'What you see here is a simple directive that shifts the font color to yellow
    if we hover over it. We need to attach it to a component. Let us define an element
    next, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here we can see that we added the element as an attribute to the `p`-tag that
    we defined in the components template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s go over to our test. We now know how to write tests, and especially
    how to test elements, so the following test code should come as no surprise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `beforeEach()`method, we talk to `TestBed` to configure our testing
    module and tell it about the`BananaDirective` as well as the`BananaComponent`,
    with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In the test itself, we use `TestBed`yet again to create a component. Thereafter,
    we find our element by its CSS class. We find the element so that we are able
    to trigger an event, a `mouseover`. Triggering a `mouseover`event will trigger
    code in the directive that will make the font color yellow. With the event triggered,
    then we are able to assert the element''s font color with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, this is how simple it can be to test a directive, even if it has dependencies.
    The key takeaway is that if that is the case, you need an element to place the
    directive on, and that you implicitly test the directive through the element.
  prefs: []
  type: TYPE_NORMAL
- en: The road ahead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This last test example wraps up our journey into unit testing with Angular,
    but keep in mind that we have barely scratched the surface. Testing web applications
    in general, and Angular applications in particular, poses a myriad of scenarios
    that usually need a specific approach. Remember that if a specific test requires
    a cumbersome and convoluted solution, we are probably facing a good case for a
    module redesign instead.
  prefs: []
  type: TYPE_NORMAL
- en: Where should we go from here? There are several paths to compound our knowledge
    of web application testing in Angular and enable us to become great testing ninjas.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing code coverage reports in your test stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we know how far our tests go on testing the application? Are we sure
    we are not leaving any piece of code untested and if so, is it relevant? How can
    we detect the pieces of code that fall outside the scope of our current tests
    so we can better assess whether they are worth testing or not?
  prefs: []
  type: TYPE_NORMAL
- en: These concerns can be easily addressed by introducing code coverage reporting
    in our application tests stack. A code coverage tool aims to track down the scope
    of our unit testing layer and produce an educated report informing you of the
    overall reach of your test specs and what pieces of code still remain uncovered.
  prefs: []
  type: TYPE_NORMAL
- en: There are several tools for implementing code coverage analysis in our applications,
    the most popular ones at this time being Blanket ([http://blanketjs.org](http://blanketjs.org))
    and Istanbul ([https://gotwarlost.github.io/istanbul](https://gotwarlost.github.io/istanbul)).
    In both cases, the installation process is pretty quick and easy.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing E2E tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how we could test certain parts of the UI by evaluating
    the state of the DOM. This gives us a good idea of how things would look from
    the end user's point of view, but ultimately this is just an educated guess.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end (E2E) testing is a methodology for testing web applications using
    an automated agent that will programmatically follow the end user's flow from
    start to finish. Contrary to what unit testing poses, the nuances of the code
    implementation are not relevant here since E2E testing entails testing our application
    from start to finish from the user's endpoint. This approach allows us to test
    the application in an integrated way. While unit testing focuses on the reliability
    of each particular piece of the puzzle, E2E testing assesses the integrity of
    the puzzle as a whole, finding integration issues between components that are
    frequently overlooked by unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the previous incarnation of the Angular framework, the Angular team built a
    powerful tool named Protractor ([http://www.protractortest.org/](http://www.protractortest.org/)),
    which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"An end to end test runner which simulates user interactions that will help
    you verify the health of your Angular application."'
  prefs: []
  type: TYPE_NORMAL
- en: The tests syntax will become pretty familiar since it also uses Jasmine for
    putting together test specs. Unfortunately, E2E sits outside the scope of this
    book, but there are several resources you can rely on to expand your knowledge
    on the subject. In that sense, we recommend the book *Angular Test-Driven Development*,
    *Packt Publishing*, which provides broad insights on the use of Protractor to
    create E2E test suites for our Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are at the end of our journey, and it's definitely been a long but exciting
    one. In this chapter, you saw the importance of introducing unit testing in our
    Angular applications, the basic shape of a unit test, and the process of setting
    up Jasmine for our tests. You also saw how to code powerful tests for our components,
    directives, pipes, routes, and services. We also discussed new challenges in your
    path for mastering Angular. It is fair to say that there is still a long road
    ahead, and it is definitely an exciting one.
  prefs: []
  type: TYPE_NORMAL
- en: The end of this chapter is also the end of this book, but the experience continues
    beyond its boundaries. Angular is still a pretty young framework, and as such,
    all the great things that it will bring to the community are yet to be created.
    Hopefully, you will be one of those creators. If so, please let the authors know.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for taking the time to read this book.
  prefs: []
  type: TYPE_NORMAL
