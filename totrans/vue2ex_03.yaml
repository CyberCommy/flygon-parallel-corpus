- en: Optimizing your App and Using Components to Display Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0031.html#TI1E0-985bf4ae118d4f62b18ae64204cb251c), *Displaying,
    Looping, Searching, and Filtering Data*, we got our Vue app displaying our people
    directory, we can use this opportunity to optimize our code and separate it out
    into components. This makes the code more manageable, easier to understand, and
    makes it easier for other developers to work out the flow of data (or you, when
    you come back and look at your code in a few months!).
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is going to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing our Vue.js code by reducing the repetition, and logically organizing
    our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create Vue components and use them with Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use props and slots with components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing events to transfer data between components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we wrote the code while we were figuring out the problem, there comes a
    point when you need to take a step back and look at your code to optimize it.
    This could include reducing the number of variables and methods or creating methods,
    to reduce repeating functionality. Our current Vue app looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the preceding code, there are some improvements we can make. These
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the number of filter variables and grouping logically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining the format functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the number of hard-coded variables and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-ordering methods into a more logical order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll cover these points individually so we have a clean code base for building
    components with.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the number of filter variables and grouping logically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The filtering currently uses up three variables, `filterField`, `filterQuery`,
    and `filterUserState`. The only thing that currently links these variables is
    the name, rather than being in an object of their own to link them systematically.
    Doing this avoids any ambiguity as to whether they are related to the same component
    or just coincidentally the same. In the data object, create a new object titled
    `filter` and move each variable inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the data, update any references of `filterField` to `this.filter.field`.
    Note the extra dot, denoting it is a key of the filter object. Don''t forget to
    update `filterQuery` and `filterUserState` references as well. For example, the
    `isActiveFilterSelected` method would become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will also need to update the `v-model` and `v-show` attributes in your view—there
    are five occurrences of the various variables.
  prefs: []
  type: TYPE_NORMAL
- en: While updating the filtering variables, we can take this opportunity to remove
    one. With our current filtering, we can only have one filter active at a time.
    This means the `query` and `userState` variables are only being used at any one
    time, which gives us the opportunity to combine these two variables. To do so,
    we'll need to update the view and application code to cater for this.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `userState` variable from your filter data object and update any
    occurrence of `filter.userState` in your view to `filter.query`. Now do a *find
    and replace* in your Vue JavaScript code for `filter.userState`, again replacing
    it with `filter.query`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Viewing your app in the browser, it will appear to initially work, being able
    to filter users by the field. However, if you filter by status, then switch to
    any other field, the query field won''t show. This is because using the radio
    buttons sets the value to a Boolean which, when trying to convert to lowercase
    for the query field, fails to do so. To tackle this, we can convert whatever value
    is in the `filter.query` variable to a string using the native JavaScript `String()`
    function. This ensures that our filtering function can work with any filtering
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding this to our code now ensures our query data is usable no matter what
    the value. The issue this now creates is when the user is switching between fields
    to filter. If you select the Active user and chose a radio button, the filtering
    works as expected, however, if you now switch to Email, or another field, the
    input box is prepopulated with either `true` or `false`. This instantly filters
    and will often return no results. This also occurs when switching between two
    text filtering fields, which is not the desired effect.
  prefs: []
  type: TYPE_NORMAL
- en: What we want is, whenever the select box is updated, the filter query should
    clear. Whether it is the radio buttons or input box, selecting a new field should
    reset the filter query, this ensures a new search can begin.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by removing the link between the select box and the `filter.field`
    variable and creating our own method to handle the update. We then trigger the
    method when the select box is changed. This method will then clear the `query`
    variable and set the `field` variable to the select box value.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `v-model` attribute on the select box and add a new `v-on:change` attribute.
    We will pass a method name into this that will fire every time the select box
    is updated.
  prefs: []
  type: TYPE_NORMAL
- en: '`v-on` is a new Vue binding that we''ve not encountered before. It allows you
    to bind actions from elements to Vue methods. For example, `v-on:click` is one
    that is used the most commonly - which allows you to bind a `click` function to
    the element. We''ll cover more on this in the next section of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where v-bind can be `abbreviated` to just a colon, `v-on` can be shortened
    to an `@` symbol, allowing you to use `@click=""`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This attribute is firing the `changeFilter` method on every update and passing
    it the `$event` data of the change. This default Vue event object contains a lot
    of information that we could utilize, but the `target.value` data is the key we
    are after.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method in your Vue instance that accepts the event parameter and
    updates both the `query` and `field` variables. The `query` variable needs to
    be cleared, so set it to an empty string, whereas the `field` variable can be
    set to the value of the select box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Viewing your application now should clear whatever the filter query is, while
    still operating as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Combining the format functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next optimization will be to combine the `formatBalance` and `formatDate` methods
    in our Vue instance. This would then allow us to scale our format functions without
    bloating the code with several methods with similar functionality. There are two
    ways to approach a format style function—we can either auto-detect the format
    of the input or pass the desired format option in as a second option. Both have
    their pros and cons, but we'll walk through both.
  prefs: []
  type: TYPE_NORMAL
- en: Autodetection formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Autodetection of the variable type, when passed into a function, is great for
    cleaner code. In your view, you could invoke the function and pass the one parameter
    you wish to format. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The method would then contain a `switch` statement and format the variable based
    on the `typeof` value. A `switch` statement can evaluate a single expression and
    then execute different code based on the output. `Switch` statements can be very
    powerful as they allow clauses to be built up—utilizing several different bits
    of code based on the result. More can be read about `switch` statements on MDN.
  prefs: []
  type: TYPE_NORMAL
- en: '`Switch` statements are a great alternative to `if` statements if you are comparing
    the same expression. You are also able to have several cases for one block of
    code and even include a default if none of the previous cases was met. As an example
    of one in use, our format method might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The important thing to note is the `break;` lines. These finish each `switch`
    case. If a break was omitted, the code would carry on and execute the following
    case—which sometimes is the desired effect.
  prefs: []
  type: TYPE_NORMAL
- en: Autodetecting the variable type and formatting is a great way of simplifying
    your code. However, for our app, it is not a suitable solution as we are formatting
    the date, which when outputting the `typeof` results in a string, and would not
    be identifiable from other strings we may wish to format.
  prefs: []
  type: TYPE_NORMAL
- en: Passing in a second variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The alternative to the preceding autodetection is to pass the second variable
    into the `format` function. This gives us greater flexibility and scalability
    should we wish to format other fields. With the second variable, we can either
    pass in a fixed string that matches a preselected list in our `switch` statement
    or we could pass in the field itself. An example of the fixed string approach
    in the view would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This would work perfectly and would be great if we had several different fields
    that all needed to be formatted like `balance` currently does, but there seems
    to be some slight repetition in using the `balance` key and `currency` format.
  prefs: []
  type: TYPE_NORMAL
- en: As a compromise, we are going to pass the `person` object as the first parameter,
    so we can access all the data, and the name of the field as the second parameter.
    We will then use this for both identifying the format method required and to return
    the specific data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your view, replace both the `formatDate` and `formatBalance` functions with
    a singular format one, passing in the `person` variable as the first parameter,
    and the field enclosed quotes as the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new format method inside your Vue instance, which accepts two parameters: `person`
    and `key`. As the first step, retrieve the field using the person object and the
    `key` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have also created a second variable inside the function titled `output`—this
    will be what is returned at the end of the function and is set to the `field`
    by default. This ensures that if our formatting key does not match the one passed
    in, the untouched field data is returned—we do, however, convert the field to
    a string and trim any whitespace from the variable. Running the app now will return
    the fields without any formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `switch` statement, setting the expression to be just the `key`. Add
    two cases to the `switch` statement—one being `balance` and the other `registered`.
     As we do not wish for anything to happen to our input when it does not match
    a case, there is no need for us to have a `default` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We now just need to copy the code from our original formatting functions into
    the individual cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This format function is now a lot more flexible. We can add more `switch` cases
    should we need to cater for more fields (process the `name` field, for example)
    or we can add new cases to existing code. An example of this would be if our data
    contained a field that detailed the date on which the user `deactivated` their
    account, we could easily display it in the same format as registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Reducing the number of hard-coded variables and properties, and reducing redundancy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When looking at the Vue JavaScript, it is quickly evident that it can be optimized
    by introducing global variables and setting more local variables in the functions
    to make it more readable. We can also use existing functionality to stop repeating
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first optimization is in our `filterRow()` method where we check whether `filter.field`
    is active. This is also repeated in the `isActiveFilterSelected` method we use
    to show and hide our radio buttons. Update the `if` statement to use this method
    instead, so the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code has the `this.filter.field === ''isActive''` code removed
    and replaced with the `isActiveFilterSelected()` method. It should now look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'While we''re in the `filterRow` method, we can reduce the code by storing the
    `query` and `field` as variables at the start of the method. `result` is also
    not the right keyword for this, so let''s change it to `visible`. First, create
    and store our two variables at the start and rename `result` to `visible`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace all instances in that function of the variables, for example, the first
    part of the method would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Save your file and open the app in the browser to ensure your optimizations
    haven't broken the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last stage is to reorder the methods into an order that makes sense to
    you. Feel free to add comments to separate out the different method types—for
    example, ones that relate to CSS classes or filtering. I have also removed the `activeStatus`
    method, as we are able to utilize our `format` method to *format* the output of
    this field. After the optimizations, the JavaScript code now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating Vue components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we're confident our code is cleaner, we can move on to making Vue components
    for the various parts of our app. Put aside your code for now and open a new document
    while you get to grips with components.
  prefs: []
  type: TYPE_NORMAL
- en: Vue components are extremely powerful and a great addition to any Vue app. They
    allow you to make packages of reusable code that include their own data, methods,
    and computed values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our app, we have the opportunity to create two components: one for each
    person and one for the filtering section of our app. I would encourage you to
    always look at breaking your app into components where possible—this helps group
    your code into related functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Components look like mini Vue instances as each one has its own data, methods,
    and computed objects—along with some component-specific options that we will cover
    shortly. Components are also extremely useful when it comes to creating an app
    with different pages and sections—this will be covered in [Chapter 8](part0135.html#40NRU0-985bf4ae118d4f62b18ae64204cb251c), *Introducing
    Vue-Router and Loading URL-Based Components*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a component is registered, you create a custom HTML element to use in
    your view, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When naming your component, you can use kebab-case (hyphens), PascalCase (no
    punctuation, but each word is capitalized) or camelCase (similar to Pascal but
    the first word is not capitalized). Vue components are not restricted by, or associated
    with, the W3C web components/custom element rules, but it is good practice to
    follow this convention of using kebab-case.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and initializing your component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue components are registered using the `Vue.component(tagName, options)` syntax.
    Each component must have an associated tag name. The `Vue.component` registration **must**
    happen before you initialize your Vue instance. As a minimum, each component should
    have a `template` property—denoting what should be displayed when the component
    is used. Templates must always have a single wrapping element; this is so the
    custom HTML tag can be replaced with the parent container.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you couldn''t have the following as your template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you do pass a template of this format, Vue will throw an error in the browser's
    JavaScript console warning you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Vue component yourself, with a simple fixed template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this component declared, it would now give us a `<my-component></my-component>`
    HTML tag to use in our view.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify components on the Vue instance itself. This would be used
    if you had multiple Vue instances on one site and wished to contain a component
    to one instance. To do this, create your component as a simple object and assign
    the `tagName` within the `components` object of your Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For our app though, we are going to stick with the `Vue.component()` method
    of initializing our components.
  prefs: []
  type: TYPE_NORMAL
- en: Using your component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your view, add your custom HTML element component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Viewing this in the browser should replace the `<my-component>` HTML tag with
    a `<div>` and a hello message.
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be some cases where a custom HTML tag won''t be parsed and accepted
    - these cases tend to be in `<table>`, `<ol>`, `<ul>`, and `<select>` elements.
    If this is the case, you can use the `is=""` attribute on a standard HTML element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using component data and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Vue components are self-contained elements of your Vue app, they each have
    their own data and functions. This helps when re-using components on the same
    page, as the information is self-contained per instance of a component. `methods`
    and `computed` functions are declared the same as you would on the Vue app, however,
    the data key should be a function that returns an object.
  prefs: []
  type: TYPE_NORMAL
- en: The data object of a component must be a function. This is so that each component
    has its own self-contained data, rather than getting confused and sharing data
    between different instances of the same component. The function must still return
    an object as you would in your Vue app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component called `balance`, add a `data` function and `computed`
    object to your component and an empty `<div>` to the `template` property for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a key/value pair to your `cost` data object with an integer and add
    the variable to your template. Add the `<balance></balance>` custom HTML element to
    your view and you should be presented with your integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As with our Vue instance in [Chapter 1](part0023.html#LTSU0-985bf4ae118d4f62b18ae64204cb251c), *Getting
    Started with Vue.js*, add a function to the `computed` object that appends a currency
    symbol to the integer and ensures there are two decimal places. Don't forget to
    add the currency symbol to your data function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the template to output the computed value instead of the raw cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is a basic example of a component, however, it is quite restricted with
    the fixed `cost` on the component itself.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data to your component – props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the balance as a component is great, but not very good if the balance
    is fixed. Components really come into their own when you add the ability to pass
    in arguments and properties via HTML attributes. In the Vue world, these are called
    **props**. Props can be either static or variable. In order for your component
    to expect these properties, you need to create an array on the component by using
    the `props` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this would be if we wanted to make a `heading` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The component would then be used in the view like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With props, we don't need to define the `text` variable in the data object,
    as defining it in the props array automatically makes it available for use in
    the template. The props array can also take further options, allowing you to define
    the type of input expected, whether it is required or a default value to use if
    omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a prop to the balance component so we can pass the cost as an HTML attribute.
    Your view should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the cost prop to the component in the JavaScript, and remove
    the fixed value from our data function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Running this in our browser, however, will throw an error in our JavaScript
    console. This is because, natively, props being passed in are interpreted as strings.
    We can address this in two ways; we can either convert our prop to a number in
    our `formatCost()` function or, alternatively, we can use the `v-bind:` HTML attribute
    to tell Vue to accept the input for what it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, we used this technique with our filters for the `true` and
    `false` values—allowing them to be used as Boolean instead of strings. Add `v-bind:`
    in front of your `cost` HTML attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There is an extra step we can do to ensure Vue knows what kind of input to expect
    and informs other users of your code as to what they should be passing to the
    component. This can be done in the component itself and, along with the format,
    allows you to specify default values along with whether the prop is required or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert your `props` array to an object, with `cost` as the key. If you are
    just defining the field type, you can use the Vue shorthand for declaring this
    by setting the value as the field type. These can be String, Number, Boolean,
    Function, Object, Array, or Symbol. As our cost attribute should be a number,
    add that as the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be nice if, rather than throwing an error when nothing is defined,
    our component rendered `$0.00`. We can do this by setting the default to just
    `0`. To define a default we need to convert our prop into an object itself - containing
    a `type` key that has the value of `Number`. We can then define another `default` key
    and set the value to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Rendering the component in the browser should show whatever value is passed
    into the cost attribute—but removing this will render `$0.00`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, our component looks like :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We should be able to expand on this example when we make the`person` component
    of our listing app.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data to your component – slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when you may need to pass chunks of HTML to your component that
    are not stored in a property or that you want to format before appearing in the
    component. Rather than trying to pre-format in a computed variable or similar,
    you can use slots with your component.
  prefs: []
  type: TYPE_NORMAL
- en: Slots are like placeholders and allow you to place content between the opening
    and closing tags of your component and determine where they are going to display.
  prefs: []
  type: TYPE_NORMAL
- en: A perfect example of this would be a modal window. These normally have several
    tags and often consist of a lot of HTML to copy and paste if you wish to use it
    in your application multiple times. Instead, you can create a `modal-window` component
    and pass your HTML with a slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component titled `modal-window`. This accepts one prop of `visible`,
    which accepts a Boolean value and is `false` by default. For the template, we''ll
    use the HTML from the *Bootstrap modal* as a good example of how a component using
    slots can easily simplify your application. To ensure the component is styled,
    make sure you include the bootstrap *asset files* in your document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using the visible prop to determine whether the modal window is
    open or not. Add a `v-show` attribute to your outer container that accepts the
    `visible` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add your `modal-window` component to the app, specifying `visible` to be `true`
    for now, so we can understand and see what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to pass some data to our modal box. Add a heading and some paragraphs
    between the two tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Pressing refresh in the browser won''t do anything, as we need to tell the
    component what to do with the data. Inside your template, add a `<slot></slot>`
    HTML tag where you want your content to appear. Add it to the `div` with the `modal-body`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Viewing your app will now reveal the content you passed in inside the modal
    window. Already, the app is looking cleaner with this new component.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the Bootstrap HTML, we can see there is space for a header, body, and
    footer. We can identify these sections with named slots. This allows us to pass
    specific content to specific areas of our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two new `<slot>` tags in the header and footer of the modal window.
    Give these new ones a name attribute, but leave the existing one empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In our app, we can now specify what content goes where by specifying a `slot`
    attribute in the HTML. This can either go on a specific tag or a container around
    several tags. Any HTML without a `slot` attribute will also default to your unnamed
    slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can now specify and direct our content to specific places.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing you can do with slots is specified a default value. For example,
    you may want to display the buttons in the footer most of the time, but want to
    have the ability to replace them if desired. With a `<slot>`, any content placed
    between the tags will be displayed unless overwritten when specifying the component
    in your app.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new slot titled `buttons`,  and place the buttons in the footer inside.
    Try replacing them with some other content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Although we won't be utilizing slots with our people listing app, it's good
    to be aware of the capabilities of a Vue component. If you wished to use a modal
    box like this, you can set the visibility to a variable that is false by default.
    You can then add a button with a click method that changes the variable from `false`
    to `true`—displaying the modal box.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repeatable component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beauty of components is being able to use them multiple times in the same
    view. This gives you the ability to have one single "source of truth" for the
    layout of that data. We're going to make a repeatable component for our people
    list and a separate component for the filtering section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your people listing code you created in the last couple of chapters and
    create a new component titled `team-member`. Don''t forget to define the component
    before your Vue app is initialized. Add a `prop` to the component to allow the
    person object to be passed in. For validation purposes, only specify that it can
    be an `Object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We now need to integrate our template into the component, which is everything
    inside (and including) the `tr` in our View.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template variable in the component just accepts a normal string without
    new lines, so we need to do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: inline our HTML template—great for small templates but in this case will sacrifice
    readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: add new lines with the `+` string concatenation—great for one or two lines,
    but would bloat our JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: create a template block—Vue gives us the option to use external templates that
    are defined in the view using the `text/x-template` syntax and an ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As our template is quite big, we are going to choose the third option of declaring
    our template at the end of our view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your HTML, outside of your app, create a new script block and add a `type`
    and `ID` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then move our person template into this block and remove the `v-for`
    attribute—we''ll still use that in the app itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to update the view to use the `team-member` component instead of
    the fixed code. To make our view cleaner and easier to understand, we are going
    to utilize the `<template>` HTML attribute mentioned earlier. Create a `<template>`
    tag and add the `v-for` loop we had before. To avoid confusion, update the loop
    to use `individual` as the variable for each person. They can be the same, but
    it makes the code easier to read if the variables, components, and props have
    different names. Update the `v-for` to be `v-for="individual in people"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `template` tags of your view, add a new instance of the `team-member`
    component, passing the `individual` variable to the `person` prop. Don''t forget
    to add `v-bind:` to the person prop, otherwise, the component will interpret it
    as a fixed string with the value of the individual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to update the component to use the template we have declared using
    the `template` property and the ID of the script block as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Viewing the app in the browser will create several errors in the JavaScript
    console. This is because we are referencing several methods that are no longer
    available - as they are on the parent Vue instance, not on the component. If you
    want to verify that your component is working, change the code to only output
    the name of the person, and press refresh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Creating component methods and computed functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to create the methods we had created on the Vue instance on the
    child component, so they are available to use. One thing we could do is cut and
    paste the methods from the parent into the child in the hope they would work;
    however, those methods rely on parent properties (such as filtering data) and
    we also have the opportunity to utilize `computed` properties, which cache the
    data and can speed up your app.
  prefs: []
  type: TYPE_NORMAL
- en: For now, remove the `v-show` attribute from the `tr` element—as this involves
    the filtering, and that will be covered once we have our rows displaying correctly.
    We'll step through the errors and resolve them one at a time to help you understand
    problem-solving with Vue.
  prefs: []
  type: TYPE_NORMAL
- en: CSS class functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first error we encounter when viewing the application in the browser is:'
  prefs: []
  type: TYPE_NORMAL
- en: Property or method "balanceClass" is not defined
  prefs: []
  type: TYPE_NORMAL
- en: The first error is with regards to both the `balanceClass` and `activeClass`
    functions we use. Both of these functions add CSS classes based on the data of
    the person, which does not change once the component has been rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, we are able to use the caching found in Vue. Move the methods
    across to the component but put them in a new `computed` object, instead of the
    `methods` one.
  prefs: []
  type: TYPE_NORMAL
- en: 'With components, a new instance is created every time it is called, so we can
    rely on the `person` object we passed in via a `prop` and no longer need to pass
    the `person` into the function. Remove the parameter from the function and the
    view—also update any reference to `person` *inside* the function to `this.person`
    to reference the object stored on the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The part of our component template that utilizes this function should now look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Formatted value functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to moving the `format()` function to the component for formatting
    our data, we are faced with two options. We can move it like-for-like and put
    it in the `methods` object, or we can take advantage of the Vue caching and conventions
    and create a `computed` function for each value.
  prefs: []
  type: TYPE_NORMAL
- en: We are building this app for scalability, so it's advisable to make computed
    functions for each value—it will also have the advantage of tidying up our template.
    Create three functions in the computed object titled `balance`, `dateRegistered`,
    and `status`. Copy the corresponding parts of the `format` function across to
    each one, updating the reference of `person` to `this.person` once more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where we were retrieving the field using a function parameter, you can now
    fix the value in each function. You will also need to add a data object with the
    currency symbol for the balance function—add this after the `props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As the `team-member` component is the only place our currency symbol is used,
    we can remove it from the Vue app itself. We can also remove the format function
    from our parent Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In total, our Vue `team-member` component should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And our `team-member-template` should look fairly simple in comparison to what
    it did look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, our Vue instance should look significantly smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the app in the browser, we should be presented with our list of people
    with the correct classes added to the table cells and formatting added to the
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Making the filtering work again with props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Re-add the `v-show="filterRow()"` attribute to the containing `tr` element
    in your template. As our component has the person cached on each instance, we
    no longer need to pass the person object to the method. Refreshing the page will
    give you a new error in your JavaScript console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This error is because our component has the `v-show` attribute, showing and
    hiding based on our filtering and properties, but not the corresponding `filterRow`
    function. As we don''t use it for anything else, we can move the method from the
    Vue instance to the component, adding it to the `methods` component. Remove the
    person parameter and update the method to use `this.person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The next error in the console is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The reason the filtering does not work is that the `filterRow` method is looking
    for `this.filter.field` and `this.filter.query` on the component, not the parent
    Vue instance where it belongs.
  prefs: []
  type: TYPE_NORMAL
- en: As a quick fix, you can use `this.$parent` to reference data on the parent element—however,
    this is not recommended and should only be used in extreme circumstances or to
    quickly pass the data through.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass the data through to the component we are going to use another prop
    - similar to how we are passing the person into the component. Fortunately, we
    had grouped our filtering data already, so we are able to pass that one object
    instead of individual properties of `query` or `field`. Create a new prop on your
    component titled `filter` and ensure you only allow an `Object` to be passed through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add the prop to the `team-member` component, allowing us to pass
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for our filtering to work, we need to pass in one more property- the `isActiveFilterSelected()`
    function. Create another prop, titled `statusFilter`, allowing only a `Boolean`
    to be the value (as this is what the function equates to), and pass the function
    through. Update the `filterRow` method to use this new value. Our component now
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And the component within the View with the extra props now looks like the following.
    Note that the camel-cased prop becomes snake case (hyphenated) when used as an
    HTML attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Making the filters a component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to make the filtering section its own component. This isn't strictly
    necessary in this scenario, but it's good practice and gives us more challenges.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we face in making the filtering a component is a challenge of transferring
    filter data between the filtering component and the `team-member` component. Vue
    addresses this with custom events. These let you pass (or "emit") data to the
    parent or other components from the child component.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a filtering component which, on filtering change, passes
    the data back to the parent Vue instance. This data is already passed through
    to the `team-member` component to filter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the `team-member` component, declare a new `Vue.component()` in your
    JavaScript, referencing a template ID of `#filtering-template`. Create a new `<script>`
    template block in your view and give it the same ID. Replace the filtering form
    in the view with a `<filtering>` custom HTML template and put the form inside
    your `filtering-template` script block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your view should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And you should have the following in your JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Resolving JavaScript errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the `team-member` component, you are going to experience some errors
    in your JavaScript console. These can be resolved by copying the `filter` data
    object and both the `changeFilter` and `isActiveFilterSelected` methods from the
    parent instance. We''ll leave them in both the component and parent instance for
    now, but we''ll remove the duplication later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Running the app will show both the filters and person listing, but the filters
    won't update the people list as they are not communicating yet.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom events to change the filter field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With custom events, you can pass data back up to the parent instances using the
    `$on` and `$emit` functions. For this app, we are going to store the filtering
    data on the parent Vue instance and update it from the component. The `team-member`
    component can then read the data from the Vue instance and filter accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to utilize the filter object on the parent Vue instance.
    Remove the `data` object from your component and pass in the parent one via a
    prop - just as we did with the `team-member` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We are now going to modify the `changeFilter` function to emit the event data
    so the parent instance, so it can update the `filter` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing `changeFilter` method from the `filtering` component and
    create a new one called `change-filter-field`. Within this method, we just need
    to `$emit` the name of the field selected in the drop-down menu. The `$emit` function
    takes two parameters: a key and the value. Emit a key of `change-filter-field`
    and pass the `event.target.value` as the data. When using variables with multiple
    words (For example, `changeFilterField`), ensure these are hyphenated for the
    event name (the first parameter of the `$emit` function) and the HTML attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to then pass the data to the changeFilter method on our parent Vue
    instance, we need to add a new prop to our `<filtering>` element. This uses `v-on`
    and binds to the custom event name. It then has the parent method name as the
    attribute value. Add the attribute to your element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This attribute preceding tells Vue to trigger the `changeFilter` method when
    a `change-filter-field` event is emitted. We can then tweak our method to accept
    the parameter as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This then clears the filters and updates the field value, which then ripples
    down to our components via props.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the filter query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To emit the query field, we are going to use a new Vue key that we have not
    used before, called `watch`. The `watch` function tracks a data property and can
    run methods based on the output. The other thing it is able to do is to emit events.
    As both, our text field and radio buttons are set to update the field.query variable,
    we will create a new `watch` function on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `watch` object after the methods on your component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The key is the variable you wish to watch. As ours contains a dot, it needs
    to be wrapped in quotes. Within this function, create a new `$emit` event of `change-filter-query` that
    outputs the value of `filter.query`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to bind this method and custom event to the component in the view,
    so it is able to pass the data to the parent instance. Set the value of the attribute
    to `changeQuery`—we''ll make a method to handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'On the parent Vue instance, make a new method, titled `changeQuery`, that simply
    updates the `filter.query` value based on the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Our filtering is now working again. Both updating the select box and the input
    box (or radio buttons) will now update our person list. Our Vue instance is significantly
    smaller and our templates and methods are contained with separate components.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to avoid the repetition of the `isActiveFilterSelected()` method,
    as this is only used once on the `team-member` component, but several times on
    the `filtering` component. Remove the method from the parent Vue instance, the
    prop from the `team-member` HTML element, and replace the `statusFilter` variable
    in the `filterRow` method within the `team-member` component with the contents
    of the function being passed through.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final JavaScript now looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'And the view is now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last three chapters, you have learned how to initialize a new Vue instance,
    what the meaning behind computed, method, and data objects are, and how to list
    out data from an object and manipulate it to be displayed correctly. You have
    also learned how to make components and what benefits there are to keeping your
    code clean and optimized.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section of the book, we are going to introduce Vuex, something which
    helps us store and manipulate stored data better.
  prefs: []
  type: TYPE_NORMAL
