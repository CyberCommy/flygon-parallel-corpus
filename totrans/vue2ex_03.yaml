- en: Optimizing your App and Using Components to Display Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化您的应用程序并使用组件显示数据
- en: In [Chapter 2](part0031.html#TI1E0-985bf4ae118d4f62b18ae64204cb251c), *Displaying,
    Looping, Searching, and Filtering Data*, we got our Vue app displaying our people
    directory, we can use this opportunity to optimize our code and separate it out
    into components. This makes the code more manageable, easier to understand, and
    makes it easier for other developers to work out the flow of data (or you, when
    you come back and look at your code in a few months!).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0031.html#TI1E0-985bf4ae118d4f62b18ae64204cb251c)中，*显示、循环、搜索和过滤数据*，我们让Vue应用程序显示了我们的人员目录，我们可以利用这个机会来优化我们的代码并将其分离成组件。这使得代码更易于管理，更容易理解，并且使其他开发人员能够更容易地了解数据流程（或者在几个月后再次查看代码时，您自己也能更容易理解）。
- en: 'This chapter is going to cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Optimizing our Vue.js code by reducing the repetition, and logically organizing
    our code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过减少重复和逻辑组织我们的代码来优化我们的Vue.js代码
- en: How to create Vue components and use them with Vue
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建Vue组件并在Vue中使用它们
- en: How to use props and slots with components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在组件中使用props和slots
- en: Utilizing events to transfer data between components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用事件在组件之间传递数据
- en: Optimizing the code
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化代码
- en: 'As we wrote the code while we were figuring out the problem, there comes a
    point when you need to take a step back and look at your code to optimize it.
    This could include reducing the number of variables and methods or creating methods,
    to reduce repeating functionality. Our current Vue app looks like the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在解决问题时编写代码时，有一个时刻你需要退后一步，审视你的代码以进行优化。这可能包括减少变量和方法的数量，或者创建方法来减少重复的功能。我们当前的Vue应用程序如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Looking at the preceding code, there are some improvements we can make. These
    include:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看上述代码，我们可以进行一些改进。这些包括：
- en: Reducing the number of filter variables and grouping logically
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少过滤变量的数量并进行逻辑分组
- en: Combining the format functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并格式化函数
- en: Reducing the number of hard-coded variables and properties
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少硬编码的变量和属性的数量
- en: Re-ordering methods into a more logical order
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将方法重新排序为更合理的顺序
- en: We'll cover these points individually so we have a clean code base for building
    components with.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个讨论这些要点，以便我们有一个干净的代码库来构建组件。
- en: Reducing the number of filter variables and grouping logically
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少过滤变量的数量并进行逻辑分组
- en: 'The filtering currently uses up three variables, `filterField`, `filterQuery`,
    and `filterUserState`. The only thing that currently links these variables is
    the name, rather than being in an object of their own to link them systematically.
    Doing this avoids any ambiguity as to whether they are related to the same component
    or just coincidentally the same. In the data object, create a new object titled
    `filter` and move each variable inside:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的过滤使用了三个变量`filterField`，`filterQuery`和`filterUserState`。目前唯一将这些变量联系在一起的是名称，而不是它们自己的对象以系统地将它们链接在一起。这样做可以避免任何关于它们是否与同一组件相关或仅仅是巧合的歧义。在数据对象中，创建一个名为`filter`的新对象，并将每个变量移动到其中：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To access the data, update any references of `filterField` to `this.filter.field`.
    Note the extra dot, denoting it is a key of the filter object. Don''t forget to
    update `filterQuery` and `filterUserState` references as well. For example, the
    `isActiveFilterSelected` method would become:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数据，请将`filterField`的任何引用更新为`this.filter.field`。注意额外的点，表示它是过滤器对象的键。不要忘记更新`filterQuery`和`filterUserState`的引用。例如，`isActiveFilterSelected`方法将变为：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will also need to update the `v-model` and `v-show` attributes in your view—there
    are five occurrences of the various variables.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在视图中更新`v-model`和`v-show`属性-有五个不同变量的出现。
- en: While updating the filtering variables, we can take this opportunity to remove
    one. With our current filtering, we can only have one filter active at a time.
    This means the `query` and `userState` variables are only being used at any one
    time, which gives us the opportunity to combine these two variables. To do so,
    we'll need to update the view and application code to cater for this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新过滤变量的同时，我们可以利用这个机会删除一个变量。根据我们当前的过滤，我们一次只能有一个过滤器处于活动状态。这意味着 `query` 和 `userState`
    变量在任何时候只被使用一次，这给我们合并这两个变量的机会。为了做到这一点，我们需要更新视图和应用程序代码来适应这个变化。
- en: Remove the `userState` variable from your filter data object and update any
    occurrence of `filter.userState` in your view to `filter.query`. Now do a *find
    and replace* in your Vue JavaScript code for `filter.userState`, again replacing
    it with `filter.query`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的过滤数据对象中删除 `userState` 变量，并将视图中的任何 `filter.userState` 出现更新为 `filter.query`。现在，在您的Vue
    JavaScript代码中进行*查找和替换*，将 `filter.userState` 替换为 `filter.query`。
- en: 'Viewing your app in the browser, it will appear to initially work, being able
    to filter users by the field. However, if you filter by status, then switch to
    any other field, the query field won''t show. This is because using the radio
    buttons sets the value to a Boolean which, when trying to convert to lowercase
    for the query field, fails to do so. To tackle this, we can convert whatever value
    is in the `filter.query` variable to a string using the native JavaScript `String()`
    function. This ensures that our filtering function can work with any filtering
    input:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看您的应用程序时，它将首先显示正常，可以通过字段对用户进行筛选。然而，如果您按状态筛选，然后切换到任何其他字段，查询字段将不会显示。这是因为使用单选按钮将值设置为布尔值，当尝试将其转换为小写以用于查询字段时，无法成功。为了解决这个问题，我们可以使用原生的JavaScript
    `String()` 函数将 `filter.query` 变量中的任何值转换为字符串。这确保我们的过滤函数可以处理任何过滤输入：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding this to our code now ensures our query data is usable no matter what
    the value. The issue this now creates is when the user is switching between fields
    to filter. If you select the Active user and chose a radio button, the filtering
    works as expected, however, if you now switch to Email, or another field, the
    input box is prepopulated with either `true` or `false`. This instantly filters
    and will often return no results. This also occurs when switching between two
    text filtering fields, which is not the desired effect.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这个添加到我们的代码中，确保我们的查询数据可以使用任何值。现在创建的问题是当用户在字段之间切换进行筛选时。如果您选择了活动用户并选择了一个单选按钮，过滤将按预期工作，然而，如果您现在切换到电子邮件或其他字段，输入框将预填充为
    `true` 或 `false`。这会立即进行过滤，并且通常不会返回任何结果。当在两个文本过滤字段之间切换时，也会发生这种情况，这不是期望的效果。
- en: What we want is, whenever the select box is updated, the filter query should
    clear. Whether it is the radio buttons or input box, selecting a new field should
    reset the filter query, this ensures a new search can begin.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望的是，无论是单选按钮还是输入框，每当选择框更新时，过滤查询都应该被清除。选择一个新字段应该重置过滤查询，这样可以开始一个新的搜索。
- en: This is done by removing the link between the select box and the `filter.field`
    variable and creating our own method to handle the update. We then trigger the
    method when the select box is changed. This method will then clear the `query`
    variable and set the `field` variable to the select box value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过删除选择框与 `filter.field` 变量之间的链接，并创建我们自己的方法来处理更新来完成的。然后，在选择框更改时触发该方法。该方法将清除
    `query` 变量并将 `field` 变量设置为选择框的值。
- en: Remove the `v-model` attribute on the select box and add a new `v-on:change` attribute.
    We will pass a method name into this that will fire every time the select box
    is updated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择框上删除 `v-model` 属性，并添加一个新的 `v-on:change` 属性。我们将传递一个方法名给它，每当选择框更新时都会触发该方法。
- en: '`v-on` is a new Vue binding that we''ve not encountered before. It allows you
    to bind actions from elements to Vue methods. For example, `v-on:click` is one
    that is used the most commonly - which allows you to bind a `click` function to
    the element. We''ll cover more on this in the next section of the book.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-on`是一个我们之前没有遇到过的新的Vue绑定。它允许您将元素的操作绑定到Vue方法。例如，`v-on:click`是最常用的一个 - 它允许您将`click`函数绑定到元素上。我们将在本书的下一节中详细介绍这个。'
- en: 'Where v-bind can be `abbreviated` to just a colon, `v-on` can be shortened
    to an `@` symbol, allowing you to use `@click=""`, for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在v-bind可以简写为冒号的情况下，v-on可以缩写为@符号，允许您使用@click=""，例如：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This attribute is firing the `changeFilter` method on every update and passing
    it the `$event` data of the change. This default Vue event object contains a lot
    of information that we could utilize, but the `target.value` data is the key we
    are after.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性在每次更新时触发`changeFilter`方法，并传递`$event`更改的数据。这个默认的Vue事件对象包含了很多我们可以利用的信息，但我们关注的是`target.value`数据。
- en: 'Create a new method in your Vue instance that accepts the event parameter and
    updates both the `query` and `field` variables. The `query` variable needs to
    be cleared, so set it to an empty string, whereas the `field` variable can be
    set to the value of the select box:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Vue实例中创建一个接受事件参数并更新`query`和`field`变量的新方法。`query`变量需要被清除，所以将其设置为空字符串，而`field`变量可以设置为选择框的值：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Viewing your application now should clear whatever the filter query is, while
    still operating as expected.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看您的应用程序应该清除任何过滤查询，同时仍然按预期运行。
- en: Combining the format functions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合格式函数
- en: Our next optimization will be to combine the `formatBalance` and `formatDate` methods
    in our Vue instance. This would then allow us to scale our format functions without
    bloating the code with several methods with similar functionality. There are two
    ways to approach a format style function—we can either auto-detect the format
    of the input or pass the desired format option in as a second option. Both have
    their pros and cons, but we'll walk through both.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个优化将是将`formatBalance`和`formatDate`方法合并到我们的Vue实例中。这将允许我们扩展我们的格式函数，而不会用几个具有相似功能的方法膨胀代码。有两种方法可以处理格式样式函数
    - 我们可以自动检测输入的格式，或者将所需的格式选项作为第二个选项传递。两种方法都有其优缺点，但我们将逐步介绍两种方法。
- en: Autodetection formatting
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动检测格式化
- en: 'Autodetection of the variable type, when passed into a function, is great for
    cleaner code. In your view, you could invoke the function and pass the one parameter
    you wish to format. For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递给函数时，自动检测变量类型对于代码更清晰很有帮助。在您的视图中，您可以调用该函数并传递您希望格式化的一个参数。例如：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The method would then contain a `switch` statement and format the variable based
    on the `typeof` value. A `switch` statement can evaluate a single expression and
    then execute different code based on the output. `Switch` statements can be very
    powerful as they allow clauses to be built up—utilizing several different bits
    of code based on the result. More can be read about `switch` statements on MDN.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该方法将包含一个`switch`语句，并根据`typeof`值对变量进行格式化。`switch`语句可以评估单个表达式，然后根据输出执行不同的代码。`switch`语句非常强大，因为它允许构建子句
    - 根据结果利用几个不同的代码片段。有关`switch`语句的更多信息可以在MDN上阅读。
- en: '`Switch` statements are a great alternative to `if` statements if you are comparing
    the same expression. You are also able to have several cases for one block of
    code and even include a default if none of the previous cases was met. As an example
    of one in use, our format method might look like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在比较相同的表达式，那么`switch`语句是`if`语句的一个很好的替代方案。您还可以为一个代码块设置多个情况，甚至在之前的情况都不满足时包含一个默认情况。例如，我们使用的一个示例是format方法可能如下所示：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The important thing to note is the `break;` lines. These finish each `switch`
    case. If a break was omitted, the code would carry on and execute the following
    case—which sometimes is the desired effect.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项是`break;`行。这些行结束了每个`switch` case。如果省略了`break`，代码将继续执行下一个case，有时这是期望的效果。
- en: Autodetecting the variable type and formatting is a great way of simplifying
    your code. However, for our app, it is not a suitable solution as we are formatting
    the date, which when outputting the `typeof` results in a string, and would not
    be identifiable from other strings we may wish to format.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 自动检测变量类型和格式化是简化代码的好方法。然而，对于我们的应用程序来说，这不是一个合适的解决方案，因为我们正在格式化日期，而在输出`typeof`结果时，日期会被转换为字符串，并且无法与我们可能希望格式化的其他字符串区分开来。
- en: Passing in a second variable
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传入第二个变量
- en: 'The alternative to the preceding autodetection is to pass the second variable
    into the `format` function. This gives us greater flexibility and scalability
    should we wish to format other fields. With the second variable, we can either
    pass in a fixed string that matches a preselected list in our `switch` statement
    or we could pass in the field itself. An example of the fixed string approach
    in the view would be:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的自动检测相反，我们可以将第二个变量传入`format`函数中。这样做可以使我们在需要格式化其他字段时具有更大的灵活性和可扩展性。对于第二个变量，我们可以传入一个固定的字符串，与我们`switch`语句中的预选列表匹配，或者我们可以直接传入字段本身。在视图中使用固定字符串的示例如下：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This would work perfectly and would be great if we had several different fields
    that all needed to be formatted like `balance` currently does, but there seems
    to be some slight repetition in using the `balance` key and `currency` format.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有几个不同的字段都需要像`balance`一样进行格式化，那么这种方法将非常完美，但是在使用`balance`键和`currency`格式时似乎存在一些重复。
- en: As a compromise, we are going to pass the `person` object as the first parameter,
    so we can access all the data, and the name of the field as the second parameter.
    We will then use this for both identifying the format method required and to return
    the specific data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了妥协，我们将把`person`对象作为第一个参数传入，这样我们就可以访问所有的数据，将字段的名称作为第二个参数传入。然后我们将使用这个参数来确定所需的格式化方法，并返回特定的数据。
- en: Creating the method
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建方法
- en: 'In your view, replace both the `formatDate` and `formatBalance` functions with
    a singular format one, passing in the `person` variable as the first parameter,
    and the field enclosed quotes as the second:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的视图中，用一个格式化函数替换`formatDate`和`formatBalance`函数，将`person`变量作为第一个参数传入，将字段用引号括起来作为第二个参数：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new format method inside your Vue instance, which accepts two parameters: `person`
    and `key`. As the first step, retrieve the field using the person object and the
    `key` variable:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Vue实例中创建一个新的格式化方法，接受两个参数：`person`和`key`。作为第一步，使用`person`对象和`key`变量检索字段：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have also created a second variable inside the function titled `output`—this
    will be what is returned at the end of the function and is set to the `field`
    by default. This ensures that if our formatting key does not match the one passed
    in, the untouched field data is returned—we do, however, convert the field to
    a string and trim any whitespace from the variable. Running the app now will return
    the fields without any formatting.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在函数内部创建了一个名为`output`的第二个变量，这将在函数结束时返回，并默认设置为`field`。这样可以确保如果我们的格式化键与传入的键不匹配，将返回未经处理的字段数据。但是，我们会将字段转换为字符串并删除变量中的任何空格。现在运行应用程序将返回没有任何格式化的字段。
- en: 'Add a `switch` statement, setting the expression to be just the `key`. Add
    two cases to the `switch` statement—one being `balance` and the other `registered`.
     As we do not wish for anything to happen to our input when it does not match
    a case, there is no need for us to have a `default` statement:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`switch`语句，将表达式设置为`key`。在`switch`语句中添加两个case，一个是`balance`，另一个是`registered`。由于我们不希望在输入不匹配case时发生任何操作，所以我们不需要有一个`default`语句：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We now just need to copy the code from our original formatting functions into
    the individual cases:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将原始格式化函数中的代码复制到各个case中：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This format function is now a lot more flexible. We can add more `switch` cases
    should we need to cater for more fields (process the `name` field, for example)
    or we can add new cases to existing code. An example of this would be if our data
    contained a field that detailed the date on which the user `deactivated` their
    account, we could easily display it in the same format as registered:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个格式化函数现在更加灵活。如果我们需要处理更多字段（例如处理`name`字段），我们可以添加更多的`switch` case，或者我们可以在现有代码中添加新的case。例如，如果我们的数据包含一个字段，详细说明用户`停用`帐户的日期，我们可以轻松地以与注册日期相同的格式显示它：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Reducing the number of hard-coded variables and properties, and reducing redundancy
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少硬编码的变量和属性的数量，减少冗余
- en: When looking at the Vue JavaScript, it is quickly evident that it can be optimized
    by introducing global variables and setting more local variables in the functions
    to make it more readable. We can also use existing functionality to stop repeating
    ourselves.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看Vue JavaScript时，很快就会发现可以通过引入全局变量并在函数中设置更多的局部变量来进行优化，以使其更易读。我们还可以使用现有功能来避免重复。
- en: 'The first optimization is in our `filterRow()` method where we check whether `filter.field`
    is active. This is also repeated in the `isActiveFilterSelected` method we use
    to show and hide our radio buttons. Update the `if` statement to use this method
    instead, so the code is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个优化是在我们的`filterRow()`方法中，我们检查`filter.field`是否处于活动状态。这也在我们用于显示和隐藏单选按钮的`isActiveFilterSelected`方法中重复出现。更新`if`语句以使用此方法，代码如下：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code has the `this.filter.field === ''isActive''` code removed
    and replaced with the `isActiveFilterSelected()` method. It should now look like
    this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码已删除`this.filter.field === 'isActive'`代码，并替换为`isActiveFilterSelected()`方法。现在它应该是这样的：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'While we''re in the `filterRow` method, we can reduce the code by storing the
    `query` and `field` as variables at the start of the method. `result` is also
    not the right keyword for this, so let''s change it to `visible`. First, create
    and store our two variables at the start and rename `result` to `visible`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`filterRow`方法中时，我们可以通过在方法开始时将`query`和`field`存储为变量来减少代码。`result`也不是正确的关键字，所以让我们将其更改为`visible`。首先，在开头创建和存储我们的两个变量，并将`result`重命名为`visible`：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Replace all instances in that function of the variables, for example, the first
    part of the method would look like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 替换该函数中所有变量的所有实例，例如，方法的第一部分将如下所示：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Save your file and open the app in the browser to ensure your optimizations
    haven't broken the functionality.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并在浏览器中打开应用程序，以确保优化不会破坏功能。
- en: 'The last stage is to reorder the methods into an order that makes sense to
    you. Feel free to add comments to separate out the different method types—for
    example, ones that relate to CSS classes or filtering. I have also removed the `activeStatus`
    method, as we are able to utilize our `format` method to *format* the output of
    this field. After the optimizations, the JavaScript code now looks like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating Vue components
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we're confident our code is cleaner, we can move on to making Vue components
    for the various parts of our app. Put aside your code for now and open a new document
    while you get to grips with components.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Vue components are extremely powerful and a great addition to any Vue app. They
    allow you to make packages of reusable code that include their own data, methods,
    and computed values.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'For our app, we have the opportunity to create two components: one for each
    person and one for the filtering section of our app. I would encourage you to
    always look at breaking your app into components where possible—this helps group
    your code into related functions.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Components look like mini Vue instances as each one has its own data, methods,
    and computed objects—along with some component-specific options that we will cover
    shortly. Components are also extremely useful when it comes to creating an app
    with different pages and sections—this will be covered in [Chapter 8](part0135.html#40NRU0-985bf4ae118d4f62b18ae64204cb251c), *Introducing
    Vue-Router and Loading URL-Based Components*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'When a component is registered, you create a custom HTML element to use in
    your view, for example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When naming your component, you can use kebab-case (hyphens), PascalCase (no
    punctuation, but each word is capitalized) or camelCase (similar to Pascal but
    the first word is not capitalized). Vue components are not restricted by, or associated
    with, the W3C web components/custom element rules, but it is good practice to
    follow this convention of using kebab-case.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Creating and initializing your component
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue components are registered using the `Vue.component(tagName, options)` syntax.
    Each component must have an associated tag name. The `Vue.component` registration **must**
    happen before you initialize your Vue instance. As a minimum, each component should
    have a `template` property—denoting what should be displayed when the component
    is used. Templates must always have a single wrapping element; this is so the
    custom HTML tag can be replaced with the parent container.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you couldn''t have the following as your template:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you do pass a template of this format, Vue will throw an error in the browser's
    JavaScript console warning you.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Vue component yourself, with a simple fixed template:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this component declared, it would now give us a `<my-component></my-component>`
    HTML tag to use in our view.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify components on the Vue instance itself. This would be used
    if you had multiple Vue instances on one site and wished to contain a component
    to one instance. To do this, create your component as a simple object and assign
    the `tagName` within the `components` object of your Vue instance:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For our app though, we are going to stick with the `Vue.component()` method
    of initializing our components.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Using your component
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your view, add your custom HTML element component:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Viewing this in the browser should replace the `<my-component>` HTML tag with
    a `<div>` and a hello message.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be some cases where a custom HTML tag won''t be parsed and accepted
    - these cases tend to be in `<table>`, `<ol>`, `<ul>`, and `<select>` elements.
    If this is the case, you can use the `is=""` attribute on a standard HTML element:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using component data and methods
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Vue components are self-contained elements of your Vue app, they each have
    their own data and functions. This helps when re-using components on the same
    page, as the information is self-contained per instance of a component. `methods`
    and `computed` functions are declared the same as you would on the Vue app, however,
    the data key should be a function that returns an object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The data object of a component must be a function. This is so that each component
    has its own self-contained data, rather than getting confused and sharing data
    between different instances of the same component. The function must still return
    an object as you would in your Vue app.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component called `balance`, add a `data` function and `computed`
    object to your component and an empty `<div>` to the `template` property for now:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, add a key/value pair to your `cost` data object with an integer and add
    the variable to your template. Add the `<balance></balance>` custom HTML element to
    your view and you should be presented with your integer:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As with our Vue instance in [Chapter 1](part0023.html#LTSU0-985bf4ae118d4f62b18ae64204cb251c), *Getting
    Started with Vue.js*, add a function to the `computed` object that appends a currency
    symbol to the integer and ensures there are two decimal places. Don't forget to
    add the currency symbol to your data function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the template to output the computed value instead of the raw cost:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a basic example of a component, however, it is quite restricted with
    the fixed `cost` on the component itself.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Passing data to your component – props
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the balance as a component is great, but not very good if the balance
    is fixed. Components really come into their own when you add the ability to pass
    in arguments and properties via HTML attributes. In the Vue world, these are called
    **props**. Props can be either static or variable. In order for your component
    to expect these properties, you need to create an array on the component by using
    the `props` property.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this would be if we wanted to make a `heading` component:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The component would then be used in the view like so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With props, we don't need to define the `text` variable in the data object,
    as defining it in the props array automatically makes it available for use in
    the template. The props array can also take further options, allowing you to define
    the type of input expected, whether it is required or a default value to use if
    omitted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a prop to the balance component so we can pass the cost as an HTML attribute.
    Your view should now look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can now add the cost prop to the component in the JavaScript, and remove
    the fixed value from our data function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Running this in our browser, however, will throw an error in our JavaScript
    console. This is because, natively, props being passed in are interpreted as strings.
    We can address this in two ways; we can either convert our prop to a number in
    our `formatCost()` function or, alternatively, we can use the `v-bind:` HTML attribute
    to tell Vue to accept the input for what it is.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, we used this technique with our filters for the `true` and
    `false` values—allowing them to be used as Boolean instead of strings. Add `v-bind:`
    in front of your `cost` HTML attribute:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is an extra step we can do to ensure Vue knows what kind of input to expect
    and informs other users of your code as to what they should be passing to the
    component. This can be done in the component itself and, along with the format,
    allows you to specify default values along with whether the prop is required or
    not.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert your `props` array to an object, with `cost` as the key. If you are
    just defining the field type, you can use the Vue shorthand for declaring this
    by setting the value as the field type. These can be String, Number, Boolean,
    Function, Object, Array, or Symbol. As our cost attribute should be a number,
    add that as the key:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It would be nice if, rather than throwing an error when nothing is defined,
    our component rendered `$0.00`. We can do this by setting the default to just
    `0`. To define a default we need to convert our prop into an object itself - containing
    a `type` key that has the value of `Number`. We can then define another `default` key
    and set the value to `0`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Rendering the component in the browser should show whatever value is passed
    into the cost attribute—but removing this will render `$0.00`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, our component looks like :'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We should be able to expand on this example when we make the`person` component
    of our listing app.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Passing data to your component – slots
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when you may need to pass chunks of HTML to your component that
    are not stored in a property or that you want to format before appearing in the
    component. Rather than trying to pre-format in a computed variable or similar,
    you can use slots with your component.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Slots are like placeholders and allow you to place content between the opening
    and closing tags of your component and determine where they are going to display.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: A perfect example of this would be a modal window. These normally have several
    tags and often consist of a lot of HTML to copy and paste if you wish to use it
    in your application multiple times. Instead, you can create a `modal-window` component
    and pass your HTML with a slot.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component titled `modal-window`. This accepts one prop of `visible`,
    which accepts a Boolean value and is `false` by default. For the template, we''ll
    use the HTML from the *Bootstrap modal* as a good example of how a component using
    slots can easily simplify your application. To ensure the component is styled,
    make sure you include the bootstrap *asset files* in your document:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will be using the visible prop to determine whether the modal window is
    open or not. Add a `v-show` attribute to your outer container that accepts the
    `visible` variable:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add your `modal-window` component to the app, specifying `visible` to be `true`
    for now, so we can understand and see what is going on:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We now need to pass some data to our modal box. Add a heading and some paragraphs
    between the two tags:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Pressing refresh in the browser won''t do anything, as we need to tell the
    component what to do with the data. Inside your template, add a `<slot></slot>`
    HTML tag where you want your content to appear. Add it to the `div` with the `modal-body`
    class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Viewing your app will now reveal the content you passed in inside the modal
    window. Already, the app is looking cleaner with this new component.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the Bootstrap HTML, we can see there is space for a header, body, and
    footer. We can identify these sections with named slots. This allows us to pass
    specific content to specific areas of our component.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two new `<slot>` tags in the header and footer of the modal window.
    Give these new ones a name attribute, but leave the existing one empty:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In our app, we can now specify what content goes where by specifying a `slot`
    attribute in the HTML. This can either go on a specific tag or a container around
    several tags. Any HTML without a `slot` attribute will also default to your unnamed
    slot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can now specify and direct our content to specific places.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The last thing you can do with slots is specified a default value. For example,
    you may want to display the buttons in the footer most of the time, but want to
    have the ability to replace them if desired. With a `<slot>`, any content placed
    between the tags will be displayed unless overwritten when specifying the component
    in your app.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Create a new slot titled `buttons`,  and place the buttons in the footer inside.
    Try replacing them with some other content.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The template becomes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And the HTML:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Although we won't be utilizing slots with our people listing app, it's good
    to be aware of the capabilities of a Vue component. If you wished to use a modal
    box like this, you can set the visibility to a variable that is false by default.
    You can then add a button with a click method that changes the variable from `false`
    to `true`—displaying the modal box.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repeatable component
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beauty of components is being able to use them multiple times in the same
    view. This gives you the ability to have one single "source of truth" for the
    layout of that data. We're going to make a repeatable component for our people
    list and a separate component for the filtering section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your people listing code you created in the last couple of chapters and
    create a new component titled `team-member`. Don''t forget to define the component
    before your Vue app is initialized. Add a `prop` to the component to allow the
    person object to be passed in. For validation purposes, only specify that it can
    be an `Object`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We now need to integrate our template into the component, which is everything
    inside (and including) the `tr` in our View.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'The template variable in the component just accepts a normal string without
    new lines, so we need to do one of the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: inline our HTML template—great for small templates but in this case will sacrifice
    readability
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: add new lines with the `+` string concatenation—great for one or two lines,
    but would bloat our JavaScript
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: create a template block—Vue gives us the option to use external templates that
    are defined in the view using the `text/x-template` syntax and an ID
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As our template is quite big, we are going to choose the third option of declaring
    our template at the end of our view.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'In your HTML, outside of your app, create a new script block and add a `type`
    and `ID` attribute:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can then move our person template into this block and remove the `v-for`
    attribute—we''ll still use that in the app itself:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We now need to update the view to use the `team-member` component instead of
    the fixed code. To make our view cleaner and easier to understand, we are going
    to utilize the `<template>` HTML attribute mentioned earlier. Create a `<template>`
    tag and add the `v-for` loop we had before. To avoid confusion, update the loop
    to use `individual` as the variable for each person. They can be the same, but
    it makes the code easier to read if the variables, components, and props have
    different names. Update the `v-for` to be `v-for="individual in people"`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Inside the `template` tags of your view, add a new instance of the `team-member`
    component, passing the `individual` variable to the `person` prop. Don''t forget
    to add `v-bind:` to the person prop, otherwise, the component will interpret it
    as a fixed string with the value of the individual:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We now need to update the component to use the template we have declared using
    the `template` property and the ID of the script block as the value:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Viewing the app in the browser will create several errors in the JavaScript
    console. This is because we are referencing several methods that are no longer
    available - as they are on the parent Vue instance, not on the component. If you
    want to verify that your component is working, change the code to only output
    the name of the person, and press refresh:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Creating component methods and computed functions
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to create the methods we had created on the Vue instance on the
    child component, so they are available to use. One thing we could do is cut and
    paste the methods from the parent into the child in the hope they would work;
    however, those methods rely on parent properties (such as filtering data) and
    we also have the opportunity to utilize `computed` properties, which cache the
    data and can speed up your app.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: For now, remove the `v-show` attribute from the `tr` element—as this involves
    the filtering, and that will be covered once we have our rows displaying correctly.
    We'll step through the errors and resolve them one at a time to help you understand
    problem-solving with Vue.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: CSS class functions
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first error we encounter when viewing the application in the browser is:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Property or method "balanceClass" is not defined
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The first error is with regards to both the `balanceClass` and `activeClass`
    functions we use. Both of these functions add CSS classes based on the data of
    the person, which does not change once the component has been rendered.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, we are able to use the caching found in Vue. Move the methods
    across to the component but put them in a new `computed` object, instead of the
    `methods` one.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'With components, a new instance is created every time it is called, so we can
    rely on the `person` object we passed in via a `prop` and no longer need to pass
    the `person` into the function. Remove the parameter from the function and the
    view—also update any reference to `person` *inside* the function to `this.person`
    to reference the object stored on the component:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The part of our component template that utilizes this function should now look
    like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Formatted value functions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to moving the `format()` function to the component for formatting
    our data, we are faced with two options. We can move it like-for-like and put
    it in the `methods` object, or we can take advantage of the Vue caching and conventions
    and create a `computed` function for each value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: We are building this app for scalability, so it's advisable to make computed
    functions for each value—it will also have the advantage of tidying up our template.
    Create three functions in the computed object titled `balance`, `dateRegistered`,
    and `status`. Copy the corresponding parts of the `format` function across to
    each one, updating the reference of `person` to `this.person` once more.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Where we were retrieving the field using a function parameter, you can now
    fix the value in each function. You will also need to add a data object with the
    currency symbol for the balance function—add this after the `props`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As the `team-member` component is the only place our currency symbol is used,
    we can remove it from the Vue app itself. We can also remove the format function
    from our parent Vue instance.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'In total, our Vue `team-member` component should look like:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And our `team-member-template` should look fairly simple in comparison to what
    it did look like:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And lastly, our Vue instance should look significantly smaller:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Viewing the app in the browser, we should be presented with our list of people
    with the correct classes added to the table cells and formatting added to the
    fields.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Making the filtering work again with props
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Re-add the `v-show="filterRow()"` attribute to the containing `tr` element
    in your template. As our component has the person cached on each instance, we
    no longer need to pass the person object to the method. Refreshing the page will
    give you a new error in your JavaScript console:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This error is because our component has the `v-show` attribute, showing and
    hiding based on our filtering and properties, but not the corresponding `filterRow`
    function. As we don''t use it for anything else, we can move the method from the
    Vue instance to the component, adding it to the `methods` component. Remove the
    person parameter and update the method to use `this.person`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The next error in the console is:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The reason the filtering does not work is that the `filterRow` method is looking
    for `this.filter.field` and `this.filter.query` on the component, not the parent
    Vue instance where it belongs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: As a quick fix, you can use `this.$parent` to reference data on the parent element—however,
    this is not recommended and should only be used in extreme circumstances or to
    quickly pass the data through.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass the data through to the component we are going to use another prop
    - similar to how we are passing the person into the component. Fortunately, we
    had grouped our filtering data already, so we are able to pass that one object
    instead of individual properties of `query` or `field`. Create a new prop on your
    component titled `filter` and ensure you only allow an `Object` to be passed through:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can then add the prop to the `team-member` component, allowing us to pass
    the data:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In order for our filtering to work, we need to pass in one more property- the `isActiveFilterSelected()`
    function. Create another prop, titled `statusFilter`, allowing only a `Boolean`
    to be the value (as this is what the function equates to), and pass the function
    through. Update the `filterRow` method to use this new value. Our component now
    looks like:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And the component within the View with the extra props now looks like the following.
    Note that the camel-cased prop becomes snake case (hyphenated) when used as an
    HTML attribute:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Making the filters a component
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to make the filtering section its own component. This isn't strictly
    necessary in this scenario, but it's good practice and gives us more challenges.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The problem we face in making the filtering a component is a challenge of transferring
    filter data between the filtering component and the `team-member` component. Vue
    addresses this with custom events. These let you pass (or "emit") data to the
    parent or other components from the child component.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a filtering component which, on filtering change, passes
    the data back to the parent Vue instance. This data is already passed through
    to the `team-member` component to filter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Creating the component
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the `team-member` component, declare a new `Vue.component()` in your
    JavaScript, referencing a template ID of `#filtering-template`. Create a new `<script>`
    template block in your view and give it the same ID. Replace the filtering form
    in the view with a `<filtering>` custom HTML template and put the form inside
    your `filtering-template` script block.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Your view should look like the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And you should have the following in your JavaScript:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Resolving JavaScript errors
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the `team-member` component, you are going to experience some errors
    in your JavaScript console. These can be resolved by copying the `filter` data
    object and both the `changeFilter` and `isActiveFilterSelected` methods from the
    parent instance. We''ll leave them in both the component and parent instance for
    now, but we''ll remove the duplication later:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Running the app will show both the filters and person listing, but the filters
    won't update the people list as they are not communicating yet.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Using custom events to change the filter field
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With custom events, you can pass data back up to the parent instances using the
    `$on` and `$emit` functions. For this app, we are going to store the filtering
    data on the parent Vue instance and update it from the component. The `team-member`
    component can then read the data from the Vue instance and filter accordingly.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to utilize the filter object on the parent Vue instance.
    Remove the `data` object from your component and pass in the parent one via a
    prop - just as we did with the `team-member` component:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We are now going to modify the `changeFilter` function to emit the event data
    so the parent instance, so it can update the `filter` object.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing `changeFilter` method from the `filtering` component and
    create a new one called `change-filter-field`. Within this method, we just need
    to `$emit` the name of the field selected in the drop-down menu. The `$emit` function
    takes two parameters: a key and the value. Emit a key of `change-filter-field`
    and pass the `event.target.value` as the data. When using variables with multiple
    words (For example, `changeFilterField`), ensure these are hyphenated for the
    event name (the first parameter of the `$emit` function) and the HTML attribute:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In order to then pass the data to the changeFilter method on our parent Vue
    instance, we need to add a new prop to our `<filtering>` element. This uses `v-on`
    and binds to the custom event name. It then has the parent method name as the
    attribute value. Add the attribute to your element:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This attribute preceding tells Vue to trigger the `changeFilter` method when
    a `change-filter-field` event is emitted. We can then tweak our method to accept
    the parameter as the value:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This then clears the filters and updates the field value, which then ripples
    down to our components via props.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Updating the filter query
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To emit the query field, we are going to use a new Vue key that we have not
    used before, called `watch`. The `watch` function tracks a data property and can
    run methods based on the output. The other thing it is able to do is to emit events.
    As both, our text field and radio buttons are set to update the field.query variable,
    we will create a new `watch` function on this.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `watch` object after the methods on your component:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The key is the variable you wish to watch. As ours contains a dot, it needs
    to be wrapped in quotes. Within this function, create a new `$emit` event of `change-filter-query` that
    outputs the value of `filter.query`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We now need to bind this method and custom event to the component in the view,
    so it is able to pass the data to the parent instance. Set the value of the attribute
    to `changeQuery`—we''ll make a method to handle this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'On the parent Vue instance, make a new method, titled `changeQuery`, that simply
    updates the `filter.query` value based on the input:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Our filtering is now working again. Both updating the select box and the input
    box (or radio buttons) will now update our person list. Our Vue instance is significantly
    smaller and our templates and methods are contained with separate components.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to avoid the repetition of the `isActiveFilterSelected()` method,
    as this is only used once on the `team-member` component, but several times on
    the `filtering` component. Remove the method from the parent Vue instance, the
    prop from the `team-member` HTML element, and replace the `statusFilter` variable
    in the `filterRow` method within the `team-member` component with the contents
    of the function being passed through.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'The final JavaScript now looks like:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'And the view is now:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last three chapters, you have learned how to initialize a new Vue instance,
    what the meaning behind computed, method, and data objects are, and how to list
    out data from an object and manipulate it to be displayed correctly. You have
    also learned how to make components and what benefits there are to keeping your
    code clean and optimized.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: In the next section of the book, we are going to introduce Vuex, something which
    helps us store and manipulate stored data better.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
