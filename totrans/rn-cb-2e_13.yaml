- en: Integration with Native Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Combining a React Native app and a Native iOS app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating from an iOS app to React Native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating from React Native to an iOS app container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle being invoked by an external iOS app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining a React Native app and a native Android app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating from an Android app to React Native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating from React Native to an Android app container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle being invoked by an external Android app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Native was introduced as a solution to build native applications using
    JavaScript, with the goal of granting more developers the ability to build truly
    native applications for multiple platforms. As a consequence of building a React
    Native application with a team, it can be common for JavaScript developers and
    native developers to work closely together.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of React Native's ability to render native UI views is
    that they can be easily embedded inside existing native apps. It is not uncommon
    for companies to already have sophisticated native apps that are critical to their
    line of business. There may be no immediate need to rewrite their entire codebase
    in React Native if the app is not broken. In such a case, React Native can be
    leveraged by both JavaScript and native developers to write React Native code
    that can be integrated into an existing app.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus exclusively on using React Native inside existing native
    iOS and Android applications. We will cover rendering a React Native app within
    a native app, how to communicate between the React Native app and its native parent
    app, and how our React Native app can be invoked with other apps on a user's device.
  prefs: []
  type: TYPE_NORMAL
- en: When working on the Android recipes, it is recommended that you enable the auto-import
    settings in Android Studio or use *Alt*+*Enter* to perform a quick fix code completion
    for the class import.
  prefs: []
  type: TYPE_NORMAL
- en: Combining a React Native app and a Native iOS app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the event that you work for a company or have a client that has an active
    iOS app out in the world, it may not be advantageous to rewrite it from scratch,
    especially if it is well-built, used frequently, and praised by its users. If
    you just want to build new functionality using React Native, the React Native
    app can be embedded and rendered inside an existing native iOS app.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe will walk through creating a blank iOS app and adding it to a React
    Native app so that the two layers can communicate with each other. We will cover
    two ways of rendering the React Native app: embedded inside the application as
    a nested view, and another as a full-screen implementation. The steps that are
    discussed in this recipe serve as a baseline for rendering React Native apps,
    along with native iOS apps.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will be referencing a native iOS application named `EmbeddedApp`.
    We will walk through creating the sample iOS application in this section. If you already
    have an iOS app you intend on integrating with React Native, you can skip ahead
    to the recipe instructions. You will, however, need to be sure that you have `cocoapods`
    installed. This library is a package manager for Xcode projects. It can be installed
    via Homebrew using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With `cocoapods` installed, the next step is creating a new native iOS project
    in Xcode. This can be done by opening Xcode and choosing File | New | Project.
    In the window that follows, choose the default Single View Application iOS template
    to get started, and hit Next.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the options screen for the new project, be sure to set the Product Name
    field to `EmbeddedApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/86748b32-0ee0-44e1-82c2-bfb91772e34f.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll begin by creating a new vanilla React Native app that will serve as
    the root of our project. Let''s name the new project `EmbedApp`. You can create
    the new React Native app with the CLI using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By creating the new app with the CLI, the `ios` and `android` subfolders will
    be automatically created for us, holding the native code for each platform. Let's
    move the native app we created in the *Getting ready* section to the `ios` folder
    so that it lives at `/EmbedApp/ios/EmbeddedApp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have the basic structure we need for the app, we'll need to add
    a Podfile. This is a file, similar to `package.json` in web development, that
    keeps track of all of the cocoapod dependencies (called pods) that are used in
    a project. The Podfile should always live in the root of the vanilla iOS project,
    which in our case is `/EmbedApp/ios/EmbeddedApp`. In a Terminal, `cd` into this
    directory and run the `pod init` command. This generates a base Podfile for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open the Podfile in your favorite IDE. We''ll be adding the pods that
    are needed for the app to this file. The following is the contents of the final
    Podfile, with the newly added React Native dependencies in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice how each of the paths listed in the React Native dependencies that we're
    adding point to the `/node_modules` folder of the React Native project. If your
    native project (in our case, `EmbeddedApp`) was at a different location, these
    references to `/node_modules` would have to be updated accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: With the Podfile in place, installing the pods themselves is as easy as running
    the `pod install` command from the Terminal in the same directory we created the
    Podfile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let''s return to the React Native app at the root directory of the project, `/EmbedApp`.
    We''ll start by removing the generated code in `index.js`, and replacing it with
    our own simple React Native app.At the bottom of the file, we''ll use the `registerComponent` method
    on the `AppRegistry` component to register `EmbedApp` as the root component of
    the React Native app. This will be a very simple app that just renders the text
    `Hello in React Native` so that it can be distinguished from the native layer
    in later steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a React Native app, we can move to the native code. When we
    initialized cocoapods in *step 3*, it also generated a new `.xcworkspace` file. Be
    sure to close the `EmbeddedApp` project in Xcode, then re-open it in Xcode using
    the `EmbeddedApp.xcworkspace` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Xcode, let''s open `Main.storyboard`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8137ae79-365d-4021-92fb-a3bbea5710bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the storyboard, we''ll need to add two buttons: one labeled Open React Native
    App and one labeled Open React Native App (Embedded). We''ll also need a new container
    view below the two buttons. The resulting storyboard should look something like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a5422254-5435-4d34-b043-6a2d199e9c7b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we''ll need a new a new Cocoa Touch Class. This can be created from the
    menus by choosing File | New | File. We''ll name the class `EmbeddedViewController` and assign
    it a subclass of `UIViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0a544b69-116a-491e-baa8-7f3c3e89db2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s return to `Main.storyboard`. In the new scene that''s created by adding
    the class in the previous step (second View Controller Scene), select the View
    Controller child. Make sure that the Identity inspector is open in the right-hand
    panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/25acdbd3-b7a1-4297-8988-fdcfb99b9742.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the View Controller selected, change the Class value to our newly created
    class, `EmbeddedViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b1431a9d-3d22-43cb-90ac-a676db65613a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, in the top View Controller Scene, select the Embed segue object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/83a215de-c779-4dc6-892d-c75beede2ef1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the segue selected, select the Attributes inspector from the right-hand
    panel, and update the Identifier field to the embed value. We will use this identifier
    to embed the React Native layer within the native app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/00ca967c-3df7-4d4c-8e6b-45e58d03b7ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''re ready to build out the `ViewController` implementation. Open the `ViewController.m` file.
    We''ll start with the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Just beneath the imports, we can add an interface definition to point to the
    `EmbeddedViewController` we created in *step 10*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Following is the `@interface`, we'll add the methods we need to the `@implementation`.
    The first method, `openRNAppButtonPressed`, will be wired to the first button
    we created in the storyboard, labeled Open React Native App. Likewise, the `openRNAppEmbeddedButtonPressed`
    method will be wired to the second button, Open React Native App (Embedded).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll likely notice that the methods are almost identical, with the second
    method referencing `embeddedViewController`, the same `EmbeddedViewController`
    class we created in step 10 (`[embeddedViewController setView:rootView];`). Both
    methods define `jsCodeLocation` with the value of `http://localhost:8081/index.bundle?platform=ios`,
    which is the URL that the React Native app will be served from. Also, take note
    that the `moduleName` property in both methods is set to `EmbedApp`, which is
    the name that the React Native app is exported as, which we defined in *step 6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need to define the `prepareForSegue` method. Here, you can see `segue.identifier
    isEqualToString:@"embed"`, which refers to the embed identifier we gave the segue
    in *step 13*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With our implementation of `ViewController` in place, we now we need to wire
    up our button actions to the buttons themselves. Let''s return to `Main.storyboard`. *Ctrl +*
    click on the first button to get a menu of actions that are assignable to the
    button, select the Touch Up Inside action by clicking and dragging from Touch
    Up Inside back to the storyboard, and map the button to the `openRNAppButtonPressed` method
    we defined in *step 15*. Repeat these steps for the second button, linking it
    instead to the `openRNAppEmbeddedButtonPressed` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7d82272a-9878-4c24-900c-86db62b70e71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the React Native layer to be able to communicate with the native layer,
    we also need to add a security exception, which will allow our code to communicate
    with `localhost`. Right-click on the `Info.plist` file and select Open As | Source
    Code. Within the base `<dict>` tag, add the following entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app is complete! From the `/EmbedApp` root directory, start up the React
    Native app using the CLI with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the React Native app running, let's also run the native app `EmbeddedApp`
    from Xcode. Now, pressing the Open React Native App button should open the React
    Native app we created in *step 6* in full screen, and the same React Native app
    should open within the container view we created in *step 9* when pressing the
    Open React Native App (Embedded) button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we covered rendering a React Native app within a native iOS
    app via two different methods. The first method replaces the application's main
    `UIViewController` instance with the React Native app, referred to in the native
    code as `RCTRootView`. This was accomplished in the `openRNAppButtonPressed` method.
    The second and slightly more involved method is rendering the React Native app
    inline with the native app. This was accomplish by creating a container view that links
    to a different `UIViewController` instance. In this case, we replaced the contents
    of `embedViewController` with our `RCTRootView` instance. This is what happens
    when the `openRNAppEmbeddedButtonPressed` method is fired.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a better understanding of the role cocoapods plays in Xcode/React Native
    development, I recommend Google's *Route 85 Show* episode covering the subject
    on YouTube. The video can be found at [https://www.youtube.com/watch?v=iEAjvNRdZa0](https://www.youtube.com/watch?v=iEAjvNRdZa0).
  prefs: []
  type: TYPE_NORMAL
- en: Communicating from an iOS app to React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to render a React Native app as part
    of a larger native iOS app. Unless you're building a glorified app container or
    portal, you'll likely need to communicate between the native layer and the React
    Native layer. This will be the subject matter of the next two recipes, one recipe
    for each direction of communication.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will cover communicating from the native layer to the React
    Native layer, sending data from the parent iOS app to our embedded React Native
    app, by using a `UITextField` in the iOS app that sends its data to the React
    Native app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this recipe requires a native app with a nested React Native app within
    it, we'll be beginning at the end of the previous recipe, effectively picking
    up where we left off. This will help you understand how basic cross-layer communication
    works so that you can use the same principles in your own native app, which may
    already exist and have complex features. Therefore, the easiest way to follow
    along with this recipe is to use the endpoint of the previous recipe as a starting
    place.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by updating the `ViewController.m` implementation file in the
    native layer. Be sure to open the project in Xcode via the `.xcworkspace` file
    in the `EmbeddedApp`, which we placed in the `/ios/EmbeddApp` directory of the
    project in the previous recipe. We''ll start with the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add a reference to the React Native bridge via the `ViewController`
    interface, effectively linking the native controller with the React Native code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need an `@property` reference of `userNameField` that we will
    use in a later step to wire to the `UITextField`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Directly below this reference, we''ll begin defining the class methods. We''ll
    begin with the `sourceURLForBridge` method, which defines where the React Native
    app will be served from. In our case, the app URL should be `http://localhost:8081/index.bundle?platform=ios`, which
    points at the `index.js` file of the React Native app once it is run with the `react-native
    start` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll leave the `viewDidLoad` and `didReveiveMemoryWarning` methods as is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll need to update the `openRNAppEmbeddedButtonPressed` method. Notice
    how the `moduleName` property is set to `FromNativeToRN`. This is a reference
    to the name that we give the React Native app when it is exported, which we''ll
    define in a later step. This time, we are also defining a property of `userName`
    for passing data to the React Native layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need an `onUserNameChanged` method. This is the method that will
    do the actual sending of data across the bridge to the React Native layer. The
    event name we''re defining here is `UserNameChanged`, which we''ll reference in
    the React Native layer in a later step. This will also pass along the text that''s
    currently in the text input, which will be named `userNameField`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need `prepareForSegue` for configuring `embeddedViewController`
    just before it is displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `Main.storyboard`, let''s add that Text Field, along with a Label
    that defines what the input is for. You can also name the input User Name Field so
    that everything is easier to recognize in the View Controller Scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c44f2cfe-f832-489c-8dcf-543f805b85c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we''ll need to wire an event for when the text changes in the User Name
    Field text input, and a referencing outlet so that the View Controller knows how
    to reference it. These can both be done via the Connections Inspector, which is
    accessible via the last button along the top of the right-hand side panel (the
    icon is a right pointing arrow in a circle).  With the text input selected, click
    and drag from Editing Changed to the View Controller (represented via the main
    storyboard), and choose the `onUserNameChange` method we defined in *step 7*.
    Then, create the following wirings by dragging the item to the `ViewController`.
    Similarly, add a new Referencing Outlet by clicking and dragging from the New
    Referencing Outlet back to the View Controller, this time choosing the userNameField
    value we targeted in *step 7*. Your Connections Inspector settings should now
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e423f6dc-291d-448b-aef0-95862640aa3a.png)'
  prefs: []
  type: TYPE_IMG
- en: We've now completed the steps needed in the native app. Let's move on to the
    React Native layer. Back in the `index.js` file, we'll start with imports. Notice
    how we're now including the `NativeAppEventEmitter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the following functions inside the class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll name the app `FromNativeToRN` to match the module name we defined in
    the native layer in *step 6*, using `AppRegistry.registerComponent` to register
    the app with the same name. We''ll also leave the basic styles in place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll set an initial `state` object with a `userName` string property for
    storing and displaying the text that''s received from the native layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `userName` value passed into the React Native layer will be received as
    a property. When the component mounts, we want to do two things: set the `userName` state
    property if it''s already defined by the native layer, and wire an event listener
    to update `userName` when the text field in the native layer is updated. Recall
    in *step 7* that we defined the event''s name to be `UserNameChanged`, so that''s
    the event we''ll listen for. When the event is received, we update the `state.userName`
    to the text that''s passed along with the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can add the `render` function, which simply renders the value stored
    in `state.userName`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to run our app! First, in the root of the project, we can start
    up the React Native app with the React Native CLI with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We follow this by running the native app in the simulator via Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f917a790-b142-4636-b6e0-b547fae1b21f.png)'
  prefs: []
  type: TYPE_IMG
- en: Communicating from React Native to an iOS app container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last recipe covered communication between layers in the direction of native
    to React Native. In this recipe, we will cover communicating in the opposite direction:
    from React Native to native. This time, we will render a user input element inside
    our React Native app and set up a one-way binding from React Native to a UI component
    rendered in the native app.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the last recipe, this recipe depends on the final product of the first
    app in this chapter, in the *Combining a React Native app and a Native iOS app* recipe.
    To follow along, be sure you've finished that recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin in the native layer. Open the `EmbeddedApp` native app in Xcode
    via the `.xcworkspace` file. We''ll first add imports to `ViewController.m`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did in the last recipe, we need to add a reference to the React Native
    bridge via the `ViewController` interface, providing a bridge between the native
    controller and the React Native code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need a `@property` reference of `userNameField` that we will use
    in a later step to wire to the `UITextField`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move on to defining the `@implementation`. Again, we must provide the
    source of the React Native app, which will be served from `localhost`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `viewDidLoad` method, we can also connect the controller to the method
    that opens the React Native app in our container view (`openRNAppEmbeddedButtonPressed`).
    We''ll leave the `didReveiveMemoryWarning` method as is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the last recipe, we''ll need to update the `openRNAppEmbeddedButtonPressed`
    method. This time, the `moduleName` property is set to `FromRNToNative` to reflect
    the name that we will give the React Native app when it is exported, as defined
    in a later step. We also define a property of `userName` for passing data to the
    React Native layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two methods we''ll need in this file are `prepareForSegue` for configuring
    the `embeddedViewController` just before it is displayed, and an `updateUserNameField` method
    that will be fired when our text input in the native layer is updated with new
    text from the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the previous recipe, we''ll need to also update the `ViewController` header
    file (`ViewController.h`). The method referenced here, `updateUserNameField`,
    will be used when we define the `ViewController` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''re going to need to create a new `UserNameManager` native module.
    First, create a Cocoa Touch class named `UserNameManager`. Once created, let''s
    open the implementation file (`UserNameManger.m`) and add our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For a more in-depth look at creating native modules, refer to the *Exposing
    Custom iOS Modules *recipe in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding
    Native Functionality**.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll define the class implementation. The main takeaway here is the `setUserName`
    method, which is the method that we''re exporting from the native layer for use
    in the React Native app. We''ll use this method in the React Native app to update
    the value in the native Text Field. However, since we are updating a native UI
    component, the operation must be performed on the main thread. This is the purpose
    of the `methodQueue` function, which instructs the module to execute on the main
    thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need to update the `UserNameMangager.h` header file to use the
    React Native bridge module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the last recipe, we''ll need to add a Text Field and Label for the User
    Name input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5e24e43a-1913-49b0-b7c5-0c78dceebc4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll also need to add a Referencing Outlet from the Text Field we created
    in the last set to our `userNameField` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0d70c124-06e7-4132-b78a-985abbe8592c.png)If you need more information
    on how to create a Referencing Outlet, view *step 10* of the previous recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re finished with the native portion of this project, so let''s turn to
    our React Native code. Let''s open the `index.js` file at the root of the project.
    We''ll start with our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the app with the name `FromRNToNative` to line up with the `moduleName`
    we declared in the native code in *step 6*, and register the component with the
    same name. The `state` object only needs a `userName` string property for hold
    the value that''s saved to the `TextInput` component, which we''ll add in the
    component''s `render` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The app''s `render` function uses a `TextInput` component to take input from
    the user, which it will then send to the native app via the React Native bridge.
    It does this by calling the `onUserNameChange` method when the value of the `TextInput`
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do is define the `onUserNameChange` method that''s
    used by the `onChangeText` property of the `TextInput` component we defined in
    the previous step. This method updates `state.userName` to the value in the text
    input, and also sends the value along to the native code by using the `NativeModules`
    component in React Native. `NativeModules` has the `UserNameManager` class we
    defined as a Cocoa Touch class in the native layer in *step 9*. We call the `setUserName`
    method that we defined on the class in *step 10* to pass the value along to the
    native layer, where it will be displayed in the Text Field we created in *step
    12*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The app is done! Return to the root of the project to start up the React Native
    app with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, with the React Native app started, run the native `EmbeddedApp` project
    from Xcode. Now, the input in the React Native app should communicate its value
    to the input in the parent native app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/02a70ade-cb5a-4dd8-bd2e-13ea02e8a899.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To communicate from our React Native app to the parent native app, we created
    a native module named `UserNameManager` with a `setUserName` method, which we
    exported from the native layer, and used in the React Native app, in its `onUserNameChange`
    method. This is the recommended way of communicating from React Native to native.
  prefs: []
  type: TYPE_NORMAL
- en: Handle being invoked by an external iOS app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is also a common behavior for native apps to communicate between one another
    via linking, and are usually prompted to the user with the phrase Open in...,
    along with the name of an app that can better handle an action. This is done by
    using a protocol that is specific to your app. Just like any website link has
    a protocol of either `http://` or `https://`, we can also create a custom protocol
    that will allow any other app to open and send data to our app.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be creating a custom protocol called `invoked://`. By
    using the `invoked://` protocol, any other app can use it to run our app and pass
    data to it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll be starting from a new vanilla React Native app. Let's
    name it `InvokeFromNative`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by opening the native layer of the new project in Xcode. The first
    thing we need to do is adjust the project''s Build Settings. This can be done
    by selecting the root project in the left panel, then choosing the Build Settings
    tab along the top of the middle panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d0e90cd7-0f3c-4270-85a1-05792d34f948.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll need to add a new entry to the Header Search Paths field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3e1e1fb4-601b-4bbf-94f1-554e18e332da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the project to know the location of the React Native JavaScript, it needs
    the `$(SRCROOT)/../node_modules/react-native/Libraries` value. Let''s add it as
    a recursive entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/068fa616-dda9-4c8c-b4ce-d540f1217b06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also need to register our custom protocol, which will be used by other apps.
    Open the `Info.plist` file as source code (right-click then Open As | Source Code).
    Let''s add an entry to the file that will register our application under the `invoked://`
    protocol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the `RCTLinkingManager` to the `AppDelegate` implementation,
    which lives in `AppDelegate.m`, and wire it to our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s move on to the React Native layer. Inside `index.js`, we''ll add
    our imports, which includes the `Linking` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create the class definition and register the component as `InvokeFromNative`.
    We''ll also define an initial `state` object with a `status` string property set
    to the value `''App Running''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll use the mount and unmount life cycle hooks to `add`/`remove` the
    event listener for the `invoked://` protocol. When the event is heard, the `onAppInvoked`
    method, which is defined in the next step, will be fired:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onAppInvoked` function simply takes the event from the event listener
    and updates `state.status` to reflect that invocation has happened, displaying
    the protocol via `event.url`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` method''s only real purpose in this recipe is to render the `status`
    property on state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also add a few basic styles to center and size the text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app is finished. Once you''ve started running the app, you should see something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d62bd623-bd8b-495d-a7c1-39a95eedbec4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the app running, we can simulate the action of another app opening our
    React Native app using the `invoked://` protocol. This can be done with the following
    Terminal command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Once invoked, the app should update to reflect the invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c8a2362a-570a-4888-a103-c418c6f76378.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we covered how to register a custom protocol (or URL schema)
    for allowing our app to be invoked by other apps. The aim of this recipe was to
    keep our example as simple as possible, so we did not build out the handling data
    we passed to an app via the linking mechanism. However, it is entirely possible
    to do so if the needs of your app require it. For a deeper dive on the `Linking`
    component, check out the official documents at [https://facebook.github.io/react-native/docs/linking](https://facebook.github.io/react-native/docs/linking).
  prefs: []
  type: TYPE_NORMAL
- en: Combining a React Native app and a native Android app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the Android platform still holds the majority stake in the smartphone
    market space, it's likely that you'll want to build the app for both Android as
    well as iOS. A large advantage of React Native development is making this process
    easier. But what happens when you want to write a new feature using React Native
    for a working Android app that's already been published? Fortunately, React Native makes
    this possible as well.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will cover the process of embedding a React Native app inside an
    existing Android app by displaying the React Native app inside a container view.
    The steps here are used as a baseline for the recipes that follow, which involve
    communication with a React Native app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a sample Android application using Android
    Studio called `EmbedApp`. If you have a base Android application you would like
    to work with, you can skip these steps and proceed to the actual implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Android Studio and create a new project (File|New Project)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the application name to `EmbeddedApp` and fill out your company domain.
    Press Next
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave Empty Activity selected as the default and press Next
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the Activity properties as they are by default and press Finish
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, our app has no references to React Native, so we''ll start by
    installing it. In the app''s root folder, in the Terminal, install React Native
    from the command line using `yarn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need a Node.js script for starting the React Native app. Let''s
    open `package.json` and add the following property as a member of the scripts object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We only need a very simple React Native app for this recipe. Let''s create
    an `index.android.js` file with the following boilerplate app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Naming this file `index.android.js` indicates to React Native that this code
    only applies to the Android version of this app. This is recommended by the official
    docs when platform-specific code is more complex. You can read more about it at [https://facebook.github.io/react-native/docs/platform-specific-code#platform-specific-extensions](https://facebook.github.io/react-native/docs/platform-specific-code#platform-specific-extensions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to Android Studio and open the `build.gradle` file (from the app module)
    and add the following to the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need a reference to the local React Native maven directory. Open
    the other `build.gradle` and add the following line to the `allprojects.repositories`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s update the app''s permissions to use the internet, and the system
    alert window. We''ll open `AndroidManifest.xml` and add the following permissions
    to the `<manifest>` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re ready to update the `MainApplication` Java class. The `getUseDeveloperSupport`
    method here will enable the development menu. The `getPackages` method is a list
    of packages used by the app, and only includes `MainReactPackage()` since we are
    only using the main React package. The `getJSMainModuleName` method returns the `index.android` string,
    which refers to the `index.android.js` file in the React Native layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create another new Java class with the name `ReactFragment`. This
    class needs three methods: `OnAttach` is called when the fragment is attached
    to the main activity, `OnCreateView` instantiates the view for the fragment, and
    `OnActivityCreated` is called when the activity is being created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a Java class called `EmbedFragment` that will extend `ReactFragment`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Let's open `MainActivity.java` and add `implements DefaultHardwareBackBtnHandler` to
    the class definition for handling hardware back button events. You can view the
    annotated source code for this React Native class here: [https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/modules/core/DefaultHardwareBackBtnHandler.java](https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/modules/core/DefaultHardwareBackBtnHandler.java).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll also be adding a few methods to the class. The `onCreate` method will
    set the content view to the Main Activity and add a FAB button that, when clicked,
    will instantiate a new instance of the `EmbedFragment` we defined in *step 10*.
    That instance of `EmbedFragment` is used by the fragment manager to add the React
    Native app to the view. The remaining methods handle the events that occur when
    the device''s system buttons are pressed (such as the back, pause, and resume
    buttons):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to add some settings for the layout when the fragment is loaded.
    We''ll need to edit the `content_main.xml` file, which is located in the `/res`
    folder. This is the main content of the view. It holds the container view (`FrameLayout`)
    that we will attach the fragment to, and the other native elements should be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Terminal, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This builds and hosts the React Native app. Now, we can open the app in the Android
    emulator. You will see the following after pressing the FAB button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6f5ee6bb-0ec1-4474-9748-606437b3d2c8.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To accomplish rendering React Native inside of our Android application, we had
    to perform a few steps. First, we had to define an `Application` class that implements
    the `ReactApplication` interface. Then, we had to create a `Fragment` that would
    be responsible for instantiating and rendering the `ReactRootView`. With a fragment,
    we are able to render the React Native view in our `MainActivity`. In this recipe,
    we added the fragment to our fragment container view. This essentially replaces
    all of the application content with the React Native application.
  prefs: []
  type: TYPE_NORMAL
- en: We covered a lot of integration code in this recipe. For a more in-depth look
    at how each of these pieces work, you can read the official documentation at [https://facebook.github.io/react-native/docs/integration-with-existing-apps.html](https://facebook.github.io/react-native/docs/integration-with-existing-apps.html).
  prefs: []
  type: TYPE_NORMAL
- en: Communicating from an Android app to React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered how to render our React Native app inside an Android
    app in the *Combining a React Native app and a native Android app* recipe, we're
    ready to take the next step. Our React Native application should be more than
    a dummy UI. It should be able to react to actions that are going on in its parent
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will accomplish sending data from our Android application
    to our embedded React Native app. The React Native application can accept data
    when it is first instantiated, and then at runtime. We will be covering how to
    accomplish both methods. This recipe will use `EditText` in the Android app and
    set up one-way binding to the React Native app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, please ensure that you have an Android app with a React Native
    app embedded. If you need guidance to accomplish this, please complete the *Combining
    a React Native app and a native Android app* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android Studio, open the Android portion of the React Native app. First,
    we'll need to edit `content_main.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll only need a very simple layout for this app. You can edit the file by
    pressing the Text tab on the bottom to open the source editor and add/replace
    the following nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `MainActivity.java` and add the following class fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `onCreatemethod`, set the `userNameField` property with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll be using a FAB button to update the content of the Android app to be
    our React Native app. We will need to replace `FloatingActionButtononClickListener` with
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add a `TextChangedListener` to our `userNameField` in the `onCreate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The last change we need to make for our `Activity` is to add methods that will
    send the event across the React Native bridge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s return to the JavaScript layer. We''ll use the `addListener` method
    of the `NativeAppEventEmitter` component to listen to the `UserNameChanged` event
    that was sent from the native Android code, and update `state.userName` with the
    data from the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run the application, you can enter text in the User Name field
    and start the React Native application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8eed73c3-6777-48bd-81f6-965e890169aa.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we rendered the fragment as an inline view. In *step 2*, we
    added an empty `FrameLayout` that we targeted in *step 5* to render the fragment.
    The binding functionality was accomplished by using the React Native bridge via
    `RCTDeviceEventEmitter`. This was originally designed to be used with native modules,
    but as long as you have access to the `ReactContext` instance, you can use it
    for any communication with the React Native JavaScript layer.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating from React Native to an Android app container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in the previous recipe, it is extremely beneficial for our embedded application to
    be aware of what's going on around it. We should also make an effort so that our
    Android parent application can be informed about what goes on inside the React
    Native application. The application should not only be able to perform business
    logic – it should be able to update its UI to reflect changes in the embedded
    app.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows us how to leverage native modules to update the native UI
    that's created inside the Android application. We will have a text field in our
    React Native app that updates a text field that is rendered in the host Android
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, please ensure that  you have an Android application with a
    React Native app embedded. If you need guidance to accomplish this, please complete
    the *Combining a React Native app and a native Android app* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Android Studioto your Project and open `content_main.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press the Texttab on the bottom to open the source editor and add/replace the
    following nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Create a Java class named `UserNameManager`. This will be a native module that
    will serve the purpose of updating the `EditTextfield` we added to the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are not familiar with creating a native module for React Native, please
    refer to the *Exposing custom Android modules* recipe in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding
    Native Functionality*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the work in `UserNameManager.java` is being done in the `setUserName`
    method. Here, the Android layer updates the text contents of the view based on
    what it''s sent from the React Native layer. The React method isn''t necessarily
    going to run on the main UI thread, so we use `mainActivity.runOnUiThread` to
    update the view when the main UI thread is ready:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'To export the `UserNameManager` module, we''ll need to edit the `UserNamePackage`
    Java class. We can export it to the React Native layer by calling `modules.add`,
    passing in a new `UserNameManager` that takes the `reactContext` as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `UserNamePackage` in the `getPackages` method in `MainApplication`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to have our React Native UI render a `TextField` and call our `UserNameManager` native
    module. Open `index.android.js` and import the `TextInput` and `NativeModules` modules
    from `'react-native'`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable reference for the `UserNameManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The React Native app will simply need a `TextInput` for manipulating a `userName`
    property on the `state` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the application, starting the React Native embedded app, and
    adding text to the text field, you should see something similar to what''s shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c3c111f9-4a0b-455c-8784-1e859f69db12.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get our React Native app to update the native app containers, we created
    a native module. This is the recommended way of communicating from JavaScript
    to the native layer. However, since we had to update a native UI component, the
    operation had to be performed on the main thread. This is achieved by getting
    a reference to `MainActivity` and calling the `runOnUiThread` method. This is
    done in the `setUserName` method of *step 4*.
  prefs: []
  type: TYPE_NORMAL
- en: Handle being invoked by an external Android app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we covered how to handle invocation from an external
    app in iOS in the *Handle being invoked by an external Android app* recipe. In
    this recipe, we'll cover the same concept of deep linking in Android.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by opening the React Native Android project in Android Studio and
    navigating to `AndroidManifest.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our example, we will register our application under `invoked://scheme`.
    We''ll update the `<activity>` node to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: For more information on how this `intent-filter` works, refer to the official
    Android documentation at [https://developer.android.com/training/app-links/deep-linking](https://developer.android.com/training/app-links/deep-linking).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll need to create a simple React Native app whose UI reacts to being
    invoked. Let''s open the `index.android.js` file. We''ll start by importing the `Linking`
    module in the `import` block from `''react-native''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build out the `App` class for the React Native app. When the component
    mounts, we''ll register a `Linking` event listener with an event we''ll name `url`.
    When this event occurs, `onAppInvoked` will be fired, updating the `status` property
    of state, along with the event that''s passed to the callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the application and invoking it from another app will look something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3c740e41-fd02-4b2a-8be2-32e7a7935dfc.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we registered our URL schema for linking by editing the `AndroidManifest.xml` file
    in *step 2*. An important thing to note is the change of the `launchMode` to `singleTask`.
    This prevents the operating system from creating multiple instances of our React
    activity. This is important if you want to be able to properly capture the data
    that's passed along with the intent.
  prefs: []
  type: TYPE_NORMAL
