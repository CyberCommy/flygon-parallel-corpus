- en: Chapter 7. Unobtrusive JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing "Hello World" unobtrusively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a glowing "submit" button with the event listener
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a button stand out when you hover over it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resizing an element with unobtrusive jQuery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Masking a password with unobtrusive JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an event listener to animate an image shadow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of unobtrusive JavaScript fits right into responsive design. By
    keeping your interaction layer at an arm's length from your presentation layer,
    you can build a great degree of flexibility into your web app. Because mobile
    devices have very different input methods, you may need to call a function through
    a different event. You may want to create a desktop version of a page with JavaScript
    and use jQuery Mobile instead for your mobile version; with the same template
    files, by using unobtrusive JavaScript, this is not a difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: Writing "Hello World" unobtrusively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important facet of responsive design is interaction. As we know that mobile
    devices and desktops have very different user interfaces, we cannot expect that
    our JavaScript interaction scripts will work across all devices. An illustrative
    example is the `.mouseover()` or mouse hover event listener. The mouse is not
    attached to a touch screen device, so any misdirected attempt at the `.mouseover()`
    event would likely function as a `.click()` event. The solution to this is to
    fully remove your interaction script from your templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method is referred to as "Unobtrusive JavaScript". Here, instead of embedding
    scriptlets like `onclick()` in your HTML template, you can create an external
    JavaScript that runs through a series of event listeners to set up your interaction.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with a simple example; we will create only a button and an alert.
    Many JavaScripts start as a test; in essence, I will create an event listener
    and then debug it with an alert. We start by creating an HTML page with a simple
    `submit` button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There you go, that was a simple task, but not very exciting. That''s just a
    basic `submit` button, even though it did not submit anything. So let''s make
    this more interesting, one step at a time. Start by adding some custom text to
    the button, so that we at least have some expectation of what might happen when
    this page is ready. We add `value="Say Hello"`. That''s enough for the `body`
    tags, next we add a `script` tag to the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the script tags, you will need to add an event to start the JavaScript.
    The script would otherwise not run without the `$(document).ready(function(){...});`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this function, replace `//do something` with a listener for the `:submit`
    button click event that fires a function to somehow put Hello World on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have created a JavaScript that loads as the page loads and listens
    for when the user clicks on the button. When the `click` event occurs, a function
    executes, but right now that function is empty. Our next task is to create the
    method of adding the "Hello World" text to the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the function, we want to append the "Hello World" text to the parent
    element of the `:submit` button. Since the `:submit` button is the object from
    which the method is firing, we can reference it by using `$(this)` in jQuery.
    To attach the "Hello World" text, use the jQuery `.append()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The jQuery will append the "Hello World" text to the end of HTML's `body` tag.
    To have more control over where the text is appended, wrap the button in a parent
    `div` element.
  prefs: []
  type: TYPE_NORMAL
- en: Open the HTML file in the browser and test the button's functions. If pressing
    the button does not make the text **Hello World** appear under the button, then
    something has gone wrong. Go back through the tutorial and see where you went
    astray.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, we can't just let the text be plain text. We want to be able
    to do more with this later. Mark it up with a paragraph tag that includes an `ID`
    attribute, `helloWorld`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have accomplished our basic intention, to clicks a button,
    and write Hello World. That is good, but not good enough; because we always over-deliver,
    don't we?
  prefs: []
  type: TYPE_NORMAL
- en: Outside the `.click()` event function, add a variable `foo` for the string `Hello
    World`. Next, replace the `.append(...)` function's internal Hello World text
    with the `foo` variable. Removing the text from the method and replacing it with
    a variable makes things easier to work with, and is only a small step towards
    improving this function. Refresh and test your page to make sure everything still
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `body` tags, we are now going to personalize this page by sending
    the text to the script through a form `input` element. Inside your HTML body tags,
    enter a text `input` element with `id="bar"` and `placeholder="Enter your name"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To receive the text from our input box, we need to add a new variable bar inside
    your function. Set it equal to the value of the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update your `.append()` method by changing it to include `foo`, `bar`,
    and some new text, all wrapped in a styleable element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you refresh this page, you see that the text box has been added. Try
    it out by entering your name in the input box and watch the results.
  prefs: []
  type: TYPE_NORMAL
- en: This is great, but not complete. Now it's time for some cleanup. Let's go through
    some scenarios that we want to avoid. We do not want to be able to submit an empty
    input or keep adding more lines of **Hello World**.
  prefs: []
  type: TYPE_NORMAL
- en: First, take care of the blank input box. Let us add an `if` condition to check
    that the input text is not blank before we append it to the HTML. After the line
    that gets the input value, add a new line with the conditional statement checking
    that the variable is not a blank string. This condition wraps the `append` statement.
    Also add an `else` statement for when the input is a blank string. Inside it,
    copy the `.append()` method with text reminding the user to enter a value in the
    text input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This adds some validation to your form that will nag your user to enter your
    name if the **submit** button is clicked with a blank text box. There are two
    more clean-up items left, so hang on for a few more minutes.
  prefs: []
  type: TYPE_NORMAL
- en: First, we want the appended HTML to reset each time. So add a line right after
    your `if` conditional statement and before the `else` statement, removing the
    `.newText` element added earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, right before the end of the `if` conditional, reset the input form
    to have a blank value by using the `.val()` method. Also add an `ID` attribute
    to the text input to connect the value to the input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We have kind of over killed it, but we have a pretty good Hello World
    web app.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unobtrusive JavaScript works by loading up the script on page load and operates
    by using listeners to wait for specific events to occur on the page. This may
    be an adjustment in how you write, but then there is an advantage in being able
    to separate the interaction from the presentation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a glowing "submit" button with the event listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with forms is often an overlooked aspect of most web design topics,
    even more so, responsive web design. Often non-transactional pages do not use
    forms beyond the simple **Contact Us** page, therefore the form design is often
    an afterthought. However, in the realm of transactional e-commerce and Software
    as a Service industries, forms are the most important elements the user interacts
    with. In this world, responsive design is more than just responsive layouts and
    images, it includes thoughtful interaction. In this recipe we can imagine a scenario
    where a user is at the end of a form process and is ready to submit the form.
  prefs: []
  type: TYPE_NORMAL
- en: It's not an uncommon occurrence to see a person rather comically click the **submit**
    button and watch the page just sit there, seemingly doing nothing (but it is actually
    performing the `post` action of the form) and react by clicking the same button
    again and again and again. In the simple **Contact Us** scenario, this could generate
    some additional form submission e-mails, but in the transactional situation, this
    could activate a long string of business logic and become disruptive to other
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: On the user side, there can be the idea that if nothing happens immediately
    after clicking the **submit** button, something has gone wrong and the site has
    failed; and the end result is the abandoned transaction and the damaged trust
    of your site. There are a number of things you can and should do about this. One
    of them is adding visual cues to let the user know that they have successfully
    clicked the button, and something is going to happen. Consider the transaction
    being performed behind the scenes and the time it will take. If you anticipate
    a long wait, be aware that your user might not know this. People usually expect
    that in the Internet world of instant gratification everything is instant, and
    anything that isn't instant is broken.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Writing "Hello World" unobtrusively* recipe, we wrote a simple submit
    button function. We can use this as the basic building block for this recipe.
    If you do not have that code handy, you can get the finished version of it online
    at Packt Publishing's website ([http://www.packtpub.com/](http://www.packtpub.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we need to break out the meat of the submit function into a separate
    function that is called by the `.click()` event function. Cut out everything from
    inside the function and paste it outside the `$(document).ready(function() {...});`
    function. Replace everything that you have cut out with a function call to the
    new function. In the function call, include the declared variable `foo` with the
    `ID` value of `$(this)` by the `.attr()` method. Then, wrap the code you pasted
    in a new function of the same name, and assign it to receive the two variables.
    Finally add an `ID` attribute to your submit input. Your code should look similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First things first, remove the `bar` variable from the `formAction()` function
    and paste it inside the `.click()` event listener function. This builds the variable
    on every click event. Now onto building new functions; add a new function to the
    JavaScript called `buttonAnimate()` and call it after the `formAction()` call
    in the `.click()` event listener. In the `buttonAnimate()` function call, send
    the `bar` variable. Finally, add the `bar` variable to the `formAction()` function
    call and the function declaration variables. The key development is that we have
    added the input value as a variable in the `.click()` event listener function
    and sent it to the two function calls.
  prefs: []
  type: TYPE_NORMAL
- en: With that out of the way, we can now start writing in our new function of animating
    effects on the button. Take a small break and get some coffee. We are going to
    temporarily shift gears and write some CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Add a stylesheet to your project; inside the stylesheet, add two classes, `.valid`
    and `.invalid`, which will act on the button for its two different response states,
    `valid` and `invalid`. The `pass` scenario occurs when the text is entered into
    the form when submitted and the `fail` scenario occurs when the **submit** button
    is pressed without the text being entered in the `form` element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the `valid` state, we have submitted the form with text in the input box.
    We want to add CSS to the button that represents a positive state; the button
    has been activated, indicating that something correct has happened. I have added
    a border, shadow, text-shadow, background color, text color, and border-radius.
    This will be a sufficient indicator that something expected has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We add the same CSS style types to the `invalid` state, where the user has submitted
    the form with no text in the input box. In this instance, we want to give visual
    clues that something has gone wrong, and prompt the user for their attention to
    try again. In this scenario, orange and red are good colors to signal that an
    error has been made. In addition, we also add a CSS blur effect with a transition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That is all the CSS we are going to write for this recipe. Next, we are going
    to write the JavaScript to connect the two different styles to the actual states.
    Way back earlier in this recipe, we created an empty function called `buttonAnimate()`
    that received the variable `bar`, now it's time to build that out. Inside it,
    add the same `if` conditional statement to check if `bar` is an empty string.
    If it is, add the `valid` class to the `submit` button, and if it is not, add
    the class `invalid`. This added `invalid` class alerts the user that something
    has gone awry, and an action needs to be taken.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When the appropriate action is taken, that is, when the user clicks on the
    form element to enter text, the button should be reset to its original state;
    technically, the new added class should be removed. That code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The final bit of cleanup left is to remove either or both classes from the beginning
    of the `if` and `else` conditions. Use the .`removeClass()` method on the `submit`
    element twice to remove the class opposite to the class to be added.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now reload and test out the page and see the magic you created. It will look
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5442OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jQuery is a great library that does the heavy lifting for you to create great
    web apps quickly and with very little code. In the old world of plain old JavaScript,
    this functionality would have cost you much more code and time. It has the library
    functions to read the form's values, append HTML easily, and toggle the CSS classes
    on and off. All you need is to implement some jQuery methods and CSS, and the
    rest is done for you.
  prefs: []
  type: TYPE_NORMAL
- en: Making a button stand out when you hover over it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the big challenge in responsive design is being able to really over
    deliver a project when the requirements are only to build something that is just
    good enough. A button is an opportunity where you can deliver that extra level
    of polish for a product that astonishes the users. If we were not over delivering,
    we could just throw a `:hover` selector at this and be done. However, in this
    recipe, we're going to make a button that shines like a boss when you hover over
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Know the pitfalls of over delivering. Giving more than asked is something we
    should all strive for, but beware of setting unreasonable expectations that you
    cannot meet, and drive an otherwise successful project into failure.
  prefs: []
  type: TYPE_NORMAL
- en: In a previous recipe, we created a form with a button that animated when you
    clicked on it. For this recipe, you can continue working with that code. You can
    also go and download the code for that recipe, or this recipe for that matter.
  prefs: []
  type: TYPE_NORMAL
- en: Or you could just make a form and button element. It's not that hard.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are essentially starting with a page with two form elements; an input box
    and a submit button. As I mentioned earlier, these were built in a previous recipe;
    you could also just build them here. The JavaScript we built in the recipe will
    work with the new interaction, but is not required. The `input` element has the
    `id` attribute `fooBar`, and the button has the `id` attribute `submit`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by making the default look of the button more interesting. Add
    to your CSS a style for the `input#submit` element. Inside the style, add a blue
    background color, a white font color, an 8-point border radius, a 14-pixel font
    size, and padding of 5 pixels and 8 pixels. This can be done using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that the button's default look is defined, let's talk about the interactive
    design. Here, we get into the actual advantage of using JavaScript for a `.mouseover()`
    event instead of a CSS `:hover` selector. I would like to interact with the `form`
    element and query if text has been entered in it or not. If text is entered, we
    want a special visual cue indicating that the form is ready to be submitted; if
    no text is submitted, a strong visual cue should tell the user to stop and go
    back to check their form again.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if the form is ready to be submitted, the button will appear to extend
    out towards the mouse pointer and turn green. The CSS will include a green background
    color with the `!important` override, a box shadow, and a text-shadow. See the
    following code snippet for the exact CSS syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Alternately, if the form input is empty, the button will turn red and retract
    away from the mouse pointer. This CSS will have a red background color with the
    `!important` override, and inset shadow, and a text shadow that makes the text
    blurred.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the extent of the CSS we are creating. It''s time to build the interactivity.
    In your header, if you have not already done so, create the opening and closing
    `<script>` tags. First, we create the `(document).ready` listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That does not do much, but it is a start. So let us move forward to building
    the interactivity. Inside the `(document).ready` listener function, add an event
    listener for the `.mouseover()` event and one for the `.mouseout()` event. The
    `.mouseover()` listener replaces the hover in function, and will both animate
    the button and add one of the CSS classes we built earlier, while the `.mouseout()`
    listener completes the hover out function, and will ultimately remove the `class`
    attribute of the `.mouseover()` function that was added.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving forward, let us build the `.mouseover()` event listener function first.
    At its core, it performs two functions; first, it queries the value of the form
    `input` element, and then changes the `submit` button based on the value of the
    form `input` element. The first part, querying the value of the input, will look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first condition, when the value of the form is not an empty string, should
    create new variables, `classtoAdd = "buttonLight"` and `paddingAdd = "5px 8px
    5px 9px"`. The other condition, when the value of the form is an empty string,
    creates the same variables, `classtoAdd = "redButtonLight"` and `paddingAdd =
    "5px 9px 5px 7px"`. These will be applied to the `submit` button in the next part
    of this function.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the function starts by animating the opacity and padding of
    the button with the `.animate()` method, and adding the class determined by the
    `classtoAdd` variable. The animation should be somewhat quick, say 100 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That is all that is required for the `.mouseover()` event. What is needed next
    is the `.mouseout()` function's inner workings. Again, animate the `submit` button's
    `position` and `padding` attributes, but for a longer time, and then remove the
    `class` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And that is it. Launch the page and watch the interaction of the button. The
    following screenshot is illustrating the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5442OT_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses event listeners to replace the simple CSS `:hover` selector
    that can only deploy with limited logic with a `.mouseover()` event listener that
    can make a query against the form `input` element to see if the form data is not
    empty. Based on the page's form state, the script can assign a different CSS class
    to the button. This adds another level of logic to the client side of the application
    and a richer interactivity to your application.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing an element with unobtrusive jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of this recipe is to build a smart image element handler in your
    project. This will be a simple element that can respond to your screen size. We
    can do all this with an unobtrusive jQuery script.
  prefs: []
  type: TYPE_NORMAL
- en: In a previous recipe, we resized an image with server-side scripting using PHP.
    This recipe is going to achieve a similar result, but it will be client side instead
    of server side, and it will be for a mobile-first responsive design.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is a good tool for mobile-first responsive design. For instance,
    if you want a scaled down image to display the loading of the document first,
    and if the screen is large, the script will replace the image with a larger version
    of the image. The unobtrusive aspect of this means that the script can easily
    be called by adding a `class` attribute to the image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe starts from scratch, so you won''t be required to go download anything
    to get started. You do, however, need to plug in to the jQuery libraries to make
    this work. In your header, include the path to the jQuery libraries online:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <img src="img/robot-small.png" class="scalable" />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: div.wrap{width:75%;}
  prefs: []
  type: TYPE_NORMAL
- en: div.wrap div:first-child{float:left;width:50%;background-color:#ccc;}
  prefs: []
  type: TYPE_NORMAL
- en: div.wrap div:nth-child(2){float:right;width:50%;background-color:#666;}
  prefs: []
  type: TYPE_NORMAL
- en: div.wrap div img{width:100%;height:auto;}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: function replaceImage(size){...}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: if (size == 'small') {…} else {…};
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: if($("img.scalable").attr("src").indexOf('large')>1){…}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: var newImageReplace = $("img.scalable").attr("src").replace("-large.", "-small.");
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: $("img.scalable").attr({src:newImageReplace});
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: if($("img.scalable").attr("src").indexOf('small')>1){
  prefs: []
  type: TYPE_NORMAL
- en: var newImageReplace =    $("img.scalable").attr("src").replace("-small.", "-large.");
  prefs: []
  type: TYPE_NORMAL
- en: $("img.scalable").attr({src:newImageReplace});
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: function measureWindow(){
  prefs: []
  type: TYPE_NORMAL
- en: var getWindowWidth = $(window).width();
  prefs: []
  type: TYPE_NORMAL
- en: if (getWindowWidth < 600){
  prefs: []
  type: TYPE_NORMAL
- en: replaceImage("small");
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: replaceImage("large");
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: $(document).ready(function(){
  prefs: []
  type: TYPE_NORMAL
- en: measureWindow();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: $(window).resize(function(){
  prefs: []
  type: TYPE_NORMAL
- en: measureWindow();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Masking a password with unobtrusive JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common way to handle masking a password is to use the password type
    when creating an input element. This is the best practice when used on a desktop.
    When entering a password on a mobile device however, there is a high potential
    for input error on the device's touch input. These input errors are often not
    caught because you cannot see the encrypted text. This is a problem that the designers
    of iOS really got right. They created an input where the input text is visible
    for a short time before turning into a `*`, or changes upon entry of the next
    character.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a password input that mimics this solution for
    your password input.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this form element to mask other form entries as well. But be sure
    you understand that the underlying hidden form contains the entry to be transmitted.
    It is not encrypted unless you specify so. This only prevents the password from
    being seen visually.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don't need to get any files locally to get started. Only, in your header,
    include the link to the jQuery libraries. This will allow you to plug in to the
    jQuery libraries and use them to extend the functionality of your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first task is to create in your HTML body, two `input` elements. The first
    has the attributes of `type` and `ID` of the password. This will be the encrypted
    version submitted in the form, but will ultimately be hidden from view. The second
    will have the ID `altDisplay` and be disabled, so the user cannot click inside
    it. This one will be displayed on top of the other one and it will appear to be
    the one the user is typing into. At the end, we will add a style to hide the password
    field.
  prefs: []
  type: TYPE_NORMAL
- en: That is all that is needed for the HTML body of the recipe, of course you can
    add other form elements as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the header, add a JavaScript `<script>` element, and inside add the jQuery
    `$(document).ready` function. Inside it, add a listener to the `#password` input
    for the `.keyup()` event. This occurs after the key is pressed down, and when
    the key is let up, the event fires.
  prefs: []
  type: TYPE_NORMAL
- en: But there is a small bump in the road to manage before we get into the meat
    of this recipe. First, not all keys pressed enter a letter; there are *Shift*,
    *Tab*, and function keys, and then there is the *Delete* key. Each key has a numerical
    identifier, and you can find it by logging in the console `e.which`. You will
    need the numerical key identifiers to write a condition to filter out non-character
    keyup events.
  prefs: []
  type: TYPE_NORMAL
- en: First we should make a series of `if` conditions to make sure that we are not
    getting a keystroke that is not an actual character. Inside that, create an additional
    `if` statement to check that the *Delete* (8) key was not entered. If not, we
    can proceed with the function to handle a regular character `keyup` event, otherwise
    we will need to add functionality to handle the `delete keyup` event (that will
    come later).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the condition of a character `keyup`, we will get the current values of both
    input fields into variables `altDisplayVal` and `passwordVal`. The value present
    in the `#altDisplay` input is taken and it's values are all changed to `*` in
    a regular expression and stored in the `regAltDisplayVal` variable. The value
    in the `#password` is taken and the last letter is taken out and put into a new
    variable with the `.charAt()` method. These two new variables are added together
    to become the new value of the `#altDisplay` input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: That handled `keyup` on a character key, next let's write functionality for
    the delete key. The delete key is different in that it removes the last character
    in the character string. To handle the delete keyup event, get the last character
    in the `#password` input with the `.charAt()` method and hold it in the `delLast`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Then use the `.slice()` method to first get through the next-to-last characters
    for the `delTxt` variable. Use a regular expression to change the characters into
    `*` and store them in the `regDelTxt` variable. Finally, add the `regDelTxt` and
    `delLast` variables to make the new value of the `#altDisplay` input element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And that takes care of the JavaScript. You can now launch the page and see
    both the input elements on the page. Enter the text in the first input element,
    and then it will enter into the second as `*`. Now the only problem is that having
    two side-by-side form elements in the page does not make this an iOS style password
    element. To make it really work, we need to overlay the `#password` input over
    `#altDisplay` and make it invisible. You can do this with some CSS, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There, try that. On refreshing your screen, you will see only one input element.
    When you enter text into it, it transforms into stars.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This does not actually change the input submitted; it only hides it, and translates
    the values in the hidden field into star characters. It should be a good mimic
    of the iOS password entry.
  prefs: []
  type: TYPE_NORMAL
- en: Using an event listener to animate an image shadow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this is the last recipe, it should be a fun recipe. This one takes a responsive
    image, like the one we built back in [Chapter 1](ch01.html "Chapter 1. Responsive
    Elements and Media"), *Responsive Elements and Media*, and uses jQuery event listeners
    and CSS3 to animate a shadow to follow your cursor.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple recipe, but it still works in a responsive way. The image will
    respond to the page width, while the jQuery is written such that it still measures
    the image position and mouse position on every mouse movement.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe needs you to work with jQuery. So in the header of your new file,
    add a link to the jQuery libraries. Other than that, you are ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create the body of your HTML file using a div element with the class
    `wrap`. Inside it, add an image with the class `topRight`. Next up; the CSS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a section for the CSS. First, add a `text-align: center` style to the body.
    Next, give the `.wrap` div element a width of `30%`, and an automatic horizontal
    width. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The next set of CSS is varying the image class variations that will be assigned
    by the jQuery script depending on the mouse position. Each contains a differently
    angled `box-shadow`. Name the different classes `topLeft`, `topRight`, `bottomLeft`,
    and `bottomRight`. Each will have a shadow offset of `5` pixels, a spread of `2`
    pixels, and blur radius of `2` pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Excellent work so far. Now it is time to build the JavaScript. Inside your `script`
    tag, create the standard `$(document).ready` event function. Then, to start add
    a `.mousemove()` event listener function to the body. Inside it, create two new
    variables `imgHorz` and `imgVert` for the horizontal and vertical positions of
    the `.wrap img` div element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Next, after the variables have been created, we create some conditions based
    on the variable values compared to the position of the mouse at the time of the
    event. If the results are true, then remove all CSS classes before adding one
    of the image classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you will want to add three additional `else`/`if` conditions to add the
    other classes. The following code snippet shows the four conditions displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: And that wraps up the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing, we also need to animate the transition between CSS styles. So,
    instead of adding more JavaScript, add a CSS transition to the `.wrap img` element
    (each browser needs its own transition command).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'That was a fairly simple recipe, and the end result is a fun image element
    where the shadow follows the mouse around. The following screenshot is an illustration
    of this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5442OT_07_6_event_listener_animate_image_shadow.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe measures the location of the image and the mouse on every `.mousemove()`
    event. The result of each is that a new shadow is applied to the object. Now it
    is important to think about what events are appropriate for mobile devices versus
    desktops. A `.mousemove()` event won't work as there is no mouse attached to a
    mobile device. From here, I would refer to [Chapter 5](ch05.html "Chapter 5. Making
    Mobile-first Web Applications"), *Making Mobile-first Web Applications*, for a
    refresher on how to load JavaScripts such as jQuery Mobile for mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: We built simple UI interactions using unobtrusive JavaScript. I hope that these
    simple scripts are not only useful examples that you could actually use in a project,
    but they also demonstrate effectively how to write JavaScript that could live
    outside of your template files. This fits into your responsive design when you
    pair it with mobile versions of the script that can be called to the mobile devices.
    Going forward, this will help you create more responsive and fluidly transitioning
    web projects.
  prefs: []
  type: TYPE_NORMAL
- en: Live long and prosper, my friends.
  prefs: []
  type: TYPE_NORMAL
