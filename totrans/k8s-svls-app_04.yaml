- en: Introducing Kubeless Functioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our Kubernetes installation up-and-running, we can look at
    running our first serverless applications; we are going to start by installing
    and running Kubeless by working through some examples. We will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubeless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubeless overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our first functions using Kubeless—the hello world examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more advanced example—posting tweets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The serverless plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started by installing Kubeless on our three target operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubeless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two components to Kubeless; the first is the stack, which runs on
    Kubernetes, and the second part is the command-line client you use to interact
    with your Kubeless cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We will first look at getting the Kubernetes side of Kubeless up-and-running.
    Once up we will then look at installing the command client on our three target
    operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubeless Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be installing Kubeless on the single-node Minikube cluster we installed
    and configured in the previous chapter. The first thing we need to do is ensure
    that we are starting with a clean Kubernetes installation. To do this, we simply
    need to run the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Please remember that running the `minikube delete` command will immediately
    remove your currently running virtual machine without warning, meaning everything
    that is currently active on your Minikube single-node cluster will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our fresh single-node Kubernetes cluster up-and-running, we
    need to create a namespace for Kubeless by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And then install Kubeless itself by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the current version of Kubeless was v0.2.3\. You can
    check for the latest release at the projects, GitHub releases page, which is at
    [https://github.com/kubeless/kubeless/releases](https://github.com/kubeless/kubeless/releases).
    To install a later version simply use the newer releases version number in the
    following URL—however, please be warned that there may be differences in the output
    between versions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this will create and launch all of the components needed to
    run Kubeless on your single-node Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/512c4f3f-0ccb-4f15-bfa7-b0ab993f6409.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It will take a few minutes for everything to start up. You can check the status
    of each of the components launched by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show you something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e0de3e0-f560-4245-9dd8-d45588db224a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can also check the status using the Kubernetes dashboard.
    To do this, open the dashboard by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When the dashboard first opens, it is configured to display the default namespace,
    as the first command we executed created a new namespace called `kubeless`. We
    need to switch the `kubeless` namespace to see the Pods, Deployments, and Stateful
    Sets that have been deployed inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have changed namespaces you should see something on the following
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5ffd6926-4594-4952-b813-e93a474da322.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have deployed quite a complex set of services using just
    two commands. All of the heavy lifting and complexity has been completely abstracted
    away from us.
  prefs: []
  type: TYPE_NORMAL
- en: The command-line client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that Kubeless is installed on our single-node Kubernetes cluster we can
    look at getting the command-line client installed; this is how we will be interacting
    with our Kubeless cluster.
  prefs: []
  type: TYPE_NORMAL
- en: macOS 10.13 High Sierra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already have Homebrew installed from the previous chapter, we are going
    to use the `brew` command to install Kubeless. To do this, we need to add the
    Kubeless tap; a tap is a third-party repository that contains software installation
    instructions. Once the tap has been added, we can then install Kubeless in much
    the same way we did Minikube in [Chapter 2](494a207a-b5ff-4ee2-ae3c-c2abc8cbc108.xhtml),
    *An Introduction to Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the tap and then install the Kubeless command-line client, run the
    following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed you can check the version of the client that was installed by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Do not worry too much if this returns a different version of the client than
    the software you installed; this should not be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 Professional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unfortunately, there is no Chocolatey installer available for Kubeless, so
    we will have to download and uncompress the executable file manually. To do this
    in PowerShell, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can download the `kubeless_windows-amd64.zip` file from
    the Kubeless releases page. Once downloaded, extract the `.zip` file and put the
    `kubeless.exe` file where we can execute it. Run the following command from the
    folder that contains your `kubeless.exe` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will return the version of the command-line client.
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 17.04
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like the Windows 10 version of the command-line client for Kubeless, we have
    to download the release, uncompress it, and move the executable in place. To do
    this, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to check that the executable is working as expected, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are ready to use Kubeless on our Ubuntu Linux host.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubeless web interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move on we can also install the web interface for Kubeless. This,
    like Kubeless itself, can easily be installed by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use Minikube to open the service in your browser by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding command, as the `ui` service has been deployed
    in the `kubeless` namespace we need to let Minikube know that this is where the
    service is accessible by passing the `--namespace` flag. It may take up to several
    minutes for the Kubeless web interface to launch, but when it does you should
    be greeted by a page that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c568edd3-5b21-4002-8ad7-8b60e540fdc8.png)'
  prefs: []
  type: TYPE_IMG
- en: Kubeless overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to deploy serverless functions using Kubeless we should take
    a little time to work through what it is we have just installed, and also take
    a look at the commands available when using the Kubeless command-line client.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already mentioned, the installation process was extremely simple—while
    we were installing Kubeless on our single-node Kubernetes cluster the installation
    process would have remained pretty much the same if we were installing it on a
    Kubernetes made up of several nodes.
  prefs: []
  type: TYPE_NORMAL
- en: So what is Kubeless?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubeless is a framework that supports the deployment of serverless functions
    on your Kubernetes cluster, and it allows you to use both HTTP and event triggers
    to execute your Python, Node.js, or Ruby code. The framework is built using core
    Kubernetes functionality such as deployments, services, ConfigMaps, and so on.
    This keeps the Kubeless codebase small, and also means that developers do not
    have to reproduce large chunks of scheduling logic as it already exists within
    the Kubernetes core.
  prefs: []
  type: TYPE_NORMAL
- en: It works by taking advantage of Kubernetes controllers. Using controllers, the
    Kubeless developers have extended the Kubernetes API to add a function object
    within Kubernetes. The Kubeless controller runs within the Kubernetes cluster
    as a deployment, its primary job is to watch for the function endpoint being called.
    When the endpoint is called, runtimes containing the function code are executed;
    these are pre-built Docker images that wrap your functions, which are injected
    using ConfigMaps, in either an Apache Kafka consumer, which is used for events,
    or an HTTP server, which you can call like any other web page in your Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Kafka is a distributed streaming platform that lets you both publish
    and subscribe to a stream of information. In our case, this stream of information
    is an event being triggered to which the Kubeless controller is subscribed.
  prefs: []
  type: TYPE_NORMAL
- en: All of this means that we can get a similar experience of the serverless services
    we covered from AWS and Microsoft Azure in [Chapter 1](37d92482-56fd-4329-8b81-01acc97e9c0c.xhtml),
    *The Serverless Landscape*, on our Kubernetes cluster, including the single-node
    cluster we are running locally.
  prefs: []
  type: TYPE_NORMAL
- en: Who made Kubeless?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubeless was created by Bitnami ([https://bitnami.com/](https://bitnami.com/))
    and it is one of several projects they have written and open-sourced to support
    the easy deployment of applications into a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Bitnami has for many years been a leader in distributing pre-packaged open source
    and commercially supported licensed applications—there are over 140 at the time
    of writing—in a predictable and consistent way across many different platforms
    and public clouds, so the jump to supporting and developing for Kubernetes was
    a natural fit for them.
  prefs: []
  type: TYPE_NORMAL
- en: They are a core contributor, alongside Microsoft and Google, to Helm, which
    is a package manager for Kubernetes maintained by the Cloud Native Computing Foundation
    forum, who as we know from [Chapter 2](494a207a-b5ff-4ee2-ae3c-c2abc8cbc108.xhtml),
    *An Introduction to Kubernetes*, also maintain Kubernetes itself.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the Kubeless website at [http://kubeless.io/](http://kubeless.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Kubeless commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubeless command-line client has several commands. Before we look at launching
    our first serverless function on Kubernetes using Kubeless we should quickly discuss
    some of the commands we are going to be using.
  prefs: []
  type: TYPE_NORMAL
- en: The most common command we are going to be using is `kubeless function`. This
    allows us to `deploy`, `delete`, `edit`, and `list` functions. Also, we can execute
    our functions by using `call` and check the `logs`.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we have `kubeless ingress`; with this command we can `create`, `delete`,
    and `list` routes to our functions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will also be looking at `kubeless topic`; like `ingress`, it allows
    us to `create`, `delete`, and `list` topics as well as `publish` a message to
    a topic.
  prefs: []
  type: TYPE_NORMAL
- en: Hello world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start off with we are going to look at deploying two very simple hello world
    functions. The first simply prints `Hello World!` and the second takes an input
    and then displays it back to you.
  prefs: []
  type: TYPE_NORMAL
- en: The basic example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, we need our function. The static hello-world function requires
    the following three lines of Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Place the preceding code, which is also available in the `Chapter04/hello-world`
    folder of the GitHub repository that accompanies this book, in a file called `hello.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have our function we can deploy it into the default namespace by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a function called `hello`, using the file `hello.py`. Whenever
    the function called `hello.handler` is executed, we are using the `python2.7`
    runtime, and our function is set to be triggered by an `http` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that, when you ran the command, there was no feedback,
    so to check that the function was created you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several columns in the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NAME`: This is the name of the function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NAMESPACE`: The name of the namespace the function has been deployed into'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HANDLER`: The name of the handler to run—in our case the handler is simply
    handler, so it is calling `hello-world.handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUNTIME`: There is a separate runtime for each of the languages supported
    by Kubeless'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TYPE`: This is how the function is being called, in our case this is HTTP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TOPIC`: If we were subscribing to a message queue this would be the topic
    we would be watching for messages in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, as mentioned in the previous section, Kubeless adds functions objects
    to Kubernetes. You can run the following command to check our function is being
    listed in the functions object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Running through these commands should give you something like the following
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a065e896-8db8-4d0e-ac06-292efb0e4dc5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our function deployed, we can execute it. To do this run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fae35d98-a824-4619-a8bf-4312b2459612.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way we can call the function is using the Kubeless web interface. Open
    it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once open, you should see the function `hello` listed on the left-hand side.
    Clicking on `hello` will show you the code in the function, and there is a button
    labelled RUN FUNCTIONon the right-hand side; clicking this will execute the `hello`
    function and return `Hello World!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a103d7d4-d225-44d4-8d1e-bd34376d9930.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The final way we can interact with our function is to create an Ingress rule;
    however, before we do that we must enable the Ingress add-on in Minikube. To do
    that, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the Ingress add-on is enabled we need to create the Ingress route
    using Kubeless. To do this we simply need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to know the host that Kubeless created so that we can access our service.
    To do this, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will give information on the Ingress route we created, including the host
    we will be able to use to access the service. For me, this was `http://hello.192.168.99.100.nip.io/`.
  prefs: []
  type: TYPE_NORMAL
- en: '`nip.io` is a simple and free DNS service that allows you to create a DNS record
    to map your host to an IP address. Kubeless uses this service to create a valid
    host to route to your service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening this URL in my browser returned `Hello World!`, as did running it through
    HTTPie, which we covered in [Chapter 1](37d92482-56fd-4329-8b81-01acc97e9c0c.xhtml),
    *The Serverless Landscape,* as you can see from the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0a40f91c-d6bb-4622-96ab-8228c1f9c878.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our first function up-and-running, let's look at creating one
    that can be passed and print data.
  prefs: []
  type: TYPE_NORMAL
- en: An example of reading data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for our new function is still quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'All this code does is take the JSON we post and display it back to us. Place
    it in a file called `hello-name.py` or use the one in the `Chapter04/hello-world/`
    folder in the GitHub repository. Once you have the file you can create the function
    by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have deployed the function, you check it has been created by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see two functions listed, `hello` and `hello-name`. Now that we
    have created our new function you can call it by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this time we are using the `--data` flag to pass data to the function.
    Running all of the commands, you should see something like the following terminal
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a6639d16-6ca1-4734-8002-583e1e08b50d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When calling the function using the web interface, we also need to pass data.
    To do this, open the interface again by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once open, click on the `hello-name` function. Before clicking the RUN FUNCTION
    button change GET to POST using the drop-down menu, and in the Request form enter
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, press the RUN FUNCTION button. This will return the same result as the
    `kubeless function call` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/74229f95-2b2a-4338-ac02-95f7175eb8a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also interact with the service directly by configuring an Ingress route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you URLs for both of our functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/04cb951e-861b-40c9-a279-b68696db2150.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unlike our first example, going to the URL for `hello-name`, which for me was
    `http://hello-name.192.168.99.100.nip.io/`, will give Error: 500 Internal Server
    Error (or on later versions of Kubeless, a 504 Gateway timeout):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/041b574c-34fc-4f43-91af-fba1f8cc17e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Why is that, given that it worked without error when we called it using the
    `kubeless function call` command and also using the Kubeless web interface?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, by simply entering the URL into a browser we have not posted any data
    for the function to return; this is why the error is being generated. We can confirm
    this by checking the logs. To do this, refresh the page in your browser a few
    times and then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/28667ea3-e6f4-40fa-9d03-ace20d7eb60d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first line of the preceding log output is the internal health check, which
    was successful, as a `200` status was generated, which you can see after the `GET`.
    The next several lines contain the error we are after; as you can see, we get
    a `Traceback` and then the following: `TypeError: handler() takes exactly 1 argument
    (0 given)`. This means that the function was expecting data to be passed and none
    was. The next line is the request from our browser; as you can see after the `GET`,
    there is a status of `500`.'
  prefs: []
  type: TYPE_NORMAL
- en: So how can we interact with our function that requires us to POST data rather
    than GET? There are a few ways you can achieve this on the macOS and Linux command
    line, but you will have to run something else on Windows. Rather than working
    through different examples I am going to install a piece of software called Postman.
    This desktop software works on all three of the operating systems we are covering
    in the book and it will provide a great graphical interface for us to interact
    with both the `hello-name` function and any other functions we launch.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Postman on macOS 10.13 High Sierra using Homebrew, simply run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a Chocolatey package for Postman, so if you are using Windows 10 Professional,
    you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To install Postman on Ubuntu 17.04 we need to run a few more additional steps.
    First of all, we need to download, uncompress, and move the file into place, making
    sure to clean up and move the files we need. To do this, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the files in the correct place, we can create a desktop launcher
    for them by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Once you have created the launcher you should see a Postman icon appear in the
    list of installed software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have installed Postman, open it and you will be greeted by a screen
    asking you to sign-up. It is up to you if you wish to sign-up or not; the service
    is free and you will find it of great use if you ever need to test posting data
    to APIs. Once you have passed the Sign up or Sign in option you will be presented
    with a screen that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a7b780ee-1998-41a4-b4b1-a82103f989b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Request option under BUILDING BLOCKS; this will take you to a save
    dialog. Here, enter the Request name of `hello-name` and then click on +Create
    Collection. Here, create a collection called `Kubeless` and then click on the
    Save to Kubeless button.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, change GET to POST using the drop-down menu, then in the space
    that is labelled Enter request URL enter `http://hello-name.192.168.99.100.nip.io`
    (or your URL if different). Now that we have defined that we are going to be posting
    our data, to we need to actually give Postman the data that needs to be passed
    to our function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enter the data click on Body, and then select the raw option. When you select
    raw the input field will change, and you should see the word Text with a drop-down
    icon next to it. Click on this and check the option for JSON (application/json).
    Once changed, enter the following in the main field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that Postman is configured to POST JSON data to our function you can click
    on Send. This will post the data we defined and then display the results in the
    bottom part of the screen, along with the HTTP status and the time the request
    took to be executed, just like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/68e8d681-0794-4ad0-851a-e9aadfcd7179.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the Save button will store the settings, should you want to re-run
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the next section we should tidy up our functions. To do
    this, we simply need to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will remove our two hello world functions and Ingress routes. You can
    also double-check that everything has been removed in the Kubeless web interface
    and Kubernetes dashboard; again, you can open these by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you spot anything left over for either `hello` or `hello-name` you can remove
    the services, pods, and even Ingress routes from the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Twitter example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubeless GitHub account has a few more example applications that do something
    more than printing static content or reposting data you sent. In this example,
    we are going to look at creating a function that posts to a Twitter account.
  prefs: []
  type: TYPE_NORMAL
- en: The Twitter API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we look at launching the function we need to generate keys for our function
    to be able to authenticate against Twitter and then post to your account. To do
    this, you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Twitter account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mobile number registered with the account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have them then going to the Twitter application page at [https://apps.twitter.com/](https://apps.twitter.com/)
    will present you with a form to fill in (Application Details)—I used the following
    information. However, a few of the fields need to be unique to you; these are
    marked with *:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name*: `MedialGlassesKubeless`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Description: `Testing posting to Twitter using Kubeless`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Website*: `https://media-glass.es/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Callback URL: Leave blank'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Developer Agreement: Agree to the agreement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have filled in the preceding information, click on the Create your
    Twitter application button. Once the application has been created you will be
    taken to a page that allows you to manage your application. One of the tabs on
    the page is Keys and Access Tokens; clicking on this will reveal your Consumer
    Key (API Key) and Consumer Secret (API Secret)—make a note of these.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the page, you will have a button that allows you to create
    an Access Token and Access Token Secret for your account; clicking on the button
    will generate the tokens—again, make a note of these.
  prefs: []
  type: TYPE_NORMAL
- en: While the following examples will contain the keys I have generated, they have
    been revoked, and you should use your own. Also, as they allow both read and write
    access to your Twitter account, storing them in a publicly accessible place such
    as GitHub, Gists, or other version control software may result in third-parties
    having full access to your Twitter account without your permission.
  prefs: []
  type: TYPE_NORMAL
- en: Adding secrets to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our Twitter application configured and all of the tokens we
    need to be able to post a tweet, we need to add them to Kubernetes. Kubernetes
    allows you to define secrets; these are variables such as API keys and tokens
    that your applications need to use to function. However, you might not want to
    put them under source control or embed them in your application because various
    deployments of the same code interact with the APIs using different keys—for example,
    the development version of the code uses a different set of API credentials from
    the production version.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the tokens you made a note of in the previous section you just need
    to run the following command, replacing the placeholders, which are in uppercase,
    with your tokens and keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For me, the command looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2ac31d01-3e2b-44d6-a10e-408be3e438ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This has created a secret called `twitter` that contains the four different
    keys and tokens we passed to the command. You can list the secrets by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list all of the secrets within your Kubernetes cluster, as you can
    see from the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/03d530ba-27c4-4586-9c23-169891138d84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are the default Kubernetes service account tokens, which contain three
    items, and our `twitter` secret containing the four keys and tokens. You can also
    view secrets in the Kubernetes dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/46a1520c-fa01-4080-a3ec-a937485a8ce8.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, you also have the option of revealing
    the secret by clicking on the eye icon.
  prefs: []
  type: TYPE_NORMAL
- en: The Twitter function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our environment prepared we can deploy the function. To do
    this we need two files; the first is the `requirements.txt` file, this contains
    just two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `requirements.txt` file lets Python know which external libraries to deploy
    alongside our code. In our file we are using the `twitter` library so that we
    can post the tweet easily, and also the `kubernetes` library to decode the secrets
    we created in the previous section. Using the libraries means that our code is
    quite streamlined, as all of the hard work takes place outside our core function.
    The code for the function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Place this in a file called `tweet.py`. As before, both the `requirements.txt`
    and `tweet.py` files can be found in the GitHub repository at `Chapter04/twitter/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to deploy the function has one addition to the deployment command.
    As we are now loading external libraries, we need to let Kubeless know that we
    want to use a `requirements.txt` file by adding the `--dependencies` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, the dependencies are now
    listed when running the `kubeless function list` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4c4fc377-f38c-451e-acc6-46969dfaecdd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that our function has been deployed, we can start tweeting. To send our
    first tweet you simply need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You will not receive any feedback, but if you go to your Twitter account you
    should see the tweet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/66f521f6-717a-432b-8c15-7906e6aeafba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also use Postman to send a tweet. First of all, create an Ingress route
    by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the route and give us the host we need to use to access the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f9daa0b6-64d2-49e3-9500-58b2440ec5ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can open Postman, and as before configure it in pretty much the same
    way, but this file uses the following as the post content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking on Send will post the tweet and, like when calling the function using
    the `kubeless function call` command, will not give us any feedback:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2be50eb1-e057-423c-a3e1-d817773ba022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Checking Twitter should show you a second tweet, this time mentioning `@postmanclient`.
    You can view both of my test tweets at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Command line tweet: [https://twitter.com/mediaglasses/status/922036070954536960](https://twitter.com/mediaglasses/status/922036070954536960)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Postman tweet: [https://twitter.com/mediaglasses/status/922038490883346432](https://twitter.com/mediaglasses/status/922038490883346432)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, before moving on to the next section we should remove our function and
    tidy up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Also, if you need to you should return to [https://apps.twitter.com/](https://apps.twitter.com/)
    and either remove or revoke your application or tokens.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubeless serverless plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 1](37d92482-56fd-4329-8b81-01acc97e9c0c.xhtml), *The Serverless
    Landscape*, we installed the Serverless framework to deploy an AWS Lambda function;
    serverless also works with Kubeless.
  prefs: []
  type: TYPE_NORMAL
- en: If you didn't install serverless yet, here is a quick recap on how to install
    it on the three operating systems we are covering.
  prefs: []
  type: TYPE_NORMAL
- en: While every effort has been made to ensure that the following instructions work
    on all supported platforms there has been varying degrees of success of running
    the Kubeless serverless plugin on *Windows-based* operating systems due to compatibility
    issues with some of the dependencies required by the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS 10.13 High Sierra, run the following command to install Node.js using
    Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are following along using Windows 10 Professional then you can install
    Node.js using Chocolatey by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you are using Ubuntu 17.04, you can install Node.js using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the latest version of Node.js is installed we can use **Node Package
    Manager** (**NPM**) to install serverless by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once serverless is installed you can log in using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that serverless is installed we can launch the demo Kubeless function by
    running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not following along, running these commands gives the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae272daf-8510-4fb1-acbc-c650f0d9ed05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This has installed the Kubeless serverless plugin and created the `serverless.yml`
    file that defines our function. This contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code tells serverless that we are using Kubeless and that
    it should use the Kubeless plugin. It also defines a function and handler called
    `hello`. The function can be found in the `handler.py` file. This contains the
    following code and is pretty similar to the hello-world examples we looked at
    earlier in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our example function, we can deploy the service by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the service has been deployed, the final step is to deploy the function
    itself. To do this, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Using serverless itself to invoke the function might result in an error like
    the following one—if it does, do not worry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/46e38a11-2f63-4841-9dcb-0ec381c9ca39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can still access the function using Kubeless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a30409ea-a28b-4d16-9225-c73774c79b6f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To remove the example function, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Before we finish this chapter, let's look at an example that uses events rather
    than HTTP. In the `Chapter04/serverless-event/` folder in the GitHub repository,
    there is a sample application that listens for events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `serverless.yml` file differs from the previous HTTP example in that as
    well as a handler it adds an events section that contains the trigger/topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handler.py` file contains probably the most simplistic code we have looked
    at so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To launch the example, simply run the following commands from within the `Chapter04/serverless-event/`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/0aca75c4-1e13-4c4c-8507-4b3900c3aacc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the preceding Terminal output, we have a type of `PubSub`
    and a topic of `hello_topic`. We can now publish an event in the `hello_topic`
    topic by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can check the logs to see the that the two events have been processed
    by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following output, the events have successfully been
    published and processed by our test function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c0fe43a8-e234-4028-8272-5cedd178a7d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before moving on to the next chapter, we can remove our Kubeless Kubernetes
    single-node cluster by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have deployed Kubeless onto our single-node Kubernetes, which
    we launched with Minikube. We installed the Kubernetes command-line client and
    web-based interface. Once the cluster was deployed and tools installed, we deployed
    and executed functions on our Kubeless installation.
  prefs: []
  type: TYPE_NORMAL
- en: We worked through installing two basic test functions before installing a more
    useful function that posts tweets. We then looked at how we can interact with
    Kubeless using the Serverless framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to be looking at an event-based framework
    called **Funktion**.
  prefs: []
  type: TYPE_NORMAL
