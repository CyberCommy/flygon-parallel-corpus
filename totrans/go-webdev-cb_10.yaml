- en: Securing a Go Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a private key and SSL certificate using OpenSSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving an HTTP server to HTTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining REST APIs and routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a JSON web token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing a RESTful service using a JSON web token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing cross-site request forgery in Go web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing web applications is one of the most important aspects, besides creating
    applications, that we will be learning about in this chapter. Application security
    is a very wide topic and can be implemented in various ways that are beyond the
    scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will just focus on how we can move our Go web application
    from the HTTP protocol to HTTPS, which is often called **HTTP + TLS** **(Transport
    Layer Security)**, along with securing Go web application REST endpoints using
    **JSON web tokens** **(JWTs)**, and protecting our application from **cross-site
    request forgery (CSRF)** attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a private key and SSL certificate using OpenSSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To move a server running on HTTP to HTTPS, the first thing we have to do is
    to get the SSL certificate, which may be either self-signed or a certificate signed
    by a trusted certificate authority such as Comodo, Symantec, or GoDaddy.
  prefs: []
  type: TYPE_NORMAL
- en: To get the SSL certificate signed by a trusted certificate authority, we have
    to provide them with a **Certificate Signing Request** (**CSR**), which mainly
    consists of the public key of a key pair and some additional information, whereas
    a self-signed certificate is a certificate that you can issue to yourself, signed
    with its own private key.
  prefs: []
  type: TYPE_NORMAL
- en: Self-signed certificates can be used to encrypt data as well as CA-signed certificates,
    but the users will be displayed with a warning that says that the certificate
    is not trusted by their computer or browser. Therefore, you should not use them
    for the production or public servers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a private key, a certificate-signing
    request, and a self-signed certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe assumes you have `openssl` installed on your machine. To verify
    that it is installed, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generate a private key and certificate signing request using `openssl` by executing
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4195e84-d3b8-4163-b65e-2562c8c6e5e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Generate a certificate and sign it with the private key we just created by
    executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the command has executed successfully, we can see `domain.key`, `domain.csr`,
    and `domain.crt` generated, where `domain.key` is a 2,048-bit RSA private key
    that is used to sign the SSL certificate, and `domain.crt` and `domain.csr` are
    certificate-signing requests that consist of the public key of a key pair with
    some additional information, which is inserted into the certificate when it is
    signed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the command we executed to generate a certificate-signing
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-newkey rsa:2048` option creates a new certificate request and a new private
    key that should be 2,048-bit, generated using the RSA algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-nodes` option specifies that the private key created will not be encrypted
    with a passphrase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-keyout domain.key` option specifies the filename to write the newly created
    private key to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-out domain.csr` option specifies the output filename to write to, or the
    standard output by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-subj` option replaces a subject field of the input request with specified
    data and outputs a modified request. If we do not specify this option, then we
    have to answer the CSR information prompt by `OpenSSL` to complete the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will understand the command we executed to generate the certificate
    and sign it with the private key, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `-key` option specifies the file to read the private key from. The `-x509`
    option outputs a self-signed certificate instead of a certificate request. The
    `-days 365` option specifies the number of days to certify the certificate for.
    The default is 30 days.
  prefs: []
  type: TYPE_NORMAL
- en: Moving an HTTP server to HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the web application development is over, it's likely that we will deploy
    it to the servers. While deploying, it is always recommended to run the web application
    on an HTTPS protocol rather than HTTP, especially for the servers that are publicly
    exposed. In this recipe, we will learn how we can do this in Go.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create `https-server.go`, where we will define a handler that will just write
    Hello World! to an HTTP response stream for all HTTPS requests, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTPS server will start locally listening on port
    `8443`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing `https://localhost:8443/` will give us Hello World! as a response
    from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b88936f9-4a85-446f-bcc1-41e96312da93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Moreover, executing a `GET` request from the command line passing the `--insecure`
    flag with `curl` will skip the certificate validation, as we are using a self-signed
    certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const (CONN_HOST = "localhost" CONN_PORT = "8443" HTTPS_CERTIFICATE = "domain.crt"
    DOMAIN_PRIVATE_KEY = "domain.key")`: Here, we declared four constants - `CONN_HOST`
    with the value as `localhost`, `CONN_PORT` with the value as `8443`, `HTTPS_CERTIFICATE`
    with the value as `domain.crt` or a self-signed certificate, and `DOMAIN_PRIVATE_KEY`
    with the value as `domain.key` or the private key that we created in the previous
    recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func helloWorld(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello
    World!") }`: This is a Go function that takes `ResponseWriter` and `Request` as
    input parameters and writes `Hello World!` on an HTTP response stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we declared `main()` from where the program execution begins. As this
    method does a lot of things, let''s understand it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http.HandleFunc("/", helloWorld)`: Here, we are registering the `helloWorld`
    function with the URL pattern `/` using `HandleFunc` of the `net/http` package,
    which means `helloWorld` gets executed, passing `(http.ResponseWriter, *http.Request)`
    as input to it whenever we access the HTTPS URL pattern `/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`err := http.ListenAndServeTLS(CONN_HOST+":"+CONN_PORT, HTTPS_CERTIFICATE,
    DOMAIN_PRIVATE_KEY, nil)`: Here, we are calling `http.ListenAndServeTLS` to serve
    HTTPS requests that handle each incoming connection in a separate Goroutine. `ListenAndServeTLS`
    accepts four parameters—server address, SSL certificate, private key, and a handler.
    Here, we are passing the server address as `localhost:8443`, our self-signed certificate,
    private key, and handler as `nil`, which means we are asking the server to use
    `DefaultServeMux` as a handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if err != nil { log.Fatal("error starting https server : ", err) return}`:
    Here, we check whether there are any problems in starting the server. If there
    are, then log the error(s) and exit with a status code of 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining REST APIs and routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing RESTful APIs, it's very common to authenticate the user before
    allowing them to access it. A prerequisite to authenticating the user is to create
    the API routes, which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/gorilla/mux` and `github.com/gorilla/handlers` packages
    using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `http-rest-api.go`, where we will define three routes—`/status`, `/get-token` and
    `/employees`—along with their handlers, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you could execute a `GET` request from the command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you the status of the REST API. You could execute a `GET` request
    from the command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you a list of all the employees. We could try to get the access
    token through the command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will get the Not Implemented message from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import ("encoding/json" "log" "net/http" "os" “github.com/gorilla/handlers"
    "github.com/gorilla/mux")`: Here, we imported `github.com/gorilla/mux` to create
    a Gorilla Mux router and `github.com/gorilla/handlers` to create a Gorilla logging
    handler for logging HTTP requests in the Apache Common Log Format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func getStatus(w http.ResponseWriter, r *http.Request) { w.Write([]byte("API
    is up and running"))}`: This is a handler that just writes API is up and running to
    an HTTP response stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func getEmployees(w http.ResponseWriter, r *http.Request) { json.NewEncoder(w).Encode(employees)}`:
    This is a handler that writes a static array of employees to an HTTP response
    stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func notImplemented(w http.ResponseWriter, r *http.Request) { w.Write([]byte(“Not Implemented"))
    }`: This is a handler that just writes Not Implemented to an HTTP response stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we defined `main()`, where we create a `gorilla/mux` router instance using
    the `NewRouter()` handler with the trailing slash behavior for new routes as `true`,
    add routes and register handlers to it, and finally call `http.ListenAndServe`
    to serve HTTP requests which handle each incoming connection in a separate Goroutine.
    `ListenAndServe` accepts two parameters—the server address and the handler. Here,
    we are passing the server address as `localhost:8080` and the handler as Gorilla
    `LoggingHandler`, which logs HTTP requests in the Apache Common Log Format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a JSON web token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To secure your REST API or a service endpoint, you have to write a handler in
    Go that generates a JSON web token, or `JWT`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be using `https://github.com/dgrijalva/jwt-go` to generate
    `JWT` , although you can implement any library from a number of third-party libraries
    available in Go, such as `https://github.com/square/go-jose` and `https://github.com/tarent/loginsrv`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/dgrijalva/jwt-go`, `github.com/gorilla/mux` and `github.com/gorilla/handlers`
    packages using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `create-jwt.go`, where we will define the `getToken` handler that generates `JWT`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we execute a `GET` request from the command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It will give you the status of the API. Next, we execute a `GET` request from
    the command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It will give you a list of all the employees. Next, let''s attempt to get the
    access token of the REST API through the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It will give us the JWT token generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, browse to `https://jwt.io/` and paste the token generated in the Encoded
    section to see it''s decoded value, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3d84091-ec25-4d4a-a277-8a034edb5fd8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the changes we introduced in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import ( "encoding/json" "log" "net/http" "os" "time" jwt "github.com/dgrijalva/jwt-go"
    "github.com/gorilla/handlers" "github.com/gorilla/mux")`: Here, we imported an
    additional package—`github.com/dgrijalva/jwt-go`—which has a Go implementation
    of the JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const ( CONN_HOST = "localhost" CONN_PORT = "8080" CLAIM_ISSUER = "Packt"
    CLAIM_EXPIRY_IN_HOURS = 24 )`: Here, we introduced two additional constants—one
    is `CLAIM_ISSUER`, which identifies the principal that issued the JWT, and the
    other one is `CLAIM_EXPIRY_IN_HOURS`, which identifies the expiration time on
    or after which the JWT must not be accepted for processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var signature = []byte("secret")`: This is the signature held by the server.
    Using this, the server will be able to verify existing tokens and sign new ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we defined a `getToken` handler, where we first prepared a claims object
    using the `JWT StandardClaims` handler, which then generates a JWT token using
    the `jwt NewWithClaims` handler, and, finally, signs it with the server signature
    and writes it to an HTTP response stream.
  prefs: []
  type: TYPE_NORMAL
- en: Securing a RESTful service using a JSON web token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have a REST API endpoint and a JWT token generator handler in hand,
    we can easily secure our endpoints with the JWT, which we will be covering in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/auth0/go-jwt-middleware`, `github.com/dgrijalva/jwt-go`,
    `github.com/gorilla/mux`, and `github.com/gorilla/handlers` packages using the `go
    get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `http-rest-api-secured.go`, where we will define the JWT middleware
    to check for JWTs on HTTP requests, and wrap the `/employees` route with it, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we execute a `GET` request from the command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It will give you the status of the API. Next we execute a `GET` request from
    the command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It will display us the message that the JWT was not found in the request. So,
    to get the list of all the employees, we have to get the access token of the API,
    which we can get by executing the following  command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, calling the employee API, again passing the JWT as the HTTP `Authorization` request
    header as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It will give you a list of all the employees, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the changes we introduced in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ( "encoding/json" "log" "net/http" "os" "time" jwtmiddleware "github.com/auth0/go-jwt-middleware"
    jwt "github.com/dgrijalva/jwt-go" "github.com/gorilla/handlers" "github.com/gorilla/mux")`,
    we imported an additional package, `github.com/auth0/go-jwt-middleware`, with
    the alias as `jwtmiddleware`, which checks for JWTs on HTTP requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we constructed a new secure instance of `jwtmiddleware`, passing `SigningMethod`
    as `HS256` and the `ValidationKeyGetter` option as a Go function that returns
    the key to validate the JWT. Here, a server signature is used as a key to validate
    the JWT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we wrapped the `/employees` route with a `jwtmiddleware` handler in `main()`,
    which means for each request with the URL pattern `/employees` , we check and
    validate the JWT before serving the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preventing cross-site request forgery in Go web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's a common practice to secure web applications from a malicious website,
    email, blog, instant message, or a program attacking a trusted site for which
    the user is currently authenticated to prevent unwanted action. We often call
    this cross-site request forgery.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing cross-site request forgery in Go is fairly easy using the Gorilla
    CSRF package, which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/gorilla/csrf` and `github.com/gorilla/mux` packages
    using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `sign-up.html` with name and email input text fields and an action that
    gets called whenever an HTML form is submitted, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `prevent-csrf.go`, where we create a `signUp` handler that renders a
    signup HTML form and a `post` handler that gets executed whenever an HTML form
    is submitted and the request has a valid CSRF token, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8443`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, execute a `POST` request from the command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It will give you the Forbidden - CSRF token invalid message as a response from
    the server and forbids you to submit an HTML form because the server does not
    find a valid CSRF token as part of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9154e672-74b9-424e-8e39-62b5d6d5a274.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, to submit a form, firstly we have to sign up, which generates a valid CSRF
    token by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you an HTTP `X-CSRF-Token` , as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a93d469-bc90-479c-90f4-948a2e81f13f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And now you have to pass it as an HTTP `X-CSRF-Token` request header along
    with an HTTP cookie to submit an HTML form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const (CONN_HOST = "localhost" CONN_PORT = "8443" HTTPS_CERTIFICATE = "domain.crt"
    DOMAIN_PRIVATE_KEY = "domain.key")`: Here, we declared four constants - `CONN_HOST`
    with the value as `localhost`, `CONN_PORT` with the value as `8443`, `HTTPS_CERTIFICATE`
    with the value as `domain.crt` or a self-signed certificate, and `DOMAIN_PRIVATE_KEY`
    with the value as `domain.key` or the private key that we created in the previous
    recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var AUTH_KEY = []byte("authentication-key")`: This is the authentication key
    which is used to generate the CSRF token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signUp`: This is a handler that parses `sign-up.html` and provides an `<input>`
    field populated with a CSRF token replacing `{{ .csrfField }}` in the form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post`: This is a handler that parses the submitted form, gets the value of
    the name input field, and writes it to an HTTP response stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we defined `main()`, where we create a `gorilla/mux` router instance
    using the `NewRouter()` handler with the trailing slash behavior for new routes
    as `true`, registered the `/signup` route with the `signUp` handler and the `/post`
    route with the `post` handler, and called the `http.ListenAndServeTLS` passing
    handler as `csrf.Protect(AUTH_KEY)(muxRouter)`, which makes sure all `POST` requests
    without a valid token will return `HTTP 403 Forbidden`.
  prefs: []
  type: TYPE_NORMAL
