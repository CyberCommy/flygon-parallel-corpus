- en: Project 5 - Online Shop and Scaling Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will quickly set up a "Fashion Store" app in order to focus
    on more advanced topics, such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Improving the compatibility of our CSS code with PostCSS and autoprefixer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linting our code with ESLint to improve its quality and style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing our Vue components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localizing the app and taking advantage of the code-splitting feature of webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling server-side rendering of the app in Nodejs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the app for production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The app will be a simple wearable online shop that will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/87d90bd9-c55e-4bfc-8d62-64d4d9722836.png)'
  prefs: []
  type: TYPE_IMG
- en: Advanced development workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first section, we will improve our development workflow with new tools
    and packages. However, first, we need to set up our Fashion Store project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generate a new project using the `vue init` command like we did in [Chapter
    5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml), *Project 3 - Support Center*,
    and [Chapter 6](40d407e7-1556-4265-8385-4afe5fc66430.xhtml), *Project 4 - Geolocated
    Blog*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also install stylus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Remove the content of the `src` folder. Then, download the sources files ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/src](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/src))
    and extract them in the `src` folder. Those contains all the app source code that
    have been already done so that we can move forward faster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to install a few more packages in the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: axios is a great library for making requests to the server and is recommended
    by the Vue.js team.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a quick development API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we had a full node server for the backend, but this time we will
    not focus on the app features. So, we will use the `json-server` package to generate
    a very simple local API for the purpose of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `json-server` as a dev dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we run this package, it will locally expose a simple REST API and use a
    `db.json` file to store the data. You can download it ([https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/db.json](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/db.json))
    and put it in the project root directory. If you open it, you will see a few items
    for sale and a comment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we will need to add a script to launch the json server. Add a new `db`
    script to the `package.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will run the `json-server` package command-line tool
    and watch the `db.json` file you just downloaded for changes so that you can edit
    it easily. To try it, use `npm run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, it will listen to the port `3000`. You can already try it by opening
    the `http://localhost:3000/items` REST address in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/13a1e3e2-fbe1-426a-a1be-553418aa754d.png)'
  prefs: []
  type: TYPE_IMG
- en: Launching the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to start the app. Open a new terminal and use `npm run` as
    usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It should open a new browser window with the right address, and you should
    be able to use the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/98d88834-6f0f-41c2-aaca-6b8d287b8682.png)'
  prefs: []
  type: TYPE_IMG
- en: Auto-prefixing CSS with PostCSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing CSS (or Stylus) code, we want it to be compatible with most browsers.
    Fortunately, there are tools that will do this automatically for us, for example,
    by adding vendor-prefixed versions of the CSS properties (such as `-webkit-user-select`
    and `-moz-user-select`).
  prefs: []
  type: TYPE_NORMAL
- en: PostCSS is a library specialized in CSS postprocessing. It has a very modular
    architecture; it works by adding plugins to it that process the CSS in various
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have to install it. `vue-loader` already has PostCSS included. We only
    have to install the plugins we want. In our case, we need the `autoprefixer` package
    to make our CSS code compatible with more browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `autoprefixer` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For PostCSS to be active, we will need to add a configuration file called `postcss.config.js`
    in the project root directory. Let''s tell PostCSS we want to use `autoprefixer`
    in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Our code will now be processed by `autoprefixer`. For example,
    consider this Stylus code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The final CSS will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Targeting specific browsers with browserslist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can change what browsers are targeted by `autoprefixer` with the `browserslist`
    configuration. It consists of a list of rules to determine which browsers to support.
    Open the `package.json` file and look for the `browserslist` field. It should
    already have the default values of the `webpack-simple` template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first rule takes the browsers that have more than 1% of usage share on the
    internet. The second one additionally selects the last two versions of every browsers.
    Finally, we state that we don't support Internet Explorer 8 or older.
  prefs: []
  type: TYPE_NORMAL
- en: The data used is provided by the site ([https://caniuse.com/](https://caniuse.com/)),
    which is specialized in browser compatibility data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now target even older browsers by customizing this field. For example,
    to target Firefox 20 and later versions, you would add the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can find more information about `browserslist` in its repository ([https://github.com/ai/browserslist](https://github.com/ai/browserslist)).
  prefs: []
  type: TYPE_NORMAL
- en: Improving code quality and style with ESLint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enforcing good coding practices and quality is essential when working on a project
    with other developers. It ensures that no syntax or basic errors are made (such
    as forgetting to declare a variable), and it helps to keep the source code clean
    and consistent. This process is called **linting**.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint is the recommended linting tool by the Vue.js team. It provides a set
    of linting rules that can be turned on and off to check the code quality. More
    rules can be added by plugins and some packages define a preset of enabled rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the StandardJS preset and the `eslint-plugin-vue` package, which
    adds more rules that help follow the official Vue styleguide ([https://vuejs.org/v2/style-guide/](https://vuejs.org/v2/style-guide/)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eslint-config-standard` package has four peer dependencies that we need
    to install as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use babel for the JavaScript code when ESLint parses the files,
    we will need an additional package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Configuring ESLint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `.eslintrc.js` file in the project root directory and write the
    following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we use `vue-eslint-parser` to read the files (including the `.vue` files).
    It uses `babel-eslint` when parsing the JavaScript code. We also specify the EcmaScript
    version of JavaScript and that we use the `import/export` syntax for the modules.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we tell ESLint that we expect to be in a browser and ES6 (or ES2015) JavaScript
    environment, which means we should be able to access globals such as `window`
    or Promise without ESLint raising undefined variable errors.
  prefs: []
  type: TYPE_NORMAL
- en: We also specify which configurations (or presets) we would like to use--`standard`
    and `vue/recommended`.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can change what rules are enabled and modify their options with the `rules`
    object. Add the following to the ESLint configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first line disables the `no-use-before-define` rule, which has a bug when
    using the `...` destructuration operator. The second one changes the `commad-dangle`
    rule to enforce putting a trailing `,` comma at the end of all the array and object
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: The rules have a status, which can take on those three values--`'off'` (or `0`),
    `'warn'` (or `1`), and `'error'` (or `2`).
  prefs: []
  type: TYPE_NORMAL
- en: Running ESLint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run eslint on the `src` folder, we will need a new script in the `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should note some errors in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/405cf69d-f21a-4c90-b2cd-f1c943e713ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of those issues can be fixed by ESLint by adding the `--fix` argument
    to the preceding `eslint` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it again, and you should see only one error remaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9fa11065-ae01-4017-bf71-b27f2df6a266.png)'
  prefs: []
  type: TYPE_IMG
- en: 'ESLint tells us we shouldn''t create new objects without keeping their reference
    in a variable. If we look at the corresponding code, we see that we indeed create
    a new instance of Vue in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the ESLint error, you can see the code of the rule--`no-new`.
    You can open the [https://eslint.org/](https://eslint.org/) website and type it
    in the search field to get the rule definition. If it's a rule added by a plugin,
    it should have the name of the plugin followed by a slash, for example, `vue/require-v-for-key`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is written as intended, since this is the standard way of declaring
    a Vue app. So, we need to disable this rule for this specific line of code by
    adding a special comment just before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: ESLint inside Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, we have to manually run the `eslint` script to check our code. It would
    be even better if we were able to check our code when it is processed by Webpack,
    so it would be fully automatic. Fortunately, this is possible thanks to the `eslint-loader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install it in the dev dependencies alongside the `friendly-errors-webpack-plugin`
    package, which will improve the console messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now we have to change the webpack configuration to add a new ESLint loader rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `webpack.config.js` file and add this new rule at the top of the `module.rules`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we can enable the `friendly-errors-webpack-plugin` package. Import
    it at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can't use the `import/export` syntax here, since it will be executed in nodejs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add this plugin when we are in development mode by adding an `else` condition
    at the end of the configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart webpack by rerunning the `dev` script and remove a comma somewhere
    in the code. You should see the ESLint error displayed in the webpack output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2a3f551a-d859-475b-a371-c77241e6fa29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the browser, you should now see the error overlay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3f43e45a-33e9-4dee-8eec-e0324b169115.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you fix the error by putting the comma back again, the overlay will close
    and the console will display a friendly message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30a0902a-1b0d-4313-85f2-9172ffcb67a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit testing with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Important code and components should be unit tested to ensure that they are
    working as intended and to prevent most regressions when the code evolves. The
    recommended test runner for Vue components is Jest from Facebook. It is quite
    fast with a cache system and has an handy snapshot feature to help detect regressions
    even more.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install Jest and the official Vue unit testing tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a few utilities related to Vue to compile the `.vue` files with
    `jest-vue` and to take snapshots of the components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The recommended way to get the HTML render of a component in node is using the
    `vue-server-renderer` package used to do server-side rendering as we will see
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will need some babel packages to support babel compilation and
    webpack dynamic imports inside Jest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure Jest, let''s create a new `jest.config.js` file in the project
    root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `transform` option defines processors for the JavaScript and Vue files.
    Then, we tell Jest to use `jest-serializer-vue` to serialize the snapshots of
    the components. We will also enable the source maps with the `mapCoverage` option.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more configuration options at the Jest website ([https://facebook.github.io/jest/](https://facebook.github.io/jest/)).
  prefs: []
  type: TYPE_NORMAL
- en: Babel configuration for Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To support JavaScript `import/export` modules and dynamic imports inside Jest,
    we will need to change our babel configuration when the tests are run.
  prefs: []
  type: TYPE_NORMAL
- en: When using Jest, we are not using webpack and the loaders we use to build the
    real application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add two babel plugins to the configuration, when the `NODE_ENV`
    environment variable is set to `"test"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `transform-es2015-modules-commonjs` plugin adds support for `import/export`
    syntax to Jest, and the `dynamic-import-node` adds support for dynamic imports.
  prefs: []
  type: TYPE_NORMAL
- en: When run, Jest will automatically set the `NODE_ENV` environment variable to
    `'test'`.
  prefs: []
  type: TYPE_NORMAL
- en: Our first unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be recognized by Jest anywhere by default, we need to call our test files
    `.test.js` or `.spec.js`. We will test the `BaseButton.vue` component; go ahead
    and create a new `BaseButton.spec.js` file next to it in the `src/components`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import the component and the `shallow` method from `vue-test-utils`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create a tests suite with the `describe` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the tests suite, we can add our first unit test with the `test` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We will test whether the `click` event is emitted when we click on the component.
    We need to create a wrapper object around the component that will provide useful
    functions to test the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will simulate a click on the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will check whether the `click` event was emitted using the Jest
    `expect` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a script in the `package.json` file to run Jest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the usual `npm run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests are launched and should pass as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ba5e5b4-61b3-472e-a5d8-7061e349368d.png)'
  prefs: []
  type: TYPE_IMG
- en: To learn more about unit testing Vue components, you can visit the official
    guide at [https://vue-test-utils.vuejs.org/](https://vue-test-utils.vuejs.org/)
  prefs: []
  type: TYPE_NORMAL
- en: ESLint and Jest globals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we run ESLint now, we will get errors related to the Jest keywords such
    as `describe`, `test`, and `expect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cbe5bb34-3fa0-4ec2-845e-665b0927d6f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to make a tiny change to our ESLint configuration--we have to specify
    the `jest` environment; edit the `.eslintrc.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, ESLint will know about the Jest keywords and will stop complaining.
  prefs: []
  type: TYPE_NORMAL
- en: Jest snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Snapshots are strings that are saved and compared each time tests are run to
    detect potential regression. They are mostly used to save the HTML render of component,
    but can be used for any value as long as it make sense to store it between tests
    and compare it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our Vue component, we will snapshot the HTML render of it using the server-side
    Rendering tool called `vue-server-renderer`. We will need the `createRenderer`
    method from this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'At the start of the test, we instanciate a renderer instance, then we wrap
    the component with `shallow` and start rendering the component to a String. Finally,
    we compare the result with the previous one. Here is an example of snapshot test
    for the `BaseButton` component, passing some props values and the default slot
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If the snapshot test is run for the first time, it will create and save the
    snapshot to a `__snapshots__` folder next to it. If you are using a versioning
    system such as git, you need to add these snapshot files to it.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you modify a component, there is a chances that its HTML render will change
    too. This means its snapshots will no longer be valid and the Jest tests will
    fail. Fortunately, the `jest` command has a `--updateSnapshots` argument. When
    used, all the failing snapshots will be resaved and will pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new script in our `package.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Modify the `BaseButton` component by changing a CSS class, for example. If your
    run the Jest tests again, you should get an error that says, the snapshots don't
    match anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/697b17b2-cdb2-499a-a113-e8e3ea3c7301.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, update the snapshot with the new script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'All the tests should pass now, and the `BaseButton` snapshot should be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d00b9be6-1df2-480a-96e8-50533f37de7d.png)You should run this command
    only when you are sure there are no regressions elsewhere. A good idea is to run
    the tests normally just before, to make sure only the modified component snapshot
    fails, as expected. After you have updated the snapshots, use the normal test
    command.'
  prefs: []
  type: TYPE_NORMAL
- en: Complementary topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover a few more topics that can be useful for bigger
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization and code-splitting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the app is to be used by people in different countries, it should be translated
    to be more user-friendly and appealing. To localize the texts of the app, you
    can use the recommended `vue-i18n` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Using `vue-i18n`, we will add a link in the `AppFooter` component to a new page
    where the user can select the language. Only the link and this page will be translated,
    but you can translate more parts of the app if you wish. `vue-i18n` works by creating
    a `i18n` object from it with the translated messages and injecting it into the
    Vue app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/plugins.js` file, install the new plugin into Vue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a new folder called `i18n` in the project directory. Download the
    `locales` folder ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/locales](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/locales))
    containing the translation files and put it inside. You should have, for example,
    the `en` translations in the `i18n/locales/en.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `index.js` file that exports the list of available languages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need two new utility functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createI18n`: To create the `i18n` object, with a `locale` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAutoLang`: That returns the two-letter language code set by the user in
    the browser, for example, `en` or `fr`. Most of the time, this will be the OS
    language setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `src/utils` folder, create a new `i18n.js` file and import both `VueI18n`
    and the list of available locales we defined earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'At the time of writing, we need the `babel-preset-stage-2` (or less) to allow
    Babel to parse the dynamic imports. In the `package.json` file, change the `babel-preset-stage-3`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Run `npm install` to update your packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `.babelrc` file in the root folder and change `stage-3` to `stage-2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to switch to stage-2, do the following installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Code-splitting with dynamic imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create the `i18n` object, we want to load only the translations of the
    selected locale via the `locale` argument. To do that, we will make a dynamic
    import of the file with the `import` function. It takes the path as the argument
    and returns a Promise, which will eventually resolve to the corresponding JavaScript
    module once it is loaded from the server.
  prefs: []
  type: TYPE_NORMAL
- en: In webpack, this dynamic import feature is sometimes referred as 'code splitting',
    because webpack will move the asynchronous module to another compiled JavaScript
    file called a chunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of an asynchronous module loaded with a dynamic import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use variables in the imported path, as long as it has some information
    about where webpack can find the files. For example, this code will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the following one will work fine as long as the variable path is simple
    (without `../`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this example, all the files with the `json` extension in the `data` folder
    will be added to the build into asynchronous chunks, because webpack can't guess
    which ones you will really use at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronously loading big JavaScript modules with dynamic imports can reduce
    the size of the initial JavaScript code sent to the browser when opening the page.
    In our app, it allows us to load only the relevant translations file instead of
    including them all in the initial JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a module is already imported with a normal `import` in the main code (the
    initial chunk), it will already be loaded and will not be split into another chunk.
    In that case, you won''t have the benefits of the code-splitting feature and the
    initial file size won''t be reduced. Note that you can synchronously use other
    modules with the normal `import` keyword inside the dynamically loaded module:
    they will be put together in the chunk (if they aren''t already included in the
    initial chunk).'
  prefs: []
  type: TYPE_NORMAL
- en: The `i18n` object is created with the `VueI18n` constructor from the `vue-i18n`
    package. We will pass the `locale` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the `createI18n` function should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we need to take the `default` value of the module, because we
    exported the messages using `export default`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code using `async/await` above can be written using Promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Automatically loading the user locale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we can use `navigator.language` (or `userLanguage` for Internet Explorer
    compatibility) to retrieve the locale code. Then, we will check whether it is
    available in the `langs` list or if we have to use the default `en` locale.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getAutoLang` function should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Some browsers may return the code in the `en-US` format, but we only need the
    first two characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/main.js` file, import the two new utility functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the preferred locale using `getAutoLang`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and wait for the `i18n` object with the `createI18n` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the `i18n` object into the root Vue instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget the `await` keyword in front of `createI18n`, or else you will
    get the Promise instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now open the network pane in the browser devtools and refresh the page.
    The translations module corresponding to the selected locale will be loaded by
    webpack in a separate request. In this example screenshot, this is the `2.build.js`
    file that is asynchronously loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7fc40741-5fb8-4dac-b4fe-6b1108ed649e.png)'
  prefs: []
  type: TYPE_IMG
- en: Changing Language page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, nothing really changed in the app, so let's add the page that will
    allow us to select the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/router.js` file, import the `PageLocale` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the `locale` route in the `routes` array, just before the last one
    (with the `*` path):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `AppFooter.vue` component, add this router link to the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we use the `$t` provided by `vue-i18n`
    to display a translated text. The argument correspond to the key in the locale
    file. You should now see the link in the app footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/16f6aa12-ab37-4402-b2ad-68b0ba446978.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The links takes us to the language selection page, which is already fully translated
    using `vue-i18n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ebe4ef49-49c9-4427-b65a-090b56bd23f0.png)'
  prefs: []
  type: TYPE_IMG
- en: You can look at its source code in the `components/PageLocale.vue` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on a locale button, the corresponding translations are loaded
    if they aren''t already. In the network pane of the browser devtools, you should
    see a request made to other chunks each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/be04ca4d-f80a-4f51-94fd-f3a2659730a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Server-side rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Server-side Rendering** (**SSR**) consists of running and rendering the app
    on the server, before sending the HTML back to the browser. This has two main
    advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Better **Search Engine Optimization** (**SEO**), since the initial content of
    the application will be rendered in the page HTML. This is important since no
    search engine is indexing an asynchronous JavaScript app (for example, when you
    have a spinner).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slower networks or devices will display contents faster--the rendered HTML doesn't
    need the JavaScript to be shown to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, using SSR also brings some trade-offs:'
  prefs: []
  type: TYPE_NORMAL
- en: The code need to be able to run on the server (unless it is in client-side only
    hooks such as `mounted`). Also, some libraries may not play well on the browser
    and may require special treatments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The load will increase on the server, since it is doing more work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development setup is a bit more complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So using SSR isn't always a good idea, especially if the time the first content
    is shown isn't critical (for example, an admin dashboard).
  prefs: []
  type: TYPE_NORMAL
- en: Universal App Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a Universal App that runs both on the client and the server requires
    changing the architecture of the source code.
  prefs: []
  type: TYPE_NORMAL
- en: When running on the client, we are in a fresh context each time the page is
    loaded. That's why we used singletons instance of the root instance, the router,
    and the store until now. However, now we need to have a fresh context on the server
    as well--the problem is, Node.js is stateful. The solution is creating a fresh
    new root instance, router, and store for each request handled by the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the router. In the `src/router.js` file, wrap the router
    creation into a new exported `createRouter` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We will do the same with the Vuex store. In the `src/store/index.js` file,
    wrap the code into a new exported `createStore` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also rename the `src/main.js` file to `src/app.js`. This will be our
    universal file that creates the router, the store, and the Vue root instance.
    Change the `main` function into an exported `createApp` function, which takes
    a `context` argument and returns the app, the router, and the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to change the imports for `createRouter` and `createStore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server, we won''t select the initial locale the same way as in the client
    since we won''t have access to `window.navigator`. That''s why we are passing
    the locale in the `context` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We also removed the `el` option from the root instance definition since it doesn't
    make sense on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Client entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the browser, the code will be started in the client entry file that we will
    write now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `src/entry-client.js` file that will be the entry point for the
    client bundle. It will get the user language, call the `createApp` function, and
    then mount the app into the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now change the entry path in the `webpack.config.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You can restart the `dev` script and check whether the app still works in the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Server entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new `src/entry-server.js` file that will be the entry point for the
    server bundle. It will export a function that gets a `context` object from the
    HTTP server we will build later. It should return a Promise that resolves with
    the Vue app when it's ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will pass an `url` attribute to the context so that we can set the current
    route like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly to the client entry, we also use the `createApp` function to create
    the root app instance, the router, and the store. `entry-server.js` should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We return a Promise because we will send the application `app` when we will
    have finished all the operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `app` root instance will be send back to what we call the renderer (kind
    of like when we did Jest snapshots) using `resolve(app)`. First, we need to take
    care of preloading the Vuex store.
  prefs: []
  type: TYPE_NORMAL
- en: State management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When processing a request, we need to fetch the data on the relevant components
    before rendering the app. That way, the data will already be displayed when the
    HTML is loaded by the browser. For example, `PageHome.vue` fetches the store items
    and `PageStoreItem.vue` retrieves the item details and comments.
  prefs: []
  type: TYPE_NORMAL
- en: We will add a new `asyncData` custom option to those, so we can call it on the
    server when doing SSR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `PageHome.vue` component by adding this function that dispatches the
    `fetchItems` action of the `items` store module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `PageStoreItem.vue` component, we need to call the `fetchStoreItemDetails`
    action of the `item` store module, with the `id` parameter of the route passed
    by the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our components are ready, we will go back to `entry-server.js`. We
    can use the `router.getMatchedComponents()` method to get the list of components
    that matched with the current route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then call all the `asyncData` options of these components and wait for
    them to finish. We pass both the store and the current route to them, and when
    they have all completed, we send the Vuex store state back to the renderer with
    `context.state = store.state`. Use `Promise.all(array)` to wait for all the `asyncData`
    calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If an error occurs, it will reject the Promise we returned to the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring the Vuex state on the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The store state is serialized by the server on a `__INITIAL_STATE__` variable
    in the HTML page. We can use this to set the state even before the app is mounted,
    so the components will have access to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `entry-client.js` file and use the `store.replaceState` method before
    mounting the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Now, the store will have the data sent by the server.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our app code is now ready. Before continuing, we need to refactor our webpack
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We will need a slightly different webpack configuration for the client and the
    server. It is a good idea to have a common configuration file, which is then extended
    for the client and the server. We can do this easily with the `webpack-merge`
    package that merges multiples webpack configuration objects into one.
  prefs: []
  type: TYPE_NORMAL
- en: For the server configuration, we also need the `webpack-node-externals` package
    to prevent webpack from bundling the packages in `node_modules`--this is not necessary
    since we will run inside nodejs and not in the browser. All the corresponding
    imports will be left as `require` statements so that node will load them itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the packages in the dev dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `webpack` folder in the project root directory, then move and rename
    the `webpack.config.js` file to `webpack/common.js`. Some changes are needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `entry` option from the configuration. This will be specified in
    the specific extended configurations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `output` option to target the correct folder and to generate better
    chunk names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Client configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next to `webpack/common.js`, create a new `client.js` file that extends the
    base configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The `VueSSRClientPlugin` will generate a `vue-ssr-client-manifest.json` file
    that we will give to the renderer. This way, it will know more about the client.
    Also, it will automatically inject the script tags and the critical CSS to the
    HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The Critical CSS is the style of the components rendered by the server. Those
    styles will be directly injected to the page HTML so that the browser doesn't
    have to wait for the CSS to be loaded; it can display those components sooner.
  prefs: []
  type: TYPE_NORMAL
- en: The `CommonsChunkPlugin` will put the webpack runtime code into a leading chunk
    so that asynchronous chunks can be injected right after it. It also improves caching
    of the app and vendor code.
  prefs: []
  type: TYPE_NORMAL
- en: Server configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next to `webpack/common.js`, create a new `server.js` file that extends the
    base configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Here, we change multiple options, such as the `target` and `output.libraryTarget`
    ones, to adapt to the node.js environment.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `webpack-node-externals` package, we tell webpack to ignore the modules
    located in the `node_modules` folder (which means the dependencies). Since we
    are in nodejs and not in a browser, we don't have to bundle all the dependencies
    into the bundle, so this will improve the build times.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `VueSSRServerPlugin` to generate the server bundle file that
    will be used by the renderer. It contains the compiled server-side code and a
    lot of other informations so that the renderer can support source maps (with the
    `source-map` value of `devtool`), hot-reloading, critical CSS injection, and other
    injections in conjunction with the client manifest data.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In development, we can't use `webpack-dev-server` directly anymore with SSR.
    Instead, we will set up the express server with webpack. Download the `server.dev.js`
    file ([https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js))
    and put it in the project root directory. This file exports a `setupDevServer`
    function that we will use to run webpack and update the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need some packages for the development setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We can create virtual file systems with `memory-fs`, watch files with `chokidar`,
    and enable webpack Hot Module Replacement in an express server with the last two
    middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Page template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `index.template.html` file alongside `index.html` and copy its
    contents. Then, replace the body content with the special `<!--vue-ssr-outlet-->`
    comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This special comment will be replaced by the rendered markup on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Express server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the nodejs side, we will use `express` package to create our HTTP server.
    We will also need the `reify` package so that we can require files that uses the
    `import/export` syntax inside nodejs (which doesn't support it natively).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the new packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Download this incomplete `server.js` file ([https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js))
    and put it in the project root directory. It already creates an express server
    and configures the necessary express routes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, we will focus on the development part.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and updating the renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To render our app, we will need a renderer created with the `createBundleRenderer`
    function from the `vue-server-renderer` package.
  prefs: []
  type: TYPE_NORMAL
- en: A bundle renderer is quite different from a normal renderer. It uses a server
    bundle file (that will be generated, thanks to our new webpack configuration)
    with an optional client manifest that allows the renderer to have more information
    about the code. This enables more features such as source maps and hot-reloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `server.js` file, replace the `// TODO development` comment with this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `server.dev.js` file, we can add support of webpack hot-reloading
    to our express server. We also specify the path to the HTML page template, so
    we can reload it too when changed.
  prefs: []
  type: TYPE_NORMAL
- en: When the setup triggers an update, we create or recreate the bundle renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the Vue app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we will need to implement the code that renders the app and send the HTML
    result back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `// TODO render` comment with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `req.acceptsLanguages` method from express, we can easily select
    the preferred language of the user.
  prefs: []
  type: TYPE_NORMAL
- en: When performing the request, the web browser will send a list of "accepted languages"
    by the user. This is generally the language set for either their browser or OS.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `renderToString` method that will call the function we exported
    in the `entry-server.js` file, wait for the returned Promise to complete and then
    render the app into an HTML string. Finally, we send the result to the client
    (unless there is an error during the render).
  prefs: []
  type: TYPE_NORMAL
- en: Running our SSR app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now is the time to run the app. Change the `dev` script to run our express
    server instead of `webpack-dev-server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the script and refresh the app. To be sure that the SSR is working
    correctly, view the source of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e6fa9edd-fa17-4311-ad62-3f77f09f2fcb.png)'
  prefs: []
  type: TYPE_IMG
- en: The app is already rendered in HTML by the server.
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessary fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, something is wrong with our app. The server sends the Vuex store
    data alongside the HTML of the page, which means the app already has all the data
    it needs when running for the first time, except that the requests to retrieve
    the stored items of the item details and comments are still being made. You can
    see this because of the loading animation that appears when you first load or
    when you refresh one of the corresponding pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this is to prevent the components from fetching data if it
    is not necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PageHome.vue` component, we need to fetch the items only if we don''t
    have them already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `PageStoreItem.vue` component, the details and comments should be fetched
    only if we don''t have the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We no longer have the issue now.
  prefs: []
  type: TYPE_NORMAL
- en: To continue learn more about SSR, you can visit the official documentation at
    [https://ssr.vuejs.org/](https://ssr.vuejs.org/) or use an easy-to-use framework
    called nuxtjs ([https://nuxtjs.org/](https://nuxtjs.org/)), which abstracts a
    lot of boilerplate away from you.
  prefs: []
  type: TYPE_NORMAL
- en: Production build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our app is working great in development. Let's say we have finished it and we
    want to deploy it to a real server.
  prefs: []
  type: TYPE_NORMAL
- en: Additional configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to add some configuration for the production build of the app to ensure
    that it is optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the style into CSS files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, the style was added to the page via the JavaScript code. This is
    great in development because it allows hot-reloading with webpack. However, in
    production, it is recommended to extract it into separate CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `extract-text-webpack-plugin` package in the dev dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `webpack/common.js` configuration file, add a new `isProd` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `vue-loader` rule to enable the CSS extraction if we are in production
    and to ignore the whitespaces between HTML tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `ExtractTextPlugin` and the `ModuleConcatenationPlugin` to the production-only
    plugins list at the bottom of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '`ExtractTextPlugin` will put the style into CSS files and the `ModuleConcatenationPlugin`
    will optimize the compiled JavaScript code to be faster.'
  prefs: []
  type: TYPE_NORMAL
- en: Production express server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last changes we need to make to our code is the bundle renderer creation
    in the express server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `server.js` file, replace the `// TODO production` comment with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We will read the HTML page template, the server bundle, and the client manifest.
    Then, we create a new bundle renderer since we won't have hot-reloading in production.
  prefs: []
  type: TYPE_NORMAL
- en: New npm scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The compiled code will be output to a `dist` directory in the project root.
    Between each build, we need to remove it so we are in a clean state. To do that
    in a cross-platform manner, we will use the `rimraf` package that can recursively
    delete files and folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `rimraf` package to the dev dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `build` script for both the client and server bundles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We set the `NODE_ENV` environment variable to `'production'` and run the `webpack`
    command with the corresponding webpack configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `build` script that clears the `dist` folder and runs the two
    other `build:client` and `build:server` scripts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a last script called `start` that runs the express server in production
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the build; use the usual `npm run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dist` folder should now contain all the chunks generated by webpack, plus
    the server bundle and client manifest json files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b512c29d-758b-4e57-8c09-bee33bb1f435.png)These are the files that
    need to be uploaded to your real nodejs server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start the express server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: You should also upload the `server.js`, `package.json`, and `package-lock.json`
    files to the real server. Don't forget to install the dependencies with `npm install`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we improved our development workflow by learning how to autoprefix
    our CSS with PostCSS, lint our code for quality with ESLint, and unit test our
    components with Jest. We went even further by adding localization with the `vue-i18n`
    package and dynamic imports, and by refactoring the project to enable server-side
    rendering while still taking advantage of the awesome webpack features such as
    hot-reloading, code-splitting, and optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we will create a simple real-time app with the Meteor fullstack
    framework and Vue.
  prefs: []
  type: TYPE_NORMAL
