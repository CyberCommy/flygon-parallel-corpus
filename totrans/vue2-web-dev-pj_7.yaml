- en: Project 5 - Online Shop and Scaling Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目5 - 在线商店和扩展
- en: 'In this chapter, we will quickly set up a "Fashion Store" app in order to focus
    on more advanced topics, such as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将快速设置一个“时尚商店”应用程序，以便专注于更高级的主题，例如以下内容：
- en: Improving the compatibility of our CSS code with PostCSS and autoprefixer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进我们的CSS代码与PostCSS和autoprefixer的兼容性
- en: Linting our code with ESLint to improve its quality and style
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ESLint对我们的代码进行linting以提高其质量和风格
- en: Unit testing our Vue components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我们的Vue组件进行单元测试
- en: Localizing the app and taking advantage of the code-splitting feature of webpack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化应用程序并利用webpack的代码拆分功能
- en: Enabling server-side rendering of the app in Nodejs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Nodejs中启用应用程序的服务器端渲染
- en: Building the app for production
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为生产构建应用程序
- en: 'The app will be a simple wearable online shop that will look like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将是一个简单的可穿戴在线商店，看起来像这样：
- en: '![](assets/87d90bd9-c55e-4bfc-8d62-64d4d9722836.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/87d90bd9-c55e-4bfc-8d62-64d4d9722836.png)'
- en: Advanced development workflow
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级开发工作流程
- en: In this first section, we will improve our development workflow with new tools
    and packages. However, first, we need to set up our Fashion Store project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用新的工具和包来改进我们的开发工作流程。但是，首先，我们需要设置我们的时尚商店项目。
- en: Setting up the project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Generate a new project using the `vue init` command like we did in [Chapter
    5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml), *Project 3 - Support Center*,
    and [Chapter 6](40d407e7-1556-4265-8385-4afe5fc66430.xhtml), *Project 4 - Geolocated
    Blog*:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`vue init`命令生成一个新项目，就像我们在[第5章](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml)中所做的那样，*项目3
    - 支持中心*，以及[第6章](40d407e7-1556-4265-8385-4afe5fc66430.xhtml)中所做的那样，*项目4 - 地理定位博客*：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will also install stylus:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将安装stylus：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remove the content of the `src` folder. Then, download the sources files ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/src](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/src))
    and extract them in the `src` folder. Those contains all the app source code that
    have been already done so that we can move forward faster.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`src`文件夹的内容。然后，下载源文件（[https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/src](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/src)）并将其解压缩到`src`文件夹中。这些包含了已经完成的所有应用程序源代码，以便我们可以更快地前进。
- en: 'We need to install a few more packages in the dependencies:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在依赖项中安装一些更多的包：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: axios is a great library for making requests to the server and is recommended
    by the Vue.js team.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: axios是一个很棒的库，用于向服务器发出请求，并且被Vue.js团队推荐使用。
- en: Generating a quick development API
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成一个快速开发API
- en: 'Previously, we had a full node server for the backend, but this time we will
    not focus on the app features. So, we will use the `json-server` package to generate
    a very simple local API for the purpose of this chapter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们有一个完整的用于后端的node服务器，但这次我们不会专注于应用程序功能。因此，我们将使用`json-server`包为本章的目的生成一个非常简单的本地API：
- en: 'Install `json-server` as a dev dependency:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`json-server`作为开发依赖：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we run this package, it will locally expose a simple REST API and use a
    `db.json` file to store the data. You can download it ([https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/db.json](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/db.json))
    and put it in the project root directory. If you open it, you will see a few items
    for sale and a comment.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行这个包时，它将在本地公开一个简单的REST API，并使用`db.json`文件来存储数据。您可以下载它（[https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/db.json](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/db.json)）并将其放在项目根目录中。如果您打开它，您将看到一些待售物品和评论。
- en: 'Then, we will need to add a script to launch the json server. Add a new `db`
    script to the `package.json` file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加一个脚本来启动json服务器。在`package.json`文件中添加一个新的`db`脚本：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding command will run the `json-server` package command-line tool
    and watch the `db.json` file you just downloaded for changes so that you can edit
    it easily. To try it, use `npm run`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将运行`json-server`包的命令行工具，并监视您刚刚下载的`db.json`文件以进行更改，以便您可以轻松编辑它。要尝试它，请使用`npm
    run`：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By default, it will listen to the port `3000`. You can already try it by opening
    the `http://localhost:3000/items` REST address in your browser:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它将监听端口`3000`。您可以通过在浏览器中打开`http://localhost:3000/items` REST地址来尝试它：
- en: '![](assets/13a1e3e2-fbe1-426a-a1be-553418aa754d.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/13a1e3e2-fbe1-426a-a1be-553418aa754d.png)'
- en: Launching the app
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动应用程序
- en: 'We are now ready to start the app. Open a new terminal and use `npm run` as
    usual:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备启动应用程序。打开一个新的终端，像往常一样使用`npm run`：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It should open a new browser window with the right address, and you should
    be able to use the app:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该打开一个新的浏览器窗口，显示正确的地址，您应该能够使用该应用程序：
- en: '![](assets/98d88834-6f0f-41c2-aaca-6b8d287b8682.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/98d88834-6f0f-41c2-aaca-6b8d287b8682.png)'
- en: Auto-prefixing CSS with PostCSS
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PostCSS自动添加CSS前缀
- en: When writing CSS (or Stylus) code, we want it to be compatible with most browsers.
    Fortunately, there are tools that will do this automatically for us, for example,
    by adding vendor-prefixed versions of the CSS properties (such as `-webkit-user-select`
    and `-moz-user-select`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写CSS（或Stylus）代码时，我们希望它与大多数浏览器兼容。幸运的是，有一些工具可以自动为我们完成这项工作，例如，通过添加CSS属性的供应商前缀版本（例如`-webkit-user-select`和`-moz-user-select`）。
- en: PostCSS is a library specialized in CSS postprocessing. It has a very modular
    architecture; it works by adding plugins to it that process the CSS in various
    ways.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS是一个专门用于CSS后处理的库。它具有非常模块化的架构；它通过向其中添加处理CSS的插件来工作。
- en: We don't have to install it. `vue-loader` already has PostCSS included. We only
    have to install the plugins we want. In our case, we need the `autoprefixer` package
    to make our CSS code compatible with more browsers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必安装它。`vue-loader`已经包含了PostCSS。我们只需要安装我们想要的插件。在我们的情况下，我们需要`autoprefixer`包来使我们的CSS代码与更多浏览器兼容。
- en: 'Install the `autoprefixer` package:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`autoprefixer`包：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For PostCSS to be active, we will need to add a configuration file called `postcss.config.js`
    in the project root directory. Let''s tell PostCSS we want to use `autoprefixer`
    in this file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使PostCSS生效，我们需要在项目根目录下添加一个名为`postcss.config.js`的配置文件。让我们在这个文件中告诉PostCSS我们想要使用`autoprefixer`：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That''s it! Our code will now be processed by `autoprefixer`. For example,
    consider this Stylus code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们的代码现在将由`autoprefixer`处理。例如，考虑这段Stylus代码：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final CSS will be as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的CSS将如下所示：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Targeting specific browsers with browserslist
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用browserslist来定位特定的浏览器
- en: 'We can change what browsers are targeted by `autoprefixer` with the `browserslist`
    configuration. It consists of a list of rules to determine which browsers to support.
    Open the `package.json` file and look for the `browserslist` field. It should
    already have the default values of the `webpack-simple` template, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`browserslist`配置更改`autoprefixer`所定位的浏览器。它包括一系列规则，用于确定要支持哪些浏览器。打开`package.json`文件，查找`browserslist`字段。它应该已经具有`webpack-simple`模板的默认值，如下所示：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first rule takes the browsers that have more than 1% of usage share on the
    internet. The second one additionally selects the last two versions of every browsers.
    Finally, we state that we don't support Internet Explorer 8 or older.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个规则获取在互联网上使用份额超过1%的浏览器。第二个规则另外选择每个浏览器的最后两个版本。最后，我们声明不支持Internet Explorer 8或更早版本。
- en: The data used is provided by the site ([https://caniuse.com/](https://caniuse.com/)),
    which is specialized in browser compatibility data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的数据由专门从事浏览器兼容性数据的网站（[https://caniuse.com/](https://caniuse.com/)）提供。
- en: 'You can now target even older browsers by customizing this field. For example,
    to target Firefox 20 and later versions, you would add the following rule:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过自定义此字段来针对甚至更旧的浏览器。例如，要针对Firefox 20及更高版本进行定位，您将添加以下规则：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can find more information about `browserslist` in its repository ([https://github.com/ai/browserslist](https://github.com/ai/browserslist)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其存储库中找到有关`browserslist`的更多信息（[https://github.com/ai/browserslist](https://github.com/ai/browserslist)）。
- en: Improving code quality and style with ESLint
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ESLint改进代码质量和风格
- en: Enforcing good coding practices and quality is essential when working on a project
    with other developers. It ensures that no syntax or basic errors are made (such
    as forgetting to declare a variable), and it helps to keep the source code clean
    and consistent. This process is called **linting**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在与其他开发人员一起开发项目时，强制执行良好的编码实践和质量至关重要。它确保不会出现语法或基本错误（例如忘记声明变量），并有助于保持源代码清洁和一致。这个过程称为**linting**。
- en: ESLint is the recommended linting tool by the Vue.js team. It provides a set
    of linting rules that can be turned on and off to check the code quality. More
    rules can be added by plugins and some packages define a preset of enabled rules.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint是Vue.js团队推荐的linting工具。它提供了一组可以打开和关闭以检查代码质量的linting规则。通过插件可以添加更多规则，并且一些软件包定义了启用规则的预设。
- en: 'We will use the StandardJS preset and the `eslint-plugin-vue` package, which
    adds more rules that help follow the official Vue styleguide ([https://vuejs.org/v2/style-guide/](https://vuejs.org/v2/style-guide/)):'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用StandardJS预设和`eslint-plugin-vue`软件包，该软件包添加了更多规则，有助于遵循官方Vue风格指南（[https://vuejs.org/v2/style-guide/](https://vuejs.org/v2/style-guide/)）。
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `eslint-config-standard` package has four peer dependencies that we need
    to install as well:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`eslint-config-standard`软件包有四个需要安装的对等依赖项：'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to use babel for the JavaScript code when ESLint parses the files,
    we will need an additional package:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在ESLint解析文件时对JavaScript代码使用babel，我们需要安装额外的软件包：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Configuring ESLint
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置ESLint
- en: 'Create a new `.eslintrc.js` file in the project root directory and write the
    following configuration:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录中创建一个新的`.eslintrc.js`文件，并编写以下配置：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we use `vue-eslint-parser` to read the files (including the `.vue` files).
    It uses `babel-eslint` when parsing the JavaScript code. We also specify the EcmaScript
    version of JavaScript and that we use the `import/export` syntax for the modules.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`vue-eslint-parser`来读取文件（包括`.vue`文件）。在解析JavaScript代码时，它使用`babel-eslint`。我们还指定了JavaScript的EcmaScript版本，以及我们使用`import/export`语法进行模块化。
- en: Then, we tell ESLint that we expect to be in a browser and ES6 (or ES2015) JavaScript
    environment, which means we should be able to access globals such as `window`
    or Promise without ESLint raising undefined variable errors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们告诉ESLint我们期望在浏览器和ES6（或ES2015）JavaScript环境中，这意味着我们应该能够访问全局变量，如`window`或Promise，而不会引发ESLint未定义变量错误。
- en: We also specify which configurations (or presets) we would like to use--`standard`
    and `vue/recommended`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了我们想要使用的配置（或预设）--`standard`和`vue/recommended`。
- en: Customizing the rules
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义规则
- en: 'We can change what rules are enabled and modify their options with the `rules`
    object. Add the following to the ESLint configuration:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`rules`对象更改启用的规则以及修改它们的选项。将以下内容添加到ESLint配置中：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line disables the `no-use-before-define` rule, which has a bug when
    using the `...` destructuration operator. The second one changes the `commad-dangle`
    rule to enforce putting a trailing `,` comma at the end of all the array and object
    lines.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行禁用了`no-use-before-define`规则，在使用`...`解构运算符时会出现bug。第二行将`commad-dangle`规则更改为强制在所有数组和对象行的末尾放置逗号`,`。
- en: The rules have a status, which can take on those three values--`'off'` (or `0`),
    `'warn'` (or `1`), and `'error'` (or `2`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Running ESLint
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run eslint on the `src` folder, we will need a new script in the `package.json`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should note some errors in the console:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/405cf69d-f21a-4c90-b2cd-f1c943e713ed.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 'Some of those issues can be fixed by ESLint by adding the `--fix` argument
    to the preceding `eslint` command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run it again, and you should see only one error remaining:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9fa11065-ae01-4017-bf71-b27f2df6a266.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'ESLint tells us we shouldn''t create new objects without keeping their reference
    in a variable. If we look at the corresponding code, we see that we indeed create
    a new instance of Vue in the `main.js` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you look at the ESLint error, you can see the code of the rule--`no-new`.
    You can open the [https://eslint.org/](https://eslint.org/) website and type it
    in the search field to get the rule definition. If it's a rule added by a plugin,
    it should have the name of the plugin followed by a slash, for example, `vue/require-v-for-key`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is written as intended, since this is the standard way of declaring
    a Vue app. So, we need to disable this rule for this specific line of code by
    adding a special comment just before:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ESLint inside Webpack
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, we have to manually run the `eslint` script to check our code. It would
    be even better if we were able to check our code when it is processed by Webpack,
    so it would be fully automatic. Fortunately, this is possible thanks to the `eslint-loader`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Install it in the dev dependencies alongside the `friendly-errors-webpack-plugin`
    package, which will improve the console messages:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we have to change the webpack configuration to add a new ESLint loader rule.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `webpack.config.js` file and add this new rule at the top of the `module.rules`
    option:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Additionally, we can enable the `friendly-errors-webpack-plugin` package. Import
    it at the top of the file:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can't use the `import/export` syntax here, since it will be executed in nodejs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add this plugin when we are in development mode by adding an `else` condition
    at the end of the configuration file:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Restart webpack by rerunning the `dev` script and remove a comma somewhere
    in the code. You should see the ESLint error displayed in the webpack output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2a3f551a-d859-475b-a371-c77241e6fa29.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: 'In the browser, you should now see the error overlay:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3f43e45a-33e9-4dee-8eec-e0324b169115.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: 'If you fix the error by putting the comma back again, the overlay will close
    and the console will display a friendly message:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30a0902a-1b0d-4313-85f2-9172ffcb67a4.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: Unit testing with Jest
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Important code and components should be unit tested to ensure that they are
    working as intended and to prevent most regressions when the code evolves. The
    recommended test runner for Vue components is Jest from Facebook. It is quite
    fast with a cache system and has an handy snapshot feature to help detect regressions
    even more.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install Jest and the official Vue unit testing tools:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also need a few utilities related to Vue to compile the `.vue` files with
    `jest-vue` and to take snapshots of the components:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The recommended way to get the HTML render of a component in node is using the
    `vue-server-renderer` package used to do server-side rendering as we will see
    later in the chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will need some babel packages to support babel compilation and
    webpack dynamic imports inside Jest:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Configuring Jest
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure Jest, let''s create a new `jest.config.js` file in the project
    root directory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `transform` option defines processors for the JavaScript and Vue files.
    Then, we tell Jest to use `jest-serializer-vue` to serialize the snapshots of
    the components. We will also enable the source maps with the `mapCoverage` option.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: You can find more configuration options at the Jest website ([https://facebook.github.io/jest/](https://facebook.github.io/jest/)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Babel configuration for Jest
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To support JavaScript `import/export` modules and dynamic imports inside Jest,
    we will need to change our babel configuration when the tests are run.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: When using Jest, we are not using webpack and the loaders we use to build the
    real application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add two babel plugins to the configuration, when the `NODE_ENV`
    environment variable is set to `"test"`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `transform-es2015-modules-commonjs` plugin adds support for `import/export`
    syntax to Jest, and the `dynamic-import-node` adds support for dynamic imports.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: When run, Jest will automatically set the `NODE_ENV` environment variable to
    `'test'`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Our first unit test
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be recognized by Jest anywhere by default, we need to call our test files
    `.test.js` or `.spec.js`. We will test the `BaseButton.vue` component; go ahead
    and create a new `BaseButton.spec.js` file next to it in the `src/components`
    folder.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import the component and the `shallow` method from `vue-test-utils`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we will create a tests suite with the `describe` function:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside the tests suite, we can add our first unit test with the `test` function:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will test whether the `click` event is emitted when we click on the component.
    We need to create a wrapper object around the component that will provide useful
    functions to test the component:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we will simulate a click on the component:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we will check whether the `click` event was emitted using the Jest
    `expect` method:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s add a script in the `package.json` file to run Jest:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, use the usual `npm run` command:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The tests are launched and should pass as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ba5e5b4-61b3-472e-a5d8-7061e349368d.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: To learn more about unit testing Vue components, you can visit the official
    guide at [https://vue-test-utils.vuejs.org/](https://vue-test-utils.vuejs.org/)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: ESLint and Jest globals
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we run ESLint now, we will get errors related to the Jest keywords such
    as `describe`, `test`, and `expect`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cbe5bb34-3fa0-4ec2-845e-665b0927d6f4.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: 'We need to make a tiny change to our ESLint configuration--we have to specify
    the `jest` environment; edit the `.eslintrc.js` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, ESLint will know about the Jest keywords and will stop complaining.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Jest snapshots
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Snapshots are strings that are saved and compared each time tests are run to
    detect potential regression. They are mostly used to save the HTML render of component,
    but can be used for any value as long as it make sense to store it between tests
    and compare it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'For our Vue component, we will snapshot the HTML render of it using the server-side
    Rendering tool called `vue-server-renderer`. We will need the `createRenderer`
    method from this package:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'At the start of the test, we instanciate a renderer instance, then we wrap
    the component with `shallow` and start rendering the component to a String. Finally,
    we compare the result with the previous one. Here is an example of snapshot test
    for the `BaseButton` component, passing some props values and the default slot
    content:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the snapshot test is run for the first time, it will create and save the
    snapshot to a `__snapshots__` folder next to it. If you are using a versioning
    system such as git, you need to add these snapshot files to it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Updating the snapshots
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you modify a component, there is a chances that its HTML render will change
    too. This means its snapshots will no longer be valid and the Jest tests will
    fail. Fortunately, the `jest` command has a `--updateSnapshots` argument. When
    used, all the failing snapshots will be resaved and will pass.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new script in our `package.json` file:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Modify the `BaseButton` component by changing a CSS class, for example. If your
    run the Jest tests again, you should get an error that says, the snapshots don't
    match anymore.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/697b17b2-cdb2-499a-a113-e8e3ea3c7301.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'Now, update the snapshot with the new script:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'All the tests should pass now, and the `BaseButton` snapshot should be updated:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d00b9be6-1df2-480a-96e8-50533f37de7d.png)You should run this command
    only when you are sure there are no regressions elsewhere. A good idea is to run
    the tests normally just before, to make sure only the modified component snapshot
    fails, as expected. After you have updated the snapshots, use the normal test
    command.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Complementary topics
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover a few more topics that can be useful for bigger
    apps.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization and code-splitting
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the app is to be used by people in different countries, it should be translated
    to be more user-friendly and appealing. To localize the texts of the app, you
    can use the recommended `vue-i18n` package:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using `vue-i18n`, we will add a link in the `AppFooter` component to a new page
    where the user can select the language. Only the link and this page will be translated,
    but you can translate more parts of the app if you wish. `vue-i18n` works by creating
    a `i18n` object from it with the translated messages and injecting it into the
    Vue app.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/plugins.js` file, install the new plugin into Vue:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Let's create a new folder called `i18n` in the project directory. Download the
    `locales` folder ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/locales](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/locales))
    containing the translation files and put it inside. You should have, for example,
    the `en` translations in the `i18n/locales/en.js` file.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `index.js` file that exports the list of available languages:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will need two new utility functions:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '`createI18n`: To create the `i18n` object, with a `locale` parameter.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAutoLang`: That returns the two-letter language code set by the user in
    the browser, for example, `en` or `fr`. Most of the time, this will be the OS
    language setting.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `src/utils` folder, create a new `i18n.js` file and import both `VueI18n`
    and the list of available locales we defined earlier:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'At the time of writing, we need the `babel-preset-stage-2` (or less) to allow
    Babel to parse the dynamic imports. In the `package.json` file, change the `babel-preset-stage-3`
    package:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Run `npm install` to update your packages.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `.babelrc` file in the root folder and change `stage-3` to `stage-2`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to switch to stage-2, do the following installation:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Code-splitting with dynamic imports
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create the `i18n` object, we want to load only the translations of the
    selected locale via the `locale` argument. To do that, we will make a dynamic
    import of the file with the `import` function. It takes the path as the argument
    and returns a Promise, which will eventually resolve to the corresponding JavaScript
    module once it is loaded from the server.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: In webpack, this dynamic import feature is sometimes referred as 'code splitting',
    because webpack will move the asynchronous module to another compiled JavaScript
    file called a chunk.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of an asynchronous module loaded with a dynamic import:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can use variables in the imported path, as long as it has some information
    about where webpack can find the files. For example, this code will not work:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, the following one will work fine as long as the variable path is simple
    (without `../`):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, all the files with the `json` extension in the `data` folder
    will be added to the build into asynchronous chunks, because webpack can't guess
    which ones you will really use at runtime.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronously loading big JavaScript modules with dynamic imports can reduce
    the size of the initial JavaScript code sent to the browser when opening the page.
    In our app, it allows us to load only the relevant translations file instead of
    including them all in the initial JavaScript file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'If a module is already imported with a normal `import` in the main code (the
    initial chunk), it will already be loaded and will not be split into another chunk.
    In that case, you won''t have the benefits of the code-splitting feature and the
    initial file size won''t be reduced. Note that you can synchronously use other
    modules with the normal `import` keyword inside the dynamically loaded module:
    they will be put together in the chunk (if they aren''t already included in the
    initial chunk).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The `i18n` object is created with the `VueI18n` constructor from the `vue-i18n`
    package. We will pass the `locale` argument.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the `createI18n` function should look like:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, we need to take the `default` value of the module, because we
    exported the messages using `export default`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The code using `async/await` above can be written using Promises:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Automatically loading the user locale
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we can use `navigator.language` (or `userLanguage` for Internet Explorer
    compatibility) to retrieve the locale code. Then, we will check whether it is
    available in the `langs` list or if we have to use the default `en` locale.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getAutoLang` function should look like this:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Some browsers may return the code in the `en-US` format, but we only need the
    first two characters.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/main.js` file, import the two new utility functions:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, modify the `main` function:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the preferred locale using `getAutoLang`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and wait for the `i18n` object with the `createI18n` function.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the `i18n` object into the root Vue instance.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It should now look like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Don't forget the `await` keyword in front of `createI18n`, or else you will
    get the Promise instead.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now open the network pane in the browser devtools and refresh the page.
    The translations module corresponding to the selected locale will be loaded by
    webpack in a separate request. In this example screenshot, this is the `2.build.js`
    file that is asynchronously loaded:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7fc40741-5fb8-4dac-b4fe-6b1108ed649e.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: Changing Language page
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, nothing really changed in the app, so let's add the page that will
    allow us to select the language.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/router.js` file, import the `PageLocale` component:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, add the `locale` route in the `routes` array, just before the last one
    (with the `*` path):'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the `AppFooter.vue` component, add this router link to the template:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As you can see in the preceding code, we use the `$t` provided by `vue-i18n`
    to display a translated text. The argument correspond to the key in the locale
    file. You should now see the link in the app footer:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/16f6aa12-ab37-4402-b2ad-68b0ba446978.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: 'The links takes us to the language selection page, which is already fully translated
    using `vue-i18n`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ebe4ef49-49c9-4427-b65a-090b56bd23f0.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: You can look at its source code in the `components/PageLocale.vue` file.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on a locale button, the corresponding translations are loaded
    if they aren''t already. In the network pane of the browser devtools, you should
    see a request made to other chunks each time:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/be04ca4d-f80a-4f51-94fd-f3a2659730a8.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: Server-side rendering
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Server-side Rendering** (**SSR**) consists of running and rendering the app
    on the server, before sending the HTML back to the browser. This has two main
    advantages:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Better **Search Engine Optimization** (**SEO**), since the initial content of
    the application will be rendered in the page HTML. This is important since no
    search engine is indexing an asynchronous JavaScript app (for example, when you
    have a spinner).
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slower networks or devices will display contents faster--the rendered HTML doesn't
    need the JavaScript to be shown to the user.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, using SSR also brings some trade-offs:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The code need to be able to run on the server (unless it is in client-side only
    hooks such as `mounted`). Also, some libraries may not play well on the browser
    and may require special treatments.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The load will increase on the server, since it is doing more work.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development setup is a bit more complex.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So using SSR isn't always a good idea, especially if the time the first content
    is shown isn't critical (for example, an admin dashboard).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Universal App Structure
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a Universal App that runs both on the client and the server requires
    changing the architecture of the source code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: When running on the client, we are in a fresh context each time the page is
    loaded. That's why we used singletons instance of the root instance, the router,
    and the store until now. However, now we need to have a fresh context on the server
    as well--the problem is, Node.js is stateful. The solution is creating a fresh
    new root instance, router, and store for each request handled by the server.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the router. In the `src/router.js` file, wrap the router
    creation into a new exported `createRouter` function:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will do the same with the Vuex store. In the `src/store/index.js` file,
    wrap the code into a new exported `createStore` function:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s also rename the `src/main.js` file to `src/app.js`. This will be our
    universal file that creates the router, the store, and the Vue root instance.
    Change the `main` function into an exported `createApp` function, which takes
    a `context` argument and returns the app, the router, and the store:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Don't forget to change the imports for `createRouter` and `createStore`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server, we won''t select the initial locale the same way as in the client
    since we won''t have access to `window.navigator`. That''s why we are passing
    the locale in the `context` argument:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We also removed the `el` option from the root instance definition since it doesn't
    make sense on the server.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Client entry
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the browser, the code will be started in the client entry file that we will
    write now.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `src/entry-client.js` file that will be the entry point for the
    client bundle. It will get the user language, call the `createApp` function, and
    then mount the app into the page:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can now change the entry path in the `webpack.config.js` file:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can restart the `dev` script and check whether the app still works in the
    browser.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Server entry
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new `src/entry-server.js` file that will be the entry point for the
    server bundle. It will export a function that gets a `context` object from the
    HTTP server we will build later. It should return a Promise that resolves with
    the Vue app when it's ready.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'We will pass an `url` attribute to the context so that we can set the current
    route like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Similarly to the client entry, we also use the `createApp` function to create
    the root app instance, the router, and the store. `entry-server.js` should look
    like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We return a Promise because we will send the application `app` when we will
    have finished all the operations.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The `app` root instance will be send back to what we call the renderer (kind
    of like when we did Jest snapshots) using `resolve(app)`. First, we need to take
    care of preloading the Vuex store.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: State management
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When processing a request, we need to fetch the data on the relevant components
    before rendering the app. That way, the data will already be displayed when the
    HTML is loaded by the browser. For example, `PageHome.vue` fetches the store items
    and `PageStoreItem.vue` retrieves the item details and comments.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: We will add a new `asyncData` custom option to those, so we can call it on the
    server when doing SSR.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `PageHome.vue` component by adding this function that dispatches the
    `fetchItems` action of the `items` store module:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the `PageStoreItem.vue` component, we need to call the `fetchStoreItemDetails`
    action of the `item` store module, with the `id` parameter of the route passed
    by the server:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now that our components are ready, we will go back to `entry-server.js`. We
    can use the `router.getMatchedComponents()` method to get the list of components
    that matched with the current route:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can then call all the `asyncData` options of these components and wait for
    them to finish. We pass both the store and the current route to them, and when
    they have all completed, we send the Vuex store state back to the renderer with
    `context.state = store.state`. Use `Promise.all(array)` to wait for all the `asyncData`
    calls:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If an error occurs, it will reject the Promise we returned to the renderer.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Restoring the Vuex state on the client
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The store state is serialized by the server on a `__INITIAL_STATE__` variable
    in the HTML page. We can use this to set the state even before the app is mounted,
    so the components will have access to it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `entry-client.js` file and use the `store.replaceState` method before
    mounting the app:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, the store will have the data sent by the server.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Webpack configuration
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our app code is now ready. Before continuing, we need to refactor our webpack
    configuration.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: We will need a slightly different webpack configuration for the client and the
    server. It is a good idea to have a common configuration file, which is then extended
    for the client and the server. We can do this easily with the `webpack-merge`
    package that merges multiples webpack configuration objects into one.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: For the server configuration, we also need the `webpack-node-externals` package
    to prevent webpack from bundling the packages in `node_modules`--this is not necessary
    since we will run inside nodejs and not in the browser. All the corresponding
    imports will be left as `require` statements so that node will load them itself.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the packages in the dev dependencies:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Create a new `webpack` folder in the project root directory, then move and rename
    the `webpack.config.js` file to `webpack/common.js`. Some changes are needed.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `entry` option from the configuration. This will be specified in
    the specific extended configurations.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `output` option to target the correct folder and to generate better
    chunk names:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Client configuration
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next to `webpack/common.js`, create a new `client.js` file that extends the
    base configuration:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `VueSSRClientPlugin` will generate a `vue-ssr-client-manifest.json` file
    that we will give to the renderer. This way, it will know more about the client.
    Also, it will automatically inject the script tags and the critical CSS to the
    HTML.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The Critical CSS is the style of the components rendered by the server. Those
    styles will be directly injected to the page HTML so that the browser doesn't
    have to wait for the CSS to be loaded; it can display those components sooner.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The `CommonsChunkPlugin` will put the webpack runtime code into a leading chunk
    so that asynchronous chunks can be injected right after it. It also improves caching
    of the app and vendor code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Server configuration
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next to `webpack/common.js`, create a new `server.js` file that extends the
    base configuration:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, we change multiple options, such as the `target` and `output.libraryTarget`
    ones, to adapt to the node.js environment.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Using the `webpack-node-externals` package, we tell webpack to ignore the modules
    located in the `node_modules` folder (which means the dependencies). Since we
    are in nodejs and not in a browser, we don't have to bundle all the dependencies
    into the bundle, so this will improve the build times.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `VueSSRServerPlugin` to generate the server bundle file that
    will be used by the renderer. It contains the compiled server-side code and a
    lot of other informations so that the renderer can support source maps (with the
    `source-map` value of `devtool`), hot-reloading, critical CSS injection, and other
    injections in conjunction with the client manifest data.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Server-side setup
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In development, we can't use `webpack-dev-server` directly anymore with SSR.
    Instead, we will set up the express server with webpack. Download the `server.dev.js`
    file ([https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js))
    and put it in the project root directory. This file exports a `setupDevServer`
    function that we will use to run webpack and update the server.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need some packages for the development setup:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We can create virtual file systems with `memory-fs`, watch files with `chokidar`,
    and enable webpack Hot Module Replacement in an express server with the last two
    middleware.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Page template
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `index.template.html` file alongside `index.html` and copy its
    contents. Then, replace the body content with the special `<!--vue-ssr-outlet-->`
    comment:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This special comment will be replaced by the rendered markup on the server.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Express server
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the nodejs side, we will use `express` package to create our HTTP server.
    We will also need the `reify` package so that we can require files that uses the
    `import/export` syntax inside nodejs (which doesn't support it natively).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the new packages:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Download this incomplete `server.js` file ([https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js))
    and put it in the project root directory. It already creates an express server
    and configures the necessary express routes.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, we will focus on the development part.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Creating and updating the renderer
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To render our app, we will need a renderer created with the `createBundleRenderer`
    function from the `vue-server-renderer` package.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: A bundle renderer is quite different from a normal renderer. It uses a server
    bundle file (that will be generated, thanks to our new webpack configuration)
    with an optional client manifest that allows the renderer to have more information
    about the code. This enables more features such as source maps and hot-reloading.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `server.js` file, replace the `// TODO development` comment with this
    code:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Thanks to the `server.dev.js` file, we can add support of webpack hot-reloading
    to our express server. We also specify the path to the HTML page template, so
    we can reload it too when changed.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: When the setup triggers an update, we create or recreate the bundle renderer.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the Vue app
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we will need to implement the code that renders the app and send the HTML
    result back to the client.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `// TODO render` comment with this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Thanks to the `req.acceptsLanguages` method from express, we can easily select
    the preferred language of the user.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: When performing the request, the web browser will send a list of "accepted languages"
    by the user. This is generally the language set for either their browser or OS.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `renderToString` method that will call the function we exported
    in the `entry-server.js` file, wait for the returned Promise to complete and then
    render the app into an HTML string. Finally, we send the result to the client
    (unless there is an error during the render).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Running our SSR app
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now is the time to run the app. Change the `dev` script to run our express
    server instead of `webpack-dev-server`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Restart the script and refresh the app. To be sure that the SSR is working
    correctly, view the source of the page:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e6fa9edd-fa17-4311-ad62-3f77f09f2fcb.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
- en: The app is already rendered in HTML by the server.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessary fetch
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, something is wrong with our app. The server sends the Vuex store
    data alongside the HTML of the page, which means the app already has all the data
    it needs when running for the first time, except that the requests to retrieve
    the stored items of the item details and comments are still being made. You can
    see this because of the loading animation that appears when you first load or
    when you refresh one of the corresponding pages.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this is to prevent the components from fetching data if it
    is not necessary:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PageHome.vue` component, we need to fetch the items only if we don''t
    have them already:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the `PageStoreItem.vue` component, the details and comments should be fetched
    only if we don''t have the data:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We no longer have the issue now.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: To continue learn more about SSR, you can visit the official documentation at
    [https://ssr.vuejs.org/](https://ssr.vuejs.org/) or use an easy-to-use framework
    called nuxtjs ([https://nuxtjs.org/](https://nuxtjs.org/)), which abstracts a
    lot of boilerplate away from you.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Production build
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our app is working great in development. Let's say we have finished it and we
    want to deploy it to a real server.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Additional configuration
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to add some configuration for the production build of the app to ensure
    that it is optimized.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the style into CSS files
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, the style was added to the page via the JavaScript code. This is
    great in development because it allows hot-reloading with webpack. However, in
    production, it is recommended to extract it into separate CSS files.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `extract-text-webpack-plugin` package in the dev dependencies:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the `webpack/common.js` configuration file, add a new `isProd` variable:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Modify the `vue-loader` rule to enable the CSS extraction if we are in production
    and to ignore the whitespaces between HTML tags:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Add the `ExtractTextPlugin` and the `ModuleConcatenationPlugin` to the production-only
    plugins list at the bottom of the file:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`ExtractTextPlugin` will put the style into CSS files and the `ModuleConcatenationPlugin`
    will optimize the compiled JavaScript code to be faster.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Production express server
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last changes we need to make to our code is the bundle renderer creation
    in the express server.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `server.js` file, replace the `// TODO production` comment with this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We will read the HTML page template, the server bundle, and the client manifest.
    Then, we create a new bundle renderer since we won't have hot-reloading in production.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: New npm scripts
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The compiled code will be output to a `dist` directory in the project root.
    Between each build, we need to remove it so we are in a clean state. To do that
    in a cross-platform manner, we will use the `rimraf` package that can recursively
    delete files and folders.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `rimraf` package to the dev dependencies:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Add a `build` script for both the client and server bundles:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We set the `NODE_ENV` environment variable to `'production'` and run the `webpack`
    command with the corresponding webpack configuration file.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `build` script that clears the `dist` folder and runs the two
    other `build:client` and `build:server` scripts:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Add a last script called `start` that runs the express server in production
    mode:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You can now run the build; use the usual `npm run` command:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `dist` folder should now contain all the chunks generated by webpack, plus
    the server bundle and client manifest json files:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b512c29d-758b-4e57-8c09-bee33bb1f435.png)These are the files that
    need to be uploaded to your real nodejs server.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start the express server:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: You should also upload the `server.js`, `package.json`, and `package-lock.json`
    files to the real server. Don't forget to install the dependencies with `npm install`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we improved our development workflow by learning how to autoprefix
    our CSS with PostCSS, lint our code for quality with ESLint, and unit test our
    components with Jest. We went even further by adding localization with the `vue-i18n`
    package and dynamic imports, and by refactoring the project to enable server-side
    rendering while still taking advantage of the awesome webpack features such as
    hot-reloading, code-splitting, and optimizations.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we will create a simple real-time app with the Meteor fullstack
    framework and Vue.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
