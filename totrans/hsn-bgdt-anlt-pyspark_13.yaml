- en: Leveraging the Spark GraphX API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to create a graph from a data source. We
    will then carry out experiments with the Edge API and Vertex API. By the end of
    this chapter, you will know how to calculate the degree of vertex and PageRank.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a graph from a data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Vertex API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Edge API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the degree of vertex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating PageRank
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a graph from a data source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be creating a loader component that will be used to load the data, revisit
    the graph format, and load a Spark graph from file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the loader component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `graph.g` file consists of a structure of vertex to vertex. In the following
    `graph.g` file, if we align `1` to `2`, this means that there is an edge between
    vertex ID `1` and vertex ID `2`. The second line means that there''s an edge from
    vertex ID `1` to `3`, then from `2` to `3`, and finally `3` to `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will take the `graph.g` file, load it, and see how it will provide results
    in Spark. First, we need to get a resource to our `graph.g` file. We will do this
    using the `getClass.getResource()` method to get the path to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Revisiting the graph format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we have the `GraphBuilder` method, which is our own component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is our `GraphBuilder.scala` file for our `GraphBuilder` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It uses a `GraphLoader` class from the `org.apache.spark.graphx.{Graph, GraphLoader}` package
    and we are specifying the format.
  prefs: []
  type: TYPE_NORMAL
- en: The format that's specified here is `edgeListFile`. We are passing the `sc` parameter,
    which is the `SparkContext` and `path` parameter, which contains the path of where
    the file is placed. The resulting graph will be `Graph [Int, Int]`, which we will
    use as the identifier of our vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Spark from file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have the resulting graph, we can pass the `spark` and `path` parameters
    to our `GraphBuilder.loadFromFile()` method, and at this point, we''ll have a
    `graph` that is a construct graph of `Graph [Int, Int]`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To iterate and validate that our graph was properly loaded, we will use `triplets`
    from `graph`, which are a pair of vertex to vertex and also an edge between those
    vertices. We will see that the structure of the graph was loaded properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, we are asserting that we get `4` triplets (as shown earlier in
    the *Creating the loader component* section, we have four definitions from the
    `graph.g` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will start the test and see whether we are able to load our graph properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the following output. Here, we have `(2, 1)`, `(3, 1)`, `(3,1)`, `(5,1)`,
    `(1,1)`, `(2,1)`, `(1,1)`, and `(3,1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5623373e-3747-48f4-bcc0-935cffd2fed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Hence, according to the output graph, we were able to reload our graph using
    Spark.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Vertex API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will construct the graph using edge. We will learn to use
    the Vertex API and also leverage edge transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a graph using the vertex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Constructing a graph is not a trivial task; we need to supply vertices and
    edges between them. Let''s focus on the first part. The first part consists of our
    `users`, `users` is an RDD of `VertexId` and `String` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`VertexId` is of the `long` type; this is only a `type` alias for `Long`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'But since our graph sometimes has a lot of content, the `VertexId` should be
    unique and a very long number. Every vertex in our vertices'' RDD should have
    a unique `VertexId`. The custom data associated with the vertex can be any class,
    but we will go for simplicity with the `String` class. First, we are creating
    a vertex with ID `1` and string data `a`, the next with ID `2` and string data
    `b`, the next with ID `3` and string data `c`, and similarly for the data with
    ID `4` and string `d`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating a graph from only vertices will be correct but not very useful. A graph
    is the best way to find relationships between the data, which is why a graph is
    the main building block for social networks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating couple relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create couple relationships and edges between our
    vertices. Here, we''ll have a relationship that is an `Edge`. An `Edge` is a case
    class from the `org.apache.spark.graphx` package. It is a bit more involved because
    we need to specify the source vertex ID and destination vertex ID. We want to
    specify that vertex ID `1` and `2` have a relationship, so let''s make a label
    for this relationship. In the following code, we will specify vertex ID `1` and
    ID `2` as a `friend`, then we will specify vertex ID `1` and ID `3` as a `friend` as
    well. Lastly, vertex ID `2` and ID `4` will be a `wife`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, a label could be of any type—it doesn''t need to be a `String` type;
    we can type what we want and pass it. Once we have our vertices, users, and edge
    relationships, we can create a graph. We are using the `Graph` class'' `apply`
    method to construct our Spark GraphX graph. We need to pass `users`, `VertexId`,
    and `relationships`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f41c7ab7-c2ee-417c-a501-8baa146d05ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Returning `graph` is an RDD, but it''s a special RDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we go to the `Graph` class, we will see that the `Graph` class has an
    RDD of `vertices` and an RDD of `edges`, so the `Graph` class is a companion object
    for two RDDs, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ed921b5-e3c9-454d-9c28-34296efda1c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can get the underlying RDD of `vertices` and `edges` by issuing some methods.
    For example, if you want to get all the vertices, we can map all vertices and
    we will get the attribute and `VertexId`. Here, we are only interested in the
    attribute and we will convert it into uppercase, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we convert it into uppercase, we can just collect all the vertices and
    perform `toList()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that after applying the transformation to the values, our graph
    has the following vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5639e74-f504-4de7-9c38-dad03641c394.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the Edge API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will construct the graph using the Edge API. We'll also
    use the vertex, but this time we'll focus on the edge transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the graph using edge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous sections, we have edges and vertices, which is an RDD.
    As this is an RDD, we can get an edge. We have a lot of methods that are available
    on the normal RDD. We can use the `max` method, `min` method, `sum` method, and
    all other actions. We will apply the `reduce` method, so the `reduce` method will
    take two edges, we will take `e1`, `e2`, and we can perform some logic on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `e1` edge is an edge that has an attribute, destination, and a source,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70fff1b2-97e3-4840-845f-7689be653d0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the edge is chaining together two vertices, we can perform some logic
    here. For example, if the `e1` edge attribute is equal to `friend`, we want to
    lift an edge using the `filter` operation. So, the `filter` method is taking only
    one edge, and then if the edge `e1` is a `friend`, it will be perceived automatically.
    We can see that at the end we can `collect` it and perform a `toList` so that
    the API that is on Spark is available for our use. The following code will help
    us implement our logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It also has a couple of methods on the top of the standard RDD. For example,
    we can do a map edge, which will take an edge, and we can take an attribute and
    map every label to uppercase, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: On the graph, we can also perform group edges. Grouping edges is similar to
    `GROUP BY`, but only for edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following command to print line-mapping edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start our code. We can see in the output that our code has filtered
    the `wife` edge—we only perceive the `friend` edge from vertex ID `1` to ID `2`,
    and also vertex ID `1` to ID `3`, and map edges as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad57af2a-f940-43aa-8b89-ed7248c18624.png)'
  prefs: []
  type: TYPE_IMG
- en: Calculating the degree of the vertex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover the total degree, then we'll split it into two
    parts—an in-degree and an out-degree—and we will understand how this works in
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first test, let''s construct the graph that we already know about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the degrees using the `degrees` method. The `degrees` method is
    returning `VertexRDD` because `degrees` is a vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code explains that for the `4L` instance of `VertexId`, there
    is only one relationship because there is a relationship between `2L` and `4L`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, for the `2L` instance of `VertexId`, there are two, so it is between
    `1L, 2L` and `2L, 4L`. For the `1L` instance of `VertexId`, there are two, which
    are `1L, 2L` and `1L, 3L`, and for `VertexId 3L`, there is only one relationship,
    between `1L` and `3L`. This way, we can check how our graph is coupled and how
    many relationships there are. We can find out which vertex is best known by sorting
    them, so we can see that our test passed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14383131-b9a0-495e-b272-bf7b723f32bd.png)'
  prefs: []
  type: TYPE_IMG
- en: The in-degree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The in-degree tells us how many vertices come into the second vertex, but not
    the other way around. This time, we can see that for the `2L` instance of `VertexId`,
    there''s only one inbound vertex. We can see that `2L` has a relationship with `1L`,
    `3L` has a relationship with `1L` as well, and `4L` has a relationship with `1L`.
    In the following resulting dataset, there will be no data for `VertexId 1L`, because
    `1L` is the input. So, `1L` would only be a source and not a destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding characteristic of the in-degree is a very useful property. We
    use the in-degree when we are unable to find out which of our pages are very important
    because they are linked through the page, not from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running this test, we can see that it works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b833ae5d-5154-4b61-9758-359815e92eaa.png)'
  prefs: []
  type: TYPE_IMG
- en: The out-degree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The out-degree explains how many vertices are going out. This time, we'll be
    calculating the sources of our edges, relationships, and not destinations, like
    we did in the in-degree method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the out-degree, we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `outDegrees` method contains both `RDD` and `VertexRDD`, which we have collected
    to a list using the `collect` and `toList` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `VertexId 1L` should have two outbound vertices because there is a relationship
    between `1L, 2L` and `1L, 3L`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Also, `VertexId 2L` should have one outbound vertex as there is a relationship
    between `2L` and `4L` and not the other way around, as shown in the preceding
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run this test and get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/572ee639-66b1-4f94-8249-ba5853949981.png)'
  prefs: []
  type: TYPE_IMG
- en: Calculating PageRank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will load data about users and reload data about their followers.
    We will use the graph API and the structure of our data, and we will calculate
    PageRank to calculate the rank of users.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to load `edgeListFile`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a `followers.txt` file; the following screenshot shows the format of
    the file, which is similar to the file we saw in the *Creating the loader component*
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce7f1f3a-0eff-4b12-9171-bb5b3fe8a45c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that there''s a relationship between each of the vertex IDs. Hence,
    we are loading the `graph` from the `followers.txt` file and then issuing PageRank.
    We are taking `vertices` that will be needed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: PageRank will calculate the influence and relationship between our vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and reloading data about users and followers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To find out which user has which name, we need to load the `users.txt` file.
    The `users.txt` file assigns the `VertexId` with a username and its own name.
    We use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `users.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5c42ab0-8639-4371-8915-5905dbba68bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are splitting on the comma and the first group is our integer, which will
    be vertex ID, and then `fields(1)` is the name of vertex, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will `join` the `users` with `ranks`. We will `join` the `users` using
    the `VertexId` by using the `username` and `rank` of the user. Once we have that,
    we can sort everything by the `rank`, so we will take a second element of the
    tuple and it should be sorted as `sortBy ((t) =>t.2`. At the beginning of the
    file, we will have the user with the most influence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will print the following and order the `rankByUsername`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If we skip the `sortBy` method, Spark does not guarantee any ordering of elements;
    to keep the ordering, we need to issue the `sortBy` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d25a619-5388-4912-97c8-016a62cb11a9.png)'
  prefs: []
  type: TYPE_IMG
- en: When we start running this test, we can see whether the GraphX PageRank was
    able to calculate the influence of our users. We get the output that's shown in
    the preceding screenshot, where `BarackObama` was first with `1.45` influence,
    then `ladygaga` with an influence of `1.39`, `odersky` with `1.29`, `jeresig`
    with `0.99`, `matai_zaharia` with `0.70`, and at the end, `justinbieber` with
    an influence of `0.15`.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding information, we were able to calculate complex algorithms
    with a minimal amount of code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into transformations and actions, and then we learned
    about Spark's immutable design. We studied how to avoid shuffle and how to reduce
    operational expenses. Then, we looked at how to save the data in the correct format.
    We also learned how to work with the Spark key/value API, and how to test Apache
    Spark jobs. After that, we learned how to create a graph from a data source, and
    then we investigated and experimented with the edge and vertex APIs. We learned
    how to calculate the degree of the vertex. Finally, we looked at PageRank and
    how we are able to calculate it using the Spark GraphicX API.
  prefs: []
  type: TYPE_NORMAL
