- en: '*Chapter 22*: Augmented Reality in Unity'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, new technologies expand the fields of application of Unity, from gaming
    to all kinds of software, such as simulations, training, apps, and so on. In the
    latest versions of Unity, we saw lots of improvements in the field of **augmented
    reality (AR)**, which allows us to add a layer of virtuality on top of our reality,
    thereby augmenting what our device can perceive to create games that rely on real-world
    data, such as the camera's image, our real-world position, and the current weather.
    This can also be applied to work environments, such as when viewing the building
    map or checking the electrical ducts inside a wall. Welcome to the extra section
    of this book, where we are going to discuss how to create AR applications using
    Unity's AR Foundation package.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine the following AR Foundation concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Using AR Foundation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building for mobile devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple AR game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create AR apps using AR Foundation,
    and will have a fully functional game that uses its framework so that you can
    test the framework's capabilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by exploring the AR Foundation framework.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Using AR Foundation
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to AR, Unity has two main tools to create applications: Vuforia
    and AR Foundation. Vuforia is an AR framework that can work on almost any phone
    and contains all the needed features for basic AR apps, but with a paid subscription
    for more advanced features. On the other hand, the completely free AR Foundation
    framework supports the latest AR native features of our devices but is supported
    only by newer devices. Picking between one or the other depends a lot on the type
    of project you''re going to build and the target audience. However, since this
    book aims to discuss the latest Unity features, we are going to explore how to
    use AR Foundation to create our first AR app for detecting the positions of images
    and surfaces in the real world. So, we''ll start by exploring its API.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will examine the following AR Foundation concepts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AR Foundation project
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tracking features
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by discussing how to prepare our project so that it can run AR Foundation
    apps.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AR Foundation project
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something to consider when creating AR projects is that we will not only change
    the way we code our game, but also the game design aspect. AR apps have differences,
    especially in the way the user interacts, and also limitations, such as the user
    being in control of the camera all the time. We cannot simply port an existing
    game to AR without changing the very core experience of the game. That's why,
    in this chapter, we are going to work on a brand new project; it would be too
    difficult to change the game we've created so far so that it works well in AR.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we are going to create a game where the user controls a player
    moving a "marker", a physical image you can print that will allow our app to recognize
    where the player is in the real world. We will be able to move the player while
    moving that image, and this virtual player will automatically shoot at the nearest
    Enemy. Those enemies will spawn from certain spawn points that the user will need
    to place in different parts of the home. As an example, we can put two spawn points
    on the walls and place our player marker in a table in the middle of the room
    so that the enemies will go toward them. In the following image, you can see a
    preview of what the game will look like:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 22.1 – Finished game. The Cylinder is an Enemy Spawner, the Capsule
    is the Enemy, and the Cube is the Player. These are positioned in a marker image
    displayed by the cellphone'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.01_B14199.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.1 – Finished game. The Cylinder is an Enemy Spawner, the Capsule is
    the Enemy, and the Cube is the Player. These are positioned in a marker image
    displayed by the cellphone
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start creating a new URP-based project in the same manner we created
    our first game. Something to consider is that AR Foundation works with other pipelines,
    including built-in ones, in case you want to use it in already existing projects.
    If you don''t remember how to create a project, please refer to [*Chapter 2*](B14199_02_Final_SK_ePub.xhtml#_idTextAnchor040),
    *Setting Up Unity*. Once you''re in your new blank project, install the AR Foundation
    package from the Package Manager, just like we''ve installed other packages previously;
    that is, from **Window | Package Manager**. Remember to set the Package Manager
    so that it shows all packages, not only the ones in the project (the **Packages**
    button at the top-left part of the window needs to be set to **Unity Registry**).
    At the time of writing this book, the latest version is 4.0.2\. Remember you can
    use the **See other Versions** button that appears clicking the triangle at the
    left of the package under **Package Item** in the list to display other version
    options. If you find a newer version than mine, you can try using that one, but
    as usual, if something works differently to what we want, please install this
    specific version:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 22.2 – Installing AR Foundation'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.2_B14199.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.2 – Installing AR Foundation
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Before we install any other needed packages, now is a good moment to discuss
    some core ideas of the AR Foundation framework. This package, by itself, does
    nothing; it defines a series of AR features that mobile devices offer, such as
    image tracking, cloud points, and object tracking, but the actual implementation
    of how to do that is contained in the **Provider** packages, such as AR Kit and
    AR Core XR plugins. This is designed like this because, depending on the target
    device you want to work with, the way those features are implemented changes.
    As an example, in iOS, Unity implements those features using AR Kit, while in
    Android, it uses AR Core; they are platform-specific frameworks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Something to consider here is that not all iOS or Android devices support AR
    Foundation apps. You might find an updated list of supported devices when searching
    for AR Core and AR Kit supported devices on the internet. At the time of writing,
    the following links provide the supported devices lists:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'iOS: [https://www.apple.com/lae/ios/augmented-reality/](https://www.apple.com/lae/ios/augmented-reality/)
    (at the bottom of the page)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Android: [https://developers.google.com/ar/discover/supported-devices](https://developers.google.com/ar/discover/supported-devices)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, there isn''t a PC Provider package, so the only way to test AR Foundation
    apps so far is directly on the device, but testing tools are going to be released
    soon. In my case, I will be creating an app for iOS, so aside from the **AR Foundation**
    package, I need to install the **ARKit XR** plugin. However, if you want to develop
    for Android, install the **ARCore XR** plugin instead (or both if you''re targeting
    both platforms). I will be using the 4.0.2 version of the ARKit package, but at
    the moment of writing this book, the ARCore recommended version is 4.0.4 Usually,
    the versions of the **AR Foundation** and **Provider** packages match, but apply
    the same logic as when you picked the **AR Foundation** version. In the following
    screenshot, you can see the **ARKit** package in the Package Manager:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 22.3 – Installing the platform-specific AR provider package'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.3_B14199.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.3 – Installing the platform-specific AR provider package
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the needed plugins, we need to prepare a scene for AR, as
    follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Scene in **File | New Scene**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete **Main Camera**; we are going to use a different one.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **GameObject | XR** menu, create an **AR Session** Object.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same menu, create an **AR Session Origin** Object that has a **Camera**
    inside it:![Figure 22.4 – Creating the Session objects
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.04_B14199.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.4 – Creating the Session objects
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.4 - 创建会话对象
- en: 'Your hierarchy should look as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的层次结构应如下所示：
- en: '![Figure 22.5 – Starter ARSCcene'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.5 - 起始ARSCcene'
- en: '](img/Figure_22.05_B14199.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.05_B14199.jpg)'
- en: Figure 22.5 – Starter ARSCcene
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.5 - 起始ARSCcene
- en: The **AR Session** object will be responsible for initializing AR Framework
    and will handle all the update logic for the AR systems. The **AR Session Origin**
    object will allow the framework to locate tracked objects such as images and point
    clouds in a relative position to the scene. The devices inform the positions of
    tracked objects relative to what the device considers "the origin". This is usually
    the first area of your house you were pointing at when the app started detecting
    objects, so the AR Session Origin object will represent that area. Finally, you
    can check the camera inside the origin, which contains some extra components,
    with the most important being **AR Pose** **Driver**, which will make your **Camera**
    object move along with your device. Since the device's position is relative to
    the Session Origin object's point, the camera needs to be inside the origin object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR会话**对象将负责初始化AR框架，并处理AR系统的所有更新逻辑。**AR会话原点**对象将允许框架相对于场景定位跟踪对象，如图像和点云。设备会通知跟踪对象相对于设备认为的“原点”的位置。这通常是您在应用程序开始检测对象时指向的房屋的第一个区域，因此AR会话原点对象将代表该区域。最后，您可以检查原点内的相机，其中包含一些额外的组件，其中最重要的是**AR姿势驱动器**，它将使您的**相机**对象随着您的设备移动。由于设备的位置是相对于会话原点对象的点，因此相机需要在原点对象内部。'
- en: 'One extra step in case you are working in a URP project (our case) is that
    you need to set up the render pipeline so that it supports rendering the camera
    image in the app. To do that, go to the `Settings` folder that was generated when
    we created the project, look for the `Forward Renderer` file, and select it. In
    the **Renderer Features** list, click the **Add renderer feature** button and
    select **AR Background Renderer Feature**. Consider that this option might be
    unavailable if you are working on versions older than 4.0.0 of the AR Foundation
    and Provider plugins. In the following screenshot, you can see what the Forward
    Renderer asset should look like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在URP项目（我们的情况）中的一个额外步骤是，您需要设置渲染管道，以便支持在应用程序中渲染相机图像。为此，请转到创建项目时生成的`Settings`文件夹，查找`Forward
    Renderer`文件，并选择它。在**Renderer Features**列表中，单击**添加渲染器功能**按钮，然后选择**AR背景渲染器功能**。请注意，如果您使用的是早于AR
    Foundation和Provider插件4.0.0版本的版本，则此选项可能不可用。在以下截图中，您可以看到前向渲染器资产应该是什么样子的：
- en: '![Figure 22.6 – Adding support for URP'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.6 - 添加对URP的支持'
- en: '](img/Figure_22.06_B14199.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.06_B14199.jpg)'
- en: Figure 22.6 – Adding support for URP
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.6 - 添加对URP的支持
- en: And that's all! We are ready to start exploring the AR Foundation components
    so that we can implement tracking features.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们已经准备好开始探索AR Foundation组件，以便我们可以实现跟踪功能。
- en: Using tracking features
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用跟踪功能
- en: 'For our project, we are going to need two of the most common tracking features
    in AR (but not the only ones): image recognition and plane detection. The first
    one consists of detecting the position in the real world of a specific image so
    that we can place digital objects on top of it, such as the player. The second
    one, plane detection, consists of recognizing real-life surfaces, such as floors,
    tables, and walls, so that we have a reference of where we can put objects such
    as the enemies'' spawn points. Only horizontal and vertical surfaces are recognized
    (just vertical surfaces on some devices).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将需要AR中最常见的两种跟踪功能（但不是唯一的）：图像识别和平面检测。第一种是检测特定图像在现实世界中的位置，以便我们可以将数字对象放在其上，例如玩家。第二种，平面检测，是识别现实生活中的表面，如地板、桌子和墙壁，以便我们知道可以放置对象的位置，例如敌人的生成点。只有水平和垂直表面被识别（某些设备上只有垂直表面）。
- en: 'The first thing we need to do is tell our app which images it needs to detect,
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是告诉我们的应用程序它需要检测哪些图像，如下所示：
- en: Add an image to the project that you can print or display in a cellphone. Having
    a way to display the image in the real world is necessary to test this. In this
    case, I will use the following image:![Figure 22.7 – Image to track
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目添加一个图像，您可以打印或在手机上显示。有一种在现实世界中显示图像的方式是必要的来测试这一点。在这种情况下，我将使用以下图像：![图22.7 -
    要跟踪的图像
- en: '](img/Figure_22.07_B14199.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.07_B14199.jpg)'
- en: Figure 22.7 – Image to track
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.7 - 要跟踪的图像
- en: Important Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Try to get an image that contains as many features as you can. This means an
    image with lots of little details, such as contrasts, sharp corners, and so on.
    Those are what our AR systems use to detect it; the more detail, the better the
    recognition. In our case, the Unity logo we are using doesn't actually have too
    many details, but there's enough contrast (just black and white) and sharp corners
    for the system to recognize it. If your device has trouble detecting it, try other
    images (the classic QR code might help).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量获取包含尽可能多特征的图像。这意味着图像具有许多细节，如对比度、锐利的角落等。这些是我们的AR系统用来检测的；细节越多，识别就越好。在我们的情况下，我们使用的Unity标志实际上并没有太多细节，但有足够的对比度（只是黑白）和锐利的角落，以便系统识别它。如果您的设备在检测时出现问题，请尝试其他图像（经典的QR码可能会有所帮助）。
- en: Consider that some devices might have trouble with certain images, such as the
    image suggested in this book. If this generates issues when testing, please try
    using another one. You will be testing this on your device in the upcoming sections
    of this chapter, so just keep this in mind.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，某些设备可能会对某些图像（例如本书中建议的图像）产生问题。如果在测试时出现问题，请尝试使用其他图像。您将在本章的后续部分在您的设备上测试这一点，所以请记住这一点。
- en: Create a Reference Image Library, an asset containing all the images we wish
    our app to recognize, by clicking the **+** button in **Project Panel** and selecting
    **XR** | **Reference Image Library**:![Figure 22.8 – Creating a Reference Image
    Library
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.08_B14199.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.8 – Creating a Reference Image Library
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Select the library asset and click the **Add Image** button to add a new image
    to the library.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the texture to the texture slot (the one that says **None**).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Turn **Specify Size** on and set **Physical Size** to the size that your image
    will be in real life, in meters. Try to be accurate here; on some devices, not
    having this value right might result in the image not being tracked:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 22.9 – Adding an image to be recognized'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.09_B14199.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.9 – Adding an image to be recognized
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve specified the images to be detected, let''s test this by placing
    a cube on top of the real-life image:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Create a prefab of a cube and add the **AR Tracked Image** component to it.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **AR Tracked Image Manager** component to the **AR Session Origin**
    object. This will be responsible for detecting images and creating objects in
    its position.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Image Library** asset to the **Serialized Library** property of the
    component to specify the images to recognize.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the **Cube** prefab to the **Tracked Image** Prefab property of the component:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 22.10 – Setting up the Tracked Image Manager'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.10_B14199.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.10 – Setting up the Tracked Image Manager
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'And that''s all! We will see a cube spawning in the same position the image
    is located at in the real world. Remember that you need to test this in the device,
    which we will do in the next section, so for now, let''s keep coding our test
    app:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 22.11 – Cube located on top of the image being displayed by the cellphone'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.11_B14199.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.11 – Cube located on top of the image being displayed by the cellphone
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also prepare our app so that it can detect and display the plane surfaces
    the camera has recognized. This is simply done by adding the **AR Plane Manager**
    component to the **AR Session Origin** object:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 22.12 – Adding the AR Plane Manager component'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.12_B14199.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.12 – Adding the AR Plane Manager component
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'This component will detect surface planes over our house as we move the camera
    over it. It can take a while to detect them, so it''s important to visualize the
    detected areas to get feedback about this to ensure it''s working properly. We
    can manually get information about the plane from a component reference to the
    AR Plane Manager, but luckily, Unity allows us to visualize planes easily. Let''s
    take a look:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Create a prefab of a plane, first by creating the plane in **GameObject | 3D
    Object | Plane**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Line Renderer** to it. This will allow us to draw a line over the edges
    of the detected areas.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `0.01`, the **Color** property to black, and uncheck **Use World Space**:![Figure
    22.13 – Setting the Line Renderer
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.13_B14199.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.13 – Setting the Line Renderer
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Remember to create a material for **Line Renderer** with the proper shader and
    set it as the material of the renderer:![Figure 22.14 – Creating the Line Renderer
    Material
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.14_B14199.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.14 – Creating the Line Renderer Material
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Also, create a transparent material and use it in the **MeshRenderer** plane.
    We want to see through it so that we can easily see the real surface beneath:![Figure
    22.15 – Material for the detected plane
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.15_B14199.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.15 – Material for the detected plane
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Add the **AR Plane** and **AR Plane Mesh Visualizer** components to the **Plane**
    prefab.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the prefab to the **Plane Prefab** property of the **AR Plane Manager**
    component of the **AR Session Origin** object:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 22.16 – Setting the plane visualization prefab'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.16_B14199.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.16 – Setting the plane visualization prefab
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.16 – 设置平面可视化预制件
- en: Now, we have a way to see the planes, but seeing them is not the only thing
    we can do (sometimes, we don't even want them to be visible). The real power of
    planes resides on placing virtual objects on top of real-life surfaces, tapping
    in a specific plane area, and getting its real-life position. We can access the
    plane data using the AR Plane Manager or by accessing the AR Plane component of
    our visualization planes, but something easier is to use the **AR Raycast Manager**
    component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一种方法来看到平面，但看到它们并不是我们唯一能做的事情（有时，我们甚至不希望它们可见）。平面的真正力量在于将虚拟对象放置在现实表面上，点击特定平面区域，并获取其现实位置。我们可以使用AR
    Plane Manager或访问可视化平面的AR Plane组件来访问平面数据，但更简单的方法是使用**AR Raycast Manager**组件。
- en: 'The `Physics.Raycast` function of the Unity Physics system, which, as you may
    recall, is used to create imaginary rays that start from one position and go toward
    a specified direction in order to make them hit surfaces and detect the exact
    hit point. The version provided by **AR Raycast Manager**, instead of colliding
    with Physics Colliders, collides with tracked objects, mostly Point Clouds (we
    are not using them) and the "Planes" we are tracking. We can test this feature
    by following these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Unity物理系统的`Physics.Raycast`函数，您可能还记得，用于创建从一个位置开始并朝着指定方向的虚拟射线，以使它们击中表面并检测确切的击中点。由**AR
    Raycast Manager**提供的版本，与物理碰撞体不同，它与跟踪对象发生碰撞，主要是点云（我们不使用它们）和我们正在跟踪的“平面”。我们可以通过以下步骤测试这个功能：
- en: Add the **AR Raycast Manager** component to the **AR Session Origin** object.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR Raycast Manager**组件添加到**AR Session Origin**对象中。
- en: Create a custom script called `InstanceOnPlane` in the **AR Session Origin**
    object.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**AR Session Origin**对象中创建一个名为`InstanceOnPlane`的自定义脚本。
- en: In the `ARRaycastManager`. You will need to add the `using UnityEngine.XR.ARFoundation;`
    line to the top of the script for this class to be usable in our script.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ARRaycastManager`中。您需要在脚本顶部添加`using UnityEngine.XR.ARFoundation;`行，以便在我们的脚本中可用。
- en: Create a private field of the `List<ARRaycastHit>` type and instantiate it;
    the Raycast is going to detect every plane our ray hit, not just the first one:![Figure
    22.17 – List to store hits
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`List<ARRaycastHit>`类型的私有字段并实例化它；Raycast将检测我们的射线击中的每个平面，而不仅仅是第一个：![图22.17
    – 存储射线击中的列表
- en: '](img/Figure_22.17_B14199.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.17_B14199.jpg)'
- en: Figure 22.17 – List to store hits
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.17 – 存储射线击中的列表
- en: Under `KeyCode.Mouse0`) is being pressed. In AR apps, the mouse is emulated
    with the device's touch screen (you can also use the `Input.touches` array for
    multi-touch support).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`KeyCode.Mouse0`下按下。在AR应用中，鼠标是用设备的触摸屏模拟的（您还可以使用`Input.touches`数组来支持多点触控）。
- en: Inside the `if` statement, add another condition for calling the `Raycast` function
    of **AR Raycast Manager**, passing the position of the mouse as the first parameter
    and the list of hits as the second.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if`语句中，添加另一个条件来调用**AR Raycast Manager**的`Raycast`函数，将鼠标的位置作为第一个参数，将击中列表作为第二个参数。
- en: This will throw a raycast toward the direction the player touches the screen
    and store the hits inside the list we provided. This will return `true` if something
    has been hit, and `false` if not:![Figure 22.18 – Throwing AR raycasts
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将向玩家触摸屏幕的方向投射射线，并将击中的结果存储在我们提供的列表中。如果有东西被击中，它将返回`true`，否则返回`false`：![图22.18
    – 发射AR射线
- en: '](img/Figure_22.18_B14199.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.18_B14199.jpg)'
- en: Figure 22.18 – Throwing AR raycasts
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.18 – 发射AR射线
- en: Add a public field to specify the prefab to instantiate in the place we touched.
    You can just create a Sphere prefab to test this; there's no need to add any special
    component to the prefab here.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个公共字段来指定要在我们触摸的位置实例化的预制件。您可以只创建一个球体预制件来测试这个；这里不需要为预制件添加任何特殊组件。
- en: 'Instantiate the prefab in the **Position** and **Rotation** fields of the **Pose**
    property of the first hit stored in the list. The hits are sorted by distance,
    so the first hit is the closest one. Your final script should look as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中存储的第一个击中的**Pose**属性的**Position**和**Rotation**字段中实例化预制件。击中是按距离排序的，所以第一个击中是最近的。您的最终脚本应如下所示：
- en: '![Figure 22.19 – Raycaster component'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.19 – 射线投射器组件'
- en: '](img/Figure_22.19_B14199.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.19_B14199.jpg)'
- en: Figure 22.19 – Raycaster component
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.19 – 射线投射器组件
- en: In this section, we learned how to create a new AR project using AR Foundation.
    We discussed how to install and set up the framework, as well as how to detect
    real-life image positions and surfaces, and then how to place objects on top of
    them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用AR Foundation创建新的AR项目。我们讨论了如何安装和设置框架，以及如何检测现实图像的位置和表面，然后如何将对象放置在其上。
- en: As you may have noticed, we never hit play to test this, and sadly at the time
    of writing this book, we cannot test this in the Editor. Instead, we need to test
    this directly on the device. Due to this, in the next section, we are going to
    learn how to do builds for mobile devices such as Android and iOS.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，我们从未点击播放按钮来测试这个，遗憾的是，在撰写本书时，我们无法在编辑器中测试这个。相反，我们需要直接在设备上测试这个。因此，在下一节中，我们将学习如何为Android和iOS等移动设备构建。
- en: Building for mobile devices
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为移动设备构建
- en: Unity is a very powerful tool that solves the most common problems in game development
    very easily, and one of them is building the game for several target platforms.
    Now, the Unity part of building our project for such devices is easy to do, but
    each device has its non-Unity-related nuances for installing development builds.
    In order to test our AR app, we need to test it directly in the device. So, let's
    explore how we can make our app run on Android and iOS, the most common mobile
    platforms.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Unity是一个非常强大的工具，可以非常轻松地解决游戏开发中最常见的问题之一，其中之一是为多个目标平台构建游戏。现在，为这些设备构建我们的项目的Unity部分很容易，但是每个设备都有其与Unity无关的细微差别，用于安装开发构建。为了测试我们的AR应用程序，我们需要直接在设备上测试它。因此，让我们探索如何使我们的应用程序在Android和iOS上运行，这是最常见的移动平台。
- en: Before diving into this topic, it is worth mentioning that the following procedures
    change a lot over time, so you will need to find the latest instructions on the
    internet. The Unity Learn portal site ([https://learn.unity.com/tutorial/building-for-mobile](https://learn.unity.com/tutorial/building-for-mobile))
    may be a good alternative in case the instructions in this book fail, but try
    the steps here first.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will examine the following mobile building concepts:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Building for Android
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building for iOS
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by discussing how to build our app so that it runs on Android phones.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Building for Android
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating Android builds is relatively easy compared to other platforms, so
    we''ll start with Android. Remember that you will need an Android device capable
    of running AR Foundation apps, so please refer to the link regarding Android supported
    devices we mentioned in the first section of this chapter. The first thing we
    need to do is check if we have installed Unity''s Android support and configured
    our project to use that platform. To do that, follow these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Close Unity and open **Unity Hub**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Installs** section and locate the Unity version you are working
    on.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the three dots button at the top-right corner of the Unity version and
    click **Add Modules**:![Figure 22.20 – Adding modules to the Unity version
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.20_B14199.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.20 – Adding modules to the Unity version
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Make sure **Android Build Support** and the sub-options that are displayed when
    you click the arrow on its left are checked. If not, check them and click the
    **Done** button at the bottom-right to install them:![Figure 22.21 – Adding Android
    support to Unity
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.21_B14199.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.21 – Adding Android support to Unity
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Open the AR project we created in this chapter.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Build Settings** (**File | Build Settings**).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Android** platform from the list and click the **Switch Platform**
    button at the bottom-right part of the window:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 22.22 – Switching to Android builds'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.22_B14199.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.22 – Switching to Android builds
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'To build an app on Android, there are some requirements we need to meet, such
    as having the Java SDK (not the regular Java runtime) and Android SDK installed,
    but luckily, the new versions of Unity take care of that. Just to double-check
    that we have installed the needed dependencies, follow these steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Unity Preferences** (**Edit | Preferences** on Windows, **Unity | Preferences**
    on Mac).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **External Tools**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check that all the options that say …**Installed with Unity** on the Android
    section are checked. This means we will be using all the dependencies installed
    by Unity:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 22.23 – Using installed dependencies'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.23_B14199.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.23 – Using installed dependencies
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some additional Android AR Core-specific related settings to check
    that you can find at [https://developers.google.com/ar/develop/unity-arf/quickstart-android](https://developers.google.com/ar/develop/unity-arf/quickstart-android).
    These can change if you are using newer versions of AR Core. You can apply them
    by following these steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Player Settings** (**Edit | Project Settings | Player**).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck **Multithreaded Rendering** and **Auto Graphics API**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove **Vulkan** from the **Graphics APIs** list.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set **Minimum API Level** to **Android 7.0**:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 22.24 – AR Core settings'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.24_B14199.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.24 – AR Core settings
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can finally build the app from **File | Build Settings** like usual,
    by using the **Build** button. This time, the output will be a single APK file
    that you can install by copying the file to your device and opening it. Remember
    that in order to install APKs that weren't downloaded from the Play Store, you
    need to set your device to allow **Install Unknown Apps**. The location for that
    option varies a lot, depending on the Android version and the device you are using,
    but this option is usually located in the **Security** settings. Some Android
    versions prompt you to view these settings when installing the APK.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can copy and install the generated APK build file every time we want
    to create a build. However, we can let Unity do that for us using the **Build
    and Run** button. This option, after building the app, will look for the first
    Android device connected to your computer via USB and will automatically install
    the app. For this to work, we need to prepare our device and PC, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'On your device, find the build number in the **Settings** section of the device,
    whose location, again, can change depending on the device. On my device, it is
    located in the **About Phone | Software Information** section:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 22.25 – Locating the build number'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.25_B14199.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.25 – Locating the build number
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Tap it a few times until the device says you are now a programmer. This procedure
    enables the hidden developer option in the device, which you can now find in the
    settings.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the developer options and turn on **USB Debugging**, which allows your
    PC to have special permissions on your device. In this case, it allows you to
    install apps.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the USB drivers from your phone manufacturer's site onto your computer.
    For example, if you have a Samsung device, search for `Samsung USB Driver`. Also,
    if you can't find that, you can look for `Android USB Driver` to get the generic
    drivers, but that might not work if your device manufacturer has their own. On
    Mac, this step is usually not necessary.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect your device (or reconnect it if it's already connected). The option
    to **Allow USB Debugging** for your computer will appear on the device. Check
    **Always Allow** and click **OK**:![Figure 22.26 – Allowing USB debugging
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.26_B14199.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.26 – Allowing USB debugging
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Accept the **Allow Data** prompt that appears.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If these options don't appear, check that the **USB Mode** of your device is
    set to **Debugging** and not any other.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Unity, build with the **Build and Run** button.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please remember to try another image if you have trouble detecting the image
    where we instantiate the player (the Unity logo, in my case). This might vary
    a lot, according to your device's capabilities.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And that's all! Now that you have your app running on your device, let's learn
    how to do the same for the iOS platform.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Building for iOS
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developing on iOS, you will need to spend some money. You will need to
    run Xcode, a piece of software you can only run on OS X. Due to this, you'll need
    a device that can run it, such as a MacBook, a Mac mini, and so on. There may
    be ways to run OS X on PCs, but you will need to find this out and try it for
    yourself. Besides spending on a Mac and on an iOS device (iPhone, iPad, iPod,
    and so on), you'll need to pay for an Apple Developer account, which costs 99
    USD per year, even if you are not planning to release the application on the App
    Store (there may be alternatives, but, again, you will need to find them).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to create an iOS build, you should do the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Get a Mac computer.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get an iOS device.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Apple Developer account (at the time of writing this book, you can
    create one at [https://developer.apple.com/](https://developer.apple.com/)).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Xcode from the App Store onto your Mac.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if you have iOS build support in Unity Install on the Unity Hub. Please
    refer to the *Building on Android* section for more information about this step:![Figure
    22.27 – Enabling iOS build support
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Unity Hub中是否安装了iOS构建支持。有关此步骤的更多信息，请参考*在Android上构建*部分：![图22.27 - 启用iOS构建支持
- en: '](img/Figure_22.27_B14199.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.27_B14199.jpg)'
- en: Figure 22.27 – Enabling iOS build support
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.27 - 启用iOS构建支持
- en: Switch to the iOS platform under **Build Settings**, selecting iOS and clicking
    the **Switch Platform** button:![Figure 22.28 – Switching to iOS build
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建设置**下切换到iOS平台，选择iOS并点击**切换平台**按钮：![图22.28 - 切换到iOS构建
- en: '](img/Figure_22.28_B14199.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.28_B14199.jpg)'
- en: Figure 22.28 – Switching to iOS build
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.28 - 切换到iOS构建
- en: Click the **Build** button in the **Build Settings** window and wait.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**构建设置**窗口中的**构建**按钮，然后等待。
- en: 'You will notice that the result of the build process will be a folder containing
    an Xcode project. Unity cannot create the build directly, so it generates a project
    you can open with the Xcode software we mentioned previously. The step you need
    to follow to create a build with the Xcode version being used in this book (11.4.1)
    are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到构建过程的结果是一个包含Xcode项目的文件夹。Unity无法直接创建构建，因此它生成了一个项目，您可以使用我们之前提到的Xcode软件打开。在本书中使用的Xcode版本（11.4.1）创建构建的步骤如下：
- en: Double-click the `.xcproject` file inside the generated folder:![Figure 22.29
    – Xcode project file
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击生成的文件夹中的`.xcproject`文件：![图22.29 - Xcode项目文件
- en: '](img/Figure_22.29_B14199.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.29_B14199.jpg)'
- en: Figure 22.29 – Xcode project file
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.29 - Xcode项目文件
- en: Go to **Xcode | Preferences**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**Xcode | 首选项**。
- en: In the **Accounts** tab, hit the **+** button at the bottom-left part of the
    window and log in with the Apple account you registered as an Apple developer:![Figure
    22.30 – Account Settings
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**帐户**选项卡中，点击窗口左下角的**+**按钮，并使用您注册为苹果开发者的苹果帐户登录：![图22.30 - 帐户设置
- en: '](img/Figure_22.30_B14199.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.30_B14199.jpg)'
- en: Figure 22.30 – Account Settings
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.30 - 帐户设置
- en: Connect your device and select it from the top-left part of the window, which
    should now say **Generic iOS device**:![Figure 22.31 – Selecting the device
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接您的设备，并从窗口左上角选择它，现在应该显示**通用iOS设备**：![图22.31 - 选择设备
- en: '](img/Figure_22.31_B14199.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.31_B14199.jpg)'
- en: Figure 22.31 – Selecting the device
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.31 - 选择设备
- en: In the left panel, click the folder icon and then the **Unity-iPhone** settings
    to display the project settings.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中，点击文件夹图标，然后点击**Unity-iPhone**设置以显示项目设置。
- en: From the **TARGETS** list, select **Unity-iPhone** and click on the **Signing
    & Capabilities** tab.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**目标**列表中，选择**Unity-iPhone**，然后点击**签名和功能**选项卡。
- en: In the `Personal Team`:![Figure 22.32 – Selecting a team
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`个人团队`中：![图22.32 - 选择团队
- en: '](img/Figure_22.32_B14199.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.32_B14199.jpg)'
- en: Figure 22.32 – Selecting a team
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.32 - 选择团队
- en: If you see a `com.XXXX.XXXX`), and then click on **Try Again** until it is solved.
    Once you find one that works, set it in Unity (**Bundle Identifier** under **Player
    Settings**) to avoid needing to change it in every build.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果看到一个`com.XXXX.XXXX`），然后点击**重试**，直到问题解决。一旦找到一个有效的，设置在Unity中（**播放器设置**下的**包标识符**）以避免在每次构建中都需要更改它。
- en: Hit the **Play** button at the top-left part of the window and wait for the
    build to complete. You might be prompted to enter your password a couple of times
    in the process, so please do so.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口左上角的**播放**按钮，等待构建完成。在这个过程中，您可能会被提示输入密码几次，请务必这样做。
- en: When the build completes, remember to unlock the device. A prompt will ask you
    to do that. Note that the process won't continue unless you unlock the phone.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完成后，请记得解锁设备。会有提示要求您这样做。请注意，除非您解锁手机，否则流程将无法继续。
- en: After completion, you may see an error saying that the app couldn't be launched
    but that it was installed anyway. If you try to open it, it will say you need
    to trust the developer of the app, which you can do by going to the settings of
    your device.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您可能会看到一个错误，说应用无法启动，但已经安装了。如果尝试打开它，会提示您需要信任应用的开发者，您可以通过转到设备的设置来执行。
- en: From there, go to **General | Device Management** and select the first developer
    in the list.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，转到**通用 | 设备管理**，并选择列表中的第一个开发者。
- en: Click the blue **Trust …** button and then **Trust**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击蓝色的**信任...**按钮，然后**信任**。
- en: Try to open the app again.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试再次打开应用程序。
- en: Please remember to try another image if you're having trouble detecting the
    image where we instantiate the player (the Unity logo, in my case). This might
    vary a lot, depending on your device's capabilities.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在实例化播放器的图像上遇到问题，请记得尝试另一张图像（在我的情况下是Unity标志）。这可能会有很大的变化，取决于您设备的能力。
- en: In this section, we discussed how to build a Unity project that can run on iOS
    and Android, thus allowing us to create mobile apps–AR mobile apps, specifically.
    Like any build, there are methods we can follow to profile and debug, as we saw
    when we looked at PC builds, but we are not going to discuss that here. Now that
    we have created our first test project, we will convert it into a real game by
    adding some mechanics to it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何构建一个可以在iOS和Android上运行的Unity项目，从而使我们能够创建移动应用程序 - 特别是AR移动应用程序。与任何构建一样，我们可以遵循方法进行分析和调试，就像我们在查看PC构建时所看到的那样，但我们不打算在这里讨论。现在我们已经创建了我们的第一个测试项目，我们将通过向其添加一些机制将其转换为一个真正的游戏。
- en: Creating a simple AR game
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的AR游戏
- en: As we discussed previously, the idea is to create a simple game where we can
    move our player while moving a real-life image, and also put in some Enemy Spawners
    by just tapping where we want them to be, such as a wall, the floor, a table,
    and so on. Our player will automatically shoot at the nearest Enemy, and the enemies
    will shoot directly at the player, so our only task will be to move the Player
    so that they avoid bullets. We are going to implement these game mechanics using
    scripts very similar to the ones we used in this book's main project.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will develop the following AR game features:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Spawning the Player and Enemies
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the Player and Enemy behavior
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we are going to discuss how to make our Player and Enemies appear on
    the app, specifically in real-world positions, and then we will make them move
    and shoot each other to create the specified gameplay mechanics. Let's start with
    spawning.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Spawning the Player and Enemies
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the Player, since that''s the easiest one to deal with: we
    will create a prefab with the graphics we want the player to have (in my case,
    just a cube), a `Rigidbody` with `0.05`, `0.05`, `0.05`). Since the original cube
    is 1 meter in size, this means that my player will be *5x5x5* centimeters. Your
    Player prefab should look as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 22.33 – The starting "Player" prefab'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.33_B14199.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.33 – The starting "Player" prefab
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The enemies will require a little bit more work, as shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Create a prefab called `Spawner` with the graphic you want your Spawner to have
    (in my case, a cylinder) and its real-life size.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a custom script that spawns a prefab every few seconds, such as the one
    shown in the following screenshot.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice the usage of `Physics.IgnoreCollision` to prevent the Spawner
    from colliding with the `Spawner` object, getting the colliders of both objects
    and passing them to the function. You can also use the **Layer Collision Matrix**
    to prevent collisions, just like we did with this book's main project, if you
    prefer to:![Figure 22.34 – Spawner script
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.34_B14199.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.34 – Spawner script
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Create an `Enemy` prefab with the desired graphic (a Capsule, in my case) and
    a `Rigidbody` component with the **Is Kinematic** checkbox checked. This way,
    the Enemy will move but not with physics. Remember to consider the real-life size
    of the Enemy.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Prefab** property of the Spawner so that it spawns our Enemy at your
    desired time frequency:![Figure 22.35 – Configuring the Spawner
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.35_B14199.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.35 – Configuring the Spawner
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `SpawnerPlacer` custom script to the **AR Session Origin** object
    that instantiates a prefab in the place the player tapped using the AR Raycast
    system, as shown in the following screenshot:![Figure 22.36 – Placing the Spawners
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.36_B14199.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.36 – Placing the Spawners
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Set the prefab of `SpawnerPlacer` so that it spawns the **Spawner** prefab we
    created earlier.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And that's all for the first part. If you test the game now, you will be able
    to tap on the detected planes in the app and see how the Spawner starts creating
    enemies. You can also look at the target image and see our Cube Player appear.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the objects in the scene, let's make them do something more
    interesting, starting with the Enemies.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Player and Enemy behavior
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Enemy must move toward the player in order to shoot at them, so it will
    need to have access to the player position. Since the Enemy is instantiated, we
    cannot drag the Player reference to the prefab. However, the Player has also been
    instantiated, so we can add a `PlayerManager` script to the player that uses the
    Singleton pattern (as we did with managers). To do that, follow these steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Create a `PlayerManager` script similar to the one shown in the following screenshot
    and add it to the Player:![Figure 22.37 – Creating the PlayerManager script
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.37_B14199.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.37 – Creating the PlayerManager script
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Enemy has a reference to the player, let's make them look at the
    player by adding a `LookAtPlayer` script, as shown here:![Figure 22.38 – Creating
    the LookAtPlayer script
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.38_B14199.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.38 – Creating the LookAtPlayer script
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, add a simple `MoveForward` script like the one shown in the following
    screenshot to make the `LookAtPlayer` script is making the Enemy face the Player,
    this script moving along the z axis is just enough:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 22.39 – Creating the MoveForward script'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.39_B14199.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.39 – Creating the MoveForward script
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will take care of the Player movement. Remember that our player is
    controlled through moving the image, so here, we are actually referring to the
    rotation, since the player will need to automatically look and shoot at the nearest
    Enemy. To do this, follow these steps:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Create an `Enemy` script and add it to the **Enemy** prefab.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `EnemyManager` script like the one shown in the following screenshot
    and add it to an empty `EnemyManager` object in the scene:![Figure 22.40 – Creating
    the EnemyManager script
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.40_B14199.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.40 – Creating the EnemyManager script
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In the `Enemy` script, make sure to register the object in the `EnemyManager`,
    as we did previously with `WavesManager` in this book's main project:![Figure
    22.41 – Creating the Enemy script
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.41_B14199.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.41 – Creating the Enemy script
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Create a `LookAtNearestEnemy` script like the one shown in the following screenshot
    and add it to the **Player** prefab to make it look at the nearest Enemy:![Figure
    22.42 – Looking at the nearest Enemy
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.42_B14199.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.42 – Looking at the nearest Enemy
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our objects are rotating and moving as expected, the only thing missing
    is shooting and damaging:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Life` script like the one shown in the following screenshot and add
    it to both the `Life` instead of needing to check if the life has reached zero
    every frame. We have created a `Damage` function to check that damage is dealt
    (the `Damage` function is executed), but the other version of this book's project
    also works:![Figure 22.43 – Creating a Life component
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.43_B14199.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.43 – Creating a Life component
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Bullet` prefab with the desired graphics, the collider with the `Rigidbody`
    component with **Is Kinematic** checked (a Kinematic Trigger Collider), and the
    proper real-life size.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `MoveForward` script to the **Bullet** prefab to make it move. Remember
    to set the speed.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Spawner` script to both the **Player** and the **Enemy** components and
    set the **Bullet** prefab as the prefab to spawn, as well as the desired spawn
    frequency.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Damager` script like the one shown in the following screenshot to the
    **Bullet** prefab to make bullets inflict damage on the objects it touches. Remember
    to set the damage:![Figure 22.44 – Creating a Damager script – part 1
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_22.44_B14199.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.44 – Creating a Damager script – part 1
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an `AutoDestroy` script like the one shown in the following screenshot
    to the `Destroy` time:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 22.45 – Creating a Damager script – part 2'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_22.45_B14199.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Figure 22.45 – Creating a Damager script – part 2
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: And that's all! As you can see, we basically created a new game using almost
    the same scripts we used in the main game, mostly because we designed them to
    be generic (and the game genres are almost the same). Of course, this project
    can be improved a lot, but we have a nice base project upon which to create amazing
    AR apps.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the AR Foundation Unity framework, explored how
    to set it up, and how to implement several tracking features so that we can position
    virtual objects on top of real-life objects. We also discussed how to build our
    project so that it can run on both iOS and Android platforms, which is the only
    way we can test our AR apps at the time of writing. Finally, we created a simple
    AR game based on the game we created in the main project but modified it so that
    it's suitable for use in AR scenarios.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了AR Foundation Unity框架，探讨了如何设置它，以及如何实现几个跟踪功能，以便我们可以将虚拟对象放置在现实对象之上。我们还讨论了如何构建我们的项目，使其可以在iOS和Android平台上运行，这是我们在撰写时测试我们的AR应用程序的唯一方法。最后，我们创建了一个简单的AR游戏，基于我们在主项目中创建的游戏，但修改了它，使其适用于AR场景的使用。
- en: With this new knowledge, you will be able to start your path as an AR app developer,
    creating apps that augment real objects with virtual objects by detecting the
    positions of the real objects. This can be applied to games, training apps, and
    simulations. You may even be able to find new fields of usage, so take advantage
    of this new technology and its new possibilities!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些新知识，您将能够开始作为AR应用程序开发人员的道路，通过检测真实对象的位置，创建可以用虚拟对象增强真实对象的应用程序。这可以应用于游戏、培训应用程序和模拟。您甚至可能能够找到新的使用领域，因此利用这项新技术及其新的可能性！
