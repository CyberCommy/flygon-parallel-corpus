- en: Chapter 4. Transforming, Filtering, and Accumulating Your Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the means for creating `Observable` instances from a wide variety
    of source data, it's time to build programming logic around these instances. We
    will present the basic reactive operators that we'll use to achieve step-by-step
    computations (the reactive way of handling data).
  prefs: []
  type: TYPE_NORMAL
- en: We will begin with transformations, using the famous `flatMap()` and `map()`
    operators, as well as some more less common transforming operators. After that
    we'll learn how to filter our data, using the `filter()` operator, skipping elements,
    receiving only elements at a given position in time. The chapter will also cover
    accumulating data with the `scan` operator. Most of these operators will be presented
    using *marble diagrams*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to marble diagrams and transformations with mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering your data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accumulating values using the `scan` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observable transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've used the `map()` operator in some of the previous examples. The **higher
    order functions** which transform the incoming values into something else are
    called **transformations**. The higher order functions that can be invoked on
    an `Observable` instance, producing a new `Observable` instance from it, are called
    operators. The **transforming operators** transform the elements emitted from
    the source `Observable` instance in some way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand how the different operators work, we will be using pictures
    called **marble diagrams**. For example, this one describes the `map` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Observable transformations](img/4305_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The rectangle in the center of the diagram represents the operator (function).
    It transforms its input (circles) into something else (triangles). The arrow above
    the rectangle represents the source `Observable` instance, the colored circles
    on it represent `OnNext` *notifications* emitted in time, and the vertical line
    at the end is the `OnCompleted` *notification*. The arrow below the rectangle
    is the output of the `Observable` instance with its transformed elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `map()` operator does exactly this: it transforms every ''*next*''
    value from the source to something else, defined via the function passed to it.
    Here is a little example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first `map()` operator transforms every number emitted from the source to
    itself, multiplied by three. The second `map()` operator transforms every multiplied
    number to a string. The string is '`even`' if the number is even and '`odd`' otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `map()` operator, we can transform each emitted value into a new value.
    There are more powerful transforming operators that look similar to the `map()`
    operator, but have their own usage and purpose. Let's look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Transformations with the various flatMap operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `flatMap` operator is just like the `map()` operator, but with two differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of receiving a function that transforms a value into an arbitrary type
    of value, the `flatMap` operator's argument always transforms a value or sequence
    of values into the form of an `Observable` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It merges the values emitted by those resulting `Observable` instances. This
    means that instead of emitting the `Observable` instances as values it emits their
    notifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the marble diagram for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations with the various flatMap operators](img/4305_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, each value from the source `Observable` instance is turned into
    an `Observable` instance, and in the end, all the values of these *derivative
    Observables* are emitted by the resulting `Observable` instance. Note that the
    resulting `Observable` instance may emit the values of the derivative `Observable`
    instances in an interleaved fashion and even out of order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flatMap` operator is very useful for forking logic. For example, if an
    `Observable` instance represents a file system folder and emits files from it,
    we can turn each file object into an `Observable` instance using the `flatMap`
    operator and apply some operations to these *file observables*. The result will
    be a summary of these operations. Here is an example of reading some files from
    a folder and dumping them into the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This piece of code introduces two methods for working with folders and files.
    We will take a short look at them and how we''ve used them in this `flatMap` example:'
  prefs: []
  type: TYPE_NORMAL
- en: The first method, `listFolder()`, takes a folder in the form of a `Path` variable
    and a `glob` expression. It returns an `Observable` instance representing this
    folder. This `Observable` instance emits all the files in the folder, complying
    the `glob` expression as `Path` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method is implemented using both the `Observable.create()` and `Observable.from()`
    operators. The main idea of this implementation is that if an exception occurs,
    it should be handled and emitted by the resulting `Observable` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of the `Subscriber.add()` operator to add a new `Subscription`
    instance to the subscriber, created using the `Subscriptions.create()` operator.
    This method creates a `Subscription` instance using an action. This action will
    be executed when the `Subscription` instance is *unsubscribed*, which means when
    the `Subscriber` instance is *unsubscribed* in this case. So this is similar to
    putting the closing of the `stream` in the final block.
  prefs: []
  type: TYPE_NORMAL
- en: The other method this example introduces is `Observable<String> from(Path)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It reads a file located and passed to the `path` instance line by line and emits
    the lines as `OnNext()` *notifications*. The method uses the `Subscriber.add()`
    operator on a `Subscription` instance for closing the `stream` to the file.
  prefs: []
  type: TYPE_NORMAL
- en: The example using `flatMap` creates an `Observable` instance from a folder,
    using the `listFolder()` operator, which emits two `Path` parameters to files.
    Using the `flatMap()` operator for every file, we create an `Observable` instance,
    using the `from(Path)` operator, which emits the file content as lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of the preceding chain will be the two file contents, printed on
    the standard output. If we used the `Scheduler` instances (see [Chapter 6](ch06.html
    "Chapter 6. Using Concurrency and Parallelism with Schedulers"), *Using Concurrency
    and Parallelism with Schedulers*) for every *file path Observable*, the content
    would be *scrambled* because the `flatMap` operator interleaves the notifications
    of the `Observable` instances that it merges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code introducing the `Observable<String> from(final Path path)` method
    can be found at [https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L61](https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L61).
  prefs: []
  type: TYPE_NORMAL
- en: The source code containing the `Observable<Path> listFolder(Path dir, String
    glob)` method can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L128](https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L128).
  prefs: []
  type: TYPE_NORMAL
- en: The example using the `flatMap` operator can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FlatMapAndFiles.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FlatMapAndFiles.java).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flatMap` operator has multiple overloads. For example, there is one that
    takes three functions—one for `OnNext`, one for `OnError`, and one for `OnComleted`.
    It transforms *errors* or *completed* events into `Observable` instances too,
    and if there is an `OnError` or `OnCompleted` event, their `Observable` instance
    transformation is merged in the resulting `Observable` instance, followed by an
    `OnCompleted` *notification*. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output of that will be `-2(2/-1)` and `0` (because of the error raised by
    `2/0`). Because of the *error*, `1` won't be emitted and won't reach the `flatMap`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting overload is `Observable<R> flatMap(Func1<T, Observable<U>>,
    Func2<T, U, R>)`. Here is its marble diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations with the various flatMap operators](img/4305_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This one combines items from the source `Observable` instance with the `Observable`
    instance triggered by those source items and calls a user-supplied function with
    the pair of the original and derived items. The `Observable` instance will then
    emit the result of this function. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the first element emitted by the source `Observable` instance
    is `5`, the `flatMap` operator turns it into an `Observable` instance using the
    `range()` operator, which emits `5` and `6`. But this `flatMap` operator doesn''t
    stop here; for every item emitted by this range `Observable` instance, it applies
    the second function with first parameter—the original item (`5`) and second parameter—the
    range-emitted item. So we have *5 + 5* and then *5 + 6*. The same is applied for
    the second item emitted by the source `Observable` instance: `432`. It is turned
    to *432 + 432 = 864* and *432 + 433 = 865*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This overload is useful when all of the derivative items need to have access
    to their source item and usually saves us from using some kind of **tuple** or
    **pair** classes, saving on memory and library dependencies. In the earlier example
    with files, we could prepend the name of the file to each of the outputted lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The operator `flatMapIterable` doesn''t take as parameter lambda that takes
    arbitrary value as a parameter and returns an `Observable` instance. Instead the
    lambda passed to it takes arbitrary value and returns an `Iterable` instance.
    All of these `Iterable` instances are flattened to values emitted by the resulting
    `Observable` instance. Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This simple example merges the two lists emitted by the source `Observable`
    instance, and the result emits the four items. It is worth mentioning that invoking
    `flatMapIterable(list -> list)` is the same as invoking `flatMap(l → Observable.from(l))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another form of the `flatMap` operator is the `concatMap` operator. It behaves
    just like the original `flatMap` operator, except that it concatenates rather
    than merges the resulting `Observable` instance in order to generate its own sequence.
    The following marble diagram shows how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations with the various flatMap operators](img/4305_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The items from the different *derivative Observables* are not interleaved, as
    with the `flatMap` operator. A significant difference between the `flatMap` and
    `concatMap` operators is that the `flatMap` operator uses the inner `Observable`
    instances in parallel, whereas the `concatMap` operator only subscribes to one
    of the `Observable` instances at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last operator similar to `flatMap` is `switchMap`. Its marble diagram looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations with the various flatMap operators](img/4305_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It operates in similar fashion to the `flatMap` operator, except that whenever
    a new item is emitted by the source `Observable` instance, it stops mirroring
    the `Observable` instance generated from the previously emitted item and it begins
    mirroring only the current `Observable` instance. In other words, it internally
    unsubscribes from the current *derivative* `Observable` instance when the next
    one begins emitting its items. Here is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The source `Observable` instance is using the `Observable.interval()` operator
    to emit sequential numbers (beginning with zero) every 40 milliseconds. Using
    the `switchMap` operator, a new `Observable` instance emitting another sequence
    of numbers is created for every number. This secondary sequence of numbers begins
    from the source number that was passed to the `switchMap` operator (that's implemented
    by summing the source number with every emitted number, using the `map()` operator).
    So, every 40 milliseconds, a new sequence of numbers is being emitted (each number
    at 10-millisecond intervals).
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for all the mapping examples can be downloaded/viewed at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/MappingExamples.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/MappingExamples.java).
  prefs: []
  type: TYPE_NORMAL
- en: Grouping items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Items can be grouped by specific property or key.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll look at the `groupBy()` operator, a method that divides a source
    `Observable` instance into multiple `Observable` instances. Each of these `Observable`
    instances emits some of the source's items depending on a grouping function.
  prefs: []
  type: TYPE_NORMAL
- en: The `groupBy()` operator returns an `Observable` instance that emits `Observable`
    instances. These `Observable` instances are special; they are of type `GroupedObservable`,
    and you can retrieve their grouping keys using the `getKey()` method. Once the
    `groupBy()` operator is used, the different groups can be handled in a different
    or a common way.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when the `groupBy()` operator creates an observable that emits the
    `GroupedObservables` instances, each of them buffers its items. So, if we ignore
    any of them, this buffer will present a potential memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'The marble diagram of the `groupBy()` operator looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grouping items](img/4305_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the form of the items is used as the common trait of the grouping. For
    a better understanding of the idea of the method, we can look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The example emits some of Pink Floyd''s album titles and groups them by the
    number of words contained in them. For example `Meddle` and `More` are in the
    same group with key `1`, and `A Saucerful of Secrets` and `Wish You Were Here`
    are both in a group with the key of `4`. All these groups are presented by the
    `GroupedObservable` instances, so we can subscribe to them in the `subscribe()`
    call of the source `Observable` instance. The different groups are printed with
    different labels, depending on their keys. The output of this little program is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The order the items are emitted in is the same, but they are emitted by different
    `GroupedObservable` instances. Also, all the `GroupedObservable` instances are
    completed after the source completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `groupBy()` operator has another overload that takes a second, transforming
    function that transforms each of the items in a group in some way. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The album titles are grouped by the number of the occurrences of the letter
    `m` in them. The text is transformed in a way that all the occurrences of the
    letter are replaced with `*`. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code demonstrating use of the `Observable.groupBy()` operator can
    be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/UsingGroupBy.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/UsingGroupBy.java).
  prefs: []
  type: TYPE_NORMAL
- en: Additional useful transformation operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few additional *transformations* worth mentioning. For example,
    there is the `cast()` operator, which is a shortcut for the `map(v -> someClass.cast(v))`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The initial `Observable` instance here emits values of type `Number`, but they
    are actually `Integer` instances, so we can use the `cast()` operator to represent
    them as `Integer` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another helpful operator is the `timestamp()` operator. It adds a *timestamp*
    to each emitted value by transforming it into an instance of the `Timestamped<T>`
    class. This is helpful if, for example, we want to log the output of an `Observable`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, each number is being timestamped. Again, that can be implemented
    using the `map()` operator very easily. The output of the preceding example looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar operator is the `timeInterval` operator, but it transforms a value
    to an instance of the `TimeInterval<T>` operator instead. A `TimeInterval<T>`
    instance represents an item emitted by an `Observable` along with the amount of
    time that elapsed either since the emission of the previous item, or (if there
    was no previous item) since the subscription. This can be used for generating
    statistics, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the different values are emitted roughly at 150 milliseconds,
    as they should be.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `timeInterval` and `timestamp` operators work on the *immediate* scheduler
    (see [Chapter 6](ch06.html "Chapter 6. Using Concurrency and Parallelism with
    Schedulers"), *Using Concurrency and Parallelism with Schedulers*), and both of
    them keep their time information in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for the preceding examples can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java).
  prefs: []
  type: TYPE_NORMAL
- en: Filtering data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first chapter''s reactive sum example, we were filtering the user input,
    based on a special pattern. The pattern was, for example, *a: <number>*. It is
    common to filter only interesting bits of data from the data stream. For example,
    it''s useful to filter out *<enter>* key-down events only from all key-down events,
    or only lines containing a given expression from a file. That''s why it is important
    to not only be able to transform our data but also to learn how to filter it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many filtering operators in RxJava. The most important of these operators
    is `filter()`. Its marble diagram is very simple and is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering data](img/4305_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It shows that the `filter()` operator filters the data by some property. In
    the diagram, it''s the form of the elements: it filters only circles. Like all
    the other operators, `filter()` creates a new `Observable` instance from the source.
    This `Observable` instance emits only items that comply to the condition, defined
    by the `filter()` operator. The following piece of code illustrates that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will output only *even* numbers (`32`, `8`, and `98`), because of the filtering
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filter()` operator filters elements based on a user-defined function.
    There are quite a few additional filtering operators. In order to understand them,
    let''s look at some simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We define three `Observable` instances to use in our examples. The first one
    emits nine numbers. The second one emits all the words from a sentence, one by
    one. The third one emits elements of different types—strings, integers, doubles,
    and longs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `takeLast()` operator returns a new `Observable` instance that emits only
    the last *n* items from the source `Observable` instance, only when it completes.
    This method has a few overloads. For example, there is one that emits the last
    *N* or less items from the source, emitted in a specified time window. Another
    one can receive a `Scheduler` instance in order to be executed on another thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, only the last four items of the `Observable` instance will
    be filtered and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Observable` instance created by the `last()` operator, which outputs only
    the *last item* emitted by the source `Observable` instance when it completes.
    If the source doesn''t emit an item, a `NoSuchElementException` exception will
    be emitted as an `OnError()` *notification*. It has an overload that receives
    a predicate parameter of type `T->Boolean`. As a result, it emits only the last
    item emitted by the source, complying to the condition defined by the predicate.
    In this example, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `takeLastBuffer()` method behaves much like the `takeLast()` method, but
    the `Observable` instance created by it emits only one item—a `List` instance
    containing the last *N* items from the source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It has analogical overloads to the `takeLast()` method''s. The output here
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lastOrDefault()` operator behaves like and has the same overload with
    a predicate as the `last()` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the source doesn''t emit anything, the `lastOrDefault()` operator
    emits the default value instead of the `OnError` *notification*. The output of
    this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `skipLast()` operator is the exact opposite of the `takeLast()` method;
    it emits everything except the last *N* items from the source when it completes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It has similar overloads. The output of this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `skip()` method is the same as the `skipLast()` method but skips the first
    *N* items instead of the last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the output of the example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `take()` operator is similar to the `takeLast()` operator, but instead of
    the last *N* items of the source, it emits the first *N* items.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a commonly-used operator, cheaper than the `takeLast()` operator, because
    the `takeLast()` operator buffers its items and waits for the source to complete.
    This operator doesn''t buffer its items but emits them when it receives them.
    It is very useful for limiting infinite `Observable` instances. The output of
    the preceding example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `first()` operator is similar to the `last()` operator but emits only the
    first item emitted by the source. It emits the same `OnError` *notification* if
    there is no first item. Its predicate form has an alias— the `takeFirst()` operator.
    There is also a `firstOrDefault()` operator form of this operator. The output
    of this example is clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `elementAt()` operator is similar to the `first()` and `last()` operators
    but has no predicate form. There is an `elementAtOrDefault()` form though. It
    emits only the element at the specified index in the sequence of items, emitted
    by the source `Observable` instance. This example outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Observable` instance produced by the `distinct()` operator emits the items
    from the source, excluding the repeated ones. There is an overload that can receive
    a function, returning a key or hash code value to be used to decide whether an
    item is distinct from another or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `distinctUntilChanged()` operator is similar to the `distinct()` method,
    but the `Observable` instance that it returns emits all items emitted by the source
    `Observable` instance that are distinct from their immediate predecessors. So,
    in this example, it will emit every word, except the last one, `crew`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ofType()` operator creates an `Observable` instance that emits only the
    items emitted by the source of a given type. It basically is a shortcut to this
    call: `filter(v -> Class.isInstance(v))`. In this example the output will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for all of these examples can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FilteringExamples.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FilteringExamples.java).
  prefs: []
  type: TYPE_NORMAL
- en: These are the most commonly used *filtering* operators provided by RxJava. We'll
    be using some of them a lot in later examples.
  prefs: []
  type: TYPE_NORMAL
- en: The `last` operator we'll look at in this chapter is a transformational one,
    but a bit special. It can use previously accumulated states! Let's learn more
    about it.
  prefs: []
  type: TYPE_NORMAL
- en: Accumulating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `scan(Func2)` operator takes a function with two arguments as a parameter.
    Its result is an `Observable` instance. The first item, emitted by the result
    of the `scan()` method, is the first item of the source `Observable` instance.
    The second item emitted is created by applying the function that was passed to
    the `scan()` method on the previous item emitted by the result `Observable` instance
    and the second item, emitted by the source `Observable` instance. The third item,
    emitted by the `scan()` method result, is created by applying the function, passed
    to the `scan()` method to the previous item, emitted by it and the third item
    emitted by the source `Observable` instance. This pattern continues in order to
    create the rest of the sequence emitted by the `Observable` instance creates by
    the `scan()` method. The function passed to the `scan()` method is called an **accumulator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the marble diagram of the `scan(Func2)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accumulating data](img/4305_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The items emitted by the `scan()` method can be generated using an accumulated
    state. In the diagram, the circle is accumulated in the triangle, and then this
    triangle-circle is accumulated in the square.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can emit the sums of a sequence of integers, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The first *subscription* will output all the emissions : *1, 3 (1+2), 6 (3
    + 3), 10 (6 + 4) .. 55*. But in most cases, we are interested only in the last
    emitted item—the final sum. We can use an `Observable` instance that emits only
    the last element, using the `last()` filtering operator. It''s worth mentioning
    that there is a `reduce(Func2)` operator, an alias for the `scan(Func2).last()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `scan()` operator has one overload which can be used with a *seed/initial*
    parameter. In this case, the function passed to the `scan(T, Func2)` operator
    is applied to the first item emitted by the source and this *seed* parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This example counts the number of lines in a file. The file `Observable` instance
    emits the lines of the file specified by the given path, one-by-one. We use the
    `scan(T, Func2)` operator with a *seed* value of `0` to count the lines by adding
    one to the accumulated count on every line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will conclude this chapter with an example using many of the operators introduced
    in it, together. Let''s look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code uses lots of operators to filter out and assemble a sentence
    hidden in a file. The file is represented by an `Observable` instance, which emits
    all the lines contained in it one by one.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to operate only on the different lines; we want to emit all the
    sentences contained in the file. So, we use the `flatMap` operator to create an
    `Observable` instance which emits the file sentences by sentence (determined by
    `dot`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We trim these sentences using the `map()` operator. It is possible for them
    to contain some leading or trailing spaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to operate on the different words contained in our sentence items, so
    we turn them into arrays of words, using the `map()` operator and the `String::split`
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't care about empty sentences (if there are any), so we filter them out
    using the `filter()` operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need only the first words from the sentences, so we use the `map()` operator
    to get them. The resulting `Observable` instance emits the first word of every
    sentence contained in the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't need duplicated words, so we use the `distinct()` operator to get rid
    of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we want to branch our logic in a way that some of the words are treated
    differently. So we use the `groupBy()` operator and a `Boolean` key to divide
    our words into two `Observable` instances. The key is `True` for the chosen words
    and `False` for all the others.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `flatMap` operator, we join our separated words, but only the chosen
    ones (with a key of `True`) are left unchanged. The rest are *decapitalized*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We trim all the different words from leading/trailing spaces, using the `map()`
    operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `filter()` operator to filter out the empty ones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `scan()` operator, we concatenate the words with spaces as separators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `last()` operator, our resulting `Observable` instance will emit only
    the last concatenation, containing all the words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One last call to the `map()` operator creates a sentence from our concatenated
    words by adding a dot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we output the single item emitted by this `Observable` instance, we'll get
    a sentence composed of the first words of all the sentences contained in the initial
    file (skipping duplicated words)!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding example can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example concluding the chapter demonstrates what we've learned so far. We
    can write complex logic by chaining the `Observable` instances using a variety
    of operators. We can transform incoming data using the `map()` or `flatMap()`
    operators and can branch logic by using the `groupBy()` or `filter()` operators
    or the different `flatMap()` operators. We can join these branches again with
    the `flatMap()` operators. We can select parts of the data with the help of different
    filters and accumulate it with the `scan()` operator. Using all of these operators,
    we can write pretty decent programs in a readable and simple way. The complexity
    of the program doesn't affect the complexity of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to learn how to combine the branches of our logic in a more
    straightforward fashion. We'll learn how to combine data coming from different
    sources too. So let's proceed with the next chapter!
  prefs: []
  type: TYPE_NORMAL
