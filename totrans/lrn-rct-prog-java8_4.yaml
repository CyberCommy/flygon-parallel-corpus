- en: Chapter 4. Transforming, Filtering, and Accumulating Your Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the means for creating `Observable` instances from a wide variety
    of source data, it's time to build programming logic around these instances. We
    will present the basic reactive operators that we'll use to achieve step-by-step
    computations (the reactive way of handling data).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We will begin with transformations, using the famous `flatMap()` and `map()`
    operators, as well as some more less common transforming operators. After that
    we'll learn how to filter our data, using the `filter()` operator, skipping elements,
    receiving only elements at a given position in time. The chapter will also cover
    accumulating data with the `scan` operator. Most of these operators will be presented
    using *marble diagrams*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to marble diagrams and transformations with mapping
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering your data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accumulating values using the `scan` operator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observable transformations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've used the `map()` operator in some of the previous examples. The **higher
    order functions** which transform the incoming values into something else are
    called **transformations**. The higher order functions that can be invoked on
    an `Observable` instance, producing a new `Observable` instance from it, are called
    operators. The **transforming operators** transform the elements emitted from
    the source `Observable` instance in some way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand how the different operators work, we will be using pictures
    called **marble diagrams**. For example, this one describes the `map` operator:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![Observable transformations](img/4305_04_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: The rectangle in the center of the diagram represents the operator (function).
    It transforms its input (circles) into something else (triangles). The arrow above
    the rectangle represents the source `Observable` instance, the colored circles
    on it represent `OnNext` *notifications* emitted in time, and the vertical line
    at the end is the `OnCompleted` *notification*. The arrow below the rectangle
    is the output of the `Observable` instance with its transformed elements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `map()` operator does exactly this: it transforms every ''*next*''
    value from the source to something else, defined via the function passed to it.
    Here is a little example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first `map()` operator transforms every number emitted from the source to
    itself, multiplied by three. The second `map()` operator transforms every multiplied
    number to a string. The string is '`even`' if the number is even and '`odd`' otherwise.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Using the `map()` operator, we can transform each emitted value into a new value.
    There are more powerful transforming operators that look similar to the `map()`
    operator, but have their own usage and purpose. Let's look at them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Transformations with the various flatMap operators
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `flatMap` operator is just like the `map()` operator, but with two differences:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Instead of receiving a function that transforms a value into an arbitrary type
    of value, the `flatMap` operator's argument always transforms a value or sequence
    of values into the form of an `Observable` instance.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It merges the values emitted by those resulting `Observable` instances. This
    means that instead of emitting the `Observable` instances as values it emits their
    notifications.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the marble diagram for it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations with the various flatMap operators](img/4305_04_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: As we can see, each value from the source `Observable` instance is turned into
    an `Observable` instance, and in the end, all the values of these *derivative
    Observables* are emitted by the resulting `Observable` instance. Note that the
    resulting `Observable` instance may emit the values of the derivative `Observable`
    instances in an interleaved fashion and even out of order.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flatMap` operator is very useful for forking logic. For example, if an
    `Observable` instance represents a file system folder and emits files from it,
    we can turn each file object into an `Observable` instance using the `flatMap`
    operator and apply some operations to these *file observables*. The result will
    be a summary of these operations. Here is an example of reading some files from
    a folder and dumping them into the standard output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This piece of code introduces two methods for working with folders and files.
    We will take a short look at them and how we''ve used them in this `flatMap` example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The first method, `listFolder()`, takes a folder in the form of a `Path` variable
    and a `glob` expression. It returns an `Observable` instance representing this
    folder. This `Observable` instance emits all the files in the folder, complying
    the `glob` expression as `Path` objects.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method is implemented using both the `Observable.create()` and `Observable.from()`
    operators. The main idea of this implementation is that if an exception occurs,
    it should be handled and emitted by the resulting `Observable` instance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of the `Subscriber.add()` operator to add a new `Subscription`
    instance to the subscriber, created using the `Subscriptions.create()` operator.
    This method creates a `Subscription` instance using an action. This action will
    be executed when the `Subscription` instance is *unsubscribed*, which means when
    the `Subscriber` instance is *unsubscribed* in this case. So this is similar to
    putting the closing of the `stream` in the final block.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The other method this example introduces is `Observable<String> from(Path)`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It reads a file located and passed to the `path` instance line by line and emits
    the lines as `OnNext()` *notifications*. The method uses the `Subscriber.add()`
    operator on a `Subscription` instance for closing the `stream` to the file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The example using `flatMap` creates an `Observable` instance from a folder,
    using the `listFolder()` operator, which emits two `Path` parameters to files.
    Using the `flatMap()` operator for every file, we create an `Observable` instance,
    using the `from(Path)` operator, which emits the file content as lines.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of the preceding chain will be the two file contents, printed on
    the standard output. If we used the `Scheduler` instances (see [Chapter 6](ch06.html
    "Chapter 6. Using Concurrency and Parallelism with Schedulers"), *Using Concurrency
    and Parallelism with Schedulers*) for every *file path Observable*, the content
    would be *scrambled* because the `flatMap` operator interleaves the notifications
    of the `Observable` instances that it merges.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code introducing the `Observable<String> from(final Path path)` method
    can be found at [https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L61](https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L61).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The source code containing the `Observable<Path> listFolder(Path dir, String
    glob)` method can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L128](https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L128).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The example using the `flatMap` operator can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FlatMapAndFiles.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FlatMapAndFiles.java).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flatMap` operator has multiple overloads. For example, there is one that
    takes three functions—one for `OnNext`, one for `OnError`, and one for `OnComleted`.
    It transforms *errors* or *completed* events into `Observable` instances too,
    and if there is an `OnError` or `OnCompleted` event, their `Observable` instance
    transformation is merged in the resulting `Observable` instance, followed by an
    `OnCompleted` *notification*. Here is an example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output of that will be `-2(2/-1)` and `0` (because of the error raised by
    `2/0`). Because of the *error*, `1` won't be emitted and won't reach the `flatMap`
    operator.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting overload is `Observable<R> flatMap(Func1<T, Observable<U>>,
    Func2<T, U, R>)`. Here is its marble diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations with the various flatMap operators](img/4305_04_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: 'This one combines items from the source `Observable` instance with the `Observable`
    instance triggered by those source items and calls a user-supplied function with
    the pair of the original and derived items. The `Observable` instance will then
    emit the result of this function. Here is an example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is because the first element emitted by the source `Observable` instance
    is `5`, the `flatMap` operator turns it into an `Observable` instance using the
    `range()` operator, which emits `5` and `6`. But this `flatMap` operator doesn''t
    stop here; for every item emitted by this range `Observable` instance, it applies
    the second function with first parameter—the original item (`5`) and second parameter—the
    range-emitted item. So we have *5 + 5* and then *5 + 6*. The same is applied for
    the second item emitted by the source `Observable` instance: `432`. It is turned
    to *432 + 432 = 864* and *432 + 433 = 865*.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'This overload is useful when all of the derivative items need to have access
    to their source item and usually saves us from using some kind of **tuple** or
    **pair** classes, saving on memory and library dependencies. In the earlier example
    with files, we could prepend the name of the file to each of the outputted lines:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The operator `flatMapIterable` doesn''t take as parameter lambda that takes
    arbitrary value as a parameter and returns an `Observable` instance. Instead the
    lambda passed to it takes arbitrary value and returns an `Iterable` instance.
    All of these `Iterable` instances are flattened to values emitted by the resulting
    `Observable` instance. Let''s take a look at the following code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This simple example merges the two lists emitted by the source `Observable`
    instance, and the result emits the four items. It is worth mentioning that invoking
    `flatMapIterable(list -> list)` is the same as invoking `flatMap(l → Observable.from(l))`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Another form of the `flatMap` operator is the `concatMap` operator. It behaves
    just like the original `flatMap` operator, except that it concatenates rather
    than merges the resulting `Observable` instance in order to generate its own sequence.
    The following marble diagram shows how it works:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations with the various flatMap operators](img/4305_04_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: The items from the different *derivative Observables* are not interleaved, as
    with the `flatMap` operator. A significant difference between the `flatMap` and
    `concatMap` operators is that the `flatMap` operator uses the inner `Observable`
    instances in parallel, whereas the `concatMap` operator only subscribes to one
    of the `Observable` instances at a time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The last operator similar to `flatMap` is `switchMap`. Its marble diagram looks
    like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations with the various flatMap operators](img/4305_04_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: 'It operates in similar fashion to the `flatMap` operator, except that whenever
    a new item is emitted by the source `Observable` instance, it stops mirroring
    the `Observable` instance generated from the previously emitted item and it begins
    mirroring only the current `Observable` instance. In other words, it internally
    unsubscribes from the current *derivative* `Observable` instance when the next
    one begins emitting its items. Here is an example of this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The source `Observable` instance is using the `Observable.interval()` operator
    to emit sequential numbers (beginning with zero) every 40 milliseconds. Using
    the `switchMap` operator, a new `Observable` instance emitting another sequence
    of numbers is created for every number. This secondary sequence of numbers begins
    from the source number that was passed to the `switchMap` operator (that's implemented
    by summing the source number with every emitted number, using the `map()` operator).
    So, every 40 milliseconds, a new sequence of numbers is being emitted (each number
    at 10-millisecond intervals).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting output looks like:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for all the mapping examples can be downloaded/viewed at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/MappingExamples.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/MappingExamples.java).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Grouping items
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Items can be grouped by specific property or key.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll look at the `groupBy()` operator, a method that divides a source
    `Observable` instance into multiple `Observable` instances. Each of these `Observable`
    instances emits some of the source's items depending on a grouping function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The `groupBy()` operator returns an `Observable` instance that emits `Observable`
    instances. These `Observable` instances are special; they are of type `GroupedObservable`,
    and you can retrieve their grouping keys using the `getKey()` method. Once the
    `groupBy()` operator is used, the different groups can be handled in a different
    or a common way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Note that when the `groupBy()` operator creates an observable that emits the
    `GroupedObservables` instances, each of them buffers its items. So, if we ignore
    any of them, this buffer will present a potential memory leak.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The marble diagram of the `groupBy()` operator looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![Grouping items](img/4305_04_06.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'Here, the form of the items is used as the common trait of the grouping. For
    a better understanding of the idea of the method, we can look at this example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The example emits some of Pink Floyd''s album titles and groups them by the
    number of words contained in them. For example `Meddle` and `More` are in the
    same group with key `1`, and `A Saucerful of Secrets` and `Wish You Were Here`
    are both in a group with the key of `4`. All these groups are presented by the
    `GroupedObservable` instances, so we can subscribe to them in the `subscribe()`
    call of the source `Observable` instance. The different groups are printed with
    different labels, depending on their keys. The output of this little program is
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The order the items are emitted in is the same, but they are emitted by different
    `GroupedObservable` instances. Also, all the `GroupedObservable` instances are
    completed after the source completes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The `groupBy()` operator has another overload that takes a second, transforming
    function that transforms each of the items in a group in some way. Here is an
    example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The album titles are grouped by the number of the occurrences of the letter
    `m` in them. The text is transformed in a way that all the occurrences of the
    letter are replaced with `*`. The output is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code demonstrating use of the `Observable.groupBy()` operator can
    be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/UsingGroupBy.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/UsingGroupBy.java).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Additional useful transformation operators
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few additional *transformations* worth mentioning. For example,
    there is the `cast()` operator, which is a shortcut for the `map(v -> someClass.cast(v))`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The initial `Observable` instance here emits values of type `Number`, but they
    are actually `Integer` instances, so we can use the `cast()` operator to represent
    them as `Integer` instances.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Another helpful operator is the `timestamp()` operator. It adds a *timestamp*
    to each emitted value by transforming it into an instance of the `Timestamped<T>`
    class. This is helpful if, for example, we want to log the output of an `Observable`,
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, each number is being timestamped. Again, that can be implemented
    using the `map()` operator very easily. The output of the preceding example looks
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A similar operator is the `timeInterval` operator, but it transforms a value
    to an instance of the `TimeInterval<T>` operator instead. A `TimeInterval<T>`
    instance represents an item emitted by an `Observable` along with the amount of
    time that elapsed either since the emission of the previous item, or (if there
    was no previous item) since the subscription. This can be used for generating
    statistics, for example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will output something similar to this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can see that the different values are emitted roughly at 150 milliseconds,
    as they should be.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Both the `timeInterval` and `timestamp` operators work on the *immediate* scheduler
    (see [Chapter 6](ch06.html "Chapter 6. Using Concurrency and Parallelism with
    Schedulers"), *Using Concurrency and Parallelism with Schedulers*), and both of
    them keep their time information in milliseconds.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for the preceding examples can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Filtering data
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first chapter''s reactive sum example, we were filtering the user input,
    based on a special pattern. The pattern was, for example, *a: <number>*. It is
    common to filter only interesting bits of data from the data stream. For example,
    it''s useful to filter out *<enter>* key-down events only from all key-down events,
    or only lines containing a given expression from a file. That''s why it is important
    to not only be able to transform our data but also to learn how to filter it.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many filtering operators in RxJava. The most important of these operators
    is `filter()`. Its marble diagram is very simple and is shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering data](img/4305_04_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'It shows that the `filter()` operator filters the data by some property. In
    the diagram, it''s the form of the elements: it filters only circles. Like all
    the other operators, `filter()` creates a new `Observable` instance from the source.
    This `Observable` instance emits only items that comply to the condition, defined
    by the `filter()` operator. The following piece of code illustrates that:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will output only *even* numbers (`32`, `8`, and `98`), because of the filtering
    condition.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filter()` operator filters elements based on a user-defined function.
    There are quite a few additional filtering operators. In order to understand them,
    let''s look at some simple examples:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We define three `Observable` instances to use in our examples. The first one
    emits nine numbers. The second one emits all the words from a sentence, one by
    one. The third one emits elements of different types—strings, integers, doubles,
    and longs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `takeLast()` operator returns a new `Observable` instance that emits only
    the last *n* items from the source `Observable` instance, only when it completes.
    This method has a few overloads. For example, there is one that emits the last
    *N* or less items from the source, emitted in a specified time window. Another
    one can receive a `Scheduler` instance in order to be executed on another thread.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, only the last four items of the `Observable` instance will
    be filtered and output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Observable` instance created by the `last()` operator, which outputs only
    the *last item* emitted by the source `Observable` instance when it completes.
    If the source doesn''t emit an item, a `NoSuchElementException` exception will
    be emitted as an `OnError()` *notification*. It has an overload that receives
    a predicate parameter of type `T->Boolean`. As a result, it emits only the last
    item emitted by the source, complying to the condition defined by the predicate.
    In this example, the output will be as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `takeLastBuffer()` method behaves much like the `takeLast()` method, but
    the `Observable` instance created by it emits only one item—a `List` instance
    containing the last *N* items from the source:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It has analogical overloads to the `takeLast()` method''s. The output here
    is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `lastOrDefault()` operator behaves like and has the same overload with
    a predicate as the `last()` operator:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, if the source doesn''t emit anything, the `lastOrDefault()` operator
    emits the default value instead of the `OnError` *notification*. The output of
    this example is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `skipLast()` operator is the exact opposite of the `takeLast()` method;
    it emits everything except the last *N* items from the source when it completes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It has similar overloads. The output of this example is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `skip()` method is the same as the `skipLast()` method but skips the first
    *N* items instead of the last:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This means that the output of the example is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `take()` operator is similar to the `takeLast()` operator, but instead of
    the last *N* items of the source, it emits the first *N* items.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is a commonly-used operator, cheaper than the `takeLast()` operator, because
    the `takeLast()` operator buffers its items and waits for the source to complete.
    This operator doesn''t buffer its items but emits them when it receives them.
    It is very useful for limiting infinite `Observable` instances. The output of
    the preceding example is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `first()` operator is similar to the `last()` operator but emits only the
    first item emitted by the source. It emits the same `OnError` *notification* if
    there is no first item. Its predicate form has an alias— the `takeFirst()` operator.
    There is also a `firstOrDefault()` operator form of this operator. The output
    of this example is clear:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `elementAt()` operator is similar to the `first()` and `last()` operators
    but has no predicate form. There is an `elementAtOrDefault()` form though. It
    emits only the element at the specified index in the sequence of items, emitted
    by the source `Observable` instance. This example outputs the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `Observable` instance produced by the `distinct()` operator emits the items
    from the source, excluding the repeated ones. There is an overload that can receive
    a function, returning a key or hash code value to be used to decide whether an
    item is distinct from another or not:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `distinctUntilChanged()` operator is similar to the `distinct()` method,
    but the `Observable` instance that it returns emits all items emitted by the source
    `Observable` instance that are distinct from their immediate predecessors. So,
    in this example, it will emit every word, except the last one, `crew`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `ofType()` operator creates an `Observable` instance that emits only the
    items emitted by the source of a given type. It basically is a shortcut to this
    call: `filter(v -> Class.isInstance(v))`. In this example the output will be as
    follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for all of these examples can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FilteringExamples.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FilteringExamples.java).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: These are the most commonly used *filtering* operators provided by RxJava. We'll
    be using some of them a lot in later examples.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The `last` operator we'll look at in this chapter is a transformational one,
    but a bit special. It can use previously accumulated states! Let's learn more
    about it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Accumulating data
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `scan(Func2)` operator takes a function with two arguments as a parameter.
    Its result is an `Observable` instance. The first item, emitted by the result
    of the `scan()` method, is the first item of the source `Observable` instance.
    The second item emitted is created by applying the function that was passed to
    the `scan()` method on the previous item emitted by the result `Observable` instance
    and the second item, emitted by the source `Observable` instance. The third item,
    emitted by the `scan()` method result, is created by applying the function, passed
    to the `scan()` method to the previous item, emitted by it and the third item
    emitted by the source `Observable` instance. This pattern continues in order to
    create the rest of the sequence emitted by the `Observable` instance creates by
    the `scan()` method. The function passed to the `scan()` method is called an **accumulator**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the marble diagram of the `scan(Func2)` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Accumulating data](img/4305_04_08.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: The items emitted by the `scan()` method can be generated using an accumulated
    state. In the diagram, the circle is accumulated in the triangle, and then this
    triangle-circle is accumulated in the square.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can emit the sums of a sequence of integers, for example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first *subscription* will output all the emissions : *1, 3 (1+2), 6 (3
    + 3), 10 (6 + 4) .. 55*. But in most cases, we are interested only in the last
    emitted item—the final sum. We can use an `Observable` instance that emits only
    the last element, using the `last()` filtering operator. It''s worth mentioning
    that there is a `reduce(Func2)` operator, an alias for the `scan(Func2).last()`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The `scan()` operator has one overload which can be used with a *seed/initial*
    parameter. In this case, the function passed to the `scan(T, Func2)` operator
    is applied to the first item emitted by the source and this *seed* parameter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This example counts the number of lines in a file. The file `Observable` instance
    emits the lines of the file specified by the given path, one-by-one. We use the
    `scan(T, Func2)` operator with a *seed* value of `0` to count the lines by adding
    one to the accumulated count on every line.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'We will conclude this chapter with an example using many of the operators introduced
    in it, together. Let''s look at it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This piece of code uses lots of operators to filter out and assemble a sentence
    hidden in a file. The file is represented by an `Observable` instance, which emits
    all the lines contained in it one by one.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to operate only on the different lines; we want to emit all the
    sentences contained in the file. So, we use the `flatMap` operator to create an
    `Observable` instance which emits the file sentences by sentence (determined by
    `dot`).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We trim these sentences using the `map()` operator. It is possible for them
    to contain some leading or trailing spaces.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to operate on the different words contained in our sentence items, so
    we turn them into arrays of words, using the `map()` operator and the `String::split`
    parameter.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't care about empty sentences (if there are any), so we filter them out
    using the `filter()` operator.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不关心空句子（如果有的话），所以我们使用`filter()`操作符将它们过滤掉。
- en: We need only the first words from the sentences, so we use the `map()` operator
    to get them. The resulting `Observable` instance emits the first word of every
    sentence contained in the file.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要句子中的第一个单词，所以我们使用`map()`操作符来获取它们。生成的`Observable`实例会发出文件中每个句子的第一个单词。
- en: We don't need duplicated words, so we use the `distinct()` operator to get rid
    of them.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要重复的单词，所以我们使用`distinct()`操作符来摆脱它们。
- en: Now we want to branch our logic in a way that some of the words are treated
    differently. So we use the `groupBy()` operator and a `Boolean` key to divide
    our words into two `Observable` instances. The key is `True` for the chosen words
    and `False` for all the others.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们想以某种方式分支我们的逻辑，使一些单词被不同对待。所以我们使用`groupBy()`操作符和一个`Boolean`键将我们的单词分成两个`Observable`实例。选择的单词的键是`True`，其他的是`False`。
- en: Using the `flatMap` operator, we join our separated words, but only the chosen
    ones (with a key of `True`) are left unchanged. The rest are *decapitalized*.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`flatMap`操作符，我们连接我们分开的单词，但只有选择的单词（带有`True`键）保持不变。其余的被*小写*。
- en: We trim all the different words from leading/trailing spaces, using the `map()`
    operator.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`map()`操作符去除所有不同单词的前导/尾随空格。
- en: We use the `filter()` operator to filter out the empty ones.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`filter()`操作符来过滤掉空的句子。
- en: Using the `scan()` operator, we concatenate the words with spaces as separators.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`scan()`操作符，我们用空格作为分隔符连接单词。
- en: With the `last()` operator, our resulting `Observable` instance will emit only
    the last concatenation, containing all the words.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`last()`操作符，我们的结果`Observable`实例将只发出最后的连接，包含所有单词。
- en: One last call to the `map()` operator creates a sentence from our concatenated
    words by adding a dot.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一次调用`map()`操作符，通过添加句点从我们连接的单词中创建一个句子。
- en: If we output the single item emitted by this `Observable` instance, we'll get
    a sentence composed of the first words of all the sentences contained in the initial
    file (skipping duplicated words)!
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们输出这个`Observable`实例发出的单个项目，我们将得到一个由初始文件中所有句子的第一个单词组成的句子（跳过重复的单词）！
- en: 'And the output is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding example can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java)找到。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The example concluding the chapter demonstrates what we've learned so far. We
    can write complex logic by chaining the `Observable` instances using a variety
    of operators. We can transform incoming data using the `map()` or `flatMap()`
    operators and can branch logic by using the `groupBy()` or `filter()` operators
    or the different `flatMap()` operators. We can join these branches again with
    the `flatMap()` operators. We can select parts of the data with the help of different
    filters and accumulate it with the `scan()` operator. Using all of these operators,
    we can write pretty decent programs in a readable and simple way. The complexity
    of the program doesn't affect the complexity of the code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结尾的示例演示了我们迄今为止学到的内容。我们可以通过链接`Observable`实例并使用各种操作符来编写复杂的逻辑。我们可以使用`map()`或`flatMap()`操作符来转换传入的数据，并可以使用`groupBy()`或`filter()`操作符或不同的`flatMap()`操作符来分支逻辑。我们可以再次使用`flatMap()`操作符将这些分支连接起来。我们可以借助不同的过滤器选择数据的部分，并使用`scan()`操作符累积数据。使用所有这些操作符，我们可以以可读且简单的方式编写相当不错的程序。程序的复杂性不会影响代码的复杂性。
- en: The next step is to learn how to combine the branches of our logic in a more
    straightforward fashion. We'll learn how to combine data coming from different
    sources too. So let's proceed with the next chapter!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是学习如何以更直接的方式组合我们逻辑的分支。我们还将学习如何组合来自不同来源的数据。所以让我们继续下一章吧！
