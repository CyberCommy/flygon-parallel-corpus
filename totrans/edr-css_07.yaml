- en: Chapter 7. Applying ECSS to Your Website or Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this Chapter we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying ECSS to logic modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying ECSS to visual modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organising modules, their components and naming files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with generated content from a CMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECSS and global styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECSS is a good match for complex web applications. First up, let's consider
    how we might apply ECSS around the logic of a large application.
  prefs: []
  type: TYPE_NORMAL
- en: Applying ECSS to logic modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, in a web application, some programming language (e.g. JavaScript/TypeScript/Ruby/whatever),
    will be generating *a thing*.
  prefs: []
  type: TYPE_NORMAL
- en: It's often practical and desirable to use the file name of that thing as the
    name of the module (or component of a module). Therefore, if a file is called
    `Header.js` and generates the container for the header, any component parts of
    that header could be named accordingly. For example, in ECSS parlance, a company
    registration number might get `sw-Header_Reg` as its selector. By extension, a
    search box component inside the header might have a selector like `sw-HeaderSearch_Input`
    (the input box created by the `HeaderSearch.js` file).
  prefs: []
  type: TYPE_NORMAL
- en: An example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's consider a more concrete example. Suppose we are authoring a JavaScript
    client-side application and we have a component called `ShoppingCartLines.js`.
    Its task is to render out the lines within a shopping cart and it in turn displays
    within a module called `ShoppingCart.js`. The `ShoppingCart` module renders out
    anything to do with the shopping cart itself. Straight forward enough so far.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's complicate our imagined scenario a little by suggesting that our shopping
    cart will work within a modal view in some scenarios and as part of the page,
    in normal document flow, in others.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this instance, we have a wider module: `ShoppingCart` and a component that
    typically lives within the module called `ShoppingCartLines`. Each of those will
    have their own child nodes. The module and component have two possible views:
    in a modal and in the page. Let''s also imagine that the switch of contexts would
    be handled by the application logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Our constant is the module itself and we can use a namespace to provide context
    for it. When applying ECSS around application logic it makes sense to always use
    the full name of the application module or component as the module section of
    the ECSS style selector. This has the benefit of making all HTML classes in the
    DOM self descriptive as to their origin and purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When naming the class for the outermost container of a module or component,
    no child extension should be added to the class/selector. Only the child parts
    of a module or component should get the node extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so, at this point, our selectors could be named like this in the style
    sheets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This way our module and component have their two contexts isolated by a namespace
    switch. We are free to style each as we see fit with no potential leakage of styles
    from one to the other. This is the exact kind of scenario that typically becomes
    fraught when components and modules share HTML classes in the interest of abstraction
    and re-use.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a twist on this scenario. Let's suppose we don't switch contexts
    with application logic. Instead, we have a switch of styles with media queries.
    We have a modal implementation at smaller viewports and the page style, in normal
    document flow, at larger viewports.
  prefs: []
  type: TYPE_NORMAL
- en: In this instance, we could have a single namespace e.g. `sc-ShoppingCart` (I'm
    using `sc-` to designate the context is `ShoppingCart`) and use media queries
    in the CSS to provide visual changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Child nodes of a module or component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, a module or component will have its own child node
    elements. These selectors should be named with a child extension. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each child gets the namespace and component (or module) name of its parent.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Full details on the ECSS naming convention are in [Chapter 5](ch05.html "Chapter 5. File
    Organisation and Naming Conventions"), *File Organisation and Naming Conventions*.
  prefs: []
  type: TYPE_NORMAL
- en: So, at this point we now have an understanding of how we might name our selectors
    when applying ECSS around application modules and logic. We will look now at how
    we might name selectors and apply ECSS around purely visual modules. However,
    first a brief but important tangent on using type selectors.
  prefs: []
  type: TYPE_NORMAL
- en: A note on type selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When authoring CSS, there are occasions when it can be tempting to use type
    selectors. Usually this is when there are HTML5 text-level elements, such as `<i>`,
    `<b>`, `<em>` or `<span>`. For example, suppose we have a sentence with a couple
    of words that need to be bold. Then temptation would be to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A note on type selectors](img/Warning-image-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And use these selectors to apply styles to the contents of that `b` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A note on type selectors](img/Warning-image-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of problems here:'
  prefs: []
  type: TYPE_NORMAL
- en: We have created a dependency on certain markup structure (it must be a child
    node and be a `b` tag).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Due to point 1, we have created a selector that is more specific than it needs
    to be. This makes any future overrides more difficult to reason about and perform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While it may seem overly verbose, this is how that scenario should be handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And this CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each element has its own selector and rule. Neither depends upon the other.
    Neither rule requires particular markup to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each rule applied to an element should be as opinionated about its own appearance
    as possible. For example, it you have an element that contains two text nodes
    it seems logical to apply the font size and line height to the wrapping element
    so the two text nodes will inherit from it. However, this prevents that text node
    being moved to another location and rendering consistently. Instead, apply the
    color, font-size and line-height to each node, even if they are initially very
    similar (perhaps at the outset only the colour differs). It will seem counter-intuitive
    at first but protects against possible deviations in the future (being moved in
    the DOM, styles diverging etc).
  prefs: []
  type: TYPE_NORMAL
- en: Applying ECSS to visual modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Visual* components refers to areas of markup that are not necessarily generated
    by a particular piece of application logic.'
  prefs: []
  type: TYPE_NORMAL
- en: You can still break areas into logical **visual** areas and apply ECSS to them.
    This is the approach employed on the [http://ecss.io](http://ecss.io)  website.
  prefs: []
  type: TYPE_NORMAL
- en: There are no hard and fast rules. As an example, we might break a design into
    visual areas for Structure, Menu, Footer, Navigation, Quick Jump Menu, Hero Image
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'And in this case, our selectors look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we might just as easily do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even like this if it''s the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: None of those approaches is wrong or right. As long as child nodes/selectors
    follow the same naming convention, the styles will be isolated to the particular
    area.
  prefs: []
  type: TYPE_NORMAL
- en: The reality is that on smaller sites, you could use pretty much any class-naming
    approach you like and the dangers of collision would be minimal. However, as soon
    as projects start to grow the benefits of namespacing and a strict naming convention
    will start to pay you back handsomely. Just make a decision, and apply that choice
    consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Organising modules, their components, and naming files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, I think it will be useful to consider a more detailed example
    module structure. It's similar to the structure in which I'm used to employing
    ECSS. It's a little more involved than our prior examples and gives another subtly
    different variation on how files could be organised and selectors named. As ever,
    from our CSS point of view our aim is isolation, consistency and solid developer
    ergonomics. Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a module. Its job is to load the sidebar area of our site.
    The directory structure might initially look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of the example markup structure this module should produce, we would
    expect something like this initially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSS that styles this initial element should live inside the `css` folder
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we have a component inside the `SidebarModule` that creates a
    header for the `SidebarModule`. We might name the component with a file called
    `Header.js` and store it inside the components sub-folder of our `SidebarModule`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, the `Header.js` might render markup like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note how the `Header` component, due to being within the context of the `SidebarModule`
    carries the `sb-` micro-namespace to designate its parentage. And the nodes created
    by this new component are named according to the logic that creates them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of the general conventions to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Components should carry the micro-namespace of the originating logic. If you
    are creating a component that sits within a module, it should carry a/the namespace
    of the originating module (possible namespaces for a module are defined in `css-namespaces.json`).
  prefs: []
  type: TYPE_NORMAL
- en: HTML classes/CSS selectors should be named according to the file name/components
    that generated them. For example, if we created another component inside our module
    called `HeaderLink.js` which renders its markup inside a child of the `Header.js`
    component, then the markup it generates and the applicable CSS selectors should
    match this file name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of the folder structure, it would now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice how there is a 1:1 correlation between component logic (the `*.js` file)
    and the associated styles (the `*.css` files) – both sit within a `components`
    sub-folder. Although both logic and styles don't share the same immediate parent
    folder, they both live within the same module folder, making removal of the entire
    module simple if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes within a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To recap. Used in this way, the ECSS naming convention of nodes within a component
    should always be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`ns` : The micro-namespace (always lower-case)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Component`: The Component name (always upper camel-case)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_Node`: The child node of a component (always upper camel-case preceded by
    an underscore)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-variant`: The optional variant of a node (always lower-case and preceded
    by a hyphen)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the `-variant` part of a node within a component is optional and
    should only be used to denote subtle variations on otherwise identical items.
    For example, multiple headers that are identical apart from a differing background
    image might be rendered like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Remember, we discussed the use of variant selectors a little more in [Chapter
    5](ch05.html "Chapter 5. File Organisation and Naming Conventions"), *File Organisation
    and Naming Conventions*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with generated content from a CMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's probable that if you use ECSS with any sort of content management system
    (Wordpress, Ghost, Drupal et al) you will encounter a situation where it's not
    possible to add a class to every element. For example, in a Wordpress page or
    post, it would be unrealistic to expect users entering content to remember the
    right class to add to each paragraph tag. In these situations, I think pragmatism
    has to win out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set a ECSS class to the enclosing element and (grudgingly) accept that all
    the nested elements will be set with a type selector. Here''s some example markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how you might author the CSS to handle selecting those elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I'm not crazy about that. We're nesting selectors, tying our styles to elements,
    basically everything we normally want to avoid with ECSS. However, I'm being honest.
    The reality is that this is likely going to be the best compromise we can manage.
    Where it is possible to add a class to elements we absolutely should. However,
    there will be situations where this simply isn't possible and no amount of Ivory
    Tower idealism will help in those situations. Remember *Pin Cing Do*!
  prefs: []
  type: TYPE_NORMAL
- en: ECSS and global styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whilst the Lion's share of CSS in a web application can be described as module
    based, there is an inevitable amount of global CSS we need to deal with. From
    an ECSS perspective we should keep this global CSS as minimal as possible. Typically,
    besides any requisite *reset* styles, there will be a default font-size, font-family
    and perhaps some default colours. These are styles that are usually applied to
    type selectors. Unless you have classes on the root HTML element of body for example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are looking for a base set of reset styles for a web application you
    may find my *App Reset* CSS useful. You can find it on GitHub here: [https://github.com/benfrain/app-reset](https://github.com/benfrain/app-reset) 
    or install via NPM with `npm install app-reset`.'
  prefs: []
  type: TYPE_NORMAL
- en: There may also be some global structure needed. For example, if you have a common
    structure throughout your application (header, footer, sidebar etc), you may want
    to create some selectors to reflect this. In the past I have used a `.st-` or
    `.sw-` micro-namespace to define *Structure* or *Site Wide* but you can use whatever
    is most apt for you. However, my advice would be that there really shouldn't be
    many of these selectors as these typically relate to very broad areas that all
    the modules of an application should live within.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of organising global CSS I currently favour a folder in the root of
    any project called `globalCSS`. In that folder would be any variables, mixins,
    global image assets, any font or icon-font files, a basic CSS reset file and any
    global CSS needed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at the two principal ways you might apply ECSS in this chapter.
    We've also considered a possible folder structure for a complete and more complicated
    module. I'm hopeful that by this point, you'll have a fair idea of how you might
    apply ECSS in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Hand-in-hand with the architectural approach of implementing CSS is the practice
    of actually authoring your style sheets. You know, how the code actually looks
    in the editor. The code samples throughout this book have been demonstrating this
    syntax but it's time now to delve into it in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to best author style sheets to put all this ECSS malarkey into practice
    is what we will look at in the next chapter.
  prefs: []
  type: TYPE_NORMAL
