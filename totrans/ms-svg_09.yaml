- en: Helper Libraries Snap.svg and SVG.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve learned a lot about SVG so far in this book. If you''ve made it this
    far, you''re ready to do some serious SVG development, and for that there are
    three ways to go:'
  prefs: []
  type: TYPE_NORMAL
- en: Continue doing what we've, mostly, done so far in this book-learn about the
    way the core technologies interact and integrate SVG into your sites or applications,
    as you would in any markup. Manipulate it with JavaScript and CSS and you're ready
    to tackle basically anything. This is a valid approach and is the one I often
    take in my own work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use task-specific frameworks and libraries. We've started to look at this a
    little bit with GSAP and Vivus for animation. We'll continue to look at this in
    [Chapter 10](b297a139-f545-435c-9ca2-752987638d15.xhtml), *Working with D3.js*,
    when we look at D3, a powerful visualization framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use general purpose SVG libraries that will help you with a variety of SVG-related
    tasks. SVG was brought into the mainstream of web development on the back of one
    such library, Raphael, and there are current libraries available for you to use
    in your own work. This option is the focus of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As previously mentioned, SVG took many years to gain traction owing to limited
    browser support. A general-purpose SVG library called Raphael.js ([http://dmitrybaranovskiy.github.io/raphael/](http://dmitrybaranovskiy.github.io/raphael/))
    helped to bridge that support gap by offering a very clever **Vector Markup Language**
    (**VML**), [https://docs.microsoft.com/en-us/windows/desktop/vml/web-workshop---specs---standards----introduction-to-vector-markup-language--vml-](https://docs.microsoft.com/en-us/windows/desktop/vml/web-workshop---specs---standards----introduction-to-vector-markup-language--vml-),
    polyfill for an older version of Internet Explorer. It also offered a friendly
    API for dealing with SVG in the browser, which helped people unfamiliar with SVG
    to get started quickly and easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter deals with two of the most popular successors to Raphael.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Snap.svg`: a direct successor to Raphael, being a library authored by the
    author of Raphael.js, Dmitry Baranovskiy ([http://snapsvg.io/](http://snapsvg.io/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`svg.js`: another small, lightweight library that offers plenty of powerful
    options for manipulating SVG ([http://svgjs.com/](http://svgjs.com/)[)](http://svgjs.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the chapter will look at the basics of each library and will then
    go through some familiar examples, reworked to utilize the power of these general
    purpose SVG tools.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with Snap.svg.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Snap.svg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Snap.svg is an SVG utility library from Adobe authored by Dmitry Baranovskiy.
    It is relatively full-featured, has a friendly, easy-to-explore API and is open
    source.  Development on this library has slowed recently, but it's still a useful
    tool and one you should be aware of if you're exploring a general purpose SVG
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Snap.svg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Snap.svg is available on `npm`, so by far the easiest way to get started with
    `Snap.svg` is to install it using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It's also available for download directly from the website, [http://snapsvg.io/](http://snapsvg.io/), and
    is also available to download or clone from GitHub, [https://github.com/adobe-webplatform/Snap.svg](https://github.com/adobe-webplatform/Snap.svg).
  prefs: []
  type: TYPE_NORMAL
- en: Once you've done that, it's as easy as including the `snap.svg-min.js` from
    `node_modules` or the downloaded folder, and you're ready to start using Snap.
  prefs: []
  type: TYPE_NORMAL
- en: In this first example, we load Snap into the document and then go through some
    Snap basics loading up the Snap API and manipulating some SVG.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, in this first example, we get a reference to a containing `div`,
    using the ID `#target`. Then we create an instance of Snap, using the `new` keyword
    and storing it in a variable, `S`. There are two arguments passed in, `800` and
    `600`. These represent the width and height of the SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: While we will use the variable `S` to represent the `Snap.svg` API in this chapter,
    you can name the variable anything you like as long as you assign the return value
    of the `Snap.svg` constructor to it. There's nothing magical about S, other than
    the fact that it's the conventional variable name that the authors of Snap use
    for their examples.
  prefs: []
  type: TYPE_NORMAL
- en: Next we use the Snap utility method `S.appendTo` to add our new SVG element
    into the document, using our `#target` element as the container.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the SVG element is on the page, we add two new SVG elements into the
    document to show the basic pattern for adding and manipulating SVG elements with
    Snap. We add a circle and a rectangle. The circle is added with `S.circle`, passing
    in three attributes, the `center x`, the `center y`, and the `radius`. Once the
    circle is added, we call the chained method `attr`, passing in a `fill` and a
    `stroke`.
  prefs: []
  type: TYPE_NORMAL
- en: Next we call `S.rect` to create a rectangle, passing in `x`, `y`, `width`, and
    `height` arguments and, again, using `attr` to add a `fill` and `stroke`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This jQuery-like pattern of chaining method calls to manipulate SVG elements
    is the core of your interaction with Snap. If you''ve got experience with that
    style of development, you''ll pick up Snap very quickly. The API is clear and
    logical, so it''s easy to experiment with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding in a browser produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f040b3f-f908-4c1c-a61b-75c757ef89a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Taking that basic pattern, we can now start to recreate some of the demos we
    did previously, using Snap. Seeing how we transition from core technologies to
    libraries can be instructive and can give you a feel for the library and whether
    or not it feels like something you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: Animation with Snap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since animation with SVG is such an important feature of the modern web, Snap
    offers several animation utilities. It also offers the ability to manipulate existing
    SVG elements and not just elements generated by Snap itself (which is something
    SVG.js can't do). This demo takes advantage of both of those features.
  prefs: []
  type: TYPE_NORMAL
- en: The setup is similar to what we saw in earlier examples of this animation demo.
    We start the demo by obtaining three element references, `doc` for the `document`,
    `canvas` for the parent SVG, and `circle` for the `circle` element. Next, we get
    a reference to the `viewBox` and associated `width`, in order to make some calculations
    about the finishing point of the circle. This new finishing point is stored as
    `newX`.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the Snap specific features of this example. First, we load up a reference
    to the `circle` element with Snap's API. We do this by passing the variable `circle`,
    a DOM reference to the `circle` element, into Snap. If you've worked a lot with
    jQuery, this might be a familiar pattern for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that is done we can use the Snap `animate` method to animate the circle
    across the screen. `animate`, in this instance, takes four arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is an object indicating the end state of the animation. In this case
    we're animating the `cx` property to the calculated `newX` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we pass in the duration of the animation, three seconds in milliseconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that we pass in the animation easing. Once again we're using bounce easing.
    This is available as part of Snap's `mina` object, which provides built-in easing
    options as well as some other utilities for working with animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we pass in a `callback` function to run after the animation is completed.
    This function changes the fill color to red:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the animation utilities seen in this example, Snap also includes
    other utilities for working with SVG. The next section will illustrate some of
    those utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Snap.svg utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example will illustrate a couple of useful Snap utilities available for
    working with SVG. The whole purpose of working with a general-purpose library
    like Snap is to use utility methods such as the following. This example shows
    just two such utilities, but this should be enough to show you the sort of things
    that are available.
  prefs: []
  type: TYPE_NORMAL
- en: The beginning of the example is standard `Snap.svg` development. You start by
    getting a reference to the `#target` element. We create a `Snap` variable, `S`,
    and then append it to the `#target` element.
  prefs: []
  type: TYPE_NORMAL
- en: Once it's in the document, we can use the first of two utilities. It's a single
    line assignment to the variable `bbox`, which returns the bounding box of an SVG
    element, in this case, a circle.
  prefs: []
  type: TYPE_NORMAL
- en: A bounding box is the smallest possible rectangle that can contain a shape (or
    group of shapes).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at what happens in this assignment. First we create a new `circle`
    at (`255`, `255`) with a `110` pixel radius. Then we add a `fill` and `stroke`
    so that we can see it on the SVG element. Then we call the `getBbox` method, which
    is stored as `bbox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we `console.log` out the `bbox` variable, we see the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8249c115-1a72-40ab-ad36-ab620620d986.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the return value contains a lot more information than just the
    simple coordinates of the smallest possible rectangle that can contain the element.
    It has that information (the `x`, `y`, `height`, and `width`), but it also has
    several other properties that might be useful if you're manipulating the element
    in relation to another element in an animation, visualization, or dynamic drawing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows the values of the bounding box and what they represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cx` the *x* value of the center of the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cy` the *y* value of the center of the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h` the height of the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height` the height of the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path` the path command for the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r0` the radius of a circle that fully encloses the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r1` the radius of the smallest circle that can be enclosed by the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r2` the radius of the largest circle that can be enclosed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vb` the box as a `viewBox` command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w` the width of the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width` the width of the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x2` the *x* value of the right side of the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` the *x* value of the left side of the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y2` the *y* value of the bottom edge of the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y` the *y* value of the top edge of the box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's a very useful, but possibly unexceptional utility method. As you'll see
    in the SVG.js section, a bounding box is an important and common concept when
    working with SVG.
  prefs: []
  type: TYPE_NORMAL
- en: The next example utility is a little more interesting. Let's take a look at
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we first create a `path` that represents a stylized letter R. You
    saw this R and the associated `path` previously as part of one of our animation
    examples. Once the letter R is inserted into the document, we add a `fill` and
    `stroke` to it, and then apply a transformation to it in order to center it on
    the `circle` we previously created. The end result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84fe1b92-8341-42d1-8b4e-02dddb89787b.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the path is inserted, we call `console.log` again, with another utility
    method,  `path.getTotalLength()` passed in as an argument. `path.getTotalLength()`
    does what it says on the tin — it returns the total length of the referenced path
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were, for example, animating along the path over a defined length of
    time, getting the length of the path would be a vital metric. As the following
    screenshot shows, this utility provides that powerful metric with very little
    fuss:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fbe144a-9612-4ea8-a469-54be1507c26f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The entirety of the code just described is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've taken a look at some Snap utilities, let's look at Snap's events
    system, which allows you to work with SVG elements in an interactive way while
    still staying tightly within the confines of the Snap API.
  prefs: []
  type: TYPE_NORMAL
- en: Snap.svg events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you may already have a handle on managing events manually using `Element.addEventListener`
    or are already using something like jQuery to handle your events, it's worth noting
    that Snap offers some event utilities of its own. This allows you to cut down
    on external dependencies if you're doing very focused work with SVG. It also allows
    you to skip over any of the quirks that a library like jQuery offers when working
    with SVG elements.
  prefs: []
  type: TYPE_NORMAL
- en: The following example is a familiar one modified to show how Snap.svg events
    work. In this example, we're once again adding `click` event handlers to a blank
    SVG canvas and inserting random sized circles into the SVG element at the point
    of the click. Using Snap to implement this demo is very similar to what you saw
    previously, but it has some conveniences that are worth noting, and it illustrates
    the straightforward way that Snap handles events.
  prefs: []
  type: TYPE_NORMAL
- en: The example starts off by getting access to the `#target` element, setting `height`
    and `width` variables, and then creating an instance of Snap appended to the `#target`
    element and stored in the standard Snap variable, `S`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have Snap loaded, we chain a series of method calls to add a circle
    using the `S.circle` method, set the `fill` using the `attr` method, and then
    add a click event handler to the element using Snap's `click` event utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `callback` function called when the user clicks on the SVG element is almost
    the same as the vanilla JS Version, although it does use the Snap method `S.circle`
    to insert a circle element using the familiar randomized parameters `fill`, `radius`,
    `newX`, and `newY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you're used to working with jQuery or other libraries that follow a similar
    pattern, then you should be able to pick up working with Snap's event utilities
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Custom data visualization with Snap.svg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final example using `Snap.svg` shows how it can be used to do custom data
    visualizations. This will show many features of `Snap.svg` in action and will
    provide a final, full look at the library.
  prefs: []
  type: TYPE_NORMAL
- en: This example will once again generate a visualization showing the positive/negative
    delta of home runs hit per year versus the average home runs hit per year by David
    Ortiz of the Boston Red Sox per year over his Red Sox career.
  prefs: []
  type: TYPE_NORMAL
- en: Since we've already seen this visualization, in this section we'll only focus
    on the areas where `Snap.svg` is being used and not on every line of the script.
    If you need a refresher on the hows and whys of data visualization itself and
    how the metrics are calculated, please look back at [Chapter 8](c444b4d6-9f5d-40f5-9de3-e3b72235098d.xhtml), *SVG
    Animation and Visualizations*, for a full explanation of the entire script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first file you''ll see is the HTML file, which is similar to the original
    version of this visualization. The only real difference is including the `Snap.svg`
    source file from `node_modules`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the source of `scripts.js`, the `viz()` function is structurally
    the same, but has some Snap-related differences that you'll want to notice.
  prefs: []
  type: TYPE_NORMAL
- en: The `data` variable is exactly the same and is truncated here to make the `viz()`
    function slightly easier to read. See [Chapter 8](c444b4d6-9f5d-40f5-9de3-e3b72235098d.xhtml), *SVG
    Animation and Visualizations*, or the source code to see the full data set.
  prefs: []
  type: TYPE_NORMAL
- en: Following the `data` variable, some of the interesting stuff starts with the
    `S` variable. As you saw previously, `S` is an instance of `Snap.svg` and that's
    going to be the interface through which we do a lot of our work. Following that,
    there aren't any changes between this version and the original version of this,
    until we use a reference to the Snap reference to the SVG element's DOM node,
    `S.node`, to access the SVG element's `viewBox`.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, the biggest difference you'll notice is the ability to use the
    Snap convenience methods, `S.rect`, `S.line`, and `S.text` (all paired with `S.attr`)
    to add our lines, boxes, and text elements to the screen. We also use `S.addClass`
    to add a CSS class to one of our lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because all of these methods exist in `Snap.svg`, the biggest difference between
    this example and our JavaScript-only example is the absence of our own, hand-rolled
    convenience methods. Since Snap provides so many convenient features, we don''t
    need to provide them ourselves. Which is great in and of itself, and, of course,
    Snap includes many more convenience methods than `S.rect`, `S.line`, `S.text`,
    and `S.attr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've taken a good look at `Snap.svg` and hopefully given you a feel
    for what it is like to work with, let's take a look at another `helper` library,
    the appropriately named SVG.js.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SVG.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SVG.js was created by Wout Fierens and is currently maintained by Ulrich-Matthias
    Schäfer, Jon Ronnenberg, and Rémi Tétreault. It's designed to be lightweight and
    fast, and to be a friendly interface for working with SVG. It's more actively
    maintained than `Snap.svg`, so it's got that going for it. As of the time of writing,
    the most recent code was added to the project within the past two weeks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with SVG.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like `Snap.svg`, SVG.js is available on `npm`, so the easiest way to get started
    with SVG.js is to install it using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you install `svg.js` with `npm` and not `svg.js`. Both work and both
    point to the correct project. `svg.js` is, however, out of date because the official
    package is `svg.js`.
  prefs: []
  type: TYPE_NORMAL
- en: It's also available for download directly from the website [http://svgjs.com/installation/#download](http://svgjs.com/installation/#download).
    It is also available to download or clone from GitHub, [http://svgjs.com/](http://svgjs.com/) and
    is available on `cdnjs`[.](http://snapsvg.io/)
  prefs: []
  type: TYPE_NORMAL
- en: Once you've done that, it's as easy as including the `svg.min.js` from `node_modules` or
    the downloaded folder, and you're ready to start using SVG.js.
  prefs: []
  type: TYPE_NORMAL
- en: This first example repeats the earlier blue circle/green square demo. The convention
    with SVG.js, as shown in their demos, is to use a variable, `draw`, to hold the
    loaded instance of SVG.js that you work with.
  prefs: []
  type: TYPE_NORMAL
- en: To create an instance of SVG.js, you pass in a reference to a target HTML element
    and SVG.js inserts a loaded SVG element into the targeted element, ready for you
    to work with. You then chain a method, `SVG.size`, which will set the size of
    the newly created SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: While we will use the variable `draw` to represent the SVG.js API in this chapter,
    you can name the variable anything you like. As long as you assign the return
    value of the SVG.js constructor to it, any variable name will work. There's nothing
    specifically magical about `draw`, other than the fact that it's the conventional
    variable name that the authors of SVG.js use for their examples.
  prefs: []
  type: TYPE_NORMAL
- en: The same is `true` of `Snap.svg` and the variable `S`. These are just conventions.
  prefs: []
  type: TYPE_NORMAL
- en: SVG.js isn't designed to work with an existing SVG element, so you have to slightly
    change your approach if you're used to getting a reference to an existing SVG
    element and then manipulating it.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a reference to `draw` and our SVG element is added to the page,
    we can start to manipulate the SVG element, adding our square and circle.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the example of the circle, we call the clearly named method `draw.circle` 
    to create a circle. `draw.circle` accepts *one* argument, the *radius* of the
    circle.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, all of the other attributes are manipulated with the familiar
    (from jQuery and Snap) `attr` method. I think this is a peculiar choice since
    a circle with just a radius isn't very useful. The same goes for `draw.rect`,
    which requires the height and width of the rectangle as arguments and then does
    everything else as attributes with `attr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This syntax works just fine. But it is interesting that the attributes are
    spread across two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Animation with SVG.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've seen the basic example of inserting elements into the page, let's
    continue the same pattern we followed with `Snap.svg` and look at how to create
    an animation with SVG.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more dependency to get animations running properly in SVG.js, `svg.easing.js`.
    This is a library of easing functions that work with SVG animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Include that after you include the main SVG.js file and you're ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with this example, we create several variables to use throughout
    the animation, `width`, `height`, `cx`, `cy`, and `radius`. You saw these previously
    and they map to properties of SVG elements.
  prefs: []
  type: TYPE_NORMAL
- en: Then we create our SVG.js instance, using the `height` and `width` values as
    arguments, and store it in the `draw` variable. After that we create the `circle` element
    we will animate, by calling `draw.circle` with the `radius` variable as the sole
    argument. We then call `attr` with a blue `fill` value and the `cx` and `cy` variables
    as values for the `cx` and `cy` attributes respectively. This creates the blue
    circle in the correct spot on the SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: Then we calculate the `newX` variable. We then animate the circle to that new
    value with the SVG.js method `circle.animate`. The `animate` method takes three
    arguments, `3000`, the length of the animation, `SVG.easing.bounce`, the easing
    function to use (from `svg.easing.js`), and `1000`, the animation delay.
  prefs: []
  type: TYPE_NORMAL
- en: Next up there is a chained manipulation method, `center`, which, in this example,
    indicates the type of animation to perform. `center`, by itself, moves an element's
    center to the new `(x,y)` coordinates passed into it. Chaining it with `animate`
    means that you will smoothly animate between the two states. In our example, `center`
    takes the `newX` and original `cy` variables as arguments, which gives us our
    new horizontal placement while retaining our original vertical placement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to illustrate an animation `callback` method, we use the method `after`,
    which allows us to run a function after the animation has completed. Here we simply
    change the color of the circle with the `attr` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we've seen in these two examples, there are some quirks in the SVG.js API.
    Since the quirks are consistent, like setting properties in two chained methods,
    you can very quickly get used to them.
  prefs: []
  type: TYPE_NORMAL
- en: SVG.js utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like `Snap.svg`, SVG.js has a suite of utility functions to help you work with
    SVG. Some of them are really great. This example shows how many of them work.
  prefs: []
  type: TYPE_NORMAL
- en: To kick off this example we create a loaded SVG.js variable, draw, and pass
    in `800`, `600` for the `height` and `width`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting off immediately with some utilities, we call `draw.viewbox()` to get
    the `viewBox` of the SVG element. If you remember the visualization example done
    with `Snap.svg`, you'll recall that we had to navigate multiple properties to
    access the `viewBox` in Snap. There was no convenience method at all, just a property
    of the DOM Node that represented the SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have a convenience method that returns it directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6299d61f-3d66-43d0-afcf-f28483706ef6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next we load up a variable, `rect` with a `100` by `100` rectangle at (`100`,
    `100`) `console.log` out `rect.bbox()`, which returns the bounding box of the
    rectangle. As you can see in the following screenshot, it has fewer properties
    than the `Snap.svg` example of a bounding box, but it remains useful with all
    of the standard properties you would need to interact cleanly with this element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a880d18b-7513-47c9-b13a-4c2fab5aee8d.png)'
  prefs: []
  type: TYPE_IMG
- en: One very useful utility related to the standard bounding box is illustrated
    next.
  prefs: []
  type: TYPE_NORMAL
- en: First, we transform the rectangle using SVG.js' `transform` method, rotating
    it by 125 degrees. `transform` is a `getter `/ `setter` that will return the current
    transformation value when called without arguments and will set the value when
    called with arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve transformed the `rect` rectangle, we `console.log` out the return
    value of `rect.rbox()`, which returns a bounding box that represents a visual
    representation of the element which includes all transformations*. *This will
    save you a lot of coding if you''re working with transformed elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c7752a6-c0b5-4358-b450-07eeb98ada5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next method, `data`, works just like the jQuery data method. Called as
    a `setter`, `rect.data({"data":"storing arbitrary data"}),`, `data` sets arbitrary
    data on an object, stored under a user-supplied label. Called as a `getter`, with
    the label passed in as an argument, `rect.data("data")`, it returns the value
    of the labeled data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94970048-f07a-47e9-bccc-ce0454dc37b9.png)'
  prefs: []
  type: TYPE_IMG
- en: The next utility method allows you to adjust the stack of SVG elements. Unlike
    absolutely positioned HTML elements, which have an explicit stacking order (z-index),
    SVG elements are layered based on their appearance in the DOM. Elements that are
    later in the DOM appear to sit on top of elements that appear earlier in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The next code block shows how you can adjust this stacking order with SVG.js
    utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create two squares, a green square and then a blue square. When they
    appear on the screen initially, they look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa7a2182-d20b-4d0a-b96e-b4eb155f4280.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, inside a one second timeout, we call the `back()` method, which sends
    the element to the back of the stack. After that, the squares look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0181a282-3e7c-48b0-980c-d486a87e6ce8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have two squares on the screen, it''s time to look at one final,
    super useful, bounding box related utility. If you call `first.bbox().merge` and
    pass in `second.bbox()` as the argument, you get a combined bounding box. This
    is incredibly useful if you''re working with multiple elements that are not part
    of a structured SVG group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/590dc8e3-adcd-40c6-86f2-d5f84c63aa91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the entire code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: SVG.js events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SVG.js also has event handling utilities. The following example will illustrate
    the very familiar event handling pattern provided by SVG.js.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we're illustrating event handling by binding `click` events to a
    function that inserts random-sized circles with random fills on the canvas. This
    will also illustrate one nice usage of the SVG.js `front()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The example starts off by creating the `draw` variable, setting its height and
    width and then creating a `circle` variable with an SVG.js enhanced `circle` element.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we bind a `click` event to the circle, which creates the randomly-sized/filled
    circle element using the event utility `circle.click`. It's straightforward. Like
    the `Snap.svg` example or examples from earlier versions of jQuery, you pass in
    the `callback` method as an argument to `click` and that's all it takes to bind
    your events properly.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `callback`, we use `draw.circle` to create our circles with the random
    values generated every time the function runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The one nice bonus of using SVG.js here is that you can always ensure that
    the clickable circle is at the top of the stack by calling `circle.front()` after
    every circle is added. Otherwise, it could eventually be buried by other elements
    appearing on top of it because they were inserted later on in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Custom data visualization with SVG.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final example in this chapter is another example of doing a custom data
    visualization. We're going to once again revisit the visualization representing
    David Ortiz's home runs over his career as a member of the Boston Red Sox.
  prefs: []
  type: TYPE_NORMAL
- en: Since we've seen this multiple times, we can simply focus on the ways that SVG.js
    can help us do this work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first file you''ll see is the HTML file. The only differences between this
    and the vanilla JS Version are the inclusion of the SVG.js source file from `node_modules`
    and the absence of a base SVG element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `viz()` function is similar to what we saw with the `Snap.svg` Version.
    Once again we've clipped the data object for readability.
  prefs: []
  type: TYPE_NORMAL
- en: Following that there's the familiar pattern for working with SVG.js. We set
    `width` and `height` variables and then create the `draw` SVG.js instance using
    the `width` and `height` variables as the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The first place where SVG.js comes into play is the easy-to-use `viewBox()`
    method in the `DOMContentLoaded callback` function, which returns the SVG element's
    `viewBox`. We use this variable to calculate multiple variables used in the visualization.
    After more than 20 lines of creating familiar variables (see [Chapter 8](c444b4d6-9f5d-40f5-9de3-e3b72235098d.xhtml),* SVG
    Animation and Visualizations*, for a refresher on what each of these does), we
    draw some boxes, we draw some lines, and we add some text.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of how SVG.js can help with each of these.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing boxes allows us to expose some nice convenience methods that SVG.js
    offers as a replacement to setting properties in `attr`. `draw.rect` is called
    the same as before, passing in the calculated width and height for each box. Then,
    we chain three more method calls to it: `attr` is used to set the `x` and `y`
    and then, as an illustration of their availability, we also use two convenience
    methods, `fill` and `stroke`, to set the `fill` and `stroke` directly. It's quite
    possible to simply set everything as an argument to `attr`, but if you prefer
    to chain method calls in this way, it's a nice option for you to be able to call
    `fill` and `stroke` to set those properties.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing text introduces a new method, `draw.plain`. There is a `draw.text` method,
    but `draw.text` is designed to work with larger blocks of text and therefore introduces `tspan`
    elements into the mix to help control flow and line breaks. That's actually very
    clever and is a useful option for many situations where you're working with long
    blocks of text in SVG since everything to do with flow and line breaks has to
    be handled manually. In those situations, having multiple elements to work with
    is great.
  prefs: []
  type: TYPE_NORMAL
- en: '`draw.plain`, however, is perfect for our needs here as we''re only interested
    in individual text elements. To use it, we call the `draw.plain`, pass in our
    concatenated string as an argument, and then set the `(x,y)` coordinates using
    our good friend `attr`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing lines requires four initial arguments, the starting `(x,y)` and the
    finishing `(x,y)`. Once we provide those values as calculated by the rest of the
    `viz()` function, we can do things like add a stroke, via `draw.attr` (as in this
    example) or `draw.stroke` (if you prefer), or add a class using the convenience
    method `draw.addClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has provided you with a rapid-fire introduction to two separate
    libraries for working with SVG, `Snap.svg` and SVG.js. Doing the same, familiar
    tasks you previously tackled in vanilla JS in the two libraries has allowed you
    to see the differences between doing these SVG manipulations with vanilla JS and
    doing them with a library. You've also been able to compare the two libraries
    themselves across similar tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, you've learned a number of different topics with these two libraries,
    including how to get started, how to animate elements, how to handle events, and
    how to do custom data visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about general purpose libraries, we're going to take
    a look at one final SVG library with a very specific purpose, D3.js. D3 is used
    for heavy duty data visualizations and is one of the most powerful tools out there
    for working with SVG.
  prefs: []
  type: TYPE_NORMAL
