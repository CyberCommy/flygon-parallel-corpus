- en: HTML5 and WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will show you how the C code we write to target WebAssembly
    comes together with HTML5, JavaScript, and CSS to create a web page. We will teach
    you how to create a new HTML shell file to be used by Emscripten in the creation
    of our WebAssembly app. We will discuss the `Module` object and how Emscripten
    uses it as an interface between our JavaScript and the WebAssembly module. We
    will show you how to call WebAssembly functions written in C from within JavaScript
    on our HTML page. We will also show you how to call JavaScript functions from
    our C code. We will discuss how to use CSS to improve the look of our web page.
    We will introduce you to the HTML5 Canvas element and show how it is possible
    to display images to the canvas from within JavaScript. We will briefly discuss
    moving those images around the canvas from our WebAssembly module. This chapter
    will give you an understanding of how everything works together and lays the foundation
    for other features we are developing for our WebAssembly applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginning with this chapter and continuing through the remainder of the book,
    you will need image and font files from the GitHub project to compile the examples.
    For this chapter, you will need the `/Chapter02/spaceship.png` image file from
    the project directory. Please download the project from the following URL: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I highly recommend working along as you read each section of this chapter.
    You may use your favorite code editor and the command line to follow along. Even
    though we have provided links to download the code directly, it cannot be emphasized
    enough how much you will learn by actually following edits suggested in this chapter.
    You are going to make mistakes and learn a lot from them. If you decide to work
    along, another suggestion is the following: do not proceed to the next section
    unless your edit/steps in the current section are successful. If you need help,
    contact me on twitter (`@battagline`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Emscripten minimal shell file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new HTML shell and C file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining our CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 and game development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a canvas to the Emscripten template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Emscripten minimal shell file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first build we created with Emscripten used a default HTML shell file. If
    you have a website, this is probably not the way you would prefer your web page
    to look. You would probably prefer to design your look and feel using CSS and
    HTML5 specific to your design or business needs. For instance, the templates I
    use for my websites typically include advertisements to the left and right of
    the game's canvas. That is how traffic to these sites is monetized. You may choose
    to add a logo for your website above your game's canvas. There is also a text
    area where Emscripten logs output from `printf` or other standard IO calls. You
    may choose to remove this `textarea` element altogether, or you may keep it, but
    keep it hidden because it is useful for debugging later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the HTML file based on a new shell file that is not the default Emscripten
    shell, we must use the `--shell-file` parameter, passing it the new HTML template
    file we would like to use, instead of Emscripten''s default. The new `emcc` command
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not execute this command just yet. We do not currently have a `new_shell.html`
    file in our project directory, so running the command before that file exists
    will result in an error message. We need to create the `new_shell.html` file and
    use it as the HTML shell instead of Emscripten''s default HTML shell. This shell
    file must follow a specific format. To construct it, we have to start with Emscripten''s
    minimum HTML shell file, which you can find at GitHub here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/emscripten-core/emscripten/blob/master/src/shell_minimal.html](https://github.com/emscripten-core/emscripten/blob/master/src/shell_minimal.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be writing our own HTML shell, using the `shell_minimal.html` file
    as a starting point. Much of what is in the minimal shell is not required, so
    we will make some significant edits to it. We will remove much of the code to
    suit our purpose. When you open `shell_minimal.html` in your text editor, you
    will see that it starts with a standard HTML header and a `style` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code is based on the version of `shell_minimal.html` available at the time
    of writing. No changes to this file are anticipated. However, WebAssembly is evolving
    quickly. Unfortunately, we cannot say with complete certainty that this file will
    remain unchanged by the time you read this. As mentioned earlier, if you run into
    problems, please feel free to contact me on Twitter (`@battagline`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We remove this style tag so you can style your code any way you like. It is
    necessary if you like their spinner loading image and want to keep it, but it
    is preferable to yank all of this out and replace it with CSS loaded externally
    from a CSS file with the link tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Scroll down a little further, and you will see the loading indicators they
    use. We are going to replace that with our own eventually, but for now, we are
    testing all of this locally, and our files are all tiny, so we would remove this
    code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, there is an HTML5 `canvas` element and some other tags related
    to it. We will eventually need to add a `canvas` element back in, but for now,
    we will not be using the `canvas`, so that part of the code is not necessary either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `canvas`, there is a `textarea` element. That is also not necessary,
    but it would be good to use it as the location where any `printf` commands executed
    from my C code are printed. The shell has surrounded it with two `<hr/>` tags,
    used for formatting, so we can remove those as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we have is our JavaScript. That starts with three variables
    that represent HTML elements that we removed earlier, so we are going to need
    to remove all of those JavaScript variables as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Module` object inside JavaScript is the interface that the Emscripten-generated
    JavaScript *glue* code uses to interact with our WebAssembly module. It is the
    most crucial part of a shell HTML file, and it is essential to understand what
    it is doing. The `Module` object begins with two arrays, `preRun`, and `postRun`.
    These are arrays of functions that will run before and after the module is loaded,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For demonstration purposes, we could add functions to these arrays like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This would produce the following output from our hello WASM app that we created
    in [Chapter1](2a47a921-b081-4857-9040-de3ff6298a43.xhtml), *Introduction to WebAssembly
    and Emscripten*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `preRun` and `postRun` functions run in the reverse order in
    which they are placed in the array. We could use the `postRun` array to call a
    function that would initialize our WebAssembly wrappers, but, for demonstration
    purposes, we will instead call a JavaScript function from within our C `main()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two functions inside the `Module` object are the `print` and `printErr`
    functions. The `print` function is used to print out the output of the `printf`
    calls to both the console and to the `textarea` that we have named `output`. You
    can change this `output` to print out to any HTML tag, but, if your output is
    raw HTML, there are several commented-out text replace calls that must run. Here
    is what the `print` function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `printErr` function is run by the glue code when an error or warning occurs
    in either our WebAssembly module or the glue code itself. The output of `printErr`
    is only the console, although, in principle, if you wanted to add code that would
    write to an HTML element, you could do that as well. Here is the `printErr` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After the `print` functions, there is a `canvas` function. This function is
    set up to alert the user to a lost WebGL context. We do not need that code right
    now, because we have removed the HTML Canvas. When we add the `canvas` element
    back in, we will need to restore this function. It also makes sense to update
    it to handle a lost context event, instead of just alerting the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are several different situations when your web page could lose its WebGL
    context. The context is your portal into the GPU, and your app's access to the
    GPU is managed by both the browser and the operating system. Let's take a trip
    to *The Land of Metaphor*, where we imagine the GPU is a bus, the web browser
    is the bus driver, and the apps using their context are a bunch of rowdy middle
    school kids. If the bus driver (browser) feels that the kids (apps) are getting
    too rowdy, he can stop the bus (GPU), throw all the kids off the bus (make the
    apps lose their context), and let them come back one at a time if they promise
    to behave.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the minimal shell has some code that keeps track of the module''s
    status and dependencies. In this code, we can remove references to the `spinnerElement`,
    `progressElement`, and `statusElement`. Later, if we choose, we can replace these
    with elements to keep track of the state of loaded modules, but, for the moment,
    they are not needed. Here is the status and run dependency monitoring code in
    the minimal shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The final piece of JavaScript code inside the minimal shell file determines
    what JavaScript will do in the event of a browser error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After our JavaScript, there is one more important line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This tag tells Emscripten to place the link to the JavaScript glue code here.
    Here is an example of what gets compiled into the final HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`shell-min.js` is the JavaScript glue code that is built by Emscripten. In
    the next section, we will learn how to create our own HTML shell file.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new HTML shell and C file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to create a new `shell.c` file that exposes several
    functions called from our JavaScript. We will also use `EM_ASM` to call the `InitWrappers`
    function that we will define inside the new HTML shell file that we will be creating.
    This function will create wrappers inside JavaScript that can call functions defined
    in the WebAssembly module. Before creating the new HTML shell file, we need to
    create the C code that will be called by the JavaScript wrappers inside the HTML
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the new `shell.c` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function runs when the WebAssembly module is loaded. At this point,
    the `Module` object can use `cwrap` to create a JavaScript version of that function
    that we can tie to `onclick` events on the HTML elements. Inside the `main` function,
    the `EM_ASM( InitWrappers() );` code calls an `InitWrappers()` function that is
    defined inside JavaScript in the HTML shell file. The DOM uses events to call
    the next four functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way we could have initialized the wrappers is by calling the `InitWrappers()`
    function from the `Module` object `postRun: []` array.'
  prefs: []
  type: TYPE_NORMAL
- en: We will tie a call to the `test()` function to a button click in the DOM. The
    `int_test` function will be passed as a value from an input field in the DOM and
    will print a message to the console and `textarea` element that includes that
    integer, by using a `printf` statement. The `float_test` function will be passed
    a number as a floating point, printed to the console and `textarea` element. The
    `string_test` function will print out a string that is passed in from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to add the following code to an HTML shell file and call it
    `new_shell.html`. The code is based on the *Emscripten minimal shell file* created
    by the Emscripten team and explained in the previous section. We will present
    the entire HTML page divided into four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, there is the beginning of the HTML file and the `head` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, is the beginning of the `body` tag. After that, we have several HTML
    `input` elements as well as the `textarea` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After our HTML, we have the beginning of our `script` tag, and some JavaScript
    code we have added to the default shell file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the `Module` object that we brought in from the default shell
    file. After the `Module` object, we have the end to the `script` tag, the `{{{
    SCRIPT }}}` tag, which is replaced by Emscripten when compiled, and the ending
    tags in our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These previous four sections all make up a single shell file called `new_shell.html`.
    You can create this code by typing out the last four parts into a file you name
    `new_shell.html`, or you can download the file from our GitHub page at [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly/blob/master/Chapter02/new_shell.html](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly/blob/master/Chapter02/new_shell.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen the entire `new_shell.html` file in large chunks, we
    can spend a little time breaking down the essential parts and going over it at
    a granular level. You will notice that we removed all of the CSS style code and
    have created a new `shell.css` file included with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have reworked the HTML code inside this file to create elements that
    will interact with the WebAssembly module. First, we are going to add a button
    that will call the `test()` function inside the WebAssembly module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will style the button and its included `div` element inside the `shell.css`
    file that we have created. We will need to define the function that will be called
    by the `onclick` event of this `button` element inside the JavaScript code we
    will write later. We will do something similar for the two input/button pairs
    we will define in the HTML, as demonstrated in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Like we did with the first `button` element, we will tie these next two buttons
    to functions that will make calls into the WebAssembly module. These function
    calls will also pass the values defined in the `input` elements into the WebAssembly
    functions. We have left the `textarea` element as an output for the `printf` calls
    that happen within the WebAssembly module. We have styled it differently in the
    CSS file, but we will leave the functionality unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Underneath the `textarea` element, we have added one more `button` and a `string`
    `input` element. This button will call the `string_test` function inside the WebAssembly
    module, passing it the value inside the `string_input` element as a C `char*`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined all of the elements we need in the HTML, we will go
    through and add some JavaScript code to tie the JavaScript and WebAssembly module
    together. The first thing we need to do is define the `InitWrappers` function.
    `InitWrappers` will be called from within the `main` function in the C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This function uses `Module.cwrap` to create JavaScript function wrappers around
    the exported functions inside the WebAssembly module. The first parameter we pass
    to `cwrap` is the name of the C function we are wrapping. All of these JavaScript
    functions will return `undefined`. JavaScript does not have a `void` type like
    C, so when we declare the `return` type in JavaScript, we need to use the `undefined`
    type instead. If the function were to return an `int` or a `float,` we would need
    to put the `'number'` value here. The final parameter passed into `cwrap` is an
    array of strings that represent the C type of the parameters passed into the WebAssembly
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have defined the JavaScript wrappers around the functions, we need
    to call them from the buttons. The first one of these calls is to the WebAssembly
    `int_test` function. Here is how we set the `onclick` event for the `int_button`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we will do is check to see whether `int_test` is defined. If
    so, we call the `int_test` wrapper we explained earlier, passing it the value
    from the `int_num` input. We then do something similar for all of the other buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we do is create a `runbefore` and `runafter` function that we
    place in the `preRun` and `postRun` arrays on the `Module` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That will cause "before module load" to be printed to the console before the
    module is loaded, and "after module load" is printed after the module is loaded.
    These functions are not required; they are designed to show how you might run
    code before and after a WebAssembly module is loaded. If you do not want to call
    the `InitWrappers` function from the `main` function in the WebAssembly module,
    you could instead put that function inside the `postRun` array.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the JavaScript code is similar to what you would find inside
    the `shell_minimal.html` file created by Emscripten. We have removed code that
    is superfluous for this demonstration, such as code related to the `spinnerElement`,
    `progressElement`, and `statusElement`, as well as code having to do with the
    HTML5 `canvas`. It is not that there is anything wrong with leaving that code
    in JavaScript, but it is not truly necessary for our demonstration, so we have
    removed it to reduce this shell to the minimum required.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have some basic HTML, we need to create a new `shell.css` file.
    Without any CSS styling, our page looks pretty terrible.
  prefs: []
  type: TYPE_NORMAL
- en: 'A page without styling will be similar to the one shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8b0d833-eab2-4125-9705-d44e21ddf664.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The Hello WebAssembly app without a CSS style'
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, a little bit of CSS goes a long way to make our web page look
    presentable. Here is what the new `shell.css` file we are creating looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let me quickly walk through what we need to do to style this page. This book
    is not a book on CSS, but it does not hurt to cover the topic in a cursory fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will do is put a little 20-pixel margin on the page body
    to put a little bit of space between the browser toolbar and the content on our
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created five input boxes that take up `20%` of the browser width each.
    The boxes on the left and the right have nothing in them, so that the content
    takes up 60% of the browser width. They are displayed as an inline-block, so that
    they line up horizontally across the screen. Here is the CSS that makes it happen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have a few classes to style our buttons using a class called `em_button`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have set the button width to take up `45%` of the containing element. We
    set the button height to 40 pixels. We have set the button's color to `orangered`,
    and the text color to `white`. We remove the border by setting its width to 0
    pixels. We have set the font size to 20 pixels and given it an 8 pixel border-radius,
    which provides the button with a rounded look. The last line sets the amount of
    time it takes to transition to a new color when the user hovers over the button.
  prefs: []
  type: TYPE_NORMAL
- en: After we finish the definition of the `em_button` class, we define the `em_button:hover`
    class, which changes the color of the button when the user hovers over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some versions of Safari require the line `-webkit-transition-duration: 0.2s;`
    inside the `em_button` class definition to have a transition to the hover state.
    Without this line, the button would instantly change from `orangered` to `orange`
    in some versions of Safari, rather than transitioning over 200 milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next class we define is for the `input` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We have set its `height`, `width`, and `font-size` at the beginning. We set
    the background color to a `darkslategray` with `white` text. We have added `6`
    pixels of padding so that there is a small space between the font and the edge
    of the `input` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#` in front of the name of a CSS element styles an ID instead of a class.
    An ID defines a specific element where a class (preceded by a `.` in CSS) can
    be assigned to multiple elements in your HTML. The next bit of CSS styles the
    `textarea` that has the ID of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two lines set the background and text color. We set the font size
    to `16` pixels and add `10` pixels of padding. The next two lines use the left
    and right margin to center the `textarea`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting `display: block;` puts this element on a line by itself. Setting the
    width to `60%` makes the element take up `60%` of the containing element, which,
    in this case, is the browser''s `body` tag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we style the `string_box` and `string_input` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `string_box` is the box that contains the string button and the string
    input elements. We pad the top of the box to add some space between the `string_box`
    and the `textarea` above it. `margin-left: auto` and `margin-right: auto` center
    the box. Then, we use `display:block` and `width: 60%` to have it take up `60%`
    of the web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `string_input` element, we set the font size and the colors and pad
    it by 6 pixels. We set a left margin of 5 pixels to put some space on the left
    between the element and its button. We set it to take up `45%` of the width of
    the containing element, while the `float: right` style pushes the element to the
    right side of the containing element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To build our app, we need to run `emcc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`EXPORTED_FUNCTIONS` is used to define all of the functions called from JavaScript.
    They are listed with a preceding `_` character. `EXTRA_EXPORTED_RUNTIME_METHODS`
    is used to make the `cwrap` and `ccall` methods available to the JavaScript inside
    our shell file. We are not currently using `ccall`, which is an alternative to
    `cwrap`, which we may choose to use in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that you must run WebAssembly apps using a web server,
    or with `emrun`. If you would like to run your WebAssembly app using `emrun`,
    you must compile it with the `--emrun` flag. The web browser requires a web server
    to stream the WebAssembly module. If you attempt to open an HTML page that uses
    WebAssembly in a browser directly from your hard drive, that WebAssembly module
    will not load.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added some CSS styling, we have a much nicer looking app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8381064-6edf-40d8-8e9d-2f1e4f4b678c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: The Hello WebAssembly app with a CSS style'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss HTML5 web game development.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 and game development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most HTML rendering is done through the HTML **Document Object Model** (**DOM**).
    The DOM is what is known as a *retained mode* graphical library. Retained mode
    graphics retain a tree known as a **scene graph**. This scene graph keeps track
    of all the graphical elements in our model and how to render them. The nice thing
    about retained mode graphics is that they are straightforward for a developer
    to manage. The graphical library does all the heavy lifting and keeps track of
    our objects for us as well as where they render. The downside is that a retained
    mode system takes up a lot more memory and provides a lot less control to the
    developer. When we write HTML5 games, we could take images rendered in the DOM
    using `<IMG>` HTML elements and move those elements around using JavaScript or
    CSS animations to manipulate the positions of those images within the DOM directly.
  prefs: []
  type: TYPE_NORMAL
- en: However, this would, in most circumstances, make the game painfully slow. Every
    time we move an object in our DOM, it forces our browser to recalculate the position
    of all other objects within our DOM. Because of this, manipulating objects from
    within our DOM to make web games is usually a non-starter.
  prefs: []
  type: TYPE_NORMAL
- en: Immediate mode versus retained mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Immediate mode is frequently thought of as the opposite of retained mode, but,
    in practice, when we write code for an immediate mode system, we may build on
    top of an API that gives us some of the functionality of a retained mode library.
    Immediate mode forces the developer to do all or most of the heavy lifting done
    by a retained mode library. We, as developers, are forced to manage our scene
    graph, and understand what graphical objects we need to render and how and when
    those objects must render. In short, it is a lot more work, but if done well,
    the payoff is a game that will render much faster than what is possible to render
    using the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be asking yourself right now: *How do I go about using this Immediate
    Mode thingy*? Enter the HTML5 Canvas! In 2004, Apple Inc. developed the canvas
    element as an immediate mode display tag for Apple''s proprietary browser technology.
    The canvas partitions off a section of our web page, which allows us to render
    to that area using immediate mode rendering. That will enable us to render to
    a part of the DOM (the canvas) without requiring the browser to recalculate the
    position of all the elements from within the DOM. That allows the browser to optimize
    the rendering of the canvas further, using the computer''s **Graphical Processing
    Unit** (**GPU**).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a canvas to the Emscripten template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an earlier part of this chapter, we discussed making calls to the Emscripten
    WebAssembly app from a shell template. Now that you know how to make the interaction
    work between JavaScript and WebAssembly, we can add a `canvas` element back into
    the template and start to manipulate that `canvas` using the WebAssembly module.
    We are going to create a new `.c` file that will call a JavaScript function passing
    it an `x` and `y` coordinate. The JavaScript function will manipulate a spaceship
    image, moving it around the `canvas`. We will also create a brand new shell file
    called `canvas_shell.html`.
  prefs: []
  type: TYPE_NORMAL
- en: As we did for the previous version of our shell, we will start by breaking this
    file down into four sections to discuss it at a high level. We will then discuss
    the essential parts of this file a piece at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beginning of the HTML file starts with the opening `HTML` tag and the `head`
    element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we have the opening `body` tag, and we have removed many of the
    HTML elements that we had in the earlier version of this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, there is the opening `script` tag, a few global JavaScript variables,
    and a few new functions that we added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After the new JavaScript functions, we have the new definition of the `Module`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The last few lines close out our tags and include the `{{{ SCRIPT }}}` Emscripten
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Those previous four blocks of code define our new `canvas_shell.html` file.
    If you would like to download the file, you can find it on GitHub at the following
    address: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly/blob/master/Chapter02/canvas.html](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly/blob/master/Chapter02/canvas.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have looked at the code at a high level, we can look at the source
    in more detail. In the `head` section of the HTML, we are changing the `title`
    and the `name` of the CSS file that we are linking. Here is the change in the
    HTML `head`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not need most of the elements that were in the previous `<body>` tag.
    We need a `canvas`, which we had removed from the `shell_minimal.html` file provided
    by Emscripten, but now we need to add it back in. We are keeping the `textarea`
    that was initially in the minimal shell, and we are adding a new `img` tag that
    has a spaceship image taken from a TypeScript canvas tutorial on the [embed.com](https://www.embed.com)
    website at [https://www.embed.com/typescript-games/draw-image.html](https://www.embed.com/typescript-games/draw-image.html).
    Here are the new HTML tags in the `body` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to change the JavaScript code. The first thing we are going
    to do is add three variables at the beginning to hold a reference to the `canvas`
    element, the canvas context, and the new spaceship `img` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we are adding to the JavaScript is a function that renders the
    spaceship image to the canvas at a given `x` and `y` coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This function first checks to see whether the `img` variable is a value other
    than `null`. That will let us know if the module has been loaded or not because
    the `img` variable starts set to null. The next thing we do is clear the canvas
    with the color black using the `ctx.fillStyle = “black”` line to set the context
    fill style to the color `black`, before calling `ctx.fillRect` to draw a rectangle
    that fills the entire canvas with a black rectangle. The next four lines save
    off the canvas context, translate the context position to the ship's `x` and `y`
    coordinate value, and then draw the ship image to the canvas. The last one of
    these four lines performs a context restore to set our translation back to (0,0)
    where it started.
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining this function, the WebAssembly module can call it. We need to
    set up some initialization code to initialize those three variables when the module
    is loaded. Here is that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `ModuleLoaded` function uses `getElementById` to set `img` and `canvas`
    to the spaceship and `canvas` HTML elements, respectively. We will then call `canvas.getContext(”2d”)`
    to get the 2D canvas context and set the `ctx` variable to that context. All of
    this gets called when the `Module` object finishes loading because we added the
    `ModuleLoaded` function to the `postRun` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also added back the `canvas` function that was on the `Module` object
    in the minimum shell file, which we had removed along with the canvas in an earlier
    tutorial. That code watches the canvas context and alerts the user if that context
    is lost. Eventually, we will want this code to fix the problem, but, for now,
    it is good to know when it happens. Here is that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To go along with this new HTML shell file, we have created a new `canvas.c`
    file to compile into a WebAssembly module. Be aware that, in the long run, we
    will be doing a lot less in our JavaScript and a lot more inside our WebAssembly
    C/C++ code. Here is the new `canvas.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: To start, we create a `ship_x` and `ship_y` variable to track the ship's *x*
    and *y* coordinates. After that, we create a `MoveShip` function. This function
    increments the ship's *x* position by `2` and the ship's *y* position by `1` each
    time it is called. It also checks to see whether the ship's x coordinates have
    left the canvas on the right side, which moves it back to the left side if it
    has, and does something similar if the ship has moved off the canvas on the bottom.
    The last thing this function does is call our JavaScript `ShipPosition` function,
    passing it the ship's *x* and *y* coordinates. That final step is what will draw
    our spaceship to the new coordinates on the HTML5 canvas element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new version of our `main` function, we have the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This line turns the function passed in as the first parameter into a game loop.
    We will go into more detail about how `emscripten_set_main_loop` works in a later
    chapter, but for the moment, know that this causes the `MoveShip` function to
    be called every time a new frame is rendered to our canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will create a new `canvas.css` file that keeps the code for the
    `body` and `#output` CSS and adds a new `#canvas` CSS class. Here are the contents
    of the `canvas.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After everything is complete, we will use `emcc` to compile the new `canvas.html`
    file as well as `canvas.wasm` and the `canvas.js` glue code. Here is what the
    call to `emcc` will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Immediately after `emcc`, we pass in the name of the `.c` file, `canvas.c`,
    which will be used to compile our WASM module. The `-o` flag tells our compiler
    that the next argument will be the output. Using an output file with a `.html`
    extension tells `emcc` to compile the WASM, JavaScript, and HTML files. The next
    flag passed in is `--shell-file`, which tells `emcc` that the argument to follow
    is the name of the HTML shell file, which will be used to create the HTML file
    of our final output.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that you must run WebAssembly apps using a web server,
    or with `emrun`. If you would like to run your WebAssembly app using `emrun`,
    you must compile it with the `--emrun` flag. The web browser requires a web server
    to stream the WebAssembly module. If you attempt to open an HTML page that uses
    WebAssembly in a browser directly from your hard drive, that WebAssembly module
    will not load.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of `canvas.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8f3036f-4633-49d4-85ac-8e6324bebfa5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Our first WebAssembly HTML5 canvas app'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the Emscripten minimal shell HTML file, what its
    various components are, and how they work. We also wrote about what parts of the
    file we can do without, if we are not using our shell to generate canvas code.
    You learned about the `Module` object, and how it is the interface that uses the
    JavaScript glue code to tie the JavaScript in our HTML and our WebAssembly together.
    We then created a new WebAssembly module that contained functions we exported
    to allow JavaScript to use `Module.cwrap` to create JavaScript functions we could
    then call from our DOM that executes our WebAssembly functions.
  prefs: []
  type: TYPE_NORMAL
- en: We created a brand new HTML shell file that used some of the `Module` code from
    the Emscripten minimal shell, but rewrote the HTML and CSS of the original shell
    almost entirely. We were then able to compile that new C code and HTML shell file
    into a working WebAssembly app that was able to call WebAssembly functions from
    JavaScript, as well as call JavaScript functions from WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the benefits of using the HTML5 canvas element, and the differences
    between immediate and retained mode graphics. We also explained why it makes sense
    for games and other graphics-intensive tasks to use immediate mode instead of
    retained mode.
  prefs: []
  type: TYPE_NORMAL
- en: We then created a shell file to make use of the HTML5 canvas element. We added
    JavaScript code to draw an image to the canvas and wrote C code that used WebAssembly
    to modify the position of that image on the canvas every frame creating the appearance
    of a moving spaceship on the HTML5 canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce you to WebGL, what it is, and how it
    improves graphics rendering on the web.
  prefs: []
  type: TYPE_NORMAL
