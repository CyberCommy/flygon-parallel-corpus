- en: Chapter 7. Redis in Business Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Redis in Web Applications"), *Redis in
    Web Applications*, you saw how Redis can be useful in web applications. This usefulness
    of Redis can be extended to business applications. As with any enterprise, the
    outer layer or the boundary application usually comprises of a web application,
    which in a way encapsulates the core heterogeneous business applications. These
    business applications form the core backbone of the enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: '![Redis in Business Applications](img/0123OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simple representation of application in an enterprise ecosystem
  prefs: []
  type: TYPE_NORMAL
- en: As many of you will have experienced in your projects and assignments over the
    years, these business applications are as varied as one can imagine in their business
    functionality. However, they all share some features and aspects that are common
    to most of them. In this chapter, we will take a few of these features and see
    how Redis fits into the landscape of business applications. To begin with, the
    most common and humble feature in any application is **configuration management**.
  prefs: []
  type: TYPE_NORMAL
- en: The subsequent topic takes into consideration configuration management and puts
    in Redis as a core component in constructing an enterprise-level application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very often, you may have seen improper configuration management or the lack
    of it create problems at a later point in the development and maintenance life
    cycles. Another problem is when scalability comes into picture and more nodes
    of software are added; then, maintaining state across all the nodes becomes a
    challenge. Business applications have been relying on RDBMS to store configuration
    data. The problem with this approach is performance; if the design is **PULL**-based
    and the problem with **PULL**-based design is performance penalty. Another problem
    is if the concurrency is high (because of other business functionalities), then
    these RDBMS also have to cater to these requests as well as the requests for configuration
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration management](img/0123OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: PULL-based design for config management
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to convert the design from **PULL**-based to **PUSH**-based. The
    big advantage of this technique is performance. The state or configuration data
    stays close to the application, and whenever change takes place, the data is pushed
    to the local cache of the application. Another requirement is to have a system
    that is low on the compute resource footprint.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration management](img/0123OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: PUSH-based design for config management
  prefs: []
  type: TYPE_NORMAL
- en: Redis with its Swiss knife-like capability, low resource footprint, availability
    of client libraries in various languages, and capability to scale massively makes
    it a good candidate to be used to take care of this requirement. The sample application
    that we are going to discuss in subsequent topics will highlight that. This sample
    application is just for demo and does not take any guarantee in the production
    environment. So, let's have some fun developing one configuration management server
    with Redis as the backbone, and let's call it the **gossip server**.
  prefs: []
  type: TYPE_NORMAL
- en: Gossip server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The gossip server is a centralized node that manages configuration data and
    groups services in a synchronized way. The **Gossip Server** will hold data and
    will be managed by a node called the **Gossip Server (Admin)**. The **Gossip Server**
    in turn will manage all the other nodes hooked to it. The following diagram depicts
    that it is the responsibility of the gossip server to push configuration data
    to all the nodes that are connected to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Gossip server](img/0123OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Gossip Server design overview
  prefs: []
  type: TYPE_NORMAL
- en: Internal to this gossip server is the Redis server, which provides all the capabilities
    that might be required by the proposed configuration management system. The nodes
    can be implemented in any programming language, but keeping in tradition with
    the examples in the book, we are going to use Java as the language of implementation
    in this example. The main idea of this gossip server is to keep aside a common
    component for configuration management the next time that you need to architect
    or design an enterprise grade solution, and to keep in mind Redis when doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the implementation and design specifications of our common
    component, let's agree upon the capabilities of this gossip server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the capabilities of the gossip server:'
  prefs: []
  type: TYPE_NORMAL
- en: The gossip server maintains all the information or configuration data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It acts like a hub and distributes the information or configuration data to
    all the connected nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the nodes, including the master node, connect to the hub in order to send
    messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The master node is responsible for pushing data to a specific client node or
    all the client nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the client nodes are in the same position in the hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the client nodes can be embedded in the solutions that are to be made a
    part of this configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nodes have a life cycle and they are managed by themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nodes, when they change state, inform the master and other peer client nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nodes can also send messages to other peer nodes if the business logic demands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A node in the gossip server is the client component between which all the messages
    flow. In the current example, the node can be classified into two types, client
    nodes and the master node.
  prefs: []
  type: TYPE_NORMAL
- en: The client node is inherently meant to be the component that can be plugged
    into any solution where there is a need for configuration management. The client
    nodes are responsible for the application data that they store in Redis. Data
    in the node can come either from the application they are plugged into or from
    the master node, which can push the data to the client node. The whole idea behind
    allowing the master node to push data or rather publish data into the gossip server
    is to spread the control of the configuration data of the application from the
    application itself to another source. The benefit of doing this will be to take
    out the responsibility of the configuration data management from the application
    and have a centralized node from where data can be managed. Another advantage
    is that new configuration data can be introduced into the application at runtime
    without stopping the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a representation of the configuration data pushing
    capability of the gossip server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Node](img/0123OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pushing data into Gossip Server either via application or master node
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go further into the implementation, it''s better to understand the
    various states that the client node can traverse in its life cycle. The following
    diagram is a snapshot of the various paths that the client node can take:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Node](img/0123OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pushing data into Gossip Server either via application or master node
  prefs: []
  type: TYPE_NORMAL
- en: The client node begins its journey with **Register**. After **Register**, the
    client node needs to **Activate** itself. Once the client node is activated, it
    can either **Passivate** itself or reach the **Archive** state. The **Archive**
    state can be achieved if the application is brought down or a `Kill` command is
    sent by the master node. Once the client node is in the **Passivate** state, it
    can be made **Activate** through an intermediate state of **Reactivate**. If the
    client node is in the **Archive** state, it can be brought to the **Activate**
    state via an intermediary state of **Reconnect**.
  prefs: []
  type: TYPE_NORMAL
- en: The commands for the client node are modelled around the mentioned states, and
    there are other commands for the management of data and for messaging data around
    the ecosystem. Without wasting much time, let's dive into the design of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Layered design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The design for the gossip server is minimalistic and very simple to follow,
    but there are certain considerations to be kept in mind. As discussed, the nodes
    participating in the gossip server are of two types: client nodes and master nodes.
    Every client node is responsible for its own life cycle, and the master node has
    limited control over it. The nodes can communicate with each other by passing
    messages. The design includes four primary layers, as depicted in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layered design](img/0123OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Gossip Server structural layers overview
  prefs: []
  type: TYPE_NORMAL
- en: 'The packages in the gossip server correspond to the layers described in the
    preceding diagram and include a few extra. Let''s have a brief introduction of
    the packages and the classes they contain. Here''s a list of the packages and
    the layers they correspond to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.redisch7.gossipserver.shell`: This corresponds to the **Shell layer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.redisch7.gossipserver.commands`: This corresponds to the **Command layer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.redisch7.gossipserver.commandhandlers`: This corresponds to the **Command
    Handler layer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.redisch7.gossipserver.datahandler`: This corresponds to the **Data Handler
    layer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.redisch7.gossipserver.util.commandparser`: This is a utility package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Shell is a program that acts like a standalone gateway to the gossip server
    as well as a plugin to an application that wants to use the gossip server. The
    shell activates the node, which in turn prepares the listeners and the command
    library for the node. As discussed, there are two types of nodes: client nodes
    and master nodes; a detailed discussion of these nodes is done in the latter portion
    of the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shell](img/0123OS_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Interaction with shell
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the gossip server is simple and basically commands delegation
    to the node for processing. In the case of Shell as a standalone program, the
    response is displayed in Command Prompt, whereas in the case of Shell as an API
    plugin, the result object `CheckResult` is passed back to the program calling
    it. Shell is implemented as a singleton. This is the code for `Shell.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Listeners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Listeners are spawned by nodes and execute independently of the thread executing
    the Shell. The basic job of a listener is to constantly listen for any message
    event coming to the node. The message is then parsed and executed accordingly.
    The basic idea is to provide a mechanism for the nodes to interact with each other.
    In the current implementation, it's the master node that interacts with the client
    nodes. This provides a limited remote control of the master over the client nodes.
    The implementation for the other way around communication is not done and can
    be incorporated easily if the need arises, that is, if the client nodes interact
    with the master node. Not all commands can be remotely executed on client nodes
    via this arrangement. Commands that can be executed remotely (by the master node)
    are `SET`, `KILL`, and `CLONE`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Listeners](img/0123OS_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Relation between Node, Message Listener Manager, Meassage Listeners, and Subscriber
  prefs: []
  type: TYPE_NORMAL
- en: Listeners internally have a subscriber that extends the `JedisPubSub` abstract
    class, which is Jedis's client library's hook to Redis's messaging capability.
    The node maintains the life cycle of the listeners. The node activates the listeners
    on some commands, such as **Activate**, **Reconnect**, and so on, and deactivates
    on some commands, such as `Passivate`, `KILL`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for the client listener, which is `ClientEventMessageListener`.Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the code for the master listener, that is, `MasterEventMessageListener.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Listener manager
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Listener managers** are responsible for maintaining the life cycle of the
    listeners. Listeners can either exist in the start mode or in the stop mode. The
    gossip server has an event-oriented design; therefore, on every event that the
    client node accepts, there is a corresponding command that gets executed.'
  prefs: []
  type: TYPE_NORMAL
- en: In the system, there are two types of listener managers, one for the client
    node called the client node listener manager and the other for the master node
    called master node listener manager.
  prefs: []
  type: TYPE_NORMAL
- en: The client node listener manager is programmed to start the listeners on commands
    such as `Activate`, `Reactivate`, and `Reconnect` and to stop the listeners on
    commands such as `Passivate` and `Kill`.
  prefs: []
  type: TYPE_NORMAL
- en: The master node listener manager is programmed to start the listener on commands
    such as `Start` and to stop on commands such as `Stop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for `ClientNodeListenerManager.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the code for `MasterNodeListenerManager.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The data handler layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This layer or package is straightforward in its activity, such as interacting
    with the Redis server. This layer is responsible for encapsulating Redis from
    the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![The data handler layer](img/0123OS_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Gossip Server structural layers overview
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the data structures used for the current application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Registration holder**: This is going to be implemented as a Set in the Redis
    datastore. This will hold all the nodes that are going to be registered in the
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Activation holder**: This is going to be implemented as a Set in the Redis
    data store. This will hold all the nodes that are going to be in the `Active`
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Passivation holder**: This is going to be implemented as a Set in the Redis
    data store. This will hold all the nodes that are going to be in the **Passive**
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration store**: This is going to be implemented as a Map in the Redis
    data store. This will hold all the configuration data pertaining to a node in
    the name-value format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Archive store**: This is going to be implemented as a File store in the local
    file system of the client node. This will hold all the configuration data pertaining
    to a node in the name-value format that is going to be archived in the JSON format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important class in this layer is `JedisUtilImpl`; let's spend some
    time understanding this class. The very nature of this class makes this class
    pretty big but easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: JedisUtil.java
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This class is instrumental in conversing with the data store. All the logic
    around managing the account, state, and data of a node is managed here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we are using `jedis_2.1.0` as our choice of client API in order to
    connect to Redis. There is a bug related to using `MULTI` in `PIPELINE` functions
    with this version of the client library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since Redis is single-thread server, we have sacrificed the use of `MULTI` in
    `PIPELINE` for this application, as this will have no implications on the sanctity
    of the data in Redis and minimally affect the performance. We have gone ahead
    with sending our commands singularly and not in bulk, as in the case of `PIPELINE`.
    The future API of Jedis might have a solution for this, and it is up to you to
    change the class as you see fit if you are using a newer version of Jedis.
  prefs: []
  type: TYPE_NORMAL
- en: Client implementation in other languages or other client implementations for
    Redis in Java, will not have a problem as this is specific to Jedis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an understanding of the `JedisUtil` class, we in a way understand
    the working of the gossip server and the capabilities that the gossip server has
    to offer. So, let''s focus on the commands and how they are implemented. As a
    rule of thumb, the flow of data can be summarized as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JedisUtil.java](img/0123OS_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in a command
  prefs: []
  type: TYPE_NORMAL
- en: Client node commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of commands that can be fired from client nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `register` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `activate` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `set` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `status` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `del` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `passivate` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reacyivate` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `archive` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sync` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reconnect` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each command from a design and implementation perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The register command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command will register the node into the gossip server ecosystem. The precondition
    for executing this command is that the node name should be unique; otherwise,
    a response of failure will be sent to the **Shell**. The node name will be stored
    in the Registration holder, which is implemented as a Set data structure in Redis.
    Apart from this, when the registration process takes place, an archive file is
    created in the local machine of the node.
  prefs: []
  type: TYPE_NORMAL
- en: '![The register command](img/0123OS_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in a Register command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `register`. The following screenshot shows
    the response in the Shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The register command](img/0123OS_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of RegisterCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The RegisterCommand is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of RegisterCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The RegisterCommandHandler is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The activate command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command will activate the node into the gossip server ecosystem. The precondition
    for executing this command is that the node should be registered. When the node
    is activated, an entry is added to the ACTIVATION-HOLDER, which is implemented
    as Set in Redis. Apart from this, on activation, the client node will spawn listeners,
    which will be up and ready to listen to any event that can come from the master.
    The listeners will be basically listening for events on a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: '![The activate command](img/0123OS_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Activate command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `activate`. The following screenshot shows
    the response in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activate command](img/0123OS_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of ActivateCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ActivateCommand is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of ActivateCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ActivateCommandHandler is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The set command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command will set the data in the nodes. The precondition for executing
    this command is that the node should be in the activated state. The command is
    going to insert the name values into the node's *Config-store*. The *Config store*
    is implemented as the Hashes data structure in Redis. As evident, multiple name-value
    pairs can be inserted in the *Config store*.
  prefs: []
  type: TYPE_NORMAL
- en: '![The set command](img/0123OS_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Set command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `set <name=value>,<name=value>`. The following
    screenshot shows the response in the Shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The set command](img/0123OS_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of SetCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SetCommand is implemented as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of SetCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `set` command handler is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The get command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command will get the data from the nodes. The precondition for executing
    this command is that the node should be in the activated state. The input will
    be a list of variables and the data needs to be picked up from the Config store.
    Every node will have its own Config store.
  prefs: []
  type: TYPE_NORMAL
- en: '![The get command](img/0123OS_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Get command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax foe this command is: `get`. The following screenshot shows the response
    in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The get command](img/0123OS_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of GetCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The GetCommand is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of GetCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `get` command handler is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The del command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command will delete the data in the nodes. The precondition for executing
    this command is that the node should be activated. The command will be executed
    by passing the name of the variable that needs to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '![The del command](img/0123OS_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Delete command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `del <parameter>`. The following screenshot
    shows the response in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The del command](img/0123OS_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of DeleteCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The DeleteCommand is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of DeleteCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `delete` command handler is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The status command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command is used to get the current status of a node. The precondition for
    executing this command is that the node should be in some state. The command in
    the client focuses on the data of the client node.
  prefs: []
  type: TYPE_NORMAL
- en: '![The status command](img/0123OS_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Passivate command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `status`. The following screenshot shows the
    response in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The status command](img/0123OS_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of StatusCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `status` command is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of StatusCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `passive` command handler is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The passivate command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command will passivate the node into the gossip server ecosystem. The precondition
    for executing this command is that the node should be in the activated state.
    On passivation, the client's event listeners will be shut down and will not be
    in a position to take events from the master. Since the node is passivated, the
    data in the node's Config store will be taken and pushed into the archive file
    of the node.
  prefs: []
  type: TYPE_NORMAL
- en: '![The passivate command](img/0123OS_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Passivate command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `passivate`. The following screenshot shows
    the response in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The passivate command](img/0123OS_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of PassivateCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `passivate` command is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of PassivateCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `passivate` command handler is implemented as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The reactivate command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command will reactivate the node. The precondition for executing this command
    is that the node should be in the passive mode. Upon reactivation, the client's
    event listener will be spawned once again. The data in the archive file will be
    pumped back again to the node's Config store.
  prefs: []
  type: TYPE_NORMAL
- en: '![The reactivate command](img/0123OS_07_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Reactivate command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `reactivate`. The following screenshot shows
    the response in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The reactivate command](img/0123OS_07_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of ReactivateCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `passivate` command is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of ReactivateCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `reactivate` command handler is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The archive command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This `command` will archive the data of a node in the gossip server ecosystem.
    The precondition for executing this command is that the node should be in the
    registered mode. When this command is issued, the data in the node's Config store
    will be flushed and put into an archive file in the filesystem of the client node's
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: '![The archive command](img/0123OS_07_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Archive command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `archive`. The following screenshot shows the
    response in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The archive command](img/0123OS_07_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of ArchiveCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `archive` command is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of ArchiveCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `reactive` command handler is implemented as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The sync command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sync` command will synchronize the data of a node in the gossip server
    ecosystem. The precondition for executing this command is that the node should
    be in the registered mode. When this command is issued, the data in the archive
    file is pumped back into the Config store of the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![The sync command](img/0123OS_07_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Sync command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of this command is: `sync`. The following screenshot shows the response
    in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The sync command](img/0123OS_07_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of SyncCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `sync` command is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of SyncCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `sync` command handler is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The reconnect command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `reconnect` command will reconnect a node in the gossip server ecosystem.
    The precondition for executing this command is that the node should be in the
    activated state and the node should have undergone a shut down. So, when the node
    comes up after the shut down and this command is fired, then the listeners for
    the client node will get spawned and the node will be back in the activated state.
  prefs: []
  type: TYPE_NORMAL
- en: '![The reconnect command](img/0123OS_07_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Reconnect command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `reconnect`. The following screenshot shows
    the response in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The reconnect command](img/0123OS_07_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of ReconnectCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `reconnect` command is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of ReconnectCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `reconnect` command handler is implemented as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Master node commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of commands that can be fired from the master nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `start` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `status` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `msg` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `kill` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `clone` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `stop` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each command from a design and implementation perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The start command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `start` command will start the master node in the gossip server ecosystem.
    The precondition for executing this command is that the node name should be unique.
  prefs: []
  type: TYPE_NORMAL
- en: '![The start command](img/0123OS_07_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Start command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `start`. The following screenshot shows the
    response in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The start command](img/0123OS_07_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of StartMasterCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `start` command is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The stop command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `stop` command will stop the master node in the gossip server ecosystem.
    The precondition for executing this command is that the node should be in the
    start mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![The stop command](img/0123OS_07_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Start command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this code is: `stop`. The following screenshot shows the response
    in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The stop command](img/0123OS_07_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of StopMasterCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `stop` command is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The status command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `status` command will show the current status of a node in the gossip server
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: '![The status command](img/0123OS_07_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Status command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `status`. The following screenshot shows the
    response in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The status command](img/0123OS_07_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of StatusCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `status` command is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of StatusCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `status` command handler is implemented as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The get command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `get` command will display the state of all the nodes that are registered
    in the gossip server ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `get <field1>,<field2> where nodes are <nodename1>,<nodename2>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the response in the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The get command](img/0123OS_07_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of GetNodeDataCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `get` command is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of GetNodeDataCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `get` command handler is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The msg command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `msg` command is used to send messages to the nodes in the gossip server
    ecosystem. The precondition for executing this command is that the master node
    should be in the start mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![The msg command](img/0123OS_07_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Message command
  prefs: []
  type: TYPE_NORMAL
- en: '![The msg command](img/0123OS_07_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Messaging between master and client nodes
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `mgs <node name> where command = set, field
    1, field 2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the response in the master shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The msg command](img/0123OS_07_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The response in the client node (`vinoo`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The msg command](img/0123OS_07_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of MessageCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `MessageCommand` is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of MessageCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `messageCommandHandler` is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The kill command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `kill` command is used to kill a node in the gossip server ecosystem. The
    precondition for executing this command is that the master node should be in the
    start mode. Here we'll do it via the `msg` command.
  prefs: []
  type: TYPE_NORMAL
- en: '![The kill command](img/0123OS_07_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Kill command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this command is: `mgs <node name> where command = kill`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the response in the master shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The kill command](img/0123OS_07_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The response in the client node (`vinoo`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The kill command](img/0123OS_07_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of KillNodeCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `kill` command is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of KillNodeCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Kill` command handler is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The clone command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `clone` command is used to make a clone of a node in the gossip server ecosystem.
    The precondition for executing this command is that the master node should be
    in the start mode and a minimum of two client nodes should be in the activated
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![The clone command](img/0123OS_07_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of flow of data in Clone command
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this code is: `mgs <node name> where command = clone, target
    =<node name>, source=<node name>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the response in the master shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The clone command](img/0123OS_07_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the response in the client node (`loki`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The clone command](img/0123OS_07_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, all the attributes in the source node will be copied to the target
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of CloneNodeCommand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `clone` command is implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of CloneNodeCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `cloneCommandHandler` is implemented as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Redis configuration – data management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To manage data in Redis, it''s important to understand the application we are
    trying to build. Since the gossip server is meant to be a Config server, the reads
    are will be more than the writes. Redis provides a couple of data persistence
    mechanisms that we have already dealt with in the previous chapters, and the current
    section can act as a refresher. The mechanisms that Redis provides are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The RDB option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AOF option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VM over commit memory (LINUX environments only)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RDB option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The RDB option provides a mechanism to take a snapshot of the data at regular
    intervals. Since this is a periodic activity, which dumps the data into the `dump.rdb`
    file, it makes it a good option to take data backups. For our current application,
    the configuration in the `redis.conf` file for RDB can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`save 60 10`: This will save data every 1 minute if 10 keys have changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save 900 10`: This will save data every 15 minutes if 1 key has changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AOF option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This works for all the write operations. The AOF option dumps the write data
    commands to an `appendonly.aof` file by default. There are combinations that can
    be used to write commands to this file, but every strategy comes with a performance
    to data persistence rider. What this means is that Redis can be configured to
    write to this file every time it encounters a write command, but this can make
    the entire process slow. Leaving the persistence to the underlying operating system
    in order to flush the buffer to this file can take the control away from the system,
    but this makes the application very fast. For the gossip server, the configuration
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`appendonly yes`: This will create an `appendonly.aof` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appendfsync everysec`: This will call the `fsync()` function every second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VM overcommit memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is achieved by tuning the `/etc/stsctl.conf` of your Linux box. This command
    will take care of how virtual memory management will take place inside the Linux
    box. The problem occurs when the `BGSAVE` function is called and the parent process
    forks a child process. By rule, the child process will have as much memory in
    the shared memory pages as the parent process. So, if the data changes in the
    parent, the child process also needs to have the same dataset to flush to disk.
    If the combined memory requirement for the parent and child does not add up to
    the shared memory, then `BGSAVE` fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion on VM memory management is outside the scope of the book. However,
    lack of this setting can cause Redis to fail in writing data to the disk. The
    change that should be made to the `/etc/stsctl.conf` is: `vm.overcommit_memory=1`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this application, you learned how to make a Config server, also called as
    a gossip server that can store properties and pass information around to its peer
    nodes. In this chapter, we have made provisions for the client node to store and
    access information and have a life cycle. Also, we provided a master node, which
    can have control over any of the client nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In the subsequent chapters, we will take this further and add capabilities for
    the server to scale and have fault tolerance.
  prefs: []
  type: TYPE_NORMAL
