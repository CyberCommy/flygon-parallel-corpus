- en: Kernel Workspace Setup
  prefs: []
  type: TYPE_NORMAL
- en: Hello, and welcome to this book on learning Linux kernel development. To get
    the most out of this book, it is very important that you first set up the workspace
    environment that we will be using throughout the book. This chapter will teach
    you exactly how to do this and get started.
  prefs: []
  type: TYPE_NORMAL
- en: We will install a recent Linux distribution, preferably as a **Virtual Machine**
    (**VM**), and set it up to include all the required software packages. We will
    also clone this book's code repository on GitHub, and learn about a few useful
    projects that will help along this journey.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn something is to do so *empirically –* not taking anyone's
    word on anything at all, but trying it out and experiencing it for yourself. Hence,
    this book gives you many hands-on experiments and kernel code examples that you
    can and indeed must try out yourself; this will greatly aid in your making real
    progress and deeply learning and understanding various aspects of Linux kernel
    and driver development. So, let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will take us through the following topics, which will help us
    set up our environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Running Linux as a guest VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the software – distribution and packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few additional useful projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need a modern desktop PC or laptop. Ubuntu Desktop specifies the following
    as "recommended system requirements" for the installation and usage of the distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: A 2 GHz dual core processor or better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RAM:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running on physical host: 2 GB or more system memory (more will certainly help).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running as a guest VM: The host system should have at least 4 GB RAM (the more
    the better and the smoother the experience).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25 GB of free hard drive space (I suggest more, at least double this).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either a DVD drive or a USB port for the installer media (not required when
    setting up Ubuntu as a guest VM).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet access is definitely helpful and required at times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As performing tasks such as building a Linux kernel from source is a very memory-
    and CPU-intensive process, I highly recommend that you try it out on a powerful
    Linux system with plenty of RAM and disk space to spare as well. It should be
    pretty obvious – the more RAM and CPU power the host system has, the better!
  prefs: []
  type: TYPE_NORMAL
- en: Like any seasoned kernel contributor, I would say that working on a native Linux
    system is best. However, for the purposes of this book, we cannot assume that
    you will always have a dedicated native Linux box available to you. So, we will
    assume that you are working on a Linux guest. Working within a guest VM also adds
    an additional layer of isolation and thus safety.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloning our code repository**: The complete source code for this book is
    freely available on GitHub at [https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Learn-Linux-Kernel-Development)*.* You
    can clone and work on it by cloning the `git` tree, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The source code is organized chapter-wise. Each chapter is represented as a
    directory – for example, `ch1/` has the source code for this chapter. The root
    of the source tree has some code that is common to all chapters, such as the source
    files `convenient.h`, `klib_llkd.c`, as well as others.
  prefs: []
  type: TYPE_NORMAL
- en: For efficient code browsing, I would strongly recommend that you always index
    the code base with `ctags(1)` and/or `cscope(1)`. For example, to set up the `ctags`
    index, just `cd` to the root of the source tree and type `ctags -R` .
  prefs: []
  type: TYPE_NORMAL
- en: Unless noted otherwise, the code output we show in the book is the output as
    seen on an x86-64 *Ubuntu 18.04.3 LTS* guest VM (running under Oracle VirtualBox
    6.1). You should realize that due to (usually minor) distribution – and even within
    the same distributions but differing versions – differences, the output shown
    here may not perfectly match what you see on your Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: Running Linux as a guest VM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed previously, a practical and convenient alternative to using a native
    Linux system is to install and use the Linux distribution as a guest OS on a VM.
    It's key that you install a recent Linux distribution, preferably as a VM to be
    safe and avoid unpleasant data loss or other surprises. The fact is when working
    at the level of the kernel, abruptly crashing the system (and the data loss risks
    that arise thereof) is actually a commonplace occurrence. I recommend using **Oracle
    VirtualBox 6.x** (or the latest stable version) or other virtualization software,
    such as **VMware Workstation***.*
  prefs: []
  type: TYPE_NORMAL
- en: Both of these are freely available. It's just that the code for this book has
    been tested on *VirtualBox 6.1*. Oracle VirtualBox is considered **Open Source
    Software** (**OSS**) and is licensed under the GPL v2 (the same as the Linux kernel).
    You can download it from [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
    Its documentation can be found here: [https://www.virtualbox.org/wiki/End-user_documentation](https://www.virtualbox.org/wiki/End-user_documentation).
  prefs: []
  type: TYPE_NORMAL
- en: The host system should be either MS Windows 10 or later (of course, even Windows
    7 will work), a recent Linux distribution (for example, Ubuntu or Fedora), or
    macOS. So, let's get started by installing our Linux guest.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a 64-bit Linux guest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, I won't delve into the minutiae of installing Linux as a guest on Oracle
    VirtualBox, the reason being that this installation is *not* directly related
    to Linux kernel development. There are many ways to set up a Linux VM; we really
    don't want to get into the details and the pros and cons of each of them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you are not familiar with this, don''t worry. For your convenience,
    here are some excellent resources that will help you out:'
  prefs: []
  type: TYPE_NORMAL
- en: A very clearly written tutorial entitled *Install Linux Inside Windows Using
    VirtualBox* by Abhishek Prakash (*It's FOSS!, August 2019*): [https://itsfoss.com/install-linux-in-virtualbox/](https://itsfoss.com/install-linux-in-virtualbox/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternate, similarly excellent resource is *Install Ubuntu on Oracle VirtualBox:* [https://brb.nci.nih.gov/seqtools/installUbuntu.html](https://brb.nci.nih.gov/seqtools/installUbuntu.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, you can look up useful resources for installing a Linux guest on VirtualBox
    in the *Further reading *section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: While you install the Linux VM, keep the following things in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Turn on your x86 system's virtualization extension support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installing a 64-bit Linux guest requires that CPU virtualization extension
    support (Intel VT-x or AMD-SV) be turned on within the host system''s **basic
    input/output system** (**BIOS**) settings. Let''s see how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is to ensure that our CPU supports virtualization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**There are two broad ways to check this while on a Windows host**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One, run the Task Manager app and switch to the Performance tab. Below the CPU
    graph, you will see, among several other things, Virtualization, with Enabled
    or Disabled following it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second way to check on Windows systems is to open a Command window (cmd).
    In Command Prompt, type `systeminfo` and press *Enter.* Among the output seen
    will be the `Virtualization Enabled in firmware` line. It will be followed by
    either `Yes` or `No`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To check this while on a Linux host**, from Terminal, issue the following
    commands (processor virtualization extension support: `vmx` is the check for Intel
    processors, `smv` is the check for AMD processors):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For Intel CPUs, the `vmx` flag will show up (in color) if virtualization is
    supported. In the case of AMD CPUs, `svm` will show up (in color). With this,
    we know that our CPU supports virtualization. But in order to use it, we need
    to enable it in the computer BIOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the BIOS by pressing *Del* or *F12* while booting (the precise key to
    press varies with the BIOS). Please refer to your system''s manual to see which
    key to use. Search for terms such as `Virtualization` or `Virtualization Technology
    (VT-x)`. Here is an example for Award BIOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/72bfc0d7-0c9b-4ffc-8393-427ca3b78384.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Setting the BIOS Virtualization option to the Enabled state
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an Asus EFI-BIOS, you will have to set the entry to `[Enabled]`
    if it is not set by default. Visit [https://superuser.com/questions/367290/how-to-enable-hardware-virtualization-on-asus-motherboard/375351#375351](https://superuser.com/questions/367290/how-to-enable-hardware-virtualization-on-asus-motherboard/375351#375351).
    [](https://superuser.com/questions/367290/how-to-enable-hardware-virtualization-on-asus-motherboard/375351#375351)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, choose to use hardware virtualization in VirtualBox''s Settings menu for
    your VM. To do this, click on System and then Acceleration. After that, check
    the boxes, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e815207f-62a8-4a25-ae0b-b27d80b98be6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Enabling hardware virtualization options within the VirtualBox
    VM settings
  prefs: []
  type: TYPE_NORMAL
- en: This is how we enable our host processor's hardware virtualization features
    for optimal performance.
  prefs: []
  type: TYPE_NORMAL
- en: Allocate sufficient space to the disk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For most desktop/laptop systems, allocating a gigabyte of RAM and two CPUs to
    the guest VM should be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: However, when allocating space for the guest's disk, please be generous. Instead
    of the usual/default 8 GB suggested, I strongly recommend you make it 50 GB or
    even more. Of course, this implies that the host system has more disk space than
    this available! Also, you can specify this amount to be *dynamically allocated*
    or *allocated on-demand*. The hypervisor will "grow" the virtual disk optimally,
    not giving it the entire space to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: Install the Oracle VirtualBox Guest Additions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For best performance, it''s important to install the Oracle VirtualBox Guest
    Additions as well within the guest VM. These are essentially para-virtualization
    accelerator software, which greatly helps with optimal performance. Let''s see
    how to do this on an Ubuntu guest session:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update your Ubuntu guest OS''s software packages. You can do so using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On completion, reboot your Ubuntu guest OS and then install the required packages
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from the VM menu bar, go to Devices | Insert Guest Additions CD image.... This
    will mount the `Guest Additions ISO` file inside your VM. The following screenshot shows
    what it looks like doing this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/389c7708-c2c5-4b5b-b039-a454da17fab0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – VirtualBox | Devices | Insert Guest Additions CD image
  prefs: []
  type: TYPE_NORMAL
- en: Now, a dialog window will pop up that will prompt you to run the installer in
    order to launch it. Select Run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Guest Additions installation will now take place in a Terminal window that
    shows up. Once complete, hit the *Enter* key to close the window. Then, power
    off your Ubuntu guest OS in order to change some settings from the VirtualBox
    manager, as explained next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, to enable Shared Clipboard and Drag''n''Drop functionalities between the
    guest and host machines, go to General | Advanced and enable the two options (Shared
    Clipboard and Drag''n''Drop) as you wish with the dropdowns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aa611c54-cea4-4676-8abc-c0e5cd159d39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4 – VirtualBox: enabling functionality between the host and guest'
  prefs: []
  type: TYPE_NORMAL
- en: Then, click OK to save the settings. Now boot into your guest system, log in,
    and test that everything is working fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As of the time of writing, Fedora 29 has an issue with the installation of
    the `vboxsf` kernel module required for the Shared Folders feature. I refer you
    to the following resource to attempt to rectify the situation: *Bug 1576832 **- virtualbox-guest-additions
    does not mount shared folder (*[https://bugzilla.redhat.com/show_bug.cgi?id=1576832](https://bugzilla.redhat.com/show_bug.cgi?id=1576832)).
    [](https://bugzilla.redhat.com/show_bug.cgi?id=1576832) If this refuses to work,
    you can simply transfer files between your host and guest VM over SSH (using `scp(1)`);
    to do so, install and start up the SSH daemon with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo yum install openssh-server`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo systemctl start sshd`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to update the guest VM regularly and when prompted. This is an essential
    security requirement. You can do so manually by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to be safe, please do not keep any important data on the guest VM.
    We will be working on kernel development. Crashing the guest kernel is actually
    a commonplace occurrence. While this usually does not cause data loss, you can
    never tell! To be safe, always back up any important data. This applies to Fedora
    as well. To learn how to install Fedora as a VirtualBox guest, visit [https://fedoramagazine.org/install-fedora-virtualbox-guest/](https://fedoramagazine.org/install-fedora-virtualbox-guest/).
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, especially when the overhead of the X Window System (or Wayland)
    GUI is too high, it's preferable to simply work in console mode. You can do so
    by appending `3` (the run level) to the kernel command line via the bootloader.
    However, working in console mode within VirtualBoxmay not be that pleasant an
    experience (for one, the clipboard is unavailable, and the screen size and fonts
    are less than desirable). Thus, simply doing a remote login (via `ssh`, `putty`,
    or equivalent) into the VM from the host system can be a great way to work.
  prefs: []
  type: TYPE_NORMAL
- en: Experimenting with the Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Raspberry Pi is a popular credit card-sized **Single-Board Computer **(**SBC**),
    much like a small-factor PC that has USB ports, a microSD card, HDMI, audio, Ethernet,
    GPIO, and more. The **System on Chip** (**SoC**) that powers it is from Broadcom,
    and in it is an ARM core or cluster of cores. Though not mandatory, of course,
    in this book, we strive to also test and run our code on a Raspberry Pi 3 Model
    B+ target. Running your code on different target architectures is always a good
    eye-opener to possible defects and helps with testing. I encourage you to do the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29496127-e03d-4829-b976-47296b7509fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – The Raspberry Pi with a USB-to-serial adapter cable attached to
    its GPIO pins
  prefs: []
  type: TYPE_NORMAL
- en: You can work on the Raspberry Pi target either using a digital monitor/TV via
    HDMI as the output device and a traditional keyboard/mouse over its USB ports
    or, more commonly for developers, over a remote shell via `ssh(1)`. However, the SSH approach
    does not cut it in all circumstances. Having a *serial console* on the Raspberry
    Pi helps, especially when doing kernel debugging.
  prefs: []
  type: TYPE_NORMAL
- en: I would recommend that you check out the following article, which will help
    you set up a USB-to-serial connection, thus getting a console login to the Raspberry
    Pi from a PC/laptop: *WORKING ON THE CONSOLE WITH THE RASPBERRY PI,* kaiwanTECH: [https://kaiwantech.wordpress.com/2018/12/16/working-on-the-console-with-the-raspberry-pi/](https://kaiwantech.wordpress.com/2018/12/16/working-on-the-console-with-the-raspberry-pi/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up your Raspberry Pi, please refer to the official documentation: [https://www.raspberrypi.org/documentation/](https://www.raspberrypi.org/documentation/).
    Our Raspberry Pi system runs the "official" Raspbian (Debian for Raspberry Pi)
    Linux OS with a recent (as of the time of writing) 4.14 Linux kernel. On the console
    of the Raspberry Pi, we run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What if you don't have a Raspberry Pi, or it's not handy? Well, there's always
    a way – emulation! Though not as good as having the real thing, emulating the
    Raspberry Pi with the powerful **Free and Open Source Software** (**FOSS**) emulator
    called **QEMU **or** Quick Emulator** is a nice way to get started, at least.
  prefs: []
  type: TYPE_NORMAL
- en: As the details of setting up the emulated Raspberry Pi via QEMU go beyond the
    scope of this book, we will not be covering it. However, you can check out the
    following links to find out more: *Emulating Raspberry Pi on Linux*: [http://embedonix.com/articles/linux/emulating-raspberry-pi-on-linux/](http://embedonix.com/articles/linux/emulating-raspberry-pi-on-linux/)and *qemu-rpi-kernel,
    GitHub*: [https://github.com/dhruvvyas90/qemu-rpi-kernel/wiki](https://github.com/dhruvvyas90/qemu-rpi-kernel/wiki).
  prefs: []
  type: TYPE_NORMAL
- en: Also, of course, you do not have to confine yourself to the Raspberry Pi family;
    there are several other excellent prototyping boards available. One that springs
    to mind is the popular **BeagleBone Black** (**BBB**) board.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, for professional development and product work, the Raspberry Pi is
    really not the best choice, for several reasons... a bit of googling will help
    you understand this. Having said that, as a learning and basic prototyping environment
    it's hard to beat, with the strong community (and tech hobbyist) support it enjoys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several modern choices of microprocessors for embedded Linux (and much more)
    are discussed and contrasted in this excellent in-depth article: *SO YOU WANT
    TO BUILD AN EMBEDDED LINUX SYSTEM?*, Jay Carlson, Oct 2020 : [https://jaycarlson.net/embedded-linux/](https://jaycarlson.net/embedded-linux/);
    do check it out.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, I expect that you have set up Linux as a guest machine (or are using
    a native "test" Linux box) and have cloned the book''s GitHub code repository.
    So far, we have covered some information regarding setting up Linux as a guest
    VM (as well as optionally using boards such as the Raspberry Pi or the BeagleBone).
    Let''s now move on to a key step: actually installing software components on our
    Linux guest system so that we can learn and write Linux kernel code on the system!'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the software – distribution and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is recommended to use one of the following or later stable version Linux
    distributions. As mentioned in the previous section, they can always be installed
    as a guest OS on a Windows or Linux host system, with the clear first choice being
    Ubuntu Linux 18.04 LTS Desktop*.* The following screenshot shows you the recommended
    version and the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebd213e7-04ce-4dcd-909e-0977d073f2a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Oracle VirtualBox 6.1 running Ubuntu 18.04.4 LTS as a guest VM
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding version – Ubuntu 18.04 LTS Desktop** –** is the version of choice
    for this book, at least.  The two primary reasons for this are straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Linux is one of the, if not *the, *most popular Linux (kernel) development
    workstation environments in industry use today.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot always, for lack of space and clarity, show the code/build output
    of multiple environments in this book. Hence, we have chosen to show the output
    as seen on Ubuntu 18.04 LTS Desktop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu 16.04 LTS Desktop is a good choice too (it has **Long-Term Support** (**LTS**)
    as well), and everything should work. To download it, visit [https://www.ubuntu.com/download/desktop](https://www.ubuntu.com/download/desktop).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other Linux distributions that can also be considered include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CentOS 8 Linux (not CentOS Stream)**: CentOS Linux is a distribution that''s
    essentially a clone of the popular enterprise server distribution from RedHat
    (RHEL 8, in our case). You can download it from here: [https://www.centos.org/download/](https://www.centos.org/download/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fedora Workstation**: Fedora is a very well-known FOSS Linux distribution
    as well. You can think of it as being a kind of test-bed for projects and code
    that will eventually land up within RedHat''s enterprise products. Download it
    from [https://getfedora.org/](https://getfedora.org/) (download the Fedora Workstation
    image).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raspberry Pi as a target**: It''s really best to refer to the official documentation
    to set up your Raspberry Pi (*Raspberry Pi documentation*: [https://www.raspberrypi.org/documentation/](https://www.raspberrypi.org/documentation/)).
    It''s perhaps worth noting that Raspberry Pi "kits" are widely available that
    come completely pre-installed and with some hardware accessories as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to learn how to install a Raspberry Pi OS image on an SD card, visit [https://www.raspberrypi.org/documentation/installation/installing-images/](https://www.raspberrypi.org/documentation/installation/installing-images/).
  prefs: []
  type: TYPE_NORMAL
- en: '**BeagleBone Black as a target**: The BBB is, like the Raspberry Pi, an extremely
    popular embedded ARM SBC for hobbyists and pros. You can get started here: [https://beagleboard.org/black](https://beagleboard.org/black). The
    System Reference Manual for the BBB can be found here: [https://cdn.sparkfun.com/datasheets/Dev/Beagle/BBB_SRM_C.pdf](https://cdn.sparkfun.com/datasheets/Dev/Beagle/BBB_SRM_C.pdf).
    Though we don''t present examples running on the BBB, nevertheless, it''s a valid
    embedded Linux system that, once properly set up, you can run this book''s code
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we conclude our discussion on selecting our software distribution for
    the book, here are a few more points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: These distributions are, in their default form, FOSS and non-proprietary, and
    free to use as an end user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though our aim is to be Linux distribution-neutral, the code has only been tested
    on Ubuntu 18.04 LTS and "lightly" tested on CentOS 8, and a Raspberry Pi 3 Model
    B+ running the Raspbian GNU/Linux 9.9 (stretch) Debian-based Linux OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will, as far as is possible, use the very latest (as of the time of writing)
    **stable LTS**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux kernel version 5.4** for our kernel build and code runs. Being an LTS
    kernel, the 5.4 kernel is an excellent choice to run on and learn with.'
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to know that the 5.4 LTS kernel will indeed have a long lifespan;
    from November 2019 right up to December 2025! This is good news: this book's content
    remains current and valid for years to come!
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we'll log in as the user account named `llkd`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to realize, for maximized security (with the latest defenses
    and fixes), that you must run the most recent **Long Term Support** (**LTS**)
    kernel possible for your project or product.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have chosen our Linux distribution and/or hardware boards and VMs,
    it's time we install essential software packages.
  prefs: []
  type: TYPE_NORMAL
- en: Installing software packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The packages that are installed by default when you use a typical Linux desktop
    distribution, such as any recent Ubuntu, CentOS, or Fedora Linux system, will
    include the minimal set required by a systems programmer: the native toolchain,
    which includes the `gcc` compiler along with headers, and the `make` utility/packages.'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, though, we are going to learn how to write kernel-space code using
    a VM and/or a target system running on a foreign processor (ARM or AArch64 being
    the typical cases). To effectively develop kernel code on these systems, we will
    need to install some software packages. Read on.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Oracle VirtualBox guest additions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make sure you have installed the guest VM (as explained previously). Then,
    follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to your Linux guest VM and first run the following commands within a
    Terminal window (on a shell):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Install the Oracle VirtualBox Guest Additions now. Refer to *How to Install
    VirtualBox Guest Additions in Ubuntu:* [https://www.tecmint.com/install-virtualbox-guest-additions-in-ubuntu/](https://www.tecmint.com/install-virtualbox-guest-additions-in-ubuntu/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This only applies if you are running Ubuntu as a VM using Oracle VirtualBox
    as the hypervisor app.
  prefs: []
  type: TYPE_NORMAL
- en: Installing required software packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install the packages, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the Ubuntu VM, first do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command in a single line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The command installing `gcc`, `make`, and `perl` is done first so that the Oracle
    VirtualBox Guest Additions can be properly installed straight after. These (Guest
    Additions) are essentially para-virtualization accelerator software. It's important
    to install them for optimal performance.
  prefs: []
  type: TYPE_NORMAL
- en: This book, at times, mentions that running a program on another CPU architecture
    – typically ARM – might be a useful exercise. If you want to try (interesting!)
    stuff like this, please read on; otherwise, feel free to skip ahead to the *Important
    installation notes* section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a cross toolchain and QEMU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way to try things on an ARM machine is to actually do so on a physical ARM-based
    SBC; for example, the Raspberry Pi is a very popular choice. In this case, the
    typical development workflow is to first build the ARM code on your x86-64 host
    system. But to do so, we need to install a **cross toolchain** – a set of tools
    allowing you to build software on one host CPU designed to execute on a different
    *target* CPU. An x86-64 *host* building programs for an ARM *target* is a very
    common case, and indeed is our use case here. Details on installing the cross
    compiler follow shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Often, an alternate way to just trying things out is to have an ARM/Linux system
    emulated – this alleviates the need for hardware! To do so, we recommend using
    the superb **QEMU** project ([https://www.qemu.org/](https://www.qemu.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the required QEMU packages, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For installation on Ubuntu, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For installation on Fedora, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To get the version number on Fedora, just type the preceding command and after
    typing the required package name (here, `qemu-system-arm-`), press the *Tab* key
    twice. It will auto-complete, providing a list of choices. Choose the latest version
    and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: CentOS 8 does not seem to have a simple means to install the QEMU package we
    require. (You could always install a cross toolchain via the source, but that's
    challenging; or, obtain an appropriate binary package.) Due to these difficulties,
    we will skip showing cross-compilation on CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a cross compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you intend to write a C program that is compiled on a certain host system
    but must execute on another target system, then you need to compile it with what''s
    known as a cross compiler or cross toolchain. For example, in our use case, we
    want to work on an x86-64 host machine. It could even be an x86-64 guest VM, no
    issues, but run our code on an ARM-32 target:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu, you can install the cross toolchain with the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command installs an x86_64-to-ARM-32 toolchain appropriate for
    ARM-32 "hard float" (armhf) systems (such as the Raspberry Pi); this is usually
    just fine. It results in the `arm-linux-gnueabihf-<foo>` set of tools being installed;
    where `<foo>` represents cross tools such as `addr2line`, `as`, `g++`, `gcc`,
    `gcov`, `gprof`, `ld`, `nm`, `objcopy`, `objdump`, `readelf`, `size`, `strip`,
    and so on. (The cross compiler prefix in this case is `arm-linux-gnueabihf-`).
    In addition, though not mandatory, you can install the `arm-linux-gnueabi-<foo>` cross
    toolset like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On Fedora, you can install the cross toolchain with the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For Fedora Linux, the same tip as earlier applies – use the *Tab* key to help
    auto-complete the command.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using a cross toolchain might require some reading up for newbie
    users. You can visit the *Further reading* section where I have placed a few useful
    links that will surely be of great help.
  prefs: []
  type: TYPE_NORMAL
- en: Important installation notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now mention a few remaining points, most of them pertaining to software
    installation or other issues when working on particular distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On CentOS 8, you can install Python with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this does not actually create the (required) **symbolic link** (**symlink**),
    `/usr/bin/python`; why not? Check out this link for details: [https://developers.redhat.com/blog/2019/05/07/what-no-python-in-red-hat-enterprise-linux-8/](https://developers.redhat.com/blog/2019/05/07/what-no-python-in-red-hat-enterprise-linux-8/).
    [](https://developers.redhat.com/blog/2019/05/07/what-no-python-in-red-hat-enterprise-linux-8/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually create the symlink to, for example, `python3`, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel build might fail if the OpenSSL header files aren''t installed.
    Fix this on CentOS 8 with the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS 8, the `lsb_release` utility can be installed with the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On Fedora, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install these two packages, ensuring the dependencies are met when building
    a kernel on Fedora systems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo dnf install openssl-devel-1:1.1.1d-2.fc31 elfutils-libelf-devel` (the
    preceding `openssl-devel` package is suffixed with the relevant Fedora version
    number (`.fc31` here; adjust it as required for your system).'
  prefs: []
  type: TYPE_NORMAL
- en: In order to use the `lsb_release` command, you must install the `redhat-lsb-core` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations! This completes the software setup, and your kernel journey
    begins! Now, let's check out a few additional and useful projects to complete
    this chapter. It's certainly recommended that you read through these as well.
  prefs: []
  type: TYPE_NORMAL
- en: Additional useful projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section brings you details of some additional miscellaneous projects that
    you might find very useful indeed. In a few appropriate places in this book, we
    refer to or directly make use of some of them, thus making them important to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with the well-known and important Linux *man pages* project.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Linux man pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You must have noticed the convention followed in most Linux/Unix literature:'
  prefs: []
  type: TYPE_NORMAL
- en: The suffixing of *user commands* with `(1)` – for example, `gcc(1)` or `gcc.1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*System calls* with `(2)` – for example, `fork(2)` or `fork().2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Library APIs* with `(3)` – for example, `pthread_create(3)` or `pthread_create().3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you are no doubt aware, the number in parentheses (or after the period)
    denotes the section of the **manual** (the **man** pages) that the command/API
    in question belongs to. A quick check with `man(1)`, via the `man man` command (that''s
    why we love Unix/Linux!) reveals the sections of the Unix/Linux manual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, for example, to look up the man page on the `stat(2)` system call, you
    would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At times (quite often, in fact), the `man` pages are simply too detailed to
    warrant reading through when a quick answer is all that's required. Enter the `tldr`
    project – read on!
  prefs: []
  type: TYPE_NORMAL
- en: The tldr variant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we're discussing `man` pages, a common annoyance is that the `man` page
    on a command is, at times, too large. Take the `ps(1)` utility as an example.
    It has a large `man` page as, of course, it has a huge number of option switches.
    Wouldn't it be nice, though, to have a simplified and summarized "common usage"
    page? This is precisely what the `tldr` pages project aims to do.
  prefs: []
  type: TYPE_NORMAL
- en: '**TL;DR** literally means **Too Long; Didn''t Read***.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In their own words, they provide *"*simplified and community-driven man pages."
    So, once installed, `tldr ps` provides a neat brief summary on the most commonly
    used `ps` command option switches to do something useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3222a01-e03c-4c9b-842d-d16a5295ee50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7 – A screenshot of the tldr utility in action: tldr ps'
  prefs: []
  type: TYPE_NORMAL
- en: All Ubuntu repos have the `tldr` package. Install it with `sudo apt install
    tldr`.
  prefs: []
  type: TYPE_NORMAL
- en: It's indeed worth checking out. If you're interested in knowing more, visit [https://tldr.sh/](https://tldr.sh/).
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, recall that we said that userspace system calls fall under section
    2 of the man pages, library subroutines under section 3, and kernel APIs under
    section 9. Given this, then, in this book, why don't we specify the, say, `printk`
    kernel function (or API) as `printk(9)` – as `man man` shows us that section `9`
    of the manual is *Kernel routines*? Well, it's fiction, really (at least on today's
    Linux): *no man pages actually exist for kernel APIs! *So, how do you get documentation
    on the kernel APIs and so on? That's just what we will briefly delve into in the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: Locating and using the Linux kernel documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The community has developed and evolved the Linux kernel documentation into
    a good state over many years of effort. The *latest version* of the kernel documentation,
    presented in a nice and modern "web" style, can always be accessed online here: [https://www.kernel.org/doc/html/latest/](https://www.kernel.org/doc/html/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as we will mention in the next chapter, the kernel documentation
    is always available for that kernel version within the kernel source tree itself,
    in the directory called `Documentation/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As just one example of the online kernel documentation, see the following partial
    screenshot of the page on *Core Kernel Documentation*/*Basic C Library Functions* ([https://www.kernel.org/doc/html/latest/core-api/kernel-api.html#basic-c-library-functions](https://www.kernel.org/doc/html/latest/core-api/kernel-api.html#basic-c-library-functions)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89f4c179-15d9-4d6e-a241-9e984e14ebae.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Partial screenshot showing a small part of the modern online Linux
    kernel documentation
  prefs: []
  type: TYPE_NORMAL
- en: As can be gleaned from the screenshot, the modern documentation is pretty comprehensive.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the kernel documentation from source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can literally generate the full Linux kernel documentation from within the
    kernel source tree in various popular formats (including PDF, HTML, LaTeX, EPUB,
    or XML), in a *Javadoc* or *Doxygen-like* style. The modern documentation system
    used internally by the kernel is called **Sphinx**. Using `make help` within the
    kernel source tree will reveal several *documentation targets*, among them `htmldocs`,
    `pdfdocs`, and more. So, you can, for example, `cd` to the kernel source tree
    and run `make pdfdocs` to build the complete Linux kernel documentation as PDF
    documents (the PDFs, as well as some other meta-docs, will be placed in `Documentation/output/latex`).
    The first time, at least, you will likely be prompted to install several packages
    and utilities (we don't show this explicitly).
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if the preceding details are not crystal clear yet. I suggest you
    first read [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 1*, and [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 2*, and then revisit these details.
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis tools for the Linux kernel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static analyzers are tools that, by examining the source code, attempt to identify
    potential errors within it. They can be tremendously useful to you as the developer,
    though you must learn how to "tame" them – in the sense that they can result in
    false positives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several useful static analysis tools exist. Among them, the ones that are more
    relevant for Linux kernel code analysis include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sparse: [https://sparse.wiki.kernel.org/index.php/Main_Page](https://sparse.wiki.kernel.org/index.php/Main_Page)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coccinelle: [http://coccinelle.lip6.fr/](http://coccinelle.lip6.fr/) (requires
    the `ocaml` package installed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smatch: [http://smatch.sourceforge.net/](http://smatch.sourceforge.net/), [http://repo.or.cz/w/smatch.git](http://repo.or.cz/w/smatch.git)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flawfinder: [https://dwheeler.com/flawfinder/](https://dwheeler.com/flawfinder/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cppcheck: [https://github.com/danmar/cppcheck](https://github.com/danmar/cppcheck)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to install and try Sparse, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also several high-quality commercial static analysis tools available.
    Among them are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SonarQube: [https://www.sonarqube.org/](https://www.sonarqube.org/)​ (a free
    and open source community edition is available)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coverity Scan: [https://scan.coverity.com/](https://scan.coverity.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Klocwork: [https://www.meteonic.com/klocwork](https://www.meteonic.com/klocwork)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clang` is a frontend to GCC that is becoming more popular even for kernel
    builds. You can install it on Ubuntu with `sudo apt install clang clang-tools`.'
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis tools can save the day. Time spent learning to use them effectively
    is time well spent!
  prefs: []
  type: TYPE_NORMAL
- en: Linux Trace Toolkit next generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A superb tool for *tracing* and *profiling* is the powerful**Linux Tracing Toolkit
    next generation** (**LTTng**) toolset, a Linux Foundation project. LTTng allows
    you to trace both userspace (applications) and/or the kernel code paths in minute
    detail. This can tremendously aid you in understanding where performance bottlenecks
    occur, as well as aiding you in understanding the overall code flow and thus in
    learning about how the code actually performs its tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In order to learn how to install and use it, I refer you to its very good documentation
    here: [https://lttng.org/docs](https://lttng.org/docs)​ (try [https://lttng.org/download/](https://lttng.org/download/) for
    installation for common Linux distributions). It is also highly recommended that
    you install the Trace Compass GUI: [https://www.eclipse.org/tracecompass/](https://www.eclipse.org/tracecompass/).
    It provides an excellent GUI for examining and interpreting LTTng's output.
  prefs: []
  type: TYPE_NORMAL
- en: Trace Compass minimally requires a **Java Runtime Environment** (**JRE**) to
    be installed as well. I installed one on my Ubuntu 20.04 LTS system with `sudo
    apt install openjdk-14-jre`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example (I can''t resist!), here''s a screenshot of a capture by LTTng
    being "visualized" by the superb Trace Compass GUI. Here, I show a couple of hardware
    interrupts (IRQ lines 1 and 130, the interrupt lines for the i8042 and Wi-Fi chipset,
    respectively, on my native x86_64 system.):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3845add2-b5a5-4f1b-a6b2-a2bb787f58e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Sample screenshot of the Trace Compass GUI; samples recorded by
    LTTng showing IRQ lines 1 and 130
  prefs: []
  type: TYPE_NORMAL
- en: The pink color in the upper part of the preceding screenshot represents the
    occurrence of a hardware interrupt. Underneath that, in the IRQ vs Time tab (it's
    only partially visible), the interrupt distribution is seen. (In the distribution
    graph, the *y* axis is the time taken; interestingly, the network interrupt handler
    – in red – seems to take very little time, the i8042 keyboard/mouse controller
    chip's handler – in blue – takes more time, even exceeding 200 microseconds!)
  prefs: []
  type: TYPE_NORMAL
- en: The procmap utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visualizing the complete memory map of the kernel **Virtual Address Space**
    (**VAS**) as well as any given process's user VAS is what the `procmap` utility
    is designed to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The description on its GitHub page sums it up:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>It outputs a simple visualization of the complete memory map of a given process
    in a vertically-tiled format ordered by descending virtual address. The script
    has the intelligence to show kernel and userspace mappings as well as calculate
    and show the sparse memory regions that will be present. Also, each segment or
    mapping is scaled by relative size (and color-coded for readability). On 64-bit
    systems, it also shows the so-called non-canonical sparse region or 'hole' (typically
    close to 16,384 PB on the x86_64).</q>
  prefs: []
  type: TYPE_NORMAL
- en: The utility includes options to see only kernel space or userspace, verbose
    and debug modes, the ability to export its output in convenient CSV format to
    a specified file, as well as other options. It has a kernel component as well
    and currently works (and auto-detects) on x86_64, AArch32, and Aarch64 CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: Do note, though, that I am still working on this utility; it's currently under
    development... there are several caveats. Feedback and contributions are most
    appreciated!
  prefs: []
  type: TYPE_NORMAL
- en: 'Download/clone it from [https://github.com/kaiwan/procmap](https://github.com/kaiwan/procmap):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6518827-5c73-4216-8c8d-3dfb7675c5c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – A partial screenshot of the procmap utility's output, showing
    only the top portion of kernel VAS on x86_64
  prefs: []
  type: TYPE_NORMAL
- en: We make good use of this utility in [Chapter 7](06ee05b5-3e71-482d-93b8-235c27ce23bc.xhtml),
    *Memory Management Internals - Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Embedded ARM Linux System FOSS project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SEALS** or **Simple Embedded ARM Linux System** is a very simple "skeleton"
    Linux base system running on an emulated ARM machine. It provides a primary Bash
    script that asks the end user what functionality they want via a menu, then accordingly
    proceeds to cross-compile a Linux kernel for ARM, then creates and initializes
    a simple root filesystem. It can then call upon QEMU ( `qemu-system-arm`) to emulate
    and run an ARM platform (the Versatile Express CA-9 is the default board emulated).
    The useful thing is, the script builds the target kernel, the root filesystem,
    and the root filesystem image file, and sets things up for boot. It even has a
    simple GUI (or console) frontend, to make usage a bit simpler for the end user. The
    project''s GitHub page is here: [https://github.com/kaiwan/seals/](https://github.com/kaiwan/seals/).
    Clone it and give it a try... we definitely recommend you have a look at its wiki
    section pages at [https://github.com/kaiwan/seals/wiki](https://github.com/kaiwan/seals/wiki) for
    help.'
  prefs: []
  type: TYPE_NORMAL
- en: Modern tracing and performance analysis with [e]BPF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An extension of the well-known**Berkeley Packet Filter** or **BPF**, **eBPF**is
    the **extended BPF***.* (FYI, modern usage of the term is simply to refer to it
    as **BPF**, dropping the 'e' prefix).Very briefly, BPF used to provide the supporting
    infrastructure within the kernel to effectively trace network packets. BPF is
    a very recent kernel innovation – available only from the Linux 4.0 kernel onward.
    It extends the BPF notion, allowing you to trace much more than just the network
    stack. Also, it works for tracing both kernel space as well as userspace apps.
    *In effect, BPF and its frontends are the modern approach to tracing and performance
    analysis on a Linux system*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use BPF, you will need a system with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel 4.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel support for BPF ([https://github.com/iovisor/bcc/blob/master/INSTALL.md#kernel-configuration](https://github.com/iovisor/bcc/blob/master/INSTALL.md#kernel-configuration))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **BCC** or `bpftrace` frontends installed (link to install them on popular
    Linux distributions: [https://github.com/iovisor/bcc/blob/master/INSTALL.md#installing-bcc](https://github.com/iovisor/bcc/blob/master/INSTALL.md#installing-bcc))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root access on the target system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the BPF kernel feature directly is very hard, so there are several easier
    front ends to use. Among them, BCC and `bpftrace` are regarded as useful. Check
    out the following link to a picture that opens your eyes to just how many powerful
    BCC tools are available to help trace different Linux subsystems and hardware:
    [https://github.com/iovisor/bcc/blob/master/images/bcc_tracing_tools_2019.png](https://github.com/iovisor/bcc/blob/master/images/bcc_tracing_tools_2019.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Important: You can install the BCC tools for your regular host Linux distro
    by reading the installation instructions here: [https://github.com/iovisor/bcc/blob/master/INSTALL.md](https://github.com/iovisor/bcc/blob/master/INSTALL.md). Why
    not on our guest Linux VM? You can, when running a distro kernel (such as an Ubuntu-
    or Fedora-supplied kernel). The reason: the installation of the BCC toolset includes
    (and depends upon) the installation of the `linux-headers-$(uname -r)` package;
    this `linux-headers` package exists *only for* distro kernels (and not for our
    custom 5.4 kernel that we shall often be running on the guest).'
  prefs: []
  type: TYPE_NORMAL
- en: The main site for BCC can be found at [https://github.com/iovisor/bcc](https://github.com/iovisor/bcc).
  prefs: []
  type: TYPE_NORMAL
- en: The LDV - Linux Driver Verification - project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Russian Linux Verification Center, founded in 2005, is an opensource project;
    it has specialists in, and thus specializes in, automated testing of complex software
    projects. This includes comprehensive test suites, frameworks, and detailed analyses
    (both static and dynamic) being performed on the core Linux kernel as well as on
    the primarily device drivers within the kernel. This project puts a great deal
    of focus on the testing and verification of *kernel modules* as well, which many
    similar projects tend to skim.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of particular interest to us here is the Online Linux Driver Verification Service
    page ([http://linuxtesting.org/ldv/online?action=rules](http://linuxtesting.org/ldv/online?action=rules));
    it contains a list of a few verified Rules (Figure 1.11):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0e68bf6-a2d9-4bb0-b09e-cc02a2bf32da.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Screenshot of the 'Rules' page of the Linux Driver Verification
    (LDV) project site
  prefs: []
  type: TYPE_NORMAL
- en: By glancing through these rules, we'll be able to not only see the rule but
    also instances of actual cases where these rules were violated by driver/kernel
    code within the mainline kernel, thus introducing bugs. The LDV project has successfully
    discovered and fixed (by sending in patches in the usual manner) several driver/kernel
    bugs. In a few of the upcoming chapters, we shall mention instances of these LDV
    rule violations (for example, memory leakage, **Use After Free** (**UAF**) bugs,
    and locking violations) having been uncovered, and (probably) even fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some useful links on the LDV website:'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux Verification Center home page; [http://linuxtesting.org/](http://linuxtesting.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux Kernel Space Verification; [http://linuxtesting.org/kernel](http://linuxtesting.org/kernel)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online Linux Driver Verification Service page **with verified Rules** : [http://linuxtesting.org/ldv/online?action=rules](http://linuxtesting.org/ldv/online?action=rules)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Problems in Linux Kernel* page; lists over 400 issues found in existing drivers
    (mostly fixed as well); [http://linuxtesting.org/results/ldv](http://linuxtesting.org/results/ldv)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered in detail the hardware and software requirements
    to set up an appropriate development environment for beginning to work on Linux
    kernel development. In addition, we mentioned the basics and provided links, wherever
    appropriate, for setting up a Raspberry Pi device, installing powerful tools such
    as QEMU and a cross toolchain, and so on. We also threw some light on other "miscellaneous"
    tools and projects that you, as a budding kernel and/or device driver developer,
    might find useful, as well as information on how to begin looking up kernel documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we definitely recommend and expect you to try out and work on
    kernel code in a hands-on fashion. To do so, you must have a proper kernel workspace
    environment set up, which we have successfully done in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our environment is ready, let's move on and explore the brave world
    of Linux kernel development! The next two chapters will teach you how to download,
    extract, configure, and build a Linux kernel from source.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions).
    You will find some of the questions answered in the book''s GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn).'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help you delve deeper into the subject with useful materials, we provide
    a rather detailed list of online references and links (and at times, even books)
    in a Further reading document in this book's GitHub repository. The *Further reading*
    document is available here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md).
  prefs: []
  type: TYPE_NORMAL
