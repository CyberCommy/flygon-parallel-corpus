- en: Chapter 4. Introducing the ECSS Methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter we considered existing CSS methodologies, and where, for
    your humble authors needs, they fell short.
  prefs: []
  type: TYPE_NORMAL
- en: I'm not about to try and convince you that the Enduring CSS approach is the
    *Alpha and the Omega*. However, it does have different strengths and aims than
    the existing approaches. Therefore, even if taking it wholesale doesn't appeal,
    I'd hope there may be something you can borrow to solve your own issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Highlights of ECSS:'
  prefs: []
  type: TYPE_NORMAL
- en: It gains maintainability by isolating each visual pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File size remains minimal over long periods of time by virtue of the fact that
    you can cut out sections/features/components with impunity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rules are *self-quarantining*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class names/selectors can communicate context, originating logic and variation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All rules, their effects and reach are entirely predictable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When I first wrote about Enduring CSS I was expecting a backlash of sorts. At
    that time (August 2014), no-one was really advocating what I was suggesting. Received
    wisdom for scaling CSS was to abstract visual patterns, normalise designs as much
    as possible and DRY out code. *Enduring CSS* is, in some ways, the antithesis
    of these beliefs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we won't be dealing with the specific technical detail of ECSS,
    such as naming conventions, tooling, authoring and organisation. We'll be covering
    those subjects in detail in future chapters. Instead, we will be looking at the
    broad aims and benefits of the approach as it compares to other approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you aren't aware of the acronym, DRY stands for Don't Repeat Yourself,
    a popular goal when coding so that logic is only written once in a codebase to
    provide a single source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into this, I think it may help to clarify the terminology that
    will be used. The terms used to define the visual parts of a page are known by
    different names in different approaches. There's nothing revelatory in what I'm
    suggesting or the terms I'm using, it's just important we're all on the same page
    before we get into this.
  prefs: []
  type: TYPE_NORMAL
- en: Defining terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm using the term *module* to designate an area of functionality and/or the
    code that creates it. To exemplify, the header of a website could be considered
    a module. The header module would, in turn, be made up of other smaller pieces
    of functionality. For example, drop-down menus or search boxes. These nested pieces
    of functionality would be defined as components. Finally, our smallest *items* would
    be the child nodes that make up a component or module.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to reiterate:'
  prefs: []
  type: TYPE_NORMAL
- en: A **module** is the widest, visually identifiable, individual section of functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Components** are the nested pieces of functionality that are included within
    a module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Child nodes** are the individual parts that go to make up a component (typically
    nodes in the DOM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For brevity, for what follows, when I'm referring to modules, it could be a
    module or component. The difference from a ECSS authoring perspective is unimportant.
  prefs: []
  type: TYPE_NORMAL
- en: The problems ECSS solves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My primary goal with ECSS was to isolate styles as opposed to abstracting them.
  prefs: []
  type: TYPE_NORMAL
- en: Ordinarily, it makes sense to create CSS classes that are abstractions of common
    functionality. The benefit being that they can then be re-used and re-applied
    on many varied elements. That's sound enough in principle. The problem is, on
    larger and more complicated user interfaces, it becomes impossible to make even
    minor tweaks and amendments to those abstractions without inadvertently effecting
    things you didn't intend to.
  prefs: []
  type: TYPE_NORMAL
- en: A guiding principle with ECSS therefore was to isolate styles to the intended
    target.
  prefs: []
  type: TYPE_NORMAL
- en: Depending upon your goals, even at the cost of repetition, isolation can buy
    you greater advantages; allowing for predictable styling and simple decoupling
    of styles.
  prefs: []
  type: TYPE_NORMAL
- en: A further advantage of isolating styles is that designers can be encouraged
    to bring whatever they need making, without necessarily feeling encumbered by
    existing visual patterns. Every new module that needs to be coded can be a *greenfield*.
    I found that I could code out designs far faster when starting from scratch than
    attempting to build them from any number of vague abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with specificity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I also wanted to negate issues surrounding specificity. To this ends, I adopted
    the widely used approach of insisting all selectors used a single (or as close
    to that ideal as possible) class-based selector.
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *If you''re having CSS problems I feel bad for you son, I got 99 problems
    but specificity ain''t one* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*[https://twitter.com/benfrain/status/537339394706141184](https://twitter.com/benfrain/status/537339394706141184)*
    |'
  prefs: []
  type: TYPE_TB
- en: Furthermore, structural HTML elements (with the exception of pseudo-elements)
    are NEVER referenced in the style sheets as type selectors. In addition ID selectors
    are completely avoided in ECSS. Not because ID selectors are bad per se, but because
    we need a level playing field of selector strength.
  prefs: []
  type: TYPE_NORMAL
- en: '*Changes* to components are handled via simple overrides. However, the way
    they are handled from an authoring perspective makes them easy to manage and reason
    about.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have an element that needs to be a different width if it is within
    a certain container - easy peasy, we don''t need to be draconian in the manner
    an override can happen. We don''t need a modifier applied to that specific element.
    We can handle typical and very loose override scenarios but manage them confidently.
    You would write it like this in the authoring style sheets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And it would yield this CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This may seem like a subtle benefit. After all, we may be authoring things a
    little differently by nesting the overrides, but the net result is typical CSS;
    an element that gets different styles based upon a different and more specific
    selector.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of the ampersand symbol within a nesting context to denote the parent
    selector is a convention borrowed from the *Sass* ([http://sass-lang.com/](http://sass-lang.com/))
    language.
  prefs: []
  type: TYPE_NORMAL
- en: However, by adopting this approach, from an authoring perspective, we create
    a *single source of truth* for each key selector. Everything that will ever make
    a change to that key selector is nested inside that opening set of curly braces.
    Furthermore, that key selector will never be defined as a root rule anywhere else
    in the entire codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Different interpretations of DRY**'
  prefs: []
  type: TYPE_NORMAL
- en: I wasn't convinced that the goal of DRY code that other CSSers were pursuing
    and extolling the virtues of, was the same kind of DRY code I wanted. To explain
    that a little more - I didn't care much about repeated values and pairs across
    my rules, which is what most people were concentrating on DRYing out. What I cared
    about was key selectors not being repeated in the codebase. Key selectors were
    my *single source of truth* and that was the area I wanted to DRY out. To that
    ends, with ECSS, an authoring convention is enforced that prevents a key selector
    being defined more than once project-wide. We will get into that in much more
    detail in [Chapter 8](ch08.html "Chapter 8. The Ten Commandments of Sane Style
    Sheets"), *The Ten Commandments of Sane Style Sheets*.
  prefs: []
  type: TYPE_NORMAL
- en: This is !important
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If on the odd occasion the presence of one override isn't enough, we can make
    use of `!important`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will likely be aware that using `!important` in CSS is generally frowned
    upon. Here''s what MDN has to say about `!important`:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *When an !important rule is used on a style declaration, this declaration
    overrides any other declaration made in the CSS, wherever it is in the declaration
    list. Although, !important has nothing to do with specificity, using !important
    is bad practice because it makes debugging hard since you break the natural cascading
    in your style sheets* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*[https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity)*
    |'
  prefs: []
  type: TYPE_TB
- en: 'However, when events beyond our control mess with our styles (e.g. a 3rd party
    CSS file loaded on the page) and we need some clout, I embrace !important. Here''s
    an example of a state change that is receiving some extra welly from !important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I'll be honest, I really don't lose much sleep over using `!important` when
    it is needed. Thanks to all overrides being localised to their parent selector
    in the authoring style sheets, the occasional use of `!important` presents no
    problems in ECSS.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing repetition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get much further, I think it's important to deal with a possible *elephant
    in the room*. I need to try and convince you that eliminating repetition of properties
    and values across files may not buy as much, from a maintenance perspective, as
    a solid and contained set of modules that are easy to remove from a codebase as
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: The ECSS approach embraces repetition of properties and values in the CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'With ECSS, every single visual module or component is written with a micro-namespace
    to provide isolation from other modules and components. Here is a typical example
    of an authored ECSS rule (the authoring syntax is very similar to Sass, but typically
    facilitated by PostCSS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Those inclined towards OOCSS and Atomic CSS methodologies may look at that and
    shudder. Things like `color` and `font-size` are declared in most components.
    The `@mixin Headline` mixin generates a sizeable chunk of CSS to designate a particular
    font stack too. So, yes, there's repetition of properties and values.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the positives:'
  prefs: []
  type: TYPE_NORMAL
- en: It's verbose yet it relies on no inheritance of styles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's generally context agnostic (save for the size context of where it is placed),
    any media queries that affect this component are defined within this single set
    of curly braces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key selector like this is written once and once only. When this key selector
    needs to change, you only need to look in this one place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing rules with all overrides nested within creates a sort of micro-cascade.
    Where ordinarily overrides could be anywhere in the CSS, adhering to this method
    confines them to a very specific area. It then becomes far easier to reason about
    specificity as it relates to the rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero component abstractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With ECSS, if a component needs to be made that is similar, yet subtly different
    to an existing component, we would not abstract or extend from this existing component.
    Instead, a new one would be written.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, I'm serious.
  prefs: []
  type: TYPE_NORMAL
- en: Even if 95% of it is the same.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of this is that each component is then independent and isolated.
    One can exist without the other. One can change however it needs to, independently
    from the other. Despite their apparent aesthetic similarity at the outset, they
    can mutate as needed with no fear of infecting or tainting any other similar looking
    component. To extend the biological metaphor, we have gained components that are
    *self-quarantining* by virtue of their unique namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A further analogy: A BMW 3 series has a lot in common with a BMW 5 series.
    But they are not the same. They may share some/many parts (the equivalent of CSS
    property and value combinations) but that doesn''t make them the same. Their differences
    define them. They cannot be made of exactly the same parts because there is something
    inherently different about them. I''d argue it is the same case with modules and
    components defined with ECSS. The CSS language is the abstraction. The property/value
    pairs of CSS already mean we can build what we want from individual parts.'
  prefs: []
  type: TYPE_NORMAL
- en: The cost of repetition?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fully reap the benefits of ECSS you need to be comfortable with the property
    and value repetition it creates. At this point, you may believe me deluded. With
    all this duplication, how can this ECSS approach be a viable option? I''ll address
    that concern with one word: gzip.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, I lied. I'd like to qualify that further.
  prefs: []
  type: TYPE_NORMAL
- en: gzip is incredibly efficient at compressing repetitive strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I was curious what *real world* difference the verbosity of repeated property/value
    pairs in an approach like ECSS actually made? An experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: The resultant CSS file of a ECSS based project I was working on, when gzipped
    (as it would be served *over the wire*), was 42.9 KB. That's a significantly sized
    CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common and verbose patterns that could be abstracted from this style
    sheet to an OOCSS class was a couple of Flex based rules that were used abundantly
    throughout to vertically centre content within their container. They were even
    more verbose thanks to the fact that there was considerable code added by *Autoprefixer*
    ([https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer))
    to enable support on older devices. For example, the resultant CSS for defining
    flex layout was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the test style sheet, those four lines of CSS were repeated **193** times.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was only half of it. Many of those items needed aligning too. That required
    this in the CSS too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That block was repeated **117** times. Doesn't seem like any better reason to
    abstract to an OOCSS class, right? That must be causing some serious bloat right
    there?
  prefs: []
  type: TYPE_NORMAL
- en: Not so fast, Batman!
  prefs: []
  type: TYPE_NORMAL
- en: If those blocks of code were removed and the file re-gzipped, the CSS file size
    dropped to 41.9 KB.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the most common and verbose visual pattern to an OOCSS class saved
    just 1 KB of CSS over the wire. And despite just a 1 KB saving in the CSS, factor
    in that if abstracting those styles to Single Responsibility Classes (e.g. `.flex`
    and `.flex-center`), it would also be necessary to litter the HTML with the relevant
    OOCSS classes to get the visual effect back.
  prefs: []
  type: TYPE_NORMAL
- en: Does that make Single Responsibility Classes worth it?
  prefs: []
  type: TYPE_NORMAL
- en: Given that no other property combination had anything like that sort of verbosity
    and repetition, from a file size perspective, certainly not in my book. It would
    cost a lot of development agility (remember abstraction makes authoring and iteration
    slower as its necessary to change both templates and CSS) and responsive flexibility
    (what if I want this thing to do something different in a different viewport)
    for a minor saving in CSS file size. It's the CSS equivalent of *robbing Peter
    to pay Paul*.
  prefs: []
  type: TYPE_NORMAL
- en: Let me be quite clear. Despite the efficacy of gzip, if your priority is having
    the smallest possible CSS file size, ECSS isn't your best choice.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, go take a look at *Atomic CSS* ([http://acss.io/](http://acss.io/)).
    Its creators are smart people, indeed, *Thierry Koblentz* ([http://www.cssmojo.com/](http://www.cssmojo.com/))
    is one of the smartest CSSers I know of. I'm sure ACSS will serve your needs well.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the priorities of ECSS are developer ergonomics (understandable
    class-naming conventions), easy maintainability (styles organised by component
    and simple to delete) and style encapsulation (namespacing prevents leaky abstractions).
  prefs: []
  type: TYPE_NORMAL
- en: Different problems, different solution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope I've given you enough to consider that obsessing over repeated property
    values and pairs might not be the best use of your time if you are trying to create
    maintainable style sheets. In the next chapter, besides looking at the benefits
    of the ECSS naming convention, I'll also be arguing that a sound organisational
    approach to project maintenance will generate far leaner style sheets in the long
    term than class abstraction and re-use.
  prefs: []
  type: TYPE_NORMAL
