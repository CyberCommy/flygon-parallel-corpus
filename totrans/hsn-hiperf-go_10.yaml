- en: Memory Management in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memory management is paramount to system performance. Being able to utilize
    a computer''s memory footprint to the fullest allows you to keep highly functioning
    programs in memory so that you don''t often have to take the large performance
    hit of swapping to disk. Being able to manage memory effectively is a core tenet
    of writing performant Go code. In this chapter, we will learn about the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Computer memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How memory is allocated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Go utilizes memory effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How objects are allocated in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategies for computing devices with limited memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how memory is utilized can help you learn to utilize memory effectively
    in your programs. Memory is one of the fastest places in the computer to store
    and manipulate data, so being able to manage it performantly will have a lasting
    impact on your code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Modern Computer Memory - A Primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern computers have **Random Access Memory** (**RAM**), which is utilized
    in machine code and data storage. RAM is used alongside the CPU and hard disks
    in order to store and retrieve information. Utilizing the CPU, RAM, and disks
    has performance trade-offs. In a modern computer at the time of writing, we have
    the following generic, rounded timings for some common operations in computers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data Storage Type** | **Timing** |'
  prefs: []
  type: TYPE_TB
- en: '| L1 (Processor Cache) Reference | 1 ns |'
  prefs: []
  type: TYPE_TB
- en: '| L2 (Processor Cache) Reference | 4 ns |'
  prefs: []
  type: TYPE_TB
- en: '| Main Memory Reference | 100 ns |'
  prefs: []
  type: TYPE_TB
- en: '| SSD Random Read | 16 μs |'
  prefs: []
  type: TYPE_TB
- en: '| 7200 RPM HDD Disk Seek | 2 ms |'
  prefs: []
  type: TYPE_TB
- en: As you'll notice from the table, the different storage types have wildly differing
    timings for different portions of a modern computer's architecture. New computers
    have KBs of L1 cache, MBs of L2 cache, GBs of main memory, and TBs of SSD/HDD.
    As we recognize that these different types of data storage vary significantly
    in terms of cost and performance, we need to learn how to use each of them effectively
    in order to write performant code.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main memory that a computer has is used for many things. The **Memory Management
    Unit** (**MMU**) is a piece of computer hardware that translates between physical
    and virtual memory addresses. When a CPU performs an instruction that uses a memory
    address, the MMU takes that logical memory address and translates it to a physical
    memory address. These are handled in groupings of physical memory addresses called
    pages. Pages are usually handled in 4 kB segments, using a table called a page
    table. The MMU also has other functionality, including using buffers, such as
    the **Translation Lookaside Buffer** (**TLB**), to hold recently accessed translations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual memory is helpful because it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows hardware device memory to be mapped to an address space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows access permissions (rwx) for particular memory regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows processes to have separate memory mappings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows memory to be more easily moved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows memory to be more easily swapped to disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows for shared memory, where physical ram is mapped to many processes simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the virtual memory is allocated in a modern Linux OS, both the kernel and
    user space processes use virtual addresses. These virtual addresses are often
    split into two pieces—the upper portion of memory in a virtual address space is
    used for the kernel and kernel processes, and the lower portion of the memory
    is used for user space programs.
  prefs: []
  type: TYPE_NORMAL
- en: The OS utilizes this memory. It moves processes between memory and disk to optimize
    the use of the resources that we have available in our computer. Computer languages
    use **virtual memory space** (**VMS**) in the underlying OS that they run on.
    Go is no exception to that rule. If you've programmed in C, you'll know the malloc
    and free idioms. In Go, we don't have a `malloc` function. Go is also a garbage-collected
    language, so we don't have to consider freeing memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two different primary measures of memory within the user space: VSZ
    and RSS.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing VSZ and RSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**VSZ**, the **virtual memory size**, references all of the memory that an
    individual process can access, including swapped memory. This is the memory size
    that is allocated during the initial execution of the program. VSZ is reported
    in KiB.'
  prefs: []
  type: TYPE_NORMAL
- en: '**RSS**, the **resident set size**, references how much memory a particular
    process has allocated in RAM, not including swapped memory. RSS includes shared
    library memory as long as that memory is currently available. RSS also includes
    stack and heap memory. RSS memory can be larger than the total memory available
    in the system based on the fact that these memory references are often shared.
    RSS is reported in kilobytes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we start up a simple HTTP server, we can see the VSZ and RSS that are
    allocated to our individual processes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then take a look at the process ID that is spawned when the server is
    invoked, as can be seen in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81bdfc69-6487-4960-8314-6bbc1befb46f.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see the VSZ and RSS values for the `server.go` process that we've
    invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to reduce the Go binary build size, we can build our binary without
    libc libraries using a `build` flag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we build our binary without including the libc libraries, we will have a
    much smaller memory footprint for our example server, as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c6365c0-e7b8-4ad6-b012-156776750b96.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, both our VSZ and RSS memory utilization were reduced considerably.
    In practice, memory is inexpensive and we can leave the libc libraries in our
    Golang binaries. Libc is utilized for a lot of standard library bits, including
    user and group resolution as well as bits of host resolution, and this is why
    it's dynamically linked at build time.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we build our Go binaries, they are stored in a container format. Linux
    machines store this particular binary in a format known as **ELF** (short for
    **Executable** and **Linkable Format**). Go''s standard library has a methodology
    for reading ELF files. We can examine the `simpleServer` binary that we have generated
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output from our `simpleServer` example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e368c05e-61a4-4f07-9d92-e6bfca7f7bc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are also other Linux tools that we can use to investigate these ELF binaries. `readelf`
    will also print ELF files in a more human readable format. For example, we can
    take a look at an ELF file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fe039dc-bb91-46ab-b5a0-0f9faaa1b30a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'ELF files have a specific format. This format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File Layout Portion** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| File header | **Class field**: Defines 32 and 64 bit addresses as 52 or 64
    bytes long, respectively.**Data**: Defines little or big endians.**Version**:
    Stores the ELF version (currently there is only one version, 01).**OS/ABI**: Defines
    the OS and the application binary interface.**Machine**: Tells you the machine
    type.**Type**: Indicates what type of file this is; common types are CORE, DYN
    (for shared objects), EXEC (for executable files), and REL (for relocatable files).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Program headers or segments | Contain instructions on how to create a process
    or memory image for execution at runtime. The kernel then uses these to map to
    a virtual address space using mmap. |'
  prefs: []
  type: TYPE_TB
- en: '| Section headers or sections | `.text`: Executable code (instructions, static
    constants, literals)`.data`: Access controlled, initialized data`.rodata`: Read-only
    data`.bss`: Read/write uninitialized data |'
  prefs: []
  type: TYPE_TB
- en: 'We can also compile a 32 bit version of this program to see the difference.
    As mentioned in [Chapter 1](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml), *Introduction
    to Performance in Go*, we can build Go binaries for different architectures. We
    can build a binary for an i386 Linux system using the following build parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`env GOOS=linux GOARCH=386 go build -o 386simpleServer simpleServer.go`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this build has been completed, we can inspect the resulting ELF file and
    corroborate the fact that the resulting ELF is different from the one we processed
    before for my x86_64 computer. We''ll use the `-h` flag just to view the headers
    for each file for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/642fb06a-a721-41ab-b51d-4db166d02b1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the resulting output, this particular binary was generated
    for an i386 processor, as opposed to the x86_64 binary that was generated initially:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f2a3cba-31df-4636-a91e-44c3e442cc8e.png)'
  prefs: []
  type: TYPE_IMG
- en: Knowing the limitations of your system, your architecture, and your memory limits
    can help you to build Go programs that will run effectively on your hosts. In
    this section, we will deal with memory utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding memory utilization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have our initial binary, we start building on the knowledge that we
    have of the ELF format to continue our understanding of memory utilization. The
    text, data, and bss fields are a foundation on which the heap and stack are laid.
    The heap begins at the end of the `.bss` and `.data` bits and grows continuously to
    form larger memory addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The stack is an allocation of contiguous blocks of memory. This allocation happens
    automatically within the function call stack. When a function is called, its variables
    get memory allocated on the stack. After the function call is completed, the variable's
    memory is deallocated. The stack has a fixed size and can only be determined at
    compile time. Stack allocation is inexpensive from an allocation perspective because
    it only needs to push to the stack and pull from the stack for allocation.
  prefs: []
  type: TYPE_NORMAL
- en: The heap is a grouping of memory that is available to allocate and deallocate.
    Memory is allocated in random order, manually performed by the programmer. It
    is more expensive timewise and is slower to access because of its non-continuous
    blocks. It is, however, possible to resize elements in the heap. Heap allocation
    is expensive, as malloc searches for enough memory to hold the new data. As the
    garbage collector works later, it scans for objects in the heap that aren't referenced
    anymore, and deallocates them. These two processes are much more expensive than
    stack allocation/deallocation bits. Because of this, Go prefers allocation on
    the stack rather than the heap.
  prefs: []
  type: TYPE_NORMAL
- en: We can compile programs with a gcflag of `-m` in order to see how the Go compiler
    uses escape analysis (the process in which the compiler determines whether to
    use the stack or the heap for variables initialized at runtime).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a very simple program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then compile our program with the escape analysis flag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31678bb4-b5a6-4c78-816d-646eeb49a4e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In our resulting output, we can see that our simple `greetingString` is allocated
    to the heap. If we want additional verbosity with this flag, we can pass multiple
    `m` values. At the time of writing, passing up to 5 `-m` flags gives us different
    levels of verbosity. The following screenshot is of a build with 3 `-m` flags
    (for the sake of brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb8813d9-27e7-4f36-bb82-d4cebcbae446.png)'
  prefs: []
  type: TYPE_IMG
- en: Go variables that are statically assigned tend to live on the stack. Items that
    are pointers to memory or methods on interface types tend to be dynamic and therefore
    live on the heap generally.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to see more available optimizations while performing our builds,
    we can see them using the following command: `go tool compile -help`.
  prefs: []
  type: TYPE_NORMAL
- en: Go runtime memory allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in [Chapter 3](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml), *Understanding
    Concurrency*, the Go runtime uses the `G` struct to represent stack parameters
    for a single goroutine. The `P` struct manages logical processors for execution.
    The malloc that is used as part of the Go runtime, defined at [https://golang.org/src/runtime/malloc.g](https://golang.org/src/runtime/malloc.go)[o](https://golang.org/src/runtime/malloc.go),
    does a lot of work. Go uses mmap to ask the underlying OS directly for memory.
    Small allocation sizes (memory allocations up to and including 32 kB) are handled
    separately from large memory allocations.
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's quickly discuss a couple of objects that are associated with Go's small
    object memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: We can see the `mheap` and `mspan` structs in [https://golang.org/src/runtime/mheap.go](https://golang.org/src/runtime/mheap.go).
  prefs: []
  type: TYPE_NORMAL
- en: '`mheap` is the main malloc heap. It keeps track of global data, as well as
    many other heap details. Some important ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| lock | A mutex locking mechanism |'
  prefs: []
  type: TYPE_TB
- en: '| free | An mTreap (a data structure that is a blend of a tree and a heap)
    of non-scavenged spans |'
  prefs: []
  type: TYPE_TB
- en: '| scav | An mTreap of free and scavenged spans |'
  prefs: []
  type: TYPE_TB
- en: '| sweepgen | An integer that keeps track of a span''s swept status |'
  prefs: []
  type: TYPE_TB
- en: '| sweepdone | Tracking whether all spans are swept |'
  prefs: []
  type: TYPE_TB
- en: '| sweepers | The number of `sweepone` calls active |'
  prefs: []
  type: TYPE_TB
- en: '`mspan` is the main span malloc. It keeps track of all available spans. Spans
    are 8K or larger contiguous regions of memory. It also keeps many other span details.
    Some important ones to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `next` | The next span in the list; (nil) if one isn''t present |'
  prefs: []
  type: TYPE_TB
- en: '| `previous` | Previous span in the list; (nil) if there isn''t one |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | A span list for debugging |'
  prefs: []
  type: TYPE_TB
- en: '| `startAddr` | First byte of a span |'
  prefs: []
  type: TYPE_TB
- en: '| `npages` | The number of pages in the span |'
  prefs: []
  type: TYPE_TB
- en: Memory object allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three classifications of memory objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tiny: An object that is less than 16 bytes in size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Small: An object that is greater than 16 bytes and less than or equal to 32
    kB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Large: An object that is larger than 32 kB in size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A tiny object in memory in Go performs the following process for memory allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: If `P`'s mcache has room, use that space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the existing sub object in the mcache and round it to 8, 4, or 2 bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the object in memory if it fits in the allocated space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A small object in memory in Go follows a specific pattern for memory allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The object''s size gets rounded up and classified into one of the small size
    classes that are generated in [https://golang.org/src/runtime/mksizeclasses.go](https://golang.org/src/runtime/mksizeclasses.go).
    In the following output, we can see the `_NumSizeClasses` and the `class_to_size`
    variable allocations defined on my x86_64 machine. This value is then used to
    find a free bitmap within the mspan in P''s mcache and will allocate accordingly
    if there''s a free slot of memory available. The following screenshot illustrates
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d1ab7fe3-9ab0-4a0a-8aca-c6c2e7035bf3.png)'
  prefs: []
  type: TYPE_IMG
- en: If there are no free spots in P's mspan, a new mspan is obtained from mcentral's
    mspan list that has enough space for the new memory object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If that list is empty, a run of pages from the mheap is performed in order to
    find room for the mspan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If that fails, is empty, or doesn't have a large enough page to allocate, a
    new group of pages is allocated from the OS. This is expensive, but is done in
    at least 1 MB chunks, which helps with the cost of having to talk to the OS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Freeing objects from an mspan follow a similar process:'
  prefs: []
  type: TYPE_NORMAL
- en: An mspan is returned to the mcache if it is being swept in response to an allocation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the mspan still has objects that are allocated to it, the mcentral free list
    receives this mspan for deallocation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the mspan is idle (it has no allocated objects), it gets returned to the
    mheap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the mspan is idle for a given interval, these pages are returned to the
    underlying OS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Large objects don't use the mcache or the mcentral; they just use the mheap
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use our previously created HTTP server in order to take a look at some
    memory stats. Using the runtime package, we can derive the amount of memory the
    program has retrieved from the OS, as well as the heap allocation for the Go program.
    Let''s see how this happens step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize our package, perform our imports, and set up our first
    handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We then write an anonymous function to capture our run statistics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After we execute this program, we can see the memory allocation for our service.
    The first printout in the following results shows the initial allocations of memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b113544c-1739-46b6-9cca-8d0ea15c940f.png)'
  prefs: []
  type: TYPE_IMG
- en: The second printout is after a request for `http://localhost:1234/` has been
    made. You can see that the system and heap allocations stay roughly the same,
    and that both the idle heap and the heap in use shift for utilization with the
    web request.
  prefs: []
  type: TYPE_NORMAL
- en: Go's memory allocator was originally derived from TCMalloc, a thread caching
    malloc. More information about TCMalloc can be found at [http://goog-perftools.sourceforge.net/doc/tcmalloc.html](http://goog-perftools.sourceforge.net/doc/tcmalloc.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Go allocator, the Go memory allocator, uses thread-local cache and spans that
    are 8 K or larger contiguous regions of memory. These 8 K regions, also known
    as spans, are commonly used in one of three capacities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Idle: A span that can be reused for the heap/stack or returned to the OS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In use: A span that is currently being used in the Go runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stack: A span that is used for the goroutine stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we create a program that doesn''t have shared libraries, we should see a
    much smaller memory footprint for our program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize our package and import the required libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We then perform the same actions that we did for our previous simple http server,
    but we just use the `fmt` package to print a string. We then sleep so that we
    have the ability to see the memory utilization output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output from the execution of this program, we can see that the heap
    allocation for this executable is much smaller than our simple HTTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/87c357c5-4297-4f02-953d-411fd51fd370.png)'
  prefs: []
  type: TYPE_IMG
- en: But why is this the case? We can use the goweight library [[https://github.com/jondot/goweight](https://github.com/jondot/goweight)]
    to see the size of the dependencies within our program. We just need to download
    this binary: `go get github.com/jondot/goweight`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then determine what the large dependencies are in our Go program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a3278b05-e735-4544-8fac-6ece827fc174.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the `net/http` library takes up a lot of space, as do the runtime
    and the net library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, let''s look at our simple program with memory stats:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84587793-0388-4e30-8053-78dd733cfaa8.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that our next largest segments without the runtime are much smaller
    than the `net/http` and `net` libraries. It's always important to know exactly
    where our resources are being utilized in order to make more efficient binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the OS level calls with strace, we can next see the difference
    between the interaction with our simple web server and our simple program. An
    example of our simple web server is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15f01d58-f40a-4f5d-80d6-a17a17d9a441.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of our simple program can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1797f59-dcb9-477d-a3c9-43d4761f5a36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the output, we can notice a couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: The output from our `simpleWebServer` is much longer than our `simpleProgram`
    (this has been truncated in the screenshots, but if it is generated we can see
    that the response length is longer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `simpleWebServer` loads a lot more C libraries (we can see `ld.so.preload`, `libpthread.so.0`,
    and `libc.so.6` in our strace capture in the screenshot).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are quite a lot more memory allocations in our `simpleWebServer` than
    our `simpleProgram` output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can take a look at where these are pulled in. The `net/http` library doesn't
    have any C references, but its parent library net does. In all of the cgo packages
    in the net library, we have documentation that tells us how we can skip using
    underlying CGO resolvers for packages: [https://golang.org/pkg/net/#pkg-overview](https://golang.org/pkg/net/#pkg-overview).
  prefs: []
  type: TYPE_NORMAL
- en: 'This documentation shows us how we can use the Go and cgo resolvers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use this to enable just the Go resolver in our example web server by
    executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see the process that is executing for our
    `simpleServer` without the C resolver:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c5071fb-8149-4b4a-ba74-c152eff4e528.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that our VSZ and RSS are low. Compare that to using the C resolver
    by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the output of our `simpleServer` using the following C resolver:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/456eb523-f097-49dc-9674-28140e57c054.png)'
  prefs: []
  type: TYPE_IMG
- en: Our VSZ is significantly lower in our server that wasn't compiled with the cgo
    resolver. Next, we will discuss limited memory situations and how to account for
    and build them.
  prefs: []
  type: TYPE_NORMAL
- en: Briefing on limited memory situations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are running Go on an embedded device or a device with very constrained
    memory, it's sometimes smart to understand some of the underlying processes within
    the runtime to make informed decisions regarding your processes. The Go garbage
    collector *prioritizes low latency and simplicity*. It uses a non-generational
    concurrent tri-color mark and sweep garbage collector. By default, it manages
    memory allocation automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Go has a function in the debug standard library that will force a garbage collection
    and return memory to the OS. The Go garbage collector returns unused memory to
    the OS after 5 minutes. If you are running on a low memory device, this function,
    `FreeOSMemory()`, can be found here: [https://golang.org/pkg/runtime/debug/#FreeOSMemory](https://golang.org/pkg/runtime/debug/#FreeOSMemory).
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the `GC()` function, which can be found here: [https://golang.org/pkg/runtime/#GC](https://golang.org/pkg/runtime/#GC).
  prefs: []
  type: TYPE_NORMAL
- en: The `GC()` function may also block the entire program. Use both of these functions
    at your own risk, because they can lead to unintended consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned about how Go allocates the heap and stack. We've
    also learned how to effectively monitor VSZ and RSS memory, and how we can optimize
    our code to make better use of available memory. Being able to do this allows
    us to effectively scale with the resources we have, serving more concurrent requests
    with the same amount of hardware.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing GPU processing in Go.
  prefs: []
  type: TYPE_NORMAL
