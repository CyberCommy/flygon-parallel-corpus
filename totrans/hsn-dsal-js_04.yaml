- en: Using Trees for Faster Lookup and Modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trees are one of the most advanced and complex data structures out there. It
    opens doors to graph theory, which is used to represent a relationship between
    objects. The objects can be of any type, and as long as they have an established
    relationship, it can be represented in the form of a tree.
  prefs: []
  type: TYPE_NORMAL
- en: Although there are tens of trees out there, it is not possible to cover them
    all in the chapter, so we will take a different approach and learn about trees
    in a more practical way when we go through the examples, instead of doing it upfront
    like in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be exploring the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a base angular application,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a typeahead lookup component using **trie trees**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a credit card approval predictor using the ID3 algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's dig into it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Angular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we implement any trees, let's set up a base application, which we can
    use in our subsequent examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like we did in previous chapters, we will be creating an Angular application
    using the Angular CLI using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Angular CLI using the following command (if not done already):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the new project in the folder of your choice by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After these two steps, you should be able to see the new project created and
    all the corresponding node modules installed and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run your application, run the following command from Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating a typeahead lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine this, you have a form for user signup, and your users have to fill out
    their information, including their country. Lucky for us, there are only a fixed
    number of countries, so the user experience around populating and selecting can
    be made extremely fun and easy rather than having them scroll through hundreds
    of options.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will be creating a trie tree and prepopulating it with a
    list of all the countries. The users can then type the name of their country and
    our component will work as a typeahead and show the available options to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now discuss why we need a trie tree. According to Wikipedia, the following
    is the definition of a simple trie tree:'
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, a trie, also called digital tree and sometimes radix tree or prefix
    tree (as they can be searched by prefixes), is a kind of search tree — an ordered
    tree data structure that is used to store a dynamic set or associate array where
    the keys are usually strings
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, a trie tree is an optimized search tree where the keys are
    strings. Let''s illustrate this with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider that we have an array of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This, when converted into a `trie` tree, would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/06376a37-7b3e-4c2a-a135-4951d8f616f4.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding diagram, we can note that the tree starts at the root and
    then, based on the input strings, the tree gets constructed. While inserting the
    strings into the `trie` tree, the words are broken into individual characters
    and then the duplicate nodes are not reinserted but rather reused to construct
    the rest of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a trie tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now create the `trie` tree, which we will be using within our application.
    Within our application, let's first create the directory called `utils` under
    the `src` folder in which we will be adding our `trie.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API for our tree will be quite concise with only two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add()`: Adds elements to the `trie` tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search()` : Accepts an input string and returns the subtree that matches the
    query string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, let''s inject it into the list of providers in our main module
    listed in `app.module.ts` so that our components have access to the tree, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the add() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, our tree is ready to have its first method implemented. Our tree starts
    off with no elements in it (that is, an empty object). You can use any data structure
    for your implementation, but we will use objects as our data store for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, this method is made up of the following
    two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine what level the tree is already built to and ignore those characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the remainder as a new subtree and continue till the end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The friends' example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's put our knowledge to use in an example in which our user wants to add
    two elements to this tree, **Adam**, and **Adrian**. First, we will add **Adam**to
    the tree so we have nodes **a***,* **d**, **a**, and **m**. Then, when adding
    **Adrian***, *we check what is already added—**a** and **d**, in this case—and
    thus the rest of the word **rian** is added as a new subtree.
  prefs: []
  type: TYPE_NORMAL
- en: 'When logged, the following is what we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8cf13a76-f164-4301-a7d8-eb21e0d5ad93.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, **a** and **d** are common for
    both the words and then the rest are two subtrees for each string that we added.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the search() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `search()` method is even simpler and highly efficient with a complexity
    of O(n), where n is the length of the search input. The big O notation is something
    that will be covered in detail in a later chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's take the friends example described in the preceding code. If the user
    types a,for example, we extract the subtree using the `search()` method just implemented.
    We get the subtree below a*. *
  prefs: []
  type: TYPE_NORMAL
- en: 'The more input character the user provides, the more granular the response
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/31bdb223-08c7-4bc6-80c2-ba7b343c9681.png) ![](assets/3b1c2519-b178-411a-8c95-c9358a525bb9.png) ![](assets/7a675cd2-1ae0-45fb-8105-0e6f5bfac4a9.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding screenshots, as the user types more, our `search()`
    method keeps returning the sub-tree of the node that matches with it while the
    entire tree can be seen below it. And to render it on the screen we are using
    the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `app.component.ts` file we add the following, which queries the `search()`
    method on the `Trie` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then this search result is bound to the template using a simple `pre` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Retaining remainders at nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `search()` method that we implemented earlier works great; however, as a
    developer, you would now need to loop over the returned sub-tree and construct
    the remainder of the word out of it to be displayed on the UI. That's kind of
    a hassle, isn't it? What if we can simplify it so that the tree would return the
    sub-tree along with the remainder of the words that they form? Actually, it's
    quite easy to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to make a small change to our algorithm and add remainders set
    at each node; that way, whenever a node is recognized, we can add the remainder
    to that set and also push new elements into this set while creating new nodes.
    Let''s take a look at how this modifies our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, adding two lines has made our job a lot
    easier than earlier. No more unnecessary looping over the subtree objects, and
    we have the remainder of the words at each node of the sub-tree returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ea81431-11ef-45ca-9cdd-ab0cfe219707.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This would also mean that we have to update our `search()` method''s failure
    condition to return an empty object with a `remainder` set instead of an empty
    object, unlike earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The final form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Putting this all together and adding simple changes to our UI, we can finally
    search through a list and show the results in a very fast and efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the previous changes incorporated, our `app.component.ts` is ready to
    take its final form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, update the `app.component.html` template to show the search results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/45135af2-d8bf-421b-b721-74b33cbb1c44.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a credit card approval predictor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trees are ubiquitous. No matter what application you are using, chances are
    that there are trees in play internally. Having said that, not all trees are data
    structures. In this example, we will explore something different, which is a really
    popular but not a typical data structure, that is, a decision tree.
  prefs: []
  type: TYPE_NORMAL
- en: At some stage, you would have come across some sort of an automatic prediction
    system. Whether it is a sports website that predicts the winner of a game or credit
    scoring websites that tell you which credit card you should apply for to get a
    quick approval. In this example, we will go with a credit card approval predictor,
    but this can be easily transferred to any application of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a majority of the cases, we have a complex Machine Learning model running
    behind the scenes to generate an accurate prediction, but, because we know that
    the number of factors affecting the approval or rejection is finite, we can use
    a decision tree to determine the chances of approval based on the past patterns
    exhibited. The following is the list of tasks that we will have to achieve in
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the decision tree by implementing  **Iterative Dichotomiser 3** (**ID3**)
    algorithm to classify future samples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a training dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running new inputs through the algorithm and validating responses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ID3 algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the algorithms that we have seen were not very complex; they were rather
    trivial, and most of our focus was on implementing the API for a particular data
    structure. In this example, there is no data structure to implement; the algorithm
    itself generates the decision tree that we would be using for our application.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's take a look at how a table of historical data can be converted
    into a decision tree. The tree that is formed primarily is made up of **decision
    nodes** (which indicate a decision) and **leaf nodes** (which indicates the final
    response, such as yes or no).  The decision nodes can have two or more subnodes,
    depending on the dataset. However, the tree has to start from somewhere, right?
    What would be the root node and how do we get it?
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the root node, we will first need to know some basics of Information
    Theory here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entropy**: Entropy is the measure of uncertainty of a series of inputs—the
    more uncertain the number of input messages, the more inputs are needed to determine
    what the message is; for example, if our input series always sends the same message,
    there is no uncertainty, and thus the entropy is zero. Such an input series is
    also known as pure. However, if the same series sends *n* different types of inputs
    with the same probability, then the entropy becomes high and the receiver needs
    to ask log[2]n Boolean questions to determine the message. The average number
    of bits needed to identify a message is a measure of the sender''s entropy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information gain**: To determine the root node, first we will need to split
    the dataset based on the attributes provided, and then determine the entropy at
    each attribute, the difference of entropy at each attribute and that of the target
    determines the information gain or loss of each attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attribute with the highest information gain becomes the root attribute.
    Then, we repeat the process for each subtree until we get no entropy. Let's take
    a look at this with an example and then start off with the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the following example, we will take a simple input and popular dataset
    to decide whether a game is going to be played or not based on the weather conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Outlook** | **Temperature** | **Humidity** | **Wind** | **Play Soccer**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sunny | Hot | High | Weak | No |'
  prefs: []
  type: TYPE_TB
- en: '| Sunny | Hot | High | Strong | No |'
  prefs: []
  type: TYPE_TB
- en: '| Overcast | Hot | High | Weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Rain | Mild | High | Weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Rain | Cool | Normal | Weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Sunny | Cool | Normal | Weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Rain | Mild | Normal | Weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Sunny | Mild | Normal | Strong | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Overcast | Mild | High | Strong | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Overcast | Hot | Normal | Weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Rain | Cool | Normal | Strong | No |'
  prefs: []
  type: TYPE_TB
- en: '| Overcast | Cool | Normal | Strong | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Sunny | Mild | High | Weak | No |'
  prefs: []
  type: TYPE_TB
- en: In the preceding example, the target is the *Play Soccer *attribute. Let's assume
    that our input source has a capability of sending *n* messages and the probability
    of sending each message is P[n] , then the entropy of the source is the summation
    over *n* of the probabilities *E = -p[i] * log[2](p[i])*.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating target entropy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we have two possible outputs for the *Play Soccer* (target) attribute,
    we will calculate the entropy using the frequency table (indicating how many times
    a particular value was received) of the target attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: The probability of receiving yes is the total times it was received divided
    by the total number of messages received and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Play Soccer** |'
  prefs: []
  type: TYPE_TB
- en: '| Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 4 |'
  prefs: []
  type: TYPE_TB
- en: 'So, the entropy of the target would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Calculating branch entropy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s break the dataset down further and calculate the entropy based
    on each branch. We have the following four main branches here:'
  prefs: []
  type: TYPE_NORMAL
- en: Outlook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Humidity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s first start with the branch for Outlook:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | Play |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | Yes | No | Total |'
  prefs: []
  type: TYPE_TB
- en: '| Outlook | Sunny | 2 | 3 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '|  | Overcast | 4 | 0 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '|  | Rain | 3 | 1 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  | 13 |'
  prefs: []
  type: TYPE_TB
- en: 'To calculate the entropy of the branch, we will first calculate the probability
    of each sub-branch and then multiply it with the entropy of that branch. We will
    then add the resultant entropy for each sub-branch to get the total entropy of
    the branch; then, we can calculate the information gain for the branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P(Play, Outlook) = P(Outcast) * E(4,0) + P(Sunny) * E(2,3)  + P(Rain) * E(3,1) *'
  prefs: []
  type: TYPE_NORMAL
- en: '*= (4/13) * 0 + (5/13) *  0.970 + (4/13) * 0.811*'
  prefs: []
  type: TYPE_NORMAL
- en: '*= 0.62261538461*'
  prefs: []
  type: TYPE_NORMAL
- en: So, *the total Information gain for Outlook branch = targetEntropy - branchEntropy*
  prefs: []
  type: TYPE_NORMAL
- en: '*= 0.89049164021 - 0.62261538461*'
  prefs: []
  type: TYPE_NORMAL
- en: '*= 0.2678762556 or **0.27***'
  prefs: []
  type: TYPE_NORMAL
- en: The final information gain per branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can calculate the entropy of all the branches using a frequency table
    of two attributes for the rest of the columns, similar to what we did for Outlook,
    and get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the branch Humidity*, *there are two possible sub-branches, which have
    the following results breakup:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | yes | no | total |'
  prefs: []
  type: TYPE_TB
- en: '| Humidity | high | 3 | 3 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '|  | normal | 6 | 1 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  | 13 |'
  prefs: []
  type: TYPE_TB
- en: 'Similarly, for Wind, the breakup is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | yes | no | total |'
  prefs: []
  type: TYPE_TB
- en: '| Wind | weak | 6 | 2 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '|  | strong | 3 | 2 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  | 13 |'
  prefs: []
  type: TYPE_TB
- en: 'For Temperature, it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | yes | no | total |'
  prefs: []
  type: TYPE_TB
- en: '| Temperature | Hot | 2 | 2 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '|  | Mild | 4 | 1 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '|  | Cool | 3 | 1 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  | 13 |'
  prefs: []
  type: TYPE_TB
- en: 'We calculate the *branchEntropy* and the *Information gain* for each branch,
    and here are the results following similar steps as we did for the Outlook branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Outlook | Temperature | Humidity | Wind |'
  prefs: []
  type: TYPE_TB
- en: '| Gain | 0.27 | 0.055510642 | 0.110360144 | 0.017801027 |'
  prefs: []
  type: TYPE_TB
- en: Since Outlook has the highest information gain, we can make it the root decision
    node and split the tree based on its branches and then recursively continue the
    process until we get all the leaf nodes, for example, entropy 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the root node selected, our input data looks as follows from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Overcast | Hot | High | Weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '|  | Overcast | Mild | High | Strong | Yes |'
  prefs: []
  type: TYPE_TB
- en: '|  | Overcast | Hot | Normal | Weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '|  | Overcast | Cool | Normal | Strong | Yes |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Sunny | Hot | High | Weak | No |'
  prefs: []
  type: TYPE_TB
- en: '| Outlook | Sunny | Hot | High | Strong | No |'
  prefs: []
  type: TYPE_TB
- en: '|  | Sunny | Cool | Normal | Weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '|  | Sunny | Mild | Normal | Strong | Yes |'
  prefs: []
  type: TYPE_TB
- en: '|  | Sunny | Mild | High | Weak | No |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Rain | Mild | High | Weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '|  | Rain | Cool | Normal | Weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '|  | Rain | Mild | Normal | Weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '|  | Rain | Cool | Normal | Strong | No |'
  prefs: []
  type: TYPE_TB
- en: Now, we can see that the branch Overcast always yields response as *Yes* (rightmost
    column), so we can leave that branch out, as the entropy is always 0, that is,
    node Overcast is a leaf node.
  prefs: []
  type: TYPE_NORMAL
- en: Now, at the branch Outlook -> Sunny, we will need to determine the next decision
    node by repeating the process that we did similar to the root. Basically, the
    steps we did previously will continue recursively until we determine all the leaf
    nodes. Let's translate this into code for our credit card example and see it in
    action.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the ID3 algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we would need to have an application; let's go ahead and create an Angular
    application as shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous example, we have seen that the first thing we will need is
    to list out our training data, which will be fed into our algorithm. In this case,
    we will need to first identify the different attributes that are affecting our
    target attribute (approved). Without going in too deep, the following are the
    major factors (and their possible values), which we are taking as an example of
    something, which can affect your approval chances:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Credit score: Overall score of your credit (Excellent, Good, Average, and Poor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Credit age: Age of your credit history in years ( >10, >5, >2, >=1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Derogatory remarks: If there are any remarks on your account (0, 1, 2, >=3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Utilization: How much of your approved credit you use (High, Medium, and Low)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hard inquiries: How many new accounts did you open recently (0, 1, 2, >=3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the fixed number of combinations of the preceding list, we can, in
    theory, generate a dataset that comprises all scenarios and then we can predict
    with 100% accuracy using that dataset, but where is the fun in that. We will instead
    be only taking half of the generated dataset and use it to predict the outcome
    of the other half.
  prefs: []
  type: TYPE_NORMAL
- en: Generating training dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although generating the training dataset can be done manually, it''s not fun.
    So, let''s write a small script, which will help us to create the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the preceding script, let''s create a small Node.js project within our
    credit-card project. At the root of the project, from Terminal, run the following
    commands to create the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Running the script above logs the `trainingDataWithApprovals` and `predictionDataWithApprovals`*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, copy the `trainingDataWithApprovals` into a file at the following path: `src/utils/training-data/credit-card.ts`*. *The
    data that is logged from the preceding code logs the data, an example of which
    can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/13e98339-b02f-458f-886c-4213a5cd38ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now move the `predictionDataWithApprovals` into the `app.component.ts`
    file and rename the `approved ` attribute to `expected` as that is what we expect
    the output to be. We will compare the actual output against this later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8319c073-7981-42f0-a73d-e8c44b6cdbc3.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the training data ready and imported into the project, let's
    create the rest of the algorithm to complete the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the decision tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep the code complexity to a minimum, we will be extracting all the helper
    methods that we would be recursively calling, as seen in the previous example.
    We can start with the `train()` method because that is going to be called first
    to determine the root decision node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do that, let''s create an Injectable service for our ID3 algorithm
    in the `utils` folder which we will be injecting where we wish to use it. This
    logic can live anywhere you wish, server or client side. One thing to note is
    that the dataset, in this case, is relatively small, so training the dataset and
    predicting the outcomes are an okay thing to do on the client side. With larger
    datasets, which take much longer to train, it is recommended to do this on the
    server side, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At each step of the algorithm, we will be relying heavily on helper methods
    to keep the implementation details clear; most of these would be provided by `lodash`,
    so let''s install and import it so that we can implement the `train()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `lodash` is installed, we can start with the `train()` method, which accepts
    three parameters: the training dataset, the target attribute, and the list of
    all the attributes extracted from the training dataset sans the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this service, mark it as a `provider` in the main module and then inject
    it in the `app.component`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to consume it in the main component, we can just import the ID3 service
    we have just created and then call the `train()` method on the service instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us also add some styles to our page to make it look nice, so update the
    `app.component.scss` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed in the preceding algorithm, the first thing that we do in our
    application is to determine the root decision node, for example, the attribute
    with the highest information gain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, you can see that we calculate the root decision node
    of the tree first by calculating the branch entropies of each attribute and determining
    the maximum information gain.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the root, we can recursively repeat the process for each branch
    of the node and then continue to find the decision nodes until we hit the entropy
    of 0, that is, leaf nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This modifies our `train()` method as follows :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, the `train()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes the input training data, the target attribute, and the attributes list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gets the current root attribute by calculating the maximum information gain
    at each of the branch of the attribute and creates the root node of the tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pushes the recursively generated sub-tree into the branches of the root node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Predicting outcome of sample inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our tree is ready and returned, we can use this in our `app.component`
    to determine whether the prediction matches that of the expected outcome using
    the `predict()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `app.component`, we consume the `predict()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Visualization of the tree and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have generated the tree and the expected/actual results of the input
    dataset based on training set, it's really difficult to visualize this data right
    now. So, to do that, let's create a small component that accepts the tree and
    renders the nested format of the tree on the UI. This is pretty minimal and is
    only for the purpose of understanding our data in the form of the decision tree.
  prefs: []
  type: TYPE_NORMAL
- en: Under the `utils` folder, let's first create the folder called `treeview` to
    contain our component. Let's call it `treeview`, as we create the component and
    inject it into the main module.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `treeview`, let''s first create the`treeview.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create the template that goes with the component and add it as
    `treeview.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s style the `treeview` to make it more legible, `treeview.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to consume the `treeview` component, let''s add it to the declarations
    in `app.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this, we just have to bind the tree that we generated in our `app.component`
    to the `tree-view` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `treeview` added, `app.component.html` gets updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders the tree on the UI as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/510c04ba-2032-4311-83cb-fb901db0b870.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, this is only a part of the big tree that is generated, which is tough
    to read and visualize. Let''s try the same with the Soccer example by switching
    the training and testing data with Soccer data instead, which we saw in the previous
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/286e3703-535c-4aec-90f9-a37f8841c963.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s render the input data that we passed in for testing our decision tree.
    For that, we can modify our `app.component.html`to show the table and visualization
    simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To style the table, we can add the following to our `app.component.scss` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8432186a-20ff-4bfa-be3c-8c3f10a2be95.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the Soccer example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d5a6ae12-b846-4521-aab9-aed522fae6f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a rather orthodox approach to understanding trees as
    data structures, where we deviated from the standard process of learning about
    a tree and implementing its methods. We instead took some real-world example and
    implemented the trees as we see fit, based on the use case at hand. This will
    be the case where you are provided the data and are challenged to implement it
    in a generic way to expand the use cases. In the next chapter, we will expand
    this approach and take it one step further, where we will note how it expands
    into graph theory.
  prefs: []
  type: TYPE_NORMAL
