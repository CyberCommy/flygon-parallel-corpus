- en: Optimizing Your Code for Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing your code for performance ensures your code is getting the most out
    of what C++ can offer. Unlike other high-level languages, C++ is capable of providing
    high-level syntactical freedom without sacrificing performance, although admittedly
    at the expense of a higher learning curve.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is important because it will demonstrate more advanced methods
    for optimizing your code, including how to benchmark your software at the unit
    level, how to examine the resulting assembly code your compiler produces for potential
    optimizations, how to reduce the number of memory resources your application is
    using, and why compiler hints such as `noexcept` are important. After reading
    this chapter, you will have the skills to write more efficient C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking your code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at assembly code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the number of memory allocations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring noexcept
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Prior to running these examples, you must install the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking your code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to benchmark and optimize your source code.
    Optimizing source code will result in more efficient C++, which increases battery
    life, improves performance, and so on. This recipe is important as the process
    of optimizing source code starts with determining which resource you plan to optimize,
    which could include speed, memory, and even power. Without benchmarking tools,
    it is extremely difficult to compare different approaches to the same problem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'There are countless benchmarking tools (anything that measures a single property
    of your program) available to C++ programmers, including C++ APIs such as Boost,
    Folly, and Abseil, and CPU-specific tools such as Intel''s vTune. There are also
    several profiling tools (anything the helps you understand the behavior of your
    program) such as valgrind and gprof. In this recipe, we will focus on two of these:
    Hayai and Valgrind. Hayai provides a simple example of a micro-benchmarking, while
    Valgrind provides an example of a more complete, though more complicated, dynamic
    analysis/profiling tool.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you've done this, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following command:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common optimization that''s applied to C++ is the speed of execution.
    To optimize C++ for speed, we must start by developing different approaches to
    the same problem and then benchmark each solution to determine which solution
    executes the fastest. Benchmarking tools such as Hayai, a C++ based benchmarking
    library on GitHub, aid in making this determination. To explain this, let''s look
    at a simple example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we execute the preceding code, we get the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b7883ec-9592-4fde-bb6f-bcc9465077c4.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we use the Hayai library to benchmark the performance
    difference between adding a string to a vector using `push_back()` versus `emplace_back()`.
    The difference between `push_back()` and `emplace_back()` is that `push_back()`
    creates the object and then copies or moves it into the vector, while `emplace_back()`
    creates the object in the vector itself without the need for the temporary object
    and subsequent copy/move. That is to say, if you use `push_back()`, an object
    must be constructed and then either copied or moved into the vector. If you use
    `emplace_back()`, the object is simply constructed. As expected, `emplace_back()`
    outperforms `push_back()`, which is why tools such as Clang-Tidy recommend the
    use of `emplace_back()` over `push_back()` whenever possible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Benchmark libraries such as Hayai are simple to use and extremely effective
    at aiding the programmer with optimizing source code and are capable of not only
    benchmarking speed but also resource usage as well. The problem with these libraries
    is they are better leveraged at the *unit* level and not at the *integration* and
    *system* level; that is, to test an entire executable, these libraries are not
    well suited to aid the programmer as they do not scale well as the size of the
    test increases. To analyze an entire executable and not a single function, tools
    such as Valgrind exist, which help you profile which functions need the most attention
    with respect to optimizations. From there, a benchmarking tool can be used to
    analyze the functions that need the most attention.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Valgrind is a dynamic analysis tool that''s capable of detecting memory leaks
    and tracing the execution of a program. To see this in action, let''s look at
    the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we increment a global variable (marked volatile to
    ensure the compiler does not optimize away the variable) from a function named
    `foo()` and then execute this function `100,000` times. To analyze this example,
    run the following (which uses `callgrind` to output how many times each function
    is called in your program):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This results in the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6aac4e5-2af5-426e-a176-9da59a0a379b.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, the `foo()` function is listed near the top of the preceding output
    (with the dynamic linker''s `_dl_lookup_symbol_x()` function called the most,
    which is used to link the program prior to execution). It should be noted that
    the program lists (on the left-hand side) the total number of instructions for
    the `foo()` function as `800,000`. This is due to the `foo()` function being `8`
    assembly instructions long and being executed `100,000` times. For example, let''s
    look at the assembly of the `foo()` function using `objdump` (a tool capable of
    outputting the compiled assembly of an executable), as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3a341c8-cf01-4265-9e74-e2496c465733.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'Using Valgrind, it is possible to profile an executable to determine which
    functions take the longest to execute. For example, let''s look at `ls`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This results in the following output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/050bd8f5-9adc-4825-b4db-fc8970010080.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: As we can see, the `strcmp` function is called a lot. This information can be
    combined with benchmarking APIs at the *unit* level to determine whether a faster
    version of `strcmp` can be written (for example, using handwritten assembly and
    special CPU instructions). Using tools such as Hayai and Valgrind, it is possible
    to isolate which functions in your program are consuming the most CPU, memory,
    and even power, and rewrite them to provide better performance while focusing
    your efforts on the optimizations that will provide the best return of investment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Looking at assembly code
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will take a look at the resulting assembly from two different
    optimizations: loop unrolling and pass-by-reference parameters. This recipe is
    important because it will teach you how to dive deeper into how the compiler converts
    C++ into executable code. This information will shed light on why C++ specifications
    such as the C++ Core Guidelines make the recommendations it does with respect
    to optimizations and performance. This is often critical when you''re attempting
    to write better C++ code, especially when you want to optimize it.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you've done this, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To compile the source code, run the following command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the best ways to learn how to optimize your C++ code is to learn how
    to analyze the resulting assembly code that the compiler generates after compilation.
    In this recipe, we will learn how this analysis is done by looking at two different
    examples: loop unrolling and pass-by-reference parameters.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at these examples, let''s look at a simple example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, we have nothing more than a `main()` function. We
    haven''t included any C or C++ libraries and the `main()` function itself is empty.
    If we compile this example, we will see that the resulting binary is still pretty
    large:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99ace8d4-1e3a-45be-a24f-c318040b45eb.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'In this case, the example is `22kb` in size. To show the resulting assembly
    that the compiler generated for this code, we can do the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The resulting output of the preceding command should be surprising as there
    is a lot of code for an application that does absolutely nothing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better feel for how much code there really is, we can refine the output
    by using `grep`, a tool that lets us filter text from any command. Let''s look
    at all of the functions in the code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d17573c5-b2e5-4905-a7a5-29b065898a0d.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, there are several functions the compiler automatically adds
    to the code for you. This includes the `_init()`, `_fini()`, and `_start()` functions.
    We can also look at a specific function, such as our main function, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b25fad2-bea6-4f4c-a87b-adb0e85f399d.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we search the output of `objdump` for `main>:` and
    `RETQ`. All the function names end with `>:` and the last instruction (typically)
    for each function is `RETQ` on an Intel 64-bit system.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the resulting assembly:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, it stores the current stack frame pointer (`rbp`) to the stack and loads
    the stack frame pointer with the current address of the stack (`rsp`) for the
    `main()` function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be seen in every function and is called the function''s prolog. The
    only code that `main()` executes is `return 0`, which was added to the code automatically
    by the compiler:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, the last assembly in this function contains the function''s epilog,
    which restores the stack frame pointer and returns:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we have a better understanding of how to get and read the resulting
    assembly for compiled C++, let''s look at an example of loop unrolling, which
    is the process of replacing a loop of instructions with its equivalent version
    of the instructions without a loop. To do this, ensure that the examples are compiled
    in release mode (that is, with compiler optimizations enabled) by configuring
    them using the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To understand loop unrolling, let''s look at the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the compiler encounters a loop, the resulting assembly it generates contains
    the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4414aa74-9275-444b-bf7a-a8a150a4a426.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: 'Let''s break this down:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first two instructions belong to the `for (auto i = 0U;` portion of the
    code. In this case, the `i` variable is stored in the `EAX` register and is set
    to `0` using the `XOR` instruction (the `XOR` instruction is faster on Intel for
    setting a register to 0 than a `MOV` instruction). The `NOPW` instruction can
    be safely ignored.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The next couple of instructions are interleaved, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These instructions represent the `i++;` and `data[i] = 42;` code. The first
    instruction stores the current value of the `i` variable and then increments it
    by one before storing `42` into the memory address indexed by `i`. Conveniently,
    this resulting assembly demonstrates a possible opportunity for optimization as
    the compiler could have achieved the same functionality using the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code stores the value `42` before executing `i++`, thus removing
    the need for the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A number of methods exist to realize this potential optimization, including
    using a different compiler or handwriting the assembly. The next set of instructions
    execute the `i < 1000;` portion of our `for` loop:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `CMP` instruction checks to see if the `i` variable is `1000` and, if not,
    uses the `JNE` instruction to jump to the top of the function to continue the
    loop. Otherwise, the remaining code executes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To see how loop unrolling works, let''s change the number of iterations the
    loop takes from `1000` to `4`, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we can see, the code is identical except for the number of iterations the
    loop takes. The resulting assembly is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4414aa74-9275-444b-bf7a-a8a150a4a426.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, the `CMP` and `JNE` instructions are missing. Now, the following
    code is compiled (*but there''s more!*):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The compiled code is converted into the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`return 0;` shows up in the assembly in-between the assignments. This is allowed
    because the return value of the function is independent of the assignment (since
    the assignment instructions never touch `RAX`), which provides the CPU with an
    additional optimization (as it can execute `return 0;` in parallel, though this
    is a topic that is out of the scope of this book). It should be noted that loop
    unrolling doesn''t require a small number of loop iterations to be used. Some
    compilers will partially unroll a loop to achieve optimizations (for example,
    executing the loop in groups of `4` instead of `1` at a time).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last example will look at pass-by-reference instead of pass-by-value. To
    start, recompile the code in debug mode:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s look at the following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, we''ve created a large structure and passed it by-value to
    a function named `foo()` in our main function. The resulting assembly for the
    main function is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45b46604-3410-4880-b1de-7ed7b6ecbd4b.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'The important instructions from the preceding example are as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding instructions copy the large structure to the stack and then call
    our `foo()` function. The copy occurs because the structure is passed by value,
    which means the compiler must perform a copy. As a side note, if you would like
    to see the output in a readable format and not a mangled format, add a `C` to
    the options, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e602d6c-13f7-4a30-9494-09b95deb705c.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'Finally, let''s pass-by-reference to see the resulting improvement:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we can see, we pass the structure by-reference instead of by-value. The
    resulting assembly is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60ea97a9-3744-48ce-bc91-000a09a842b0.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: Here, there is far less code, resulting in a faster executable. As we have learned,
    examining what the compiler produces can be effective if we wish to understand
    what the compiler is producing as this provides more information about potential
    changes you can make to write more efficient C++ code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the number of memory allocations
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hidden memory allocations are produced by C++ all the time when an application
    runs. This recipe will teach you how to determine when memory is allocated by
    C++ and how to remove these allocations when possible. Understanding how to remove
    memory allocations is important because functions such as `new()`, `delete()`,
    `malloc()`, and `free()` are not only slow, but the memory they provide is also
    finite. Removing unneeded allocations not only improves the overall performance
    of your application, but it also helps to reduce its overall memory requirements.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you've done this, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To compile the source code, run the following command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to monitor how much memory an application
    is consuming, as well as the different ways that C++ can allocate memory behind
    the scenes. To start, let''s look at a simple application that does nothing:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we can see, this application does nothing. To see how much memory the application
    has used, we will use Valgrind, a dynamic analysis tool, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b394af7-4501-4c48-bfd4-20e1f216d0de.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding example, our application has allocated heap memory
    (that is, memory allocated using `new()`/`delete()` or `malloc()`/`free()`). To
    determine where this allocation occurred, let''s use Valgrind again, but this
    time, we will enable a tool called **Massif**, which will trace where the memory
    allocation came from:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/def07c68-3679-40b0-ae34-b2b5ebb1757c.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'To see the output of the preceding example, we must output a file that was
    created for us automatically:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This results in us retrieving the following output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2434cd14-83e9-4761-b2d4-a3f3616eb879.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, the dynamic linker''s `init()` function is performing the allocation,
    which is `72,704` bytes in size. To further demonstrate how to use Valgrind, let''s
    take a look at this simple example, where we perform our own allocation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To see the memory allocation of the preceding source, we need to run Valgrind
    again:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ca77107-fafd-479a-8c84-a660ea785dd3.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, we have allocated `72,708` bytes. Since we know that the application
    will allocate `72,704` bytes for us automatically, we can see that Valgrind has
    successfully detected the `4` bytes we allocated (the size of an integer on Intel
    64-bit systems running Linux). To see where this allocation occurred, let''s use
    Massif again:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1b7826e-721d-44ad-8c3a-dbc55d4cc5e1.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, we''ve added the `--threshold=0.1` to the command-line options
    as this tells Valgrind that any allocation that makes up `.1%` of the allocations
    should be logged. Let''s `cat` the results (the `cat` program simply echoes the
    contents of a file to the console):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'By doing this, we get the following output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e0189c6-c5a1-44bb-a848-4d752d4bee3a.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: As we can see, Valgrind has detected the memory allocations from the `init()`
    function, as well as from our `main()` function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to analyze the memory allocations our application makes,
    let''s look at some different C++ APIs to see what types of memory allocations
    they make behind the scenes. To start, let''s look at an `std::vector`, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we''ve created a global vector of integers and then added `10,000` integers
    to the vector. Using Valgrind, we get the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01e29595-e5db-4190-8321-93c0973e49cb.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Here, we can see 16 allocations, with a total of `203,772` bytes. We know that
    the application will allocate `72,704` bytes for us, so we must remove this from
    our total, leaving us with `131,068` bytes of memory. We also know that we allocated
    `10,000` integers, which is `40,000` bytes in total. So, the question is, where
    did the other `91,068` bytes come from?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The answer is in how `std::vector` works under the hood. `std::vector` must
    ensure a continuous view of memory at all times, which means that when an insertion
    occurs and the `std::vector` is out of space, it must allocate a new, larger buffer
    and then copy the contents of the old buffer into the new buffer. The problem
    is that `std::vector` doesn't know what the total size of the buffer will be when
    all of the insertions are complete, so when the first insertion is performed,
    it creates a small buffer to ensure memory is not wasted and then proceeds to
    increase the size of the `std::vector` in small increments as the vector grows,
    resulting in several memory allocations and memory copies.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent such allocation from happening, C++ provides the `reserve()` function,
    which provides the user of a `std::vector` to estimate how much memory the user
    thinks they will need. For example, consider the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The code in the preceding example is the same as it is in the previous example,
    with the difference being that we added a call to the `reserve()` function, which
    tells the `std::vector` how large we think the vector will be. Valgrind''s output
    is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/726ac6f0-8701-40ea-b53e-310902914389.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: As we can see, the application allocated `112,704` bytes. If we remove our `72,704`
    bytes that the application creates by default, we are left with `40,000` bytes,
    which is the exact size we expected (since we are adding `10,000` integers to
    the vector, with each integer being `4` bytes in size).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Data structures are not the only type of C++ Standard Library API that performs
    hidden allocations. Let''s look at an `std::any`, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this example, we created an `std::any` and assigned it an integer and an
    `std::string`. Let''s look at the output of Valgrind:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56140dbb-bf2e-4670-82e2-15eb7134ce6d.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, `3` allocations occurred. The first allocation occurs by default,
    while the second allocation is produced by the `std::string`. The last allocation
    is produced by the `std::any`. This occurs because `std::any` has to adjust its
    internal storage to account for any new random data type that it sees. In other
    words, to handle a *generic* data type, C++ has to perform an allocation. This
    is made worse if we keep changing the data type. For example, consider the following
    code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding code is identical to the previous example, with the only difference
    being that we swap between data types. Valgrind produces the following output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1df2f995-397d-4929-adfd-d6847ce57abf.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, `9` allocations occurred instead of `3`. To solve this problem,
    we need to use an `std::variant` instead of `std::any`, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The difference between `std::any` and `std::variant` is that `std::variant`
    requires that the user states which types the variant must support, removing the
    need for dynamic memory allocation on assignment. Valgrind''s output is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a8432c6-3aa6-4f3e-9f2d-d83c733ea3d2.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Now, we only have `2` allocations, as expected (the default allocation and the
    allocation from `std::string`). As shown in this recipe, libraries, including
    the C++ Standard Library, can hide memory allocations, potentially slowing down
    your code and using more memory resources than you intended. Tools such as Valgrind
    can be used to identify these types of problems, allowing you to create more efficient
    C++ code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Declaring noexcept
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 introduced the `noexcept` keyword, which, besides simplifying how exceptions
    were used in general, also included a better implementation of C++ exceptions
    that removed some of their performance hits. However, this doesn't mean that exceptions
    do not include *overhead* (that is, performance penalties). In this recipe, we
    will explore how exceptions add overhead to an application and how the `noexcept`
    keyword can help reduce these penalties (depending on the compiler).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is important because it will demonstrate that if a function doesn't
    throw an exception, then it should be marked as such to prevent the additional
    overhead regarding the total size of the application, resulting in an application
    that loads faster.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you've done this, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To compile the source code, run the following command:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn why it is so important to mark a function as
    `noexcept` if it shouldn''t throw an exception. This is because it removes the
    added overhead to the application for exception support, which can improve execution
    time, application size, and even load time (this depends on the compiler, which
    Standard Library you are using, and so on). To show this, let''s create a simple
    example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first thing we need to do is create a class that sets a `private` member
    variable when it is destructed, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can create two functions. The first function throws an exception, while
    the second function is our main function. This function creates an instance of
    our class and calls the `foo()` function inside a `try`/`catch` block. In other
    words, at no time will the `main()` function throw an exception. If we look at
    the assembly for the main function, we''ll see the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8b37484-b6b5-4a42-a49c-ace342254030.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, our main function makes a call to `_Unwind_Resume`, which is
    used by the exception unwinder. This extra logic is due to the fact that C++ has
    to add additional exception logic to the end of the function. To remove this extra
    logic, tell the compiler that the `main()` function isn''t thrown:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Adding `noexcept` tells the compiler that an exception cannot be thrown. As
    a result, the function no longer contains the extra logic for handling an exception,
    as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b17102a6-7e31-4c82-8751-308a935b23f2.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: As we can see, the unwind function is no longer present. It should be noted
    that there are calls to catch functions, which are due to the `try`/`catch` block
    and not the overhead of an exception.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，取消函数不再存在。值得注意的是，存在对catch函数的调用，这是由于`try`/`catch`块而不是异常的开销。
