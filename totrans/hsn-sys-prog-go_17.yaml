- en: Coordination Using Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about the relatively new context package and its usage in concurrent
    programming. It is a very powerful tool by defining a unique interface that's
    used in many different places in the standard library, as well as in many third-party
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what context is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Studying its usage in the standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a package that uses context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Context is a relatively new component that entered the standard library in version
    1.7\. It is an interface for synchronization between goroutines that was used
    internally by the Go team and ended up being a core part of the language.
  prefs: []
  type: TYPE_NORMAL
- en: The interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main entity in the package is `Context` itself, which is an interface.
    It has only four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s learn about these four methods here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Deadline`: Returns the time when the context should be cancelled, together
    with a Boolean that is `false` when there is no deadline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Done`: Returns a receive-only channel of empty structs, which signals when
    the context should be cancelled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Err`: Returns `nil` while the `done` channel is open; otherwise it returns
    the cause of the context cancellation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Value`: Returns a value associated with a key for the current context, or
    `nil` if there''s no value for the key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Context has many methods compared to the other interfaces of the standard library,
    which usually have one or two methods. Three of them are closely related:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Deadline` is the time for cancelling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Done` signals when the context is done'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Err` returns the cause of the cancellation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last method, `Value`, returns the value associated with a certain key. The
    rest of the package is a series of functions that allow you to create different
    types of contexts. Let's go through the various functions that comprise the package
    and look at various tools for creating and decorating contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Default contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TODO` and `Background` functions return `context.Context` without the need
    for any input argument. The value that's returned is an empty context, though,
    their distinction is just semantic.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Background` is an empty context that doesn''t get cancelled, hasn''t got a
    deadline, and doesn''t hold any values. It is mostly used by the `main` function
    as the root context or for testing purposes. The following is some example code
    for this context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/y_3ip7sdPnx](https://play.golang.org/p/y_3ip7sdPnx).
  prefs: []
  type: TYPE_NORMAL
- en: We can see that, in the context of the example, the loop goes on infinitely
    because the context is never completed.
  prefs: []
  type: TYPE_NORMAL
- en: TODO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TODO` is another empty context that should be used when the scope of the context
    isn''t clear or if the type of context isn''t available yet. It is used in the
    exact same way as `Background`. As a matter of fact, under the hood, they are
    the same thing; the distinction is only semantical. If we look at the source code,
    they have the exact same definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The source for this code can be found at [https://golang.org/pkg/context/?m=all#pkg-variables](https://golang.org/pkg/context/?m=all#pkg-variables).
  prefs: []
  type: TYPE_NORMAL
- en: These basic contexts can be extended using the other functions of the package.
    They will act as decorators and add more capabilities to them.
  prefs: []
  type: TYPE_NORMAL
- en: Cancellation, timeout, and deadline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The context we looked at is never cancelled, but the package offers different
    options for adding this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Cancellation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `context.WithCancel` decorator function gets a context and returns another
    context and a function called `cancel`. The returned context will be a copy of
    the context that has a different `done` channel (the channel that marks that the
    current context is done) that gets closed when the parent context does or when
    the `cancel` function is called – whatever happens first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see that we wait a few seconds before calling
    the `cancel` function, and the program terminates correctly. The value of `Err`
    is the `context.Canceled` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/fNHLIZL8e0L](https://play.golang.org/p/fNHLIZL8e0L).
  prefs: []
  type: TYPE_NORMAL
- en: Deadline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`context.WithDeadline` is another decorator, which specifies a time deadline
    as `time.Time`, and applies it to another context. If there is already a deadline
    and it is earlier than the one provided, the specified one gets ignored. If the
    `done` channel is still open when the deadline is met, it gets closed automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we set the deadline to be 5 seconds from now and
    call `cancel` 10 seconds after. The deadline arrives before the cancellation and
    `Err` returns a `context.DeadlineExceeded` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/iyuOmd__CGH](https://play.golang.org/p/iyuOmd__CGH).
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the preceding example behaves exactly as expected. It will print
    the `tick` statement each second a few times until the the deadline is met and
    the error is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Timeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last cancel-related decorator is `context.WithTimeout`, which allows you
    to specify a `time.Duration` together with the context and closes the `done` channel
    automatically when the timeout is passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there a deadline active, the new value applies only if it''s earlier than
    the parent. We can look at a pretty identical example, beside the context definition,
    and get the same result that we got for the deadline example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/-Zp63_e0zYD](https://play.golang.org/p/-Zp63_e0zYD).
  prefs: []
  type: TYPE_NORMAL
- en: Keys and values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `context.WithValue` function creates a copy of the parent context that has
    the given key associated with the specified value. Its scope holds values that
    are relative to a single request while it gets processed and should not be used
    for other scopes, such as optional function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The key should be something that can be compared, and it's a good idea to avoid
    `string` values because two different packages using context could overwrite each
    other's values. The suggestion is to use user-defined concrete types such as `struct{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see an example where we take a base context and we add a different
    value for each goroutine, using an empty struct as a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/lM61u_QKEW1](https://play.golang.org/p/lM61u_QKEW1).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see that cancelling the parent cancels the other contexts. Another
    valid key type could be exported pointer values, which won''t be the same, even
    if the underlying data is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/05XJwWF0-0n](https://play.golang.org/p/05XJwWF0-0n).
  prefs: []
  type: TYPE_NORMAL
- en: We can see that defining a key pointer with the same underlying value doesn't
    return the expected value.
  prefs: []
  type: TYPE_NORMAL
- en: Context in the standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve covered the contents of the package, we will look at how to
    use them with the standard package or in an application. Context is used in a
    few functions and methods of standard packages, mostly network packages. Let''s
    go over them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http.Server` uses it with the `Shutdown` method so that it has full control
    over timeout or to cancel an operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.Request` allows you to set a context using the `WithContext` method. It
    also allows you to get the current context using `Context`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `net` package, `Listen`, `Dial`, and `Lookup` have a version that uses `Context` to
    control deadlines and timeouts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `database/sql` package, context is used to stop or timeout many different
    operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before the introduction of the official package, each HTTP-related framework
    was using its own version of context to store data relative to HTTP requests.
    This resulted in fragmentation, and the reuse of handlers and middleware wasn't
    possible without rewriting the middleware or any specific binding code.
  prefs: []
  type: TYPE_NORMAL
- en: Passing scoped values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction of `context.Context` in `http.Request` tries to address this
    issue by defining a single interface that can be assigned, recovered, and used
    in various handlers.
  prefs: []
  type: TYPE_NORMAL
- en: The downside is that a context isn't assigned automatically to a request, and
    context values cannot be recycled. There should be no really good reason to do
    that since the context should store data that's specific to a certain package
    or scope, and the packages themselves should be the only ones that are able to
    interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good pattern is the usage of a unique unexported key type combined with auxiliary
    functions to get or set a certain value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A context request is the only case in the standard library where it is stored
    in the data structure with the `WithContext` method and it's accessed using the
    `Context` method. This has been done in order to not break the existing code,
    and maintain the promise of compatibility of Go 1.
  prefs: []
  type: TYPE_NORMAL
- en: The full example is available here: [https://play.golang.org/p/W6gGp_InoMp](https://play.golang.org/p/W6gGp_InoMp).
  prefs: []
  type: TYPE_NORMAL
- en: Request cancellation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good usage of context is for cancellation and timeout when you''re executing
    an HTTP request using `http.Client`, which handles the interruption automatically
    from the context. The following example does exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The context cancellation method can also be used to interrupt the current HTTP
    request that's passed to a client. In a scenario where we are calling different
    endpoints and returning the first result that's received, it would be a good idea
    to cancel the other requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an application that runs a query on different search engines
    and returns the results from the quickest one, cancelling the others. We can create
    a web server that has a unique endpoint that answers back in 0 to 10 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a cancellable context for the requests, combined with a wait group
    to synchronize it with the end of the request. Each goroutine will create a request
    and try to send the result using a channel. Since we are only interested in the
    first one, we will use  `sync.Once` to limit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When this program runs, we will see that one of the requests is completed successfully
    and gets sent to the channel, while the others are either cancelled or ignored.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net/http` package has several uses of context, including stopping the listener
    or being part of a request.
  prefs: []
  type: TYPE_NORMAL
- en: Shutdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`http.Server` allows us to pass a context for the shutdown operation. This
    allows to us to use some of the context capabilities, such as cancelling and timeout.
    We can define a new server with its `mux` and a cancellable context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can launch the server in a separate goroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The context will be complete when the shutdown endpoint is called and the cancellation
    function is invoked. We can wait for that event and then use another context with
    a timeout to call the shutdown method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to terminate the server effectively within the timeout, after
    which it will terminate with an error.
  prefs: []
  type: TYPE_NORMAL
- en: Passing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another usage of context in a server is as a propagation of values and cancellation
    between different HTTP handlers. Let''s look at an example where each request
    has a unique key that is an integer. We will use a couple of functions that are
    similar to the example where we had values using integers. The generation of a
    new key will be done with `atomic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define another function that takes any HTTP handler and creates
    the context, if necessary, and adds the key to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we can define a very simple handler that serves files under
    a certain root directory. This function will use the key from the context to log
    information correctly. It will also check that the file exists before trying to
    serve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine those handlers to serve content from different folders, such
    as the home user or the temporary directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We are using `http.StipPrefix` to remove the first part of the path and obtain
    the relative path, and pass it to the handler underneath. The resulting server
    will use context to pass the key value between handlers – this allows us to create
    another similar handler and use the `AssignKeyHandler` function to wrap the handler
    and `GetKey(r.Context())` to access the key inside our handler.
  prefs: []
  type: TYPE_NORMAL
- en: TCP dialing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The network package offers context-related functionalities, such as dialing
    cancellation when we're dialing or listening to incoming connections. It allows
    us to use the timeout and cancellation capabilities of context when dialing a
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: Cancelling a connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to test out the usage of context in a TCP connection, we can create
    a goroutine with a TCP server that will wait a period of time before starting
    the listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a context with a timeout that''s lower than the server waiting time. We
    have to use `net.Dialer` in order to use the context in a dial operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The application will try to connect for a short time, but will eventually give
    up when the context expires, returning an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a situation where you want to establish a single connection from a series
    of endpoints, context cancellation would be a perfect use case. All the connection
    attempts would share the same context, and the first connection that dials correctly
    would call the cancellation, stopping the other attempts. We will create a single
    server that is listening to one of the addresses we will try to call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can try to dial all three addresses and cancel the context as soon
    as one connects. We will use a `WaitGroup` to synchronize with the end of the
    goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What we will see in the output of this program is one connection succeeding,
    followed by the cancellation error of the other attempt.
  prefs: []
  type: TYPE_NORMAL
- en: Database operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We aren''t looking at the `sql/database` package in this book, but for the
    sake of completion, it is worth mentioning that it uses context too. Most of its
    operations have a counterpart with context, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: Beginning a new transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing a query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pinging the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing a query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes the packages in the standard library that use context. Next,
    we are going to try to use context to build a package to allow the user of that
    package to cancel requests.
  prefs: []
  type: TYPE_NORMAL
- en: Experimental packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A notable example in the experimental package that uses context is one we've
    already looked at – semaphore. Now that we have a better understanding of what
    context is for, it should be pretty obvious why the acquire operation also takes
    a context in as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating our application, we can provide a context with a timeout or cancellation
    and act accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Running this application will show that the semaphore is acquired for the first
    second, but after that the context expires and all the remaining operations fail.
  prefs: []
  type: TYPE_NORMAL
- en: Context in your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`context.Context` is the perfect tool to integrate into your package or application
    if it has operations that could take a long time and a user can cancel them, or
    if they should have time limitations such timeouts or deadlines.'
  prefs: []
  type: TYPE_NORMAL
- en: Things to avoid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though the context scope has been made very clear by the Go team, developers
    have been using it in various ways – some less orthodox than others. Let's check
    out some of them and which alternatives there are, instead of resorting to context.
  prefs: []
  type: TYPE_NORMAL
- en: Wrong types as keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first practice to avoid is the usage of built-in types as keys. This is
    problematic because they can be overwritten because two interfaces with the same
    built-in values are considered the same, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/2W3noYQP5eh](https://play.golang.org/p/2W3noYQP5eh).
  prefs: []
  type: TYPE_NORMAL
- en: The first print instruction outputs `true`, and since the keys are compared
    by value, the second assignment shadows the first, resulting in the values for
    both keys being the same. A potential solution to this is to use an empty struct
    custom type, or an unexported pointer to a built-in value.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It might so happen that you need to travel a long way through a stack of function
    calls. A very tempting solution would be to use a context to store that value
    and recall it only in the function that needs it. It is generally not a good idea
    to hide a required parameter that should be passed explicitly. It results in less
    readable code because it won't make it clear what influences the execution of
    a certain function.
  prefs: []
  type: TYPE_NORMAL
- en: It is still much better to pass the function down the stack. If the parameters
    list is getting too long, then it could be grouped into one or more structs in
    order to be more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters could be grouped in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Optional arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Context should be used to pass optional parameters around, and also used as
    a sort of catch-all, like Python `kwargs` or JavaScript `arguments`. Using context
    as a substitute for behaviors can be very problematic because it could cause the
    shadowing of variables, like we saw in the example of `context.WithValue`.
  prefs: []
  type: TYPE_NORMAL
- en: Another big drawback of this approach is hiding what's happening and making
    the code more obscure. A much better approach when it comes to optional values
    is using a pointer to structure arguments – this allows you to avoid passing the
    structure at all with `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you had the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `Optional`, you would have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Globals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some global variables can be stored in a context so that they can be passed
    through a series of function calls. This is generally not good practice since
    globals are available in every point of the application, so using context to store
    and recall them is pointless and a waste of resources and performance. If your
    package has some globals, you can use the Singleton pattern we looked at in [Chapter
    12](7d7f27fa-3ef5-4751-baca-dd6169979d01.xhtml), *Synchronization with sync and
    atomic*, to allow access to them from any point of your package or application.
  prefs: []
  type: TYPE_NORMAL
- en: Building a service with Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now focus on how to create packages that support the usage of context.
    This will help us put together what we've learned about concurrency up until now.
    We will try to create a concurrent file search that makes uses of channels, goroutines,
    synchronization, and context.
  prefs: []
  type: TYPE_NORMAL
- en: Main interface and usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The signature of the package will include a context, the root folder, the search
    term, and a couple of optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Search in contents**: Will look for the string in the file''s contents instead
    of the name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exclude list**: Will not search the files with the selected name/names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it should be a concurrent function, the return type could be a channel
    of result, which could be either an error or a series of matches in a file. Since
    we can search for the names of content, the latter could have more than one match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous function will return a receive-only channel of the `Result` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, this function would keep receiving values from the channel until it gets
    closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Exit and entry points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The result channel should be closed by either the cancellation of the context,
    or by the search being over. Since a channel cannot be closed twice, we can use
    `sync.Once` to avoid closing the channel for the second time. To keep track of
    the goroutines that are running, we can use `sync.Waitgroup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We could launch a goroutine for each file so that we can define a private function
    that we can use as an entry point and then use it recursively for subdirectories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The main exported function will start by adding a value to the wait group.
    It will then launch the private function, starting it as an asynchronous process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The last thing each `fileSearch` should do is call `WaitGroup.Done` to mark
    the end of the current file.
  prefs: []
  type: TYPE_NORMAL
- en: Exclude list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The private function will decrease the wait group counter before it finishes
    using the `Done` method.. Besides that, the first thing it should do is check
    the filename so that it can skip it if it is in the exclusion list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If that is not the case, we can check the current file''s information using
    `os.Stat` and send an error to the channel if we don''t succeed. Since we cannot
    risk causing a panic by sending into a closed channel, we can check whether the
    context is done, and if not, send the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Handling directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The information that''s received will tell us whether the file is a directory
    or not. If it is a directory, we can get a list of files and handle the error,
    as we did earlier with `os.Stat`. Then, we can launch another series of searches,
    one for each file, if the context isn''t already done. The following code sums
    up these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Checking file names and contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the file is a regular file and not a directory, we can compare the file
    name or its contents, depending on the options that are specified. Checking the
    file name is pretty easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are searching for the contents, we should open the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can read the file line by line to search for the selected term. If
    the context expires while we are reading the file, we will stop all operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can check for errors from the scanner. If there''s none and the
    search has results, we can send all the matches to the output channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In less than 200 lines, we created a concurrent file search function that uses
    one goroutine per file. It takes advantage of a channel to send results and synchronization
    primitives in order to coordinate operations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at what one of the newer packages, context, is all
    about. We saw that `Context` is a simple interface that has four methods, and
    should be used as the first argument of a function. Its main scope is to handle
    cancellation and deadlines to synchronize concurrent operations and provide the
    user with functionality to cancel an operation.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how the default contexts, `Background` and `TODO`, don't allow cancellation,
    but they can be extended using various functions of the package to add timeouts
    or cancellation. We also talked about the capabilities of context when it comes
    to holding values and how this should be used carefully in order to avoid shadowing
    and other problems.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we dived into the standard package to see where context is already used.
    This included the HTTP capabilities of requests, where it can be used for values,
    cancellation, and timeout, and the server shutdown operation. We also saw how
    the TCP package allows us to use it in a similar fashion with a practical example,
    and we also listed the operations in the database package that allow us to use
    context to cancel them.
  prefs: []
  type: TYPE_NORMAL
- en: Before building our own functionality using context, we went into some of the
    uses that should be avoided, from using the wrong types of keys to using context
    to pass values around that should be in a function or method signature instead.
    Then, we proceeded to create a function that searches files and contents, using
    what we have learned about concurrency from the last three chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will conclude the concurrency section of this book by showing
    off the most common Go concurrency patterns and their usage. This will allow us
    to put together all that we have learned so far about concurrency in some very
    common and effective configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a context in Go?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between cancellation, deadline, and timeout?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the best practices when passing values with a context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which standard packages already use context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
