- en: Chapter 10. Data Binding Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic Angular view with data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering lists and using Angular controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing, filters, and backend services in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Angular's client-side validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a chart component with Angular directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring applications for Meteor.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming and data in Meteor.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live HTML and user-specific data in Meteor.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security mechanisms in Meteor.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within modern web applications, a lot of code is gradually moving from the server
    to the browser. As a result, new possibilities and challenges are emerging.
  prefs: []
  type: TYPE_NORMAL
- en: One such possibility is instant automated data binding. Client-side code enables
    us to bind model objects to parts of the web page. This means that changes in
    the model are automatically and instantly reflected in the view element displaying
    that model.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, a challenge in code organization also emerges. JavaScript does
    not provide adequate module facilities or code organization models that are needed
    in larger browser applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to cover two complete frameworks that attempt to
    provide solutions to both challenges. These frameworks support a declarative,
    data-binding approach to writing web applications. At the same time, they provide
    modularization and organization facilities, allowing us to give a clear structure
    to our code—to separate it into models, views, controllers, or view-models and
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first half of the chapter will cover Angular—a framework coming from Google
    that provides client-side bindings, and can work with any server-side stack (Rails,
    Node.js, Django, and so on). It provides data binding+ and organizational facilities.
    We''ll do the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Create basic Angular views with data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Angular controllers to write a small list editing application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add validation to our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a simple markdown wiki using the Angular router and filters and define
    a local storage service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use directives to create a component that displays a chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second half will cover Meteor—a complete framework and platform that covers
    both the client and the server side, and also provides data binding and organizational
    facilities. Meteor is more of a truly different way of building web applications,
    and we will cover some of the following basics for it:'
  prefs: []
  type: TYPE_NORMAL
- en: Structuring your application Meteor style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of reactive programming, and how to work with data in Meteor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live HTML and user data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security and authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic Angular view with data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular.js allows us to create views with automated data binding. This means
    that we can specify model objects whose properties will bind to element properties
    or content.
  prefs: []
  type: TYPE_NORMAL
- en: Automated data binding simplifies programming. Instead of adding event listeners
    to watch for changes inside our elements and then manually updating elements by
    adding classes, changing attributes, or modifying their content, we can simply
    change the model objects, and the elements will get updated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to create a simple currency converter that converts
    USD to GBP using a fixed conversion rate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular is available via CDN, so no downloading is necessary. We can simply
    include it to our page.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write the Angular template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `index.html` that contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our HTML page is not written in pure, standard HTML. There are a lot of new
    attributes added, and we're going to explain them in the following paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: The `ng-app` attribute tells Angular which part of our page should be managed
    by it. In our case, it's the only `div` element on the page. We could also put
    this tag on the HTML element, in which case the entire page will be controlled
    by Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `div`, we have an input element with an `ng-model` attribute with
    the value `usdValue`. This attribute causes Angular to add a new property into
    the view's model called `usdValue`. The value of this property will automatically
    update to the value of the input field when the content changes. This property
    now becomes globally available inside the view.
  prefs: []
  type: TYPE_NORMAL
- en: Our `span` element contains an `ng-show` attribute with the value `usdValue`.
    This attribute will cause the `span` element to be shown only if `usdValue` has
    a non-falsy value. Examples of "falsy" values are null, empty string, undefined,
    and zero—for those values, the `span` element will be hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, inside the span we have both the currency and an expression placed
    within double curly braces. As this expression depends on the value of the `usdValue`
    variable, the contents of the `span` element will be automatically updated whenever
    that value changes.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting binding connects the `span` element with the input field. Whenever
    the input field is changed, the model `usdValue` variable is automatically updated.
    This in turn causes both the visibility and the content of the `span` element
    to update automatically.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ng` attributes are called **attribute directives** in Angular. Angular
    also allows you to write your own attribute directives.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ng` attributes are non-standard, and HTML validators will complain when
    encountering them. To work around this, you can prefix them with the `data` prefix.
    For example, `data-ng-model` will validate fine, as custom attributes with the
    `data` prefix are standards-compliant.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering lists and using Angular controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular allows us to interact with our view through code by letting us set a
    controller for the view. The controller can modify the view scope (the model)
    and call other operations, such as background services.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to use a controller to write a simple to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `index.html` that will display a list of tasks, the form
    to add a new task, and the button to hide all the tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named `example.js` to define the controller for our to-do list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we declare that the Angular app is going to be our entire page
    by setting the `ng-app` attribute to the root element of the page.
  prefs: []
  type: TYPE_NORMAL
- en: The `div` element represents our view. This element has an `ng-controller` attribute
    that specifies the controller for the view. The controller is a function defined
    in the global scope of the window.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this view, we use the `ng-repeat` directive to display our list of tasks
    inside list elements. Inside this list, there is a checkbox denoting the task
    completion state and the text of the task.
  prefs: []
  type: TYPE_NORMAL
- en: The `tasks` variable belongs to the view's scope. We expect the variable to
    contain an array of tasks, each having a `text` description, completion status
    in the `complete` field (bound to the checkbox of the task), and a `hidden` flag.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the page is the form used to add tasks to the list. Using the
    `ng-submit` attribute, we declare that this form should execute the `addTask()`
    function when submitted. In order to do this, we expect the scope to contain the
    `addTask()` function. The `text` field in this form is bound to the `taskToAdd`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to hide the completed tasks, we have added a button to the page. By
    setting the value of its `ng-click` attribute to `hideCompleted()`, we tell the
    button to execute the `hideCompleted()` function when the button is clicked. For
    this, we expect that the scope of the view contains a `hideCompleted()` function.
  prefs: []
  type: TYPE_NORMAL
- en: How can we attach the necessary function and some data to the view?
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we can use our controller function defined in `example.js`. The
    controller function is invoked when the view is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this controller, there is no DOM manipulation code or DOM event bindings.
    Instead, what we have is a `$scope` parameter passed to the controller by Angular.
    This parameter represents the variable scope of the view. The controller simply
    attaches variables such as the `tasks` array to that scope, and the variable immediately
    becomes available to the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also attach the `addTask()` and `hideCompleted()` functions to the scope.
    The code inside is fairly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addTask` pushes a new task from the list with the content of the `taskToAdd`
    scope variable and then resets its value to an empty string. This will cause Angular
    to update the list of tasks and to reset the content of the `input` field bound
    to `taskToAdd`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hideCompleted` goes through the list of tasks and sets the `hidden` flag to
    every completed task. As a result, the `ng-show` directive automatically causes
    the tasks marked as `hidden` to be hidden from the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example highlights the main differences when working with an automatic
    data binding framework.
  prefs: []
  type: TYPE_NORMAL
- en: Without automated data binding, we would need to manually pass data to the template
    render function, then set up event bindings for actions. The actions would manually
    pull data from the view, do the actual model manipulation, then call the render
    function again. This is an imperative approach to templating.
  prefs: []
  type: TYPE_NORMAL
- en: With automated data binding frameworks, inside the template we specify how its
    parts are connected with the model object. Then, to update the view, we simply
    manipulate or change the model and the view updates automatically to reflect those
    changes. This is a declarative approach to templating.
  prefs: []
  type: TYPE_NORMAL
- en: The only downside in this recipe is that our controller must be declared in
    the global variable scope. We're going to show how to avoid this in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Routing, filters, and backend services in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better utilize the browser's Back button functionality, as well as allow
    users to copy and paste links, Angular provides a router module. The router functions
    similarly to a server-side router, with the path appended in the URL after the
    hash along with query string parameters. It will redirect the user to the appropriate
    pair of controller and view.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, to share data between views and the server, we need to define
    a module for the backend storage. We're going to use HTML5 `localStorage` instead—the
    resulting code will be very similar.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to build a simple markdown-based wiki that stores
    pages in local storage. Angular also supports filters, so we're going to write
    a markdown filter module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write our Angular app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `index.html` that will host the Angular application. It
    includes all the necessary scripts and sets up the `div` element that will host
    the views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To display markdown, we''re going to need a `markdown` filter. Define the Angular
    filter inside an Angular module called `markdown`, within `markdown-filter.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To store the wiki pages, we''re going to need a storage module. Define a factory
    that creates `Storage` objects inside the module called `storage` in `storage.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define our wiki application inside `app.js`. Besides the `storage`
    and `markdown` modules, we''re also going to use `ngSanitize` to display unsafe
    HTML. We''re going to define two routes, one for editing and another for viewing
    pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define our viewing template in `view.html`. Besides displaying the article,
    it should also provide an edit link as well as a link to return to the main page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now let's define the viewing controller inside `view-controller.js`. It should
    load the displayed article from storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the editing template inside `edit.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then define the editing controller inside `edit-controller.js`; it should load
    the page from `storage` and define the `savePage()` method to save a page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s style things up by adding some CSS in `style.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the application, run an HTTP server for the directory. Assuming you
    have Node.js installed (see [Appendix A](apa.html "Appendix A. Installing Node.js
    and Using npm"), *Installing Node.js and Using npm*), install `http-server`, and
    then run it in the `app` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Point your browser to `http://localhost:8080/` to see the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous recipe defined a simple, single-controller application and as such,
    it had no real need for routing and modularization. This recipe, on the other
    hand, implements a more complex application with multiple views and controllers,
    as well as storage and filter modules.
  prefs: []
  type: TYPE_NORMAL
- en: Our Angular app begins in `app.js`—defined as a module called `wiki`, the same
    as the `ng-app` attribute of the `html` tag inside our `index.html` file. It contains
    the main glue code that loads our custom `markdown` and `storage` modules and
    sets up the controllers and views.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure our app, we load two objects: `$locationProvider` and `$routeProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding loading syntax is the array syntax, where we define the module
    names to load as elements of the array; then we define the function taking these
    modules as arguments at the end of the array and the executing the code that uses
    them.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `locationProvider` module to enable `html5mode`, where every URL
    looks as if it has been loaded as a separate page, containing no hashes. This
    mode requires the HTML5 browser history API. As a fallback, we define a prefix
    `!` to use after the hash and before the URL.
  prefs: []
  type: TYPE_NORMAL
- en: To define our routes, we use `routeProvider`. We declare that any `/edit/:page`
    URL will be handled by `EditController` and displayed with the `edit.html` template.
    The `:page` part of the URL is a `URL` parameter and matches any text—it will
    be accessible in the controller. We also define a `/:page` route used to view
    pages, which is handled by `ViewController` and is using the `view.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: The `view` template contains a `div` element that is shown only if the page
    text is defined. The way we do this is using the `ng-bind-html-unsafe` directive.
    This directive allows us to bind an expression, which is evaluating to arbitrary
    HTML, to the element, which is exactly what we need for the `markdown` filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the filter we use the pipe character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The editing link for the page is located at the bottom of the link, taking us
    to the editing view for this page. Similarly, on the edit page, we bind both the
    markdown text and the generated HTML to different elements. As a result, changing
    the textarea results with instant updates to the displayed HTML, giving us a live
    preview of the generated page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the view and the edit controllers are fairly simple: the first controller
    loads the article from storage, while the second controller defines a `save()`
    function that saves the article back to the storage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is new in our controllers are the extra parameters they receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'These parameters cause Angular to inject the requested objects by passing them
    as parameters to the controllers. In this case, the `Storage` object is requested
    (defined in the `storage` module) and the `$routeParams` built-in object is requested.
    The order of the parameters doesn''t matter, what matters is their names. We can
    avoid this behavior by using the array syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding syntax, Angular will inject the objects in the order specified
    by the array.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a filter is simple. Inside `markdown-filter.js`, we define a new module
    called `markdown`. Then we declare that the module will provide a filter called
    `markdown`. To define a filter, we define a function that constructs and returns
    the filter. The returned filter should be a function taking a single input argument
    and returning the filtered output. Our `markdown` filter simply calls `markdown.toHTML`
    on the input argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `storage` object is defined in a similar way in `storage.js`. Here we define
    a new module called `storage`. In this module, we define a constructor for a `Storage`
    object, which provides the `get()` and `save()` functions. Then we can inject
    our storage in any controller by adding an argument called `Storage`. In Angular,
    these injectable objects created by factories are usually called **services**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `ng-bind-html-unsafe` is not secure and may allow an attacker to write
    a page that injects arbitrary scripts that steal personal information or perform
    other actions on behalf of the user. To avoid this, the `$sanitize` service from
    the `ngSanitize` module should be used to process HTML whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular's client-side validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular extends the new HTML5 validation attributes on its own, and allows the
    users to add error conditions to the template. With these capabilities of Angular,
    we can add custom error messages and styles to our forms.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to create a simple user registration form in Angular
    and then we'll add some validation rules to the form.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `index.html` that contains the registration form and the
    validation rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular adds validation support by extending the built-in HTML5 validation
    rules with newly added rules and properties. Let''s look at the ones we''re using
    inside our form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first field is the user''s username. Besides the HTML5 `required` attribute,
    we''re also using two validation directives: `ng-minlength` and `ng-maxlength`
    to specify minimum and maximum username length.'
  prefs: []
  type: TYPE_NORMAL
- en: Another addition by Angular is the ability to access the current validation
    state in the template from other separate elements. The error spans display the
    validation errors. However, they're only shown if the respective validation error
    has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the validation state, we can use the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to check if the `user` field in the `register` form has a `minlength`
    error, we can use the following attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can use a `number` input field and check if the number is within
    the specified range with the `min` and `max` attributes. The appropriate `$error`
    fields have the names `$error.min` and `$error.max` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: For the e-mail and the URL inputs, we can use the `$error.email` and `$error.url`
    fields respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, at the end of the form, in our Submit button, we use `ng-disable`
    to disable the submission of the form if there is an error in one of the fields.
    To check for errors, we can simply use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case is, it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will return `true` if any of the validation rules in any
    field generates an error.
  prefs: []
  type: TYPE_NORMAL
- en: Making a chart component with Angular directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular directives allow us to extend the HTML syntax in a very powerful way—by
    adding new attributes and elements. This allows us to create components that feel
    native: from date and time pickers to data grids, charts, and visualizations.'
  prefs: []
  type: TYPE_NORMAL
- en: Such components can then be reused without adding initialization code to our
    controllers. We simply tell the component what model it should bind to and it
    will automatically update its appearance to reflect any changes in the model.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to make a chart directive using Flot to draw our
    chart. In the process, we will learn about some of the many powerful features
    of Angular directives.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download Flot from [http://www.flotcharts.org/](http://www.flotcharts.org/)
    and extract the ZIP archive into our recipe directory, creating a sub-directory
    called `flot`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write the code.
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `index.html`. It will include all the necessary scripts
    and a view that displays a chart using our `chart` directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the controller, create a file named `controller.js`—it will set
    up the chart data and options. Additionally, it will update the chart data with
    randomly generated points every 50 milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a random data generation function, create a file named `random.js`
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write the `chart` directive in a file named `chart.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a fairly regular Angular app with a `div` element that has a controller.
    The controller sets up a new object in the scope.
  prefs: []
  type: TYPE_NORMAL
- en: The `setInterval` call in the controller deserves a special mention. We're trying
    to modify a scope object outside of the usual functions called from the browser
    event loop by Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The browser event loop is a programming construct that waits for and dispatches
    events. Such events include mouse and keyboard events, timeouts and intervals
    set up by `setTimeout` and `setInterval`, script loading, image loading or `xmlhttprequest`
    completion, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: All functions registered on the event loop by Angular are wrapped inside a scope
    application wrapper that notifies the scope that it should check itself for updates
    after execution. However, functions outside Angular, such as `setTimeout` and
    `setInterval`, don't do this wrapping, and we have to do it manually using the
    `$apply` function on the angular `$scope` object (`$scope.$apply`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `chart` directive factory is defined inside the `chart` module. The factory
    creates the directive, which is an object. Let''s explain the properties of this
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`directive.restrict`: This restricts the directive to certain types. `E` means
    that the directive is restricted to elements. Additionally, three more possibilities
    are available: `A` for attributes, `C` for CSS classes, and `M` for a special
    comment form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`directive.scope`: This allows us to configure the attributes that define the
    local (isolate) scope of our directive. We can use the following different special
    characters for different kind of imports:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `&` character means to interpret the attribute as an expression. It allows
    us to set up arbitrary one-way bindings and watch the expression for updates.
    To get the expression value, we need to call the imported scope variable as a
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `=` character means to interpret the attribute as a variable of another
    scope. This allows us to set up two-way data bindings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@` character means to interpret the attribute as a string value. The string
    value of the attribute is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`directive.link`: This is called to link the directive with a new element.
    This is done once for every instance of the directive (in our case, every element).
    It allows us to define the code executed to render the new chart, as well as to
    set up scope watches to update the chart. It''s called with the `scope`, `element`,
    and `attribute` parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, the `chart` directive is restricted to elements. Because we
    don't need two-way data bindings, using `&`, we interpret both the `data` and
    the `options` attributes as expressions. This allows the use of filters and other
    operations, which is very useful and not provided by the `=` interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `link` function, we render the initial chart. Because we interpreted
    both attributes as expressions, we need to invoke them as functions to get the
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike in Angular controllers, the order of the parameters of our `link` function
    does matter and is always: `scope`, `element`, and `attributes`. This is because
    they are not processed by the Angular dependency injection system.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up watches for expressions is also done slightly differently—the watch
    string is a function call.
  prefs: []
  type: TYPE_NORMAL
- en: Both `data` and `options` are complex objects whose content can be modified
    without changing the object itself. Because of this, we need to pass a third parameter
    to the `watch` function that specifies that object equality should be used when
    comparing the values of the watched expression. The default is to check the object
    reference, and it will not work for our chart.
  prefs: []
  type: TYPE_NORMAL
- en: When `data` or `options` are modified, we re-render our chart. Our `chart` element
    is now fully dynamic, as can be seen from the example that updates the data points
    every 50 milliseconds. Those updates immediately reflect on the chart.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the `directive.link` property, there is also `directive.compile`. It's
    only invoked once per directive, even if there are multiple instances. It allows
    us to transform a template inside our element and to include the content inside
    the directive. More properties are also available—detailed documentation can be
    found in the Angular guide on the official website at [http://angularjs.org/](http://angularjs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Structuring applications for Meteor.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first promise made by Meteor.js is that it's a faster way of building web
    applications. Most of the web frameworks that are used today have a web server
    and a database on the same rack and send rendered HTML to the browsers. They all
    use standard request and response based development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, we also have a lot of smart clients: JavaScript-powered applications
    that run in the browser or native clients in Android or iOS. All of these are
    connected with the cloud; they all are aligned with either Google, Facebook, Twitter,
    or Amazon in one way or another.'
  prefs: []
  type: TYPE_NORMAL
- en: Meteor provides a new way to have a code built around **Smart Packages**, code
    modules that can be executed on the client or server side or even both. Developers
    can pick the Smart Packages that they will use in their app. Meteor will create
    a bundle that is ready to be part of the cloud. In this recipe, we will construct
    a very basic Meteor application in order to see what is the Meteor's way of doing
    pretty much everything. One important thing to note about Meteor is that it is
    still work in progress, and should be treated as such.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, the officially-supported platforms are Mac OS and GNU/Linux.
    There is a preview installation for Windows available as an MSI installer package
    at [http://win.meteor.com/](http://win.meteor.com/) where it should have the same
    functionality, but with a few more bugs and an uncomfortable shell. Official support
    for Windows is planned in the future, so that should not be a big problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux and Mac, installation is done using command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This command will run and install Meteor to your machine, but it only works
    for Debian-and RedHat-based distribution. If your OS is not in one of these categories,
    there is no need for worries, there is probably a package for Meteor that would
    be already part of your distribution repository, but it might be a few versions
    behind.
  prefs: []
  type: TYPE_NORMAL
- en: Meteor is built on top of Node.js and uses it's own system for managing packages.
    By default, it also uses MongoDB as a database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After having Meteor installed, we can start by creating an application titled
    `simple`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will create a folder called `simple`, and in it we should have files called
    `simple.html`, `simple.js`, `simple.css`, and a sub folder called `.meteor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the application, just type `meteor` in the folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before digging into the code, we will take a look at some of the ideas behind
    Meteor. The creators promote the framework with their seven principles that mostly
    live up to your expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: Seven Principles of Meteor
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Data on the Wire. Don't send HTML over the network. Send data and let the client
    decide how to render it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: One Language. Write both the client and the server parts of your interface in
    JavaScript.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Database Everywhere. Use the same transparent API to access your database from
    the client or the server.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Latency Compensation. On the client, use prefetching and model simulation to
    make it look like you have a zero-latency connection to the database.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Full Stack Reactivity. Make realtime the default. All layers, from database
    to template, should make an event-driven interface available.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Embrace the Ecosystem. Meteor is open source and integrates, rather than replaces,
    existing open source tools and frameworks.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity Equals Productivity. The best way to make something seem simple is
    to have it actually be simple. Accomplish this through clean, classically beautiful
    APIs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some of these principles are overblown but nonetheless, Meteor is certainly
    a new way of building web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get back to the generated code and start with `simple.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The variables `Meteor.isServer` and `Meteor.isClient` are provided so that we
    can change the behavior depending on whether the code is running on the client
    or the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add `console.log("I''m running")` in the `server` section of `simple.js`,
    we can notice the server console reloading the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is basically how we create server code in Meteor, where we can choose if
    we would like to have a singe file or a whole bunch of other files. Meteor collects
    all the files we have in our project tree, with the exception for the `server`
    and `public` subdirectories. It minifies them, and they get served to each client.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Node.js' way of creating an asynchronous callback, Meteor uses a single
    thread per request, meaning that it should lead to somewhat more maintainable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at `simple.html`, we have a simple template that uses the
    client code that is part of `simple.js`, where the appropriate `Template.hello.events`
    event and the data in `Template.hello.greeting` are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We won't get into the details behind templates just yet, but this basic example
    should be straightforward. If we open up the browser on an already-started application
    on `http://localhost:3000`, we can see that the data got loaded into the template.
    When we click on the button, a `console.log("You pressed the button")` function
    is called, and the message should be displayed in the console. Note that this
    should be the console of the browser, not the server console, as that part is
    set to run on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: The part of the code that deals with sensitive data, such as tokens or passwords
    should be only part of the server, and this can be done easily by placing that
    code in a folder named `server`. When the server is in the production mode, CSS
    files and JavaScript are served to the client, packed and bundled. While development,
    they are sent individually to make debugging simpler.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the HTML file that got served to the client is a bit
    different and larger than the one we have in our application folder. This is because
    Meteor scans the HTML files for top-level elements `<head>`, `<body>`, and `<template>`.
    The `template` sections are converted into JavaScript functions that can be called
    from the `Template.*` namespace. As for the `<head>` and `<body>` elements, they
    get joined together separately, and the additional parts, such as the DOCTYPE
    and CSS, are included for us automatically.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we need Meteor to serve some static files such as `icons`, `images`, `pdf's`,
    or, for example, `robots.txt`, we use the `public` directory for that purpose.
    The root of the application is the root of the `public` folder; for example, if
    we have a file called `meme.png`, it will be accessible via `http://localhost:3000/meme.png`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Reactive programming and data in Meteor.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Meteor uses NoSQL document-oriented storage and it comes by default with Mongo
    DB. The name comes form the word "humongous", meaning extremely large. The database
    is part of a NoSQL database family, meaning, it does not store the data as traditional
    relational databases. Mongo DB persists the date in a JSON-like document format,
    making the integration with JavaScript-based frameworks a lot easier. In this
    recipe, we are going to see how to use the database from Meteor, and how data
    access is orchestrated.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an `icon.png` image in the example files; besides that, only Meteor
    is needed to be installed on your machine and to have an open command line.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we can start by creating the application named `movies` from the command
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify the generated structure, we will create two folders: one called
    `server` and another called `client`. The `movies.css`, `movies.js`, and `movies.html`
    files can be placed in the `client` directory, as we will putting client-related
    code there.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `server` directory, we create a file called `bootstrap.js` that will
    initialize the database with the few objects that we will define:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you might be wondering is, what is this `Movies` object? It
    is a collection that we will define in a different file that can be called `publish.js`,
    as in it we are going to publish the collection from the server. This file will
    include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the client side, we have the generated files, so we start creating a
    simple HTML and a handlebar template to go with it. Inside the template, we will
    just iterate over Movies and print out a list of elements with the movie name
    and score. Additionally, in the template, we place button that will contain reference
    to an image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In order to make the `icon.png` image available as a static file, we need to
    create a folder named `public` and place the image there. This follows the principle
    of *convention over configuration*, and there is no real need why you should not
    follow it, at least most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the client side, in the previously generated `movies.js` file, we should
    automatically subscribe to the `servers` collection of movies. Also, we will add
    a functionality to fill the `movies` variable and add an event also for the button
    that will trigger a save of a random new movie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now everything should be working. After starting the application with `meteor`,
    we can access it in the browser on the default port `http://localhost:3000/`.
    If we want to change the port on which the application runs, for example on port
    `3333`, we can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can first start with the data, if we have the server running, we can open
    up another console, where we can access the same directory. Then, after opening
    the same folder in the console, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'That opens up a simple console on which we can query our database. Mongo stores
    the data as collections, and in order to get the names of all of our available
    movies, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `movies` collection is the one we defined in our `bootstrap.js` initialization;
    as for `system.indexes`, it is a collection contains all the indexes of the database.
    To manipulate data with this collection, we can use `ensureIndex()` and `dropIndex()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the console, we can assign the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Collections can be queried with `find()`; if we try to call it without arguments,
    it returns all the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The data is basic JSON, making it easy to manipulate with JavaScript. If you
    take a look at the objects, you can notice the `"_id" : "08633d22-aa0b-454f-a6d8-aa2aaad2fbb1"`
    key-value pair. This is a unique key generated by Mongo and we use it to reference
    and manipulate that object, commonly referred to as **document**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to delete the record with an ID of `beef20a3-c66d-474b-af32-aa3e6503f0de`,
    we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can call `db.movies.find()` to see to notice that one is now
    missing. There are plenty of other commands used for data manipulation, but most
    of them are intuitive, and you can easily guess by their names. As a quick reminder
    and a learning tool, there is a `help` function that can be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: These two bring up a list of commands and a short explanation of what each does.
    You should not get overwhelmed by the number of commands, as we will not use most
    of them, but it still makes a good reference.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more detailed tutorial on MongoDB commands, visit [http://mongodb.org](http://mongodb.org)
    and click on **TRY IT OUT** to try the online shell. There are tones of resources
    for NoSQL on the Web, but one great introduction done by *Martin Flower* is available
    at [http://www.youtube.com/watch?v=qI_g07C_Q5I](http://www.youtube.com/watch?v=qI_g07C_Q5I).
  prefs: []
  type: TYPE_NORMAL
- en: If we open a browser, we may notice that on every click on the Random button,
    a new record is added instantly. This looks extremely fast and it is not just
    because the server is running locally. Every time a client issues a write to the
    server, it instantly updates the local cache without response from the server
    if the write went successful. When the server receives the request and accepts
    the update, then the client does not have to do anything on the screen. This should
    happen most of the time and it saves the round trip waiting time, making the screen
    more responsive. On the other hand, if the server rejects the update, the client's
    cache gets updated with the correct result.
  prefs: []
  type: TYPE_NORMAL
- en: In Meteor, the same API is used for the client and the server in order to access
    the database. Emphasis is given to reducing the time for round trips to the server
    for every design decision in the framework. Requests and responses, as well as
    message invalidation, are orchestrated to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used `autorun` to automatically get updates from the server in our `movies.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The block of code in the `autorun` function is a so-called **reactive context**,
    enabling us to write code in an imperative style, but get a reactive behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactive programming** is one of the programming paradigms that are oriented
    around propagation of change. In imperative programming, if we have an expression
    such as `z = x + y`, this means that the result of the evaluation of `x + y` will
    be assigned to `z` as expected. For example, if we have `x = 42` and `y = 13`,
    then `z = 42 + 13` or `z = 55`. The values of `x` and `y` can be changed later,
    for example, they can be changed to `x=4` and `y=4`, but this will not affect
    `z` in any way, it will still be `55`.'
  prefs: []
  type: TYPE_NORMAL
- en: The simplest example for this is a modern spreadsheet program, such as Microsoft
    Excel or Google docs spreadsheet. Spreadsheet cells commonly contain literal values
    such as number for example, or can contain formulas that have derived values from
    some other cells. In our cell `C3` we could have the formula `"=A1+B1"` meaning
    when we change some of the values in `A1` or `B1`, `C3` will get autoupdated.
  prefs: []
  type: TYPE_NORMAL
- en: In MVC architecture, a simplification can be made using reactive programming,
    where we automatically propagate the changes from the view towards the model and
    back that can be very beneficial in real-time systems.
  prefs: []
  type: TYPE_NORMAL
- en: The use of reactive contexts saves us from writing a whole class of calls. In
    our example, we would first need to unsubscribe when something has changed and
    then again resubscribe to get the data back from the server. This reduces a substantial
    amount of code that could end up being error-prone and add more complexity in
    the maintenance phase.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides `Meteor.autorun`, reactive context is applied in `Templates` and in
    the `Meteor.render` and `Meteor.renderList` functions.
  prefs: []
  type: TYPE_NORMAL
- en: As for the data sources that can trigger changes, we can use database `collections`
    and `session` variables, and a few other functions related to authentication and
    authorization. You can find more details about it in the documentation of Meteor
    about reactivity at [http://docs.meteor.com/#reactivity](http://docs.meteor.com/#reactivity).
  prefs: []
  type: TYPE_NORMAL
- en: If you open up two different browsers side by side, you may notice that the
    same data is shown even if the sessions are different. In order to have user-specific
    data, we will create an example in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: You might wish to send the entire collection to the client, but first think
    thoroughly if that is what the client actually needs. Often, it might be a lot
    wiser to send only certain fields rather than entire documents. In order to lower
    the network traffic, certain parts of the client can have subscription turned
    off and the documents for those parts will be removed from the local cache unless
    used in other active subscription.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because the data we used is stored in the database, if we changed the data there
    using some external application, it will also trigger changes to the client. In
    the next recipe, we will see how we can allow multiple users to have their own
    favorite list for each of them instead of a single global list.
  prefs: []
  type: TYPE_NORMAL
- en: Live HTML and user-specific data in Meteor.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed in the previous recipe that the data we used was global
    and not user-specific. In this recipe, we will see how we can create session data
    and take a deeper look into the templates as well as the data associated with
    them. In order to demonstrate this, we will create a small image-voting application,
    where the user will be prompted for the name, and after that they are given 50
    points that they can spend for votes on the images.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the recipe simpler, we will serve the images statically from our `public`
    directory so you can download the sample images that are part of the example code
    or use your own ones.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start as any other normal Meteor application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we will use a little bit more code in this recipe, it makes sense to
    create a structure with a `public` folder for the static files, and the `server`
    and `client` folders for the server and client code respectively. After that,
    we can move the generated gallery files to the `client` folder and add the images
    to the `public` folder. The images, for simplicity, will be named `1.jpg`, `2.jpg`,
    `3.jpg`, and guess what, `4.jpg`. Then we proceed with creating a `bootstrap.js`
    file in the `server` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will initialize the database with a simple user and add some data about
    the images, as well as add a condition that this should happen only when there
    are less than four images in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may notice that we are using a `for` loop to insert the data, but since
    Version 2.2 of MongoDB, the `db.collection.insert()` function can accept an array
    of elements and do a bulk insert of them into the collection, but we are not using
    the method like that, as it will result in a slightly more complex structure,
    and we want to go with the simplest case. You can read more about the `db.collecton.insert()`
    on [http://docs.mongodb.org/manual/reference/method/db.collection.insert/](http://docs.mongodb.org/manual/reference/method/db.collection.insert/).
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we can proceed with the definition and the publishing of the collections,
    making the collections available to the client side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can continue with the template code in `gallery.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` template will check whether there is a user currently present. If
    present, it will display the voting, otherwise, it will display a simple form
    to enter a name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `votes` template will show how many votes are there left for the user,
    and the gallery will display the images together with the info about current number
    of votes, as well as add a button that will be used for voting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We can start up the application and see if everything turned up as expected.
    If you open up the application on two browser sessions side by side, and enter
    two different names, you can notice that when we vote on the images, the number
    of votes gets updated instantly on the other browser session.![How to do it...](img/9282OT_10_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing you might want to see is what is the state in the database.
    While having the server up, you can start the `meteor mongo` console and list
    the collections with `db.getCollectionNames()`, where you should have the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The collection names are the ones we defined in our `publish.js` file. As for
    the data contained in the database, we decided on having URL to the images in
    the `public` folder for the image collection, because that is simpler for this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need to store or manipulate binary data such as images, you can do that
    in MongoDB, and it plays very well with Meteor. There we can use EJSON, where
    the E stands for extended. Basically, it supports all JSON types while adding
    additional Data via the JavaScript `Date()` object and Binary data via `Uint8Array`.
    You can also define your own custom datatypes and use the EJSON object similarly
    to the regulator JSON. There are a few other methods such as `EJSON.newBinary(size)`
    and `EJSON.addType(name,factory)`, and you can read more about them on [http://docs.meteor.com/#ejson](http://docs.meteor.com/#ejson).
    There is also the option to configure your own already existing MongoDB instance.
    This is done by defining an environment variable before starting meteor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This makes it convenient to have a same MongoDB server that is used by non-Meteor
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the `gallery.js` file, in order to have some data in the client side, we
    used `Session` variables. This is actuality a global object that can be used on
    the client side to store any key-value pairs. Just like you are used to in other
    frameworks and languages, we have `Session.set("theKey", someValue)` that stores
    `someValue` for `theKey` and `Session.get("theKey")` is used to retrieve the data.
    As for initialization, there is the `Session.setDefault("theKey", initalValue)`,
    making it handy to avoid reinitialization of the variable every time a new version
    of your application is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about the Session object in the Meteor specification at [http://docs.meteor.com/#session](http://docs.meteor.com/#session).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have probably noticed so far, we can nest templates. This is a standard
    handlebar behavior, and in our case, we use it to simplify the view logic. In
    the real-life scenario, it not only makes more sense to separate only the parts
    that can be reused in some other sections of the application, but also at the
    same time, you don''t want to have huge templates that make your code hard to
    read. In order to have events, we can use standard CSS selectors to add them to
    our template, so if we want to attach a callback on the `click` event of an element
    using the `.name` CSS class in the `main` template, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the event callback, we can access several objects that are of use to us.
    We used some of them in `Template.gallery.events`, where `onclick` callback accepts
    two arguments; we can see that in this object, and we have access to the related
    document. Having the data context of where the element was triggered allows easy
    manipulation of that section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The two arguments that are passed in the callback allow access to the event
    type as well as the `DOMElement` of the current target.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More about how event maps and selectors are used as well as what else is accessible
    in the event callback can be found at [http://docs.meteor.com/#eventmaps](http://docs.meteor.com/#eventmaps).
    You can also attach callbacks that would be called after the template is rendered,
    [http://docs.meteor.com/#template_rendered](http://docs.meteor.com/#template_rendered).
    There is also an option to use other template engines instead of handlebars, such
    as Jade, for example, [http://docs.meteor.com/#templates](http://docs.meteor.com/#templates).
    This can be done as the reactive context for the templates is not dependent on
    the engine; you can even construct the HTML manually by appending string and it
    will still work.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` template besides `Users.insert`, we used the `db.collection.findOne`
    function that returns the first object that is found. This is done by matching
    the query that we specify with the database and retrieving the first result in
    natural order if found.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More detailed explanation of `findOne` is available in the MongoDB documentation
    at [http://docs.mongodb.org/manual/reference/method/db.collection.findOne/](http://docs.mongodb.org/manual/reference/method/db.collection.findOne/).
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the update of the elements, the collection accepts two arguments, first
    being the selection query where, for example in `voteForImage`, we used the MongoDB-generated
    `_id` for matching the element, and the second is the new update using the `$set`
    modifier to update the `pointsLeft` property of the selected documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several different update modifiers that can be used, and you can read
    about them in great detail in the documentation, but to get you up to speed with
    the basics,, you can use some of the reference cards provided by 10gen, the company
    behind MongoDB. More details can be found at [http://www.10gen.com/reference](http://www.10gen.com/reference).
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we could have used the `$inc` modifier that increments the value
    we want for a given amount, but for simplicity, we picked the more general `$set`
    modifier. Also, one other additional improvement that can be done is to move the
    collection declarations, such as `Images = new Meteor.Collection('images')`, into
    a common file for the server and the client that is not in the respective folders
    so that we can reduce the code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At some point of time, you may want to have some kind of timer based on the
    standard JavaScript `setTimeout` or `setInterval` functions. You will get an error
    if you try to do so, but the same functionality is provided by `Meteor.setTimeout`
    and `Meteor.setInterval` functions ([http://docs.meteor.com/#timers](http://docs.meteor.com/#timers)).
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the view, you may have seen so far that it is entirely handled
    with JavaScript. This is one of the problems with Meteor, because the content
    generated like this is hard to get indexed by search engines such as Google. In
    order to help you out with this problem, there is a package called **spiderable**
    ([http://docs.meteor.com/#spiderable](http://docs.meteor.com/#spiderable)) that
    can be used as a temporary fix.
  prefs: []
  type: TYPE_NORMAL
- en: Security mechanisms in Meteor.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There has been a lot of controversy around the security in Meteor. Database
    everywhere does not scream security. We are using the same API for the client-
    and server-side code, and it does not take a genius to tell that we can also delete
    collections. After playing around for a while with the JavaScript console, we
    could easily delete all the `Users` in our previous example. You can always roll
    your own implementation for the security; for example, you can override the default
    server method handlers, making the `Users` and `Images` collections accessible
    from the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we will take a look at what is the Meteor's way of securing
    the applications, and some of the mechanisms for authentication and authorization.
    To do this, we will create a simple list-entering application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are no special preparations required for this recipe; you only need command
    line and an installed version of Meteor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an application named `secure` using `meteor create secure`. In the generated
    `secure.html` file, we will define a small template that will contain an input
    element, a button, and a list of already available list entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The accompanied code in `secure.js` will initialize one element of the list
    and add the date for the rendering of the templates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the application and play around with it to check if it is working. If
    you open up the browser''s console at this point, we can directly access `Notes.remove()`,
    and this is one of the things that we usually want to forbid. We can remove one
    of the default smart packages that is part of the generated application with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The same thing can be achieved by manually editing `.meteor/packages`. This
    will make our application "secure", even too much secure, if there is such a thing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now if we try to toy with the browser''s console, we''ll get the following
    message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The same message appears if we just click on the **Add** button that previously
    worked. This is because all the requests to the DB are now treated as anonymous,
    and we only get what is published from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can always roll our own authentication, but there is a great one built in;
    to add it in our project, we can use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As previously mentioned, we can add these packages directly in our `packages`
    file; it is a good idea to check often what you have there in the example applications
    you try out so that you won't be surprised.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A variety of packages and third-party libraries extend the core Meteor functionality.
    There are packages for D3, underscore, backbone, and plenty more added each day.
    Those and some basic supporting logic can be found at [http://docs.meteor.com/#packages](http://docs.meteor.com/#packages).
    There is also a way to create your own extension and common logic for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The packages we included are a set of helpers that make the authentication
    user management logic automatic. Accounts-UI even enable us to have great user
    interface to log in with negligible effort. So what efforts do we need to make
    to enable it? First, we''ll add a small block of code in the place where we what
    the login UI to appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Also we need to configure the type of login we want, so in our case, we use
    a simple username and password type, where optionally an e-mail can be entered.
    We add this config in the `secure.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: One other thing you might want to add is a simple CSS style to position the
    login box:![How to do it...](img/9282OT_10_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a simple signup and login to the account, we should notice a user link
    with our username. We could use this in order to sign out. As you can notice,
    this was as effortless as it gets.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of other configuration options for the Accounts-UI, as well
    as extensions for connecting with Twitter, Facebook, Google, and GitHub accounts.
    More information can be found on [http://docs.meteor.com/#accounts_ui_config](http://docs.meteor.com/#accounts_ui_config),
    and the package documentation can be found at [http://docs.meteor.com/#accountsui](http://docs.meteor.com/#accountsui).
    Also, you can use features such as sending a verification e-mail or confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After login, if we try to add text using our button, we will notice that we
    still don''t have access, as our user is not authorized to do inserts. To allow
    inserts for specific users, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this insert callback, we can allow or deny access to the user with `userId`
    for the given document. For our case, the document is the `Notes` object that
    we are trying to insert and the `userId` is the ID of the currently logged user.
    Besides `collection.allow`, there is also its counterpart `collection.deny` that
    we can use to forbid access for certain methods even if there is an `allow` rule.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is very easy to create an advanced authorization system where we specify
    access rights programmatically. There are programmers who argue that this causes
    a lot of overhead, and it might be the case for certain applications, but for
    most of them, it should be very simple to set up access rights like this.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we should never, ever trust data that is coming from the client.
    Access should only be given to the parts that they must use and the input should
    be filtered. Having credit card data sent to the client is an easy way to destroy
    your business. Just because Meteor does so many things for us, that does not mean
    that we should forget about other common practices, such as data validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be wondering where the user data, which we used for signup, is stored.
    If we access the Mongo console with `meteor mongo`, there is a `users` collection
    that should contain something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As you can notice, it's more or less a standard data of what you might expect
    to be stored in the database. The passwords are stored hashed with salting to
    prevent some common attacks.
  prefs: []
  type: TYPE_NORMAL
- en: And that is it; we have a very simple yet secure application. The data of the
    list is of course not user-specific but that could be easily extended by adding
    an owner field of each of the created documents.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing you should accept is that Meteor is still not completely finished.
    There are a lot of changes being done with every version until it gets fully stable.
    Most of the stuff that the users requested is being added, as well as other significant
    architecture improvements are being implemented, so you need to update parts of
    the code with every version.
  prefs: []
  type: TYPE_NORMAL
- en: One great resource for information are the example apps; you can list them by
    calling example apps using the `meteor create –list` command; as for getting the
    code again, you can use `meteor create -example nameofexample`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes down to deployment, we can freely use the server that is provided
    as our own, but there is an option to have it deployed on [www.meteor.com](http://www.meteor.com).
    This is a service provided by a startup company behind this fun framework. The
    deployment there is just one command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: More information about the cloud solution can be found at [http://docs.meteor.com/#meteordeploy](http://docs.meteor.com/#meteordeploy).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also the option to generate a fully contained Node.jsapplication from
    our Meteor app and use some other cloud service. This can be done using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the running of the unpacked file use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This is possible as Meteor, behind the scenes, is a Node.js framework with different
    kind of packaging.
  prefs: []
  type: TYPE_NORMAL
