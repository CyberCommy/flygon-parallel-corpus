- en: Cloud-Native Application Runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having developed, tested, and deployed the applications using a deployment
    pipeline such as Jenkins, in this chapter, we will look at the runtime ecosystems
    in which our applications or services run. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The need for a comprehensive runtime, including a recap of the problems in operating
    and managing a large number of services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing the reference runtime architecture, including:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Config server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service frontends, API gateway, reverse proxy, and load balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A look at Zuul as a reverse proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container management and orchestration through Kubernetes and Minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running on **Platform as a Service** (**PaaS**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the PaaS platforms help realize service runtime reference architecture that
    we discussed in previous chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Cloud Foundry and running our `product` service on the Cloud Foundry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for a runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have developed our services, written tests for them, automated the continuous
    integration, and are running them in the container. What else do we need?
  prefs: []
  type: TYPE_NORMAL
- en: 'Running many services at scale in production is not easy. As more services
    are released in production, their management starts getting complex. Hence, here
    is a recap of the problems, discussed in the microservices ecosystem and solved
    in some code samples in a previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service running in the cloud: **A traditional large application was hosted
    on an application server and ran at an IP address and port. On the other hand,
    microservices run in multiple containers at various IP addresses and ports so
    the tracking production service can get complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services come up and go down like moles in a Whack-a-Mole game: **There are
    100s of services with their loads balanced and failover instances running all
    over the cloud space. Many teams, thanks to DevOps and agility, are deploying
    new services and taking down old services. Thus, as we can see, a microservice-driven
    cloud environment is very dynamic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two issues are addressed by the service registry tracking the services.
    So, the clients can look up where the services corresponding to a name are running
    using a client-side load balancing pattern. However, if we want to abstract the
    clients from the look up, then we use the pattern of server-side load balancing,
    where a load balancer, such as Nginx, an API gateway like Apigee, or reverse proxy
    or router, such as Zuul, abstracts the clients from the actual address of the
    services.
  prefs: []
  type: TYPE_NORMAL
- en: '**Managing my configuration across microservices: **If the deployment unit
    has broken into multiple services, so has the property file containing the packaged
    configuration items such as connection addresses, user ID, logging levels, and
    so on. So, if I have to change a logging level for a set of services or a flow,
    do I have to change it across all the application''s property files? Here, we
    will see how centralizing the property files in a config server like Spring Config
    Server or Consul helps to manage the properties in a hierarchical fashion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**So many log files to handle: **Each microservice is generating one (or more)
    log files like `.out` and `.err` and Log4j files. How do we search for log messages
    across multiple log files from multiple services?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pattern to solve this is log aggregation, implemented with commercial tools
    such as Splunk or open source tools like Logstash or Galaxia. They are also present
    by default in PaaS offerings like Pivotal Cloud Foundry.
  prefs: []
  type: TYPE_NORMAL
- en: The other option is to stream logs to the aggregators such as Kafka from where
    they can be centrally stored.
  prefs: []
  type: TYPE_NORMAL
- en: '**Metrics from each service**:In [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*, we added Spring actuator metrics,
    which are exposed as endpoints. There are many other metrics, such as Dropwizard
    metrics, that can be captured and exposed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either an agent has to monitor all services actuator metrics, or they can be
    exported and then aggregated in a monitoring and reporting tool.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is for application monitoring tools like Dynatrace, AppDynamics
    to monitor application, and extract metrics at Java level. We will take a look
    at these in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing runtime reference architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problems discussed in the previous section are addressed by the following
    reference runtime architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49927155-cba6-4fad-a513-b546c7d4fffb.png)'
  prefs: []
  type: TYPE_IMG
- en: All these components were already discussed in [Chapter 1](ba2b049f-679d-493c-9861-b655f91065bc.xhtml), *Introduction
    to Cloud-Native*. Now, we proceed to choose technologies and show an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Service registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running the service registry Eureka was discussed in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*. Please refer to that chapter to
    refresh your memory on how a `product` service registers itself with Eureka and
    how the client uses Ribbon and Eureka to find the `product` service.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of service registry is slightly diminished if we are using Docker
    Orchestration, such as Kubernetes. In this case, Kubernetes itself manages the
    registration of a service, which a proxy looks up and redirects to.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The config server stores configurations in a hierarchical manner. This way,
    the application only needs to know the address of the config server and then connect
    to it to get the remaining configurations.
  prefs: []
  type: TYPE_NORMAL
- en: There are two popular config servers. One is Hashicorp's Consul and the other
    is Spring Config Server. We will use Spring Config Server to keep the stack consistent
    to Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go over the steps to start using a config server. There are two parts
    to using externalized configuration: the server (serving the properties) and the
    client.'
  prefs: []
  type: TYPE_NORMAL
- en: The server part of the config server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many options to serve the properties over an HTTP connection,  Consul
    and Zookeeper being popular ones. However, for Spring projects, Spring Cloud provides
    a flexible config server that can connect to multiple backends, including Git,
    databases, and filesystems. Given that the properties are best stored in a version
    control, we will use the Git backend for Spring Cloud Config for this example.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Cloud Config server code, configuration, and runtime is very similar
    to Eureka and it is easy to fire up an instance like we did for Eureka in [Chapter
    2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml), *Writing Your First Cloud-Native
    Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to get a service registry running:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Maven project with the artifact ID set to `config-server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the POM file and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. The parent as `spring-boot-starter-parent`
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The dependency as `spring-cloud-config-server`
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The dependency management as `spring-cloud-config`
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3b5ae42-0431-4516-97ee-0e3b8c44f1a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create an `ConfigServiceApplication` class that will have annotation to start
    the config server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a37f8d13-eb00-4a4f-aa5f-b9a7f9c47c46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create an `application.yml` file in the `config-server/src/main/resources`
    folder of the application and put the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The port number is where the config server will listen for configuration requests
    over an HTTP connection.
  prefs: []
  type: TYPE_NORMAL
- en: The other property of `spring.cloud.config.server.git.uri` is the location of
    Git, which we have configured a local folder for development. This is where Git
    should be running on the local machine. If not, run a `git init` command on this
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: We are not covering Git authentication or encryption here. Please check the
    Spring Cloud Config manual ([https://spring.io/guides/gs/centralized-configuration/](https://spring.io/guides/gs/centralized-configuration/))
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `product.properties` file, we will hold the properties that were initially
    held in the `application.properties` file of the actual `product` project. These
    properties will be loaded by the config server. We will start with a small property,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This property file should be present in the Git folder we just referenced in
    the previous step. Please add the property file to the Git folder, using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `bootstrap.yml` file in the `resources` folder of application and
    input the name of this project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Build the Maven project and then run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see a Tomcat started message, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a4aa6729-ccc4-4b69-9a14-a99dbe98bef7.png)`ConfigurationServiceApplication`
    has started and is listening on port `8888`'
  prefs: []
  type: TYPE_NORMAL
- en: Let's check if the property we added is available for consumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fire up a browser and check for `product.properties`. There are two ways you
    can do this. The first is by viewing the property file as JSON and the second
    is by viewing it as a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8888/product/default`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a2e7f686-89d5-4e86-8cf4-b7daf8ae13c0.png)'
  prefs: []
  type: TYPE_IMG
- en: '`http://localhost:8888/product-default.properties`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/23b88c7c-b0fe-44a4-8ca1-62516d6ec7c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In case you are wondering, the default is the profile name. Spring Boot applications
    support profile overrides, for example, for test and **user acceptance testing**
    (**UAT**) environments, where the production properties can be replaced with the
    `product-test.properties` file. Hence, the config server supports the following
    form of URL reads: `http://configsvrURL/{application}/{profile}` or `http://configsvrURL/{application-profile}.properties`
    or `.yml`.'
  prefs: []
  type: TYPE_NORMAL
- en: In production, it is highly unlikely that we will access the config server directly,
    as shown previously. It will be the clients who will access the config server;
    we shall see this next.
  prefs: []
  type: TYPE_NORMAL
- en: The config client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the `product` service code developed earlier as a baseline to start
    extracting the properties out of the application into the config server.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `product` service project from eclipse to create a new project for
    this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `spring-cloud-starter-config` dependency to the list of the dependencies
    in the POM file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2dd748c2-9e31-4aba-b8c0-67ffad5887eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Our main work will be on the resources. Tell the `product` service to use the
    config server running at: `http://localhost:8888`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `failFast` flag indicates that we do not want the application loading to
    continue if we don''t find the config server. This is important, as it will ensure
    that the `product` service should not assume defaults if it does not find the
    config server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Shift all properties in the `application.properties` section of the resources
    folder of the `product` service to the `product.properties` that we had defined
    as part of the `git` folder loaded by the config server in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your `product.properties` file will now have useful configuration, in addition
    to the `Hi There` message that we had put in for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can now delete the `application.properties` file that is present in the `resources`
    folder of the `product` service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add a test method to our `product` service to check the property being
    set from the config server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Fire up the Eureka server, as done in the previous chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the config server from the previous section is still running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, start the `product` service from the `ProductSpringApp` main class. Right
    at the beginning of the logs, you will see the following statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/90a0ed0d-cd2a-4bfe-a79c-5ba82e82a130.png)'
  prefs: []
  type: TYPE_IMG
- en: When the ProductSpringApp starts, it first goes and gets the configuration from
    the external configuration service running on port 8888
  prefs: []
  type: TYPE_NORMAL
- en: The environment with `name=product` is picked as our application name in the `bootstrap.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The port number at which `product` service should listen is picked up from
    this config server, along with the other properties, such as the test message
    which we will see now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d347e80-79b2-445a-99d5-7c95034216f5.png)`ProductSpringApp` starts
    on port `8082` picked up from the externalized configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the application with two URLs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8082/testMessage`: This returns `Hi There`, which was our
    configured message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run one of the other REST services, such as product view. You will see the required
    product information to indicate our services are working fine.
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8082/product/1`: This will return `{"id":1,"name":"Apples","catId":1}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refreshing the properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, what if there is a change in the properties that you want to reflect centrally
    on all the services?
  prefs: []
  type: TYPE_NORMAL
- en: You can change the message in the `product.properties` file to a new message,
    such as `Hi Spring`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will notice that the config server picks up this change on the next read,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9879ad35-2cef-452e-b850-506ab2f3d11c.png)'
  prefs: []
  type: TYPE_IMG
- en: However, this property is not picked up by the service immediately, as calling
    `http://localhost:8082/testMessage` results in the older `Hi There` message. How
    do we refresh the properties on the command line?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the actuator command `/refresh` comes in handy. We configure
    the beans to be part of  the `@RefreshScope` annotation. These beans will get
    reloaded when the `POST` method call to `http://localhost:8082/refresh` is executed
    from the Postman application. See the following log to check what calling refresh
    results in reloading of properties looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b15ea384-b8cd-4120-8087-a6660da3fc11.png)'
  prefs: []
  type: TYPE_IMG
- en: The first line shows in the logs how `product` service refreshes its properties
    on executing `http://localhost:8082/refresh`
  prefs: []
  type: TYPE_NORMAL
- en: You can check how, after the marked line, the property loading started again
    and the message after calling `http://localhost:8082/testMessage` gets reflected.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a popular pattern to frontend a microservice with a reverse proxy, a load
    balancer, an edge gateway or an API gateway, in an increasing order of complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reverse proxy**: A reverse proxy is defined as a process that makes the downstream
    resource available as though it originated from itself. In that respect, the webserver
    frontend and the application server also act as reverse proxies. The reverse proxy
    is useful in cloud-native applications, as it ensures that the clients do not
    need to look up services and then access them like we did in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*. They have to access the reverse
    proxy, which looks up the microservices, calls them, and makes the response available
    to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancer**: The load balancer is an extended form of reverse proxy that
    can balance the request it receives from clients across multiple services. This
    increases the availability of the services. The load balancer can work with service
    registry to find out which are the active services and then balance the requests
    between them. Nginx and HAProxy are good examples of load balancers that can be
    used to frontend microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge gateway**: As the name implies, the edge gateway is a higher-order component
    that is deployed on the edge of the enterprise or division and has more capabilities
    than a load balancer, such as authentication, authorization, traffic control,
    and routing functions. Netfix Zuul is a good example of this pattern. We will
    cover code examples of using Zuul in this section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API gateway**: With the popularity of Mobile and APIs, this component provides
    more complex capabilities, such as fanning out requests to multiple services doing
    orchestration between them, intercepting and enhancing the requests or responses
    or converting their formats, doing sophisticated analysis on the requests. It
    is also possible to use both an API gateway and a load balancer, reverse proxy,
    or edge in a single flow. This approach helps with the segregation of responsibilities,
    but also adds latency due to an additional hop. We will see API gateway in later
    chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netflix Zuul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netflix Zuul is a popular Edge gateway popularized by Netflix and then offered
    as part of Spring Cloud. Zuul means gatekeeper and performs all those functions,
    including authentication, traffic control, and most importantly, routing, as discussed
    earlier. It is well-integrated with Eureka and Hystrix in looking up services
    and reporting metrics. The services in an enterprise or a domain can be frontended
    by Zuul.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put a Zuul gateway in front of our `product` service:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Maven project and set its artifact ID as `zuul-server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the POM file and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. Set the parent as `spring-boot-starter-parent`
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Set the dependency on `spring-cloud-starter-zuul`, `-eureka`, and `-web`
    projects
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Set dependency management on `spring-cloud-starter-netflix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/874b6f33-752e-4d1f-a421-1e97b627db71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create an application class with an annotation to enable Zuul Proxy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/19a8af5c-bdd0-4f89-8ab1-9fdc1b91353b.png)'
  prefs: []
  type: TYPE_IMG
- en: The configuration information in `application.yml` is very critical for Zuul.
    This is where we configure the routing capabilities of Zuul to redirect it to
    the correct microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Zuul interacts well with Eureka, we will leverage that to our advantage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This tells Zuul to look for services in the Eureka registry running at that
    port.
  prefs: []
  type: TYPE_NORMAL
- en: Configure the port to listen at `8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, configure the routes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These are the mappings of the URL in the REST request to the respective service
    that can handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What happens behind the scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at what happens behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `product` section in the route definition tells Zuul that the paths configured
    after `/product*/**` are to be redirected to the `product` service, if it is present
    in the Eureka registry configured in the Zuul server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The path is configured to be `/product*/**`. Why three `*` ? If you remember,
    our `product` service can handle two types of REST services: `/product/1 GET`
    and `/product PUT`, `DELETE`, `POST` requests. The `/products?id=1 GET` requests
    that it return a list of products for the given category ID. Hence, the `product*`
    maps to both `/product` and `/products` in the URL.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `false` setting of `stripPrefix` lets the `/product/` pass on to the `product`
    service. If the flag is not set, then only the rest of the URL after `/product*/`
    will be passed on to the microservice. Our `product` microservice has mapping
    including the `/product`, hence we want the prefix to be preserved when forwarding
    to the `product` service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running them all at once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now try to run our `product` service, along with the rest of the ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the services in the reverse order of dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the config server and the Eureka server by running the main class of the
    projects or through Maven.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the `product` service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the Zuul service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Watch the log windows and wait till all servers start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following requests in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/product/3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/products?id=1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should see product `3` listed in the first request and the products corresponding
    to category `1` in the second request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the logs of Zuul and `product` service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Zuul, you can see that the mapping of the `/product*/**` was resolved and
    the endpoint to the `product` service was fetched from the Eureka registry:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/24bb51b3-7381-4e33-804a-df7c8fa71fdd.png)'
  prefs: []
  type: TYPE_IMG
- en: Zuul edge is now registered to map requests for `product` service, and forward
    it to the service address pointed by Eureka
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `product` service, the service execution has happened by running the
    queries on the database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/52c0c7ce-1671-49fe-8722-fd28fa7b3c6d.png)'
  prefs: []
  type: TYPE_IMG
- en: Kubernetes – container orchestration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been individually deploying the services such as Eureka, the
    config server, the `product` service, and Zuul.
  prefs: []
  type: TYPE_NORMAL
- en: Recollecting from the previous chapter, we can automate their deployment through
    CI, such as Jenkins. We also saw how the deployment could be done with Docker
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: However, during runtime, the containers still run independently of each other.
    There is no mechanism to scale the containers, or to restart them if one has failed.
    Also, the decision on which service to deploy on which VM is manual, which means
    that the services always get deployed onto the static VMs that are designated
    for the services to run, instead of being mixed and matched intelligently. In
    short, the orchestration layer managing our application services is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is a popular orchestration mechanism that makes deployment and runtime
    management an easier task.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes architecture and services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes is an open source project spearheaded by Google. It attempts to
    implement some of the tried-and-tested ideas that were implemented in its own
    internal container orchestration system called Borg. Kubernetes architecture is
    composed of two components: the master and minion nodes. The master nodes have
    the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller**: To manage the nodes, replicas, and services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Server**: To provide REST endpoints used by the `kubectl` client and
    the minion nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduler**: To decide where a particular container must be spawned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Etcd**: To store the state of the cluster and configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The minion nodes contain two components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubelet**: An agent to communicate resource availability to the master and
    launch the containers specified by the scheduler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy**: To route network requests to the kubernetes services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5d4b9703-fa3e-4db5-a199-03ea0c786a63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Kubernetes is a container scheduler which uses two primitives, namely Pod and
    Service. A Pod is a collection of related containers which may be tagged with
    certain Labels; a service can target Pods using these Labels and expose endpoints.
    The following diagram illustrates the concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41cab5e8-0a49-4c89-9726-46c9fd266bda.png)'
  prefs: []
  type: TYPE_IMG
- en: Pods are considered ephemeral in kubernetes and may be killed. However, if the
    Pods were created using a `ReplicaSet`, where we can specify how many replicas
    or instances of a certain Pod have to be present in the system, then the kubernetes
    scheduler will automatically schedule new instances of the Pod and once the Pod
    becomes available, the service will start routing traffic to it. As you may notice
    that a Pod may be targeted by multiple services provided the labels match, this
    feature is useful to do rolling deployments.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at how to deploy a simple API on kubernetes and do a rolling
    upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Minikube is a project that helps in running a working, single-node Kubernetes
    on a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: You can install Minikube by following the instructions at: [https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, ensure that the following steps have been completed:'
  prefs: []
  type: TYPE_NORMAL
- en: The kubectl binary also needs to be downloaded and placed in the path so that
    once Minikube gets kubernetes running, we can communicate and manage the kubernetes
    resources from the command prompt. You can download it from: [https://storage.googleapis.com/kubernetes-release/release/v1.9.0/bin/windows/amd64/kubectl.exe.](https://storage.googleapis.com/kubernetes-release/release/v1.9.0/bin/windows/amd64/kubectl.exe)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to run Minikube from the same drive (say, `C:`) where your `Users`
    directory is present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running product service in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s change our existing `product` service to run through Kubernetes container
    orchestration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f01f2726-0de2-4bfd-87d7-0f8cf6e4e413.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can test if the configuration is working by running it, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/19de38b0-2e91-45bd-ae55-83c6ba149d05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set up the Docker client to connect to the Docker daemon running within the
    Minikube VM as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84475ab0-4a51-42ae-b1e4-98c7e510e0b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Build the Docker image from the instructions in the previous chapters where
    we created a Docker image as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d987e67b-6356-4a15-b07e-c2f3c3bb0399.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a `deployment` file (note that the `imagePullPolicy` is set to `never`,
    because otherwise, the default behavior of Kubernetes is to pull from the Docker
    registry):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/30100249-a874-4443-ab31-f3181c8231c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify that the three instances are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91f1f85e-0fb3-41e5-ab63-c0c77010337a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a `service.yml` file, so that we can access the Pods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b2f2649-3ddf-42bd-aa5e-03d1c68cb9e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, run the `service.yml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef8eb953-aca4-49d1-b4be-74afbec0f24c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you can get the address of the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d34e0441-3d00-4e5a-83b5-ca4fd0ba12fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now access the API, which will route requests to all three Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92706603-f244-4aec-85a9-7ed96aa943e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may use `-v` for individual commands to get the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac351569-8874-4233-a5b9-c9c170c309e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Change the code, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5cccf822-15ce-4697-b58d-f8c4f8b289ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Build Docker image with a new tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/de76ca1a-c146-4a34-a441-4f337b4f8b36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Update the `deployment.yml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29c79439-0779-47a2-902c-956032ec8497.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Apply the change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ef3e6a9-e013-4f80-8ef7-2e97781e9176.png)'
  prefs: []
  type: TYPE_IMG
- en: Platform as a Service (PaaS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular runtime for cloud-native applications is to use a PaaS platform,
    specifically, application PaaS platforms. PaaS provides an easy way to deploy
    cloud-native applications. They provide additional services like file storage,
    encryption, key-value storage, and databases which can be easily bound to the
    applications. PaaS platforms also provide an easy mechanism to scale cloud-native
    applications. Let's now understand why PaaS platforms provide an excellent runtime
    for cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: The case for PaaS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the runtime architecture realization, we saw that a number of components,
    such as the config server, the service registry, the reverse proxy, monitoring,
    log aggregation, and metrics have to come together to realize a scalable microservices
    architecture. With the exception of the business logic in `ProductService`, the
    rest of the services and components were pure supporting components, thus involving
    a lot of platform building and engineering.
  prefs: []
  type: TYPE_NORMAL
- en: What if all the components we built came out of the box in a platform which
    was provided as a service? Thus, PaaS is a higher level of abstraction over container
    orchestration. PaaS provides all the basic infrastructure services which we discussed
    in container orchestration, such as restarting services, scaling them, and load
    balancing, out of the box. In addition, PaaS offers additional services that complement
    the development, scaling, and maintenance of cloud-native applications. This approach
    has a trade-off that it reduces the choices in the selection and fine-tuning of
    the components. However, for most enterprises focusing on the business problem,
    this will be a fine trade-off to have.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, with PaaS, the developer can now concentrate on writing the code and not
    worrying about the infrastructure he/she is going to deploy on. All the engineering
    now becomes configuration that the developers and operations team can configure.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b373ec4d-7682-4bd1-b02e-ffad352f4447.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another few advantages of the PaaS include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtimes**: Providing various runtimes for developer to develop services,
    such as Java, Go, Node.js, or .NET. Thus, the developer focuses on generating
    a deployment, which can run in the various runtimes provided by the PaaS environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**: PaaS provides application services, such as databases and messaging
    out of the box for the applications to use. This is beneficial, as the developers
    and the operations do not have to install or manage them separately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-cloud**: PaaS abstracts the developer from the underlying infrastructure
    (or IaaS). Thus, the developer can develop for the PaaS environment, without worrying
    about deploying it in a data center or to various cloud providers such as AWS,
    Azure, or the Google Cloud Platform, if the PaaS runs on these infrastructures.
    This avoids lock-in to an infrastructure or cloud environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trade-off of the PaaS environment is that they can be restrictive and reduce
    flexibility. The default services and runtime selected may not be suitable for
    all use cases. However, most PaaS providers provide plug points and APIs to include
    more services and configurations, and policies to fine tune the runtime behaviors,
    which can mitigate the trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Foundry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud Foundry is one of the most mature open source PaaS owned by the Cloud
    Foundry foundation.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is primarily composed of, following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application runtime**: The foundation platform, where the developer deploys
    the application workloads like Java or Node.js applications. Application runtime
    provides for capabilities like application life cycle, application execution,
    and supporting functions, such as routing, authentication, platform services,
    including messaging, metrics, and logging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container runtime**: The runtime abstraction where the containers run. This
    provides deployment, management, and integration of the containers on which the
    applications run, using Kubernetes as the base platform. It is based on project
    Kubo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application services**: These are services like databases that the application
    binds to. Typically, they are provided by third-party providers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud Foundry components**: There are a lot of them, such as BOSH (for container
    runtime), Diego (for application runtime), **Bulletin Board System** (**BBS**),
    NATS, Cloud Controller, and so on. However, these are responsible for providing
    various capabilities of PaaS and can be abstracted from the developers. They are
    of relevance and interest to the operations and infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of org, account, and space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cloud Foundry has an elaborate **role-based access control** (**RBAC**) for
    managing the applications and its various resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Org**: This represents an organization, to which multiple users can be bound.
    An org shares the applications, service availability, resource quota, and plans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User account**: The user account represents an individual login that can
    act on the applications or operations in cloud foundry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Space**: Every application or service runs in a space that is bound to org
    and managed by a user account. An org has at least one space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roles and permissions**: The users belonging to org have roles which can
    do restricted actions (or permissions). The details are documented at: [https://docs.cloudfoundry.org/concepts/roles.html](https://docs.cloudfoundry.org/concepts/roles.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for implementations of Cloud Foundry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a lot of engineering involved in getting the vanilla Cloud Foundry
    installed and running. Hence, there are many PaaS implementations that use Cloud
    Foundry as a foundation and provide additional features, the most popular ones
    being Bluemix from IBM, OpenShift from Redhat, and **Pivotal Cloud Foundry** (**PCF**)
    from Pivotal.
  prefs: []
  type: TYPE_NORMAL
- en: Pivotal Cloud Foundry (PCF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pivotal's Cloud Foundry aims to increase developer productivity and operator
    efficiency and to provide security and availability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though readers of this book are free to choose the PaaS implementations that
    are based on Cloud Foundry, we have chosen Pivotal for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Pivotal has been behind Spring Framework, which we have used amply in the book.
    Pivotal's Cloud Foundry implementation has native support of the Spring Framework
    and its components, such as Spring Boot and Spring Cloud. Hence, the Spring Boot
    deployable that we create can be directly deployed to the application runtime
    of the Cloud Foundry and managed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pivotal's service marketplace is rich, covering most of the platform components
    by partners including MongoDB, PostgreSQL, Redis, and native support (Pivotal
    developed) services for MySQL and Cloud Cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pivotal has been doing a number of releases in this space and hence the service
    offerings are updated frequently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PCF components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Pivotal website [pivotal.io/platform](https://pivotal.io/platform) gives
    a very simple diagram for the implementation of Cloud Foundry, which maps to our
    earlier discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pivotal Application Service** (**PAS**): This is an abstraction for applications
    that map to application runtime in Cloud Foundry. Internally, it uses Diego, but
    that is hidden from the developer. PAS has excellent support for Spring Boot and
    Spring Cloud, but can run other Java, .NET, and Node apps as well. It is suitable
    for running custom written application workloads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pivotal Container Service** (**PKS**): This is an abstraction for containers
    and maps to container runtime in Cloud Foundry. It uses BOSH internally. It is
    suitable for running workloads that are provided as containers, that is, **independent
    service vendor** (**ISV**) applications like Elasticsearch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pivotal Function Service** (**PFS**): This is a new offering of Pivotal outside
    of the Cloud Foundry platform. It provides abstraction for functions. It promotes
    serverless computing. The functions are invoked on a HTTP request (synchronous)
    or when messages arrive (asynchronous).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Marketplace**: This maps to the application services in Cloud Foundry. Given
    the popularity of the PCF, there are a lot of services available in the marketplace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared components**: These include the supporting services to run functions,
    applications, and containers, such as authentication, authorization, logging,
    monitoring (PCF watch), scaling, networking, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/adf88116-bf09-47c7-94da-654596b2450f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: PCF can be run on most of the popular clouds, including Google Compute Platform,
    Azure, AWS, and Open Stack (IaaS), hosted on a data center.
  prefs: []
  type: TYPE_NORMAL
- en: While PCF and its components are great for the server-side loads, it might be
    cumbersome for developers who are building software on their local machines. We
    are at that stage now. We have developed `product` service and matured through
    various stages to reach cloud-native runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The entire PCF with its runtime components is difficult to fit on a laptop for
    development.
  prefs: []
  type: TYPE_NORMAL
- en: PCF Dev
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PCF Dev is a condensed PCF distribution that can run locally on a VM on a desktop
    or laptop. It promises to enable the same environment that the developers would
    have on the main PCF environment, so that there is no difference when an application
    meant for PCF Dev runs on the main PCF environment. Refer to the table in [https://docs.pivotal.io/pcf-dev/index.html](https://docs.pivotal.io/pcf-dev/index.html)
    for an exact comparison of the size and capabilities provided by PCF Dev vis-à-vis
    the full PCF and **Cloud Foundry** (**CF**):'
  prefs: []
  type: TYPE_NORMAL
- en: It supports the application runtime for Java, Ruby, PHP, and Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a mini version of PAS that gives the essential capabilities for our service
    development that we have discussed so far, such as logging and metrics, routing,
    Diego (Docker) support, application services, scaling, monitoring, and failure
    recovery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also comes with four application services built-in, these are: **Spring
    Cloud Services** (**SCS**), Redis, RabbitMQ, and MySQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it is not meant for production. It does not have BOSH, which orchestrates
    over the infrastructure layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your desktop/laptop has over 8 GB of memory and disk space over 25 GB, let's
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PCF Dev can run in a Mac, Linux, or Windows environment. Follow the instructions,
    for example, [https://docs.pivotal.io/pcf-dev/install-windows.html](https://docs.pivotal.io/pcf-dev/install-windows.html)
    for Windows, to get PCF Dev running on your machine. This essentially is in three
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Virtual Box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CF command line interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the PCF Dev
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting PCF Dev
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time we start using cf dev start, it will take a long time to download
    the VM image (4 GB), extract it (20 GB), and then start the various services of
    the PCF. Hence, once the VM is downloaded and running, we would just suspend and
    resume the VM with the Cloud Foundry services running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Command line options for starting PCF Dev are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you have a multi-core machine, you can allocate half the cores for
    this VM, such as `-c 2` for a four core machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The SCS version will use 8 GB of memory; to keep the buffer, let's use 10 GB
    of memory which is expressed in terms of MB on the command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need the services of MySQL and SCS for the next chapter. Internally,
    SCS needs RabbitMQ to run. Hence, let's include all servers while running the
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is optional to give the domain and IP address, and hence, we will skip `-d`
    and `-i` options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the environment variable `PCFDEV_HOME` to a specific folder on a drive that
    has a good amount of space, so that it does not default to the home folder on
    the home drive. We would recommend the home folder to be a fast drive like SSD,
    as the Cloud Foundry start and stop operations are very I/O intensive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, our start command will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will take a long time till finally your PCF Dev environment is ready.
  prefs: []
  type: TYPE_NORMAL
- en: '**Speeding up development time**'
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult to wait 20 minutes while the entire PCF Dev environment is started
    each time. Once you finish working for the day or before shutting down your laptop,
    you can suspend the PCF Dev by  using `cf dev suspend` and resume it the next
    day by using the `cf dev resume` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other useful commands include:'
  prefs: []
  type: TYPE_NORMAL
- en: A default PCF Dev creates two users—admin and user. To install or manage the
    applications, you should login as one of the users. The command `cf dev target`
    logs you in as a default user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cf dev trust` command installs a certificate to enable SSL communication,
    so that you don't need to use parameter `-skip ssl` every time you log in on the
    command line or on an application manager in the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cf marketplace` command (once you have logged in as a user) shows the various
    services that can be installed in the org and space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the output of the commands discussed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46e17970-de5f-4b07-a292-77961ee32592.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the marketplace, since we started the PCF Dev with the all
    services option, we can see the marketplace ready with the seven services.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MySQL service on PCF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the list, in this chapter, we will configure our `product` service to work
    with the MySQL database and look at Spring Cloud services, such as the circuit
    breaker dashboard and other services in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the services are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcb84930-b49d-4642-b4a1-0f83e00a4ed1.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the product service on PCF Dev
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a simplified version of the `product` service that just connects
    to a MySQL service that we created earlier to run queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can write the practice code from Chapter 3, *Designing Your Cloud-Native
    Application* or download the file from Git to your Eclipse environment. The artifacts
    worth noting are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Maven file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that, in the following screenshot, we have renamed our artifact to `pcf-product`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new dependency worth noting is the `spring-cloud-cloudfoundry-connector`.
    This discovers the services bound to the Cloud Foundry application, such as MySQL
    configuration, and uses them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have included a MySQL connector for the JPA to connect to the MySQL database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d4741437-8ef6-4cd0-9131-b22e87c22639.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `application.properties` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that we have not given any MySQL connection properties, such as database,
    user, or password. These are picked up automatically by the Spring application,
    when the application is uploaded into Cloud Foundry and binds with the MySQL database
    service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The auto create setting in case of MySQL should be `true` only for development
    purposes as it will recreate the database on every application deploy. In the
    UAT or production profile, this setting will be `none`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProductSpringApp` class is simplified to a plain Spring Boot start up
    application. We will enhance this in the next chapter for metrics, lookup, load
    balancing, monitoring, and management:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/39007215-027d-4e62-be46-f8704956ab5c.png)'
  prefs: []
  type: TYPE_IMG
- en: The `ProductRepository` class only has one method, called `findByCatId`, listed.
    The rest of the methods, such as `get`, `save`, `delete`, and `update` are automatically
    derived in the repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ProductService`, `product`, and other classes are unchanged from those
    in [Chapter 3](dba50b25-08ed-48b1-9d28-6f0faff42ecb.xhtml), *Designing Your Cloud-Native
    Application*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `manifest.yml` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the new file containing instructions for deploying into cloud foundry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will write the most basic version that has the application name, allotment
    of 1 GB of memory space, and the binding to the MySQL service from CloudFoundry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The random route lets the application take a route to reach the URL without
    having collisions in case of multiple versions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ea27a340-3fdf-41f8-84bd-a380bb139f74.png)'
  prefs: []
  type: TYPE_IMG
- en: Once your project is ready, run `mvn install` to create the comprehensive `.jar`
    file in the `target` directory. Its name should match the name of the `.jar` in
    the `manifest.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Cloud Foundry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deploying to Cloud Floundry is simple, use the command `cf push pcf-product`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51738f77-7096-4b77-8a42-a027d0256861.png)'
  prefs: []
  type: TYPE_IMG
- en: Cloud Foundry does a lot of work creating the application in the space, creating
    routes to reach the application, and then binding the various services with the
    application. You should perhaps read more on Cloud Foundry if you are interested
    in what happens under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the deployment is complete, you will see the success method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61d3c1bf-dda6-43d5-bc43-9285ba8913b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Note the URL which is generated in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: It is `http://pcf-product-undedicated-spirketting.local.pcfdev.io`. We will
    see how to make this URL shorter in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you got an error on startup, for example, with a wrong configuration
    or missing a few steps, you can always check the logs by giving the following
    command in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is time to test our service. In the browser window, run the two services
    that we generally run:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://pcf-product-undedicated-spirketting.local.pcfdev.io/product/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://pcf-product-undedicated-spirketting.local.pcfdev.io/products?id=1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will see the response coming from the database, that is, the output and
    logs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47e191d7-5992-4cff-ba9b-fffafa2822d3.png)'
  prefs: []
  type: TYPE_IMG
- en: This completes deploying our simple `product` service into PCF on PCF Dev.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw the various runtime components supporting cloud-native
    applications and ran our application on various runtimes, such as Kubernetes and
    Cloud Foundry.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deploy our service on AWS Cloud.
  prefs: []
  type: TYPE_NORMAL
