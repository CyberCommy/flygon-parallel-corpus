- en: Chapter 6. ELF Binary Forensics in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The field of computer forensics is widespread and includes many facets of investigation.
    One such facet is the analysis of executable code. One of the most insidious places
    for a hacker to install some type of malicious functionality is within an executable
    file of some kind. In Linux, this is, of course, the ELF file type. We already
    explored some of the infection techniques that are being used in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*, but have spent very little time discussing the analysis
    phase. How exactly should an investigator go about exploring a binary for anomalies
    or code infections? That is what this chapter is all about.
  prefs: []
  type: TYPE_NORMAL
- en: The motives for an attacker infecting an executable varies greatly, and it may
    be for a virus, a botnet, or a backdoor. There are, of course, many cases where
    an individual wants to patch or modify a binary to achieve totally different ends
    such as binary protection, code patching, or other experimentation. Whether malicious
    or not, the binary modification methods are all the same. The inserted code is
    what determines whether or not the binary is possessed with malicious intent.
  prefs: []
  type: TYPE_NORMAL
- en: In either case, this chapter will arm the reader with the insight necessary
    for determining whether or not a binary has been modified, and how exactly it
    has been modified. In the following pages, we will be examining several different
    types of infections and will even discuss some of my findings when performing
    a real-world analysis of the Retaliation Virus for Linux that was engineered by
    one of the world's most skilled Virus authors named JPanic. This chapter is all
    about training your eye to be able to spot anomalies within an ELF binary file,
    and with some practice it becomes quite possible to do so with ease.
  prefs: []
  type: TYPE_NORMAL
- en: The science of detecting entry point modification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a binary is modified in some way, it is generally for the purpose of adding
    code to the binary and then redirecting execution flow to that code. The redirection
    of execution flow can happen in many places within the binary. In this particular
    case, we are going to examine a very common technique used when patching binaries,
    especially for viruses. This technique is to simply modify the entry point, which
    is the `e_entry` member of the ELF file header.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is here to determine whether or not `e_entry` is holding an address
    that points to a location that signifies an abnormal modification to the binary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Abnormal means any modification that wasn't created by the linker itself `/usr/bin/ld`
    whose job it is to link ELF objects together. The linker will create a binary
    that represents normalcy, whereas an unnatural modification often appears suspicious
    to the trained eye.
  prefs: []
  type: TYPE_NORMAL
- en: 'The quickest route to being able to detect anomalies is to first know what
    is normal. Let''s take a look at two normal binaries: one dynamically linked and
    the other statically linked. Both have been compiled with `gcc` and neither has
    been tampered with in any way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So we can see that the entry point is `0x400520`. If we look at the section
    headers, we can see what section this address falls into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our example, the entry point starts at the beginning of the `.text` section.
    This is not always so, and therefore grepping for the first significant hex-digits,
    as we did previously isn't a consistent approach. It is recommended that you check
    both the address and size of each section header until you find the section with
    an address range that contains the entry point.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, it points right to the beginning of the `.text` section, which
    is common, but depending on how the binary was compiled and linked, this may change
    with each binary you look at. This binary was compiled so that it was linked to
    libc just like 99 percent of the binaries you will encounter are. This means that
    the entry point contains some special initialization code and it looks almost
    identical in every single libc-linked binary, so let''s take a look at it so we
    can know what to expect when analyzing the entry point code of binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding assembly code is the standard glibc initialization code pointed
    to by `e_entry` of the ELF header. This code is always executed before `main()`
    and its purpose is to call the initialization routine `libc_start_main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function sets up the process heap segment, registers constructors and destructors,
    and initializes threading-related data. Then it calls `main()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what the entry point code looks like on a libc-linked binary,
    you should be able to easily determine when the entry point address is suspicious,
    when it points to code that does not look like this, or when it is not even in
    the `.text` section at all!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A binary that is statically linked with libc will have initialization code in
    _start that is virtually identical to the preceding code, so the same rule applies
    for statically linked binaries as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look another binary that has been infected with the Retaliation
    Virus and see what type of oddities we find with the entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A quick examination of the section headers with `readelf -S` will prove that
    this address is not accounted for by any section header, which is extremely suspicious.
    If an executable has section headers and there is an executable area that is not
    accounted for by a section, then it is almost certainly a sign of infection or
    binary patching. For code to be executed, section headers are not necessary as
    we've already learned, but program headers are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look and see what segment this address fits into by looking at
    the program headers with `readelf -l`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This output is extremely suspicious for several reasons. Typically, we only
    see two LOAD segments with one ELF executable—one for the text and one for the
    data—although this is not a strict rule. Nevertheless, it is the norm, and this
    binary is showing three segments.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, this segment is suspiciously marked RWE (read + write + execute),
    which indicates self-modifying code, commonly used with viruses that have polymorphic
    engines such as this one. The entry point, points inside this third segment, when
    it should be pointing to the first segment (the text segment), which, as we can
    see, starts at the virtual address `0x400000`, which is the typical text segment
    address for executables on Linux x86_64\. We don't even have to look at the code
    to be fairly confident that this binary has been patched.
  prefs: []
  type: TYPE_NORMAL
- en: But for verification, especially if you are designing code that performs automated
    analysis of binaries, you can check the code at the entry point and see if it
    matches what it is expected to look like, which is the libc initialization code
    we looked at earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `gdb` command is displaying the disassembled instructions found
    at the entry point of the `retal_virus_sample` executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I think we can quickly agree that the preceding code does not look like the
    libc initialization code that we would expect to see in the entry point code of
    an untampered executable. You can simply compare it with the expected libc initialization
    code that we looked at from `bin1` to find this out.
  prefs: []
  type: TYPE_NORMAL
- en: Other signs of modified entry points are when the address points to any section
    outside of the `.text` section, especially if it's a section that is the last-most
    section within the text segment (sometimes this the `.eh_frame` section). Another
    sure sign is if the address points to a location within the data segment that
    will generally be marked as executable (visible with `readelf -l`) so that it
    can execute the parasite code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, the data segment is marked as RW, because no code is supposed to
    be executing in that segment. If you see the data marked RWX then let that serve
    as a red flag, because it is extremely suspicious.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the entry point is not the only way to create an entry point to insert
    code. It is a common way to achieve it, and being able to detect this is an important
    heuristic, especially in malware because it can reveal the start point of the
    parasite code. In the next section, we will discuss other methods used to hijack
    control flow, which is not always at the beginning of execution, but in the middle
    or even at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting other forms of control flow hijacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many reasons to modify a binary, and depending on the desired functionality,
    the binary control flow will be patched in different ways. In the previous example
    of the Retaliation Virus, the entry point in the ELF file header was modified.
    There are many other ways to transfer execution to the inserted code, and we will
    discuss a few of the more common approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Patching the .ctors/.init_array section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ELF executables and shared libraries, you will notice that there is a section
    commonly present named `.ctors` (commonly also named `.init_array`). This section
    contains an array of addresses that are function pointers called by the initialization
    code from the `.init` section. The function pointers refer to functions created
    with the constructor attribute, which are executed before `main()`. This means
    that the `.ctors` function pointer table can be patched with an address that points
    to the code that has been injected into the binary, which we refer to as the parasite
    code.
  prefs: []
  type: TYPE_NORMAL
- en: It is relatively easy to check whether or not one of the addresses in the `.ctors`
    section is valid. The constructor routines should always be stored specifically
    within the `.text` section of the text segment. Remember from [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, that the `.text`
    section is not the text segment, but rather a section that resides within the
    range of the text segment. If the `.ctors` section contains any function pointers
    that refer to locations outside of the `.text` section, then it is probably time
    to get suspicious.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A side note on .ctors for anti-anti-debugging**'
  prefs: []
  type: TYPE_NORMAL
- en: Some binaries that incorporate anti-debugging techniques will actually create
    a legal constructor function that calls `ptrace(PTRACE_TRACEME, 0);`.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*, this technique prevents a debugger from attaching to the
    process since only one tracer can be attached at any given time. If you discover
    that a binary has a function that performs this anti-debugging trick and has a
    function pointer in `.ctors`, then it is advised to simply patch that function
    pointer with `0x00000000` or `0xffffffff` that will direct the `__libc_start_main()`
    function to ignore it, therefore effectively disabling the anti-debugging technique.
    This task could be easily accomplished in GDB with the set command, for example,
    `set {long}address = 0xffffffff`, assuming that address is the location of the
    .ctors entry you want to modify.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting PLT/GOT hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique has been used as far back as 1998 when it was published by Silvio
    Cesare in [http://phrack.org/issues/56/7.html](http://phrack.org/issues/56/7.html),
    which discusses the techniques of shared library redirection.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, we carefully examined
    dynamic linking and I explained the inner workings of the **PLT** (**procedure
    linkage table**) and **GOT** (**global offset table**). Specifically, we looked
    at lazy linking and how the PLT contains code stubs that transfer control to addresses
    that are stored in the GOT. If a shared library function such as `printf` has
    never been called before, then the address stored in the GOT will point back to
    the PLT, which then invokes the dynamic linker, subsequently filling in the GOT
    with the address that points to the `printf` function from the libc shared library
    that is mapped into the process address space.
  prefs: []
  type: TYPE_NORMAL
- en: It is common for both static (at rest) and hot-patching (in memory) to modify
    one or more GOT entries so that a patched in function is called instead of the
    original. We will examine a binary that has been injected with an object file
    that contains a function that simply writes a string to `stdout`. The GOT entry
    for `puts(char *);` has been patched with an address that points to the injected
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three GOT entries are reserved and will typically not be patched
    because it will likely prevent the executable from running correctly (See [Chapter
    2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985 "Chapter 2. The
    ELF Binary Format"), *The ELF Binary Format*, section on Dynamic linking). Therefore,
    as analysts, we are interested in observing the entries starting at GOT[3]. Each
    GOT value should be an address. The address can have one of two values that would
    be considered valid:'
  prefs: []
  type: TYPE_NORMAL
- en: Address pointer that points back into the PLT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Address pointer that points to a valid shared library function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a binary is infected on disk (versus runtime infection), then a GOT entry
    will be patched with an address that points somewhere within the binary where
    code has been injected. Recall from [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*, that there are numerous ways to inject code into an executable
    file. In the binary sample that we will look at here, a relocatable object file
    (`ET_REL`) was inserted at the end of the text segment using the Silvio padding
    infection discussed in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*.
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing the `.got.plt` section of a binary that has been infected, we
    must carefully validate each address from GOT[4] through GOT[N]. This is still
    easier than looking at the binary in memory because before the binary is executed,
    the GOT entries should always point only to the PLT, as no shared library functions
    have been resolved yet.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `readelf -S` utility and looking for the `.plt` section, we can deduce
    the PLT address range. In the case of the 32-bit binary I am looking at now, it
    is `0x8048300` - `0x8048350`. Remember this range before we look at the following
    `.got.plt` section.
  prefs: []
  type: TYPE_NORMAL
- en: Truncated output from readelf -S command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s take a look at the `.got.plt` section of a 32-bit binary and see
    if any of the relevant addresses are pointing outside of `0x8048300`–`0x8048350`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So let''s take these addresses out of their little endian byte ordering and
    validate that each one points within the `.plt` section as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '`08048628`: This does not point to PLT!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`08048326`: This is valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`08048336`: This is valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`08048346`: This is valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GOT location `0x804a00c` contains the address `0x8048628`, which does not
    point to a valid location. We can see what shared library function `0x804a00c`
    corresponds to by looking at the relocation entries with the `readelf -r` command,
    which shows us that the infected GOT entry corresponds to the libc function `puts()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So the GOT location `0x804a00c` is the relocation unit for the `puts()` function.
    Typically, it should contain an address that points to the PLT stub for the GOT
    offset so that the dynamic linker will be invoked and resolve the runtime value
    for that symbol. In this case, the GOT entry contains the address `0x8048628`,
    which points to a suspicious bit of code at the end of the text segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically, we don''t even have to know what this code does in order to know
    that the GOT was hijacked because the GOT should only contain addresses that point
    to the PLT, and this is clearly not a PLT address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A further exercise would be to disinfect this binary manually, which is something
    we do in the ELF workshop trainings I provide periodically. Disinfecting this
    binary would primarily entail patching the `.got.plt` entry that contains the
    pointer to the parasite and replacing it with a pointer to the appropriate PLT
    stub.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting function trampolines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term trampoline is used loosely but is originally referred to inline code
    patching, where the insertion of a branch instruction such as a `jmp` is placed
    over the first 5 to 7 bytes of the procedure prologue of a function. Often times,
    this trampoline is temporarily replaced with the original code bytes if the function
    that was patched needs to be called in such a way that it behaves as it originally
    did, and then the trampoline instruction is quickly placed back again. Detecting
    inline code hooks such as these is quite easy and can even be automated with some
    degree of ease provided you have a program or script that can disassemble a binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are two examples of trampoline code (32-bit x86 ASM):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type 1:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Type 2:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A good classic paper on using function trampolines for function hijacking in
    kernel space was written by Silvio in 1999\. The same concepts can be applied
    today in userland and in the kernel; for the kernel you would have to disable
    the write protect bit in the cr0 register to make the text segment writeable,
    or directly modify a PTE to mark a given page as writeable. I personally have
    had more success with the former method. The original paper on kernel function
    trampolines can be found at [http://vxheaven.org/lib/vsc08.html](http://vxheaven.org/lib/vsc08.html).
  prefs: []
  type: TYPE_NORMAL
- en: The quickest way to detect function trampolines is to locate the entry point
    of every single function and verify that the first 5 to 7 bytes of code do not
    translate to some type of branch instruction. It would be very easy to write a
    Python script for GDB that can do this. I have written C code to do this in the
    past fairly easily.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying parasite code characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just reviewed some common methods for hijacking execution flow. If you can
    identify where the execution flow points, you can typically identify some or all
    of the parasite code. In the section *Detecting PLT/GOT hooks*, we determined
    the location of the parasite code for the hijacked `puts()` function by simply
    locating the PLT/GOT entry that had been modified and seeing where that address
    pointed to, which, in that case, was to an appended page containing parasite code.
  prefs: []
  type: TYPE_NORMAL
- en: Parasite code can be qualified as code that is unnaturally inserted into the
    binary; in other words, it wasn't linked in by the actual ELF object linker. With
    that said, there are several characteristics that can sometimes be attributed
    to injected code, depending on the techniques used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Position independent code** (**PIC**) is often used for parasites so that
    it can be injected into any point of a binary or memory and still execute properly
    regardless of its position in memory. PIC parasites are easier to inject into
    an executable because the code can be inserted into the binary without having
    to consider handling relocations. In some cases, such as with my Linux padding
    Virus [http://www.bitlackeys.org/projects/lpv.c](http://www.bitlackeys.org/projects/lpv.c),
    the parasite is compiled as an executable with the gcc-nostdlib flag. It is not
    compiled as position independent, but it has no libc linking, and special care
    is taken within the parasite code itself to dynamically resolve memory addresses
    with instruction-pointer relative computations.'
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, the parasite code is written purely in assembly language and
    is therefore in a sense more identifiable as being a potential parasite since
    it will look different from what the compiler produces. One of the giveaways with
    parasite code written in assembly is the way in which syscalls are handled. In
    C code, typically syscalls are called through libc functions that will invoke
    the actual syscall. Therefore, syscalls look just like regular dynamically linked
    functions. In handwritten assembly code, syscalls are usually invoked directly
    using either the Intel sysenter or syscall instructions, and sometimes even `int
    0x80` (which is now considered legacy). If syscall instructions are present, we
    may consider it a red flag.
  prefs: []
  type: TYPE_NORMAL
- en: Another red flag, especially when analyzing a remote process that may be infected,
    is to see `int3` instructions that can serve many purposes such as passing control
    back to a tracing process that is performing the infection or, even more disturbing,
    the ability to trigger some type of anti-debugging mechanism within malware or
    a binary protector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following 32-bit code memory maps a shared library into a process and then
    passes control back to the tracer with an `int3`. Notice that `int 0x80` is being
    used to invoke the syscalls. This shellcode is actually quite old; I wrote it
    in 2008\. Typically, nowadays we want to use either the sysenter or syscall instruction
    to invoke a system call in Linux, but the `int 0x80` will still work; it is just
    slower and therefore considered deprecated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you were to see this code inside an executable on disk or in memory, you
    should quickly come to the conclusion that it does not look like compiled code.
    One dead giveaway is the **call/pop technique** that is used to dynamically retrieve
    the address of `/lib/libtest.so.1.0`. The string is stored right after the `call
    A` instruction and therefore its address is pushed onto the stack, and then you
    can see that it gets popped into `ebx`, which is not conventional compiler code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Checking the dynamic segment for DLL injection traces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall from [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, that the dynamic
    segment can be found in the program header table and is of type `PT_DYNAMIC`.
    There is also a `.dynamic` section that also points to the dynamic segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dynamic segment is an array of ElfN_Dyn structs that contains `d_tag` and
    a corresponding value that exists in a union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using `readelf` we can easily view the dynamic segment of a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example of a legitimate dynamic segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There are many important tag types here that are necessary for the dynamic linker
    to navigate the binary at runtime so that it can resolve relocations and load
    libraries. Notice that the tag type called `NEEDED` is highlighted in the preceding
    code. This is the dynamic entry that tells the dynamic linker which shared libraries
    it needs to load into memory. The dynamic linker will search for the named shared
    library in the paths specified by the $`LD_LIBRARY_PATH` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: It is clearly conceivable for an attacker to add a `NEEDED` entry into the binary
    that is specifying a shared library to load. This is not a very common technique
    in my experience, but it is a technique that can be used tell the dynamic linker
    to load whichever library you want. The problem for analysts is that this technique
    is difficult to detect if it is done correctly, which is to say that the inserted
    `NEEDED` entry is inserted directly after the last legitimate `NEEDED` entry.
    This can be difficult because you have to move all of the other dynamic entries
    forward to make room for your insertion.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, the attacker may do this the inexperienced way where the `NEEDED`
    entry is at the very end of all other entries, which the object linker would never
    do, so if you see a dynamic segment that looks like the following, you know something
    is up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an infected dynamic segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Identifying reverse text padding infections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a virus infection technique that we discussed in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*. The idea is that a virus or parasite can make room for
    its code by extending the text segment in reverse. The program header for the
    text segment will look strange if you know what you're looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an ELF 64-bit binary that has been infected with a virus
    that uses this parasite infection method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: On Linux x86_64, the default virtual address for the text segment is `0x400000`.
    This is because the default linker script used by the linker says to do so. The
    program header table (marked by PHDR, as highlighted in the preceding) is 64 bytes
    into the file and will therefore have a virtual address of `0x400040`. From looking
    at the program headers in the preceding output, we can see that the text segment
    (the first LOAD line) does not have the expected address; instead it is `0x3ff000`.
    Yet the PHDR virtual address is still at `0x400040`, which tells you that at one
    point so was the original text segment address, and that something strange is
    going on here. This is because the text segment was essentially extended backward,
    as we discussed in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying reverse text padding infections](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Illustration – Diagram showing a reverse-text-infected executable
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an ELF file header of reverse-text-infected executables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'I have highlighted everything in the ELF header that is questionable:'
  prefs: []
  type: TYPE_NORMAL
- en: Entry point points into parasite area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start of program headers should only be 64 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Section header table offset is 0, as in stripped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying text segment padding infections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This type of infection is relatively easy to detect. This type of infection
    was also discussed in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*. This technique relies on the fact that there is always
    going to be a minimum of 4,096 bytes between the text and the data segment because
    they are loaded into memory as two separate memory segments, and memory mappings
    are always page aligned.
  prefs: []
  type: TYPE_NORMAL
- en: On 64-bit systems, there is typically `0x200000` (2MB) free due to **PSE** (**Page
    size extension**) pages. This means that a 64-bit ELF binary can be inserted with
    a 2MB parasite, which is much larger than what is typically needed for an injection
    space. With this type of infection, like any other, you can often identify the
    parasite location by examining the control flow.
  prefs: []
  type: TYPE_NORMAL
- en: With the `lpv` virus which I wrote in 2008, for instance, the entry point is
    modified to start execution at the parasite that is inserted using the text segment
    padding infection. If the executable that has been infected has a section header
    table, you will see that the entry point address resides in the range of the last
    section within the text segment. Let's take a look at a 32-bit ELF executable
    that has been infected using this technique.
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying text segment padding infections](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Illustration – Diagram showing a text segment padding infection
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an ELF file header of the `lpv` infected file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice the entry point address, `0x80485b8`. Does this address point somewhere
    inside the `.text` section? Let's take a peek at the section header table and
    find out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an ELF section headers of the `lpv` infected file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The entry point address falls within the `.eh_frame` section that is the last
    section in the text segment. This is clearly not the `.text` section that is enough
    reason to become immediately suspicious, and because the `.eh_frame` section is
    the last section in the text segment (which you can verify by using `readelf -l`),
    we are able to deduce that this Virus infection is probably using a text segment
    padding infection.The following are ELF program headers of the `lpv` infected
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Based on everything highlighted in the preceding program header output, you
    can see the program entry point, the text segment (the first `LOAD` program header),
    and the fact that `.eh_frame` is the last section in the text segment.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying protected binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Identifying a protected binary is the first step in reverse-engineering it.
    We discussed the common anatomy of protected ELF executables in [Chapter 5](part0049_split_000.html#1ENBI1-1d4163ae11644cc2802846625b2dc985
    "Chapter 5. Linux Binary Protection"), *Linux Binary Protection*. Remember from
    what we learned that a protected binary is actually two executables that have
    been merged together: you have the stub executable (the decryptor program) and
    then the target executable.'
  prefs: []
  type: TYPE_NORMAL
- en: One program is responsible for decrypting the other, and it is this program
    that is going to typically be the wrapper that wraps or contains an encrypted
    binary within it, as a payload of sorts. Identifying this outer program that we
    call a stub is typically pretty easy because of the blatant oddities you will
    see in the program header table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a 64-bit ELF binary that is protected using a protector
    I wrote in 2009 called `elfcrypt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So what are we seeing here? Or rather what are we not seeing?
  prefs: []
  type: TYPE_NORMAL
- en: This almost looks like a statically compiled executable because there is no
    `PT_DYNAMIC` segment and there is no `PT_INTERP` segment. However, if we run this
    binary and check `/proc/$pid/maps,` we see that this is not a statically compiled
    binary, but is in fact dynamically linked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output from `/proc/$pid/maps` in the protected binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can clearly see that the dynamic linker is mapped into the process address
    space, and so is libc. As discussed in [Chapter 5](part0049_split_000.html#1ENBI1-1d4163ae11644cc2802846625b2dc985
    "Chapter 5. Linux Binary Protection"), *Linux Binary Protection*, this is because
    the protection stub becomes responsible for loading the dynamic linker and setting
    up the auxiliary vector.
  prefs: []
  type: TYPE_NORMAL
- en: From the program header output, we can also see that the text segment address
    is `0xa00000`, which is unusual. The default linker script used for compiling
    executables in x86_64 Linux defines the text address as `0x400000`, and on 32-bit
    systems it is `0x8048000`. Having a text address other than the default does not,
    on its own, suggest anything malicious, but should immediately raise suspicion.
    In the case of a binary protector, the stub must have a virtual address that does
    not conflict with the virtual address of the self-embedded executable it is protecting.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing a protected binary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: True binary protection schemes that really do a good job will not be very easy
    to circumvent, but in more cases than not you can use some intermediate reverse
    engineering efforts to get past the encryption layer. The stub is responsible
    for decrypting the self-embedded executable within it, which can therefore be
    extracted from memory. The trick is to allow the stub to run long enough to map
    the encrypted executable into memory and decrypt it.
  prefs: []
  type: TYPE_NORMAL
- en: A very general algorithm can be used that tends to work on simple protectors,
    especially if they do not incorporate any anti-debugging techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Determine the approximate number of instructions in the stub's text segment,
    represented by N.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trace the program for N instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dump the memory from the expected location of the text segment (for example,
    `0x400000`) and locate its data segment by using the program headers from the
    newly found text segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A good example of this simple technique can be demonstrated with Quenya, the
    32-bit ELF manipulation software that I coded in 2008.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UPX uses no anti-debugging techniques and is therefore relatively straightforward
    to unpack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the program headers of a packed executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the stub begins at `0xc01000`, and Quenya will presume that
    the real text segment is at the expected address for a 32-bit ELF executable:
    `0x8048000`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is Quenya using its unpack feature to decompress `test.packed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the Quenya unpack feature has allegedly unpacked the UPX packed
    executable. We can verify this by simply looking at the program headers of the
    unpacked executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the program headers are completely different from the ones we looked
    at previously when the executable was still packed. This is because we are no
    longer looking at the stub executable. We are looking at the executable that was
    compressed inside the stub. The unpacking technique we used is very generic and
    not very effective for more complicated protection schemes, but helps beginners
    gain an understanding into the process of reversing protected binaries.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Pro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this book tries to focus on the anatomy of the ELF format, and the concepts
    behind analysis and patching techniques, we are less focused on which of the fancy
    tools to use. The very famous IDA Pro software has a well-deserved reputation.
    It is hands down the best disassembler and decompiler available to the public.
    It is expensive though, and unless you can afford a license, you may have settle
    for something a little less effective, such as Hopper. IDA Pro is quite complicated
    and requires an entire book unto itself, but in order to properly understand and
    use IDA Pro for ELF binaries, it is good to first understand the concepts taught
    in this book, which can then be applied when using IDA pro to reverse-engineer
    software.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned the fundamentals of ELF binary analysis. You examined
    the procedures involved in identifying various types of virus infection, function
    hijacking, and binary protection. This chapter will serve you well in the beginner
    to intermediate phases of ELF binary analysis: what to look for and how to identify
    it. In the following chapters, you will cover similar concepts, such as analyzing
    process memory for identifying anomalies such as backdoors and memory-resident
    viruses.'
  prefs: []
  type: TYPE_NORMAL
- en: For those interested in knowing how the methods described in this chapter could
    be used in the development of an anti-virus or detection software, there do exist
    some tools I have designed that use similar heuristics to those described in this
    chapter for detecting ELF infections. One of these tools is called AVU and was
    mentioned with a download link in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*. Another one is named Arcana and is still private. I have
    not personally seen any public products on the market though that use these types
    of heuristics on ELF binaries, although such tools are sorely needed to aid Linux
    binary forensics. In [Chapter 8](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "Chapter 8. ECFS – Extended Core File Snapshot Technology"), *ECFS – Extended
    Core File Snapshot Technology*, we will explore ECFS, which is a technology I
    have been working on to help improve some of the areas where forensics capabilities
    are lacking, especially as it pertains to process memory forensics.
  prefs: []
  type: TYPE_NORMAL
