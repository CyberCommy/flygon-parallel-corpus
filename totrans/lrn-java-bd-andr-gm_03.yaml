- en: Chapter 3. Speaking Java – Your First Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start writing our very own Java code at the same time
    as we begin understanding Java syntax. We will learn how to store, retrieve, and
    manipulate different types of values stored in the memory. We will also look at
    making decisions and branching the flow of our code based on the values of this
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this order, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn some Java syntax and see how it is turned into a running app by the compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store data and use it with variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to express yourself in Java with expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue with the math game by asking a question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about decisions in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue with the math game by getting and checking the answer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Acquiring the preceding Java skills will enable us to build the next two phases
    of our math game. This game will be able to ask the player a question on multiplication,
    check the answer and give feedback based on the answer given, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Speaking Java – Your First Game](img/8859OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Java syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we will use plain English to discuss some fairly technical
    things. You will never be asked to read a technical explanation of a Java or Android
    concept that has not been previously explained in a non-technical way.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, I might ask or imply that you accept a simplified explanation
    in order to offer a fuller explanation at a more appropriate time, like the Java
    class as a black box; however, you will never need to scurry to Google in order
    to get your head around a big word or a jargon-filled sentence.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, the Java and Android communities are full of people who speak
    in technical terms and to join in and learn from these communities, you need to
    understand the terms they use. So the approach this book takes is to learn a concept
    or appreciate an idea using an entirely plain speaking language, but at the same
    time, it introduces the jargon as part of the learning.
  prefs: []
  type: TYPE_NORMAL
- en: Then, much of the jargon will begin to reveal its usefulness, usually as a way
    of clarification or keeping the explanation/discussion from becoming longer than
    it needs to be.
  prefs: []
  type: TYPE_NORMAL
- en: The very term, "Java syntax," could be considered technical or jargon. So what
    is it? The Java syntax is the way we put together the language elements of Java
    in order to produce code that works in the Java/Dalvik virtual machine. Syntax
    should also be as clear as possible to a human reader, not least ourselves when
    we revisit our programs in the future. The Java syntax is a combination of the
    words we use and the formation of those words into sentence like structures.
  prefs: []
  type: TYPE_NORMAL
- en: These Java elements or words are many in number, but when taken in small chunks
    are almost certainly easier to learn than any human-spoken language. The reason
    for this is that the Java language and its syntax were specifically designed to
    be as straightforward as possible. We also have Android Studio on our side, which
    will often let us know if we make a mistake and will even sometimes think ahead
    and prompt us.
  prefs: []
  type: TYPE_NORMAL
- en: I am confident that if you can read, you can learn Java; because learning Java
    is very easy. What then separates someone who has finished an elementary Java
    course from an expert programmer? The same things that separate a student of language
    from a master poet. Mastery of the language comes through practice and further
    study.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, I will show you the right direction if you want to go on
    to master Java yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler is what turns our human-readable Java code into another piece of
    code that can be run in a virtual machine. This is called **compiling**. The Dalvik
    virtual machine will run this compiled code when our players tap on our app icon.
    Besides compiling Java code, the compiler will also check for mistakes. Although
    we might still have mistakes in our released app, many discovered when our code
    is compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Making code clear with comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you become more advanced in writing Java programs, the solutions you use
    to create your programs will become longer and more complicated. Furthermore,
    as we will see in later chapters, Java was designed to manage complexity by having
    us divide our code into separate chunks, very often across multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comments** are a part of the Java program that do not have any function in
    the program itself. The compiler ignores them. They serve to help the programmer
    to document, explain, and clarify their code to make it more understandable to
    themselves at a later date or to other programmers who might need to use or modify
    the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a good piece of code will be liberally sprinkled with lines like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding comment begins with the two forward slash characters, `//`. The
    comment ends at the end of the line. It is known as a single-line comment. So
    anything on that line is for humans only, whereas anything on the next line (unless
    it''s another comment) needs to be syntactically correct Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use multiple single-line comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Single-line comments are also useful if we want to temporarily disable a line
    of code. We can put `//` in front of the code and it will not be included in the
    program. Recall this code, which tells Android to load our menu UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding situation, the menu will not be loaded and the app will have
    a blank screen when run, as the entire line of code is ignored by the compiler.
    There is another type of comment in Java—the multiline comment. This is useful
    for longer comments and also to add things such as copyright information at the
    top of a code file. Also like the single-line comment, it can be used to temporarily
    disable code, in this case usually multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything in between the leading `/*` signs and the ending `*/` signs is ignored
    by the compiler. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no limit to the number of lines in a multiline comment. Which type
    of comment is best to use will depend upon the situation. In this book, I will
    always explain every line of code explicitly but you will often find liberally
    sprinkled comments within the code itself that add further explanation, insight
    or clarification. So it''s always a good idea to read all of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the best Java programmers liberally sprinkle their code with comments.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data and using it with variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can think of a variable as a labeled storage box. They are also like a programmer's
    window to the memory of the Android device, or whatever device we are programming.
    Variables can store data in memory (the storage box), ready to be recalled or
    altered when necessary by using the appropriate label.
  prefs: []
  type: TYPE_NORMAL
- en: Computer memory has a highly complex system of addressing that we, fortunately,
    do not need to interact with in Java. Java variables allow us to make up convenient
    names for all the data that we want our program to work with; the JVM will handle
    all the technicalities that interact with the operating system, which in turn,
    probably through several layers of buck passing, will interact with the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: So we can think of our Android device's memory as a huge warehouse. When we
    assign names to our variables, they are stored in the warehouse, ready when we
    need them. When we use our variable's name, the device knows exactly what we are
    referring to. We can then tell it to do things such as "get box A and add it to
    box C, delete box B," and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In a game, we will likely have a variable named as something along the lines
    of `score`. It would be this `score` variable that we use to manage anything related
    to the user's score, such as adding to it, subtracting or perhaps just showing
    it to the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the following situations that might arise:'
  prefs: []
  type: TYPE_NORMAL
- en: The player gets a question right, so add 10 to their existing `score`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player views their stats screen, so print `score` on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player gets the best score ever, so make `hiScore` the same as their current
    `score`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are fairly arbitrary examples of names for variables and as long as you
    don't use any of the characters keywords that Java restricts, you can actually
    call your variables whatever you like. However, in practice, it is best to adopt
    a naming convention so that your variable names will be consistent. In this book,
    we will use a loose convention of variable names starting with a lowercase letter.
    When there is more than one word in the variable's name, the second word will
    begin with an uppercase letter. This is called "camel casing."
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of camel casing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`score`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hiScore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playersPersonalBest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we look at some real Java code with some variables, we need to first
    look at the types of variables we can create and use.
  prefs: []
  type: TYPE_NORMAL
- en: Types of variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not hard to imagine that even a simple game will probably have quite a
    few variables. In the previous section, we introduced the `hiScore` variable as
    an example. What if the game has a high score table that remembers the names of
    the top 10 players? Then we might need variables for each player.
  prefs: []
  type: TYPE_NORMAL
- en: And what about the case when a game needs to know if a playable character is
    dead or alive, or perhaps has any lives/retries left? We might need code that
    tests for life and then ends the game with a nice blood spurt animation if the
    playable character is dead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common requirement in a computer program, including games, is the right
    or wrong calculation: true or false.'
  prefs: []
  type: TYPE_NORMAL
- en: To cover these and many other types of information you might want to keep track
    of, Java has **types**. There are many types of variables and, as we will see
    in [Chapter 6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"),
    *OOP – Using Other People's Hard Work*, we can also invent our own types or use
    other people's types. But for now, we will look at the built-in Java types. To
    be fair, they cover just about every situation we are likely to run into for a
    while. Some examples are the best way to explain this type of stuff.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed the hypothetical but highly likely `score` variable.
    The variable `score` is likely to be a number, so we have to convey this (that
    the score is a number) to the Java compiler by giving the score an appropriate
    type. The hypothetical but equally likely `playerName` will, of course, hold the
    characters that make up the player's name. Jumping ahead a couple of paragraphs,
    the type that holds a regular number is called `int`, and the type that holds
    name-like data is called `String`. And if we try and store a player name, perhaps
    "Ada Lovelace" in `score`, which is meant for numbers, we will certainly run into
    trouble.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler says no! Actually, the error would say this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Types of variables](img/8859OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, Java was designed to make it impossible for such errors to make
    it to a running program. Did you also spot in the previous screenshot that I had
    forgotten the semicolon at the end of the line? With this compiler identifying
    our errors, what could possibly go wrong?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main types in Java. Later, we will see how to start using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`: This type is used to store integers. It uses 32 pieces (**bits**) of
    memory and can therefore store values with a magnitude a little in excess of 2
    billion, including negative values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: As the name hints at, this data type can be used when even larger numbers
    are required. A `long` data type uses 64 bits of memory and 2 to the power of
    63 is what we can store in this type. If you want to see what that looks like,
    try this: `9,223,372,036,854,775,807`. Perhaps surprisingly, there are uses for
    `long` variables but if a smaller variable will do, we should use it so that our
    program uses less memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering when you might use numbers of this magnitude. The obvious
    examples would be math or science applications that do complex calculations but
    another use might be for timing. When you time how long something takes, the Java
    `Date` class uses the number of milliseconds since January 1, 1970\. The `long`
    data type could be useful to subtract a start time from an end time to determine
    an elapsed time. We will use `long` in [Chapter 5](ch05.xhtml "Chapter 5. Gaming
    and Java Essentials"), *Gaming and Java Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: '`float`: This is for floating-point numbers, that is, numbers where there is
    precision beyond the decimal point. As the fractional part of a number takes memory
    space just as the whole number portion, the range of numbers possible in a float
    is therefore decreased compared to non-floating-point numbers. So, unless our
    variable will definitely use the extra precision, float would not be our data
    type of choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`: When the precision in `float` is not enough we have `double`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: When even an `int` data type is overkill, the super-skinny short fits
    into the tiniest of storage boxes, but we can only store around 64,000 values,
    from -32,768 to 32,767.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte`: This is an even smaller storage box than a short type. There is plenty
    of room for these in memory but a byte can only store values from -128 to 127.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`: We will be using plenty of Booleans throughout the book. A Boolean
    variable can be either true or false—nothing else. Perhaps Booleans answer questions
    such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the player alive?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a new high score been reached?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are two examples for a Boolean variable enough?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`: This stores a single alphanumeric character. It''s not going to change
    anything on its own but it could be useful if we put lots of them together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have kept this discussion of data types to a practical level that is useful
    in the context of this book. If you are interested in how a data type's value
    is stored and why the limits are what they are, visit the Oracle Java tutorials
    site at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html).
    Note that you do not need any more information than we have already discussed
    to continue with this book.
  prefs: []
  type: TYPE_NORMAL
- en: As we just learned, each type of data that we might want to store will require
    a specific amount of memory. So we must let the Java compiler know the type of
    the variable before we begin to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding variables are known as the **primitive** types. They use predefined
    amounts of memory and so, using our storage analogy, fit into predefined sizes
    of the storage box.
  prefs: []
  type: TYPE_NORMAL
- en: As the "primitive" label suggests, they are not as sophisticated as the reference
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that we didn't cover the `String` variable type that
    we previously used to introduce the concept of variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings are a special type of variable known as a reference type. They quite
    simply refer to a place in memory where the storage of the variable begins, but
    the reference type itself does not define a specific amount of memory. The reason
    for this is fairly straightforward: we don''t always know how much data will need
    to be stored until the program is actually run.'
  prefs: []
  type: TYPE_NORMAL
- en: We can think of strings and other reference types as continually expanding and
    contracting storage boxes. So won't one of these `String` reference types bump
    into another variable eventually? If you think about the devices memory as a huge
    warehouse full of racks of labeled storage boxes, then you can think of the Dalvik
    virtual machine as a super-efficient forklift truck driver that puts the different
    types of storage boxes in the most appropriate place.
  prefs: []
  type: TYPE_NORMAL
- en: And if it becomes necessary, the virtual machine will quickly move stuff around
    in a fraction of a second to avoid collisions. It will even incinerate unwanted
    storage boxes when appropriate. This happens at the same time as constantly unloading
    new storage boxes of all types and placing them in the best place, for that type
    of variable. Dalvik tends to keep reference variables in a part of the warehouse
    that is different from the part for the primitive variables, and we will learn
    more details about this in [Chapter 6](ch06.xhtml "Chapter 6. OOP – Using Other
    People's Hard Work"), *OOP – Using Other People's Hard Work*.
  prefs: []
  type: TYPE_NORMAL
- en: So strings can be used to store any keyboard character, like a `char` data type
    but of almost any length. Anything from a player's name to an entire book can
    be stored in a single string. We will be using strings regularly including in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple more reference types we will explore. Arrays are a way to
    store lots of variables of the same type, ready for quick and efficient access.
    We will look at arrays in [Chapter 5](ch05.xhtml "Chapter 5. Gaming and Java Essentials"),
    *Gaming and Java Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: Think of an array as an aisle in our warehouse with all the variables of a certain
    type lined up in a precise order. Arrays are reference types, so Dalvik keeps
    these in the same part of the warehouse as strings.
  prefs: []
  type: TYPE_NORMAL
- en: The other reference type is the mysterious object or class that we will look
    at in [Chapter 6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"),
    *OOP –* *Using Other People's Hard Work*.
  prefs: []
  type: TYPE_NORMAL
- en: So we know that each type of data that we might want to store will require an
    amount of memory. Hence, we must let the Java compiler know the type of the variable
    before we begin to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That's enough of theory. Let's see how we would actually use our variables and
    types. Remember that each primitive type requires a specific amount of real device
    memory. This is one of the reasons that the compiler needs to know what type a
    variable will be of. So we must first **declare** a variable and its type before
    we attempt to do anything with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a variable of type `int` with the name `score`, we would type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Simply state the type, in this case `int`, then leave a space, and
    type the name you want to use for this variable. Also note the semicolon on the
    end of the line as usual to show the compiler that we are done with this line
    and what follows, if anything, is not part of the declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For almost all the other variable types, declaration would occur in the same
    way. Here are some examples. The variable names are arbitrary. This is like reserving
    a labeled storage box in the warehouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, for each type, we initialize a value to the variable. Think about placing
    a value inside the storage box, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whether we declare and initialize separately or together is probably dependent
    upon the specific situation. The important thing is that we must do both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would cause the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There is a significant exception to this rule. Under certain circumstances variables
    can have **default values**. We will see this in [Chapter 6](ch06.xhtml "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*. But
    it is good practice to both declare and initialize variables.
  prefs: []
  type: TYPE_NORMAL
- en: Changing variables with operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Of course, in almost any program, we are going to need to do something with
    these values. Here is a list of perhaps the most common Java operators that allow
    us to manipulate variables. You do not need to memorize them as we will look at
    every line of code when we use them for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The assignment operator (=)**: This makes the variable to the left of the
    operator the same as the value to the right. For example, `hiScore = score;` or
    `score = 100;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The addition operator (+)**: This adds the values on either side of the operator.
    It is usually used in conjunction with the assignment operator, such as `score
    = aliensShot + wavesCleared;` or `score = score + 100;`. Notice that it is perfectly
    acceptable to use the same variable simultaneously on both sides of an operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The subtraction operator (-)**: This subtracts the value on the right side
    of the operator from the value on the left. It is usually used in conjunction
    with the assignment operator, such as `lives = lives - 1;` or `balance = income
    - outgoings;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The division operator (/)**: This divides the number on the left by the number
    on the right. Again, it is usually used in conjunction with the assignment operator,
    as shown in `fairShare = numSweets / numChildren;` or `recycledValueOfBlock =
    originalValue / .9;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The multiplication operator (*)**: This multiplies variables and numbers,
    such as `answer = 10 * 10;` or `biggerAnswer = 10 * 10 * 10;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The increment operator (++)**: This is a really neat way to add `1` to the
    value of a variable. The `myVariable = myVariable + 1;` statement is the same
    as `myVariable++;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The decrement operator (--)**: You guessed it: a really neat way to subtract
    `1` from something. The `myVariable = myVariable -1;` statement is the same as
    `myVariable--;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The formal names for these operators are slightly different from the names used
    here for explanation. For example, the division operator is actually one of the
    multiplicative operators. But the preceding names are far more useful for the
    purpose of learning Java and if you used the term "division operator", while conversing
    with someone from the Java community, they would know exactly what you mean.
  prefs: []
  type: TYPE_NORMAL
- en: There are actually many more operators than these in Java. We will see a whole
    bunch later in this chapter when we learn about decisions in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are curious about operators there is a complete list of them on the Java
    website at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
    All the operators required to complete the projects in this book will be fully
    explained in this book. The link is provided for the curious among us.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing yourself in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try using some declarations, assignments and operators. When we bundle
    these elements together into some meaningful syntax, we call it an expression.
    So let's write a quick app to try some out.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will make a little side project so we can play with everything we have
    learned so far. We will need to create a new project, just as we did in the previous
    chapter but we will not need a UI this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we will simply write some Java code and examine its effects by outputting
    the values of variables to the Android console, called **logcat**. We will see
    exactly how this works by building the simple project and examining the code and
    the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following is a quick reminder of how to create a new project.
  prefs: []
  type: TYPE_NORMAL
- en: Close any currently open projects by navigating to **File** | **Close Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Start a** **new Android Studio project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Create New Project** configuration window will appear. Fill in the **Application
    name** field and **Company Domain** with `packtpub.com` or you could use your
    own company website name here instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now click on the **Next** button. On the next screen, make sure the **Phone
    and Tablet** checkbox has a tick in it. Now we have to choose the earliest version
    of Android we want to build our app for. Go ahead and play with a few options
    in the drop-down selector. You will see that the earlier the version we select,
    the greater is the percentage of devices our app can support. However, the trade-off
    here is that the earlier the version we select fewer cutting-edge Android features
    will be available in our apps. A good balance is to select **API 8: Android 2.2
    (Froyo)**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next**. Now select **Blank Activity** and click on **Next** again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, simply change **Activity Name** to `MainActivity` and click
    on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we did in [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"),
    *Getting Started with Android*, to keep our code clear and simple, you can delete
    the two unneeded methods (`onCreateOptionsMenu` and `onOptionsItemSelected`) and
    their associated `@override` and `@import` statements. However, this is not necessary
    for the example to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a detailed explanation and images of creating a new project, see [Chapter
    2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting Started with
    Android*.
  prefs: []
  type: TYPE_NORMAL
- en: As with all the examples and projects in this book, you can copy or review the
    code from the download bundle. You will find the code for this tutorial in the
    `Chapter3/ExpressionsInJava/MainActivity.java` file. Just create the project as
    described previously and paste the code from `MainActivity.java` file from the
    download bundle to the `MainActivity.java` file that was generated when you created
    the project in Android Studio. Just ensure that the package name is the same as
    the one you chose when the project was created. However, I strongly recommend
    going along with the tutorial so that we can learn how to do everything for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As this app uses the logcat console to show its output, you should run this
    app on the emulator only and not on a real Android device. The app will not harm
    a real device, but you just won't be able to see anything happening.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new blank project called `Expressions In Java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in the `onCreate` method just after the line where we use the `setContentView`
    method, add this code to declare and initialize some variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the following code. This code simply outputs the value of our variables
    in a form where we can closely examine them in a minute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s change our variables using the addition operator and another new
    operator. See if you can work out the output values for variables `a`, `b`, and
    `c` before looking at the output and the code explanation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s output the values once more in the same way we did in step 3, but this
    time, the output should be different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Run the program on an emulator in the usual way. You can see the output by clicking
    on the **Android** tab from our "useful tabs" area below the Project Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the output, with some of the unnecessary formatting stripped off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s discuss what happened. In step 2, we declared and initialized three
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a`: This is an int that holds the value 10'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: This is a string that holds the name of an eminent computer scientist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c`: This is a Boolean that holds the value false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So when we output the values in step 3, it should be no surprise that we get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 4, all the fun stuff happens. We add 1 to the value of our int `a`
    using the increment operator like this: `a++;`. Remember that `a++` is the same
    as `a = a + 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add 10 to `a`. Note we are adding 10 to `a` after having already added
    1\. So we get this output for a 10 + 1 + 10 operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now let's examine our string, `b`. We appear to be using the addition operator
    on our eminent scientist. What is happening is what you could probably guess.
    We are adding together two strings `"Alan Turing"` and `"was smarter than the
    average bear Booboo."` When you add two strings together it is called **concatenating**
    and the `+` symbol doubles as the concatenation operator.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for our string, we appear to be adding `int a` to it. This is allowed
    and the value of `a` is concatenated to the end of `b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This does not work the other way round; you cannot add a string to an `int`.
    This makes sense as there is no logical answer.
  prefs: []
  type: TYPE_NORMAL
- en: '`a = a + b`'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expressing yourself in Java](img/8859OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, let''s look at the code that changes our Boolean, `c`, from true to
    false: `c = (1+1=3);`. Here, we are assigning to `c` the value of the expression
    contained within the brackets. This would be straightforward, but why the double
    equals (`==`)? We have jumped ahead of ourselves a little. The double equals sign
    is another operator called the **comparison** operator.'
  prefs: []
  type: TYPE_NORMAL
- en: So we are really asking, *does* 1+1 equal 3? Clearly the answer is false. You
    might ask, "why use `==` instead of `=`?" Simply to make it clear to the compiler
    when we mean to assign and when we mean to compare.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inadvertently using `=` instead of `==` is a very common error.
  prefs: []
  type: TYPE_NORMAL
- en: The assignment operator (`=`) assigns the value on the right to the value on
    the left, while the comparison operator (`==`) compares the values on either side.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will warn us with an error when we do this but at first glance
    you might swear the compiler is wrong. We will learn more on this comparison operator
    and others later in the chapter and throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's use everything we know and a bit more to make our math game project.
  prefs: []
  type: TYPE_NORMAL
