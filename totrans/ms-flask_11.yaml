- en: Chapter 11. Building Your Own Extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the first chapter of this book, we have been adding Flask extensions to
    our app in order to add new features and save us from spending lots of time to
    reinvent the wheel. Up to this point, it was unknown how these Flask extensions
    worked. In this chapter, we will create two simple Flask extensions in order to
    better understand Flask's internals and allow you to extend Flask with your own
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a YouTube Flask extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, the first extension we are going to create is a simple extension
    that allows embedding YouTube videos in Jinja templates with the following tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `video_id` object is the code after the `v` in any YouTube URL. For example,
    in the URL [https://www.youtube.com/watch?v=_OBlgSz8sSM](https://www.youtube.com/watch?v=_OBlgSz8sSM),
    the `video_id` object would be `_OBlgSz8sSM`.
  prefs: []
  type: TYPE_NORMAL
- en: For now, the code for this extension will reside in `extensions.py`. However,
    this is only for development and debugging purposes. When the code is ready to
    be shared, it will be moved into its own project directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that any Flask extension needs is the object that will be initialized
    on the app. This object will handle adding its `Blueprint` object to the app and
    registering the `youtube` function on Jinja:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the only thing this code does is initialize an empty blueprint on the
    `app` object. The next piece of code needed is a representation of a video. The
    following will be a class that will handle the parameters from the Jinja function
    and render HTML to display in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This object will be created from the `youtube` function in the template, and
    any arguments passed in the template will be given to this object to render HTML.
    There is also a new object in this code, `Markup`, which we never used before.
    The `Markup` class is Flask's way of automatically escaping HTML or marking it
    as safe to include in the template. If we just returned HTML, Jinja would autoescape
    it because it does not know whether it is safe or not. This is Flask's way of
    protecting your site from **cross-site scripting attacks**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the function that will be registered in Jinja:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `YouTube` class, we have to register the function to Jinja in the `init_app`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to create HTML that will add the video to the page. In a new
    folder named `youtube` in the `templates` directory, create a new HTML file named
    `video.html` and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all the code that''s needed to embed YouTube videos in your templates.
    Let''s test this out now. In `extensions.py`, initialize the `Youtube` class below
    the `Youtube` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In `__init__.py`, import the `youtube_ext` variable and use the `init_app`
    method we created to register it on the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as a simple example, add the `youtube` function to the top of the blog
    home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will have the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a YouTube Flask extension](img/B03929_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Python package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to make our new Flask extension available to others, we have to create
    an installable Python package from the code we have written so far. To begin,
    we need a new project directory outside our current application directory. We
    will need two things: a `setup.py` file, which we will fill in later, and a folder
    named `flask_youtube`. In the `flask_youtube` directory, we will have an `__init__.py`
    file, which will contain all the code that we wrote for our extension.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the final version of that code contained in the `__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Also inside the `flask_youtube` directory, we will need a `templates` directory,
    which will hold the `youtube` directory that we put in our app's `templates` directory.
  prefs: []
  type: TYPE_NORMAL
- en: In order to turn this code into a Python package, we will use the library named
    `setuptools`. `setuptools` is a Python package that allows developers to easily
    create installable packages for their code. `setuptools` will bundle code so that
    `pip` and `easy_install` can automatically install them, and will even upload
    your package to the **Python Package Index** (**PyPI**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the packages that we have been installing from `pip` have come from PyPI.
    To see all the available packages, go to [https://pypi.python.org/pypi](https://pypi.python.org/pypi).
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is needed to get this functionality is to fill out the `setup.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `setup` function from `setuptools` to find your source code
    and make sure that the machine that is installing your code has the required packages.
    Most of the attributes are rather self-explanatory, except the package attribute,
    which uses the `find_packages` function from `setuptools`. What the `package`
    attribute does is it finds which parts of our source code are part of the package
    to be released. We use the `find_packages` method to automatically find which
    parts of the code to include. This is based on some sane defaults, such as looking
    for directories with `__init__.py` files and excluding common file extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is not mandatory, this setup also contains metadata about the author
    and the license, which would be included on the PyPI page if we were to upload
    this there. There is a lot more customization available in the `setup` function,
    so I encourage you to read the documentation at [http://pythonhosted.org/setuptools/](http://pythonhosted.org/setuptools/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now install this package on your machine by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install your code into your Python `packages` directory, or if you''re
    using `virtualenv`, it will install it to the local `packages` directory. Then,
    you can import your place on package via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the response with Flask extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we have created an extension that adds new functionality to our templates.
    But how would we create an extension which modifies the behavior of our app at
    the request level? To demonstrate this, let's create an extension that modifies
    all the responses from Flask by compressing the contents of the response. This
    is a common practice in web development in order to speed up page load times,
    as compressing objects with a method like **gzip** is very fast and relatively
    cheap CPU-wise. Normally, this would be handled at the server level. So, unless
    you wish to host your app with only Python code, which is possible and will be
    covered in [Chapter 13](ch13.html "Chapter 13. Deploying Flask Apps"), *Deploying
    Flask Apps*, this extension really doesn't have much use in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we will use the `gzip` module in the Python standard library
    to compress the contents after each request is processed. We will also have to
    add special HTTP headers into the response in order for the browser to know that
    the content is compressed. We will also need to check in the HTTP request headers
    whether the browser can accept gzipped contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as before, our content will initially reside in the `extensions.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Just as with the previous extension, our initializer for the compress object
    accommodates both the normal Flask setup and the application factory setup. In
    the `after_request` method, instead of registering a blueprint, we register a
    new function on the after-request event so that our extension can compress the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: The `after_request` method is where the real logic of the extension comes into
    play. First, it checks whether the browser accepts gzip encoding by looking at
    the `Accept-Encoding` value in the request header. If the browser does not accept
    gzip, or did not return a successful response, the function just returns the contents
    and makes no modifications to it. However, if the browser does accept our content
    and the response was successful, then we will compress the content. We use another
    standard library class named `BytesIO`, which allows file streams to be written
    and stored in memory, and not in an intermediate file. This is necessary because
    the `GzipFile` object expects to write to a file object.
  prefs: []
  type: TYPE_NORMAL
- en: After the data is compressed, we set the response objects' data to the results
    of the compression and set the necessary HTTP header values in the response as
    well. Finally, the gzip contents are returned to the browser, and the browser
    then decompresses the contents, significantly speeding up the page load times.
  prefs: []
  type: TYPE_NORMAL
- en: In order to test the functionality in your browser, you have to disable **Flask
    Debug Toolbar**, because at the time of writing there is a bug in its code where
    it expects all responses to be encoded in UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: If you reload the page nothing should look different. However, if you use the
    developer tools in the browser of your choice and inspect the responses, you will
    see that they are compressed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we went through two different examples of different types of Flask
    extensions, you should have a very clear understanding of how most of the Flask
    extensions that we used work. Using the knowledge that you have now, you should
    be able to add any extra functionality to Flask that you need for your specific
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at how to add testing to our application
    to take out the guesswork of whether changes we made to the code have broken any
    of the functionality of our application.
  prefs: []
  type: TYPE_NORMAL
