- en: Containers
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning from development to production has always been a painful process.
    It involves a lot of documentation, hand-offs, installation, and configuration.
    Since every programming language produces software that behaves slightly differently,
    the deployment of heterogenous applications is always difficult.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Some of these problems have been mitigated by containers. With containers, the
    installation and configuration is mostly standardized. There are several ways
    for how to deal with distribution, but this issue also has some standards to follow.
    This makes containers a great choice for organizations that want to increase the
    cooperation between development and operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Building containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and integrating containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding container orchestration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The examples listed in this chapter require the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Docker 20.10
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: manifest-tool ([https://github.com/estesp/manifest-tool](https://github.com/estesp/manifest-tool))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buildah 1.16
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.10
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ansible-bender
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.15
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code present in the chapter has been placed on GitHub at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter14](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter14).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Reintroducing containers
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are making a lot of buzz recently. One might think they are a brand
    new technology that was not available before. However, that is not the case. Before
    the rise of Docker and Kubernetes, the dominating players in the industry at the
    moment, there were already solutions such as LXC, which offered a lot of similar
    features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: We can trace the origins of separating one execution environment from another
    with the chroot mechanism available in UNIX systems since 1979\. Similar concepts
    were also used in FreeBSD jails and Solaris Zones.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The main task of the container is to isolate one execution environment from
    another. This isolated environment can have its own configuration, different applications,
    and even different user accounts than the host environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Even though the containers are isolated from the host, they usually share the
    same operating system kernel. This is the main differentiator from virtualized
    environments. Virtual machines have dedicated virtual resources, which means they
    are separated at the hardware level. Containers are separated at the process level,
    which means there is less overhead to run them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to package and run another operating system that is already optimized
    and configured for running your application is a strong advantage of containers.
    Without containers, the build and deploy process usually consists of several steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The application is built.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The example configuration files are provided.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installation scripts and associated documentation is prepared.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application is packaged for a target operating system (such as Debian or
    Red Hat).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The packages are deployed to the target platform.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installation scripts prepare the basis for the application to run.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration has to be tweaked to fit the existing system.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you switch to containers, there is less of a need for a robust installation
    script. The application will only target a single well-known operating system
    – the one present in the container. The same goes for configuration: instead of
    preparing many configurable options, the application is pre-configured for the
    target operating system and distributed alongside it. The deployment process consists
    only of unpacking the container image and running the application process inside
    it.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: While containers and microservices are often thought to be the same thing, they
    are not. Moreover, containers may mean application containers or operating system
    containers, and only application containers fit well with microservices. The following
    sections will tell you why. We'll describe the different container types that
    you can encounter, show you how they relate to microservices, and explain when
    it's best to use them (and when to avoid them).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然容器和微服务经常被认为是同一件事，但它们并不是。此外，容器可能意味着应用容器或操作系统容器，只有应用容器与微服务配合得很好。接下来的章节将告诉您原因。我们将描述您可能遇到的不同容器类型，向您展示它们与微服务的关系，并解释何时最好使用它们（以及何时避免使用它们）。
- en: Exploring the container types
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索容器类型
- en: Of the containers described so far, operating system containers are fundamentally
    different from the current container trend led by Docker, Kubernetes, and LXD.
    Instead of focusing on recreating an entire operating system with services such
    as syslog and cron, application containers focus on running a single process within
    a container – just the application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止描述的容器中，操作系统容器与由Docker、Kubernetes和LXD领导的当前容器趋势有根本的不同。应用容器专注于在容器内运行单个进程-即应用程序，而不是专注于重新创建具有诸如syslog和cron等服务的整个操作系统。
- en: Proprietary solutions replace all the usual OS-level services. These solutions
    provide a unified way to manage the applications within a container. For example,
    instead of using syslog to handle logs, the standard output of the process with
    PID 1 is considered as application logs. Instead of using a mechanism such as
    `init.d` or systemd, the application container's lifecycle is handled by the runtime
    application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 专有解决方案替换了所有通常的操作系统级服务。这些解决方案提供了一种统一的方式来管理容器内的应用程序。例如，不使用syslog来处理日志，而是将PID 1的进程的标准输出视为应用程序日志。不使用`init.d`或systemd等机制，而是由运行时应用程序处理应用容器的生命周期。
- en: Since Docker is at the moment the dominant solution for application containers,
    we will mostly use it as an example throughout this book. To make the picture
    complete, we will present viable alternatives, as they may be better suited to
    your needs. Since the project and specification are open source, these alternatives
    are compatible with Docker and can be used as replacements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker目前是应用容器的主要解决方案，我们将在本书中大多数情况下使用它作为示例。为了使画面完整，我们将提出可行的替代方案，因为它们可能更适合您的需求。由于项目和规范是开源的，这些替代方案与Docker兼容，并且可以用作替代品。
- en: Later in this chapter, we will explain how to use Docker to build, deploy, run,
    and manage application containers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将解释如何使用Docker来构建、部署、运行和管理应用容器。
- en: The rise of microservices
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务的兴起
- en: The success of Docker coincided with the rise of the adoption of microservices.
    It is no surprise since microservices and application containers fit together
    naturally.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的成功与微服务的采用增长同时出现并不奇怪，因为微服务和应用容器自然地结合在一起。
- en: Without application containers, there was no easy and unified way to package,
    deploy, and maintain microservices. Even though individual companies developed
    some solutions to fix these problems, none was popular enough to approach being
    an industry standard.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 没有应用容器，没有一种简单而统一的方式来打包、部署和维护微服务。尽管一些公司开发了一些解决这些问题的解决方案，但没有一种解决方案足够流行，可以成为行业标准。
- en: Without microservices, the application containers were pretty limited. The software
    architecture focused on building entire systems explicitly configured for the
    given set of services running there. Replacing one service with another required
    a change of the architecture.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 没有微服务，应用容器的功能相当有限。软件架构专注于构建专门为给定的服务集合明确配置的整个系统。用另一个服务替换一个服务需要改变架构。
- en: When brought together, application containers provide a standard way for the
    distribution of microservices. Each microserver comes with its own configuration
    embedded, so operations such as autoscaling or self-healing no longer require
    knowledge about an underlying application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应用容器提供了一种标准的分发微服务的方式。每个微服务都带有其自己的嵌入式配置，因此诸如自动扩展或自愈等操作不再需要了解底层应用程序。
- en: You can still use microservices without application containers and you can use
    application containers without hosting microservices in them. For instance, even
    though neither PostgreSQL databases nor Nginx web servers were designed as microservices,
    they are typically used in application containers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以在没有应用容器的情况下使用微服务，也可以在应用容器中托管微服务。例如，尽管PostgreSQL数据库和Nginx Web服务器都不是设计为微服务，但它们通常在应用容器中使用。
- en: Choosing when to use containers
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择何时使用容器
- en: There are several benefits to the container approach. OS containers and application
    containers also have some different use cases in which their strengths lie.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 容器方法有几个好处。操作系统容器和应用容器在其优势所在的一些不同用例中也有所不同。
- en: The benefits of containers
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器的好处
- en: When compared to virtual machines, the other popular way of isolating environments,
    containers require less overhead during runtime. Unlike virtual machines, there
    is no need to run a separate version of an operating system kernel and use the
    hardware or software virtualization techniques. Application containers also do
    not run other operating system services that are typically found in virtual machines
    such as syslog, cron, or init. Additionally, application containers offer smaller
    images as they do not usually have to carry an entire operating system copy. In
    extreme examples, an application container can consist of a single statically
    linked binary.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与隔离环境的另一种流行方式虚拟机相比，容器在运行时需要更少的开销。与虚拟机不同，不需要运行一个单独的操作系统内核版本，并使用硬件或软件虚拟化技术。应用容器也不运行通常在虚拟机中找到的其他操作系统服务，如syslog、cron或init。此外，应用容器提供更小的镜像，因为它们通常不必携带整个操作系统副本。在极端情况下，应用容器可以由单个静态链接的二进制文件组成。
- en: At this point, you may wonder why to bother with containers at all if there
    is just a single binary inside? There is one particular benefit of having a unified
    and standardized way to build and run containers. As containers have to follow
    specific conventions, it is easier to orchestrate them than regular binaries,
    which can have different expectations regarding logging, configuration, opening
    ports, and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Another thing is that containers provide a built-in means of isolation. Each
    container has its own namespace for processes and a namespace for user accounts,
    among others. This means that the process (or processes) from one container has
    no notion of the processes on the host or in the other containers. The sandboxing
    can go even further as you can assign memory and a CPU quota to your containers
    with the same standard user interface (whether it is Docker, Kubernetes, or something
    else).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The standardized runtime also means higher portability. Once a container is
    built, you can typically run it on different operating systems without modifications.
    This also means what runs in operations is very close or identical to what runs
    in development. Issue reproduction is more effortless and so is debugging.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantages of containers
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since there is a lot of pressure nowadays to move workloads to containers, you
    want to understand all the risks associated with such migration as an architect.
    The benefits are touted everywhere and you probably already understand them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The main obstacle to container adoption is that not all applications can be
    easily migrated to containers. This is especially true of application containers
    that are designed with microservices in mind. If your application is not based
    on microservices architecture, putting it into containers may introduce more problems
    than it will solve.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: If your application already scales well, uses TCP/IP-based IPC, and is mostly
    stateless, the move to containers should not be challenging. Otherwise, each of
    these aspects would pose a challenge and prompt a rethink of the existing design.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Another problem associated with containers is persistent storage. Ideally, containers
    should have no persistent storage of their own. This makes it possible to take
    advantage of fast startups, easy scaling, and flexible scheduling. The problem
    is that applications providing business value cannot exist without persistent
    storage.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: This drawback is usually mitigated by making most containers stateless and relying
    on an external non-containerized component to store the data and the state. Such
    an external component can be either a traditional self-hosted database or a managed
    database from a cloud provider. Going in either direction requires you to reconsider
    the architecture and modify it accordingly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Since application containers follow specific conventions, the application has
    to be modified to follow these conventions. For some applications, it will be
    a low-effort task. For others, such as multiprocess components using in-memory
    **Inter-Process Communication** (**IPC**), it will be complicated.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: One point often omitted is that application containers work great as long as
    the applications inside them are native Linux applications. While Windows containers
    are supported, they are neither convenient nor as supported as their Linux counterparts.
    They also require licensed Windows machines running as hosts.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: It is easier to enjoy the application containers' benefits if you are building
    a new application from scratch and can base your design on this technology. Moving
    an existing application to application containers, especially if it is complicated,
    will require a lot more work and possibly also a revamp of the entire architecture.
    In such a case, we advise you to consider all the benefits and disadvantages extra
    carefully. Making a wrong decision may harm your product's lead time, availability,
    and budget.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Building containers
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application containers are the focus of this section. While OS containers mostly
    follow system programming principles, application containers bring new challenges
    and patterns. Also, they provide specialized build tools to deal with those challenges.
    The primary tool we will consider is Docker, as it's the current de facto standard
    for building and running application containers. We will also present some alternative
    approaches to building application containers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序容器是本节的重点。虽然操作系统容器大多遵循系统编程原则，但应用程序容器带来了新的挑战和模式。它们还提供了专门的构建工具来处理这些挑战。我们将考虑的主要工具是Docker，因为它是当前构建和运行应用程序容器的事实标准。我们还将介绍一些构建应用程序容器的替代方法。
- en: Unless otherwise noted, whenever we use the word "containers" from now on, it
    relates to "application containers."
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，从现在开始，当我们使用“容器”这个词时，它指的是“应用程序容器”。
- en: In this section, we will focus on different approaches to using Docker for building
    and deploying containers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将专注于使用Docker构建和部署容器的不同方法。
- en: Container images explained
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释容器镜像
- en: Before we describe container images and how to build them, it is vital to understand
    the distinction between containers and container images. There is often confusion
    between the terms, especially during informal conversations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述容器镜像及如何构建它们之前，了解容器和容器镜像之间的区别至关重要。这两个术语经常会引起混淆，尤其是在非正式的对话中。
- en: The difference between a container and a container image is the same as between
    a running process and an executable file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和容器镜像之间的区别与运行中的进程和可执行文件之间的区别相同。
- en: '**Container images are static**: They''re snapshots of a particular filesystem
    and associated metadata. The metadata describes, among other things, what environmental
    variables are set during runtime or which program to run when the container is
    created from the image.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器镜像是静态的**：它们是特定文件系统的快照和相关的元数据。元数据描述了在运行时设置了哪些环境变量，或者在创建容器时运行哪个程序，等等。'
- en: '**Containers are dynamic**: They are running a process contained within the
    container image. We can create containers from the container images and we can
    also create container images by snapshotting a running container. The container
    image build process consists, in fact, of creating several containers, executing
    commands inside them, and snapshotting them after the command finishes.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器是动态的**：它们运行在容器镜像内的一个进程。我们可以从容器镜像创建容器，也可以通过对运行中的容器进行快照来创建容器镜像。事实上，容器镜像构建过程包括创建多个容器，执行其中的命令，并在命令完成后对它们进行快照。'
- en: To distinguish between the data introduced by the container image and the data
    generated during runtime, Docker uses union mount filesystems to create different
    filesystem layers. These layers are also present in the container images. Typically,
    each build step of the container image corresponds to a new layer in the resulting
    container image.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分容器镜像引入的数据和运行时生成的数据，Docker使用联合挂载文件系统来创建不同的文件系统层。这些层也存在于容器镜像中。通常，容器镜像的每个构建步骤对应于结果容器镜像中的一个新层。
- en: Using Dockerfiles to build an application
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Dockerfiles构建应用程序
- en: The most common way to build an application container image using Docker is
    to use a Dockerfile. Dockerfile is an imperative language describing the operations
    required to produce the resulting image. Some of the operations create new filesystem
    layers; others operate on metadata.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker构建应用程序容器镜像的最常见方法是使用Dockerfile。Dockerfile是一种描述生成结果镜像所需操作的命令式语言。一些操作会创建新的文件系统层，而其他操作则会操作元数据。
- en: We will not go into details and specifics related to Dockerfiles. Instead, we
    will show different approaches to containerizing a C++ application. For this,
    we need to introduce some syntax and concepts related to Dockerfiles.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍和具体涉及Dockerfiles。相反，我们将展示不同的方法来将C++应用程序容器化。为此，我们需要介绍一些与Dockerfiles相关的语法和概念。
- en: 'Here is an example of a very simple Dockerfile:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的Dockerfile的示例：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Typically, we can divide a Dockerfile into three parts:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以将Dockerfile分为三个部分：
- en: Importing the base image (the `FROM` instruction)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入基本镜像（`FROM`指令）
- en: Performing operations within the container that will result in a container image
    (the `RUN` instruction)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内执行操作，将导致容器镜像（`RUN`指令）
- en: Metadata used during runtime (the `CMD` command)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时使用的元数据（`CMD`命令）
- en: 'The latter two parts may well be interleaved, and each of them may comprise
    one or more instructions. It is also possible to omit any of the later parts as
    only the base image is mandatory. This does not mean you cannot start with an
    empty filesystem. There is a special base image named `scratch` exactly for this
    purpose. Adding a single statically linked binary to an otherwise empty filesystem
    could look like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 后两部分可能会交错进行，每个部分可能包含一个或多个指令。也可以省略任何后续部分，因为只有基本镜像是必需的。这并不意味着你不能从空文件系统开始。有一个名为`scratch`的特殊基本镜像就是为了这个目的。在否则空的文件系统中添加一个单独的静态链接二进制文件可能看起来像下面这样：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the first Dockerfile, the steps we take are the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个Dockerfile中，我们采取的步骤如下：
- en: Import the base Ubuntu Bionic image.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入基本的Ubuntu Bionic镜像。
- en: Run a command inside the container. The results of the command will create a
    new filesystem layer inside the target image. This means the packages installed
    with `apt-get` will be available in all the containers based on this image.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内运行命令。命令的结果将在目标镜像内创建一个新的文件系统层。这意味着使用`apt-get`安装的软件包将在所有基于此镜像的容器中可用。
- en: Set the runtime metadata. When creating a container based on this image, we
    want to run `GCC` as the default process.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置运行时元数据。在基于此镜像创建容器时，我们希望将`GCC`作为默认进程运行。
- en: To build an image from a Dockerfile, you will use the `docker build` command.
    It takes one required argument, the directory containing the build context, which
    means the Dockerfile itself and other files you want to copy inside the container.
    To build a Dockerfile from a current directory, use `docker build`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: This will build an anonymous image, which is not very useful. Most of the time,
    you want to use named images. There is a convention to follow when naming container
    images and that's what we'll cover in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Naming and distributing images
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each container image in Docker has a distinctive name consisting of three elements:
    the name of the registry, the name of the image, a tag. Container registries are
    object repositories holding container images. The default container registry for
    Docker is `docker.io`. When pulling an image from this registry, we may omit the
    registry name.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Our previous example with `ubuntu:bionic` has the full name of `docker.io/ubuntu:bionic`.
    In this example, `ubuntu` is the name of the image, while `bionic` is a tag that
    represents a particular version of an image.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'When building an application based on containers, you will be interested in
    storing all the registry images. It is possible to host your private registry
    and keep your images there or use a managed solution. Popular managed solutions
    include the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: quay.io
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud providers (such as AWS, GCP, or Azure)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Hub is still the most popular one, though some public images are migrating
    to quay.io. Both are general-purpose and allow the storage of public and private
    images. GitHub or cloud providers will be mainly attractive to you if you are
    already using a particular platform and want to keep your images close to the
    CI pipeline or the deployment targets. It is also helpful if you want to reduce
    the number of individual services you use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: If none of the solutions appeal to you, hosting your own local registry is also
    very easy and requires you to run a single container.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: To build a named image, you need to pass the `-t` argument to the `docker build`
    command. For example, to build an image named `dominicanfair/merchant:v2.0.3`,
    you will use `docker build -t dominicanfair/merchant:v2.0.3 .`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Compiled applications and containers
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When building container images for applications in interpreted languages (such
    as Python or JavaScript), the approach is mostly the same:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Install dependencies.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy source files to the container image.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the necessary configuration.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the runtime command.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For compiled applications, however, there's an additional step of compiling
    the application first. There are several possible ways to implement this step,
    each of them with their pros and cons.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'The most obvious approach is to install all the dependencies first, copy the
    source files, and then compile the application as one of the container build steps.
    The major benefit is that we can accurately control the toolchain''s contents
    and configuration and therefore have a portable way to build an application. However,
    the downside is too big to ignore: the resulting container image contains a lot
    of unnecessary files. After all, we will need neither source code nor the toolchain
    during runtime. Due to the way overlay filesystems work, it is impossible to remove
    the files after being introduced in a previous layer. What is more, the source
    code in the container may prove to be a security risk if an attacker manages to
    break into the container.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it can look:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another obvious approach, and the one we discussed earlier, is building the
    application on the host machine and only copying the resulting binaries inside
    the container image. This requires fewer changes to the current build process
    when one is already established. The main drawback is that you have to match the
    same set of libraries on your build machines as you do in your containers. If
    you're running, for example, Ubuntu 20.04 as your host operating system, your
    containers will have to be based on Ubuntu 20.04 as well. Otherwise, you risk
    incompatibilities. With this approach, it is also necessary to configure the toolchain
    independently of the container.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A slightly more complicated approach is to have a multi-stage build. With multi-stage
    builds, one stage may be dedicated to setting up the toolchain and compiling the
    project, while another stage copies the resulting binaries to their target container
    image. This has several benefits over the previous solutions. First of all, the
    Dockerfiles now control both the toolchain and the runtime environment, so every
    step of the build is thoroughly documented. Second of all, it is possible to use
    the image with the toolchain to ensure compatibility between development and the
    **Continuous Integration**/**Continuous Deployment** (**CI/CD**) pipeline. This
    way also makes it easier to distribute upgrades and fixes to the toolchain itself.
    The major downside is that the containerized toolchain may not be as comfortable
    to use as a native one. Also, build tools are not particularly well-suited to
    application containers, which require that there's one process running per container.
    This may lead to unexpected behavior whenever some of the processes crash or are
    forcefully stopped.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'A multi-stage version of the preceding example would look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first stage, starting at the first `FROM` command sets up the builder, adds
    the sources, and builds the binaries. Then, the second stage, starting at the
    second `FROM` command, copies the resulting binary from the previous stage without
    copying the toolchain or the sources.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Targeting multiple architectures with manifests
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Application containers with Docker are typically used on x86_64 (also known
    as AMD64) machines. If you are only targeting this platform, you have nothing
    to worry about. However, if you are developing IoT, embedded, or edge applications,
    you may be interested in multi-architecture images.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Since Docker is available on many different CPU architectures, there are several
    ways to approach image management on multiple platforms.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: One way to handle images built for different targets is by using the image tags
    to describe a particular platform. Instead of `merchant:v2.0.3`, we could have
    `merchant:v2.0.3-aarch64`. Although this approach may seem to be the easiest to
    implement, it is, in fact, a bit problematic.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Not only do you have to change the build process to include the architecture
    in the tagging process. When pulling the images to run them, you will also have
    to take care to manually append the expected suffix everywhere. If you are using
    an orchestrator, you won't be able to share the manifests between the different
    platforms in a straightforward way, as the tags will be platform-specific.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: A better way that doesn't require modifying the deployment step is to use `manifest-tool`
    ([https://github.com/estesp/manifest-tool](https://github.com/estesp/manifest-tool)).
    The build process at first looks similar to the one suggested previously. Images
    are built separately on all the supported architectures and pushed to the registry
    with a platform suffix in their tags. After all the images are pushed, `manifest-tool`
    merges the images to provide a single multi-architecture one. This way, each supported
    platform is able to use the exact same tag.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'An example configuration for `manifest-tool` is provided here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we have three supported platforms, each with their respective suffix (`hosacpp/merchant:v2.0.3-amd64`,
    `hosacpp/merchant:v2.0.3-arm32`, and `hosacpp/merchant:v2.0.3-arm64`). `Manifest-tool`
    combines the images built for each platform and produces a `hosacpp/merchant:v2.0.3`
    image that we can use everywhere.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有三个支持的平台，每个平台都有其相应的后缀（`hosacpp/merchant:v2.0.3-amd64`，`hosacpp/merchant:v2.0.3-arm32`和`hosacpp/merchant:v2.0.3-arm64`）。`Manifest-tool`将为每个平台构建的镜像合并，并生成一个`hosacpp/merchant:v2.0.3`镜像，我们可以在任何地方使用。
- en: Another possibility is to use Docker's built-in feature called Buildx. With
    Buildx, you can attach several builder instances, each of which targets a required
    architecture. What's interesting is that you don't need to have native machines
    to run the builds; you can also use the QEMU emulation or cross-compilation in
    a multi-stage build. Although it is much more powerful than the previous approach,
    Buildx is also quite complicated. At the time of writing, it requires Docker experimental
    mode and Linux kernel 4.8 or later. It requires you to set up and manage builders
    and not everything behaves in an intuitive way. It's possible it will improve
    and become more stable in the near future.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是使用Docker内置的名为Buildx的功能。使用Buildx，你可以附加多个构建器实例，每个实例针对所需的架构。有趣的是，你不需要本机机器来运行构建；你还可以在多阶段构建中使用QEMU模拟或交叉编译。尽管它比之前的方法更强大，但Buildx也相当复杂。在撰写本文时，它需要Docker实验模式和Linux内核4.8或更高版本。你需要设置和管理构建器，并且并非所有功能都以直观的方式运行。它可能会在不久的将来改进并变得更加稳定。
- en: 'An example code to prepare the build environment and build a multi-platform
    image may look like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 准备构建环境并构建多平台镜像的示例代码可能如下所示：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, this may be a little confusing if you're used to the regular
    `docker build` command.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，如果你习惯于常规的`docker build`命令，这可能会有点令人困惑。
- en: Alternative ways to build application containers
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建应用程序容器的替代方法
- en: Building container images with Docker requires the Docker daemon to be running.
    The Docker daemon requires root privileges, which may pose security problems in
    some setups. Even though the Docker client that does the building may be run by
    an unprivileged user, it is not always feasible to install the Docker daemon in
    the build environment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker构建容器镜像需要Docker守护程序运行。Docker守护程序需要root权限，在某些设置中可能会带来安全问题。即使进行构建的Docker客户端可能由非特权用户运行，但在构建环境中安装Docker守护程序并非总是可行。
- en: Buildah
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Buildah
- en: 'Buildah is an alternative tool to build container images that can be configured
    to run without root access. Buildah can work with regular Dockerfiles, which we
    discussed earlier. It also presents its own command-line interface that you can
    use in shell scripts or other automation you find more intuitive. One of the previous
    Dockerfiles rewritten as a shell script using the buildah interface will look
    like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Buildah是一个替代工具，可以配置为在没有root访问权限的情况下运行。Buildah可以使用常规的Dockerfile，我们之前讨论过。它还提供了自己的命令行界面，你可以在shell脚本或其他更直观的自动化中使用。将之前的Dockerfile重写为使用buildah接口的shell脚本之一将如下所示：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One interesting feature of Buildah is that it allows you to mount the container
    image filesystem into your host filesystem. This way, you can use your host's
    commands to interact with the contents of the image. If you have software you
    don't want (or can't due to licensing restrictions) put within the container,
    it's still possible to invoke it outside of the container when using Buildah.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Buildah的一个有趣特性是它允许你将容器镜像文件系统挂载到主机文件系统中。这样，你可以使用主机的命令与镜像的内容进行交互。如果你有一些不想（或者由于许可限制而无法）放入容器中的软件，使用Buildah时仍然可以在容器外部调用它。
- en: Ansible-bender
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ansible-bender
- en: 'Ansible-bender uses Ansible playbooks and Buildah to build container images.
    All of the configuration, including base images and metadata, is passed as a variable
    within the playbook. Here is our previous example converted to Ansible syntax:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible-bender使用Ansible playbooks和Buildah来构建容器镜像。所有配置，包括基本镜像和元数据，都作为playbook中的变量传递。以下是我们之前的示例转换为Ansible语法的示例：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you see, the `ansible_bender` variable is responsible for all the configuration
    specific to containers. The tasks presented below are executed inside the container
    based on `base_image`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`ansible_bender`变量负责所有与容器特定配置相关的内容。下面呈现的任务在基于`base_image`的容器内执行。
- en: One thing to note is that Ansible requires a Python interpreter present in the
    base image. This is why we had to change `ubuntu:bionic` used in previous examples
    to `python:3-buster`. `ubuntu:bionic` is an Ubuntu image without a Python interpreter
    preinstalled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，Ansible需要基本镜像中存在Python解释器。这就是为什么我们不得不将在之前的示例中使用的`ubuntu:bionic`更改为`python:3-buster`。`ubuntu:bionic`是一个没有预安装Python解释器的Ubuntu镜像。
- en: Others
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他
- en: There are also other ways to build container images. You can use Nix to create
    a filesystem image and then put it inside the image using Dockerfile's `COPY`
    instruction, for example. Going further, you can prepare a filesystem image by
    any other means and then import it as a base container image using `docker import`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他构建容器镜像的方法。你可以使用Nix创建文件系统镜像，然后使用Dockerfile的`COPY`指令将其放入镜像中，例如。更进一步，你可以通过任何其他方式准备文件系统镜像，然后使用`docker
    import`将其导入为基本容器镜像。
- en: Choose whichever solution fits your particular needs. Keep in mind that building
    with a Dockerfile using `docker build` is the most popular approach and hence
    it is the best-documented one and the best supported. Going with Buildah is more
    flexible and allows you to better fit creating container images into your build
    process. Finally, `ansible-bender` may be a good solution if you're already heavily
    invested in Ansible and you want to reuse already available modules.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 选择符合你特定需求的解决方案。请记住，使用`docker build`使用Dockerfile进行构建是最流行的方法，因此它是最有文档支持的。使用Buildah更加灵活，可以更好地将创建容器镜像融入到构建过程中。最后，如果你已经在Ansible中投入了大量精力，并且想要重用已有的模块，`ansible-bender`可能是一个不错的解决方案。
- en: Integrating containers with CMake
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将容器与CMake集成
- en: In this section, we'll demonstrate how to create a Docker image by working with
    CMake.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Dockerfile with CMake
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, and foremost, we''ll need a Dockerfile. Let''s use yet another CMake
    input file for this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we're using `PROJECT_BINARY_DIR` to not overwrite any Dockerfiles
    created by other projects in the source tree if our project is part of a bigger
    one.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Dockerfile.in` file will look as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we specify that we'll take the latest Ubuntu image, install our DEB package
    on it along with its dependencies, and then tidy up. It's important to update
    the package manager cache in the same step as installing the package to avoid
    issues with stale caches due to how layers in Docker work. Cleanup is also performed
    as part of the same `RUN` command (in the same layer) so that the layer size is
    smaller. After installing the package, we make our image run the `customer` microservice
    when it is started. Finally, we tell Docker to expose the port that it will be
    listening on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Now, back to our `CMakeLists.txt` file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Integrating containers with CMake
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For CMake-based projects, it is possible to include a build step responsible
    for building the containers. For that, we need to tell CMake to find the Docker
    executable and bail out if it doesn''t. We can do this using the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's revisit the example from one of [Chapter 7](7f997c01-2634-4584-be95-0b068f448312.xhtml),
    *Building and Packaging*. There, we built a binary and a Conan package for the
    customer application. Now, we want to package this application as a Debian archive
    and build a Debian container image with a pre-installed package for the customer
    application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our DEB package, we need a helper target. Let''s use CMake''s `add_custom_target`
    functionality for this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our target invokes CPack to create just the one package that's interesting for
    us and omitting the rest. We want the package to be created in the same directory
    as the Dockerfile for convenience. The `VERBATIM` keyword is recommended as, with
    it, CMake will escape problematic characters. If it's not specified, the behavior
    of your scripts may vary across different platforms.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add_dependencies` call will make sure that before CMake builds the `customer-deb`
    target, `libcustomer` is already built. As we now have our helper target, let''s
    use it when creating the container image:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we invoke the Docker executable we found earlier in the directory
    containing our Dockerfile and DEB package, to create an image. We also tell Docker
    to tag our image as both the latest and with the version of our project. Finally,
    we ensure the DEB package will be built when we invoke our Docker target.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Building the image is as simple as `make docker` if `make` is the generator
    you chose. If you prefer the full CMake command (for example, to create generator-agnostic
    scripts), the invocation is `cmake --build . --target docker`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Testing and integrating containers
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers fit very well with CI/CD pipelines. Since they mostly require no
    further dependencies other than the container runtime itself, they can be easily
    tested. Worker machines don't have to be provisioned to fulfill the testing needs,
    so adding more nodes is much easier. What is more, all of them are general-purpose
    so that they may act both as builders, test runners, and even deployment executors
    without any prior configuration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Another great benefit of using containers in **CI**/**CD** is the fact that
    they are isolated from one another. This means multiple copies running on the
    same machine should not interfere. That is true unless the tests require some
    resources from the host operating system, such as port forwarding or volume mounting.
    Therefore it's best to design tests so that such resources are not necessary (or
    at least they don't clash). Port randomization is a helpful technique to avoid
    clashes, for example.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Runtime libraries inside containers
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The choice of containers may influence the choice of a toolchain and, therefore,
    C++ language features available to the application. Since containers are typically
    Linux-based, the system compiler available is usually GNU GCC with glibc as a
    standard library. However, some Linux distributions popular with containers, such
    as Alpine Linux, are based on a different standard library, musl.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的选择可能会影响工具链的选择，因此也会影响应用程序可用的C++语言特性。由于容器通常基于Linux，可用的系统编译器通常是带有glibc标准库的GNU
    GCC。然而，一些流行的用于容器的Linux发行版，如Alpine Linux，基于不同的标准库musl。
- en: If you are targeting such a distribution, make sure the code you'll be using,
    whether developed in-house or from third-party providers, is compatible with musl.
    The main advantage of both musl and Alpine Linux is that it results in much smaller
    container images. For example, a Python image built for Debian Buster is around
    330 MB, the slimmed-down Debian version is around 40 MB, while the Alpine version
    is only around 16 MB. Smaller images mean less wasted bandwidth (for uploads and
    downloads) and quicker updates.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标是这样的发行版，确保你将要使用的代码，无论是内部开发的还是来自第三方提供者，都与musl兼容。musl和Alpine Linux的主要优势是它们可以生成更小的容器镜像。例如，为Debian
    Buster构建的Python镜像约为330MB，精简版的Debian版本约为40MB，而Alpine版本仅约为16MB。更小的镜像意味着更少的带宽浪费（用于上传和下载）和更快的更新。
- en: Alpine may also introduce some unwanted traits, such as longer build times,
    obscure bugs, or reduced performance. If you want to use it to reduce the size,
    run proper tests to make sure the application behaves without problems.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine可能也会引入一些不需要的特性，比如更长的构建时间、隐晦的错误或性能降低。如果你想使用它来减小大小，务必进行适当的测试，确保应用程序没有问题。
- en: To reduce your images' size even more, you may consider ditching the underlying
    operating system altogether. What we mean by operating system here is all the
    userland tools ordinarily present in a container, such as a shell, package manager,
    and shared libraries. After all, if your application is the only thing that's
    going to be running, everything else is unnecessary.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步减小镜像的大小，你可以考虑放弃底层操作系统。这里所说的操作系统是指通常存在于容器中的所有用户空间工具，如shell、包管理器和共享库。毕竟，如果你的应用是唯一要运行的东西，其他一切都是不必要的。
- en: It is typical for Go or Rust applications to provide a static build that is
    self-sufficient and can form a container image. While this might not be as straightforward
    in C++, it is worth considering.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Go或Rust应用程序通常提供一个自包含的静态构建，可以形成一个容器镜像。虽然在C++中可能不那么直接，但也值得考虑。
- en: There are a few drawbacks related to decreasing the image size as well. First
    of all, if you decide to go with Alpine Linux, keep in mind it is not as popular
    as, say, Ubuntu, Debian, or CentOS. Although it is often a platform of choice
    for container developers, it's very unusual for any other purpose.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 减小镜像大小也有一些缺点。首先，如果你决定使用Alpine Linux，请记住它不像Ubuntu、Debian或CentOS那样受欢迎。尽管它经常是容器开发者的首选平台，但对于其他用途来说非常不寻常。
- en: This means that there might be new compatibility problems, mostly stemming from
    the fact it's not based on the de facto standard glibc implementation. If you
    rely on third-party components, the provider may not offer support for this platform.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着可能会出现新的兼容性问题，主要源自它不是基于事实上的标准glibc实现。如果你依赖第三方组件，提供者可能不会为这个平台提供支持。
- en: If you decide to go down the single statically linked binary inside the container
    image route, there are also some challenges to consider. First of all, you are
    discouraged from statically linking glibc as it makes internal use of dlopen to
    handle **Name Service Switch** (**NSS**) and iconv. If your software relies on
    DNS resolving or character set conversion, you'll have to provide a copy of glibc
    and the relevant libraries anyway.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定采用容器镜像中的单个静态链接二进制文件路线，也有一些挑战需要考虑。首先，你不建议静态链接glibc，因为它内部使用dlopen来处理**Name
    Service Switch**（NSS）和iconv。如果你的软件依赖于DNS解析或字符集转换，你仍然需要提供glibc和相关库的副本。
- en: Another point to consider is that shell and package managers are often used
    for debugging containers that misbehave. When one of your containers is acting
    strangely, you may start another process inside the container and figure out what
    is happening inside by using standard UNIX tools such as `ps`, `ls`, or `cat`.
    To run such an application inside the container, it has to be present in the container
    image first. Some workarounds allow the operator to inject debugging binaries
    inside the running container, but none of them are well-supported at the moment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的问题是，通常会使用shell和包管理器来调试行为异常的容器。当你的某个容器表现出奇怪的行为时，你可以在容器内启动另一个进程，并通过使用诸如`ps`、`ls`或`cat`等标准UNIX工具来弄清楚容器内部发生了什么。要在容器内运行这样的应用程序，它必须首先存在于容器镜像中。一些解决方法允许操作员在运行的容器内注入调试二进制文件，但目前没有一个得到很好的支持。
- en: Alternative container runtimes
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代容器运行时
- en: Docker is the most popular way to build and run containers, but since the container
    standard is open, there are also alternative runtimes that you may use. The main
    replacement for Docker that offers a similar user experience is Podman. Together
    with Buildah, described in the previous section, they are tools aimed to replace
    Docker altogether.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是构建和运行容器的最流行方式，但由于容器标准是开放的，也有其他可供选择的运行时。用于替代Docker并提供类似用户体验的主要工具是Podman。与前一节中描述的Buildah一起，它们是旨在完全取代Docker的工具。
- en: The added benefit is that they *don't require an additional daemon running on
    a host machine, as Docker does*. Both also have support (although it is not yet
    mature) for rootless operations, which makes them a better fit for security-critical
    operations. Podman accepts all the commands you would expect the Docker CLI to
    take, so you can simply use it as an alias this way.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to containers that aims to provide better security is the **Kata
    Containers** initiative. Kata Containers uses lightweight virtual machines to
    leverage the hardware virtualization required for an additional level of isolation
    between the containers and the host operating system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Cri-O and containerd are also popular runtimes used by Kubernetes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Understanding container orchestration
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the containers' benefits only become apparent when you are using a container
    orchestrator to manage them. An orchestrator keeps track of all the nodes that
    will be running your workload, and it also monitors the health and status of the
    containers spread across these nodes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: More advanced features, for example, high availability, require the proper setup
    of the orchestrator, which typically means dedicating at least three machines
    for the control plane and another three machines for worker nodes. The autoscaling
    of nodes, in addition to the autoscaling of containers, also requires the orchestrator
    to have a driver able to control the underlying infrastructure (for example, by
    using the cloud provider's API).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will cover some of the most popular orchestrators that you can choose
    from to base your system on. You will find more practical information on Kubernetes
    in the next chapter, [Chapter 15](https://cdp.packtpub.com/hands_on_software_architecture_with_c__/wp-admin/post.php?post=41&action=edit),
    *Cloud-Native Design*. Here, we give you an overview of the possible choices.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The presented orchestrators operate on similar objects (services, containers,
    batch jobs) although each may behave differently. The available features and operating
    principles vary between them. What they have in common is that you typically write
    a configuration file that declaratively describes the required resources and then
    you apply this configuration using a dedicated CLI tool. To illustrate the differences
    between the tools, we provide an example configuration specifying a web application
    introduced before (the merchant service) and a popular web server, Nginx, to act
    as a proxy.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Self-hosted solutions
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether you are running your application on-premises, in a private cloud, or
    in a public cloud, you may want to have tight control over the orchestrator of
    your choice. The following is a collection of self-hosted solutions in this space.
    Keep in mind that most of them are also available as managed services. However,
    going with self-hosted helps you prevent vendor lock-in, which may be desirable
    for your organization.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes is probably the best-known orchestrator of all the ones that we mention
    here. It is prevalent, which means there is a lot of documentation and community
    support if you decide to implement it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Even though Kubernetes uses the same application container format as Docker,
    this is basically where all the similarities end. It is impossible to use standard
    Docker tools to interact with Kubernetes clusters and resources directly. There
    is a new set of tools and concepts to learn when using Kubernetes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Whereas with Docker, the container is the main object you will operate on, with
    Kubernetes, the smallest piece of the runtime is called a Pod. A Pod may consist
    of one or more containers that share mount points and networking resources. Pods
    in themselves are rarely of interest as Kubernetes also has higher-order concepts
    such as Replication Controllers, Deployment Controllers, or DaemonSets. Their
    role is to keep track of the pods and ensure the desired number of replicas is
    running on the nodes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The networking model in Kubernetes is also very different from Docker. With
    Docker, you can forward ports from a container to make it accessible from different
    machines. With Kubernetes, if you want to access a pod, you typically create a
    Service resource, which may act as a load balancer to handle the traffic to the
    pods that form the service's backend. Services may be used for pod-to-pod communication,
    but they may also be exposed to the internet. Internally, Kubernetes resources
    perform service discovery using DNS names.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is declarative and eventually consistent. This means that instead
    of directly creating and allocating resources, you only have to provide the description
    of the desired end state and Kubernetes will do the work required to bring the
    cluster to the desired state. Resources are often described using YAML.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Since Kubernetes is highly extensible, there are a lot of associated projects
    developed under the **Cloud Native Computing Foundation** (**CNCF**), which turn
    Kubernetes into a provider-agnostic cloud development platform. We will present
    Kubernetes in more detail in the next chapter, [Chapter 15](27377621-3532-4513-8045-caa00285fdda.xhtml),
    *Cloud Native Design*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the resource definition looks for Kubernetes using YAML (`merchant.yaml`):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To apply this configuration and orchestrate the containers, use `kubectl apply
    -f merchant.yaml`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker Engine, also required to build and run Docker containers, comes pre-installed
    with its own orchestrator. This orchestrator is Docker Swarm, and its main feature
    is high compatibility with existing Docker tools by using the Docker API.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm uses the concept of Services to manage health checks and autoscaling.
    It supports rolling upgrades of the services natively. Services are able to publish
    their ports, which will then be served by Swarm's load balancer. It supports storing
    configs as objects for runtime customization and has basic secret management built
    in.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm is much simpler and less extensible than Kubernetes. This could
    be an advantage if you do not want to learn about all the details of Kubernetes.
    However, the main disadvantage is a lack of popularity, which means it is harder
    to find relevant material about Docker Swarm.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of using Docker Swarm is that you don't have to learn new
    commands. If you're already used to Docker and Docker Compose, Swarm works with
    the same resources. It allows specific options that extend Docker to handle deployments.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Two services orchestrated with Swarm would look like this (`docker-compose.yml`):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To apply the configuration, you run `docker stack deploy --compose-file docker-compose.yml
    dominican`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Nomad
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nomad is different from the previous two solutions, as it is not focused solely
    on containers. It is a general-purpose orchestrator with support for Docker, Podman,
    Qemu Virtual Machines, isolated fork/exec, and several other task drivers. Nomad
    is a solution worth learning about if you want to gain some of the advantages
    of container orchestration without migrating your application to containers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: It is relatively easy to set up and integrates well with other HashiCorp products
    such as Consul for service discovery and Vault for secret management. Like Docker
    or Kubernetes, Nomad clients can run locally and connect to the server responsible
    for managing your cluster.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three job types available in Nomad:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '**Service**: A long-lived task that should not exit without manual intervention
    (for example, a web server or a database).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Batch**: A shorter-lived task that can complete within as little as a few
    minutes. If the batch job returns an exit code indicating an error, it is either
    restarted or rescheduled according to configuration.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System**: A task that it is necessary to run on every node in the cluster
    (for example, logging agent).'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compared to other orchestrators, Nomad is relatively easy to install and maintain.
    It is also extensible when it comes to task drivers or device plugins (used to
    access dedicated hardware such as GPUs or FPGAs). It lacks in community support
    and third-party integrations when compared to Kubernetes. Nomad does not require
    you to redesign the application's architecture to access the provided benefits,
    which is often the case with Kubernetes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the two services with Nomad, we need two configuration files.
    The first one is `nginx.nomad`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second describes the merchant application, so it''s called `merchant.nomad`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To apply the configuration, you run `nomad job run merchant.nomad && nomad job
    run nginx.nomad`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: OpenShift
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenShift is Red Hat's commercial container platform built on Kubernetes. It
    includes a lot of additional components that are useful in the everyday operations
    of Kubernetes clusters. You get a container registry, a build tool similar to
    Jenkins, Prometheus for monitoring, Istio for service mesh, and Jaeger for tracing.
    It is not fully compatible with Kubernetes so it shouldn't be thought of as a
    drop-in replacement.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: It is built on top of existing Red Hat technology such as CoreOS and Red Hat
    Enterprise Linux. You can use it on-premises, within Red Hat Cloud, on one of
    the supported public cloud providers (including AWS, GCP, IBM, and Microsoft Azure),
    or as a hybrid cloud.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: There is also an open source community-supported project called OKD, which forms
    the basis of Red Hat's OpenShift. If you do not require commercial support and
    other benefits of OpenShift, you may still use OKD for your Kubernetes workflow.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Managed services
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously mentioned, some of the aforementioned orchestrators are also available
    as managed services. Kubernetes, for instance, is available as a managed solution
    in multiple public cloud providers. This section will show you some of the different
    approaches to container orchestration, which are not based on any of the solutions
    mentioned above.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: AWS ECS
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before Kubernetes released its 1.0 version, Amazon Web Services proposed its
    own container orchestration technology called **Elastic Container Service** (**ECS**).
    ECS provides an orchestrator that monitors, scales, and restarts your services
    when needed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: To run containers in ECS, you need to provide the EC2 instances on which the
    workload will run. You are not billed for the orchestrator's use, but you are
    billed for all the AWS services that you typically use (the underlying EC2 instances,
    for example, or an RDS database).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: One of the significant benefits of ECS is its excellent integration with the
    rest of the AWS ecosystem. If you are already familiar with AWS services and invested
    in the platform, you will have less trouble understanding and managing ECS.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: If you do not require many of the Kubernetes advanced features and its extensions,
    ECS may be a better choice as it's more straightforward and more comfortable to
    learn.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: AWS Fargate
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another managed orchestrator offered by AWS is Fargate. Unlike ECS, it does
    not require you to provision and pay for the underlying EC2 instances. The only
    components you are focused on are the containers, the network interfaces attached
    to them, and IAM permissions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Fargate requires the least amount of maintenance compared to other solutions
    and is the easiest to learn. Autoscaling and load-balancing are available out
    of the box thanks to the existing AWS products in this space.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The main downside here is the premium that you pay for hosting your services
    when compared to ECS. A straight comparison is not possible as ECS requires paying
    for the EC2 instances, while Fargate requires paying for the memory and CPU usage
    independently. This lack of direct control over your cluster may easily lead to
    high costs once your services start to autoscale.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Azure Service Fabric
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem with all of the preceding solutions is that they mostly target Docker
    containers, which are first and foremost Linux-centric. Azure Service Fabric,
    on the other hand, is a Windows-first product backed by Microsoft. It enables
    running legacy Windows apps without modifications, which may help you migrate
    your application if it relies on such services.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: As with Kubernetes, Azure Service Fabric is not so much a container orchestrator
    in itself, but rather a platform on top of which you can build your applications.
    One of the building blocks happens to be containers, so it works fine as an orchestrator.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: With the recent introduction of Azure Kubernetes Service, the managed Kubernetes
    platform in the Azure cloud, there is less need for using Service Fabric.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are an architect of modern software, you have to take into account
    modern technologies. Taking them into account doesn't mean following the trends
    blindly; it means being able to objectively assess whether a particular proposition
    makes sense in your case or not.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Both microservices, presented in the previous chapters, and containers, presented
    in this chapter, are worth considering and understanding. Are they worth implementing
    as well? It depends heavily on what type of product you are designing. If you've
    read this far, you are ready to make the decision for yourself.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is dedicated to cloud-native design. A very interesting but
    also a complex topic that ties in service-oriented architecture, CI/CD, microservices,
    containers, and cloud services. As it turns out, the great performance of C++
    is a welcome feature for some of the cloud-native building blocks.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do application containers differ from operating system containers?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some early examples of sandboxing environments in UNIX systems?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are containers a good fit for microservices?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main differences between containers and virtual machines?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When are application containers a bad choice?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some tools to build multi-platform container images?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Besides Docker, what are some other container runtimes?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some popular orchestrators?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Learning Docker - Second Edition*: [https://www.packtpub.com/product/learning-docker-second-edition/9781786462923](https://www.packtpub.com/product/learning-docker-second-edition/9781786462923)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learn OpenShift*: [https://www.packtpub.com/product/learn-openshift/9781788992329](https://www.packtpub.com/product/learn-openshift/9781788992329)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Docker for Developers*: [https://www.packtpub.com/product/docker-for-developers/9781789536058](https://www.packtpub.com/product/docker-for-developers/9781789536058)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
