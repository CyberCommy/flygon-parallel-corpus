- en: Persisting with Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will work on improving the to-do list app from the previous
    chapter by properly persisting the tasks the user enters into a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different types of databases available for mobile development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to connect to some of the different databases available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A database is simply a collection of data organized in a way that makes accessing
    and/or updating it easy. Organizing data can be done in a lot of ways, but they
    can be grouped into two main types:'
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-relational databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A relational database is a database that organizes its data based on the relations
    that exist between the data. In a relational database, data is presented in the
    form of tables with rows and columns. A table stores a collection of data of the
    same type. Each column in a table represents an attribute of an object stored
    in the table. Each row in a table represents an object stored. A table has a heading
    that specifies the names and types of the different attributes of the objects
    to be stored in the database. In relational databases, the data types of each
    attribute are specified at the point of creation of the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example. The table here represents a collection of
    students:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cdfbeee-544f-46ce-8ee7-4ef1c80c7f57.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each row of the table represents a single student. The columns represent different
    attributes of each of the students.
  prefs: []
  type: TYPE_NORMAL
- en: A relational database is maintained using an **RDBMS** (**Relational Database
    Management System**). The data is accessed and managed using a language known
    as **SQL** (Structured Query Language). Some of the most-used RDBMSs are Oracle,
    MySQL, Microsoft SQL Server, PostgreSQL, Microsoft Access, and SQLite. MySQL,
    PostgreSQL, and SQLite are open sourced.
  prefs: []
  type: TYPE_NORMAL
- en: The RDBMS of choice for Android development is SQLite. This is because the Android
    OS comes bundled with SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we built a to-do list app that lets the user add, update,
    and delete tasks. We used an `ArrayList` as our data store. Let's go ahead and
    extend the app to use a relational database instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to do is to define a schema of your database. The schema of
    a database is what defines how the data in the database is organized. It defines
    the tables into which the data is organized, and restrictions on those tables
    (such as allowed data types for the columns). It is advisable to create a contract
    class that specifies the details of your database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Kotlin object, with the name `TodoListDBContract`, and replace
    its contents with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `TodoListItem` class represents a table in our database,
    and is used to declare the name of the table and names of its columns.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new Kotlin object, first, right-click the package and select New
  prefs: []
  type: TYPE_NORMAL
- en: '| Kotlin File/Class. Then in the New Kotlin File/Class dialog, select Object in
    the Kind field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17843c5f-c75e-4ae4-a767-86b46ba915b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next thing to do is to create a database helper class. This will help us
    abstract the connection to the database and not keep the database connection logic
    in our Activity. Go ahead and create a new Kotlin class with the name `TodoListDBHelper`.
    The class should take a `Context` parameter in its default constructor and extend
    the `android.database.sqlite.SQLiteOpenHelper` class as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following lines of code to the `TodoListDBHelper` class as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding lines of code the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SQL_CREATE_ENTRIES` is a SQL query to create a table. It specifies an`_id` field,
    which is set as the primary key of the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In relational databases, a table is required to have a column that uniquely
    identifies each row entry. This unique column is known as the **Primary Key**.
    Specifying a column as **AUTOINCREMENT** tells the RDBMS to auto-generate a new
    value for this field whenever a new row is being inserted.
  prefs: []
  type: TYPE_NORMAL
- en: '`SQL_DELETE_ENTRIES` is a SQL query to drop the table if it exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `onCreate()` method, the SQL query is executed to create the table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `onUpgrade()`, the table is deleted and recreated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the table will have an ID field in the database, we have to add an extra
    field in the `Task` class to track it. Open `Task.kt`, add a new field of `Long`
    type, named `taskId`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the constructor shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Inserting data into the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open `TodoListDBHelper`, and add the method shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We first retrieve the database in write mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create an instance of `ContentValues` and put in a value key mapping
    of the fields in the item we want to insert.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we invoke the `insert()` method on the database object, passing the table
    name and the `ContentValues` instance to it. This returns the primary key, `_id`,
    of the inserted item. We update the task object and return it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add an instance of the `TodoListDBHelper` class as a new field at the
    top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And, override the `onDestroy()` method of `AppCompatActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This closes the database connection when the Activity's `onDestroy()` method
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `onDialogPositiveClick()` method, locate this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Calling `dbHelper.addNewTask()` will save the new task to the database instead
    of just adding it to the `todoListItems` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2db33716-0630-4e2d-a312-b6266e3502d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've been able to save to the database, we need to be able to view
    the data when the app starts up.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open `TodoListDBHelper`, and add the method shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `retrieveTaskList` method, we perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We first retrieve the database in read-mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create an array that lists all the columns of the table we need to
    retrieve. Here, if we have no need for the values of a specific column, we don't
    add that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then pass the table name and the column list to the `query()` method on the
    database object. This returns a `Cursor` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we loop through the items in the `Cursor` object, and create an instance
    of the `Task` class with the attributes of each item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We close the cursor and return the retrieved data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open `MainActivity`, and add the following line of code at the beginning
    of the `populateListView()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `populateListView()` method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, build and run again. You''ll notice that, unlike in the previous chapter,
    when you restarted the application, the tasks you saved earlier are preserved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b24d7315-a1a7-436d-95e9-4b8aa4b26542.png)'
  prefs: []
  type: TYPE_IMG
- en: Updating a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn to update the details of an already saved task
    in the database. Open `TodoListDBHelper`, and add the method shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `updateTask()` method, we perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We first retrieve the database in write mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create an instance of `ContentValues` and put in a value key mapping
    of the fields we want to update. For what we are working on, we will assume an
    update of all columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We specify a query for selecting which database entry to update. Our selection
    query uses the `_id` column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we specify the argument for the select query which, in our case, is the
    `taskId` of the selected `Task`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we invoke the `update()` method on the database object, passing the table
    name, the `ContentValues` instance, the select query, and the selection value to
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onDialogPositiveClick()` method in the `MainActivity` class, locate
    this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And, place it right after this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onDialogPositiveClick()` method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in `onOptionsItemSelected()`, locate the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And, place it right after this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run. When you click on the **Mark as Complete** menu item, the selected
    task will be updated as completed, and the listView updated accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5216fb5-982a-43ff-89b2-a235647f803a.png)'
  prefs: []
  type: TYPE_IMG
- en: Deleting a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn to delete a saved task in the database. Open `TodoListDBHelper`,
    and add the method shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The process for deletion is similar to that of updating:'
  prefs: []
  type: TYPE_NORMAL
- en: First, retrieve the database in write mode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, specify a query for selecting which database entry to delete. Our `selection`
    query uses the `_id` column
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, specify the argument for the `selection` query which, in our case, is
    the `taskId` of the selected `Task`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we invoke the `delete()` method on the database object, passing the table
    name, the select query, and the selection value to it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the method in the `MainActivity` class, locate the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run. When you add a new item, the entry isn''t just added to the `ListView`, 
    it is also saved in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ac315e8-e5d1-4094-ba24-3a5d1d6bdf0c.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing your own SQL queries can be error-prone, especially if you're building
    an app that depends heavily on the database or requires very complex queries.
    It also requires a lot of effort and SQL query knowledge. To help with this, you
    can use an ORM library.
  prefs: []
  type: TYPE_NORMAL
- en: ORM libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **ORM** (**Object Relational Mapping**) Library provides a better way for
    you to persist objects to a database instead, without worrying much about the
    SQL queries, and opening and closing database connections.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**: You still need some level of SQL query knowledge'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of Android-compatible ORM Libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: ORMLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GreenDAO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DbFlow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Room
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But, in this book, we will focus on **Room**, which is an ORM introduced by
    Google.
  prefs: []
  type: TYPE_NORMAL
- en: To use Room, we first have to add its dependencies to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `build.gradle`, and add the following lines of code to the dependencies
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on Sync Now. For Room to be able to save tasks to the database, we need
    to specify which class represents a table. This is done by annotating the class
    as an `Entity`. Open the `Task` class and replace its contents with the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Entity` specifies that `Task` represents a table in the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ColumnInfo` maps the field to a database column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PrimaryKey` specifies that the field is the primary key of the table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next thing is to create a **DAO** (Data Access Object). Create a new Kotlin
    interface with the name `TaskDAO`, and replace its contents with the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: Room provides `Insert`, `Update`, and `Delete` annotations, so you don't have
    to write queries for those
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For select operations, you have to annotate the method with the query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have to create a database class that will connect our application
    to the database. Create a new Kotlin class with the name `AppDatabase`, and replace
    its contents with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That's all the setup needed to connect to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the database, open `MainActivity`. First, create a field of `AppDatabase`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, instantiate the field in the `onCreate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, you specify your database class and the name of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Room does not allow you to run database operations on the main thread, so we
    will use an `AsyncTask` to perform the calls. Add the private class shown here
    to the `MainActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we make a call to the `taskDao` to retrieve the task list from the database
    in the `doInBackground()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `populateListView()`  method, locate the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And, replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Room creates and manages a master table, which it uses to track the version
    of your database. As such, even though we need to perform a migration of the database
    if we want to preserve the data currently in our database.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `TodoListDBContract` class and increase the `DATABASE_VERSION` constant
    to `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, replace the database instantiation in the `MainActivity` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add a new `Migration` object to the `databaseBuilder`, while specifying
    the current version of the database and the new version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, build and run. Your app will start up with the previously saved `Tasks`
    showing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/437ab9e1-546d-4ee5-a647-fcc44f0d4004.png)'
  prefs: []
  type: TYPE_IMG
- en: Inserting data into the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add a new task, create a new `AsyncTask` in the `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we make a call to the `taskDao` to insert the new task in the database
    in the `doInBackground()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `onDialogPositiveClick()` method, locate the line of code shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And, replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, build and run. Just like in the previous section, when you add a new item,
    the entry isn''t just added to the `ListView`, it is also saved in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a374130-64f6-4d3b-b2e5-bfa9c68fa19e.png)'
  prefs: []
  type: TYPE_IMG
- en: Updating a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To update a task, create a new `AsyncTask` in the `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we make a call to the `taskDao` to insert the new task in the database
    in the `doInBackground()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `onDialogPositiveClick()` method, locate the following line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, in `onOptionsItemSelected()`, locate the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And, replace it with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, build and run. Just like in the previous chapter, select a task and click
    the Edit menu item. In the Edit Task dialog that shows up, make changes to the
    task details and click on the SAVE button.
  prefs: []
  type: TYPE_NORMAL
- en: 'This takes away the dialog, saves the changes to the database, updates your
    ListView with the updated task, and displays a ticker with the message Task Updated
    Successfully at the bottom of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4db5afbc-4728-4d11-bf8b-9b71a1ce8345.png)'
  prefs: []
  type: TYPE_IMG
- en: Deleting a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To delete a task, create a new `AsyncTask` in the `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in `onOptionsItemSelected()`, locate the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run. Select a task and click the Delete menu item. This removes the
    selected task from the ListView, removes it from the database as well, and displays a
    ticker with the message Task deleted successfully at the bottom of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01e114b6-5787-42ac-b0cc-a6c7a10d0fd7.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it. As you can see, using the ORM lets you write less code and reduces
    SQL errors.
  prefs: []
  type: TYPE_NORMAL
- en: Non-relational databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A non-relational, or NoSQL database, is a database that does not organize its
    data based on relations. Unlike relational databases, there are different ways
    in which the different non-relational databases store and manage their data. Some
    store data as key-value pairs, while others store data as objects. A number of
    these database options support Android. In most cases, these databases come with
    the ability to synchronize your data to an online server. Two of the most popular
    No-SQL mobile databases are:'
  prefs: []
  type: TYPE_NORMAL
- en: CouchBase Mobile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Realm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CouchBase is an example of a document database and Realm is an example of an
    object database.
  prefs: []
  type: TYPE_NORMAL
- en: Document databases are schema-less, which means they are unstructured and as
    such do not have restrictions on what can go into a document. They store their
    data as key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Object databases, on the other hand, store their data as objects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added the functionality of storing our tasks into a database.
    We also learned about the different types of databases we can use. The most-used
    database among Android developers is SQLite, but that does not prevent you from
    exploring other options. There are also database services such as Firebase that
    provide a backend as a service functionality.
  prefs: []
  type: TYPE_NORMAL
- en: When choosing a database, you should consider the data needs of your application.
    Is there a need to store the data on an online server? Or, is it data that's only
    used locally for that instance of the app? Do you want to or have the capability
    to set up and manage a custom data server, or will you rather opt for a service
    that does that work for you? These are some of the considerations when choosing
    a database for your Android application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will work on adding a reminder functionality to our
    To-do List application.
  prefs: []
  type: TYPE_NORMAL
