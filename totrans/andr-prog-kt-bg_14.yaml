- en: Chapter 14. Android Dialog Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to present the user with a pop-up dialog
    window. We can then put all that we know into the first phase of our first multi-chapter
    app, *Note to self*. We will then learn about more Android and Kotlin features
    in this chapter and the four following chapters (up to [Chapter 18](ch18.html
    "Chapter 18. Localization"), *Localization*), and then use our newly acquired
    knowledge to enhance the Note to self app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In each chapter, we will also build a selection of smaller apps that are separate
    from this main app. So, what does [Chapter 14](ch14.html "Chapter 14. Android
    Dialog Windows"), *Android Dialog Windows*, hold in store for you? The following
    topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a simple app with a pop-up dialog box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use `DialogFragment` to begin the Note to self app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start the Note to self app and learn how to add string resources in our projects
    instead of hardcoding text in our layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement more complex dialog boxes to capture input from the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Dialog windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often in our apps, we will want to show the user some information, or perhaps
    ask for confirmation of an action in a pop-up window. This is known as a **dialog**
    window. If you quickly scan the palette in Android Studio, you might be surprised
    to see no mention of dialog windows whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: Dialog windows in Android are more advanced than a simple widget or even a whole
    layout. They are classes that can also have layouts and other UI elements of their
    own.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to create a dialog window in Android is to use the `DialogFragment`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fragments are an extensive and vital topic in Android, and we will spend much
    of the second half of this book exploring and using them. Creating a neat pop-up
    dialog (using `DialogFragment`) for our user to interact with is, however, a great
    introduction to fragments and is not complicated at all.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the dialog demo project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We previously mentioned that the best way to create a dialog window in Android
    is with the `DialogFragment` class. However, there is another way to create dialogs
    in Android that is arguably a little bit simpler. The problem with this simpler
    `Dialog` class is that it is not very well supported in the Activity lifecycle.
    It is even possible that using `Dialog` could accidentally crash the app.
  prefs: []
  type: TYPE_NORMAL
- en: If you were writing an app with one fixed orientation layout that only needed
    one simple pop-up dialog, it could be argued that the simpler `Dialog` class should
    be used. But, as we are aiming to build modern, professional apps with advanced
    features, we will benefit from ignoring this class.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio using the **Empty Activity** project
    template and call it `Dialog Demo`. The completed code for this project is in
    the `Chapter14/Dialog Demo` folder of the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a DialogFragment class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class in Android Studio by right-clicking on the folder with the
    name of your package (the one that has the `MainActivity.kt` file). Select **New**
    | **Kotlin File/class**, name it `MyDialog`, and choose **Class** in the drop-down
    selector. Left-click on **OK** to create the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is to change the class declaration to inherit
    from `DialogFragment`. Also, let''s add all the imports we will need in this class.
    When you have done so, your new class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's add code to this class a bit at a time and explain what is happening
    at each step.
  prefs: []
  type: TYPE_NORMAL
- en: As with so many classes in the Android API, `DialogFragment` provides us with
    functions that we can override to interact with the different events that will
    occur with the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code that overrides the `onCreateDialog` function.
    Study it carefully, and then we will examine what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one error in the code because we are missing the return statement,
    which needs to return an object of type `Dialog`. We will add this when we have
    finished coding the rest of the function shortly.
  prefs: []
  type: TYPE_NORMAL
- en: In the code that we just added, we first add the overridden `onCreateDialog`
    function, which will be called by Android when we later show the dialog with code
    from the `MainActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Then, inside the `onCreateDialog` function, we get our hands on an instance
    of a new class. We declare and initialize an object of the `AlertDialog.Builder`
    type that needs a reference to the `MainActivity` class to be passed into its
    constructor. This is why we use `activity!!` as the argument; and we are asserting
    that the instance is not null (!!).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to [Chapter 12](ch12.html "Chapter 12. Connecting Our Kotlin to the UI
    and Nullability"), *Connecting Our Kotlin to the UI and Nullability*, for a refresher
    on the not null assertion (`!!`).
  prefs: []
  type: TYPE_NORMAL
- en: The `activity` property is part of the `Fragment` class (and, therefore, `DialogFragment`
    too) and it is a reference to the `Activity` class instance that will create the
    `DialogFragment` instance. In this case, this is our `MainActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at what we can do with `builder` now that we have declared
    and initialized it.
  prefs: []
  type: TYPE_NORMAL
- en: Using chaining to configure the DialogFragment class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we can use our `builder` object to do the rest of the work. There is something
    slightly odd in the next three blocks of code. If you look ahead and quickly scan
    them, you will notice that there are three uses of the dot operator, but only
    one usage is actually placed next to the `builder` object. This shows that these
    three apparent blocks of code are, in fact, just one line to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen what is going on here before, but in a less pronounced situation.
    When we create a `Toast` message and add a `.show()` call on to the end of it,
    we are **chaining**. That is, we are calling more than one function, in sequence,
    on the same object. This is equivalent to writing multiple lines of code; it is
    just clearer and shorter this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code, which utilizes chaining, right after the previous code that
    we added in `onCreateDialog`, examine it, and then we will discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the three parts of code that we added can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first of the three blocks that uses chaining, we call `builder.setMessage`,
    which sets the main message that the user will see in the dialog box. Also, note
    that it is fine to have comments in between parts of the chained function calls,
    as these are ignored entirely by the compiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we add a button to our dialog with the `setPositiveButton` function and
    the first argument sets the text on it to `OK`. The second argument is a lambda
    that implements `DialogInterface.OnClickListener` that handles clicks on the button.
    Notice that we are not going to add any code to the `onClick` function, but we
    could, just as we did in the previous chapter. We just want to see this simple
    dialog and we will take things a step further in the next project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we call yet another function on the same `builder` object. This time,
    it's the `setNegativeButton` function. Again, the two arguments set `Cancel` as
    the text for the button and a lambda is used to set up listening for clicks. Again,
    for the purposes of this demo, we are not taking any action in the overridden
    `onClick` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will code the `return` statement to complete the function and remove
    the error. Add the `return` statement to the end (but keep it inside the final
    curly brace) of the `onCreateDialog` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This last line of code has the effect of returning to `MainActivity` (which
    will call `onCreateDialog` in the first place) our new, fully configured, dialog
    window. We will see and add this calling code quite soon.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our `MyDialog` class that inherits from `FragmentDialog`, all
    we have to do is to declare an instance of `MyDialog`, instantiate it, and call
    its overridden `onCreateDialog` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the DialogFragment class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we turn to the code, let''s add a button to our layout, by observing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the `activity_main.xml` tab, and then switch to the **Design** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Button** widget onto the layout and make sure its `id` attribute is
    set to `button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Infer Constraints** button to constrain the button exactly where
    you place it, but the position isn't important; how we will use it to create an
    instance of our `MyDialog` class is the key lesson.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now switch to the `MainActivity.kt` tab and we will handle a click on this new
    button by using a lambda as we did in [Chapter 13](ch13.html "Chapter 13. Bringing
    Android Widgets to Life"), *Bringing Android Widgets to Life* during the Widget
    exploration app. We do it this way as we only have one button in the layout, and
    it seems sensible and more compact than doing the alternative (that is, implementing
    the `OnClickListener` interface and then overriding `onClick` for the entire `MainActivity`
    class as we did in [Chapter 12](ch12.html "Chapter 12. Connecting Our Kotlin to
    the UI and Nullability"), *Connecting Our Kotlin to the UI and Nullability*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `onCreate` function of `MainActivity` after the
    call to `setContentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following `import` statement is needed for this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the only thing that happens in the code is that the `setOnClickListener`
    lambda overrides `onClick`. This means that when the button is pressed, a new
    instance of `MyDialog` is created and calls its `show` function, which will show
    our dialog window just as we configured it in the `MyDialog` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `show` function needs a reference to `FragmentManager`, which we get from
    the `supportFragmentManager` property. This is the class that tracks and controls
    all fragment instances for an `Activity` instance. We also pass in an ID (`"123"`).
  prefs: []
  type: TYPE_NORMAL
- en: More details on `FragmentManager` will be revealed when we look more deeply
    at fragments, starting in [Chapter 24,](ch24.html "Chapter 24. Design Patterns,
    Multiple Layouts, and Fragments") *Design Patterns, Multiple Layouts, and Fragments*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason we use the `supportFragmentManager` property is because we are supporting
    older devices by extending `AppCompatActivity`. If we simply extended `Activity`,
    then we could use the `fragmentManager` property. The downside is that the app
    won't run on many older devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run the app and admire our new dialog window that appears when we
    click the button in the layout. Notice that clicking either of the buttons in
    the dialog window will close it; this is the default behavior. The following screenshot
    shows our dialog window in action on the tablet emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the DialogFragment class](img/B12806_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will make two more classes that implement dialogs as the first phase
    of our multi-chapter Note to self app. We will see that a dialog window can have
    almost any layout we choose, and that we don't have to rely on the simple layouts
    that the `Dialog.Builder` class provided us with.
  prefs: []
  type: TYPE_NORMAL
- en: The Note to self app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the first of the multi-chapter apps that we will implement in this
    book. When we do these projects, we will do them more professionally than we do
    the smaller apps. In this project, we will use String resources instead of hardcoding
    the text in the layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, these things can be overkill when you are trying to learn a new Android
    or Kotlin topic, but they are useful and important to start using as soon as possible
    in real projects. They soon become like second nature and the quality of our apps
    will benefit from it.
  prefs: []
  type: TYPE_NORMAL
- en: Using String resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 3,](ch03.html "Chapter 3. Exploring Android Studio and the Project
    Structure") *Exploring Android Studio and the Project Structure*, we discussed
    using String resources instead of hardcoding text in our layout files. There were
    a few benefits of doing things this way, but it was also slightly long-winded.
  prefs: []
  type: TYPE_NORMAL
- en: As this is our first multi-chapter project, it is a good time to do things the
    right way. If you want a quick refresher on the benefits of String resources,
    refer back to [Chapter 3,](ch03.html "Chapter 3. Exploring Android Studio and
    the Project Structure") *Exploring Android Studio and the Project Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: How to get the code files for the Note to self app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fully-completed app, including all the code and resources, can be found
    in the `Chapter18/Note to self` folder within the download bundle. As we are implementing
    this app over the next five chapters, it will be useful to see the part-completed,
    runnable app at the end of every chapter as well. The part-completed, runnable
    apps and all their associated code and resources can be found in their respective
    folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chapter14/Note to self`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chapter16/Note to self`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chapter17/Note to self`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chapter18/Note to self`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no Note to self code in [Chapter 15](ch15.html "Chapter 15. Handling
    Data and Generating Random Numbers"), *Handling Data and Generating Random Numbers*,
    because although we will learn about topics we use in Note to self, we don't make
    the changes to the app until [Chapter 16](ch16.html "Chapter 16. Adapters and
    Recyclers"), *Adapters and Recyclers*.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that each of these folders contains a separate, runnable project, and
    is also contained within its own unique package. This is so that you can easily
    see the app running as it would do after completing a given chapter. When copying
    and pasting the code, be careful not to include the package name because it will
    likely be different from your package name and cause the code not to compile.
  prefs: []
  type: TYPE_NORMAL
- en: If you are following along and intend to build Note to self from start to finish,
    we will build a project simply called `Note to self`. There is still nothing stopping
    you, however, from dipping into the code files of the projects from each chapter
    to do a bit of copying and pasting at any time. Just don't copy the package directive
    from the top of a file. Additionally, be aware that at a couple of points in the
    instructions, you will be asked to remove or replace the occasional line of code
    from a previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So, even if you are copying and pasting more than you are typing the code, be
    sure to read the instructions in full and look at the code in the book for extra
    comments that might be useful.
  prefs: []
  type: TYPE_NORMAL
- en: In each chapter, the code will be presented as if you have completed the last
    chapter in full, showing code from earlier chapters, where necessary, as context
    for the new code.
  prefs: []
  type: TYPE_NORMAL
- en: Each chapter will not be solely devoted to the Note to self app. We will learn
    about other related things and build some smaller and simpler apps as well. So,
    when we come to the Note to self implementation, we will be technically prepared
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: The completed app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following features and screenshots are from the completed app. It will obviously
    look slightly different to this at the various stages of development. Where necessary,
    we will look at more images, either as a reminder, or to see the differences throughout
    the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed app will allow the user to tap thefloating button icon in the
    bottom-right corner of the app to open a dialog window to add a new note. The
    following screenshot shows this highlighted feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The completed app](img/B12806_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The screenshot on the left shows the button to tap, and the screenshot on the
    right shows the dialog window where the user can add a new note.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, as the user adds more notes, they will have a list of all the notes
    they have added on the main screen of the app, as shown in the following screenshot.
    The user can select whether the note is **Important**, an **Idea**, and/or a **To
    do** note:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The completed app](img/B12806_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'They will be able to scroll the list and tap on a note to see it shown in another
    dialog window dedicated to that note. Here is that dialog window showing a note:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The completed app](img/B12806_14_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There will also be a simple (very simple) settings screen that is accessible
    from the menu that will allow the user to configure whether the note list is formatted
    with a dividing line. Here is the settings menu option in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The completed app](img/B12806_14_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we know exactly what we are going to build, we can go ahead and start to
    implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Building the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create our new project now. Call the project `Note to Self` and use the
    **Basic Activity** template. Remember from [Chapter 3,](ch03.html "Chapter 3. Exploring
    Android Studio and the Project Structure") *Exploring Android Studio and the Project
    Structure,* that this template will generate a simple menu and a floating action
    button, which are both used in this project. Leave the other settings at their
    default settings.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the String resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will create all the String resources that we will refer to from our
    layout files instead of hardcoding the `text` property, as we have been doing
    up until now. Strictly speaking, this is a step that can be avoided. However,
    if you are looking to make in-depth Android apps, you will benefit from learning
    to do things this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, open the `strings.xml` file from the `res/values` folder in
    the project explorer. You will see the autogenerated resources. Add the following
    highlighted String resources that we will use in our app throughout the rest of
    the project. Add the code before the closing `</resources>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Observe in the preceding code that each String resource has a `name` attribute
    that is unique and distinguishes it from all the others. The `name` attribute
    also provides a meaningful and, hopefully, memorable clue as to the actual String
    value it represents. It is these name values that we will use to refer to the
    String that we want to use from within our layout files.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Note class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the fundamental data structure of the app. It is a class we will write
    ourselves from scratch and it has all the properties that we need to represent
    a single user note. In [Chapter 15,](ch15.html "Chapter 15. Handling Data and
    Generating Random Numbers") *Handling Data and Generating Random Numbers,* we
    will learn some new Kotlin code to gain an understanding of how we can let the
    user have dozens, hundreds, or even thousands of notes.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class by right-clicking on the folder with the name as your package
    – as usual, the one that contains the `MainActivity.kt` file. Select **New** |
    **Kotlin File/class**, name it `Note`, and select **Class** from the drop-down
    selector. Left-click on **OK** to create the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the new `Note` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have a simple class with no functions, called `Note`. The class has five
    `var` properties called `title`, `description`, `idea`, `todo`, and `important`.
    Their uses are to hold the title of the user's note, the description (or contents)
    of the note, and to detail whether the note is an idea, a to-do, or an important
    note, respectively. Let's now design the layout of the two dialog windows.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the dialog designs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we will do something that we have done many times before, but this time,
    for a different reason. As you know, we will have two dialog windows – one for
    the user to enter a new note, and one for the user to view a note of their choice.
  prefs: []
  type: TYPE_NORMAL
- en: We can design the layouts of these two dialog windows in the same way that we
    have designed all our previous layouts. When we come to create the Kotlin code
    for the `FragmentDialog` classes, we will then learn how to incorporate these
    layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a layout for our "new note" dialog by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `layout` folder in the project explorer and select **New**
    | **Layout resource file**. Enter `dialog_new_note` in the **File name:** field
    and then start typing `Constrai` for the **Root element:** field. Notice that
    there is a drop-down list with multiple options that start with **Constrai…**.
    Now select **androidx.constraintlayout.widget.ConstraintLayout**. Left-click on
    **OK** to generate the new layout file that will have the `ConstraintLayout` type
    as its root element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the target design in the following screenshot while following the rest
    of these instructions. I have photoshopped together the finished layout, including
    the constraints that we will soon autogenerate, next to the layout, with the constraints
    hidden for extra clarity:![Implementing the dialog designs](img/B12806_14_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop a **Plain Text** widget (from the **Text** category) to the very
    top and left of the layout, and then add another **Plain Text** below it. Don't
    worry about any of the attributes for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop three **CheckBox** widgets from the **Button** category, one below
    the other. Look at the previous reference screenshot for guidance. Again, don't
    worry about any attributes for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop two **Buttons** onto the layout, the first directly below the
    last **CheckBox** widget from the previous step, and the second horizontally in
    line with the first **Button** widget, but fully over to the right of the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tidy up the layout so that it resembles the reference screenshot as closely
    as possible, and then click on the **Infer Constraints** button to fix the positions
    that you have chosen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can set up all our `text`, `id`, and `hint` properties. You can do so
    by using the values from this next table. Remember that we are using our String
    resources for the `text` and `hint` properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you edit the first `id` property, you may be shown a pop-up window asking
    for confirmation of your changes. Check the box for **Don''t ask again during
    this session** and click on **Yes** to continue, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the dialog designs](img/B12806_14_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the values to enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Widget type** | **Property** | **Value to set to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Plain Text (top) | id | `editTitle` |'
  prefs: []
  type: TYPE_TB
- en: '| Plain Text (top) | hint | `@string/title_hint` |'
  prefs: []
  type: TYPE_TB
- en: '| Plain Text (bottom) | id | `editDescription` |'
  prefs: []
  type: TYPE_TB
- en: '| Plain Text (bottom) | hint | `@string/description_hint` |'
  prefs: []
  type: TYPE_TB
- en: '| Plain Text (bottom) | inputType | textMultiLine (uncheck any other options)
    |'
  prefs: []
  type: TYPE_TB
- en: '| CheckBox (top) | id | `checkBoxIdea` |'
  prefs: []
  type: TYPE_TB
- en: '| CheckBox (top) | text | `@string/idea_text` |'
  prefs: []
  type: TYPE_TB
- en: '| CheckBox (middle) | id | `checkBoxTodo` |'
  prefs: []
  type: TYPE_TB
- en: '| CheckBox (middle) | text | `@string/todo_text` |'
  prefs: []
  type: TYPE_TB
- en: '| CheckBox (bottom) | id | `checkBoxImportant` |'
  prefs: []
  type: TYPE_TB
- en: '| CheckBox (bottom) | text | `@string/important_text` |'
  prefs: []
  type: TYPE_TB
- en: '| Button (left) | id | `btnCancel` |'
  prefs: []
  type: TYPE_TB
- en: '| Button (left) | text | `@string/cancel_button` |'
  prefs: []
  type: TYPE_TB
- en: '| Button (right) | id | `btnOK` |'
  prefs: []
  type: TYPE_TB
- en: '| Button (right) | text | `@string/ok_button` |'
  prefs: []
  type: TYPE_TB
- en: We now have a nice neat layout ready for our Kotlin code to display. Be sure
    to keep in mind the `id` value of the different widgets because we will see them
    in action when we write our code. The important thing is that our layout looks
    nice and has an `id` value for every relevant item, so that we can get a reference
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s lay out our dialog box to show a note to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the **layout** folder in the project explorer and select **New
    | Layout resource file**. Enter `dialog_show_note` for the **File name:** field,
    and then start typing `Constrai` for the **Root element:** field. Notice that
    there is a drop-down list with multiple options that start with **Constrai…**.
    Now select **androidx.constraintlayout.widget.ConstraintLayout**. Left-click on
    **OK** to generate the new layout file that will have the `ConstraintLayout` type
    as its root element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the target design in the next screenshot, while following the rest
    of these instructions. I have photoshopped together the finished layout including
    the constraints we will soon autogenerate, next to the layout, with the constraints
    hidden for extra clarity:![Implementing the dialog designs](img/B12806_14_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, drag and drop three **TextView** widgets, vertically aligned across the
    top of the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, drag and drop another **TextView** widget just below the center of the
    three previous `TextView` widgets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another **TextView** widget just below the previous one, but on the left
    side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add a **Button** horizontally and centrally, and near the bottom of the
    layout. This is what it should look like so far:![Implementing the dialog designs](img/B12806_14_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tidy up the layout so that it resembles the reference screenshot as closely
    as possible, and then click on the **Infer Constraints** button to fix the positions
    that you have chosen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure the attributes from the following table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Widget type** | **Attribute** | **Value to set to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| TextView (top-left) | `id` | `textViewImportant` |'
  prefs: []
  type: TYPE_TB
- en: '| TextView (top-left) | `text` | `@string/important_text` |'
  prefs: []
  type: TYPE_TB
- en: '| TextView (top-center) | `id` | `textViewTodo` |'
  prefs: []
  type: TYPE_TB
- en: '| TextView (top-center) | `text` | `@string/todo_text` |'
  prefs: []
  type: TYPE_TB
- en: '| TextView (top-right) | `id` | `textViewIdea` |'
  prefs: []
  type: TYPE_TB
- en: '| TextView (top-right) | `text` | `@string/idea_text` |'
  prefs: []
  type: TYPE_TB
- en: '| TextView (center, second row) | `id` | `txtTitle` |'
  prefs: []
  type: TYPE_TB
- en: '| TextView (center, second row) | `textSize` | `24sp` |'
  prefs: []
  type: TYPE_TB
- en: '| TextView (last one added) | `id` | `txtDescription` |'
  prefs: []
  type: TYPE_TB
- en: '| Button | `id` | `btnOK` |'
  prefs: []
  type: TYPE_TB
- en: '| Button | `text` | `@string/ok_button` |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the preceding changes, you might want to tweak the final positions of
    some of the UI elements by dragging them around the screen since we have adjusted
    their size and contents. First, click on **Clear all Constraints**, then tweak
    the layout to be how you want it, and finally, click on **Infer Constraints**
    to constrain the positions again.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a layout that we can use for showing a note to the user. Notice
    that we get to reuse some string resources. The bigger our apps get, the more
    beneficial it is to do things this way.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the dialog boxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a design for both of our dialog windows ("show note" and "new
    note"), we can use what we know about the `FragmentDialog` class to implement
    a class to represent each of the dialog windows that the user can interact with.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the "new note" screen.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the DialogNewNote class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a new class by right-clicking on the project folder that has the `.kt`
    files and choose **New** | **Kotlin File/Class**. Name the `DialogNewNote` class
    and select **Class** in the drop-down selector. Click on **OK** to generate the
    new class.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, change the class declaration and inherit from `DialogFragment`. Also,
    override the `onCreateDialog` function, which is where all the rest of the code
    in this class will go. Make your code the same as the following in order to achieve
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to add these new imports as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We temporarily have an error in the new class because we need a `return` statement
    in the `onCreateDialog` function, but we will get to that in just a moment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next block of code, which we will add in a moment, first we declare and
    initialize an `AlertDialog.Builder` object as we have previously done when creating
    dialog windows. This time, however, we will not use this object as much as we
    have before.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we initialize a `LayoutInflater` object, which we will use to inflate
    our XML layout. "Inflate" simply means to turn our XML layout into a Kotlin object.
    Once this has been done, we can then access all our widgets in the usual way.
    We can think of `inflater.inflate` replacing the `setContentView` function call
    for our dialog. And, in the second line, we do just that with the `inflate` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the three lines of code that we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To support the new classes in the previous three lines of code, you will need
    to add the following `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We now have a `View` object called `dialogView` that has all the UI elements
    from our `dialog_new_note.xml` layout file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, underneath the previous block of code, we will add the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will get a reference to each of the UI widgets. Add this following
    code just after the previous block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Be sure to add the following `import` code to make the code you just added
    error-free:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is a new Kotlin feature in the preceding code that is known as the `as`
    keyword; for example, `as EditText`, `as CheckBox`, and `as Button`. This feature
    is used because there is no way for the compiler to infer the specific type of
    each of the UI widgets. Try deleting one of the `as…` keywords from the code and
    notice the error that arises. Using the `as` keyword (because we do know the type)
    overcomes this problem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next code block, we will set the message of the dialog using the `builder`
    instance. Then, we will write a lambda to handle clicks on `btnCancel`. In the
    overridden `onClick` function, we will simply call `dismiss()`, which is a function
    of `DialogFragment`, to close the dialog window. This is just what we need should
    the user click on **Cancel**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code that we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we will add a lambda to handle what happens when the user clicks on the
    **OK** button (`btnOK`).
  prefs: []
  type: TYPE_NORMAL
- en: Inside it, we create a new `Note` called `newNote`. Then, we set each of the
    properties from `newNote` to the appropriate content of the form.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we use a reference to `MainActivity` to call the `createNewNote`
    function in `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we have not written this `createNewNote` function yet, and the function
    call will show an error until we do so later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The argument sent in this function is our newly initialized `newNote` object.
    This has the effect of sending the user's new note back to `MainActivity`. We
    will see what we do with this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call `dismiss` to close the dialog window. Add the code that we
    have been discussing after the previous block of code that we added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's our first dialog window done. We haven't wired it up to appear from `MainActivity`
    yet, and we need to implement the `createNewNote` function too. We will do this
    right after we create the next dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the DialogShowNote class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a new class by right-clicking on the project folder that contains all
    the `.kt` files and choose **New** | **Kotlin File/Class**. Name the `DialogShowNote`
    class, then choose **Class** in the drop-down selector, and click on **OK** to
    generate the new class.
  prefs: []
  type: TYPE_NORMAL
- en: First, change the class declaration and inherit from `DialogFragment`, and then
    override the `onCreateDialog` function. As most of the code for this class goes
    in the `onCreateDialog` function, implement the signature and empty body as shown
    in the following code and we will revisit it in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we declare a `var` property, `note`, of the `Note` type. In addition,
    add the `sendNoteSelected` function and its single line of code that initializes
    `note`. This function will be called by `MainActivity` and it will pass in the
    `Note` object that the user has clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code that we have just discussed, and then we can look at the details
    of `onCreateDialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, you will need to import the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, we declare and initialize an instance of `AlertDialog.Builder`. Next,
    as we did for `DialogNewNote`, we declare and initialize `LayoutInflater`, and
    then use it to create a `View` object that has the layout for the dialog. In this
    case, it is the layout from `dialog_show_note.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the following block of code, we get a reference to each of the UI
    widgets and set the `text` properties on `txtTitle` and `textDescription` using
    the appropriate related properties from `note`, which was initialized in the `sendNoteSelected`
    function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code that we have just discussed within the `onCreateDialog` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the following `import` statements to make all the classes in the previous
    code available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This next code is also in the `onCreateDialog` function. It checks whether the
    note being shown is "important", and then shows or hides the `txtImportant TextView`
    widget accordingly. We then do the same for the `txtTodo` and `txtIdea` widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code after the previous block of code, while still in the `onCreateDialog`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: All we need to do now is `dismiss` (that is, close) the dialog window when the
    user clicks on the **OK** button. This is done with a lambda, as we have seen
    several times already. The `onClick` function simply calls the `dismiss` function
    that closes the dialog window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code to the `onCreateDialog` function after the previous block of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Import the `Button` class with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We now have two dialog windows ready to roll. We just must add some code to
    the `MainActivity` class to finish the job.
  prefs: []
  type: TYPE_NORMAL
- en: Showing and using our new dialogs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a new temporary property just after the `MainActivity` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code won't be in the final app; it is just so we can test our dialog windows
    right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add this function so that we can receive a new note from the `DialogNewNote`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, to send a note to the `DialogShowNote` function, we need to add a button
    with the `button` `id` to the `layout_main.xml` layout file.
  prefs: []
  type: TYPE_NORMAL
- en: 'So that it is clear what this button is for, we will change its `text` attribute
    to `Show Note`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a `Button` widget onto `layout_main.xml`, and configure its `id` as `button`
    and `text` as `Show Note`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the **Infer Constraints** button so that the button stays where you
    put it. The exact position of this button is not important at this stage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just to clarify, this is a temporary button for testing purposes and will not
    be used in the final app. At the end of development, we will click on a note's
    title from a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `onCreate` function, we will set up a lambda to handle clicks on
    our temporary button. The code in `onClick` will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `DialogShowNote` instance that is simply called `dialog`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `sendNoteSelected` function on `dialog` to pass in our `Note` object,
    called `tempNote`, as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it will call `show`, which breathes life into our new dialog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the code described previously to the `onCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Be sure to import the `Button` class with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now summon our `DialogShowNote` dialog window at the click of a button.
    Run the app and click on the **SHOW NOTE** button to see the `DialogShowNote`
    dialog with the `dialog_show_note.xml` layout, as demonstrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing and using our new dialogs](img/B12806_14_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Admittedly, this is not much to look at considering how much coding we have
    done in this chapter, but when we get the `DialogNewNote` class working, we will
    see how `MainActivity` interacts and shares data between the two dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make the `DialogNewNote` dialog useable.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the floating action button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is going to be easy. The floating action button was provided for us in
    the layout. By way of a reminder, this is the floating action button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the floating action button](img/B12806_14_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is in the `activity_main.xml` file. This is the XML code that positions
    and defines its appearance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Android Studio has even provided a ready-made lambda to handle clicks on the
    floating action button. All we need to do is add some code to the `onClick` function
    of this already provided code and we can use the `DialogNewNote` class.
  prefs: []
  type: TYPE_NORMAL
- en: The floating action button is usually used for a core action of an app. For
    example, in an email app, it will probably be used to start a new email; or, in
    a note-keeping app, it will probably be used to add a new note. So, let's do that
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity.kt`, find the autogenerated code provided by Android Studio
    in the `MainActivity.kt` class in the `onCreate` function; here is the code in
    its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, note the highlighted line and delete it. Now add the
    following code in place of the deleted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The new code creates a new dialog window of the `DialogNewNote` variety and
    then shows it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the app; tap the floating action button and add a note along
    the lines of the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the floating action button](img/B12806_14_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **OK** to save the note and return to the main layout. Next, we can
    tap the **Show Note** button to see it in a dialog window like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the floating action button](img/B12806_14_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Be aware that if you add a second note, it will overwrite the first because
    we only have one `Note` instance. Furthermore, if you turn the phone off, or fully
    shut down the app, then the note is lost forever. We need to cover some more Kotlin
    in order to solve these problems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen and implemented a common UI design with dialog
    windows using the `DialogFragment` class.
  prefs: []
  type: TYPE_NORMAL
- en: We went a step further when we started the Note to self app by implementing
    more complicated dialogs that can capture information from the user. We saw that
    `DialogFragment` enables us to have any UI we like in a dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin to deal with the obvious problem whereby
    the user can only have one note, by exploring Kotlin's data handling classes.
  prefs: []
  type: TYPE_NORMAL
