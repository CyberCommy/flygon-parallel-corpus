- en: Chapter 14. Generating Non-HTML Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually when we talk about developing websites, we''re talking about producing
    HTML. Of course, there''s a lot more to the web than HTML; we use the web to distribute
    data in all sorts of formats: RSS, PDFs, images, and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve focused on the common case of HTML production, but in this chapter
    we''ll take a detour and look at using Django to produce other types of content.
    Django has convenient built-in tools that you can use to produce some common non-HTML
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: Comma-delimited (CSV) files for importing into spreadsheet applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDF files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSS/Atom syndication feeds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sitemaps (an XML format originally developed by Google that gives hints to search
    engines).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll examine each of those tools a little later, but first we'll cover the
    basic principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basics: views and MIME types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall from [Chapter 2](ch02.xhtml "Chapter 2. Views and URLconfs"), *Views
    and URLconfs*, that a view function is simply a Python function that takes a web
    request and returns a web response. This response can be the HTML contents of
    a web page, or a redirect, or a 404 error, or an XML document, or an image ...or
    anything, really. More formally, a Django view function must*:*
  prefs: []
  type: TYPE_NORMAL
- en: Accept an `HttpRequest` instance as its first argument; and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return an `HttpResponse` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key to returning non-HTML content from a view lies in the `HttpResponse`
    class, specifically the `content_type` argument. By default, Django sets `content_type`
    to text/html. You can however, set `content_type` to any of the official Internet
    media types (MIME types) managed by IANA (for more information visit [http://www.iana.org/assignments/media-types/media-types.xhtml](http://www.iana.org/assignments/media-types/media-types.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: 'By tweaking the MIME type, we can indicate to the browser that we''ve returned
    a response of a different format. For example, let''s look at a view that returns
    a PNG image. To keep things simple, we''ll just read the file off the disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That's it! If you replace the image path in the `open()` call with a path to
    a real image, you can use this very simple view to serve an image, and the browser
    will display it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The other important thing to keep in mind is that `HttpResponse` objects implement
    Python's standard file-like object API. This means that you can use an `HttpResponse`
    instance in any place Python (or a third-party library) expects a file. For an
    example of how that works, let's take a look at producing CSV with Django.
  prefs: []
  type: TYPE_NORMAL
- en: Producing CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python comes with a CSV library, `csv`. The key to using it with Django is
    that the `csv` module''s CSV-creation capability acts on file-like objects, and
    Django''s `HttpResponse` objects are file-like objects. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The code and comments should be self-explanatory, but a few things deserve
    a mention:'
  prefs: []
  type: TYPE_NORMAL
- en: The response gets a special MIME type, `text/csv`. This tells browsers that
    the document is a CSV file, rather than an HTML file. If you leave this off, browsers
    will probably interpret the output as HTML, which will result in ugly, scary gobbledygook
    in the browser window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response gets an additional `Content-Disposition` header, which contains
    the name of the CSV file. This filename is arbitrary; call it whatever you want.
    It'll be used by browsers in the Save as... dialogue, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hooking into the CSV-generation API is easy: Just pass `response` as the first
    argument to `csv.writer`. The `csv.writer` function expects a file-like object,
    and `HttpResponse` objects fit the bill.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each row in your CSV file, call `writer.writerow`, passing it an iterable
    object such as a list or tuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CSV module takes care of quoting for you, so you don't have to worry about
    escaping strings with quotes or commas in them. Just pass `writerow()` your raw
    strings, and it'll do the right thing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming large CSV files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When dealing with views that generate very large responses, you might want
    to consider using Django''s `StreamingHttpResponse` instead. For example, by streaming
    a file that takes a long time to generate you can avoid a load balancer dropping
    a connection that might have otherwise timed out while the server was generating
    the response. In this example, we make full use of Python generators to efficiently
    handle the assembly and transmission of a large CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using the template system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alternatively, you can use the Django template system to generate CSV. This
    is lower-level than using the convenient Python `csv` module, but the solution
    is presented here for completeness. The idea here is to pass a list of items to
    your template, and have the template output the commas in a `for` loop. Here''s
    an example, which generates the same CSV file as above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference between this example and the previous example is that this
    one uses template loading instead of the CSV module. The rest of the code-such
    as the `content_type=''text/csv''`-is the same. Then, create the template `my_template_name.txt`,
    with this template code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This template is quite basic. It just iterates over the given data and displays
    a line of CSV for each row. It uses the `addslashes` template filter to ensure
    there aren't any problems with quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Other text-based formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice that there isn't very much specific to CSV here-just the specific output
    format. You can use either of these techniques to output any text-based format
    you can dream of. You can also use a similar technique to generate arbitrary binary
    data; For example, generating PDFs.
  prefs: []
  type: TYPE_NORMAL
- en: Generating PDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django is able to output PDF files dynamically using views. This is made possible
    by the excellent, open-source ReportLab (for more information visit [http://www.reportlab.com/opensource/](http://www.reportlab.com/opensource/))
    Python PDF library. The advantage of generating PDF files dynamically is that
    you can create customized PDFs for different purposes-say, for different users
    or different pieces of content.
  prefs: []
  type: TYPE_NORMAL
- en: Install ReportLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **ReportLab** library is available on PyPI. A user guide (not coincidentally,
    a PDF file) is also available for download. You can install ReportLab with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Test your installation by importing it in the Python interactive interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If that command doesn't raise any errors, the installation worked.
  prefs: []
  type: TYPE_NORMAL
- en: Write your view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The key to generating PDFs dynamically with Django is that the ReportLab API,
    like the `csv` library acts on file-like objects, like Django''s `HttpResponse`.
    Here''s a Hello World example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code and comments should be self-explanatory, but a few things deserve
    a mention:'
  prefs: []
  type: TYPE_NORMAL
- en: The response gets a special MIME type, `application/pdf`. This tells browsers
    that the document is a PDF file, rather than an HTML file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The response gets an additional `Content-Disposition` header, which contains
    the name of the PDF file. This filename is arbitrary: Call it whatever you want.
    It''ll be used by browsers in the Save as... dialogue, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Content-Disposition` header starts with `''attachment; ''` in this example.
    This forces web browsers to pop-up a dialog box prompting/confirming how to handle
    the document even if a default is set on the machine. If you leave off `''attachment;''`,
    browsers will handle the PDF using whatever program/plugin they''ve been configured
    to use for PDFs. Here''s what that code would look like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Hooking into the ReportLab API is easy: Just pass `response` as the first argument
    to `canvas.Canvas`. The `Canvas` class expects a file-like object, and `HttpResponse`
    objects fit the bill.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that all subsequent PDF-generation methods are called on the PDF object
    (in this case, `p`)-not on `response`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it's important to call `showPage()` and `save()` on the PDF file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex PDF's
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re creating a complex PDF document with ReportLab, consider using the
    `io` library as a temporary holding place for your PDF file. This library provides
    a file-like object interface that is particularly efficient. Here''s the above
    Hello World example re-written to use `io`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Further resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PDFlib ([http://www.pdflib.org/](http://www.pdflib.org/)) is another PDF-generation
    library that has Python bindings. To use it with Django, just use the same concepts
    explained in this article.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pisa XHTML2PDF ([http://www.xhtml2pdf.com/](http://www.xhtml2pdf.com/)) is yet
    another PDF-generation library. Pisa ships with an example of how to integrate
    Pisa with Django.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTMLdoc ([http://www.htmldoc.org/](http://www.htmldoc.org/)) is a command-line
    script that can convert HTML to PDF. It doesn't have a Python interface, but you
    can escape out to the shell using `system` or `popen` and retrieve the output
    in Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other possibilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s a whole host of other types of content you can generate in Python.
    Here are a few more ideas and some pointers to libraries you could use to implement
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ZIP****files**: Python''s standard library ships with the `zipfile` module,
    which can both read and write compressed ZIP files. You could use it to provide
    on-demand archives of a bunch of files, or perhaps compress large documents when
    requested. You could similarly produce TAR files using the standard library''s
    `tarfile` module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic ****images**: The **Python Imaging Library** (**PIL**) ([http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/))
    is a fantastic toolkit for producing images (PNG, JPEG, GIF, and a whole lot more).
    You could use it to automatically scale down images into thumbnails, composite
    multiple images into a single frame, or even do web-based image processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plots and charts**: There are a number of powerful Python plotting and charting
    libraries you could use to produce on-demand maps, charts, plots, and graphs.
    We can''t possibly list them all, so here are a couple of the highlights:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matplotlib` ([http://matplotlib.sourceforge.net/](http://matplotlib.sourceforge.net/))
    can be used to produce the type of high-quality plots usually generated with MatLab
    or Mathematica.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygraphviz` ([http://networkx.lanl.gov/pygraphviz/](http://networkx.lanl.gov/pygraphviz/)),
    an interface to the Graphviz graph layout toolkit, can be used for generating
    structured diagrams of graphs and networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, any Python library capable of writing to a file can be hooked into
    Django. The possibilities are immense. Now that we've looked at the basics of
    generating non-HTML content, let's step up a level of abstraction. Django ships
    with some pretty nifty built-in tools for generating some common types of non-HTML
    content.
  prefs: []
  type: TYPE_NORMAL
- en: The syndication feed framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django comes with a high-level syndication-feed-generating framework that makes
    creating RSS and Atom feeds easy. RSS and Atom are both XML-based formats you
    can use to provide automatically updating feeds of your site's content. Read more
    about RSS here ([http://www.whatisrss.com/](http://www.whatisrss.com/)), and get
    information on Atom here ([http://www.atomenabled.org/](http://www.atomenabled.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: To create any syndication feed, all you have to do is write a short Python class.
    You can create as many feeds as you want. Django also comes with a lower-level
    feed-generating API. Use this if you want to generate feeds outside of a web context,
    or in some other lower-level way.
  prefs: []
  type: TYPE_NORMAL
- en: The high-level framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The high-level feed-generating framework is supplied by the `Feed` class. To
    create a feed, write a `Feed` class and point to an instance of it in your URLconf.
  prefs: []
  type: TYPE_NORMAL
- en: Feed classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Feed` class is a Python class that represents a syndication feed. A feed
    can be simple (for example, a site news feed, or a basic feed displaying the latest
    entries of a blog) or more complex (for example, a feed displaying all the blog
    entries in a particular category, where the category is variable). Feed classes
    subclass `django.contrib.syndication.views.Feed`. They can live anywhere in your
    codebase. Instances of `Feed` classes are views which can be used in your URLconf.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This simple example, taken from a hypothetical police beat news site describes
    a feed of the latest five news items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect a URL to this feed, put an instance of the Feed object in your URLconf.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Note:**'
  prefs: []
  type: TYPE_NORMAL
- en: The Feed class subclasses `django.contrib.syndication.views.Feed`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`, `link` and `description` correspond to the standard RSS `<title>`,
    `<link>` and `<description>` elements, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`items()` is, simply, a method that returns a list of objects that should be
    included in the feed as `<item>` elements. Although this example returns `NewsItem`
    objects using Django''s object-relational mapper doesn''t have to return model
    instances. Although you get a few bits of functionality for free by using Django
    models, `items()` can return any type of object you want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're creating an Atom feed, rather than an RSS feed, set the `subtitle`
    attribute instead of the `description` attribute. See Publishing Atom and RSS
    feeds in tandem later in this chapter for an example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing is left to do. In an RSS feed, each `<item>` has a `<title>`, `<link>`
    and `<description>`. We need to tell the framework what data to put into those
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: For the contents of `<title>` and `<description>`, Django tries calling the
    methods `item_title()` and `item_description()` on the `Feed` class. They are
    passed a single parameter, `item`, which is the object itself. These are optional;
    by default, the unicode representation of the object is used for both.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to do any special formatting for either the title or description,
    Django templates can be used instead. Their paths can be specified with the `title_template`
    and `description_template` attributes on the `Feed` class. The templates are rendered
    for each item and are passed two template context variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{ obj }}`-: The current object (one of whichever objects you returned in
    `items()`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{ site }}`-: A Django `site` object representing the current site. This is
    useful for `{{ site.domain }}` or `{{ site.name }}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See *A complex example* below that uses a description template.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a way to pass additional information to title and description
    templates, if you need to supply more than the two variables mentioned before.
    You can provide your implementation of `get_context_data` method in your `Feed`
    subclass. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be called once per item in the list returned by `items()`
    with the following keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`item`: the current item. For backward compatibility reasons, the name of this
    context variable is `{{ obj }}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`obj`: the object returned by `get_object()`. By default, this is not exposed
    to the templates to avoid confusion with `{{ obj }}` (see above), but you can
    use it in your implementation of `get_context_data()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`site`: current site as described above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request`: current request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The behavior of `get_context_data()` mimics that of generic views-you're supposed
    to call `super()` to retrieve context data from the parent class, add your data
    and return the modified dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: To specify the contents of `<link>`, you have two options. For each item in
    `items()`, Django first tries calling the `item_link()` method on the `Feed` class.
    In a similar way to the title and description, it's passed a single parameter-`item`.
    If that method doesn't exist, Django tries executing a `get_absolute_url()` method
    on that object.
  prefs: []
  type: TYPE_NORMAL
- en: Both `get_absolute_url()` and `item_link()` should return the item's URL as
    a normal Python string. As with `get_absolute_url()`, the result of `item_link()`
    will be included directly in the URL, so you are responsible for doing all necessary
    URL quoting and conversion to ASCII inside the method itself.
  prefs: []
  type: TYPE_NORMAL
- en: A complex example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The framework also supports more complex feeds, via arguments. For example,
    a website could offer an RSS feed of recent crimes for every police beat in a
    city. It'd be silly to create a separate `Feed` class for each police beat; that
    would violate the DRY principle and would couple data to programming logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, the syndication framework lets you access the arguments passed from
    your URLconf so feeds can output items based on information in the feed''s URL.
    The police beat feeds could be accessible via URLs like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/beats/613/rss/`-: Returns recent crimes for beat 613.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/beats/1424/rss/`-: Returns recent crimes for beat 1424.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These can be matched with a URLconf line such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Like a view, the arguments in the URL are passed to the `get_object()` method
    along with the request object. Here''s the code for these beat-specific feeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To generate the feed's `<title>`, `<link>` and `<description>`, Django uses
    the `title()`, `link()` and `description()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, they were simple string class attributes, but this
    example illustrates that they can be either strings *or* methods. For each of
    `title`, `link` and `description`, Django follows this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it tries to call a method, passing the `obj` argument, where `obj` is
    the object returned by `get_object()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing that, it tries to call a method with no arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing that, it uses the class attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also note that `items()` also follows the same algorithm-first, it tries `items(obj)`,
    then `items()`, then finally an `items` class attribute (which should be a list).
    We are using a template for the item descriptions. It can be very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, you are free to add formatting as desired. The `ExampleFeed` class
    below gives full documentation on methods and attributes of `Feed` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the type of feed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, feeds produced in this framework use RSS 2.0\. To change that,
    add a `feed_type` attribute to your `Feed` class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you set `feed_type` to a class object, not an instance. Currently
    available feed types are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`django.utils.feedgenerator.Rss201rev2Feed` (RSS 2.01\. Default.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django.utils.feedgenerator.RssUserland091Feed` (RSS 0.91.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django.utils.feedgenerator.Atom1Feed` (Atom 1.0.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enclosures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To specify enclosures, such as those used in creating podcast feeds, use the
    `item_enclosure_url`, `item_enclosure_length` and `item_enclosure_mime_type` hooks.
    See the `ExampleFeed` class below for usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Feeds created by the syndication framework automatically include the appropriate
    `<language>` tag (RSS 2.0) or `xml:lang` attribute (Atom). This comes directly
    from your `LANGUAGE_CODE` setting.
  prefs: []
  type: TYPE_NORMAL
- en: URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `link` method/attribute can return either an absolute path (for example,
    `/blog/`) or a URL with the fully-qualified domain and protocol (for example,
    `http://www.example.com/blog/`). If `link` doesn't return the domain, the syndication
    framework will insert the domain of the current site, according to your `SITE_ID`
    setting. Atom feeds require a `<link rel="self">` that defines the feed's current
    location. The syndication framework populates this automatically, using the domain
    of the current site according to the `SITE_ID` setting.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing Atom and RSS Feeds in tandem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some developers like to make available both Atom and RSS versions of their
    feeds. That''s easy to do with Django: Just create a subclass of your `Feed` class
    and set the `feed_type` to something different. Then update your URLconf to add
    the extra versions. Here''s a full example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, the RSS feed uses a `description` while the Atom feed uses
    a `subtitle`. That's because Atom feeds don't provide for a feed-level description,
    but they do provide for a subtitle. If you provide a `description` in your `Feed`
    class, Django will not automatically put that into the `subtitle` element, because
    a subtitle and description are not necessarily the same thing. Instead, you should
    define a `subtitle` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the above example, we simply set the Atom feed''s `subtitle` to the RSS
    feed''s `description`, because it''s quite short already. And the accompanying
    URLconf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For an example that illustrates all possible attributes and methods for a `Feed`
    class, see: `https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference`'
  prefs: []
  type: TYPE_NORMAL
- en: The low-level framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Behind the scenes, the high-level RSS framework uses a lower-level framework
    for generating feeds'' XML. This framework lives in a single module: `django/utils/feedgenerator.py`.
    You use this framework on your own, for lower-level feed generation. You can also
    create custom feed generator subclasses for use with the `feed_type` `Feed` option.'
  prefs: []
  type: TYPE_NORMAL
- en: SyndicationFeed classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `feedgenerator` module contains a base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`django.utils.feedgenerator.SyndicationFeed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'and several subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`django.utils.feedgenerator.RssUserland091Feed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django.utils.feedgenerator.Rss201rev2Feed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django.utils.feedgenerator.Atom1Feed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these three classes knows how to render a certain type of feed as XML.
    They share this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: SyndicationFeed.__init__()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Initialize the feed with the given dictionary of metadata, which applies to
    the entire feed. Required keyword arguments are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`link`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s also a bunch of other optional keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`language`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author_email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author_link`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subtitle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`categories`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`feed_url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`feed_copyright`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`feed_guid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ttl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any extra keyword arguments you pass to `__init__` will be stored in `self.feed`
    for use with custom feed generators.
  prefs: []
  type: TYPE_NORMAL
- en: All parameters should be Unicode objects, except `categories`, which should
    be a sequence of Unicode objects.
  prefs: []
  type: TYPE_NORMAL
- en: SyndicationFeed.add_item()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Add an item to the feed with the given parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Required keyword arguments are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`link`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional keyword arguments are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`author_email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author_link`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pubdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comments`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enclosure`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`categories`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`item_copyright`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ttl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updateddate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extra keyword arguments will be stored for custom feed generators. All parameters,
    if given, should be Unicode objects, except:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pubdate` should be a Python `datetime` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updateddate` should be a Python `datetime` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enclosure` should be an instance of `django.utils.feedgenerator.Enclosure`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`categories` should be a sequence of Unicode objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SyndicationFeed.write()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Outputs the feed in the given encoding to outfile, which is a file-like object.
  prefs: []
  type: TYPE_NORMAL
- en: SyndicationFeed.writeString()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Returns the feed as a string in the given encoding. For example, to create
    an Atom 1.0 feed and print it to standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Custom feed generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to produce a custom feed format, you've got a couple of options.
    If the feed format is totally custom, you'll want to subclass `SyndicationFeed`
    and completely replace the `write()` and `writeString()` methods. However, if
    the feed format is a spin-off of RSS or Atom (that is, GeoRSS, (link to website
    [http://georss.org/](http://georss.org/)), Apple's iTunes podcast format (link
    to website [http://www.apple.com/itunes/podcasts/specs.html](http://www.apple.com/itunes/podcasts/specs.html)),
    and so on.), you've got a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'These types of feeds typically add extra elements and/or attributes to the
    underlying format, and there are a set of methods that `SyndicationFeed` calls
    to get these extra attributes. Thus, you can subclass the appropriate feed generator
    class (`Atom1Feed` or `Rss201rev2Feed`) and extend these call-backs. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: SyndicationFeed.root_attributes(self, )
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Return a `dict` of attributes to add to the root feed element (`feed`/`channel`).
  prefs: []
  type: TYPE_NORMAL
- en: SyndicationFeed.add_root_elements(self, handler)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Callback to add elements inside the root feed element (`feed`/`channel`). `handler`
    is an `XMLGenerator` from Python's built-in SAX library; you'll call methods on
    it to add to the XML document in process.
  prefs: []
  type: TYPE_NORMAL
- en: SyndicationFeed.item_attributes(self, item)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Return a `dict` of attributes to add to each item (`item`/`entry`) element.
    The argument, `item`, is a dictionary of all the data passed to `SyndicationFeed.add_item()`.
  prefs: []
  type: TYPE_NORMAL
- en: SyndicationFeed.add_item_elements(self, handler, item)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Callback to add elements to each item (`item`/`entry`) element. `handler` and
    `item` are as above.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you override any of these methods, be sure to call the superclass methods
    since they add the required elements for each feed format.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might start implementing an iTunes RSS feed generator like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Obviously there's a lot more work to be done for a complete custom feed class,
    but the above example should demonstrate the basic idea.
  prefs: []
  type: TYPE_NORMAL
- en: The Sitemap framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **sitemap** is an XML file on your website that tells search engine indexers
    how frequently your pages change and how important certain pages are in relation
    to other pages on your site. This information helps search engines index your
    site. For more on sitemaps, see the sitemaps.org website.
  prefs: []
  type: TYPE_NORMAL
- en: The Django sitemap framework automates the creation of this XML file by letting
    you express this information in Python code. It works much like Django's syndication
    framework. To create a sitemap, just write a `Sitemap` class and point to it in
    your URLconf.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the sitemap app, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `"django.contrib.sitemaps"` to your `INSTALLED_APPS` setting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your `TEMPLATES` setting contains a `DjangoTemplates` backend whose
    `APP_DIRS` options is set to True. It's in there by default, so you'll only need
    to change this if you've changed that setting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure you've installed the sites framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To activate sitemap generation on your Django site, add this line to your URLconf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This tells Django to build a sitemap when a client accesses `/sitemap.xml`.
    The name of the sitemap file is not important, but the location is. Search engines
    will only index links in your sitemap for the current URL level and below. For
    instance, if `sitemap.xml` lives in your root directory, it may reference any
    URL in your site. However, if your sitemap lives at `/content/sitemap.xml`, it
    may only reference URLs that begin with `/content/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sitemap view takes an extra, required argument: `{''sitemaps'': sitemaps}`.
    `sitemaps` should be a dictionary that maps a short section label (for example,
    `blog` or `news`) to its `Sitemap` class (for example, `BlogSitemap` or `NewsSitemap`).
    It may also map to an instance of a `Sitemap` class (for example, `BlogSitemap(some_var)`).'
  prefs: []
  type: TYPE_NORMAL
- en: Sitemap classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Sitemap` class is a simple Python class that represents a section of entries
    in your sitemap. For example, one `Sitemap` class could represent all the entries
    of your weblog, while another could represent all of the events in your events
    calendar.
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest case, all these sections get lumped together into one `sitemap.xml`,
    but it's also possible to use the framework to generate a sitemap index that references
    individual sitemap files, one per section. (See Creating a sitemap index below.)
  prefs: []
  type: TYPE_NORMAL
- en: '`Sitemap` classes must subclass `django.contrib.sitemaps.Sitemap`. They can
    live anywhere in your codebase.'
  prefs: []
  type: TYPE_NORMAL
- en: A simple example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume you have a blog system, with an `Entry` model, and you want your
    sitemap to include all the links to your individual blog entries. Here''s how
    your sitemap class might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Note:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`changefreq` and `priority` are class attributes corresponding to `<changefreq>`
    and `<priority>` elements, respectively. They can be made callable as functions,
    as `lastmod` was in the example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`items()` is simply a method that returns a list of objects. The objects returned
    will get passed to any callable methods corresponding to a sitemap property (`location`,
    `lastmod`, `changefreq` and `priority`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastmod` should return a Python `datetime` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no `location` method in this example, but you can provide it in order
    to specify the URL for your object. By default, `location()` calls `get_absolute_url()`
    on each object and returns the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sitemap class reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `Sitemap` class can define the following methods/attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Required.** A method that returns a list of objects. The framework doesn''t
    care what *type* of objects they are; all that matters is that these objects get
    passed to the `location()`, `lastmod()`, `changefreq()` and `priority()` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: location
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Optional.** Either a method or attribute. If it''s a method, it should return
    the absolute path for a given object as returned by `items()`. If it''s an attribute,
    its value should be a string representing an absolute path to use for every object
    returned by `items()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, absolute path means a URL that doesn''t include the protocol
    or domain. Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Good: `''/foo/bar/''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bad: `''example.com/foo/bar/''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bad: `''http://example.com/foo/bar/''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `location` isn't provided, the framework will call the `get_absolute_url()`
    method on each object as returned by `items()`. To specify a protocol other than
    `http`, use `protocol`.
  prefs: []
  type: TYPE_NORMAL
- en: lastmod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Optional.** Either a method or attribute. If it''s a method, it should take
    one argument-an object as returned by `items()`-and return that object''s last-modified
    date/time, as a Python `datetime.datetime` object.'
  prefs: []
  type: TYPE_NORMAL
- en: If it's an attribute, its value should be a Python `datetime.datetime` object
    representing the last-modified date/time for *every* object returned by `items()`.
    If all items in a sitemap have a `lastmod`, the sitemap generated by `views.sitemap()`
    will have a `Last-Modified` header equal to the latest `lastmod`.
  prefs: []
  type: TYPE_NORMAL
- en: You can activate the `ConditionalGetMiddleware` to make Django respond appropriately
    to requests with an `If-Modified-Since` header which will prevent sending the
    sitemap if it hasn't changed.
  prefs: []
  type: TYPE_NORMAL
- en: changefreq
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Optional.** Either a method or attribute. If it''s a method, it should take
    one argument-an object as returned by `items()`-and return that object''s change
    frequency, as a Python string. If it''s an attribute, its value should be a string
    representing the change frequency of every object returned by `items()`. Possible
    values for `changefreq`, whether you use a method or attribute, are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''always''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''hourly''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''daily''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''weekly''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''monthly''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''yearly''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''never''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: priority
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Optional.** Either a method or attribute. If it''s a method, it should take
    one argument-an object as returned by `items()`-and return that object''s priority,
    as either a string or float.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If it''s an attribute, its value should be either a string or float representing
    the priority of every object returned by `items()`. Example values for `priority`:
    `0.4`, `1.0`. The default priority of a page is `0.5`. See the sitemaps.org documentation
    for more.'
  prefs: []
  type: TYPE_NORMAL
- en: protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Optional.** This attribute defines the protocol (`http` or `https`) of the
    URLs in the sitemap. If it isn''t set, the protocol with which the sitemap was
    requested is used. If the sitemap is built outside the context of a request, the
    default is `http`.'
  prefs: []
  type: TYPE_NORMAL
- en: i18n
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Optional.** A Boolean attribute that defines if the URLs of this sitemap
    should be generated using all of your `LANGUAGES`. The default is `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: Shortcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sitemap framework provides a convenience class for a common case-`django.contrib.syndication.GenericSitemap`
  prefs: []
  type: TYPE_NORMAL
- en: The `django.contrib.sitemaps.GenericSitemap` class allows you to create a sitemap
    by passing it a dictionary which has to contain at least a `queryset` entry. This
    queryset will be used to generate the items of the sitemap. It may also have a
    `date_field` entry that specifies a date field for objects retrieved from the
    `queryset`.
  prefs: []
  type: TYPE_NORMAL
- en: This will be used for the `lastmod` attribute in the generated sitemap. You
    may also pass `priority` and `changefreq` keyword arguments to the `GenericSitemap`
    constructor to specify these attributes for all URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an example of a URLconf using `GenericSitemap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Sitemap for static views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often you want the search engine crawlers to index views which are neither
    object detail pages nor flat pages. The solution is to explicitly list URL names
    for these views in `items` and call `reverse()` in the `location` method of the
    sitemap. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating a sitemap index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sitemap framework also has the ability to create a sitemap index that references
    individual sitemap files, one per each section defined in your `sitemaps` dictionary.
    The only differences in usage are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You use two views in your URLconf: `django.contrib.sitemaps.views.index()`
    and `django.contrib.sitemaps.views.sitemap()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `django.contrib.sitemaps.views.sitemap()` view should take a `section` keyword
    argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s what the relevant URLconf lines would look like for the example above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically generate a `sitemap.xml` file that references both `sitemap-flatpages.xml`
    and `sitemap-blog.xml`. The `Sitemap` classes and the `sitemaps` dictionary don't
    change at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should create an index file if one of your sitemaps has more than 50,000
    URLs. In this case, Django will automatically paginate the sitemap, and the index
    will reflect that. If you''re not using the vanilla sitemap view-for example,
    if it''s wrapped with a caching decorator-you must name your sitemap view and
    pass `sitemap_url_name` to the index view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Template customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you wish to use a different template for each sitemap or sitemap index available
    on your site, you may specify it by passing a `template_name` parameter to the
    `sitemap` and `index` views via the URLconf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Context variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When customizing the templates for the `index()` and `sitemap()` views, you
    can rely on the following context variables.
  prefs: []
  type: TYPE_NORMAL
- en: Index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The variable `sitemaps` is a list of absolute URLs to each of the sitemaps.
  prefs: []
  type: TYPE_NORMAL
- en: Sitemap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The variable `urlset` is a list of URLs that should appear in the sitemap.
    Each URL exposes attributes as defined in the `Sitemap` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`changefreq`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`item`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastmod`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`priority`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `item` attribute has been added for each URL to allow more flexible customization
    of the templates, such as Google news sitemaps. Assuming Sitemap''s `items()`
    would return a list of items with `publication_data` and a `tags` field something
    like this would generate a Google compatible sitemap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Pinging google
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may want to ping Google when your sitemap changes, to let it know to reindex
    your site. The sitemaps framework provides a function to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: django.contrib.syndication.ping_google()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ping_google()` takes an optional argument, `sitemap_url`, which should be
    the absolute path to your site''s sitemap (for example, `''/sitemap.xml''`). If
    this argument isn''t provided, `ping_google()` will attempt to figure out your
    sitemap by performing a reverse looking in your URLconf. `ping_google()` raises
    the exception `django.contrib.sitemaps.SitemapNotFound` if it cannot determine
    your sitemap URL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One useful way to call `ping_google()` is from a model''s `save()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A more efficient solution, however, would be to call `ping_google()` from a
    cron script, or some other scheduled task. The function makes an HTTP request
    to Google's servers, so you may not want to introduce that network overhead each
    time you call `save()`.
  prefs: []
  type: TYPE_NORMAL
- en: Pinging Google via manage.py
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the sitemaps application is added to your project, you may also ping Google
    using the `ping_google` management command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Register with Google first!** The `ping_google()` command only works if you
    have registered your site with Google webmaster Tools.'
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll continue to dig deeper into the built-in tools Django gives you
    by taking a closer look at the Django session framework.
  prefs: []
  type: TYPE_NORMAL
