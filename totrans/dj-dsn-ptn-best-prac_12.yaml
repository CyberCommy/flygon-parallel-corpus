- en: Appendix A. Python 2 versus Python 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code samples in this book have been written for Python 3.4\. Except
    for very minor changes, they would work in Python 2.7 as well. The author believes
    that Python 3 has crossed the tipping point for being the preferred choice for
    new Django projects.
  prefs: []
  type: TYPE_NORMAL
- en: Python 2.7 development was supposed to end in 2015 but was extended for five
    more years through 2020\. There will not be a Python 2.8\. Soon all major Linux
    distributions would have completely switched to using Python 3 as a default. Many
    PaaS providers such as Heroku already support Python 3.4.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the packages listed in the Python Wall of Superpowers have turned green
    (indicating that they have support for Python 3). Almost all the red ones have
    an actively developed Python 3 port.
  prefs: []
  type: TYPE_NORMAL
- en: Django has been supporting Python 3 since Version 1.5\. In fact, the strategy
    was to rewrite the code in Python 3 and deal with Python 2 as a backward compatibility
    requirement. This is primarily implemented using utility functions from Six, a
    Python 2 and 3 compatibility library.
  prefs: []
  type: TYPE_NORMAL
- en: As you will soon see, Python 3 is a superior language in many ways due to numerous
    improvements primarily towards consistency. Yet, if you are building web applications
    with Django, the number of differences you might encounter while moving to Python
    3 are quite trivial.
  prefs: []
  type: TYPE_NORMAL
- en: But I still use Python 2.7!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are stuck with a Python 2.7 environment, then the sample project can
    be easily backported. There is a custom script named `backport3to2.py` at the
    project root that can perform a one-way conversion to Python 2.x. Note that it
    is not general enough for using in other projects.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are interested in knowing why Python 3 is better, then read
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Python 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python 3 was born out of necessity. One of Python 2's major annoyances was its
    inconsistent handling of non-English characters (commonly manifested as the infamous
    `UnicodeDecodeError` exception). Guido initiated the Python 3 project to clean
    up a number of such language issues while breaking backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: The first alpha release of Python 3.0 was made in August 2007\. Since then,
    Python 2 and Python 3 have been in parallel development by the core development
    team for a number of years. Ultimately, Python 3 is expected to be the future
    of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Python 3 for Djangonauts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section covers the most important changes in Python 3 from a Django developer's
    perspective. For the full list of changes, please refer to the recommended reading
    section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The examples are given in both Python 3 and Python 2\. Depending on your installation,
    all Python 3 commands might need to be changed from `python` to `python3` or `python3.4`.
  prefs: []
  type: TYPE_NORMAL
- en: Change all the __unicode__ methods into __str__
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python 3, the `__str__()` method is called for string representation of
    your models rather than the awkward sounding `__unicode__()` method. This is one
    of the most evident ways to identify Python 3 ported code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python 2 | Python 3 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table reflects the difference in the way Python 3 treats strings.
    In Python 2, the human-readable representation of a class can be returned by `__str__()`
    (bytes) or `__unicode__()` (text). However, in Python 3 the readable representation
    is simply returned by `__str__()` (text).
  prefs: []
  type: TYPE_NORMAL
- en: All classes inherit from the object class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python 2 has two kinds of classes: old-style (classic) and new-style. New-style
    classes are classes that directly or indirectly inherit from `object`. Only the
    new-style classes can use Python''s advanced features, such as slots, descriptors,
    and properties. Many of these are used by Django. However, classes were still
    old-style by default for compatibility reasons.'
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3, the old-style classes don't exist anymore. As seen in the following
    table, even if you don't explicitly mention any parent classes, the `object` class
    will be present as a base. So, all the classes are new-style.
  prefs: []
  type: TYPE_NORMAL
- en: '| Python 2 | Python 3 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Calling super() is easier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simpler call to `super()`, without any arguments, will save you some typing
    in Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: '| Python 2 | Python 3 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the class name and instance is optional, thereby making your code
    DRY and less prone to errors while refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Relative imports must be explicit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine the following directory structure for a package named `app1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in Python 3, let''s run the following code in the parent directory of
    `app1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Within a package, you should use explicit relative imports while referring to
    a sibling module. You can omit `__init__.py` in Python 3, though it is commonly
    used to identify a package.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 2, you can use `import models` to successfully import the `models.py`
    module. However, it is ambiguous and can accidentally import any other `models.py`
    in your Python path. Hence, this is forbidden in Python 3 and discouraged in Python
    2 as well.
  prefs: []
  type: TYPE_NORMAL
- en: HttpRequest and HttpResponse have str and bytes types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python 3, according to PEP 3333 (amendments to the WSGI standard), we are
    careful not to mix data coming from or leaving via HTTP, which will be in bytes,
    as opposed to the text within the framework, which will be native (Unicode) strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, for the `HttpRequest` and `HttpResponse` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Headers will always be the `str` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input and output streams will always be the `byte` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike Python 2, the strings and bytes are not implicitly converted while performing
    comparisons or concatenations with each other. Strings mean Unicode strings only.
  prefs: []
  type: TYPE_NORMAL
- en: Exception syntax changes and improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exception-handling syntax and functionality has been significantly improved
    in Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python 3, you cannot use the comma-separated syntax for the `except` clause.
    Use the `as` keyword instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python 2 | Python 3 and 2 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The new syntax is recommended for Python 2 as well.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3, all the exceptions must be derived (directly or indirectly) from
    `BaseException`. In practice, you would create your custom exceptions by deriving
    from the `Exception` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a major improvement in error reporting, if an exception occurs while handling
    an exception, then the entire chain of exceptions are reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python 2 | Python 3 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'During the handling of the preceding exception, another exception occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Once you get used to this feature, you will definitely miss it in Python 2.
  prefs: []
  type: TYPE_NORMAL
- en: Standard library reorganized
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The core developers have cleaned up and organized the Python standard library.
    For instance, `SimpleHTTPServer` now lives in the `http.server` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python 2 | Python 3 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: New goodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python 3 is not just about language fixes. It is also where bleeding-edge Python
    development happens. This means improvements to the language in terms of syntax,
    performance, and built-in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the notable new modules added to Python 3 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`asyncio`: This contains asynchronous I/O, event loop, coroutines, and tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unittest.mock`: This contains the mock object library for testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pathlib`: This contains object-oriented file system paths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`statistics`: This contains mathematical statistics functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if some of these modules have backports to Python 2, it is more appealing
    to migrate to Python 3 and leverage them as built-in modules.
  prefs: []
  type: TYPE_NORMAL
- en: Using Pyvenv and Pip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most serious Python developers prefer to use virtual environments. `virtualenv`
    is quite popular for isolating your project setup from the system-wide Python
    installation. Thankfully, Python 3.3 is integrated with a similar functionality
    using the `venv` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Python 3.4, a fresh virtual environment will be pre-installed with pip,
    a popular installer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the command prompt changes to indicate that your virtual environment
    has been activated.
  prefs: []
  type: TYPE_NORMAL
- en: Other changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We cannot possibly fit all the Python 3 changes and improvements in this appendix.
    However, the other commonly cited changes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`print()` **is now a function**: Previously, it was a statement, that is, arguments
    were not in parenthesis.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integers don''t overflow**: `sys.maxint` is outdated, integers will have
    unlimited precision.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Inequality operator** `<>` **is removed**: Use `!=` instead.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**True integer division**: In Python 2, `3 / 2` would evaluate to `1`. It will
    be correctly evaluated to `1.5` in Python 3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Use** `range` **instead of** `xrange(): range()` will now return iterators
    as `xrange()` used to work before.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dictionary keys are views**: `dict` and `dict`-like classes (such as `QueryDict`)
    will return iterators instead of lists for the `keys()`, `items()`, and `values()`
    method calls.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read *What's New In Python 3.0* by Guido at [https://docs.python.org/3/whatsnew/3.0.html](https://docs.python.org/3/whatsnew/3.0.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find what is new in each release of Python, read *What's New in Python* at
    [https://docs.python.org/3/whatsnew/](https://docs.python.org/3/whatsnew/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For richly detailed answers about Python 3 read *Python 3 Q & A* by Nick Coghlan
    at [http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html](http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
