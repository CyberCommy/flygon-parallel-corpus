- en: Advanced Forms in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](8eacfd6f-0cc3-49d5-9c85-f823dad66ad6.xhtml), *Asynchronous Programming*
    *Using Observables*, we used Observables to build a simple, yet easily extendable
    JSON API to query the Marvel Cinematic Universe. In this chapter, we will build
    the forms that will allow us to query our API in a more user-friendly way. These
    forms will help us to not only retrieve movies from the Marvel Cinematic Universe,
    but also to add movies. In addition to the forms themselves, we will obviously
    need to build on our API, so it supports the addition and modification of movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will see the following topics covered in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control and ControlGroup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using FormBuilder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated in the introduction of this chapter, we will build upon our JSON API
    for the Marvel Cinematic Universe of [Chapter 7](8eacfd6f-0cc3-49d5-9c85-f823dad66ad6.xhtml),
    *Asynchronous Programming* *Using Observables*. To be a bit more precise, we will
    improve the Promise-based version. Why Promises instead of pure observers? Well,
    Promises are an extremely powerful tool, and they are used in the majority of
    Angular/Typescript projects I have seen so far. Consequently, a bit more practice
    with Promises won't hurt much.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code of the Promises part here [http://bit.ly/mastering-angular2-chap7-part3](http://bit.ly/mastering-angular2-chap7-part3).
  prefs: []
  type: TYPE_NORMAL
- en: 'To clone this code into a new repo called `advanced-forms`, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These commands pull the latest version of the GitHub repository containing the
    code for this book to a folder named `advanced-forms`. Then, we go into the `advanced-forms`
    folder and prune everything that is not inside the `chap7/angular-promise` subdirectory.
    Magically enough, Git rewrites the history of the repository to keep only the
    files that were inside the `chap7/angular-promise` subdirectory. Finally, `npm
    install` will have all our dependencies ready to fire.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, you will have the behavior we achieved in [Chapter 7](8eacfd6f-0cc3-49d5-9c85-f823dad66ad6.xhtml),
    *Asynchronous Programming* *Using Observables* (for example querying movies from
    the Marvel Cinematic Universe) inside a new project named advanced-forms. Now,
    it won't be much fun if we use forms to create, read, update and delete movies
    from the Marvel Cinematic Universe, and these changes are not reflected in the
    querying part. As a reminder, the querying API we built in [Chapter 7](8eacfd6f-0cc3-49d5-9c85-f823dad66ad6.xhtml),
    *Asynchronous Programming* *Using Observables* is a static JSON file as a backend
    mock. To save the changes coming from our forms, we will have to modify the JSON
    file. While this is possible, it means that we will build a whole new functionality
    (that is editing a file) only for the purpose of our mock. This new functionality
    won't help us at all, when we go ahead with a real backend. Consequently, we will
    use an in-memory reference for our movies from the Marvel Cinematic Universe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `app.component.ts` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And the related HTML template is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IMDBAPIService` didn''t change from [Chapter 7](8eacfd6f-0cc3-49d5-9c85-f823dad66ad6.xhtml),
    *Asynchronous Programming* *Using Observables* and an `ng start` will have the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2018ccc8-c331-4d24-af00-0c0de5466ec9.png)State at the end of [chapter
    7](8eacfd6f-0cc3-49d5-9c85-f823dad66ad6.xhtml), *Asynchronous Programming* *Using
    Observables.*'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](1dfecab5-25d2-47a0-88a2-eac2cece692e.xhtml), *Template and Data
    Binding Syntax*, we learned how to leverage Data Binding and templating in Angular.
    Here, we'll combine these new notions with forms. Anyone with two hours, of HTML
    experience knows what `<form>` means and how to use them. With a couple of hours
    of HTML behind you, you know how to identify the different information in your
    forms and choose a method (that is `GET`, `POST`, `PUT`, and `DELETE`) to send
    everything to the backend of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: "In this recipe, however, we will build forms using imperative TypeScript code\
    \ instead of good old HTML. Why, you ask? Well, this allows us to test our forms\
    \ without relying on end-to-end tests that need the DOM to be generated. With\
    \ reactive forms, we can test our form with classical unit tests as described\
    \ in [\uFEFFChapter 16](38580b89-29c5-4657-819c-7260b6ce7ab4.xhtml), *Testing\
    \ Angular Apps Using Jasmine and Protractor Frameworks*."
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by building the underlying HTML structure for a form, aiming at
    adding a new movie to the Marvel Cinematic Universe as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding form, we have one couple label-input for each attribute of
    the `Movie` model. Now, there are some directives that are definitively not pure
    HTML in this form. Namely, `[formGroup]="movieForm"` and `formControlName=""`.
    The first directive (`[formGroup]="movieForm"`) is used to bind this particular
    form with an instance of `FormGroup`. Then, `formControlName` refers to instances
    of the `FormControl` class that comprises the `FormGroup`. In other words, `movieForm`
    is a `FormGroup` comprised of `FormControl`, `FormGroup`, and `FormControl` are
    in the `@angular/forms` package both. Consequently, we''ll have to import this
    package in our `app.component.ts` file: `import { FormGroup, FormControl }` from
    `@angular/forms`; after updating the `app.component.html` file with our form.
    In addition, we need to import the `ReactiveFormsModule` and add it to our application
    module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to serve your application right now, it would transpile without
    a hitch. At runtime, however, it''ll complain, as the `movieForm` form group does
    not exist in your component yet. Let''s create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have a private member of the `AppComponent` component that
    is an instance of `FormGroup`. This `FormGroup` instance is composed of many `FormControl`
    instances, one per field to be precise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the value of each field can be accessed via `this.movieForm.value.my_field`.
    Consequently, if we add a submit button to our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And the corresponding `submit()` function in the `AppComponent` component, then
    we can display the values of each one of our fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s as simple as that; we got a communication between our HTML template and
    our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2a659178-4ae0-4628-95de-27588d0c3131.png)Displaying the rather crude
    HTML form and the console output of the submit function.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can create an instance of the `Movie` model and send it to the `IMDBAPI`
    for persistence. The only thing missing is a working backend.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see the displayed HTML form and the console
    output for the improved `submit` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6f8ce37d-dc19-4504-86f1-9e8e20c20e40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that''s great; we have retrieved the values from the HTML form into the
    component side of our application, and we have created a `Movie` object that can
    be moved around and persisted. There are at least two different things to improve
    in this form:'
  prefs: []
  type: TYPE_NORMAL
- en: The wordiness of the form creation (`new FormControl() much ?`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The verifications on the different input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using FormBuilder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FormBuilder` is an injectable helper class of the `@angular/forms` package
    of Angular. This class helps to reduce the wordiness of form creation as demonstrated
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using the group method of the `FormBuilder` class, the declaration
    of `FormGroup` and `FormControl` is now implicit. We only need to have the field
    name followed by its default value. Here, all the default values are blank.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `FormBuilder` class, we first have to import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We then inject it using the constructor of our `AppComponent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that we still have the injection of `IMDBAPIService` from [Chapter 7](8eacfd6f-0cc3-49d5-9c85-f823dad66ad6.xhtml),
    *Asynchronous Programming* *Using Observables*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, `AppComponent` now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve solved the first one of our two problems: the wordiness of the form
    creation. In the next section, we''ll tackle the validation part of this chapter
    where we learn how to validate incoming inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with forms is often a pain for developers because you obviously can't
    trust the inputs provided by the user. It is either because they are just not
    paying attention to what you expect in your forms or because they want to break
    things. Validating inputs incoming from a form is painful in every language, both
    server and client-side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the Angular team came up with a rather simple way to validate inputs by
    defining what is expected from each field right at the form''s creation using
    `Validators`. Angular contains the following built-in `Validators` that we can
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`required`: Requires a non-empty value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minLength(minLength: number)`: Requires the control value to have a minimum
    length of `minLength`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxLength(maxLength: number)`: Requires the control value to have a maximum
    length of `maxLength`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern(pattern: string)`: Requires that the control value matches the provided
    pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding these built-in `validators` to our form is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to a blank default value for each field, we add the required `validator`,
    which is a static of the `Validators` class contained in the `@angular/forms`
    package. We can read the validity of the form (that is, if all the validators
    are OK''d) using the valid property of our `FormGroup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the previous modification of the `submit` method, if the user does not fill
    in one of the fields, then the `Movie` object won't be created. Also, we'll display
    a `console.error("Form not valid")`; and, if we add a conditional `<p></p>` block
    accompanied by some rudimentary CSS, we can provide some feedback to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see the displayed HTML form with feedback
    on the form''s validity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4a308388-9826-4170-b858-2a40d3f7193b.png)'
  prefs: []
  type: TYPE_IMG
- en: We can go a bit further and provide a visual feedback per field. The status
    of each field is accessible through the `valid` property of each sub `FormControl`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/760e8212-8c78-4687-984c-d85a00b521f7.png)Displaying HTML form with
    feedback on each field''s validity.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, each form except the `movid_id` one, displays the This field
    is required error as they are empty. The `*ngIf` structural directive listens
    to any changes in the associated variable and will show/hide the paragraph when
    the field becomes invalid/valid. Another useful property of the form is pristine.
    It defines whether or not a given field has been modified by a user. In our case,
    it could be used to avoid displaying errors, even when no editing occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another handy thing to know about `validators` is that they can be composed
    using the compose method of the `Validators` class. In the following example,
    We will compose a validator for the `movie_id` field from four distinct validators:
    `Validators.required`, `Validators.minLength`, `Validators.maxLength`, and `Validators.pattern`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting composite validator will henceforth ensure that the `movie_id`
    is a number that is between `1` and `4` digits long. The following screenshot
    displays an HTML form with feedback on the movide_id field. The field is valid
    because it''s composed of four digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9ee66d91-894e-4aea-a083-32cecaded17d.png)'
  prefs: []
  type: TYPE_IMG
- en: Custom validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how to use validators and combine validators
    together to create more complex validation. The `Validators.required`, `Validators.minLength`,
    `Validators.maxLength`, and `Validators.pattern` combinations can cover a lot
    of validation cases that can arise during the development of your Angular application.
    If the time comes where you can't handle your validation needs with the built-in
    validator, then you can build your very own validator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll see how to validate that the movie_id field contains
    a valid entry (that is a number that is between one and four digits long) and
    that another movie does not already use the id. To do so, we can create the following
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the validation results are, in fact, a simple `[key:string]:boolean`
    structure. If the Boolean is true, then, it means that the validator failed (that
    is, the field is not valid). Moving on to the `MovieIDValidator` class itself,
    we have a static method returning a `ValidationResult` and accepting as a parameter
    a `FormControl`. Inside this method, we pull all the movies from our JSON file
    containing the Marvel Cinematic Universe. Then, we iterate over all the movies
    and check if the current value of the `movie_id` field matches an existing id.
    If so, we return `{ "idNotTaken": true }`, meaning that there is a problem with
    the `idNotTaken` validator. Combining this new custom validator with the other
    four (that is `Validators.required`, `Validators.minLength`, `Validators.maxLength`,
    and `Validators.pattern`) is a piece of cake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can also add an asynchronous form validator that returns a Promise (for example
    `Promise<ValidationResult>` instead of `ValidationResult`). This is very handy
    when you have to do your validation using a remote API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we build a Promise that simulates a remote API call with a 1-second timeout.
    What the Promise does is the same thing as `idNotTaken`, where we check if an
    id for a movie is already taken. After the Promise creation, we return it so it
    can be used in the related component.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way Data Binding with ngModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very convenient process when creating or updating the model of your Angular
    application through forms is Two-way Data Binding with `ngModel`. In the previous
    application, we had the following `submit()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To the experimented eye, this looks clumsy. Indeed, we knew that we'd ask the
    user for a new movie. Hence, all the fields will be displayed and their value
    used to create the aforementioned movie. Using Two-way Data Binding, you can specify
    a binding between each HTML input and an attribute of your model. In our case,
    this is an attribute of the `Movie` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Have a look at the `[(ngModel)]` directive. Here, we bind one way using `[]`
    and the other way using `()`. One way is the model of the form and the other way
    is from the form to the model. It means that any modification made to the form
    will impact the model and any modification made to the model will be reflected
    on the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our submit method can be reduced to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: One important thing to keep in mind is that the values of the form will be transferred
    to the model even if the validators are not valid. For example, if you were to
    enter `ABC` into the `movie_id` field, then the `validators` will not be valid
    but `console.log(this.movie.movie_id)` will display `ABC`.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping things neat (extra credit)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have always found that forms are the bane of clean, neat, organized HTML
    templates. Even small forms, well indented and separated by comments, look cluttered
    to my eyes. To solve this problem in an Angular way, we can create directives
    that keep forms input organized. Here''s an example of what I use when creating
    a form for `Toolwatch.io`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the directive accepts a different `@Input` parameter that controls
    how the input will look and behave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the related component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This component accepts, as inputs, the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: The `id` for the input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`control`: `FormControl` controlling this input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model`: Bound model field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: Input type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label`: Label to display'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`errorLabel`: Error label to display'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formControlName`: Name of the form control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`submitAttempt`: If the form has been submitted once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoCapitalize`: HTML attribute for `autoCapitalize` on/off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoCorrect`: HTML attribute for `autoCorrect` on/off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoComplete`: HTML attribute for `autoComplete` on/off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spellCheck`: HTML attribute for `spellCheck` on/off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, it initializes the value of `label`,`errorLabel`, and `formControlName`
    with the value of `id` if they are not provided. Finally, the component also has
    a `@Output` attribute named `update` that emits an event when the `value` changes,
    so you can register for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the HTML side, we have something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The main advantage is that HTML and CSS class managements are encapsulated away
    and I don't have to copy and paste them every time I want an input.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to take advantages of reactive forms. Reactive
    forms can be created manually or programmatically using `FormBuilder`. Moreover,
    we tackled the reactive part of reactive forms by emphasizing the relationship
    between your HTML models and your `ngModel`, so every change on a given form is
    propagated to the model. We also saw how to customize validations and embed our
    newly acquired knowledge about forms in clean, reusable directives.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to integrate material design with Angular
    in order to create dashing and responsive applications.
  prefs: []
  type: TYPE_NORMAL
