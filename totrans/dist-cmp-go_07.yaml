- en: Goophr Librarian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](../Text/Ch06.xhtml), *Goophr Concierge*, we built the endpoint
    responsible for accepting new documents and breaking them down into tokens to
    be used in the index. However, the current implementation of Concierge's `api.indexAdder`
    returns after printing the token to the console. In this chapter, we will implement
    Goophr Librarian, which can interact with the Concierge to accept tokens and also
    respond to token search queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will look at following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The standard indexing model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inverted indexing model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The document indexer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query resolver APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard indexing model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the index in a book. Each book will have its own index, which lists
    all the words in an alphabetical order showing their location within the book.
    However, if we want to keep track of word occurrences in multiple books, checking
    each book's index is quite inefficient. Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: An example – books with an index of words
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine we have three books: `Book 1`, `Book 2`, and `Book 3`, and the following
    are their respective indexes. The numbers beside each word represent which page
    the word occurs on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to find three words from the books'' indexes. A naïve approach might
    be to pick each book and scan it until we hit or miss the word:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apple`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`banana`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parrot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In a nutshell, for each of the terms, we iterated through every book index and
    searched for the word. We went through this whole process for every word including
    `parrot`, which is not present in any of the books! At first this might seem acceptable,
    performance-wise, but consider when we have over a million books to wade through;
    we realize that the approach would not be practical.
  prefs: []
  type: TYPE_NORMAL
- en: The inverted indexing model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on the preceding example, we can state the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to have a quick lookup to determine if a word exists in our index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any given word, we need to have an efficient way to list all the books the
    word might be in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can achieve these two niceties by using an inverted index. A standard index's
    mapping order is **book** →** word → ****occurrence (page, line, and so on)**
    as seen in the previous example. If we use an inverted index, the mapping order
    becomes **word → ****book → ****occurrence (page, line, and so on)**.
  prefs: []
  type: TYPE_NORMAL
- en: This change might not seem to be of great significance; however, it improves
    the look up a lot. Let's look at it with another example.
  prefs: []
  type: TYPE_NORMAL
- en: An example – the inverted index for words in books
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take the data from the same example as before but now classified according
    to an inverted index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With this setup, we can efficiently answer following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Does a word exist in the index?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are all the books a word exists in?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What pages does a word occur on in a given book?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s again try to find three words from the inverted index:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apple`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`banana`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parrot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, instead of going through each of the books, we do a single look
    up for each of the terms, determine if the term exists, and if it does, return
    the list of books which is our ultimate goal.
  prefs: []
  type: TYPE_NORMAL
- en: Ranking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ranking and the relevance of search results is an interesting and complex topic.
    All major search engines have a dedicated group of software engineers and computer
    scientists who spend a lot of time and effort to ensure that their algorithms
    are most accurate.
  prefs: []
  type: TYPE_NORMAL
- en: For Goophr, we will simplify the ranking and limit it to the frequency of search
    terms. Higher the search term frequency, higher it ranks in the results.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the API definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s review Librarian''s API definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the API definition, we can state the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All communication is via the JSON format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two endpoints for Librarian are: `/api/index` and `/api/query`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/index` uses the `POST` method to add new tokens to the reverse index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/query` uses the `POST` method to receive search query terms and returns
    a list of all documents that the index contains'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The document indexer – the REST API endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main aim of `/api/index` is to accept tokens from Concierge and add them
    to the index. So let's look at what we mean by "adding them to the index".
  prefs: []
  type: TYPE_NORMAL
- en: 'Document indexing can be defined as the following set of consecutive tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: We rely on the payload to provide us with all the meta information needed to
    store the token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We follow down the inverted index tree, create any node in the path not yet
    created, and finally add the token details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The query resolver – the REST API endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main aim of `/api/query` is to find the set of search terms in the inverted
    index and return a list of document IDs in decreasing order of relevance. Let's
    look at what we mean by "querying search terms" and "relevance".
  prefs: []
  type: TYPE_NORMAL
- en: 'Query resolution can be defined as the following set of consecutive tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: For each of the search terms, we would like to retrieve all available books
    in inverted index form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we would like to store the occurrence counts for all the words within
    each individual book in a simple look up table (`map`)*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have a map with books and their respective counts, we can convert the
    look up table into an array of ordered document IDs and their respective scores.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in this chapter is quite straightforward and it follows the same code
    conventions as in [Chapter 6](../Text/Ch06.xhtml), *Goophr Concierge*. So let's
    jump right into the code.
  prefs: []
  type: TYPE_NORMAL
- en: Librarian source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have discussed the design of Librarian in detail, let''s look at
    the project structure and source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Two directories and five files!
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the source code for each of the files.
  prefs: []
  type: TYPE_NORMAL
- en: main.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The source file is responsible for initializing routes, starting the index
    system and starting the web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: common/helpers.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source file consists of code that is speacialized to one handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: api/index.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Source file containing code to process and add new terms to the index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: api/query.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Source file contains code responsible for returning sorted results based on
    search terms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Testing Librarian
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to test whether Librarian works as expected, we need to test two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if `/api/index` accepts index terms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if `/api/query` returns the correct results and in the expected order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can test point 1 with the help of a separate program/script, `feeder.go`,
    and point 2 with simple cURL commands.
  prefs: []
  type: TYPE_NORMAL
- en: Testing feeder.go using /api/index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s the `feeder.go` script to check if `/api/index` accepts index terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from running `feeder.go` (with Librarian running in other window)
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from Librarian for the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Testing /api/query
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order to test `/api/query` we need to maintain the preceding state of the
    server to make useful queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we developed an understanding of inverted indices and implemented
    it for Librarian for the efficient storage and lookup of search terms. We also
    checked our implementation with the help of a script, `feeder.go`, and cURL commands.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [Chapter 8](../Text/Ch08.xhtml), *Deploying Goophr, *we
    will rewrite Concierge's `api.indexAdder` so that it can start sending the tokens
    to be indexed to Librarian. We will also revisit `docker-compose.yaml` so that
    we can have the complete application running and use/test it as a distributed
    system.
  prefs: []
  type: TYPE_NORMAL
