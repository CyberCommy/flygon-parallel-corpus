- en: Learning the C, C++17, and POSIX Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated in [Chapter 1](af8579a6-71c4-4315-818c-733257355bfe.xhtml), *Getting
    Started with System Programming*, system programming is the act of making system
    calls to perform various actions in coordination with the underlying operating
    system. Each operating system has its own set of system calls, and how these system
    calls are made is different.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the system programmer from having to rewrite their program for each
    different operating system, several standards have been put into place that wrap
    the operating system's ABI with a well-defined API.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss three standards—the C standard, the C++ standard,
    and the POSIX standard. The C and POSIX standards provide the fundamental language
    syntax and APIs that wrap an operating system's ABI. Specifically, the C standard
    defines program linking and execution, the standard C syntax (which a number of
    higher-level languages, such as C++, are based on), and the C libraries that provide
    the ABI-to-API wrappers.
  prefs: []
  type: TYPE_NORMAL
- en: The C libraries can be thought of as a subset of the greater POSIX standard,
    which defines a much larger subset of APIs, including, but not limited to, filesystem,
    network, and threading libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the C++ standard defines the C++ syntax, program linking and execution,
    and the C++ libraries that provide higher-level abstractions of the C and POSIX
    standards. The majority of this book will revolve around these standard APIs and
    how to use them with C++17.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter has the following objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the C, C++, and POSIX standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding program linking and execution, and the differences between C and
    C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a brief overview of the facilities these standards provide, each of
    which will be discussed in greater detail later in the book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to follow the examples in this chapter, the reader must have:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCC 7+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.6+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To download all the code in this chapter, including the examples and code snippets,
    go to the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with the C standard language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C programming language is one of the oldest languages available. Unlike
    other higher-level languages, C is similar enough to assembly language programming,
    while still providing some high-level programming abstractions, that it has become
    a firm favorite among system, embedded, and kernel-level programmers alike.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every major operating system is rooted in C. In addition, most higher-level
    languages, including C++, build upon C to provide their higher-level constructs,
    and therefore still require some of the components of the C standard.
  prefs: []
  type: TYPE_NORMAL
- en: The C standard is a huge standard that is managed by the **International Organization
    for Standardization** (**ISO**). We assume the reader has some basic knowledge
    of the C standard and how to write C code: [http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, the goal of this section is to discuss some topics that are
    discussed in lesser detail in other books, as well as portions of the C standard
    that are relevant to this book and system programming, but are missing from the
    other chapters.
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on the C programming language and how to write C
    programs, please see the *Further reading* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How the standard is organized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The specification is broken up into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's briefly discuss the purpose of each section. After that, we will discuss
    specific portions of the C standard that are relevant to system programming but
    are not discussed elsewhere in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Environment section of the standard provides information that is mainly
    needed by compiler writers to better understand how to create a compiler for C.
  prefs: []
  type: TYPE_NORMAL
- en: It describes the minimum limitations the compiler must adhere to (such as the
    minimum number of nested `if()` statements that must be supported), as well as
    how programs are linked and started.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss program linking and execution to provide a
    better understanding of what is required to create a C program.
  prefs: []
  type: TYPE_NORMAL
- en: Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Language section of the standard provides all the details associated with
    the C syntax, including what a variable is, how to write a function, the difference
    between a `for()` loop and a `while()` loop, and all of the operators that are
    supported and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: This book assumes the reader has general knowledge of this section of the standard,
    and only touches on system programming-specific nuances of the standard C syntax
    that the reader is likely to run into (such as issues associated with pointers).
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Libraries section of the standard describes all of the library facilities
    that are provided by the standard C language. This includes facilities such as
    outputting strings to `stdout`, allocating memory, and working with time.
  prefs: []
  type: TYPE_NORMAL
- en: System programming largely revolves around these library facilities, and the
    bulk of this book will focus on these libraries, what they provide, and how to
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: How a C program starts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One part of the standard that is relevant to system programming, but is not
    as widely discussed in literature, is how a C program starts. A common misconception
    is that a C program starts with the following two entry points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although this is, in fact, the first function call that a C programmer provides,
    it is not the first function called when your C program starts. It is not the
    first code that executes either, nor is it the first code provided by the user
    that executes.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of work is carried out, both by the operating system and the standard
    C environment, as well as the user, prior to the `main()` function ever executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how your compiler creates a simple `Hello World\n` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To better understand the start up process of a C program, let''s look at how
    this simple program is compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By adding the `-v` option to GCC, we are able to see each step the compiler
    takes to compile our simple `Hello World\n` program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, the compiler converts the program to a format that can be processed
    by `gnu-as`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Not only can you see how the initial compilation is performed, but you can see
    the default flags that your operating system provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the compiler converts the output to an object file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last step links the resulting object files into a single executable
    using the `collect2` utility, which is a wrapper around the linker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of important things to take note of here with respect to
    how the program is linked:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-lc`: The use of this flag tells the linker to link in `libc`. Like the rest
    of the libraries being discussed here, we didn''t tell the compiler to link against
    `libc`. By default, GCC links `libc` for us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-lgcc_s`: This is a static library that is linked automatically by GCC to
    provide support for compiler-specific operations including 64-bit operations on
    a 32-bit CPU, and facilities such as exception unwinding (a topic that will be
    discussed in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml), *Error
    - Handling with Exceptions*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scrt1.o`, `crti.o`, `crtbeginS.o`, `crtendS.o`, and `crtn.o`: These libraries
    provide the code needed to start and stop your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specifically, the **C run-time** **libraries** (**CRT**) libraries are the
    libraries of interest here. These libraries provide the code that is needed to
    bootstrap the application, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing global constructors and destructors (as GCC supports constructors
    and destructors in C, even though this is not a standard C facility).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up unwinding to support exception supporting. Although this is mainly
    needed for C++ exceptions, which are not needed in a standard C-only application,
    they are still needed for linking in the set jump exception logic, a topic that
    will be explained in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml),
    *Error - Handling with Exceptions*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing the `_start` function, which is the actual entry point to any C-based
    application using a default GCC compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, all these libraries are responsible for providing the `main()` function
    with the arguments that are passed to it, as well as intercepting the return value
    of the `main()` function, and executing the `exit()` function on your behalf,
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The most important takeaway here is that the first piece of code to execute
    in your program is not the `main()` function, and if you register a global constructor,
    it is not the first piece of code that you provide that executes either. While
    system programming, if you experience issues with the initialization of your program,
    this is where to look first.
  prefs: []
  type: TYPE_NORMAL
- en: All about linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linking is an extremely complex topic that varies from operating system to operating
    system. For example, Windows links programs quite differently to Linux. For this
    reason, we will limit our discussion to Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a C source file is compiled, it is compiled into what is called an **object
    file**, which contains the compiled source code with each function that is defined
    in the program in a binary format, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As shown here, the compiler creates an object file, which contains the compiler
    (that is, binary) version of the source code. An important note here is that that
    the `main()` function is labeled *main*, in plain text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s expand this example to include another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling this source, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As shown here, each function that is compiled is labeled using the same name
    as the function. That is, the name of each function is not *mangled* (unlike in
    C++). Name mangling will be explained in further detail in the next section, as
    well as why this is important with respect to linking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going beyond a simple source file, a C program is split into groups of source
    files that are compiled and linked together. Specifically, an executable is the
    combination of object files and libraries. Libraries are a combination of additional
    object files, divided into two different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static libraries**: libraries that are linked at compile time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic libraries**: libraries that are linked at load time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static libraries are a collection of object files that are linked at compile
    time. In Linux (and most UNIX-based systems), static libraries are nothing more
    than an archive of object files. You can easily take an existing static library
    and use the `AR` tool to extract the original object files.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike object files that are linked as part of your program, object files that
    are linked as part of a static library only include the source code needed by
    that static library, providing optimization that removes unused code from your
    program, ultimately reducing the total size of your program.
  prefs: []
  type: TYPE_NORMAL
- en: The downside to this approach is that the order in which a program is linked
    using static libraries matters. If a library is linked before the code that needs
    the library is provided (on the command line, that is), a link error will occur,
    as the code from the static library will be optimized out.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries provided by the operating system usually do not support static linking
    either, and, typically, static linking of operating system libraries is not needed
    as those libraries are likely to have been loaded into memory by your operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic libraries are libraries that are linked at load time. Dynamic libraries
    are more like executables without an entry point. They contain code needed by
    your program, and the load-time linker is responsible for providing the location
    of each required function to your program while your program is being loaded.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible for your program to link itself while it executes during
    runtime as an optimization, only linking functions that are needed (a process
    known as **lazy loading**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the libraries provided by the operating system are dynamic libraries.
    To see which dynamic libraries are needed by your program, you can use the LDD
    tool, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we used the LDD tool to list the dynamic libraries needed
    by our simple `Hello World\n` example. As shown, the following libraries are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vdso`: a library provided by the operating system to speed up the process
    of making system calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libc`: the standard C library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ld-linux-x86-64`: the dynamic linker itself, responsible for lazy-loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One addition to the C language that distinguishes it dramatically from assembly
    language programming is the use of *scope*. In assembly, a function prefix and
    postfix must be hand-coded, and the process for doing this depends entirely on
    the **instruction set architecture** (**ISA**) your CPU provides, and the ABI
    the programmer decides to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C, the scope of a function is defined automatically for you using the `{}`
    syntax. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In our simple `Hello World\n` example, scope is used to define the start and
    end of our `main()` function. The scope of other primitives can also be defined
    using the `{}` syntax. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we define the scope of both our `main()` function and
    our `for()` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `{}` syntax can also be used to create *scope* for anything. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we are able to use the `i` variable twice without accidentally
    redefining it, because we wrapped the definition of `i` in a `{}`. Not only does
    this tell the compiler the scope of `i`, it also tells the compiler to automatically
    create a prefix and postfix for us if they are needed (as optimizations can remove
    the need for a prefix and postfix).
  prefs: []
  type: TYPE_NORMAL
- en: Scope is also used to define what the compiler exposes with respect to linking.
    In standard C, the `static` keyword tells the compiler that a variable is only
    visible (that is, scoped) to the object file it is being compiled to, providing
    not only an optimization to the linker, but also preventing two global variables
    or functions from colliding with each other.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, if a function is not intended to be called by another source
    file (or library), it should be labeled static.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of system programming, scope is important because system programming
    typically requires the acquisition of system-level resources. As will be seen
    in [Chapter 4](57bdbfbb-03ce-45e3-b3ac-108daf3ac728.xhtml), *C++, RAII, and the
    GSL Refresher*, C++ provides the ability to create objects whose life can be scoped
    using standard C `{}` syntax, providing a safe mechanism for resource acquisition
    and release.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers and arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In school, I had a teacher who once told me:'
  prefs: []
  type: TYPE_NORMAL
- en: '"No matter how experienced you are, nobody truly understands pointers completely."'
  prefs: []
  type: TYPE_NORMAL
- en: 'No statement could be truer. In standard C, a pointer is a variable whose value
    points to a location in memory. The problem with standard C is that this location
    in memory is not associated with a particular type. Instead, the pointer type
    itself defines the type of memory the pointer is pointing to, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we created an integer, and then created a pointer
    and pointed it at the previously-defined integer. We could, however, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we create a pointer to an integer, but we define the pointer
    type as `void *`, which tells the compiler we are creating a pointer with no type.
    We then create two additional pointers—a pointer to an integer, and a pointer
    to a floating point number. Both of these additional pointers are initialized
    using the `void *` pointer we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this example is that the standard C compiler is performing
    automatic type casting, changing a `void *` into both an integer pointer and a
    floating point number pointer. If both of these pointers were used, corruption
    would occur in a couple of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the architecture, a buffer overflow could occur, as an integer
    could be larger than a float and vice versa. It depends on the CPU being used;
    a topic that will be discussed in more detail in [Chapter 3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml), *System
    Types for C and C++*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the hood, an integer and a floating point number are stored differently
    in the same memory, meaning any attempt to set one value would corrupt the other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thankfully, modern C compilers have flags that are capable of detecting this
    type of type casting error, but these warnings must be enabled as they are not
    on by default, as shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious issue with pointers is not just that they can point to anything
    in memory and redefine that memory's meaning, but that they can also take on a
    null value. In other words, pointers are considered optional. They either optionally
    contain a valid value and point to memory, or they are null.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, pointers should not be used until their value is determined
    to be valid, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we create a pointer to an integer that is initialized
    with the location of a previously-defined integer with an initial value of `42`.
    We check to make sure `p` is not a null pointer, and then output its value to
    `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: The addition of the `if()` statement is not only cumbersome—it isn't performant.
    For this reason, most programmers would leave out the `if()` statement, knowing
    that, in this example, `p` is never a null pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this is, at some point, the programmer could add code to this
    simple example that contradicts this assumption, while simultaneously forgetting
    to add the `if()` statement, resulting in code that has the potential to generate
    a hard-to-find segmentation fault.
  prefs: []
  type: TYPE_NORMAL
- en: As will be shown in the next section, the C++ standard addresses this issue
    by introducing the notion of a *reference*, which is a non-optional pointer, meaning
    it is a pointer that must always point to a valid, typed, memory location. To
    address this issue in standard C, null pointer checks are usually (although not
    always) checked by public-facing APIs. Private APIs typically do not check for
    null pointers to improve performance, making the assumption, that so long as the
    public-facing API cannot accept a null pointer, it's likely the private API will
    never see an invalid pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard C arrays are similar to pointers. The only difference is that a C
    array leverages a syntax capable of indexing into the memory pointed to by a pointer,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we create an array of integers with 2 elements initialized
    to the values `42` and `43`. We then create a pointer that points to the array.
    Note that the `&` is no longer needed. This is because the array is a pointer,
    thus, we are simply setting one pointer to the value of another (instead of having
    to extract a pointer from an existing memory location).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we print the value of each element in the array using both the array
    itself and the pointer to the array using pointer arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: As will be discussed in [Chapter 4](57bdbfbb-03ce-45e3-b3ac-108daf3ac728.xhtml),
    *C++, RAII, and the GSL Refresher*, there is little difference between an array
    and a pointer. Both perform what is known as **pointer arithmetic** when an attempt
    is being made to access an element in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'With respect to system programming, pointers are used extensively. Examples
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Since standard C doesn't contain the notion of a *reference* as C++ does, system
    APIs that must be passed by a reference because they are too large to be passed
    by a value, or must be modified by the API, must be passed by a pointer, resulting
    in the heavy use of pointers when making system calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System programming often involves interacting with pointers to a location in
    memory, designed to define the layout of that memory. Pointers provide a convenient
    way to accomplish this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Standard C not only defines a syntax, the environment, and how programs are
    linked, it also provides a set of libraries that may be leveraged by a programmer
    to perform system programming. Some of these libraries are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`errno.h`: Provides the code needed for working with errors. This library will
    be discussed in further detail in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml),
    *Error - Handling with Exceptions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inttypes.h`: Provides type information, which will be discussed in [Chapter
    3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml), *System Types for C and C++.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits.h`: Provides information about the limits of each type, which will
    be discussed in [Chapter 3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml), **System
    Types for C and C++.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setjump.h`: Provides the APIs for C-style exception handling, which will be
    discussed in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml), *Error
    - Handling with Exceptions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signal.h`: Provides APIs for handling signals sent from the system to your
    program, which will be discussed in [Chapter 5](c2403e99-dbe5-46ae-858f-afe6102f2aeb.xhtml), *Programming
    Linux/Unix Systems*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stdbool.h`: Provides type information, which will be discussed in [Chapter
    3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml), *System Types for C and C++.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stddef.h`: Provides type information, which will be discussed in [Chapter
    3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml), *System Types for C and  C++.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stdint.h`: Provides type information, which will be discussed in [Chapter
    3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml), *System Types for C and C++.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stdio.h`: Provides functions for working with input and output while system
    programming, which will be discussed in [Chapter 6](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml), *Learning
    to Program Console Input/Output*, and [Chapter 8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml), *Learning
    to Program File Input/Output*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stdlib.h`: Provides various utilities, including dynamic memory allocation
    APIs, which will be discussed in [Chapter 7](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml), *A
    Comprehensive Look at Memory Management*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.h`: Provides facilities for working with clocks, which will be discussed
    in [Chapter 11](037338df-a0a2-455e-b03a-c16e6b3c3c3d.xhtml), *Time Interfaces
    in Unix.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As stated previously, the bulk of this book will focus on these facilities and
    how they support system programming.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the C++ standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ programming language (originally called C with Classes) was designed
    specifically to provide higher-level facilities than C, including better type
    safety and object-oriented programming, with system programming in mind. Specifically,
    C++ aims to provide the performance and efficiency of C programs, while still
    providing the features of higher-level languages.
  prefs: []
  type: TYPE_NORMAL
- en: Today, C++ is one of the most popular programming languages in the world, used
    in everything from avionics to banking.
  prefs: []
  type: TYPE_NORMAL
- en: Like the C standard, the C++ standard is huge and is managed by the ISO. We
    assume the reader has some basic knowledge of the C++ standard and how to write
    C code: [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, the goal of this section is to discuss some topics that are
    discussed in lesser detail in other books, as well as portions of the C++ standard
    that are relevant to this book and system programming but are missing from the
    other chapters. Please see the *Further reading* section of this chapter for additional
    information on the C++ programming language, and how to write C++ programs.
  prefs: []
  type: TYPE_NORMAL
- en: How the standard is organized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like the C standard specification, the C++ specification is broken up into
    three major groups of sections:'
  prefs: []
  type: TYPE_NORMAL
- en: General conventions and concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be noted that the C++ standard is considerably larger than the C standard.
  prefs: []
  type: TYPE_NORMAL
- en: General conventions and concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first four sections in the standard are dedicated to conventions and concepts.
    They define types, program start-up and shutdown, memory, and linking. They also
    outline all of the definitions and keywords that are needed to understand the
    rest of the specification.
  prefs: []
  type: TYPE_NORMAL
- en: As in the standard C specification, there are a lot of things defined in these
    sections that are important to system programmers, as they define what the compiler
    will output when a program is compiled, and how that program will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Language syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next 12 sections in the specification define the C++ language syntax itself.
    This includes C++ features such as classes, overloading, templates, and exception
    handling. There are entire books written on just these sections of the specification.
  prefs: []
  type: TYPE_NORMAL
- en: We assume the reader has a general understanding of C++ and we do not go over
    this part of the specification in the book, except the C++17-specific modifications
    in [Chapter 4](57bdbfbb-03ce-45e3-b3ac-108daf3ac728.xhtml), *C++, RAII, and the
    GSL Refresher*.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The remaining 14 sections in the specification define the libraries that C++
    provides as part of the specification. It should be noted that the bulk of this
    book revolves around this part of the specification.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we discuss in great detail the facilities that C++ provides for
    system programmers, and how to use those facilities in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Linking C++ applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in C, C++ applications typically start from a `main()` function with the
    same signatures that C already provides. Also, as in C programs, the actual entry
    point of the code is actually the `_start` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike in C, however, C++ is far more complicated, including a lot more code
    for a simple example. To demonstrate this, let''s look at a simple `Hello World\n` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'First and foremost, the C++ application example is slightly longer than the
    equivalent C example from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the symbols in our example, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As previously stated, our program contains a `main()` function and a `_start()`
    function. The `_start()` function is the actual entry point of the application,
    while the `main()` function is called by the `_start()` function after initialization
    has completed.
  prefs: []
  type: TYPE_NORMAL
- en: The `_init()` and `_fini()` functions are responsible for global construction
    and destruction. In the case of our example, the `_init()` function creates the
    code needed by the C++ library to support `std::cout`, while the `_fini()` function
    is responsible for destroying these global objects. To do this, the global objects
    register with the `__cxa_atexit()` function, and are eventually destroyed using
    the `__cxa_finalize()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the symbols make up the code for `std::cout`, including references
    to `ios_base{}` and `basic_ostream{}`.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to note here is that, as in C, there is a lot of code that
    executes both before and after the `main()` function, and using global objects
    in C++ only adds to the complexity of starting and stopping your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we use the `_C` option to demangle our function names.
    Let''s look at the same output with this option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As shown, some of these functions are still readable, while others are not.
    Specifically, the C++ specification dictates that certain support functions are
    linked using C linkage, preventing mangling. In our example, this includes the
    `__cxa_xxx()` functions, `_init()`, `_fini()`, `main()`, and `_start()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ library functions that support `std::cout`, however, are managed with
    an almost unreadable syntax. On most POSIX-compliant systems, these mangled names
    can be demangled using the `C++filt` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These names are mangled because they contain the entire function signature
    in their name, including the arguments and specializations (for example, the `noexcept`
    keyword). To demonstrate this, let''s create two function overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we created two functions with the same name, but with
    different function signatures, a process known as **function overloading**, which
    is specific to C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the symbols in our test application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of reasons why function names are mangled in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: Encoding function arguments in the function's name means functions can be overloaded,
    and the compiler and the linker will know which function does what. Without name
    mangling, two functions with the same name but different arguments would look
    identical to the linker, and errors would occur.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By encoding this type of information in the function name, the linker is able
    to identify whether a function for a library was compiled using a different signature.
    Without this information, it would be possible for the linker to link, for example,
    a library compiled with a different signature (and therefore a different implementation)
    to the same function name, which would lead to a hard-to-find error, and likely
    corruption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The biggest issue with C++ name mangling is that small changes to a public-facing
    API result in a library no longer being able to link with already-existing code.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to overcome this problem, but, in general, it's simply important
    to understand that C++ encodes a lot of information about how you write your code
    in a function's name, making it imperative that public-facing APIs do not change
    unless a version change is expected.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One major difference between C and C++ is how the construction and destruction
    of an object is handled. Let''s take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Unlike in C, in C++ we are able to use the `{}` operator to define how we would
    like the data values of the structure to be initialized. This is possible because,
    in C++, objects (both structures and classes) contain constructors and destructors
    that define how the object is initialized on construction and destroyed on destruction.
  prefs: []
  type: TYPE_NORMAL
- en: When system programming, this scheme will be used extensively, and the idea
    of the construction and destruction of objects will be leveraged throughout this
    book when handling system resources. Specifically, a scope will be leveraged to
    define the lifetime of an object, and thus the system resource that the object
    owns, using a concept called **Resource Acquisition is Initialization** (**RAII**).
  prefs: []
  type: TYPE_NORMAL
- en: Pointers versus references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed pointers in length, including how pointers
    can take on two values—valid or null (assuming corruption is not part of the equation).
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this is that the user must check whether the pointer is valid
    or not. This is normally not an issue when using pointers to define the contents
    of memory (for example, laying out memory using a data structure), but often,
    pointers in C must be used simply to reduce the overhead of passing a large object
    to a function, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we create a structure that has eight variables in it.
    Passing this type of structure with a value would result in the use of the stack
    (that is, several memory accesses). It is far more efficient to pass this structure
    with a pointer in C to reduce the cost of passing the structure to a single register,
    likely removing all memory accesses entirely.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that, now, the test function must check to make sure the pointer
    is valid before it can use it. Therefore, the function trades a set of memory
    accesses for a branch statement and possible pipeline flush in the CPU, when all
    we are trying to do is reduce the cost of passing a large object to a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated in the previous section, the solution is to simply not verify the
    validity of the pointer. In C++, however, we have another option, and that is
    to pass the structure with a reference, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, our `test()` function takes a reference to `mystruct{}`
    instead of a pointer. When we call the `test()` function, there is no need to
    get the address of the structure, as we are not using a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: C++ references will be leveraged heavily throughout this book, as they greatly
    increase both the performance and stability of a program, especially while system
    programming, where resources, performance, and stability are critical.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ not only defines the basic environment and language syntax—it also provides
    a set of libraries that may be leveraged by a programmer to perform system programming.
    These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Console input/output libraries**: These include the `iostream`, `iomanip`,
    and `string` libraries, which provide the ability to work with strings, format
    them, and output them (or grab input from the user). We will discuss most of these
    libraries in [Chapter 6](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml), *Learning
    to Program Console Input/Output*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory management libraries**: These include the memory library, which contains
    memory management utilities that help to prevent dangling pointers. They will
    be discussed in [Chapter 7](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml), *A Comprehensive
    Look at Memory Management.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File input/output libraries**: These include the `fstream` and `filesystem`
    (new to C++17) libraries, which will be discussed in [Chapter 8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml), *Learning
    to Program File Input/Output.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time libraries**: These include the `chrono` library, which will be discussed
    in [Chapter 11](037338df-a0a2-455e-b03a-c16e6b3c3c3d.xhtml), *Time Interfaces
    in Unix.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Threading libraries**: These include the `thread`, `mutex`, and `conditional_variable`
    libraries, which will be discussed in [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml), *Learn
    to Program POSIX and C++ Threads*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error-handling libraries**: These include the exception support libraries,
    which will be discussed in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml), *Error
    - Handling with Exceptions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginning with the POSIX standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The POSIX standard defines all of the functionality a POSIX-compliant operating
    system must implement. With respect to system programming, the POSIX standard
    defines the system call interface (that is, the APIs, not the ABIs) that the operating
    system must support.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, most of the system-level APIs that C and C++ provide actually
    execute POSIX functions, or are POSIX functions themselves (as is this case with
    a lot of C library APIs). In fact, `libc` is generally considered to be a subset
    of the greater POSIX standard, while C++ leverages `libc` and POSIX to implement
    its higher-level APIs such as threading, memory management, error handling, file
    operations, and input/output. For more information, refer to [https://ieeexplore.ieee.org/document/8277153/](https://ieeexplore.ieee.org/document/8277153/).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss some components of the POSIX standard that
    are relevant to system programming. All of these topics will be discussed in further
    detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the memory management functions that `libc` provides are considered POSIX
    APIs as well. In addition, there are some POSIX-specific memory management functions
    that `libc` doesn't provide, such as aligned memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following demonstrates how to allocate aligned dynamic (heap)
    memory using POSIX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `posix_memalign()` function to allocate an array
    of `42` integers, which is aligned to a page. This is a POSIX-specific function.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we leverage the `std::clog()` function to output an error to `stderr`,
    which, under the hood, leverages POSIX-specific functions for outputting character
    strings to `stderr`. We also use `::exit()`, which is a `libc` and POSIX function
    for exiting an application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we leverage both the `std::cout()` and `free()` functions. `std::cout()`
    uses POSIX functions to output character strings to `stdout`, while `free()` is
    both a `libc` and POSIX-specific function for freeing up memory.
  prefs: []
  type: TYPE_NORMAL
- en: In this simple example, we are leveraging several C, C++, and POSIX-specific
    functionalities to perform system programming. Throughout this book, we will discuss
    how to leverage POSIX heavily to program the system to accomplish specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: POSIX not only defines how to read and write a file from a POSIX-compliant operating
    system, it also defines where files should be located on the filesystem. In [Chapter
    8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml), *Learning to Program File Input/Output*,
    we will go into great detail about how to read and write to a filesystem using
    C, C++, and POSIX.
  prefs: []
  type: TYPE_NORMAL
- en: 'With respect to the layout of the filesystem, POSIX defines where files should
    be located, including common folders such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/bin`: for binaries used by all users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/boot`: for files needed to boot the operating system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev`: for physical and virtual devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc`: for configuration files needed by the operating system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home`: for user-specific files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib`: for libraries needed by executables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mnt and /media`: used as temporary mount points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sbin`: for system-specific binaries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp`: for files that are deleted on reboot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr`: for user-specific versions of the preceding folders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To perform networking on a POSIX-compliant operating system, you need to leverage
    the POSIX sockets API. The socket programming interface provided by POSIX is a
    good example of a set of APIs that is provided by neither C nor C++, but is needed
    for networking on POSIX-compliant operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](2d0b3ea6-499f-4064-a278-c480d2c74c75.xhtml), *Programming POSIX
    Sockets Using C++*, we will discuss how to perform networking using the POSIX
    sockets API, while leveraging C++. Specifically, we will show how C++ can be leveraged
    to simplify the implementation of socket-based networking, and provide several
    examples of how to perform networking.
  prefs: []
  type: TYPE_NORMAL
- en: Threading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Threads provide a system programmer with a means to perform parallel execution.
    Specifically, a thread is a unit of execution that the operating system schedules
    when it deems appropriate. Both C++ and POSIX provide APIs for working with threads,
    with the C++ APIs arguably being easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that, under the hood, C++ leverages the POSIX threads library
    (pthreads)—so, even though C++ provides a set of APIs for working with threads,
    in the end, POSIX threads are responsible for threading in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is simple. POSIX defines the interface a program leverages
    to talk to the operating system. In this case, if you wish to tell the operating
    system to create a thread, you must do so by leveraging the APIs defined by the
    operating system. If the operating system is POSIX-compliant, those interfaces
    are POSIX, regardless of any abstractions that might be put in place to make working
    with the APIs easier.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about three different standards: C, C++, and POSIX.
    The C standard defines the popular C syntax, C-style program linking and execution,
    and the standard C libraries that provide cross-platform APIs to wrap an operating
    system''s ABIs.'
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the C++ standard, and how it defines the C++ syntax, program
    linking and execution, and the high-level C++ APIs that wrap underlying C and
    POSIX APIs to C++.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how the POSIX standard provides additional APIs that go beyond
    C. These APIs include (but are not limited to) memory management, networking,
    and threading. In general, the POSIX standard defines all the standards needed
    for an application to perform its functions in a cross-platform way on any POSIX-compliant
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this book will focus on the APIs defined in these standards,
    and how they can be used to perform system programming in C++17\. In the next
    chapter specifically, we will cover the system types provided by C, C++, and POSIX,
    and how they affect system programming.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is the C standard part of the POSIX standard? If so, name an API that is common
    to both standards.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `_start()` and `main()` functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List one of the responsibilities of the C runtime?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are global constructors executed before or after the `main()` function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is C++ name mangling, and why is it needed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name one difference between C and C++ program linking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a pointer and a reference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
