- en: Attacking Availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing a deauthentication flood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting beacon frames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spoofing beacon frames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a beacon flood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARP cache poisoning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've looked at two of the three components of the CIA triad. Now it's
    time to look at the third and final part of the CIA triad, which is availability.
    Simply put, availability deals with the issues revolving around the loss of access
    to a resource, such as a file or computer or even a whole network, as we will
    see in this chapter. As you can imagine, a loss of availability is a big issue
    mainly due to the fact that if you can't access something, no matter what that
    might be, it essentially becomes worthless to you until you can gain access to
    it again. It's also not too much of a stretch to say that the loss of access to
    an item also is quite frustrating as it means you may be unable to complete your
    job or task until such access is reacquired.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about this for a second when we discuss the concept of availability.
    Imagine a situation in a wireless base network or environment where clients are
    relying on constant reliable access to files, servers, even to the internet, where
    wireless access is lost. In this situation, if these clients are relying on that
    access to carry out their work, you can have a business or client that is effectively
    unable to operate, meaning that the business itself may be unable to operate,
    which is definitely not an ideal situation. Keep in mind that in some cases even
    a partial loss or impeded availability can be enough to severely impact a business.
    We can imagine this situation simply by thinking about situations that we ourselves
    may have been in, such as connecting at a coffee shop, an airport, or even in
    a hotel to a wireless network. A network that is congested beyond capacity, and
    is extremely slow and giving unreliable access to resources is also going to have
    a substantial impact on the operations of the business. In fact, in this scenario
    even though access is there but it is very slow, it is still going to cause a
    business to grind to a halt which is unacceptable and needs to be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In wireless networks, countering the effects of availability is a tricky process
    but is very doable to undertake. You''ll find that you have several options to
    counter the types of attacks we are going to see in this particular chapter and
    make your wireless network much more resilient and resistant to the effect of
    a loss of availability. Just to give you a peek, here are some of the countermeasures
    we can employ that can limit the impact of a loss of availability or can even
    remove the possibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tuning**: What I mean by tuning is to set up and configure your wireless
    access point to avoid using channels and frequencies that other access points
    in the area may be using. By avoiding the use of those channels, you can go a
    long way toward preventing the slowdowns and loss of availability and reduced
    range that you get by competing for frequencies and congested channels. Now, keep
    in mind why you may not always be able to get exclusive use of a channel and frequency
    in a specific area. You can choose a channel and frequency that is less congested
    than other jails in the area, giving you a little more reading room than you would
    have on a more congested channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redundancy**: Using this technique simply means we implement something known
    as a mesh network, which is a spider web of sorts, set up between multiple access
    points that are used to cover an area. By using this setup, it is possible to
    have multiple access points covering an area in such a way that if any one of
    these access points, or even multiple access points, become congested we can arrange
    to give a strong signal other nodes or access points can pick up and give the
    client a stronger and more reliable signal. While this setup does take a little
    bit of planning and effort to make it work, it can reap big dividends for anyone
    dealing with the frustration of a slow or congested network. It is also worth
    noting that unlike some of the solutions that have been available over previous
    years, more user-friendly and even consumer-based solutions are available to set
    up mesh networks inexpensively and quickly from the home environment all the way
    up to large-scale enterprise deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enterprise authentication**: While this solution was mentioned in previous
    chapters on confidentiality and integrity, it actually takes on a different purpose
    here in terms of availability. An enterprise authentication system using its technology,
    such as radius or diameter, can make the authentication aspect of a wireless network
    much harder to knock offline and therefore make it more resilient in the face
    of denial of service-based attacks. Mainly employing this type of system or mechanism
    means that attackers have to put in more effort to bump this network offline via
    the authentication system than they would if they had an access point that did
    all the dedication right there on its own. The downside of the solution is that
    it does take more effort and more know-how to set up and make it work effectively,
    but it is something to consider if you want to give yourself a little extra protection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Patching and updating**: Well for anybody who has been in IT long enough,
    you probably don''t need me to explain the concept of patching and updating any
    of your firmware software on a regular basis, but it is worth mentioning. The
    reason we are patching and updating the firmware in our clients'' and our access
    points is to ensure that we are taking advantage of the latest features and fixes,
    some of which can enable us to thwart denial of service and other availability
    attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration**: This last one is a big area that covers a lot of ground
    that can help you tremendously in defeating the attack impacting availability.
    When I say it''s a big area, configuration covers everything from placement and
    setup of the access point, types of antennas to be used, parts of the facility
    or campus to be covered, to even little details such as how much ground you need
    to cover in relation to how far your clients are going to move around during their
    workday and require access to a wireless network while they''re doing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, this is a short list and is just meant to open your eyes to some
    of the things that can be used to thwart availability. You should always keep
    up-to-date on availability issues and wireless networks because it tends to be
    one of the areas that has the greatest impact in influencing how well a wireless
    network is going to be perceived and accepted by your client base. While confidentiality
    and integrity are important, clients are much more likely to notice issues related
    to availability than the other two. Slow networks and unavailable networks are
    much more obvious and therefore are something that should not only be addressed
    from a user happiness standpoint, but should also be addressed from a security
    standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Types of attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As was said, there are plenty of ways to impact the availability of a wireless
    network. They all have the same basic goal, which is to prevent the wireless network
    from being attached to and used effectively, or at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start discussing each of the attacks in depth, we should first define
    which attacks we are going to be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing a disassociation flood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting beacon frames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spoofing beacon frames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing a beacon flood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing a deauthentication flood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARP cache poisoning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a denial of service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding a wireless network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These attacks represent some of the more popular ways of impacting the availability
    of a wireless network, and as such we are presenting them here. As always, there
    are other availability attacks both deliberate and accidental that can plague
    your wireless environment that you'll need to research more on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a deauthentication flood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This first availability attack is an interesting one, and an effective one at
    that. This attack is known as a disassociation flood. In this type of attack,
    the malicious parties are trying to break the association that a client has with
    an access point. When this type of attack is carried out, clients will experience
    a situation where they are bumped off the wireless access point and will find
    themselves trying to reconnect to the access point. The key word here is if they
    can attach to the wireless access point. If this flood is carried out in a high
    enough volume, and maintained at that level, it can mean that no clients will
    be able to attach to the wireless network for very long, or at all, depending
    on how the conditions pan out.
  prefs: []
  type: TYPE_NORMAL
- en: Just to be clear, the type of attack we are discussing in this recipe is not
    a jamming-based attack. What we mean by jamming is that there is no radio signal
    or any interference being sent out that is used to block or discourage the use
    of the frequency that is being utilized by the wireless network. When performing
    a jamming-based attack, typically you would use something, such as a specific
    rebuilt device, designed to bombard the airwaves with radio traffic, in this case.
    While this attack will work because jamming disrupts the wireless frequencies,
    it is also indiscriminate in how it works. Basically, you can't pick and choose
    which clients will maintain a connection and which ones won't, nor can you choose
    the wireless network you want to block. Anything within range that operates on
    those frequencies will be blocked. This type of attack also has the very real
    issue of being illegal and subject to steep fines and even jail time if it is
    used. We will not be using jamming anywhere in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The only reason why this point is brought up is that sometimes a deuthentication
    flood is erroneously referred to as a jamming attack. The type of attack we're
    talking about is very selective, meaning it can knock out a wireless network or
    individual clients. It also does not bombard the airwaves with indiscriminate
    radio traffic, rather, it uses specially-crafted frames to target its victim or
    victims.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the questions that comes up with this type of attack is why does a deauthentication
    frame actually exist in a wireless network in the first place? Well, there''s
    actually a good answer for that, and the most obvious is that it can be used to
    disconnect wireless clients who are misbehaving or need to be disconnected for
    some reason. There are other reasons that this frame type is present as well.
    For example, using a deauthentication frame to kick off a client could be used
    in cases of rogue clients attaching to your wireless network. When they''re discovered,
    they can be selectively targeted and disconnected. Another more malicious use
    of this authentication frame could be not just to cause a denial of service, but
    it can also be to force a client to connect to a rogue access point that we control.
    In this situation, we would set up our own wireless access point in close proximity
    to the legitimate access point. Then we would send out deauthentication frames
    to kick people off the legitimate network and potentially force or entice them
    to attach to the access point that we control. This access point just happens
    to be available and ready and open to work with them. The following diagram shows
    the normal process of authenticating to a wireless network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41591879-7582-4f74-a622-ea94998fa2a2.png)'
  prefs: []
  type: TYPE_IMG
- en: The normal authentication process and deauthentication for wireless
  prefs: []
  type: TYPE_NORMAL
- en: It would really be remiss of me if I didn't mention another semi-legitimate
    (and I use that term lightly) use of a deauthentication frame that is that employed
    by some businesses. One example of this semi-legitimate use of a deauthentication
    frame happened in the United States where a hotel chain was found to be forcing
    people to use the hotel's Wi-Fi instead of Wi-Fi from another provider. In this
    situation, the hotel was using devices that transmitted deauthentication frames
    preventing hotel guests from using outside Wi-Fi and instead paying for the hotel's
    own Wi-Fi service. Once it was discovered that the hotel was using this type of
    device, it was quickly met with legal challenges by guests and clients. In the
    end, it was found that any and all hotels in the United States using this technique
    to force the usage of their service was illegal and any business employing this
    technique has been heavily fined and subject to legal action by the Federal Communications
    Commission.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that there is an ongoing debate as to whether or not
    the use of deauthentication floods can be employed in areas where the security
    of the facility and data transmission is desired. At this point, the answer seems
    to be that there really is no straightforward answer as deauthentication floods
    have been used to create safe spaces where only authorized networks are available
    to people in a certain business area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the concept of the deauthentication flood:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8953570e-9467-48c1-8dac-f65f3e801d00.png)'
  prefs: []
  type: TYPE_IMG
- en: A deauthentication flood
  prefs: []
  type: TYPE_NORMAL
- en: There is another use of deauthentication frames that can be very handy for someone
    performing pen testing against a wireless network, or network in general, and
    that is using it to grab passwords or keys for the network. In this situation,
    an attacker will send out an AE deauthentication flood and bump off clients for
    a client from a targeted network. When that client attempts to reconnect, the
    attacker will sniff the traffic that is generated during that connection and try
    to extract the connection information exchange. This type of attack can also be
    used to induce a man-in-the-middle situation where the attacker will deauthenticate
    a victim and then force them to re-authenticate through a rogue access point.
    They'll then direct the traffic on to an internet connection or whatever the actual
    legitimate network is. In essence, what is happening is that we would first issue
    a deauthentication frame or flood, and then we would use the man-in-the-middle
    or rogue access point setup that we explored in a previous chapter, and then we
    would be able to pick up these credentials as a handshake.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started, you will need to have the following items in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To perform an association flood, we simply need to use a combination of the
    steps that we've seen in earlier chapters, with a little extra added in to tweak
    it for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, we have a client attached to the wireless access point, or
    wireless router, going about their business. The attacker is going to attempt
    to break their connection to the network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get started, we need to first put our network card into monitor
    mode. Again, this is no different than what we have done in previous recipes.
    To make things simple, we will assume that our wireless adapter uses the name
    `wlan0`, but double-check to ensure the name is the same on your system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Much like before, the `airmon-ng` utility has switched our wireless card into
    monitor mode and should have renamed it to something along the lines of `mon0`.
    Once this is done, we will be capable of viewing all the traffic we need. The
    following screenshot shows the result of the `airmon-ng` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7187794-7544-4ddd-b956-778c3d4545e0.png)'
  prefs: []
  type: TYPE_IMG
- en: airmon-ng switching wlan0 into monitor mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to make use of the `airodump-ng` tool to capture information
    from the monitor interface, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the attacker will have access to information regarding wireless
    access points in the range of the targeting system (ESSID, Channel, BSSID, and
    so on):'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a list of networks in hand, we can now select one and put the hexadecimal
    value for that network into the `airodump-ng` command to focus on the specific
    network. The result of this command is that we will be able to retrieve a list
    of clients that are currently actively connected to the access point. To find
    this information, we will use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `airodump-ng` is the tool, `mon0` the interface, `-c` the channel, and
    `-bssid` the MAC address of the access point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63539b1d-eb2e-4fef-9cdd-3c6dc598363a.png)'
  prefs: []
  type: TYPE_IMG
- en: Upon closer examination, the results will show the clients currently attached
    to the access point. To make this easy, you simply browse the list of clients,
    choose the one you want to knock off, and note its MAC address, such as `00:13:CE:AC:70:BE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to actually deauthenticate or disassociate the client from
    the access point. We do this like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `aireplay-ng` is the tool, `-0` the parameter for the deauthentication
    attack, `1000` is the number of deauths to be transmitted, `-a` the MAC address
    of the wireless router, `-c` the MAC address of the client, and `mon0` the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21b3769e-8f34-4da3-bb17-d6fd75755311.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that the attack is performed successfully. The
    client is disconnected from the network and cannot establish a connection until
    the attacker stops sending deauthentication messages.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting beacon frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we discussed beacon frames and their importance to wireless networks,
    as well as how they can be used in a wireless network. Now, let's take a closer
    look at them and see what is in a beacon frame and how to analyze it so we can
    use that information for later attacks in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is a beacon frame? A beacon frame is something that is sent out by
    a wireless access point that identifies the name of the wireless network, some
    parameters regarding that wireless network, as well as some other information
    tucked in there for housekeeping and other tasks. A beacon frame is sent out by
    every wireless network at regular intervals and is used to announce the presence
    of that network to wireless clients and devices that are in range of that access
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down some of the pieces or components in a beacon frame sent out
    by a wireless LAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timestamp**: The timestamp is included as part of a beacon frame for this
    very specific purpose: the timestamp is used as a means to inform all the wireless
    clients and devices on that network to synchronize or set their clocks to that
    time. This allows the network to operate more efficiently and effectively than
    it would if the clocks run different intervals and don''t synchronizing with one
    another. This timestamp is sent out with the beacon and the clients won''t turn
    look at the timestamp and set their clocks to this time so everyone participating
    on the wireless LAN is in step with one another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beacon interval**: As you can imagine, with a name like beacon interval,
    this must tell us how often a beacon frame is sent out. This value will tell nodes
    on the wireless LAN how often a beacon frame must be sent out. On some wireless
    networks this is a user, or system administrator, configurable setting. However,
    on most consumer-grade access points and devices, this is not accessible and is
    defined by the manufacturer at the time of manufacture of the access point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capability information**: This is actually an important component of a beacon
    frame because it describes the format of the network, whether it is running infrastructure
    or ad hoc mode, whether it is using certain security features, and even what type
    of encryption it supports, if any. As you can imagine, getting this information
    and being able to dissect it can tell you quite a bit about how the network is
    operating and what you need to know to defeat it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something to keep in mind regarding intervals of beacon frames is that while
    they can be adjusted on wireless networks, it may not be ideal to change intervals
    under every condition. While there are benefits, there can also be some downsides
    that you need to be cautious of. For example, speeding up the transmission of
    beacon frames has the benefit of sending these beacon frames more frequently,
    but will also result in additional traffic on the network, which means that taking
    bandwidth, or throughput more specifically, away from users on the network, which
    means you effectively made the network slower.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of speeding the beacon frame up is that clients can associate with
    the network much faster, and if they roam around, they will be able to keep track
    of network and service changes much more rapidly. On the other hand, stretching
    out the time between beacon frames will reduce the overhead on the network. The
    immediate impact of this is that associations are slower and clients that tend
    to roam have a much slower process of association and will not get information
    about network changes in data throughput as quickly. If you are a wireless network
    engineer, it is usually best to leave the beacon interval alone because it can
    have a negative impact as much as it can have a positive impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, beacon frames do add a little bit to the traffic generated on
    a wireless network. However it is generally minimal and it is important to have
    this beacon sent out to make the network function. When a wireless client is scanning
    and looking for wireless networks across the channels it supports, it is looking
    for beacon frames that will tell it that there is an access point area and some
    details about that access point. This information also allows a client to determine
    not only the wireless networks in the area and the capabilities, but also allows
    them to prioritize and sort them depending on capabilities and services they are
    offering, and therefore allows the user or the client itself to determine which
    is the optimal network to attach to. The following screenshot shows beacon frames
    captured in Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aae8405a-6c08-44f6-b69e-809b09de91bb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Beacon frames showing in Wireshark
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that even after a client has associated with a wireless network,
    the scanning process still continues and the client is still looking for beacons
    across other channels that identify other wireless networks. The idea behind this
    is by constantly scanning and looking for other wireless networks, it gives the
    user the ability to switch to an alternative network if the current network is
    not sufficient or becomes unavailable. The beacon frames also serve the benefit
    of synchronizing the clocks, this will happen not only once but at regular intervals
    to make sure that the clocks always stay synchronized with a close tolerance,
    and they don't slowly come out of sync with one another so it serves that critical
    purpose. The beacon frame also serves as a handy mechanism to inform clients attached
    to the network that changes in the network, such as speed or channel, are going
    to happen and they need to be prepared for it and anticipate the change.
  prefs: []
  type: TYPE_NORMAL
- en: All this being said, let's move on to actually capturing and analyzing beacon
    frames so we connection to see what is contained within them first hand and what
    that means to us. This information is not an attack on its own, but it is something
    that can be used as a precursor to the attacks we are going to see in this chapter;
    as such, we will use this recipe to familiarize you with this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started, you will need to have the following items in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux with Wireshark installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kismet is an effective tool for locating and extracting useful information from
    wireless access points and devices, and in this case, it will be used to detect
    the beacon frames that are transmitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will start Kismet from the Command Prompt. However it can
    also be started from the Wireless Attacks section of the Applications menu. In
    either scenario, starting up Kismet will result in the steps documented here:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the Command Prompt, enter the `kismet` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will now be configuring Kismet from a semi-graphical environment. You will
    be using the *Tab* and *Enter* keys to navigate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the *Tab* key to highlight `No` if you cannot see the line of grey letters.
    Otherwise, leave `Yes` highlighted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *Enter* key once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *Enter* key once to acknowledge that Kismet is running as root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *Enter* key once to automatically start the Kismet server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *Enter* key once to verify that you want to start the Kismet server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *Enter* key to verify that you can to add a capture source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the name of your wireless interface using `ifconfig`. If you don''t
    remember it, you can open up another console window and run the `ifconfig` command
    again to determine the correct interface (it will usually be named something starting
    with `wlan`). The following screenshot shows the interface entry screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b008c405-9dc6-4542-98e1-1f2affdfe152.png)'
  prefs: []
  type: TYPE_IMG
- en: Kismet interface configuration
  prefs: []
  type: TYPE_NORMAL
- en: Press the *Tab* key once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the name of the wireless interface in the `Name` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *Tab* key once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *Tab* key again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *Enter* key once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kismet should recognize the named wireless interface if you entered the name
    correctly. It will also generate the names of unneeded virtual interfaces such
    as `wlan0mon`, `wlan0monmon`, and `wmaster0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `Close Console Window` is displayed at the lower right hand corner of the
    shell (Kismet window), press the *Tab* key once to highlight `Close Console Window`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *Enter* key once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A list of wireless access points will be displayed in the upper left-hand quadrant
    of the Shell (Kismet window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click View on the pull-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Monitor for Activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have gotten to this point, you will see that access point names (as
    well as clients) will start to rapidly populate the interface. As we saw before
    with this tool, there are associated details and information with each network
    name or SSID that appears on your list. Each of these entries is populated from
    information extracted from beacon frames that will start to populate the window.
    You will see the names, channel, wireless standard, and other information associated
    with each device. If you wait long enough, you will notice that additional devices
    will appear and other items listed may have more information populated that may
    not have been present before.
  prefs: []
  type: TYPE_NORMAL
- en: 'While viewing the list of networks showing up in the Kismet window, it is possible
    that you might see some entries that look a little different. For example, take
    a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43946ede-ad9a-418e-a2d2-48f4f297d7e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Showing main Kismet window displaying detected wireless clients.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the items in the windows, you will notice that there is an entry
    for `Probe Networks` if you move over this item in the list and use the *+* or
    *-* keys to open or close the selection. When you expand the item, there will
    be a list of items displayed. This list documents probe requests that are coming
    from nearby systems. These problems are sent by a wireless-enabled system that
    is attempting to attach to a network that it had attached to in the past. A careful
    analysis of the network names that show up under probe requests can reveal the
    names of different access points the system attached to and give you an idea of
    how or where the system may have been used. Keep in mind that many operating systems
    send these probes out as long as the device is unassociated with a wireless network.
  prefs: []
  type: TYPE_NORMAL
- en: There are other software packages that can be used to do the same thing that
    Kismet is doing, however Kismet has the advantage of being highly customizable
    and passive. Passive means that the software does not transmit anything out to
    elicit a response from wireless access points in the area. Instead the software
    listens for connections and traffic associated with an access point to reveal
    its presence and determine its name. Additionally, the software package has the
    ability to detect access points that are hidden where other similar packages may
    not be able to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: Spoofing beacon frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we are going to take a look at spoofing beacon frames. Now that
    we have seen what a beacon frame actually looks like, and some of the properties
    of a beacon frame, we can kind of understand the value of forging a beacon frame
    and how that might be employed to affect the availability of a wireless network
    or access point specifically.
  prefs: []
  type: TYPE_NORMAL
- en: After examining the contents of the beacon frame, we could see that important
    information such as the sinking of time, the identification of a network, as well
    as other properties are contained within this vital frame. If an attacker wants
    to disrupt the operation of a wireless network, such as slowing the network down
    or making the network unavailable, a beacon frame is an ideal place to undertake
    this action.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know upfront what makes the spoofing of a beacon frame possible.
    An acceptable form of disrupting a wireless network is a lack of verification
    or validation of forged frames. While products and technologies have appeared
    on the market over the last several years designed to aid the detection of frames
    that are forged to a wireless network, this is far from being a common occurrence
    that can be used to secure a wireless network. For the wireless networks that
    do employ some sort of detection for forged frames, there lies another problem,
    due to the unstable nature of wireless networks and the diverse forms of communication
    available across different vendors, it becomes even trickier to detect a forged
    frame. Again, system and network administrators have techniques that can be combined
    to cover the whole spectrum and allow forged frames to be detected and therefore
    prevent these types of attack.
  prefs: []
  type: TYPE_NORMAL
- en: One very important thing to consider when reviewing a beacon frame that can
    be used against a target network, is that it's not an easy attack to perform.
    While we make it sound easy, in practice it is going take some patience and effort
    to make it work correctly. While a malicious party could look online for the specifics
    on how to carry out this attack or even read the steps here,  it still can take
    a little bit of trial, error, and patience.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing to keep in mind with this type of attack is that it definitely
    can be detected as technologies and techniques have advanced far enough that they
    offer an effective way of detecting a spoof beacon frame. The challenge for the
    network owner is to understand that this is a potential attack. They need to understand
    that this is something that they should deploy, or employ protection for, to lower
    the risk of this type of attack occurring.
  prefs: []
  type: TYPE_NORMAL
- en: Let's briefly take a look at the process of spoofing a beacon frame before we
    go through the individual steps of making this attack happen successfully. What
    I'm going to do is describe the individual components and give an idea of the
    anatomy of this type of attack and then we're going to move on and go into implementing
    the attack in a real-world environment.
  prefs: []
  type: TYPE_NORMAL
- en: At its most basic level, there are actually two phases to carrying out a spoofed
    beacon frame attack, and one of the phases relies on a tool we already know, which
    is `airmon-ng`. This tool is used to put our wireless adapter into monitor mode
    so it is able to observe traffic from all wireless networks in the area even if
    it is not associated with any of them. Spoofing beacon frames using this utility
    will not be any different than any of the other times you used it. We will just
    tell the utility to go into monitor mode on a specific interface and then that
    phase is done.
  prefs: []
  type: TYPE_NORMAL
- en: The second phase of spoofing, or forging, a beacon frame is the one where the
    magic happens and makes the process what it is. To carry out the second phase,
    we will be using a tool known as `mdk3`, which is another command-line utility
    included in the arsenal of this clinic's distribution. This utility will allow
    us to generate beacon frames with any name and properties that we choose to transmit
    in the open. The end result is that this utility can send out a mass of beacon
    frames, that can be read out of a text file that you can pre-populate with your
    own names. This will generate what amounts to a sea of fake access points in the
    area that will slow down and confuse clients, and in some cases, even break their
    association with their current network if the name happens to be the same. What
    we are doing here is creating a denial of service through the use of this single
    utility.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started, you will need to have the following items in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The items listed here are basic requirements and you could easily use more (or
    different) components if you desired. If you want an enhanced range, for example,
    you could use a USB-based wireless card that has connections for an external antenna
    that could get better reception.
  prefs: []
  type: TYPE_NORMAL
- en: Something important to remember in this exercise is that we will be using a
    series of tools that all come from one suite designed to crack and analyze the
    traffic from wireless networks. While there are probably a dozen tools included
    in the suite, we only make use of about three or four in this chapter. However,
    we will revisit different tools from the suite in subsequent chapters and use
    them along the way. This will serve as your first exploration of some of the members
    of the air crack suite.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to put the wireless adapter into monitor mode. In this case,
    we will assume that our wireless adapter uses the name `wlan0` (much like before),
    but double-check to ensure the name is the same on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Much like before, the `airmon-ng` utility has switched our wireless card into
    monitor mode and should have renamed it to something along the lines of `mon0`.
    Once this is done, we will be capable of viewing all the traffic we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19864580-bf33-43bf-aadb-bd794f716afa.png)'
  prefs: []
  type: TYPE_IMG
- en: airmon-ng switching wlan0 into monitor mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to make use of the `airodump-ng` tool to capture information
    from the monitor interface, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the attacker will have access to information regarding wireless
    access points in the range of the targeting system (ESSID, Channel, BSSID, and
    so on).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have selected a network from the list that we want to spoof, we can
    move on to the next step, which is to use a tool known as `mdk3`. The `mdk3` is
    a utility that is used to exploit vulnerabilities and other issues present in
    the 802.11 standard, one of them being the ability to forge beacon frames.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `mdk3` tool, we can pick an access point off the list or use a name
    of our making. Once we have a name in mind, we run the `mdk3` command using the
    following syntax (we will fake a network called `impa`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `b` activates the beacon flood mode, `-n` sets the name, `-b 54` makes it
    `54` MB, `-w a` enables WPA2/AES only, `-m` makes `mdk3` only use valid addresses
    so the attacker will have a hard time filtering, and `-c` sets the correct channel.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you use another wireless device to check for wireless networks
    in the area, you will see a new network being broadcast, in this case named IMPA.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a beacon flood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will continue our line of thinking and exploration from
    the previous recipe where we spoofed a beacon frame, but we are going to raise
    the bar in intensity by trying to attempt a flood of beacon frames. In the previous
    recipe, we mainly focused on how to create a spoofed beacon frame. Here, what
    we want to do is send out wave after wave of fake access points with the intention
    that we can confuse clients in the area and cause them to have performance issues.
    In fact, the fascinating thing about performing a beacon flood is that under certain
    conditions it can cause scanners, software, and even drivers to not just under-perform
    but actually crash or even lock up the system they''re present on. You can imagine
    this is a denial of service and would be very frustrating for the owner of those
    software devices or whatever node is having the problem. The following diagram
    shows the concept of a beacon flood:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f33b5e59-46be-412d-8215-d399323b77cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Concept of a beacon flood
  prefs: []
  type: TYPE_NORMAL
- en: With a beacon flood, we can generate massive amounts of fake access points as
    well as vary the parameters and channels of these fake access points, further
    refining and empowering the attack to do even more damage. You will find that
    the initial steps of this attack are exactly the same as they were in the previous
    recipe. Where the variation happens is when we start using the `mdk` utility to
    start varying those parameters with the intent of causing an impact.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started, you will need to have the following items in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The items listed here are basic requirements and you could easily use more (or
    different) components if you desired. If you want an enhanced range, for example,
    you could use a USB-based wireless card that has connections for an external antenna
    that could get better reception.
  prefs: []
  type: TYPE_NORMAL
- en: Something important to remember in this exercise is that we will be using a
    series of tools that all come from one suite of tools designed to crack and analyze
    the traffic from wireless networks, and why there are probably a dozen tools included
    in the suite while we only make use of about three to four of them in this particular
    chapter. However, we will actually revisit different tools from the suite in subsequent
    chapters and use them for different purposes along the way. So this will serve
    as your first exploration of some of the members of the air crack suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to put the wireless adapter into promiscuous mode or monitor
    mode. This is no different than we did in [Chapter 4](f9b496b9-0e8e-4fe2-bd99-8147e5b08816.xhtml),
     *Attacking Confidentiality*. In this case, we will assume that our wireless adapter
    uses the name `wlan0`, but double-check to ensure the name is the same on your
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Much like before, the `airmon-ng` utility has switched our wireless card into
    monitor mode and should have renamed it to something along the lines of `mon0`.
    Once this is done, we will be capable of viewing all the traffic we need. The
    following screenshot shows the result of the `airmon-ng` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7bb32ee-beaf-4d28-a57a-92a72272083b.png)'
  prefs: []
  type: TYPE_IMG
- en: airmon-ng switching wlan0 into monitor mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to activate the `airodump-ng` utility once again to see a
    list of wireless networks or access points in the area. Remember, we need to have
    a target network in mind to attack or this will not have the desired effect. The
    beacons we will be creating will be generated using the SSID of a given network
    that we will provide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the command executes correctly, we should see a list of wireless networks
    in the area. At this point, you will choose the one you want to target. You specifically
    want the information labeled ESSID for the station you wish to target; anything
    else (such as the BSSID) will require modification of the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have selected your target, you need to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to change the timing of the flood, you can add the `-s` command
    line, so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `360` is the number of packets that will be transmitted each second.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to view the flow of beacons, you could run Kismet on another Kali
    workstation and you would see a flood of beacons being received by the station
    representing the efforts of our original attacking system.
  prefs: []
  type: TYPE_NORMAL
- en: ARP cache poisoning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are not going to be directly assaulting the wireless network,
    but manipulating something that is present in the networks to carry out actions,
    such as sniffing or man-in-the-middle attacks. The technique we're exploring here
    is something known as ARP cache poisoning, and is something that can be used on
    any network that is using the TCP/IP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: So what is ARP? Well ARP, or address resolution protocol, is a component of
    the TCP/IP protocol that is used to link a logical addresses or IP addresses to
    a physical address or MAC address. In practice, the following is what happens
    with ARP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine a situation where you have two clients that are on the same
    subnet who wish to initiate communication with one another. In this situation,
    an IP address is not needed in the normal sense because there are no routing requirements
    present. In this situation, if a client wishes to send traffic to the other client,
    it will first check its ARP cache to see whether it had previously communicated
    with the intended target. If an IP to MAC address mapping exists in the ARP cache
    or table, then the sending station will just use that information to send the
    data that it desires to send to that recipient. However, if the information that
    is required to transmit the information isn''t present in the ARP cache, then
    it will send out an ARP broadcast on that subnet. When this broadcast is received
    by the client that the sender is looking for, the recipient will send back its
    IP address and MAC address combination to the sender. At that point, the sender
    will use this information to properly address and transmit the data thereby ensuring
    it gets to its intended destination, the IP and MAC address combination will also
    be retained in the local ARP cache so future transmissions can happen quicker.
    The following screenshot shows the contents of the ARP cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b20bf51a-2829-4de5-aa2f-750bbe5da2bb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ARP cache in Linux
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind when carrying out ARP cache poisoning is that you
    can poison them proactively and place information in their cache of a target using
    the techniques we're discussing. However, if the user or victim that is being
    targeted reboots that system, then the information you have placed in their cache
    will be wiped and you would have to re-initiate the poison.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dissect an ARP poisoning attack so we can understand what it is we're
    attempting to do to cause mischief. As we discovered, ARP has a very specific
    way of working to allow the ascending party to locate the IP address and MAC address
    combination of its intended recipient and that process is fairly simple in design.
    When forming a cache poisoning attack, we want to send forged or spoofed ARP replies
    to a victim with the intent that they will cache our reply and then use it when
    they're trying to send information later on during their operation. Now, take
    a close look at what I just said we're attempting to do. I said we're trying to
    send out in ARP reply, but I never said anything about going out to elicit that
    reply. In other words, this would be similar to my walking up to you and saying
    goodbye and then walking away. If I did that in real life, you would think I was
    a little crazy because there is nothing for me to say goodbye to. However, because
    of the way ARP works, this situation would actually work in the digital world.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the question here is what is in the reply that I send out in an attempt
    to poison your cache with? Well the answer is quite simple: what''s in there?
    An ARP broadcast is sent out because a system has an IP address of a client on
    the local subnet. Since it has no use for the IP address and local subnet, it
    wants to use the MAC address instead. So, by sending out this request to say,
    "I have this IP address, who owns this IP address right now" in which a MAC address
    is on your network card, I''m returned a combination of IP and MAC. What an attacker
    will do is modify this reply to say anytime you''re looking for a certain IP address,
    go to this other MAC address instead, which just happens to be the MAC address
    of a network card on the system that the malicious party is controlling. By sending
    this combination proactively to a victim, the ARP process is upended, as the transmitting
    system will look to see whether it has information about the station it is trying
    to transmit the data to, since this information will be proactively cached and
    no broadcast would have been made to find the real owner with the legitimate IP
    address to MAC address combination. The result is traffic will be directed to
    a client different from what the recipient believes to be correct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows an ARP attack in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfbc3a94-7da1-4536-a3f5-e3c21ce2aa85.png)'
  prefs: []
  type: TYPE_IMG
- en: An ARP cache poisoning attack
  prefs: []
  type: TYPE_NORMAL
- en: There are two sides to the coin as far as IP to MAC address resolution and combinations
    are concerned. ARP is used to resolve IP addresses to MAC addresses. However,
    there is a companion protocol known as RARP (reverse address resolution protocol)
    and this is used to resolve a MAC address to an IP address. While both of these
    protocols exist in their companions to one another, we really only have the need
    for ARP, and not reverse ARP. However, it is important to know that there is a
    companion protocol that exists.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started, you will need to have the following items in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The items listed here are basic requirements and you could easily use more (or
    different) components if you desired. If you want an enhanced range, for example,
    you could use a USB-based wireless card that has connections for an external antenna
    that could get better reception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to enable IP forwarding; this enables traffic forwarding
    so traffic is redirected through the attacker''s system. To carry out this attack,
    we carry out the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'View the value set for IP forwarding; this will return a value `1`. If it does
    not, repeat the preceding step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be : `1`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that the value of `1` here means that we are enabling IP forwarding. If
    we want to turn off this feature, we can run the same command with a `0` instead.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to redirect traffic as it moves through our system, this is
    easy to do through the use of the `iptables` command.
  prefs: []
  type: TYPE_NORMAL
- en: In this setup, traffic received on port `80` will be redirected to a different
    port number. In this case, port `80` is redirected to port `8080`, and port `443`
    is redirected to port `8883.` With this set of simple rules in place, the traffic
    will be redirected accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement our setup, we simply enter the following at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: iptables is a command-line utility that has been in Linux for a long time and
    is used to configure firewall settings within the Linux kernel. The utility is
    far more complex than is being covered here, but we only need to use the basics
    for our setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the important part, which is to perform the actual ARP spoofing.
    To do this, we will make use of the `arpspoof` command to change the victim system''s
    cache to have different values. In this case, we will be changing the default
    gateway to something different. We can do that by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'More specifically, we will change the victim machine to include a different
    address for the gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also perform the same against the gateway, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once these steps are complete, we will move into a phase where we can intercept
    requests as they move across the network. We have some choices in Kali for information
    gathering in this situation in the form of `sslstrip`/`drifnet`. Let's take a
    brief look at setting up each.
  prefs: []
  type: TYPE_NORMAL
- en: The `sslstrip` is a sniffing and man-in-the-middle utility designed to capture
    information moving across the SSL protocol. Information such as username, password,
    email account, and database user details could all be potentially intercepted
    using this command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will allow the attacker to sniff the traffic of target
    PC `192.168.1.23`  and specify the port defined in the `iptable nat` rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Wait a while to record sniffing data in `/usr/share/sslstrip/sslstrip.log`,
    or you can use a user-defined file to dump captured data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting utility is known as `driftnet`. Driftnetis a GUI-based
    tool that is designed to capture anything accessed from the browser. This utility
    is very simple to use and can be activated simply by using the `driftnet` command
    at the command line and the results will start to appear as traffic flows. The
    following is an example of output obtained using the utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f333b299-fb67-490f-baf5-f019b45eb538.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the driftnet command
  prefs: []
  type: TYPE_NORMAL
