- en: Chapter 3. SOLID Design Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building modular software requires strong knowledge of the class design. There
    are numerous guidelines out there, addressing the way we name our classes, number
    of variables they should have, what the size of methods should be, and so on.
    The PHP ecosystem managed to pack these into official PSR standard, more precisely
    **PSR-1: Basic Coding Standard** and **PSR-2: Coding Style Guide**. These are
    all general programming guidelines that keep our code readable, understandable,
    and maintainable.'
  prefs: []
  type: TYPE_NORMAL
- en: Aside from programming guidelines, there are more specific design principles
    that we can apply during the class design. Ones that address the notions of low
    coupling, high cohesion, and strong encapsulation. We call them SOLID design principles,
    a term coined by Robert Cecil Martin in the early 2000s.
  prefs: []
  type: TYPE_NORMAL
- en: '**SOLID** is an acronym for the following five principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: Single responsibility principle (**SRP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: Open/closed principle (**OCP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: Liskov substitution principle (**LSP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: Interface Segregation Principle (**ISP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: Dependency inversion principle (**DIP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over a decade old, the idea of SOLID principles is far from obsolete, as they
    are at the heart of good class design. Throughout this chapter, we will look into
    each of these principles, getting to understand them by observing some of the
    obvious violations that break them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface Segregation Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *single responsibility principle* deals with classes that try to do too
    much. The responsibility in this context refers to reason to change. As per the
    Robert C. Martin definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A class should have only one reason to change."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following is an example of a class that violates the SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Ticket` class deals with validation and saving of the `ticket` entity to
    the database. These two responsibilities are its two reasons to change. Whenever
    the requirements change regarding the ticket validation, or regarding the saving
    of the ticket, the `Ticket` class will have to be modified. To address the SRP
    violation here, we can use the assisting classes and interfaces to split the responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of refactored implementation, which complies with
    SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we introduced a simple `KeyValuePersistentMembers` interface with a single
    `toArray` method, which is then used with both `EntityManager` and `Validator`
    classes, both of which take on a single responsibility now. The `Ticket` class
    became a simple data holding model, whereas client now controls *instantiation*,
    *validation*, and *save* as three different steps. While this is certainly no
    universal formula of how to separate responsibilities, it does provide a simple
    and clear example of how to approach it.
  prefs: []
  type: TYPE_NORMAL
- en: Designing with the single responsibilities principle in mind yields smaller
    classes with greater readability and easier to test code.
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **open/closed principle** states that a class should be open for extension
    but closed for modification, as per the definition found on Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"software entities (classes, modules, functions, etc.) should be open for
    extension, but closed for modification"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The open for extension part means that we should design our classes so that
    new functionality can be added if needed. The closed for modification part means
    that this new functionality should fit in without modifying the original class.
    The class should only be modified in case of a bug fix, not for adding new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a class that violates the open/closed principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we have two concrete classes, `CsvExporter` and `XmlExporter`, each with
    a single responsibility. Then we have a `GenericExporter` with its `exportToFormat`
    method that actually triggers the `export` function on a proper instance type.
    The problem here is that we cannot add a new type of exporter to the mix without
    modifying the `GenericExporter` class. To put it in other words, `GenericExporter`
    is not open for extension and closed for modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of refactored implementation, which complies with
    OCP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here we added two interfaces, `ExporterFactoryInterface` and `ExporterInterface`.
    We then modified the `CsvExporter` and `XmlExporter` to implement that interface.
    The `ExporterFactory` was added, implementing the `ExporterFactoryInterface`.
    Its main role is defined by the `buildForFormat` method, which returns the exporter
    as a callback function. Finally, the `GenericExporter` was rewritten to accept
    the `ExporterFactoryInterface` via its constructor, and its `exportToFormat` method
    now builds the exporter by use of an exporter factory and calls the `execute`
    method on it.
  prefs: []
  type: TYPE_NORMAL
- en: The client itself has taken a more robust role now, by first instantiating the
    `ExporterFactory` and adding two exporters to it, which it then passed onto `GenericExporter`.
    Adding a new export format to `GenericExporter` now, no longer requires modifying
    it, therefore making it open for extension and closed for modification. Again,
    this is by no means a universal formula, rather a concept of possible approach
    towards satisfying the OCP.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Liskov substitution principle** talks about inheritance. It specifies
    how we should design our classes so that client dependencies can be replaced by
    subclasses without the client seeing the difference, as per the definition found
    on Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"objects in a program should be replaceable with instances of their subtypes
    without altering the correctness of that program"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While there might be some specific functionality added to the subclass, it has
    to conform to the same behavior as its base class. Otherwise the Liskov principle
    is violated.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to PHP and sub-classing, we have to look beyond simple concrete
    classes and differentiate: concrete class, abstract class, and interface. Each
    of the three can be put in the context of a base class, while everything extending
    or implementing it can be looked at as a derived class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of LSP violation, where the derived class does
    not have an implementation for all methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here we see an `employee` class which does not implement the `getName` method
    enforced by the interface. We could have easily used an abstract class instead
    of the interface and abstract method type for the `getName` method, the effect
    would have been the same. Luckily, the PHP would throw an error in this case,
    warning us that we haven't really implemented the interface fully.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of Liskov principle violation, where different
    derived classes return things of different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we see a simple example of an edge case. Calling `getUsers` on both derived
    classes will return a result we can loop through. However, PHP developers tend
    to use the `count` method often on array structures, and using it on `Employees`
    instances the `getUsers` result will not work. This is because the `Employees`
    class returns `UsersCollection` which implements `Iterator`, not the actual array
    structure. Since `UsersCollection` does not implement `Countable`, we cannot use
    `count` on it, which leads to potential bugs down the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further spot LSP violations in cases where the derived class behaves
    less permissively with regard to method arguments. These can usually be spotted
    by use of the instance of `type` operator, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the derived class `Processor` puts restrictions on method arguments, while
    it should accept everything conforming to the `LoggerInterface`. By being less
    permissive, it alters the behavior implied by the base class, in this case `LoggerInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: The outlined examples are merely a fragment of what constitutes a violation
    of LSP. To satisfy the principle, we need to make sure that derived classes do
    not, in any way, alter the behavior imposed by the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Segregation Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Interface Segregation Principle** states that clients should only implement
    interfaces they actually use. They should not be forced to implement interfaces
    they do not use. As per the definition found on Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"many client-specific interfaces are better than one general-purpose interface"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What this means is that we should split large and fat interfaces into several
    small and lighter ones, segregating it so that smaller interfaces are based on
    groups of methods, each serving one specific functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following leaky abstraction that violates the ISP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we have an interface setting requirements for several appliance related
    methods. Then we have several classes implementing that interface. The problem
    is quite obvious; not all appliances can be squeezed into the same interface.
    It makes no sense for a washing machine to be forced to implement bake and mix
    methods. These methods need to be split each into its own interface. That way
    concrete appliance classes get to implement only the methods that actually make
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **dependency inversion principle** states that entities should depend on
    abstractions and not on concretions. That is, a high level module should not depend
    on a low level module, rather the abstraction. As per the definition found on
    Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"One should depend upon abstractions. Do not depend upon concretions."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This principle is important as it plays a major role in decoupling our software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a class that violates the DIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see a `notify` method within the `NotifySubscriber` class coding
    in a dependency towards the `Mailer` class. This makes for tightly coupled code,
    which is what we are trying to avoid. To rectify the problem, we can pass the
    dependency through the class constructor, or possibly via some other method. Furthermore,
    we should move away from concrete class dependency towards an abstracted one,
    as shown in the rectified example shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here we see a dependency being injected through the constructor. The injection
    is abstracted by a type hinting interface, and the actual concrete class. This
    makes our code loosely coupled. The DIP can be used anytime a class needs to call
    a method of another class, or shall we say send a message to it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to modular development, extensibility is something to constantly
    think about. Writing a code that locks itself in will likely result in a future
    failure to integrate it with other projects or libraries. While SOLID design principles
    might look like an overreach for some of the parts, actively applying these principles
    is likely to result in components that are easy to maintain and extend over time.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing the SOLID principles for class design prepares our code for future
    changes. It does so by localizing and minimizing these changes within our classes,
    so any integration using it does not feel the significant impact of the change.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, in the next chapter, we will look into defining our application
    specification which we will build across all other chapters.
  prefs: []
  type: TYPE_NORMAL
