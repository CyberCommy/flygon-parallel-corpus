- en: Introduction to Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will provide an introduction to Python, focusing primarily on data
    types, variables, expressions, and program structures that the Python programming
    language follows. The objective of this chapter is to familiarize the reader with
    the basics of Python so that they can use it in the upcoming chapters. The chapter
    will cover the installation of Python and its dependency manager. We will also
    start taking a look at scripting in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Python (including its installation and setup)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence data types – lists, dictionaries, tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables and keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations and expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make sure you have the following setup ready before proceeding with this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A working computer or laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ubuntu operating system, preferably version 16.04
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Python?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we think about exploring a new programming language or technology, we often
    wonder about the scope of the new technology and how it might benefit us. Let's
    start this chapter by thinking about why we might want to use Python and what
    advantages it might give us.
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer this question, we are going to think about current technology trends
    and not get into more language-specific features, such as the fact that it is
    object-oriented, functional, portable, and interpreted. We have heard these terms
    before. Let''s try to think about why we might use Python from a strictly industrial
    standpoint, what the present and future landscapes of this language might look
    like, and how the language can serve us. We''ll start by mentioning a few career
    options that someone involved in computer science might opt for:'
  prefs: []
  type: TYPE_NORMAL
- en: Programmer or software developer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web developer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database engineer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cyber security professional (penetration tester, incident responder, SOC analyst,
    malware analyst, security researcher, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data scientist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network engineer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other roles as well, but we'll just focus on the most generic
    options for the time being to see how Python fits into them. Let's start off with
    the role of programmer or software developer. As of 2018, Python was recorded
    as the second most popular language listed in job adverts ([https://www.codingdojo.com/blog/7-most-in-demand-programming-languages-of-2018/](https://www.codingdojo.com/blog/7-most-in-demand-programming-languages-of-2018/)).
    The role of programmer might vary from company to company, but as a Python programmer,
    you might be making a software product written in Python, developing a cyber security
    tool written in Python (there are tons of these already in existence that can
    be found on GitHub and elsewhere in the cyber security community), prototyping
    a robot that can mimic humans, engineering a smart home automation product or
    utility, and so on. The scope of Python covers every dimension of software development,
    from typical software applications to robust hardware products. The reason for
    this is the ease of the language to understand, the power of the language in terms
    of its excellent library support, which is backed by a huge community, and, of
    course, the beauty of it being open source.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the web. In recent years, Python has done remarkably well in
    terms of its maturity as a web development language. The most popular full stack
    web-based frameworks such as Django, Flask, and CherryPy have made web development
    with Python a seamless and clean experience, with lots of learning, customization,
    and flexibility on the way. My personal favorite is Django, as it provides a very
    clean MVC architecture, where business, logic, and presentation layers are completely
    isolated, making the development code much cleaner and easier to manage. With
    all batteries loaded and support for ORM and out-the-box support for background
    task processing with celery, Django does everything that any other web framework
    would be capable of doing, while keeping the native code in Python. Flask and
    CherryPy are also excellent choices for web development and come with lots of
    control over the data flow and customization.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cyber security** is a field that would be incomplete without Python. Every
    industry within the cyber security domain is related to Python in one way or another
    and the majority of cyber security tools are written in Python. From penetration
    testing to monitoring security operations centers, Python is widely used and needed.
    Python aids penetration testers by providing them with excellent tools and automation
    support with which they can write quick and powerful scripts for a variety of
    penetration testing activities, from reconnaissance to exploitation. We will learn
    about this in great detail throughout the course of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Machine learning** (**ML**) and **artificial intelligence** (**AI**) are
    buzz words in the tech industry that we come across frequently nowadays. Python
    has excellent support for all ML and AI models. Python, by default in most cases,
    is the first choice for anyone who wants to learn ML and AI. The other famous
    language in this domain is R, but because of Python''s excellent coverage across
    all the other technology and software development stacks, it is easier to combine
    machine learning solutions written in Python with existing or new products than
    it is to combine solutions written in R. Python has got amazing machine learning
    libraries and APIs such as sciket-learn, NumPy, Pandas, matplotlib, NLTK, and
    TensorFlow. Pandas and NumPy have made scientific computations a very easy task,
    giving users the flexibility to process huge datasets in memory with an excellent
    layer of abstraction, which allows developers and programmers to forget about
    the background details and get the job done neatly and efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: A few years ago, a typical database engineer would have been expected to know
    relational databases such as **MySQL**, **SQL Server**, **Oracle**, **PostgreSQL**,
    and so on. Over the past few years, however, the technology landscape has completely
    changed. While a typical database engineer is still supposed to know and be proficient
    with this database technology stack, this is no longer enough. With the increasing
    volume of data, as we enter the era of big data, traditional databases have to
    work in conjunction with big data solutions such as Hadoop or Spark. Having said
    that, the role of the database engineer has evolved to be one that includes the
    skill set of a data analyst. Now, data is not to be fetched and processed from
    local database servers—it is to be collected from heterogeneous sources, pre-processed,
    processed across a distributed cluster or parallel cores, and then stored back
    across the distributed cluster of nodes. What we are talking about here is big
    data analytics and distributed computing. We mentioned the word Hadoop previously.
    If you are not familiar with it, Hadoop is an engine that is capable of processing
    huge files by spawning chunks of files across a cluster of computers and then
    performing an aggregation on the processed result set, something which is popularly
    known as a map-reduce operation. Apache Spark is a new buzzword in the domain
    of analytics and it claims to be 100 times faster than the Hadoop ecosystem. Apache
    Spark has got a Python API for Python developers called `pyspark`, using which
    we can run Apache Spark with native Python code. It is extremely powerful and
    having familiarity with Python makes the setup easy and seamless.
  prefs: []
  type: TYPE_NORMAL
- en: The objective of mentioning the preceding points was to highlight the significance
    of Python in the current technological landscape and in the coming future. ML
    and AI are likely to be the dominating industries, both of which are primarily
    powered by Python. For this reason, there will not be a better time to start reading
    about and exploring Python and cyber security with machine learning than now.
    Let's start our journey into Python by looking at a few basics.
  prefs: []
  type: TYPE_NORMAL
- en: About Python – compiled or interpreted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compilers work by converting human-readable code written in high-level programming
    languages into machine code, which is then run by the underlying architecture
    or machine. If you don't wish to run the code, the compiled version can be saved
    and executed later on. It should be noted that the compiler first checks for syntax
    errors and only creates the compiled version of the program if none are found.
    If you have used C, you might have come across `.out` files, which are examples
    of compiled files.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of interpreters, however, each line of the program is taken and
    interpreted from the source code at runtime and then converted into machine code
    for execution. Python falls into the category of interpreted byte code. This means
    that the Python code is first translated to an intermediate byte code (a `.pyc`
    file). Then, this byte code is interpreted line by line by the interpreter and
    executed on the underlying architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the course of this book, all of the exercises will be shown on a Linux
    OS. In my case, I am using Ubuntu 16.04\. You can choose any variant you prefer.
    We will be using `python3` for our exercises, which can be installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The second command installs **pip**, which is Python's package manager. All
    open source Python libraries that do not come as part of the standard installation
    can be installed with the help of `pip`. We will be exploring how to use pip in
    the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the course of this book, we will aim to cover advanced and well-known
    industry standards in Python, cyber security, penetration testing, and the data
    science space. However, as they say, every remarkable journey starts with small
    steps. Let's go ahead and start our journey by understanding the basics of Python.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Variables**, as the name suggests, are placeholders that hold a value. A
    Python variable is nothing but a name that can hold a user-defined value during
    the scope of a Python program or script. If we compare Python variables to other
    conventional languages, such as C, C++, Java, and so on, we will see that they
    are a little bit different. In the other languages, we have to associate a data
    type with the name of the variable. For example, to declare an integer in C or
    Java, we have to declare it as `int a=2`, and the compiler will immediately reserve
    two bytes of memory in C and four bytes in Java. It would then name the memory
    location as `a`, which is to be referenced from the program with the value `2`
    stored in it. Python, however, is a dynamically typed language, which means that
    we do not need to associate a data type with the variable that we will declare
    or use in our program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical Python declaration of an integer might look like `a=20`. This simply
    creates a variable named `a` and places the value `20` in it. Even if we change
    the value in the next line to be `a="hello world"`, it would associate the string
    `hello world` with the variable `a`. Let''s see that in action on the Python Terminal,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c64e1eab-6ced-40a7-afd9-f52a540dabe8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To use the Python Terminal, simply type the `python3` command in your Terminal
    prompt. Let''s think about how this works. Take a look at the following diagram,
    which compares statically typed languages with dynamically typed languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d42b878-542f-4972-a1d6-a5650b1921bc.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/36132ef2-42f9-4f37-8d0c-18089f559fd2.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagrams, in the case of Python, the variable
    actually holds a reference to the actual object. Every time the value is changed,
    a new object is created in memory and the variable points toward this new object.
    The previous object is claimed by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: Having discussed that Python is a dynamically typed language, we must not confuse
    it with a weakly typed one. Though Python is dynamically typed, it is also a strongly
    typed language, just like Java, C, or C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we declare a variable, `a`, of string type and a
    variable, `b`, of integer type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/991cd824-ffd9-4193-8d3e-31654ea761e5.png)'
  prefs: []
  type: TYPE_IMG
- en: When we carry out the operation `c=a+b`, what might happen in a weakly typed
    language is that the integer value of `b` would be typecasted to a string, and
    the result that was stored in variable `c` would have been `hello world22`. However,
    because Python is strongly typed, the function adheres to the type that is associated
    with the variable. We need to make the conversion explicitly to carry out any
    operations of this kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example to understand what it means to
    be a strongly typed language; we explicitly change the type of variable `b` and
    typecast it to a string type at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b8991ee-cd92-44ad-abfe-d0534491ef7e.png)'
  prefs: []
  type: TYPE_IMG
- en: Variable naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having understood the basics of how variables can be declared and used, let's
    try to understand the naming conventions they follow. A variable, also known as
    an identifier, can be named by anything that starts with any letter between A-Z,
    a-z, or an underscore. This can then be followed by any number of digits or alphanumeric
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'It must be noted that certain special characters, such as %, @, #, -, and !, are
    reserved in Python and can''t be used with variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Python keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Keywords**, as the name implies, are certain reserved words that have a predefined
    meaning within a particular language implementation. In other languages, we cannot
    usually name our variables with the same name as that of the keywords, but Python
    is a slightly different case. Although we shouldn''t name the variables or identifiers
    with the same name as those reserved for keywords, even if we do, the program
    will not throw any errors and we will still get an output. Let''s try to understand
    this with the help of a conventional C program and an equivalent Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3862155-a723-4571-abb9-4c60f2a57f5c.png)'
  prefs: []
  type: TYPE_IMG
- en: It should be noted that this is a simple C program in which we have declared
    an integer and used the `int` identifier to identify it, following which we simply
    print `hello world`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we try to compile the program, however, it throws a compilation error,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/334cc30b-eb1a-4cb2-a891-6614441abc6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to do the same in a Python shell and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/975e7b89-e7e4-4874-89ea-4c1768baf01c.png)'
  prefs: []
  type: TYPE_IMG
- en: It can be seen that the program did not throw any errors when we declared our
    variable with the names `int` and `str`. Although both `int` and `str` are Python
    keywords, in the preceding case, we saw that a variable declared with name as
    `int` held a string value and a variable declared with `str` type held an `int`
    value. We also saw how a normal variable, `a`, was typecasted from `int` to `string`
    type. From this, it can be established that we can use reserved words as variables
    in Python. The downside of this is that if we are to make use of keywords as variables
    or identifiers, we are overriding the actual functionality that these reserved
    words possess. When we override their actual behavior within the scope of our
    program, they will follow the updated or overridden functionality, which is very
    dangerous as this would make our code fall out of Python's conventions. This should
    always be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the preceding example. We know that `str()` is a built-in Python
    function, the purpose of which is to convert a numeric data type into a string
    type, as we saw for variable `a`. Later on, however, we overwrote its functionality
    and, for the scope of our program, we assigned it to an integer type. Now, at
    any point in time during the scope of this program, if we try to use the `str`
    function to convert a numeric type into a `string`, the interpreter will throw
    an error, saying that the `int` type variables can''t be used as methods, or that
    they are not callable, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88a7a2cd-885c-4dc5-ae8e-0865c9ca544b.png)'
  prefs: []
  type: TYPE_IMG
- en: The same would hold true for the `int` method and we would no longer be able
    to use it to type cast a string to its equivalent integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at other types of keywords that are available in Python
    that we should try not to use as our variable names. There is a cool way to do
    this with the Python code itself, which lets us print the Python keywords in the
    Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e6f151e-b64d-4871-a95a-ab0b78b4869c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `import` statement is used to import the libraries in Python, just as we
    use imports for importing packages in Java. We will get into the details of using
    imports and loops in future sections. For now, we will look at what the different
    Python keywords mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '`false`: The Boolean `false` operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`none`: This is equivalent to `Null` in other languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`true`: The Boolean `true` operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`and`: The logical `and` that can be used with conditions and loops.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as`: This is used to assign an alias to a module that we import.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert`: This is used with the objective of debugging code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`break`: This exits the loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class`: This is used to declare a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`continue`: This is the traditional `continue` statement used with loops that
    can be used to continue the execution of a loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def`: This is used to define a function. Every Python function needs to be
    preceded by the `def` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`del`: This is used to delete objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elif`: The conditional `else...if` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`else`: The conditional `else` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`except`: This is used to catch exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finally`: This is used with exception handling as part of the final block
    of code in which we clean our resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for`: The traditional for loop declaration keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`global`: This is used to declare and use global variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if`: The conditional `if` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import`: This is used to import Python libraries, packages, and modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in`: This is used to search between Python strings, lists, and other objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is`: This is used to test the identity of an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lambda`: This is used with Lambda functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nonlocal`: This is used to declare a variable inside a nested function that
    is not local to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`not`: This is a conditional operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`or`: This is another conditional operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pass`: This is used as a placeholder in Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`raise`: This is used to raise an exception in Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return`: This is used to return from a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`try`: The traditional `try` keyword that''s used with exception handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while`: This is used with the `while` loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`with`: This is used with file opening and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yield`: This is used with generators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from`: This is used with relative imports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this book, we will learn about all the keywords mentioned in this
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Python data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other programming language, Python also comes with standard data types.
    In this section, we will explore the various powerful data types that Python makes
    available for us to use.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Numbers**, as the name suggests, covers all the numeric data types, including
    both integer and floating data types. Earlier in this chapter, we saw that to
    use an integer or a float, we can simply declare the variable and assign an integer
    or a float value. Now, let''s write a proper Python script and explore how to
    use numbers. Name the script `numbers.py` which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8126ea5f-c958-432d-a21e-e104ab71827f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot show a simple Python script that adds an integer with
    a float and then prints the sum. To run the script, we can type the `python3 numbers.py`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/050cfa73-4361-4b66-9354-5975f58a6faa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You might have noticed that the command at the beginning of the script says
    `#! /usr/bin/python`. What this line does is make your code executable. After
    the privileges of the script have changed and it has been made executable, the
    command says that if an attempt is made to execute this script, then we should
    go ahead and execute it with `python3`, which is placed in the `/usr/bin/python3`
    path. This can be seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56bba27d-5bf8-4bab-a6e5-cefbbbc32293.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we observe the `print` command, we can see that the string formatter is
    `%s`. To fill it in with the actual value, the second argument to the `print`
    function is passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c97aee4e-553c-4f0a-a5ca-adfad91fdb6d.png)'
  prefs: []
  type: TYPE_IMG
- en: To convert a string into its equivalent integer or float value, we can use the
    built-in `int()` and `float()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: String types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that a string is a collection of characters. In Python, string types
    come under the sequence category. Strings are really powerful and have many methods
    that can be used to perform string manipulation operations. Let''s look at the
    following piece of code, which introduces us to strings in Python. Strings can
    be declared within both single and double quotes in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22c427ea-efbe-4418-9cff-bc1b0a78118e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, we are simply declaring a string called `my_str` and
    printing it on the console window.
  prefs: []
  type: TYPE_NORMAL
- en: String indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It must be noted that strings can be accessed as a sequence of characters in
    Python. Strings can be thought of as a list of characters. Let''s try to print
    the characters at various indices of the string, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5ec70ee-4290-461e-b965-01c74a3164cc.png)'
  prefs: []
  type: TYPE_IMG
- en: At index `0`, the character `0` gets printed. At index `10`, we have an empty
    space, while at index `5`, we have the letter `m`. It should be noted that the
    sequences are stored in Python with a starting index of `0`, and the same holds
    true for the string type.
  prefs: []
  type: TYPE_NORMAL
- en: String operations through methods and built-in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how to compare two strings, concatenate strings,
    copy one string to another, and perform various string manipulation operations
    with the help of some methods.
  prefs: []
  type: TYPE_NORMAL
- en: The replace( ) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `replace` method is used to perform string replacement. It returns a new
    string with the appropriate replacements. The first argument to the replace method
    is the string or character to be replaced within the string, while the second
    argument is the string or character with which it is to be replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fc71b45-8d4d-4b3f-a0a5-3457356c2a6c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, we can see that the `!` from the original string
    is replaced by `@` and a new string with the replacement is returned. It should
    be noted that these changes were not actually made to the original string, but
    instead a new string was returned with the appropriate changes. This can be verified
    in the following line, where we print the original string and the old unchanged
    value, `Welcome to python strings !`, is printed. The reason behind this is that
    strings in Python are immutable, just like they are in Java. This means that once
    a string is declared, it can''t usually be modified. This isn''t always the case,
    however. Let''s try to change the string and this time try and catch the modifications
    in the originally declared string, `my_str`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/149b832c-b606-4089-8a7d-eec5ae01da93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code, we were able to modify the original string, as we got
    the newly returned string from the `replace` method in our earlier declared string,
    `my_str`. This might sound contradictory to what we said previously. Let''s take
    a look at how this works by looking at what happens behind the scenes before and
    after we call the `replace` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3244b6c-200a-4d48-951b-4fda8b1b2d53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After replacing the `!` with `@`, this will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35b0c002-e5b1-4fd5-9ed7-bfc0ae446d32.png)'
  prefs: []
  type: TYPE_IMG
- en: It can be seen in the preceding two illustrations that before the `replace`
    method was called, the `my_str` string reference pointed toward the actual object
    that contained an `!`. Once the `replace()` method returned a new string and we
    updated the existing string variable with the newly returned object, the older
    memory object was not overwritten, but instead a new one was created. The program
    reference now points toward the newly created object. The earlier object is in
    memory and doesn't have any references pointing toward it. This will be cleaned
    up by the garbage collector at a later stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing we can do is try and change any character in any position of
    the original string. We have already seen that the string characters can be accessed
    by their index, but if we try to update or change a character at any specific
    index, an exception will be thrown and the operation will not be permitted, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13e222d0-bd51-47f4-92e8-e8c83e701e31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, the `replace()` method replaces all the occurrences of the replacement
    string within the target string. If we only want to replace one or two occurrences
    of something within the target string, however, we can pass a third argument to
    the `replace()` method and specify the number of replacement occurrences that
    we want to have. Let''s say we have the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f75a0ce4-c66a-4cce-b046-9fdf34154f94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we just want the first occurrence of the `!` character to be `@` and we
    want the rest to be the same, this can be achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3588b54-8a51-4fd7-aef9-019c3524b426.png)'
  prefs: []
  type: TYPE_IMG
- en: Substrings or string slicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Obtaining part of the string is a common exercise that we come across frequently
    in day-to-day string operations. Languages such as C or Java provide us with dedicated
    methods such as `substr(st_index,end_index)` or `subString(st_index,end_index)`.
    To perform the substring operation in Python, there is no dedicated method, but
    we can instead use slicing. For example, if we wish to get the first four characters
    of our original `my_str` string, we can achieve this by using operations such
    as `my_str[0:4]`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6aeed0e-02f3-469e-b7ce-9294498e9ca3.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, the slice operation returns a new string and the changes are not applied
    to the original string. Furthermore, it is worth understanding here that the slicing
    happens over n-1 characters, where `n` is the upper limit, specified as the second
    parameter, which is four, in our case. Thus, the actual substring operation will
    be performed starting from index `0` and ending at index `3`, thus returning the
    string `Welc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some more examples of slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the whole string from index `4`, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/265fb596-8570-4a43-a5bd-ac71c3cede1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To get the string from the start up to index `4`, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e980939e-4bac-4535-80d2-61117ec28703.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To print the whole string with slicing, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8663fe94-e20c-4356-bed8-c2368b4f43f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To print the characters with a step of `2`, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6f045c64-fcec-4fac-a464-6b0d2851675d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To print the reverse of the string, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8320ea2f-87aa-493d-90df-6ca0ac460748.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To print a part of the string in reverse order, to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a9f35a75-da29-4ce9-88b6-d2abb5ab707f.png)'
  prefs: []
  type: TYPE_IMG
- en: String concatenation and replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`+` is the concatenation operator that''s used in Python to concatenate two
    strings. As always, the result of the concatenation is a new string and unless
    we get the updated string, the update will not be reflected with the original
    string object. The `+` operator is internally overloaded to perform concatenation
    of objects when it is used on string types. It is also used for the addition of
    two numbers when used on numeric data types, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bbe9d09-0f6f-4be5-8b84-293154494d00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Interestingly, Python also supports another operator that gets overloaded when
    used with string data types. Instead of performing a conventional operation, this
    operator performs a variation of the original operation so that the functionality
    can be replicated across string data types. Here, we are talking about the multiplication
    operator, `*`. This is conventionally supposed to perform the multiplication of
    numeric data types, but when it is used on string data types, it performs a replication
    operation instead. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dc12321-1ec0-449b-b40e-d18c32ed580e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding case, the multiplication operator actually replicates the `Hello
    world` string stored in the `c` variable five times, as we specified in the expression.
    This is a very handy operation and can be used to generate fuzzing payloads, which
    we will see in the later chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The strip(), lstrip(), and rstrip() methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `strip` method is actually used to strip off the white spaces from the
    input string. By default, the `strip` method will strip off the spaces from both
    the left and right sides of the string and will return a new string without spaces
    on both the leading and trailing sides, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/521462f8-9528-4dd3-8432-3c961ce9e0b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if we only wish to strip off the left spaces ,we can use the `lstrip()`
    method. Similarly, if we just wish to strip off the right spaces, we can use the
    `rstrip()` method. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48b30334-a5c3-422f-a28e-dddd1dc5e34a.png)'
  prefs: []
  type: TYPE_IMG
- en: The split() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `split` method, as the name suggests, is used to split the input string
    over a particular delimiter and return a list that contains the words that have
    been split. We will be looking at lists in more detail shortly. For now, let''s
    take a look at the following example, where we have the name, the age, and the
    salary of an employee in a string separated by commas. If we wish to obtain this
    information separately, we can perform a split over `,`. The `split` function
    takes the first argument as the delimiter on which the `split` operation is to
    be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54ee7d41-e315-4acf-9ef5-30f8a364999c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, the `split` operation is performed over a space, that is, if a
    delimiter is not specified. This can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b721965-73f1-443e-ad86-80eb51ad3af0.png)'
  prefs: []
  type: TYPE_IMG
- en: The find(), index(), upper(), lower(), len(), and count() methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `find()` function is used to search for a character or string within our
    target string. This function returns the first index of the string if a match
    is found. It returns `-1` if it does not find the match:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac610f73-f88d-4f46-bd14-e0e7ca7c9db6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `index()` method is identical to the `find()` method. It returns the first
    index of the string if it finds the match and raises an exception if it does not
    find a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bacda854-0567-4485-b282-0fdab63f915a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `upper()` method is used to transform the input string to upper case letters
    and the `lower()` method is used to transform a given string to lowercase letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d9cd7e7-9c5c-46da-8404-ced350f2a170.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `len()` method returns the length of the given string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76a2b0cf-b6c7-4672-ae1a-eb1414843544.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `count()` method returns the number of occurrences of any character or
    string that we wish to count within the target string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d5e9730-57b1-4b13-b8dd-4ab28b9a0255.png)'
  prefs: []
  type: TYPE_IMG
- en: The in and not in methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `in` and `not in` methods are very handy, as they let us perform a quick
    search on the sequences. If we wish to check if a certain character or word is
    present or not present in the target string, we can use the `in` and `not in` methods.
    These will return `True` if the word is present and `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13b72441-6e6c-4f4e-8558-7a125dfe3a87.png)'
  prefs: []
  type: TYPE_IMG
- en: The endswith(), isdigit(), isalpha(), islower(), isupper(), and capitalize()
    methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `endswith()` method checks whether the given string ends with a specific
    character or word that we pass as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c680da9-5f9b-4341-8687-c510267c9191.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `isdigit()` method checks whether the given string is of a digit type or
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1b64dd8-ef60-4a1a-bdc3-3b060d1a3fc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `isalpha()` method checks whether the given string is of an alphabetic
    character type or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/588ee101-e6b4-4c46-8893-7fb5184b26e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `islower()` method checks whether the string is lowercase, while the `isupper()`
    method checks if the string is uppercase. The `capitalize()` method puts a given
    string into sentence case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b918755-df2c-4319-ba79-94af07d7cd07.png)'
  prefs: []
  type: TYPE_IMG
- en: List types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python does not have array types, but instead offers the list data type. Python
    lists also fall under the category of sequences and offer a wide range of functionalities.
    Coming from a Java, C, or C++ background, you are likely to find that Python lists
    are slightly different from the arrays and list types offered by these languages.
    In C, C++, or Java, an array is a collection of elements of similar data types,
    and this is also the case for Java array lists. This is different in the case
    of Python. In Python, a list is a collection of elements that can be of either
    homogeneous and heterogeneous data types. This is one of the features that makes
    Python lists powerful, robust, and easy to use. We also don''t need to specify
    the size of a Python list when declaring it. It can grow dynamically to match
    the number of elements it contains. Let''s see a basic example of using lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80849a5f-d291-4d12-baf5-f3968064f41f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lists in Python start from index `0` and any item can be accessed on the basis
    of indices, as shown in the preceding screenshot. The preceding list is homogeneous,
    as all the elements are of string type. We can also have a heterogeneous list,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98d236da-817a-4518-803a-e59395b2c770.png)'
  prefs: []
  type: TYPE_IMG
- en: For now, we are printing the list elements manually. We can very easily iterate
    over them with loops instead, and we will explore that later on. For now, let's
    try to understand which operations can be performed on list structures in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing the lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Slicing** is an operation that allows us to extract elements from sequences
    and lists. We can slice lists to extract portions that we might be interested
    in. It must be noted again that the indexes of slicing are 0-based and that the
    last index is always considered to be `n-1`, where n is the specified last index
    value. To slice the first five and last five elements from the list, we can perform
    the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f71326a4-1b4c-4fe4-a8a6-2ffabe019d33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see some examples of list slicing and their results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the list from index `4` onwards, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/46a125ca-dab4-473c-8796-8b0fe756da1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To get the list elements from the start up to index `4`, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3c3ea6df-f4f2-4278-b6ea-6b775b7969bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To print the whole list with slicing, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d7bf51a3-9ed3-4f24-a1a0-8890dfba879d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To print the list elements with a step size of `2`, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8fd8c671-7792-46f7-93e6-b3a979605b0f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To print the reverse of the list, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/69c36743-6554-4c54-91b7-395d2a5d1e10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To print a portion of the list in reverse order, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b490c167-0ab4-4ed5-bb00-1751307d7b46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add new elements to `list-append()`: The `append()` method is used to add elements
    to the list, and the elements to be added are given as an argument to the `append()`
    method. These elements to be added can be of any type. As well as being a number
    or a string, the element can be a list in itself:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6cf0eaa7-81d0-43f2-b4e6-bd9c147ac5f0.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see in the preceding example that we added three elements, `6`, `7`,
    and `8`, to our original list using the `append()` method. Then, we actually added
    another list containing three characters that would be stored intact as a list
    inside the original list. These can be accessed by specifying the `my_list[8]`
    index. In the preceding example, the new list is added intact to the original
    list, but is not merged.
  prefs: []
  type: TYPE_NORMAL
- en: Merging and updating lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'List merging can be done in two ways in Python. First, we can use the traditional
    `+` operator, which we used previously to concatenate two strings. It does the
    same when used on list object types. The other way to achieve this would be by
    using the `extend` method, which takes the new list as an argument to be merged
    with the existing list. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bc7138d-5445-493a-b429-ad348042890f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To update an element in the list, we can access its index and add the updated
    value for any element that we wish to update. For example, if we want to have
    the string `Hello` as the 0^(th) element of the list, this can be achieved by
    assigning the 0^(th) element to the `Hello` value as `merged[0]="hello"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81dc9bf3-7d05-4dc5-a2fe-7669da40f460.png)'
  prefs: []
  type: TYPE_IMG
- en: Copying lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen that Python variables are nothing but references to actual objects.
    The same holds true for lists. For this reason, manipulating lists gets a little
    tricky. By default, if we copy one list variable to another one by simply using
    the `=` operator, it won''t actually create a duplicate or local copy of the list
    for that variable – instead, it would just create another reference and point
    the newly created reference toward the same memory location. Thus, when we make
    a change to the copied variable, the same change will be reflected in the original
    list. In the following example, we will create new isolated copies, where a change
    in the copied variable will not be reflected in the original list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0c195ed-49bc-4dec-9772-0f94c573644a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s look at how can we create a new copy of an existing list so that
    the changes to the new one do not cause any changes to the existing one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd4396e7-54fa-4227-b771-f9708b988c64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way to create the isolated copy of the original list is to make use
    of the `copy` and `deepcopy` functions that are available in Python. A shallow
    copy constructs a new object and then inserts *references* to that object to the
    objects found in the original list. A *deep copy*, on the other hand, constructs
    a new compound object and then recursively inserts *copies* of the objects found
    in the original list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfa57b95-bd7f-4fdd-8f97-37431ba47755.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing elements from lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `del` command to delete either an element from the list or the
    whole list. The `del` command does not return anything. We can also use the `pop`
    method to remove elements from the list. The `pop` method takes the index of the
    element that we wish to remove as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41be39ab-2b4f-4483-acdd-7e1a929a6dae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The entire list structure can be deleted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52929047-d566-4cd2-b9de-96626a871fa0.png)'
  prefs: []
  type: TYPE_IMG
- en: Replication with len(), max(), and min()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The multiplication operator `*`, when applied to lists, causes a replication
    effect of the list elements. The contents of the list are repeated as many times
    as indicated by the number passed to the replication operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa5f4c95-bef4-46f8-b4c7-d54df712d39f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `len()` method gives the length of the Python lists. The `max()` method
    returns the maximum element of the list, while the `min()` method returns the
    minimum element of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb322b31-3b37-4f10-a95c-49e17ea5ce9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the `max` and `min` methods on the character types as well, but
    we cannot use them on a list that has mixed or heterogeneous types. If we do this,
    we will get an exception stating that we are trying to compare numbers and characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edea29fb-7ba5-4650-918a-97c0eaf37001.png)'
  prefs: []
  type: TYPE_IMG
- en: in and not in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `in` and `not in` methods are essential Python operations that can be used
    against any sequence type. We saw how these were used previously with strings,
    where we used them to search for a string or character within the target string.
    The `in` method returns `true` if the search is successful and returns `false`
    if not. The opposite is the case for the `not in` method. The execution is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50142294-3c9d-4e79-b4f8-70ca12912977.png)'
  prefs: []
  type: TYPE_IMG
- en: Tuples in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **Python tuple** is very similar to a Python list. The difference is that
    it''s a read-only structure, so once it is declared, no modification can be made
    to the elements of the tuple. Python tuples can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/deb53b7e-f5fc-4639-9413-03355effa0d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code, we can see that we can access tuples in the same way
    as we can access lists, but when we try to change any element of the tuple, it
    throws us an exception as a tuple is a read-only structure. If we perform the
    operations that we performed on lists, we will see that they work in exactly the
    same way as tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4f04740-11d2-47d7-b642-86bded48a6b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If a tuple has only one element in it, it has to be declared with a trailing
    comma. If we do not add that comma while declaring it, it will be interpreted
    as a numeric or string data type, depending on the elements of the tuple. The
    following example explains this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aadff71a-28ef-4377-803c-3790e9c065a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A tuple can be converted into a list and can then be operated on as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2a752cc-1c18-412a-9de8-483ee1ba9b8e.png)'
  prefs: []
  type: TYPE_IMG
- en: Dictionaries in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dictionaries** are very powerful structures and are widely used in Python.
    A dictionary is a key-value pair structure. A dictionary key can be a unique number
    or string, and the value can be any Python object. Dictionaries are mutable and
    can be changed in place. The following example demonstrates the basics of dictionaries
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/026f5772-da80-4c06-b866-5ffa45f665af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A Python dictionary can be declared within curly braces. Each key value pair
    is separated by a comma. It should be noted that the keys have to be unique; if
    we try to repeat the keys, the old key value pair is overwritten by the new one.
    From the preceding example, we can establish that the dictionary keys can be either
    string or numeric types. Let''s try to perform various operations on dictionaries
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Retrieving the dictionary values with the keys**: Dictionary values can be
    accessed through the name of the dictionary key. If the name of the key is not
    known, we can use loops to iterate through the whole dictionary structure. We
    will cover this in the next chapter of this book:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3800b1fd-c087-4497-9eb2-70d32b55f8b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is one of the many ways to print dictionary values. However, if the key
    for which the value we wish to print does not exist in the dictionary, we will
    get a key not found exception, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9be2648e-13c9-4097-b0ce-04c7dcbf929d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a better way to handle this and avoid these kinds of exceptions. We
    can use the `get()` method provided by the dictionary class. The `get()` method
    takes the key name as the first argument and the default value if the key is not
    present as the second argument. Then, instead of throwing an exception, the default
    value will be returned if the key is not found. This is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5884c24f-f3c4-44dc-9b79-ca9f0e412392.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, when the `k1` key is present in the actual dictionary,
    `dict1`, the value for the `k1` key is returned, which is `v1`. Then, the `k0`
    key was searched, which was not present originally. In that case, no exception
    was raised, but instead the `False` value was returned, suggesting that no such
    key, `K0`, was actually present. Remember that we can specify any placeholder
    as the second argument to the `get()` method to indicate the absence of the key
    we are searching for.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding keys and values to the dictionary**: Once a dictionary has been declared,
    over the course of the code, there could be many occasions in which we want to
    modify a dictionary key or add a new dictionary key and value. This can be achieved
    as follows. As mentioned earlier, a dictionary value can be any Python object,
    so we can have tuples, lists, and dictionary types as values inside a dictionary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/425afb59-cd2f-4d18-966d-8fa9b01a11a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s add more complex types as values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/228b2391-23bd-460f-85e0-6e045e2b03ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These values can be retrieved as normal values by their keys as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a68a6a98-a518-4c70-a02f-c8d7171aa4f4.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expanding a dictionary with the contents of another dictionary**: In the
    preceding example,we added a dictionary as a value to an existing dictionary.
    We will now see how can we merge two dictionaries into one common or new dictionary.
    The `update()` method can be used to do this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7474e4c8-1dc5-4086-a8df-f911e871d9c0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**`Keys()`**: To get all the dictionary keys, we can use the `keys()` method.
    This returns the class instances of the dictionary keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/85740215-8770-4e17-b499-4f91cae8fbb8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the keys method returns an instance of the `dict_keys` class,
    which holds the list of dictionary keys. We can type cast this as a list type
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86da945a-0ecb-44f2-a367-d6e6fe617918.png)'
  prefs: []
  type: TYPE_IMG
- en: '**`values()`**: The `values()` method returns all the values that are present
    in the dictionary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3c4ba243-4241-4d6c-b0c8-9bccbe80de5d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**`Items()`**: This method is actually used to iterate over the dictionary
    key value pairs, as it returns a list class instance that contains a list of tuples.
    Each tuple has two entries, the first one being the key and the second one being
    the value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6c4ee05b-2d21-4c19-b018-492110271041.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can convert the returned class instance into a tuple, list tuple, or list
    type as well. The ideal way to do this is to iterate over the items, which we
    will see later when we look at loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b526057b-5f0d-471b-9256-da3477b45944.png)'
  prefs: []
  type: TYPE_IMG
- en: '**`in`** and **`not in`**: The `in` and `not in` methods are used to see whether
    a key is present in the dictionary or not. By default, the `in` and `not in` clauses
    will search the dictionary keys, not the values. Take a look at the following
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8423b4f3-adbc-448d-a657-4ba3d67e5264.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Order of storing**: By default, Python dictionaries are unordered, which
    means they are not stored internally in the same order as we define them. The
    reason for this is that the dictionaries are stored in dynamic tables called **hash
    tables**. As these tables are dynamic, they can increase and shrink in size. What
    happens internally is that a hash value of the key is computed and stored in the
    table. The key goes in the first column, while the second column holds the actual
    value. Let''s take a look at the following example to explain this better:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5df607af-fdcd-462d-bfe9-23375ad29fd9.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding case, we declare a dictionary, `a`, with the first key as `abc`
    and the second key as `abcd`. When we print the values, however, we can see that
    `abcd` is stored internally before `abc`. To explain this, let's assume that the
    dynamic table or hash table in which the dictionary is internally stored is of
    size `8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, the keys will be stored as hash values. When we compute
    the hash of the `abc` string and and divide it in a modular fashion by `8`, which
    is the table size, we get the result of `7`. If we do the same for `abcd`, we
    get a result of `4`. This means that the hash `abcd` will be stored at index `4`,
    while the hash `abc` will be stored at index `7`. For this reason, in the listing,
    we get `abcd` listed before `abc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5c7a7d8-19a0-47de-85ee-17aa4f778632.png)'
  prefs: []
  type: TYPE_IMG
- en: There may be occasions in which two keys arrive at a common value after the
    `hash(key)%table_size` operation, which is called a **collision**. In this case,
    the key to be slotted first is the one that is stored first.
  prefs: []
  type: TYPE_NORMAL
- en: '**`sorted()`**: If we want our dictionary to be sorted according to the keys,
    we can use the built-in sorted method. This can be tweaked to return a list of
    tuples, with each tuple having a key at the 0^(th) index and its value at the
    1^(st) index:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ccb9d9fc-f6fc-4fe5-98d0-95e24576990c.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Removing elements**: We can use the conventional `del` statement to delete
    any dictionary item. When we say delete, we mean delete both the key and the value.
    Dictionary items work in pairs, so deleting the key would remove the value as
    well. Another way to delete an entry is to use the `pop()` method and pass the
    key as an argument. This is shown in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b723bc4c-f7de-45c6-87d3-8bc7252f83b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Python operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An operator in Python is something that can carry out arithmetic or logical
    operations on an expression. The variable on which the operator operates is called
    the **operand**. Let''s try to understand the various operators that are available
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Functions** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Addition | `a + b` |'
  prefs: []
  type: TYPE_TB
- en: '| Subtraction | `a - b` |'
  prefs: []
  type: TYPE_TB
- en: '| Negation | `-a` |'
  prefs: []
  type: TYPE_TB
- en: '| Multiplication | `a * b` |'
  prefs: []
  type: TYPE_TB
- en: '| Division | `a / b` |'
  prefs: []
  type: TYPE_TB
- en: '| Modulo | `a % b` |'
  prefs: []
  type: TYPE_TB
- en: '| Exponentiation | `a ** b` |'
  prefs: []
  type: TYPE_TB
- en: '| Floor Division | `a // b` |'
  prefs: []
  type: TYPE_TB
- en: '**Assignment**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a = 0` evaluates to `a=0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a +=1` evaluates to `a = a + 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a -= 1` evaluates to `a = a + 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a *= 2` evaluates to `a = a * 2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a /= 5` evaluates to `a = a / 5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a **= 3` evaluates to `a = a ** 3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a //= 2` evaluates to `a= a // 2` (floor division 2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a %= 5` evaluates to `a= a % 5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logical operators**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`and`**: `True`: If both the operands are `true`, then the condition becomes
    `true`. For example, `(a and b)` is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`or`**: `True`: If any of the two operands are non-zero, then the condition
    becomes `true`. For example, `(a or b)` is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`not`**: `True`: This is used to reverse the logical state of its operand.
    For example, `not (a and b)` is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise operators**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Functions** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `and` | `a & b` |'
  prefs: []
  type: TYPE_TB
- en: '| `or` | `a &#124; b` |'
  prefs: []
  type: TYPE_TB
- en: '| `xor` | `a ^ b` |'
  prefs: []
  type: TYPE_TB
- en: '| `invert` | `~ a` |'
  prefs: []
  type: TYPE_TB
- en: '| `Right Shift` | `a >> b` |'
  prefs: []
  type: TYPE_TB
- en: '| `Left Shift` | `a << b` |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the basics of Python and explored the syntax of
    the language. This isn't very different from the languages that you may have studied
    in the past, such as C, C ++, or Java. However, it's much easier to use and is
    really powerful in the cyber security domain compared to its peers. This chapter
    formulates the basics of Python and will help us progress, as some data types
    such as lists, dictionaries, tuples, and strings are used heavily throughout the
    course of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about conditions and loops and see how loops
    can be used with the data types that we have studied so far.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is Python open source? If so, how is it different from other open source languages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who manages Python and works on further feature enhancements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is Python faster than Java?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is Python object-oriented or functional?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can I learn Python quickly if I have little to no experience with any programming
    language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is Python beneficial to me, being a cyber security engineer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I am a penetration tester – why do I need to understand AI and machine learning?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
