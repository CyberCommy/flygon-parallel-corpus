- en: Strings and Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the problem-solving sections for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 23\. Binary to string conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a function that, given a range of 8-bit integers (such as an array or
    vector), returns a string that contains a hexadecimal representation of the input
    data. The function should be able to produce both uppercase and lowercase content.
    Here are some input and output examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: `{ 0xBA, 0xAD, 0xF0, 0x0D }`, output: `"BAADF00D"` or `"baadf00d"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: `{ 1,2,3,4,5,6 }`, output: `"010203040506"`'
  prefs: []
  type: TYPE_NORMAL
- en: 24\. String to binary conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a function that, given a string containing hexadecimal digits as the
    input argument, returns a vector of 8-bit integers that represent the numerical
    deserialization of the string content. The following are examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: `"BAADF00D"` or `"baadF00D"`, output: `{0xBA, 0xAD, 0xF0, 0x0D}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input `"010203040506"`, output: `{1, 2, 3, 4, 5, 6}`'
  prefs: []
  type: TYPE_NORMAL
- en: 25\. Capitalizing an article title
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that transforms an input text into a capitalized version, where
    every word starts with an uppercase letter and has all the other letters in lowercase.
    For instance, the text `"the c++ challenger"` should be transformed to `"The C++
    Challenger"`.
  prefs: []
  type: TYPE_NORMAL
- en: 26\. Joining strings together separated by a delimiter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that, given a list of strings and a delimiter, creates a new
    string by concatenating all the input strings separated with the specified delimiter.
    The delimiter must not appear after the last string, and when no input string
    is provided, the function must return an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: input `{ "this","is","an","example" }` and delimiter `'' ''` (space),
    output: `"this is an example"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 27\. Splitting a string into tokens with a list of possible delimiters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that, given a string and a list of possible delimiter characters,
    splits the string into tokens separated by any of the delimiters and returns them
    in an `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: input: `"this,is.a sample!!"` with delimiters `",.! "`, output: `{"this",
    "is", "a", "sample"}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 28\. Longest palindromic substring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that, given an input string, locates and returns the longest
    sequence in the string that is a palindrome. If multiple palindromes of the same
    length exist, the first one should be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 29\. License plate validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Considering license plates with the format `LLL-LL DDD` or `LLL-LL DDDD` (where
    `L` is an uppercase letter from *A* to *Z* and `D` is a digit), write:'
  prefs: []
  type: TYPE_NORMAL
- en: One function that validates that a license plate number is of the correct format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One function that, given an input text, extracts and returns all the license
    plate numbers found in the text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 30\. Extracting URL parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that, given a string that represents a URL, parses and extracts
    the parts of the URL (protocol, domain, port, path, query, and fragment).
  prefs: []
  type: TYPE_NORMAL
- en: 31\. Transforming dates in strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that, given a text containing dates in the format `dd.mm.yyyy`
    or `dd-mm-yyyy`, transforms the text so that it contains dates in the format `yyyy-mm-dd`.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the solutions for the above problem-solving sections.
  prefs: []
  type: TYPE_NORMAL
- en: 23\. Binary to string conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to write a general-purpose function that can handle various sorts
    of ranges, such as an `std::array`, `std::vector`, a C-like array, or others,
    we should write a function template. In the following, there are two overloads;
    one that takes a container as an argument and a flag indicating the casing style,
    and one that takes a pair of iterators (to mark the first and then one past the
    end element of the range) and the flag to indicate casing. The content of the
    range is written to an `std::ostringstream` object, with the appropriate I/O manipulators,
    such as width, filling character, or case flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 24\. String to binary conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The operation requested here is the opposite of the one implemented in the
    previous problem. This time, however, we could write a function and not a function
    template. The input is an `std::string_view`, which is a lightweight wrapper for
    a sequence of characters. The output is a vector of 8-bit unsigned integers. The
    following `hexstr_to_bytes` function transforms every two text characters into
    an `unsigned char` value (`"A0"` becomes `0xA0`), puts them into an `std::vector`,
    and returns the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function assumes the input string contains an even number of hexadecimal
    digits. In cases where the input string contains an odd number of hexadecimal
    digits, the last one is discarded (so that `"BAD"` becomes `{0xBA}`). As a further
    exercise, modify the preceding function so that, instead of discarding the last
    odd digit, it considers a leading zero so that `"BAD"` becomes `{0x0B, 0xAD}`.
    Also, as yet another exercise, you can write a version of the function that deserializes
    content that has the hexadecimal digits separated by a delimiter, such as space
    (for example `"BA AD F0 0D"`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code sample shows how this function can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 25\. Capitalizing an article title
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The function template `capitalize()`, implemented as follows, works with strings
    of any type of characters. It does not modify the input string but creates a new
    string. To do so, it uses an `std::stringstream`. It iterates through all the
    characters in the input string and sets a flag indicating a new word to `true`
    every time a space or punctuation is encountered. Input characters are transformed
    to uppercase when they represent the first character in a word and to lowercase
    otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following program you can see how this function is used to capitalize
    texts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 26\. Joining strings together separated by a delimiter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two overloads called `join_strings()` are listed in the following code. One
    takes a container of strings and a pointer to a sequence of characters representing
    a separator, while the other takes two random access iterators, representing the
    first and one past the last element of a range, and a separator. They both return
    a new string created by concatenating all the input strings, using an output string
    stream and the `std::copy` function. This general-purpose function copies all
    the elements in the specified range to an output range, represented by an output
    iterator. We are using here an `std::ostream_iterator` that uses `operator<<`
    to write the assigned value to the specified output stream each time the iterator
    is assigned a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As a further exercise, you should modify the overload that takes iterators as
    arguments so that it works with other types of iterators, such as bidirectional
    iterators, thereby enabling the use of this function with lists or other containers.
  prefs: []
  type: TYPE_NORMAL
- en: 27\. Splitting a string into tokens with a list of possible delimiters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two different versions of a splitting function are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one uses a single character as the delimiter. To split the input string
    it uses a string stream initialized with the content of the input string, using `std::getline()` to
    read chunks from it until the next delimiter or an end-of-line character is encountered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second one uses a list of possible character delimiters, specified in an `std::string`.
    It uses `std:string::find_first_of()` to locate the first position of any of the
    delimiter characters, starting from a given position. It does so in a loop until
    the entire input string is being processed. The extracted substrings are added
    to the result vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following sample code shows two examples of how different strings can be
    split using either one delimiter character or multiple delimiters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 28\. Longest palindromic substring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest solution to this problem is to try a brute-force approach, checking
    if each substring is a palindrome. However, this means we need to check *C(N,
    2)* substrings (where *N* is the number of characters in the string), and the
    time complexity would be *![](img/76505ab6-7d29-4aab-9955-744ed0bcd1b6.png)*. 
    The complexity could be reduced to ![](img/2f7e78fe-014a-40b2-9524-bc0f479781a1.png)
    by storing results of sub problems. To do so we need a table of Boolean values,
    of size ![](img/a4173824-4963-42ca-b9ab-fd97affe7750.png), where the element at
    `[i, j]` indicates whether the substring from position `i` to `j` is a palindrome.
    We start by initializing all elements `[i,i]` with `true` (one-character palindromes)
    and all the elements `[i,i+i]` with `true` for all consecutive two identical characters
    (for two-character palindromes). We then go on to inspect substrings greater than
    two characters, setting the element at `[i,j]` to `true` if the element at `[i+i,j-1]`
    is `true` and the characters on the positions `i` and `j` in the string are also
    equal. Along the way, we retain the start position and length of the longest palindromic
    substring in order to extract it after finishing computing the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, this solution appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some test cases for the `longest_palindrome()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 29\. License plate validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to solve this problem is by using regular expressions. The
    regular expression that meets the described format is `"[A-Z]{3}-[A-Z]{2} \d{3,4}"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function only has to validate that an input string contains only
    text that matches this regular expression. For that, we can use `std::regex_match()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function is slightly different. Instead of matching the input string,
    it must identify all occurrences of the regular expression within the string.
    The regular expression would therefore change to `"([A-Z]{3}-[A-Z]{2} \d{3,4})*"`.
    To iterate through all matches we have to use `std::sregex_iterator`, which is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 30\. Extracting URL parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This problem is also suited to being solved using regular expressions. Finding
    a regular expression that could match any URL is, however, a difficult task. The
    purpose of this exercise is to help you practice your skills with the regex library,
    and not to find the ultimate regular expression for this particular purpose. Therefore,
    the regular expression used here is provided only for didactic purposes.
  prefs: []
  type: TYPE_NORMAL
- en: You can try regular expressions using online testers and debuggers, such as
    [https://regex101.com/](https://regex101.com/). This can be useful in order to
    work out your regular expressions and try them against various datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this task we will consider that a URL has the following parts: `protocol`
    and `domain` are mandatory, and `port`, `path`, `query`, and `fragment` are all
    optional. The following structure is used to return results from parsing an URL
    (alternatively, you could return a tuple and use structured binding to bind variables
    to the various sub parts of the tuple):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A function that can parse a URL and extract and return its parts could have
    the following implementation. Note that the return type is an `std::optional<uri_parts>`
    because the function might fail in matching the input string to the regular expression;
    in this case, the return value is `std::nullopt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following program tests the `parse_uri()` function with two URLs that contain
    different parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 31\. Transforming dates in strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text transformation can be performed with regular expressions using `std::regex_replace()`.
    A regular expression that can match dates with the specified formats is `(\d{1,2})(\.|-|/)(\d{1,2})(\.|-|/)(\d{4})`.
    This regex defines five capture groups; the 1^(st) is for the day, the 2^(nd)
    is for the separator (`.` or `-`), the 3^(rd) is for the month, the 4^(th) is
    again for the separator (`.` or `-`), and the 5^(th) is for the year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to transform dates from the format `dd.mm.yyyy` or `dd-mm-yyyy` to
    `yyyy-mm-dd`, the regex replacement format string for `std::regex_replace()` should
    be `"($5-$3-$1)"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
