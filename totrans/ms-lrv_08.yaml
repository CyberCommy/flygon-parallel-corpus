- en: Chapter 8. Querying the Database with the Eloquent ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned how build the basic components of an application.
    In this chapter the Eloquent ORM, another one of the best features that makes
    Laravel so popular, will be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic query statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-to-one, one-to-many, and many-to-many relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphic relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eager loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ORM, or object relational mapping, explained in the simplest sense, turns
    a table into a class, its columns into attributes, and its rows into instances
    of that class. It creates an abstraction layer between the developer and the database
    and allows for easier programming, since it uses the familiar object-oriented
    paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall assume that we have a posts table with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **id** | **contents** | **author_id** |   |'
  prefs: []
  type: TYPE_TB
- en: 'To illustrate this example, the following would be the representation of a
    posts table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To add in the `id`, `contents`, and `author_id` attributes, we will add the
    following code to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us an overview of how a table may be represented by a class: the
    `Post` class represents an entity that has a collection of **posts**.'
  prefs: []
  type: TYPE_NORMAL
- en: If the active record pattern was followed, then Eloquent can automatically manage
    all of the class names, key names, and their related relations. The power of Eloquent
    lies in its ability to give the programmer the ability to use object-oriented
    methods to manage the relations between the classes.
  prefs: []
  type: TYPE_NORMAL
- en: Basic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now discuss some of the basic operations. There are virtually hundreds
    of ways to use Eloquent, and certainly every developer will use Eloquent in the
    best way for their project. The following techniques are the basic building blocks
    upon which more complex queries may be developed.
  prefs: []
  type: TYPE_NORMAL
- en: Finding one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most basic operations is to perform the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is accomplished by using the `find()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Room` facade is called with the `find` method, which accepts the ID as
    an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since Eloquent is based on the fluent query builder, any fluent method may be
    mixed and matched. Some of the fluent methods are chainable and others execute
    the query.
  prefs: []
  type: TYPE_NORMAL
- en: The `find()` method actually executes the query, so it always needs to be at
    the end of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the ID of the model is not found, then nothing is returned. To force a `ModelNotFoundException`,
    which can then be trapped to perform some other operation such as logging, add
    `OrFail` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The where method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To query an attribute (column) other than ID, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `where` method followed by the `get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `like` comparator may be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Chaining functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Multiple where methods can be chained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command produces the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that if the `where` comparator is `=` (equals), then the second parameter
    (the comparator) is not needed, and the second part of the comparison is passed
    into the function. Also, note that an `and` operation is added between the two
    `where` methods. To achieve an `or` operation, the following change has to be
    made to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `or` is added to the `where` creating `orWhere()`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding all
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find all of the rooms, the `all()` method is used in place of `find`. Notice
    that this method actually executes the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To limit the number of rooms, the `take` method is used in place of `find`.
    Since `take` is chainable, `get` is needed to execute the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve pagination, the following query may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the preceding query will return a JSON object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Attributes such as `total`, `per_page`, `current_page`, and `last_page` are
    used to give the developer an easy way to implement paging, while the array of
    data is returned inside of an array called `data`.
  prefs: []
  type: TYPE_NORMAL
- en: Eloquent relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relationships such as one-to-one, one-to-many (or many-to-one), and many-to-many
    are familiar to database programmers. Laravel's Eloquent has brought these concepts
    into an object-oriented environment. Additionally, Eloquent has even more powerful
    tools such as polymorphic relations, where entities can be related to more than
    one other entity. In the following examples, we will see the relationship between
    accommodations, rooms, and amenities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Eloquent relations](graphics/B04559_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One-to-one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first relation is one-to-one. In our example software, we can use the example
    of a room in our accommodation. A room may only (at least easily) belong to one
    accommodation, so the room *belongs to* the accommodation. Inside the `Room` Eloquent
    model, the following code tells Eloquent that the room belongs to the `accommodation`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, the database tables do not follow the active record pattern, especially
    if the programmer inherits a legacy database. If the database used a table called
    `bedroom` instead of `rooms`, then the class would add an attribute to indicate
    the table name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When the following route code is executed, then the `accommodation` object
    will be returned as a JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One common mistake is to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the programmer expects to return the model. This will return
    the actual `belongsTo` relation and in the context of the RESTful API, there will
    be an error thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is because Laravel can convert the JSON object to a string, but not a relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL run is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Eloquent tends to favor multiple simpler queries as opposed to doing larger
    joins.
  prefs: []
  type: TYPE_NORMAL
- en: First the room is found. Then, `limit 1` is added because `find` is only used
    to find a single entity or row. Once the `accommodation_id` is found, the next
    query will find the accommodation with that corresponding ID and return the object.
    If the active record pattern was followed, the SQL that Eloquent produces is extremely
    readable.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second relation is one-to-many. In our example software, we can use the
    example of an accommodation having many rooms. Since rooms may belong to one accommodation,
    then the the accommodation has *many rooms*. Inside the `Accommodation` Eloquent
    model, the following code tells Eloquent that the accommodation has many rooms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar route, the following code is run. This time, a collection of `rooms`
    objects will be returned as JSON-formatted objects inside an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will be the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL run is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As before, the accommodation is found. The second query will find the rooms
    that belong to that accommodation. A check is added to confirm that the `accommodation_id`
    is not null.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our example software application, the relationship between amenity and room
    is many-to-many. Each room can have many amenities, such as Internet access and
    a Jacuzzi, and each amenity is shared among many rooms: *every room in an accommodation
    could and should have internet access!* The following code, which uses a `belongsToMany`
    relationship, enables an amenity to belong to many rooms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The test route, which tells us how each room has a certain amenity, is written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A list of rooms is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL executed is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We recall the `belongToMany` relationship that returns the rooms that have
    a particular amenity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Eloquent skillfully gives us the corresponding `belongsToMany` relationship
    to determine which amenities a particular room has. The syntax is exactly the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The test route is virtually the same, just substituting `amenities` for `rooms`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a list of amenities for the room with ID 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The query used is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The query, substituting `room_id` for `amenity_id` and `rooms` for `amenities`,
    is clearly parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Has-many-through
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One great feature of Eloquent is "has-many-through". What if the requirements
    of the software change and we are asked to group some of the accommodations together
    into franchises? If an application user would like to search for a room, any of
    the rooms in any of the accommodations that belong to that franchise could be
    found. A franchises table will be added, and a nullable column to the accommodations
    table called `franchise_id` will be added. This will optionally allow for an accommodation
    to belong to a franchise. Rooms already belong to accommodations through the `accommodation_id`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: A room belongs to an `accommodation` through its `accommodation_id` key, while
    an accommodation belongs to a franchise through its `franchise_id` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eloquent allows us to retrieve the rooms associated to a franchise by using
    `hasManyThrough`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `hasManyThrough` relationship takes the target or the "has" as its first
    parameter (in this case, the room) and its "through" as the second parameter (in
    this case, the accommodation).
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic stated as a phrase is: *This franchise has many rooms through its
    accommodations*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the previous test route, the code is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The rooms are returned as an array as would be expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The queries executed are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Polymorphic relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One great feature of Eloquent is the possibility to have an entity whose relationship
    is polymorphic. The two parts of the word, *poly* and *morphic*, are from the
    Greek language. Since *poly* means *many* and *morphic* means *shape*, we can
    now easily imagine a relationship having multiple forms.
  prefs: []
  type: TYPE_NORMAL
- en: Amenitiable relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An amenity in our example software is something that is associated with a room,
    such as a Jacuzzi. Certain amenities, such as covered parking or an airport shuttle
    service, could also relate to an accommodation itself. We could create two pivot
    tables for this, one called `amenity_room` and another called `accommodation_amenity`.
    Another great way to do this is to combine the two into one table and use a field
    to distinguish between the two types or relationship.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will need a field to distinguish between *amenity and room* and
    *amenity and room*, something we could call a relationship type. Laravel's Eloquent
    skillfully handles this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eloquent uses the suffix `-able` to make this happen. In our example, we would
    create a table that has the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amenitiable_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amenitiable_type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three fields are familiar, but two new fields added. One of them will
    contain the ID of either the accommodation or the room.
  prefs: []
  type: TYPE_NORMAL
- en: The Amenity table structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For example, given a room with ID 5, `amenitiable_id` will be `5` while `amenitiable_type`
    will be `Room`. Given an accommodation with ID 5, `amenitiable_id` will be `5`
    while `amenitiable_type` will be `Accommodation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| id | name | description | amenitiable_id | amenitiable_type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Wireless internet | Internet conn. | 5 | Room |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Covered parking | Parking in garage | 5 | Accommodation |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Sea view | Ocean view from room | 5 | Room |'
  prefs: []
  type: TYPE_TB
- en: The Amenity model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In terms of code, the `Amenity` model will now contain an "amenitiable" function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The Accommodation model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Accommodation` model will change the `amenities` method to use `morphMany`
    instead of `hasMany`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The Room model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Room` model will contain the same `morphMany` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when the amenities are requested for a room or an accommodation, Eloquent
    will automatically distinguish between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Each of these functions returns the correct type of amenity for room and for
    accommodation.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many polymorphic relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible, though, that some amenities could be shared between a room
    and an accommodation. In this case, a many-to-many polymorphic relation is used.
    The pivot table now adds several fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '| amenity_id | amenitiable_id | amenitiable_type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 5 | Room |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 5 | Accommodation |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 5 | Room |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 5 | Accommodation |'
  prefs: []
  type: TYPE_TB
- en: As illustrated, both the room with ID 5 and the accommodation with ID 5 have
    amenities with IDs 1 and 2.
  prefs: []
  type: TYPE_NORMAL
- en: Has relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we would like to select all of the accommodations that are associated to
    a franchise, the `has()` method is used, where the relation is passed as the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following JSON array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `franchise_id` value is 1, which means the accommodations have
    a franchise associated with them. Optionally, a `where` may be added to the `has`
    creating a `whereHas` function. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `whereHas` takes a closure as its second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would return only the accommodations where the description contains `Pittsburgh`,
    so the returned array would contain only results like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Eager loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another great mechanism that Eloquent provides is eager loading. If we want
    return all of the franchises together with all of their accommodations, we simply
    need to add an `accommodations` function to our `Franchise` model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, by adding a `with` clause to the statement, the accommodations are returned
    for each franchise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also list the rooms associated with each accommodation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to return the rooms nested inside of the accommodation array, then
    the following syntax should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `rooms` is contained within `accommodation`.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel's ORM is powerful. In fact, there are too many types of operations to
    list within a single book. The simplest queries can be accomplished with a few
    keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel''s Eloquent command gets converted into fluent commands, so if something
    more complicated is desired, then the fluent syntax may be used. If a very complicated
    query needs to be performed, then the `DB::raw()` function can even be used. This
    will allow exact strings to be used inside the query builder. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns just the number of hotels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Learning to design the software, starting with the domain and then thinking
    about which entities are involved in that domain, will help a developer think
    in an object-oriented manner. Having a list of entities leads to the creation
    of the table, so the actual creation of the schema will be performed last. This
    approach may take some getting used to. Understanding Eloquent relationships is
    key to being able to produce expressive, readable statements that query the database
    while hiding away the complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason why Eloquent is extremely useful is in the case of a legacy database.
    If the ORM is applied in a situation where the tables have nonstandard names,
    the keys are not named by the same name, or the column names are simply not easily
    understandable, Eloquent provides the developer with tools to actually help homogenize
    the table names and field names, and perform the relations by providing attribute
    getters and setters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the field names are `fname1` and `fname2`, we can use a get
    attribute function inside our model, where the syntax is `get` followed by the
    desired name to use in the application and the attribute. So, in the case of `fname1`,
    the function would be added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Functions such as these are Eloquent's real selling point. In this chapter,
    you learned how to find data inside your database by using entity models, limiting
    the results through the addition of `where`, relationships, powerful conventions
    such as polymorphic relationships, and auxiliary helpers such as pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the Eloquent ORM was demonstrated in detail. Eloquent is an
    object-oriented wrapper to what actually happens between the database and the
    code. Since the Fluent query builder is easily accessible, it is important to
    be familiar with how the queries are written. This will help in debugging and
    also cover complex cases where Eloquent is not adequate. In this chapter, most
    of the concepts of Eloquent have been discussed. However, there are many more
    methods available, so further reading is encouraged.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, among other topics, you will learn how to scale the database
    to perform better on a larger scale.
  prefs: []
  type: TYPE_NORMAL
