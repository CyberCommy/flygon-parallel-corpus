- en: Chapter 9. Adding Real-time Functionality Using Socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, you learned how to build your MEAN application and how
    to create CRUD modules. These chapters covered the basic functionalities of a
    web application; however, more and more applications require real-time communication
    between the server and the browser. In this chapter, you''ll learn how to connect
    your Express and Angular applications in real time using the `Socket.io` module.
    Socket.io enables Node.js developers to support real-time communication using
    `WebSockets` in modern browsers and legacy fallback protocols in older browsers.
    In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Socket.io module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Express application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Socket.io/Passport session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring Socket.io routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Socket.io client object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple chat room
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern web applications, such as Facebook, Twitter, and Gmail, are incorporating
    real-time capabilities which enable applications to continuously present the user
    with recently updated information. Unlike traditional applications, in real-time
    applications, the common roles of the browser and the server can be reversed since
    the server needs to update the browser with new data regardless of the browser
    request state. This means that unlike the common HTTP behavior, the server won't
    wait for the browser's requests. Instead, it will send new data to the browser
    whenever this data becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: This reverse approach is often called **Comet**, a term coined by a web developer
    named Alex Russel back in 2006 (the term was a word play on the AJAX term; both
    Comet and AJAX are common household cleaners in the US). In the past, there were
    several ways to implement a Comet functionality using the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and easiest way is **XMLHttpRequest** (**XHR**) polling. In XHR polling,
    the browser makes periodic requests to the server. The server then returns an
    empty response unless it has new data to send back. Upon a new event, the server
    will return the new event data to the next polling request. While this works quite
    well for most browsers, this method has two problems. The most obvious one is
    that using this method generates a large number of requests that hit the server
    with no particular reason, since a lot of requests return empty. The second problem
    is that the update time depends on the request period. This means that new data
    will only get pushed to the browser on the next request, causing delays in updating
    the client state. To solve these issues, a better approach was introduced: XHR
    long polling.'
  prefs: []
  type: TYPE_NORMAL
- en: In XHR long polling, the browser makes an XHR request to the server, but a response
    is not sent back unless the server has new data. Upon an event, the server responds
    with the event data and the browser makes a new long polling request. This cycle
    enables better management of requests, since there is only a single request per
    session. Furthermore, the server can update the browser immediately with new information
    without having to wait for the browser's next request. Because of its stability
    and usability, XHR long polling has become the standard approach for real-time
    applications and was implemented in various ways, including Forever iFrame, multipart
    XHR, and JSONP long polling using script tags (for cross-domain, real-time support),
    and the common long-living XHR.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, all these approaches were actually hacks using the HTTP and XHR protocols
    in a way they were not meant to be used. With the rapid development of modern
    browsers and the increased adoption of the new HTML5 specifications, a new protocol
    emerged in order to implement real-time communication: the full duplex `WebSockets`
    protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: In browsers that support the `WebSockets` protocol, the initial connection between
    the server and browser is made over HTTP and is called an HTTP handshake. Once
    the initial connection is made, the browser and server open a single ongoing communication
    channel over a TCP socket. Once the socket connection is established, it enables
    bidirectional communication between the browser and the server. This enables both
    parties to send and retrieve messages over a single communication channel. This
    also helps lower the server load, decrease message latency, and unify PUSH communication
    using a standalone connection.
  prefs: []
  type: TYPE_NORMAL
- en: However, `WebSockets` still suffers from two major problems. First and foremost
    is browser compatibility. The `WebSockets` specification is fairly new, so older
    browsers don't support it, and though most modern browsers implement the protocol
    now, a large group of users is still using these older browsers. The second problem
    is HTTP proxies, firewalls, and hosting providers. Since `WebSockets` uses a different
    communication protocol than HTTP, a lot of these intermediaries don't support
    it yet and block any socket communication. As it has always been with the Web,
    developers are left with a fragmentation problem, which can only be solved using
    an abstraction library that optimizes usability by switching between protocols
    according to the available resources. Fortunately, a popular library called Socket.io
    has been developed for this purpose, and it is freely available for the Node.js
    developer community.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Created in 2010 by the JavaScript developer Guillermo Rauch, Socket.io aimed
    at abstracting Node.js real-time application development. Since then, it has evolved
    dramatically and has been released in nine major versions before being broken
    in its latest version into two different modules: `engine.io` and `socket.io`.'
  prefs: []
  type: TYPE_NORMAL
- en: Previous versions of Socket.io were criticized for being unstable since they
    first tried to establish the most advanced connection mechanisms and then fall
    back on more primitive protocols. This caused serious issues with using Socket.io
    in production environments and posed a threat to the adoption of Socket.io as
    a real-time library. To solve this, the Socket.io team redesigned it and wrapped
    the core functionality in a base module called Engine.io.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind Engine.io was to create a more stable real-time module, which
    first opens a long-polling XHR communication and then tries to upgrade the connection
    to a `WebSockets` channel. The new version of Socket.io uses the Engine.io module
    and provides the developer with various features, such as events, rooms, and automatic
    connection recovery, which you would otherwise implement by yourself. In this
    chapter's examples, we will use the new Socket.io 1.0, which is the first version
    to use the Engine.io module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Older versions of Socket.io prior to version 1.x don't use the new Engine.io
    module and, therefore, are much less stable in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you include the `socket.io` module, it provides you with two objects:
    a socket server object that is responsible for the server functionality and a
    socket client object that handles the browser''s functionality. We''ll begin by
    examining the server object.'
  prefs: []
  type: TYPE_NORMAL
- en: The Socket.io server object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Socket.io server object is where it all begins. You start by requiring the
    `socket.io` module and then use it to create a new Socket.io server instance that
    will interact with socket clients. The server object supports both a standalone
    implementation and the ability to use it in conjunction with the Express framework.
    The server instance then exposes a set of methods that allow you to manage the
    Socket.io server operations. Once the server object is initialized, it will also
    be responsible for serving the socket client JavaScript file for the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple implementation of the standalone Socket.io server will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open a Socket.io over the `3000` port and serve the socket client
    file at `http://localhost:3000/socket.io/socket.io.js`. Implementing the Socket.io
    server in conjunction with an Express application will be a bit different as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This time, you first use the `http` module of Node.js to create a server and
    wrap the Express application. The server object is then passed to the `socket.io`
    module and serves both the Express application and the Socket.io server. Once
    the server is running, it will be available for socket clients to connect. A client
    trying to establish a connection with the Socket.io server will start by initiating
    the handshaking process.
  prefs: []
  type: TYPE_NORMAL
- en: Socket.io handshaking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a client wants to connect the Socket.io server, it will first send a handshake
    HTTP request. The server will then analyze the request to gather the necessary
    information for the ongoing communication. It will then look for the configuration
    middleware that is registered with the server and execute it before firing the
    connection event. When the client is successfully connected to the server, the
    connection event listener is executed, exposing a new socket instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the handshaking process is over, the client is connected to the server,
    and all communication with it is handled through the socket instance object. For
    example, handling a client''s disconnection event will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note how the `socket.on()` method adds an event handler to the disconnection
    event. Although the disconnection event is a predefined event, this approach works
    the same for custom events as well, as you will see in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: While the handshake mechanism is fully automatic, Socket.io provides you with
    a way to intercept the handshake process using a configuration middleware.
  prefs: []
  type: TYPE_NORMAL
- en: The Socket.io configuration middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although the Socket.io configuration middleware existed in previous versions,
    in the new version, it is even simpler and allows you to manipulate socket communication
    before the handshake actually occurs. To create a configuration middleware, you
    will need to use the server''s `use()` method, which is very similar to the Express
    application''s `use()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `io.use()` method callback accepts two arguments: the `socket`
    object and a `next` callback. The `socket` object is the same socket object that
    will be used for the connection, and it holds some connection properties. An important
    property is the `socket.request` property, which represents the handshake HTTP
    request. In the following sections, you will use the handshake request to incorporate
    the Passport session with the Socket.io connection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `next` argument is a callback method that accepts two arguments: an error
    object and a Boolean value. The `next` callback tells Socket.io whether or not
    to proceed with the handshake process, so if you pass an error object or a false
    value to the `next` method, Socket.io will not initiate the socket connection.
    Now that you have a basic understanding of how handshaking works, it is time to
    discuss the Socket.io client object.'
  prefs: []
  type: TYPE_NORMAL
- en: The Socket.io client object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Socket.io client object is responsible for the implementation of the browser
    socket communication with the Socket.io server. You start by including the Socket.io
    client JavaScript file, which is served by the Socket.io server. The Socket.io
    JavaScript file exposes an `io()` method that connects to the Socket.io server
    and creates the client `socket` object. A simple implementation of the socket
    client will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note the default URL for the Socket.io client object. Although it can be altered,
    you can usually leave it like this and just include the file from the default
    Socket.io path. Another thing you should notice is that the `io()` method will
    automatically try to connect to the default base path when executed with no arguments;
    however, you can also pass a different server URL as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the socket client is much easier to implement, so we can move
    on to discussing how Socket.io handles real-time communication using events.
  prefs: []
  type: TYPE_NORMAL
- en: Socket.io events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To handle the communication between the client and the server, Socket.io uses
    a structure that mimics the `WebSockets` protocol and fires event messages across
    the server and client objects. There are two types of events: system events, which
    indicate the socket connection status, and custom events, which you''ll use to
    implement your business logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The system events on the socket server are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`io.on(''connection'', ...)`: This is emitted when a new socket is connected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.on(''message'', ...)`: This is emitted when a message is sent using
    the `socket.send()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.on(''disconnect'', ...)`: This is emitted when the socket is disconnected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The system events on the client are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.io.on(''open'', ...)`: This is emitted when the socket client opens
    a connection with the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.io.on(''connect'', ...)`: This is emitted when the socket client is
    connected to the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.io.on(''connect_timeout'', ...)`: This is emitted when the socket client
    connection with the server is timed out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.io.on(''connect_error'', ...)`: This is emitted when the socket client
    fails to connect with the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.io.on(''reconnect_attempt'', ...)`: This is emitted when the socket
    client tries to reconnect with the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.io.on(''reconnect'', ...)`: This is emitted when the socket client
    is reconnected to the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.io.on(''reconnect_error'', ...)`: This is emitted when the socket client
    fails to reconnect with the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.io.on(''reconnect_failed'', ...)`: This is emitted when the socket
    client fails to reconnect with the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.io.on(''close'', ...)`: This is emitted when the socket client closes
    the connection with the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While system events are helping us with connection management, the real magic
    of Socket.io lies in using custom events. In order to do that, Socket.io exposes
    two methods, both on the client and server objects. The first method is the `on()`
    method, which binds event handlers with events, and the second method is the `emit()`
    method, which is used to fire events between the server and client objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'An implementation of the `on()` method in the socket server is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you bound an event listener to the `customEvent` event.
    The event handler is called when the socket client object emits the `customEvent`
    event. Note how the event handler accepts the `customEventData` argument that
    is passed to the event handler from the socket client object.
  prefs: []
  type: TYPE_NORMAL
- en: 'An implementation of the `on()` method in the socket client is also straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This time, the event handler is called when the socket server emits the `customEvent`
    event that sends `customEventData` to the socket client event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Once you set your event handlers, you can use the `emit()` method to send events
    from the socket server to the socket client and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the socket server, the `emit()` method is used to send events to a single
    socket client or a group of connected socket clients. The `emit()` method can
    be called from the connected `socket` object, which will send the event to a single
    socket client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `emit()` method can also be called from the `io` object, which will send
    the event to all connected socket clients, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to send the event to all connected socket clients except
    from the sender using the `broadcast` property, as shown in the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'On the socket client, things are much simpler. Since the socket client is only
    connected to the socket server, the `emit()` method will only send the event to
    the socket server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Although these methods allow you to switch between personal and global events,
    they still lack the ability to send events to a group of connected socket clients.
    Socket.io offers two options to group sockets together: namespaces and rooms.'
  prefs: []
  type: TYPE_NORMAL
- en: Socket.io namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to easily control socket management, Socket.io allows developers to
    split socket connections according to their purpose using namespaces. So instead
    of creating different socket servers for different connections, you can just use
    the same server to create different connection endpoints. This means that socket
    communication can be divided into groups, which will then be handled separately.
  prefs: []
  type: TYPE_NORMAL
- en: Socket.io server namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a socket server namespace, you will need to use the socket server
    `of()` method that returns a socket namespace. Once you retain the socket namespace,
    you can just use it the same way you use the socket server object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, when you use the `io` object, Socket.io actually uses a default empty
    namespace, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines of code are actually equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Socket.io client namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the socket client, the implementation is a little different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can use multiple namespaces on the same application without
    much effort. However, once sockets are connected to different namespaces, you
    will not be able to send an event to all these namespaces at once. This means
    that namespaces are not very good for a more dynamic grouping logic. For this
    purpose, Socket.io offers a different feature called rooms.
  prefs: []
  type: TYPE_NORMAL
- en: Socket.io rooms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Socket.io rooms allow you to partition connected sockets into different groups
    in a dynamic way. Connected sockets can join and leave rooms, and Socket.io provides
    you with a clean interface to manage rooms and emit events to the subset of sockets
    in a room. The rooms functionality is handled solely on the socket server but
    can easily be exposed to the socket client.
  prefs: []
  type: TYPE_NORMAL
- en: Joining and leaving rooms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Joining a room is handled using the socket `join()` method, while leaving a
    room is handled using the `leave()` method. So, a simple subscription mechanism
    can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `join()` and `leave()` methods both take the room name as the
    first argument.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting events to rooms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To emit events to all the sockets in a room, you will need to use the `in()`
    method. So, emitting an event to all socket clients who joined a room is quite
    simple and can be achieved with the help of the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to send the event to all the connected socket clients in
    a room except the sender using the `broadcast` property and the `to()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This pretty much covers the simple yet powerful room functionality of Socket.io.
    In the next section, you will learn how to implement Socket.io in your MEAN application,
    and more importantly, how to use the Passport session to identify users in the
    Socket.io session. The examples in this chapter will continue directly from those
    in previous chapters, so copy the final example from [Chapter 8](ch08.html "Chapter 8. Creating
    a MEAN CRUD Module"), *Creating a MEAN CRUD Module*, and let's start from there.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we covered most of the Socket.io features, you can learn more about Socket.io
    by visiting the official project page at [http://socket.io/](http://socket.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you can use the `socket.io` module, you will need to install it using
    `npm`. To do that, change your `package.json` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the `socket.io` module, go to your application''s root folder and
    issue the following command in your command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As usual, this will install the specified version of Socket.io in your `node_modules`
    folder. When the installation process is successfully over, you will need to configure
    your Express application to work in conjunction with the `socket.io` module and
    start your socket server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Socket.io server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you''ve installed the `socket.io` module, you will need to start the
    socket server in conjunction with the Express application. For this, you will
    have to make the following changes in your `config/express.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's go over the changes you made to your Express configuration. After including
    the new dependencies, you used the `http` core module to create a `server` object
    that wraps your Express `app` object. You then used the `socket.io` module and
    its `listen()` method to attach the Socket.io server with your `server` object.
    Finally, you returned the new `server` object instead of the Express application
    object. When the server starts, it will run your Socket.io server along with your
    Express application.
  prefs: []
  type: TYPE_NORMAL
- en: While you can already start using Socket.io, there is still one major problem
    with this implementation. Since Socket.io is a standalone module, requests that
    are sent to it are detached from the Express application. This means that the
    Express session information is not available in a socket connection. This raises
    a serious obstacle when dealing with your Passport authentication in the socket
    layer of your application. To solve this issue, you will need to configure a persistent
    session storage, which will allow you to share your session information between
    the Express application and Socket.io handshake requests.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Socket.io session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To configure your Socket.io session to work in conjunction with your Express
    sessions, you have to find a way to share session information between Socket.io
    and Express. Since the Express session information is being stored in the memory
    currently, Socket.io will not be able to access it properly. So, a better solution
    would be to store the session information in your MongoDB. Fortunately, there
    is a node module named `connect-mongo` that allows you to store the session information
    in a MongoDB instance almost seamlessly. To retrieve the Express session information,
    you will need a way to parse the signed session cookie information. For this purpose,
    you'll also need to install the `cookie-parser` module, which is used to parse
    the cookie header and populate the HTTP request object with cookies-related properties.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the connect-mongo and cookie-parser modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you can use the `connect-mongo` and `cookie-parser` modules, you will
    need to install them using `npm`. To do that, change your `package.json` file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the new modules, go to your application''s root folder and issue
    the following command in your command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As usual, this will install the specified versions of the `connect-mongo` and
    `cookie-parser` modules in your `node_modules` folder. When the installation process
    is successfully over, your next step will be to configure your Express application
    to use `connect-mongo` as the session storage.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the connect-mongo module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To configure your Express application to store session information using the
    `connect-mongo` module, you will have to make a few changes. First, you will need
    to change your `config/express.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you configured a few things. First, you loaded
    the `connect-mongo` module and then passed the Express session module to it. Then,
    you created a new `connect-mongo` instance and passed your Mongoose connection
    object to it. Finally, you used the Express session store option to let the Express
    session module know where to store the session information.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, your Express configuration method requires a `db` argument.
    This argument is the Mongoose connection object, which will be passed to the Express
    configuration method from the `server.js` file when it requires the `express.js`
    file. So, go to your `server.js` file and change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once the Mongoose connection is created, the `server.js` file will call the
    `express.js` module method and pass the Mongoose database property to it. In this
    way, Express will persistently store the session information in your MongoDB database
    so that it will be available for the Socket.io session. Next, you will need to
    configure your Socket.io handshake middleware to use the `connect-mongo` module
    and retrieve the Express session information.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Socket.io session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To configure the Socket.io session, you''ll need to use the Socket.io configuration
    middleware and retrieve your session user. Begin by creating a new file named
    `socketio.js` in your `config` folder to store all your Socket.io-related configurations.
    In your new file, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's go over the new Socket.io configuration file. First, you required the
    necessary dependencies, and then you used the `io.use()` configuration method
    to intercept the handshake process. In your configuration function, you used the
    Express `cookie-parser` module to parse the handshake request cookie and retrieve
    the Express `sessionId`. Then, you used the `connect-mongo` instance to retrieve
    the session information from the MongoDB storage.
  prefs: []
  type: TYPE_NORMAL
- en: Once you retrieved the session object, you used the `passport.initialize()`
    and `passport.session()` middleware to populate the session's `user` object according
    to the session information. If a user is authenticated, the handshake middleware
    will call the `next()` callback and continue with the socket initialization; otherwise,
    it will use the `next()` callback in a way that informs Socket.io that a socket
    connection cannot be opened. This means that only authenticated users can open
    a socket communication with the server and prevent unauthorized connections to
    your Socket.io server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete your Socket.io server configuration, you will need to call the
    Socket.io configuration module from your `express.js` file. Go to your `config/express.js`
    file and change it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will execute your Socket.io configuration method and will take care of
    setting the Socket.io session. Now that you have everything configured, let's
    see how you can use Socket.io and MEAN to easily build a simple chat.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Socket.io chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test your Socket.io implementation, build a simple chat application. Your
    chat will be constructed from several server event handlers, but most of the implementation
    will take place in your Angular application. We'll begin with setting the server
    event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the event handlers of the chat server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before implementing the chat client in your Angular application, you''ll first
    need to create a few server event handlers. You already have a proper application
    structure, so you won''t implement the event handlers directly in your configuration
    file. Instead, it would be better to implement your chat logic by creating a new
    file named `chat.server.controller.js` inside your `app/controllers` folder. In
    your new file, paste the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this file, you implemented a couple of things. First, you used the `io.emit()`
    method to inform all the connected socket clients about the newly connected user.
    This was done by emitting the `chatMessage` event and passing a chat message object
    with the user information and the message text, time, and type. Since you took
    care of handling the user authentication in your socket server configuration,
    the user information is available from the `socket.request.user` object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you implemented the `chatMessage` event handler that will take care of
    messages sent from the socket client. The event handler will add the message type,
    time, and user information, and it will send the modified message object to all
    connected socket clients using the `io.emit()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Our last event handler will take care of handling the `disconnect` system event.
    When a certain user is disconnected from the server, the event handler will notify
    all the connected socket clients about this event using the `io.emit()` method.
    This will allow the chat view to present the disconnection information to other
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'You now have your server handlers implemented, but how will you configure the
    socket server to include these handlers? To do that, you will need to go back
    to your `config/socketio.js` file and slightly modify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note how the socket server `connection` event is used to call the chat controller.
    This will allow you to bind your event handlers directly with the connected socket.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations; you've successfully completed your server implementation! Next,
    you'll see how easy it is to implement the Angular chat component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Chat Angular module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to finish our chat implementation, we're going to create a new Angular
    chat module. Our module will include our component and template, a routing configuration,
    and a service wrapping the `socket.io` client functionality. Socket.io provides
    us with a client library to handle the socket communication; however, a best practice
    would be to obfuscate it using our own Angular service. We'll begin by configuring
    the Socket.io client library.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Socket.io client library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up the Socket.io client library, we''ll need to include the library
    JavaScript file in our `index.ejs` template. To do that, go to the `app/views/index.ejs`
    file and make the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all that we did here was add the script tag to include Socket.io's
    client file in our main application page. Next, we'll need to create our `Chat`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Chat module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we are finished with the basic declaration setup for our client Socket.io
    implementation, we can continue with our chat implementation. To begin, create
    a folder named `chat` inside your `public/app` folder. Then, create a file inside
    this folder called `chat.module.ts`, which contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you probably noticed, our module imports a new chat component and routing
    configuration and injects the chat service. Let's continue by creating our chat
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Chat service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to obfuscate our component communication with the Socket.io client
    library, we''ll need to create an Angular service. To do that, create a file named
    `chat.service.ts` inside your `public / app / chat` folder. In your new file,
    paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let's review our new code for a moment. The basic structure should look familiar,
    since it is basically a regular Angular service. After injecting the Authentication
    and Router services in the constructor, you checked whether the user is authenticated
    using the `Authentication` service. If the user was not authenticated, you redirected
    the request back to the home page using the `Router` service. Since Angular services
    are lazily loaded, the Socket service will only load when requested. This will
    prevent unauthenticated users from using the Socket service. If the user is authenticated,
    the service `socket` property is set by calling the `io()` method of Socket.io.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you wrapped the socket `emit()`, `on()`, and `removeListener()` methods
    with compatible service methods. In order to keep our example straightforward,
    we called our `ChatService` service. However, as you may notice by its structure,
    this service can easily become a general Socket service used across different
    components of our application. Now that the chat service is ready, all we have
    to do is implement the chat component and template. Let's begin by defining the
    chat component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Chat component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our chat component will contain the basic client-side chat functionality. To
    implement it, go to your `public / app / chat` folder and create a file named
    `char.component.ts`. In your new file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In our component, you first created a message array and then used the `ChatService
    on()` method to implement the `chatMessage` event listener that will add retrieved
    messages to this array. Next, you created a `sendMessage()` method that will send
    new messages by emitting the `chatMessage` event to the socket server. Finally,
    you used the in-built `ngOnInit` directive to remove the `chatMessage` event listener
    from the socket client. The `ngOnDestroy` method will be emitted when the controller
    instance is deconstructed. This is important because the event handler will still
    get executed unless you remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Chat template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The chat template will be constructed from a simple form and a list of chat
    messages. To implement your chat template, go to your `public/app/chat` folder
    and create a new file named `chat.template.html`, which contains the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In your template, you used the `ngFor` directive to render the message list
    and the `ngSwitch` directive to distinguish between status messages and regular
    messages. The template ends with a simple form that uses the `ngSubmit` directive
    to invoke the `sendMessage()` method. That is it! All you have to do is finalize
    your implementation by adding the Chat module to our application module.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Chat routing configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add your Chat component route, go back to your `public/app/chat` folder
    and create a new file named `chat.routes.ts`, which contains the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we created a simple routing for our chat component. All we have
    left to do is include our chat module in our application module.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Chat module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To finalize our Chat implementation, we''ll need to include our module in the
    application module. To do that, go to your `public/app/app.`module `.ts`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you''ll need to add a link to our chat component in our home component.
    To do that, go to your `public/app/home/home.template.html` file and make the
    following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are finished with these changes, your new chat component should be
    ready for use! Use your command-line tool and navigate to the MEAN application''s
    root folder. Then, run your application by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Once your application is running, open two different browsers and sign up with
    two different users. Then, navigate to `http://localhost:3000/` and click on your
    new Chat link. Try to send chat messages between your two clients, and you'll
    be able to see how chat messages are updated in real time. Your MEAN application
    now supports real-time communication!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how the `socket.io` module works. You went over
    the key features of Socket.io and learned how the server and client communicate.
    You configured your Socket.io server and learned how to integrate it with your
    Express application. You also used the Socket.io handshake configuration to integrate
    the Passport session. Finally, you built a fully functional chat example and learned
    how to wrap the Socket.io client with an Angular service. In the next chapter,
    you'll learn how to write and run tests to cover your application code.
  prefs: []
  type: TYPE_NORMAL
