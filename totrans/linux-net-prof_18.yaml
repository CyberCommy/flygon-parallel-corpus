- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following pages, we will review all of the practice questions from each
    of the chapters in this book and provide the correct answers.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 – Basic Linux Network Configuration and Operations – Working with
    Local Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A default gateway is a special route, usually denoted as `0.0.0.0/0` (in other
    binary, this indicates "all networks"). A host always has a local routing table,
    with an order of precedence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any network that is directly connected to an interface is processed first. These
    are called `ip` command of the `route` command.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the default route is referenced. If the traffic being sent does not
    match a connected route or a route in the routing table, it is sent to the IP
    defined in the default gateway. Usually, this device will be a special router
    or firewall device, which in turn will usually have both a local table, statically
    defined routes, and a default gateway (among several other routing mechanisms
    that are not in the scope of this book).
  prefs: []
  type: TYPE_NORMAL
- en: For this network, the subnet mask is `255.255.255.0` (24 binary bits). The broadcast
    address is `192.158.25.255`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traffic sent to the broadcast address is sent to the entire subnet and is processed
    by all hosts in that subnet. An example of this is a standard ARP request (which
    we will cover in more depth in the next chapter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The host addresses can range from `192.168.25.1` to `192.168.25.254`. The `0`
    address is the network address, so it cannot be used for a host. The `255` address
    is the broadcast address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `nmcli` command is the recommended method of making this change. For instance,
    to set interface connection wired Ethernet 1 to 100 Mbps/full duplex, use this
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 3 – Using Linux and Linux Tools for Network Diagnostics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will never see this. From the network perspective, sessions, connections,
    and conversations only exist for the TCP protocol (at OSI Layer 5). UDP conversations
    are stateless – the network does not have a way to relate a UDP request to a UDP
    response – this all has to happen within the application. Often the application
    will include something like a session number or sequence number (or both, depending
    on the application) in the packet data to accomplish this. Keep in mind though
    that if the application does maintain a session over UDP somehow, it's the application's
    responsibility to keep it straight – there's nothing on the host or network at
    Layer 5 that will track this as we see in TCP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are troubleshooting network or application issues, this is critical information.
    If, for instance, you have an application issue that may be network related, understanding
    which ports that host listens on can be key – for instance, those ports might
    need to be configured on the host firewall or on some other in-path firewall.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the other perspective, if you are seeing firewall errors on specific ports,
    such as long-running sessions that are being terminated, for instance, then you
    need to relate the port back to the application.
  prefs: []
  type: TYPE_NORMAL
- en: For a third example, when investigating malware, you may see malware activity
    that is tied to a sending or listening port. Being able to diagnose this quickly
    can make finding other stations that might be affected by that malware much simpler.
    For instance, malware listening on a specific port can be found using Nmap or
    finding malware transmitting on a specific port can be quickly found using firewall
    logs. A great example of this would be malware exfiltrating data on DNS ports
    – in that case, you would be looking for firewall log entries for `tcp/53` or
    `udp/53`, either from internal hosts that are not DNS servers, or to external
    hosts that are not DNS servers. In most corporate environments, only DNS servers
    should be making DNS queries to specific internet DNS forwarding hosts (see [*Chapter
    6*](B16336_06_Final_NM_ePub.xhtml#_idTextAnchor100), *DNS Services on Linux*,
    for more detail on this).
  prefs: []
  type: TYPE_NORMAL
- en: In a well-run network, the internet firewall will typically have rules in both
    directions. The inbound set of rules (from the internet to the inside network)
    will describe which listening ports you might want to allow internet clients to
    connect to. This is often called an `deny all` as its last entry and with appropriate
    alerts will often alert administrators to malware, unwanted software installed
    on the desktop or server, misconfigured hosts or devices, or *I brought it from
    home* hardware that doesn't belong on the organization's network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Certificates are used to secure many services, and HTTPS (on `tcp/443`) is just
    the most popular. Certificates are also used to authenticate or secure lots of
    other services. A short list of the most commonly found ones are shown in the
    following table (there are **lots** more):![](img/B16336_Assesment_Table_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a certificate expires, in the best-case users who connect to that service
    will receive an error. Depending on their browser settings, they may not be able
    to proceed. If the connection is from a program to a service (that is, not a browser),
    the connection may just error out, depending on how the application error-handling
    and logging code was written.
  prefs: []
  type: TYPE_NORMAL
- en: All ports under `1024` are server ports, so administrative rights are needed
    in order to open a listener on any of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming a 20 GHz channel width, channels 1, 6, and 11 do not overlap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Channel width will generally improve performance, depending on what the client
    stations are attempting to do on the media. However, in the 2.4 GHz band, with
    only 11 channels available (and only 3 choices that don't create interference),
    increasing the channel width will almost certainly increase interference for most
    environments. There is a much better opportunity for wider channel use in the
    5 GHz band, because there are so many more channels available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4 – The Linux Firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, you would consider using nftables. While iptables will still be supported
    for several years, nftables is more efficient (CPU-wise), and supports IPv6\.
    It's also more flexible in "matching" traffic, allowing easier matches on individual
    fields in packets for further processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An easy method to support central firewall standards (without adding orchestration
    or configuration management tools into the mix) would be to use `nft` `include`
    files. These files can be managed in a single location, given meaningful names,
    then copied out to target servers that match the use case for each of these `include`
    files. For instance, having an `include` file for web servers, DNS hosts, or DHCP
    servers is commonly seen. Having a separate `include` file to allow host administration
    only from a small set of administrative "jump hosts," address ranges, or subnets
    is another very common use case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even without `include` files, though, orchestration tools such as Terraform,
    Ansible, Puppet, Chef, or Salt can be used to centrally manage many facets of
    Linux hosts and services, including the firewall. It's wise in this case to at
    least hardcode the access needed by the orchestration tool you are using – it's
    never fun to find out that a simple configuration typo in the orchestration tool
    has just removed all administrative access to your server farm.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 – Linux Security Standards with Real-Life Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sadly, at this time, the USA does not have any federal privacy legislation.
    Hopefully, that will change in the near future!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, the critical controls are not meant as an audit framework. However, you
    can certainly be assessed against them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For instance, in critical control 1, there is a recommendation to deploy 802.1x
    authentication for network access. This implies that your workstations and/or
    user accounts "authenticate" to the network and that the authentication process
    dictates what that station and userid combination has access to. While this isn't
    an audit item (it doesn't discuss specific settings or even specific services
    or accesses), whether you have implemented 802.1x in your infrastructure or not
    can be assessed in a larger security program or set of projects.
  prefs: []
  type: TYPE_NORMAL
- en: The first answer to this is that the first check might not be accurate, and
    a parallax view can be helpful in determining that. For instance, if a change
    is made but an operating system or application bug means that the configuration
    change isn't implemented correctly, a second tool to assess the setting can identify
    this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: More importantly, configuration changes and checks are often made locally on
    the host and need to be repeated host by host. Assessing a setting "over the wire"
    – for instance, with an Nmap scan – allows you to assess hundreds of hosts in
    just a few minutes. Not only is this a time-saver, but it's also the time-saving
    method used by auditors, penetration testers, and yes, malware.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 – DNS Services on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNSSEC implements records that allow "signing" to validate DNS response data.
    It does not encrypt either the request or the response, so it can operate using
    the standard DNS ports of `udp/53` and `tcp/53`. DoT fully encrypts DNS requests
    and responses using TLS. Because DoT is an entirely different protocol, it uses
    port `tcp/853`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DoH behaves as an API—the requests and responses are carried within HTTPS traffic
    with a specific HTTP header. A DoT `/dns-query`, and because of the HTTPS transport,
    the protocol uses only `tcp/443`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An internal DNS server would definitely implement recursion and forwarders,
    to allow the resolution of internet hosts. Usually, auto-registration is enabled,
    and requests are normally limited to "known" subnets that are within the organization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: External DNS servers for an organization's zone will normally not implement
    recursion or forwarders and will almost never implement auto-registration. Rate
    limiting of some kind is almost always implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 – DHCP Services on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, this may be a problem only for the person who called the Helpdesk. Make
    sure that this is a branch-wide issue. Make sure that the person who called is
    plugged into the network (or is associated properly if they are wireless). Make
    sure that they are not working from home; if they're not even in the office, then
    this isn't likely a problem with your server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the *Do we have a problem* questions done, see if you can reach anything
    in the remote office. If the WAN link, VPN link, router, or switches for the office
    are not all working, then DHCP won't be working either. Make sure that you can
    ping or otherwise test each of these devices before digging too deep into the
    DHCP side of things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, start by ensuring that the DHCP server is actually working. Check whether
    the service is running – note that the following `systemctl` command provides
    you with some of the recent DHCP packet information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'tail command to just pull the last few log entries. If the dates are not for
    today, note the date to see when the DHCP last assigned an address. You will likely
    have this from the systemctl output, but you can also get it from syslog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'On any Linux client, get the IP of the DHCP server. There are a few methods
    for doing this. You could check the `syslog` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or just dump the server information from the DHCP client leases file on the
    workstation (this updates as the various client interfaces renew):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can renew the lease in the foreground and get the information
    from there. Note that if you are connected to the client via SSH, your address
    may change with this method. The client will also appear to "hang" at the last
    line shown here. Keep in mind that it''s the background DHCP client process running
    in the foreground, so rather than "hung," it''s "waiting." Press *Ctrl + C* to
    exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if the remote client is Windows-based, there''s a simple command to get
    the DHCP server address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: No matter how you get the DHCP server IP address, if the IP address you get
    from your troubleshooting isn't your server, then you have a rogue DHCP problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we now have the DHCP IP address, ping it quickly from an affected host
    and then collect the MAC address of the rogue server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the OUI, get the manufacturer of the offending device. In this case, it's
    a Linksys home router. You can easily get this from the Wireshark OUI lookup site
    ([https://www.wireshark.org/tools/oui-lookup.html](https://www.wireshark.org/tools/oui-lookup.html)
    ), or, as noted in [*Chapter 2*](B16336_02_Final_NM_ePub.xhtml#_idTextAnchor035),
    *Basic Linux Network Configuration and Operations – Working with Local Interfaces*,
    I have a script hosted on GitHub ([https://github.com/robvandenbrink/ouilookup](https://github.com/robvandenbrink/ouilookup)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go to your switch (or loop your networking person in) and find out which
    switch port that host is connected to. Note that we''re just looking for the last
    part of the MAC address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you likely want to work toward shutting that port down and start
    making some phone calls. Be very sure that you are not shutting down a port that
    connects an entire switch when you do this. First check for other MAC addresses
    on that port, looking in particular at the count of MAC addresses found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, check the LLDP neighbor list for that port – it should tell you whether
    there''s a switch there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, look for CDP neighbors on that port, while also looking for a switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If there's a switch on that port, connect to that adjacent switch and repeat
    the process until you find your offending DHCP server's port.
  prefs: []
  type: TYPE_NORMAL
- en: After shutting down the offending port, your users should be able to start getting
    DHCP addresses again. Since you have the OUI of the server, your next step is
    to ask a trusted person in the office to go and look for a new box that has a
    <insert brand name here> label on it.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 – Certificate Services on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first function is the most important and is most often overlooked. A certificate
    provides trust and authentication. The fact that the hostname matches either the
    CN or SAN fields in the certificate provides the authentication needed to start
    the session. The fact that the certificate is signed by a trusted CA means that
    the authentication can be trusted by the client. This will be revisited again
    in the next chapter of this book, [*Chapter 9*](B16336_09_Final_NM_ePub.xhtml#_idTextAnchor153),
    *RADIUS Services for Linux*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second function is that the certificate material is used to provide some
    of the material for the secret key that is used in the symmetrical encryption
    of the subsequent session. Note, though, that as we progress to other use cases,
    many situations that make use of certificates do not do session encryption at
    all—the certificates are there purely for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The `PKCS#12` format, often seen with a suffix of `.pfx` or sometimes `.p12`,
    combines the public certificate of a service with its private key. This combination
    is often required for situations where the normal installation process might get
    the normally have a *let's start with a CSR* starting point, but the certificate
    is a pre-existing one, such as a wildcard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CT is key in the trust model that is needed for public CAs. Since all certificates
    are posted publicly, this means that the CT log can be audited for fraudulent
    certificates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a side benefit, it means that organizations can audit certificates issued
    to them for certificates purchased without authorization, to previously unknown
    services. This helps in curtailing the proliferation of *shadow IT*, where non-IT
    departments purchase IT services directly, outside of normal channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the CA is never consulted as certificates are used after they are issued,
    there are several reasons for maintaining the details of issued certificates,
    outlined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most important reason is *trust*. Keeping a register of issued certificates
    means that this list can be audited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second reason is also *trust*. Keeping a log of issued certificates means
    that when the time comes that you need to revoke one or more certificates, you
    are able to identify them by their name in the `index.txt` file, and then revoke
    those certificates by using their serial number (which matches their filename).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, when operating an internal CA and server infrastructure, you'll often
    reach a point when troubleshooting when you'll say *it's almost as though that
    certificate came from somewhere else*—for instance, it could be self-signed or
    might have been issued by another CA. While you can get that information from
    the certificate itself, the index on the private CA gives you the tools needed
    to check which certificates were issued and when, by another method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, if an attacker stands up a malicious CA with the same name as
    yours, this gives you a quick check without verifying keys and signatures, using
    `openssl` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Or worse still, if that attacker has built that malicious CA using stolen (and
    valid) key material from your actual server, the index file on the real CA will
    be your only clue to lead you toward that final diagnosis.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 – RADIUS Services for Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using an `unlang` rule that references both the authentication request and
    backend group membership is the classic solution to this. The rule should specify
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are making a VPN request, then you need to be in the `VPN users` group
    to authenticate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are making an administrative access request, then you need to be in a
    `network admins` group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This approach can be extended to include any number of authentication types,
    device types, RADIUS attribute values, and group memberships.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An example `unlang` rule that delivers the requested functions might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several reasons for this, and these are outlined here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since it uses certificates, and usually a local certificate store, the entire
    trust model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because it uses TLS—if implemented correctly, then attacks against the encryption
    of the authentication exchange are a significant challenge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each wireless user has their own session keys that rotate frequently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are no passwords for an attacker to capture or exploit. All other wireless
    authentication and encryption mechanisms use either a user ID/password (PEAP,
    for instance) or a pre-shared key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The obstacle in deploying EAP-TLS is in the preparation—notably, issuing and
    installing certificates on the RADIUS servers and, particularly, the endpoint
    clients. This is very doable in a typical organization, where the stations are
    owned by the company, or you can walk your people through installing certificates
    on any authorized gear that they own. In addition, **mobile device management**
    (**MDM**) platforms can be used to issue and install certificates on cellphones
    and tablets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, if a device is not owned by the company—for instance, if the device
    is a consultant's or vendor's laptop or a home computer that is owned by an employee,
    getting a company certificate issued and installed securely on that machine can
    be a real challenge. In particular, it becomes common to see **certificate signing
    requests** (**CSRs**) and certificates being sent back and forth over email, which
    isn't recommended for transporting sensitive data of this type.
  prefs: []
  type: TYPE_NORMAL
- en: MFA solutions leave the user ID-password interface in place for things such
    as VPN services but remove the risk of things such as password-stuffing or brute-force
    attacks from those interfaces. In addition, enrollment of remote stations in a
    system such as Google Authenticator is extremely simple—simply scanning the QR
    code that you are issued does the job!
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 – Load Balancer Services for Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are in a situation where your total load might be reaching the capacity
    of the load balancer, a DSR solution means that only the client to server traffic
    needs to be routed through the load balancer. This is especially impactful as
    most workloads have much more return traffic (server to client) than send traffic
    (from client to server). This means that changing to a DSR solution can easily
    reduce the traffic through the load balancer by 90%.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This performance is less of a consideration if smaller load balancers are matched
    1:1 with each discrete workload that needs to be balanced. Especially in a virtualized
    environment, adding CPU and memory resources to a VM-based load balancer is also
    much simpler than the matching hardware upgrade might be in a legacy, hardware-based
    appliance situation.
  prefs: []
  type: TYPE_NORMAL
- en: A DSR load balancer also needs a fair bit of server and network "tinkering"
    to make all the pieces work. Once it works, figuring it all out again a year later
    when it's time to troubleshoot it can be a real issue as well.
  prefs: []
  type: TYPE_NORMAL
- en: DSR solutions also lose a fair bit of intelligence on the traffic between the
    clients and servers, as only half of the conversation is seen.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason you would use a proxy-based load balancer is to allow for session
    persistence in HTTPS settings. This works by terminating the client sessions on
    the frontend **Virtual IP** (**VIP**), then starting a new HTTPS session on the
    backend interface. This approach allows the load balancer to insert a cookie into
    the session on the client side of this equation. When the client sends the next
    request (which will include this cookie), the load balancer then directs the session
    to the server that this client HTTPS session is assigned to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11 – Packet Capture and Analysis in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You would capture from an intermediate device for a few reasons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You don't have access to the hosts at either end or don't have permission to
    capture packets on them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't have access to a switch port that would allow you to use a host and
    Wireshark, either because you're not on-premises or don't have switch access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the intermediate device is a firewall, capturing from there will allow you
    to account for NAT (capturing before and after translation), as well as any ACLs
    on the firewall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would capture from a host at either end if you are troubleshooting host
    services and have access to either host, and have permission to install a packet
    capture tool on one or both. In addition, capturing from either end may allow
    you to capture encrypted traffic before or after decryption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing using a SPAN port is the go-to solution in almost all cases. This
    allows you to capture traffic in either direction, but does not require access
    to or permission to change either endpoint host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tcpdump is the underlying packet capture mechanism on Linux. Almost all tools,
    including Wireshark use tcpdump. Wireshark has the advantage of giving the operator
    a GUI to work from, which is very attractive if that person isn't a "CLI person."
    In addition, Wireshark will fully decode packets and allow you to interactively
    drill down to your target traffic using display filters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TCPdump, on the other hand, has the advantage that it will run anywhere, which
    is very attractive if the capture session is being run over an SSH session, or
    if the host doing the capture has no GUI running. TCPdump also gives you more
    control over lower-level functions that will affect the performance or capacity
    of the capture. For instance, the size of the ring buffer can easily be modified
    from the `tcpdump` command line.
  prefs: []
  type: TYPE_NORMAL
- en: The RTP protocol's ports will be different from one call to the next. They are
    always UDP, but the port numbers for a session's RTP call are negotiated during
    the call's setup, but SIP/SDP, specifically by the `INVITE` packets (one from
    each endpoint in the call).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12 – Network Monitoring Using Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write access for SNMP allows you to monitor (read) device or host parameters,
    as well as set (write) those same parameters. So, with read-write access, you
    could change the interface speed or duplex, reboot or shut down a device, or download
    a configuration. There is a nmap script that makes such a configuration download
    simple: `snmp-ios-config.nse`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Syslog is most often sent in clear text over `514/udp`. There is an option to
    encrypt this traffic using IPSEC, but it is not widely implemented. The risks
    are that sensitive information is sent using syslog, and as it's clear text, anyone
    in a position to read it can either collect that information for later use or
    modify it as it is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For instance, it's fairly common to have an administrator put their password
    in the `userid` field, which means that the password is possibly compromised at
    that point. The next step that person usually takes is to try again, correctly,
    which means that the attacker now has both the userid and the password. You want
    to log this information though, to help detect malicious login attempts.
  prefs: []
  type: TYPE_NORMAL
- en: One option is to enable SNMPv3 and use SNMPv3 traps for logging instead of Syslog.
    This does, however, move your logging platform to one that is usually less flexible
    and often more difficult to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable SNMPv3 traps on a Cisco IOS device, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Your SNMP trap server must have matching account information and encryption
    options. If you are going this far, you must also hardcode host information for
    each device sending traps as well.
  prefs: []
  type: TYPE_NORMAL
- en: NetFlow collects and aggregates summary information for network traffic. At
    a minimum, this includes the "tuple" of Source IP, Destination IP, Protocol, Source
    Port Number, and Destination Port Number. Times are added for analytics, usually
    by the collecting server, so that flows from multiple servers can be combined
    and correlated without the need to worry about clock drift between the various
    networking devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All that being said, the information that is sent is not usually sensitive –
    essentially, it's the source and destination IP addresses and a guess at the application
    in use (usually derived from the destination port). Most organizations would not
    consider this sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: However, if your organization does consider this a risk, it's easy enough to
    direct this data back to the collection server over an IPSEC tunnel. The architecture
    of this might be somewhat tricky as you may have to maintain two routing **Virtual
    Routing Frameworks** (**VRFs**) to do this, but it is certainly doable. It might
    be simpler to just encrypt all WAN traffic, then apply layer 2 protections between
    the core router and the NetFlow collection server (assuming that they are on the
    same subnet).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13 – Intrusion Prevention Systems on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zeek would be your tool of choice. As we saw in the Zeek example, drilling down
    through all traffic in a specific time window to a specific TLS version is very
    quick. Adding geolocation information partway through the search just takes a
    few mouse clicks. The source and destination IP addresses are summarized for you
    as you narrow your search down, so no additional action is required to collect
    that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SSH clients, when used, generate traffic. A tool such as P0F (or a commercial
    tool such as Teneble PVS) can passively collect all traffic, and then associate
    this traffic with the client workstations. By using algorithms such as JA3 or
    HASSH, passively collected data can often tell you about the client application,
    very often right down to its version. This allows you to target out-of-date clients
    for software upgrades.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PuTTY is a good example of this, since this application often isn't installed
    using a full MSI-based Windows installer. This means that it typically isn't easy
    to inventory using PowerShell or commercial inventory tools.
  prefs: []
  type: TYPE_NORMAL
- en: The downfall of this method is that you can only inventory the target applications
    when they are in use. Identifying hardware clients – for instance, unsanctioned
    **Internet of Things** (**IoT**) devices – is particularly effective since these
    devices tend to reach out to their various cloud services very frequently.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, intentionally placing an IPS on the public internet side of a
    firewall isn't productive these days, given the hostile nature of that network
    – it will simply alert continuously, which makes for just too much "noise" to
    filter through.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Placing an IPS to primarily catch outbound traffic or inbound traffic that makes
    it past the firewall narrows down the assessed traffic considerably to potential
    attack traffic (inbound) and traffic that may indicate internal hosts being compromised
    (outbound). This placement usually amounts to being on a SPAN port, monitoring
    the inside and DMZ interfaces of the firewall. This may be expanded to additional
    ports or entire VLANs (reference the section on SPAN ports in [*Chapter 11*](B16336_11_Final_NM_ePub.xhtml#_idTextAnchor192),
    *Packet Capture and Analysis in Linux*).
  prefs: []
  type: TYPE_NORMAL
- en: Placing an IPS in such a way that it can inspect decrypted traffic allows it
    to assess otherwise "invisible" payloads; for instance, in RDP, SSH, or HTTPS
    traffic. In modern architectures, this often means that the IPS is actually on
    the firewall itself, often dubbed a **Unified Threat Management** (**UTM**) firewall
    or **next-generation firewall** (**NGFW**).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14 – Honeypot Services on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Honeypots are deployed to catch attacker traffic "on film." Especially on internal
    networks, their primary goal is to keep the attacker engaged on the honeypot host
    for long enough that you can mount some defenses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lighting up an unexpected combination of ports on one host is a dead giveaway
    to your attacker that the target is a honeypot. Not only will they skip that host,
    but they'll proceed with additional caution, knowing that you have honeypots deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'An AD domain controller typically has many of these ports enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B16336_Assesment_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This list isn't complete and focuses on TCP ports. An attacker will often skip
    scanning UDP ports entirely, especially if the profile of open TCP ports is enough
    to identify target hosts.
  prefs: []
  type: TYPE_NORMAL
- en: On the internet, the exception will be scans for `500/udp` and `4500/udp`, which
    usually indicate open VPN endpoints.
  prefs: []
  type: TYPE_NORMAL
