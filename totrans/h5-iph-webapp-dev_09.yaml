- en: Chapter 9. Principles of Clean and Optimized Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, we have stressed the importance of optimizing from the
    very start of our application development. Although we have looked at topics from
    caching elements in JavaScript to modularizing our styles, in this chapter we
    want to summarize the techniques used in the book. After all, performance is highly
    important in our mobile applications for several reasons. In this chapter, we
    will cover optimizing our styles, scripts, and media. In addition to covering
    optimization techniques, we'll go over good coding standards that enhance the
    maintainability of your codebase while also enhancing performance at the same
    time. We'll start out by discussing stylesheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing stylesheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, styles have been "plopped" onto web applications without any
    forethought. Usually, we would just style our pages without any thought to modularity,
    reusability, and maintainability. However, this is no longer acceptable due to
    the extensive nature of web applications today.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we have strived to adhere to a couple of industry standards, such
    as modularity. However, we do have tools now that can help us validate and profile
    our styles. Starting with an analysis of a sample CSS file, we can then optimize
    those styles; this is what we aim to do in this section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Validating our CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to optimize our stylesheets, we need to first verify that our CSS is
    valid and compliant with today's standards. We can use various tools out there
    to validate our styles, including the W3C CSS Validator and a tool called **CSS
    Lint**. Both these tools check your stylesheets and give you a summary of what
    is wrong, why it is wrong, and what you should do about it.
  prefs: []
  type: TYPE_NORMAL
- en: W3C CSS Validator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To access the W3C CSS Validator, you can visit the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://jigsaw.w3.org/css-validator/](http://jigsaw.w3.org/css-validator/)'
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot displays the W3C validator default view, which allows
    you to enter in the URI of the page containing styles. It will automatically pick
    up your stylesheets and validate them according to the W3C specification. However,
    we are not limited only to having our page crawlable on a live or production-ready
    site. We also have the option of uploading our stylesheets, or putting them directly
    into this application.
  prefs: []
  type: TYPE_NORMAL
- en: '![W3C CSS Validator](img/1024OT_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The W3C CSS Validator – URI view
  prefs: []
  type: TYPE_NORMAL
- en: In the following view, you can see that we can validate the styles through a
    file upload process. This will simply run those stylesheets through a processor
    at the backend to check if the styles are valid; once this process is done, we
    get our results.
  prefs: []
  type: TYPE_NORMAL
- en: '![W3C CSS Validator](img/1024OT_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The W3C CSS Validator – file upload view
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have the option to directly insert our styles into the tool, perhaps
    the fastest and easiest solution depending on the project and needs of the team
    or individual. We don't have to worry about styles being stripped or modified
    in any way; the text field will handle all your input correctly. Again, similar
    to the other views, the input will run through a processor and present to you
    the results once the **Check** button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: '![W3C CSS Validator](img/1024OT_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The W3C CSS Validator – direct input view
  prefs: []
  type: TYPE_NORMAL
- en: Customizable options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with any good-quality assurance tool, we need to have the ability to customize
    the options of this tool to fit our needs. In this case, we have various options
    that are available to us, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Profile**: This option specifies the profile to be used when validating styles,
    for example, CSS Level 1, CSS Level 2, CSS Level 3, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warnings**: This option specifies the warning to be presented in the report,
    for example, Normal, Most Important, No Warnings, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Medium**: This option specifies the medium the stylesheets are supposed to
    represent, for example, Screen, Print, Handheld, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vendor Extensions**: This option specifies the way vendor extensions (`-webkit-`,
    `-moz-`, `-o-`) are to be handled in the report, for example, Warnings or Errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating a successful example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's take a look at a successful validation example. First, let's use some
    styles we created in a previous chapter to see if the CSS passes validation; in
    particular, let's use the `singlepage.css` file contents and paste it into the
    direct input view of the W3C validator and run it with the default options.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the validator, our result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating a successful example](img/1024OT_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The W3C CSS Validator – successful validation
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the output is successful and passes the CSS Level 3 specification.
    It's so amazing that we even get badges from the validator to put on our site!
    But don't do that; even though you should give yourself a pat on the back, this
    is something that most of us don't really like on our sites. Now let's look at
    an unsuccessful example.
  prefs: []
  type: TYPE_NORMAL
- en: Validating an unsuccessful example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Errors happen all the time in programming, and so it''s only natural for us
    to encounter validation errors in our styling, scripts, and markup. So, let''s
    take a look at what an example of validation errors in the W3C CSS Validator looks
    like. For this example, we''ll use a variation of the `video.css` file we created
    in [Chapter 2](ch02.html "Chapter 2. Integrating HTML5 Video"), *Integrating HTML5
    Video*. For the purpose of this example, I''ve introduced several mistakes with
    the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we pass the preceding styles through the W3C CSS Validator, we get the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating an unsuccessful example](img/1024OT_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The W3C CSS Validator – unsuccessful validaton
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example we're getting a couple of value, property, and parse
    errors, all of which can be easily solved by the references given in this unsuccessful
    validation example. What's great about this is that instead of trying to figure
    out what might be breaking your layout, a simple fix on the errors shown in the
    screenshot might solve all your problems.
  prefs: []
  type: TYPE_NORMAL
- en: In a sense this is basically all you need to make sure that your CSS is valid
    and compliant across several browsers. However, what if you could prevent these
    errors from happening? Well, there's a tool for that, CSS Lint.
  prefs: []
  type: TYPE_NORMAL
- en: CSS Lint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most cases, we want to avoid having errors all together when we code, and
    it would be helpful to catch these early on with a tool of some sort. CSS Lint
    is that tool, and in fact can be used right inside the text editor or IDE of your
    choice. CSS Lint not only checks your styling against certain principles of CSS
    (such as the box model), but also does a lot of the syntax checking, helping you
    debug your styles effectively.
  prefs: []
  type: TYPE_NORMAL
- en: CSS Lint points out problems with your CSS code. It does basic syntax checking
    as well as applying a set of rules to the code that look for problematic patterns
    or signs of inefficiency. The rules are all pluggable, so you can easily write
    your own or omit ones you don't want.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The details regarding CSS Lint can be found at [https://github.com/stubbornella/csslint/wiki/About](https://github.com/stubbornella/csslint/wiki/About).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the W3C CSS Validator, CSS Lint has its own site where you can copy
    and paste your styles into a text area and have the processor checkout your styling.
    The page in which we interact with looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CSS Lint](img/1024OT_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: CSS Lint
  prefs: []
  type: TYPE_NORMAL
- en: Customizable options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSS Lint also comes with customizable options, which are extensive, that you
    can customize to fit you or your team's needs. There are six sections of customizable
    options, including **Errors**, **Maintainability & Duplication**, **Compatibility**,
    **Accessibility**, **Performance**, and **OOCSS** (**Object Oriented CSS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The customizable options are located right below the **Lint!** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizable options](img/1024OT_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: CSS Lint options
  prefs: []
  type: TYPE_NORMAL
- en: Checking the appropriate options enables the engine to validate against those
    properties. Usually these options vary between projects; for example, you may
    be working on an application that requires padding and width to be set on certain
    elements and thus, unchecking the **Beware of broken box sizing** option may be
    more suitable for you, so that you are not presented with multiple errors.
  prefs: []
  type: TYPE_NORMAL
- en: Validating a successful example using CSS Lint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we customize our options and pass the page through CSS Lint with proper
    stylesheets that meet standards while also catering to the team''s needs, we should
    receive a successful validation, such as the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating a successful example using CSS Lint](img/1024OT_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: CSS Lint – successful validation
  prefs: []
  type: TYPE_NORMAL
- en: In the above case, our CSS styles pass and no additional information is needed.
    However, what happens when our CSS does not pass validation?
  prefs: []
  type: TYPE_NORMAL
- en: Validating an unsuccessful example using CSS Lint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we take the alternative video styles we created in the previous section
    for the W3C CSS Validator and pass them through CSS Lint, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating an unsuccessful example using CSS Lint](img/1024OT_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: CSS Lint – unsuccessful validation
  prefs: []
  type: TYPE_NORMAL
- en: 'However, just because we received four errors and two warnings does not mean
    we are helpless. In fact, when we scroll down the page, we will see a list of
    items that need to be taken care of; it also includes the type of problem, description,
    and line that the error occurs on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating an unsuccessful example using CSS Lint](img/1024OT_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: CSS Lint – unsuccessful validation listing
  prefs: []
  type: TYPE_NORMAL
- en: Integrating CSS Lint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although we have a **graphical user interface** (**GUI**) that we can use to
    validate our styles, it would be easier if we could streamline the process with
    our personal development workflow. For example, it would be great if our CSS could
    be validated as we saved our stylesheet in our text editor or **integrated development
    environment** (**IDE**). CSS Lint is very extensible, allowing us to achieve these
    integrated workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some IDEs and text editor vendors have already implemented CSS Lint, including
    Sublime Text, Cloud 9, Microsoft Visual Studio, and Eclipse Orion. Although the
    installation and setup of CSS Lint into your preferred tool is out of the scope
    of this book, you can look up all the information needed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/stubbornella/csslint/wiki/IDE-integration](https://github.com/stubbornella/csslint/wiki/IDE-integration)'
  prefs: []
  type: TYPE_NORMAL
- en: Profiling our CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously it was extremely difficult to profile any of your CSS, in fact probably
    impossible. But with the advancements that have taken place in browser debugging
    tools, we are now able to profile stylesheets to some degree. In this section,
    we review how to take profiles of our styles and read the information presented
    to us in the Safari browser on Mac.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming screens, we will briefly go over how profiling can be used for
    styles and how the Safari browser presents this information to us. We will only
    look at layout and rendering of our styles. Using the single-page application
    we built previously, we will look at the effectiveness of our styles and see the
    weaknesses and strengths of our styling in how it relates to the presentation
    layer of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by looking at the dashboard view of our single-page application
    with the Safari debugging tools opened and on the profile tab (clock symbol).
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling our CSS](img/1024OT_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Safari profiling tool
  prefs: []
  type: TYPE_NORMAL
- en: When we first load up our single-page application and view the profiling of
    the page load, we see three different timelines, including **Network requests**,
    **Layout & Rendering**, and **JavaScript & Events**. For our purposes, let's look
    at **Layout & Rendering**.
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the **Layout & Rendering** timeline, we can see where repaints
    and restyle calculations were made on page load. The debugger also lets us know
    what type of process was run, when it was run, and the properties that were changed,
    including its start time and duration. This is all extremely helpful when looking
    for performance leaks on our page. But, what about runtime profiling? Well, the
    debugger has that to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, in our left-hand side bar there is a circle on the same line as the
    **Profiles** tab that allows us to profile either our JavaScript or CSS. This
    is great because when we enable this, we''ll start profiling the application at
    run time. So, let''s say we enable the profiling of our CSS and then, within our
    application, click on the **Profile** tab to switch page views; we''ll definitely
    execute some changes in the view that would make our styles change. When we do
    this and stop our CSS profiling, we get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling our CSS](img/1024OT_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Safari profiling tool – runtime profiling
  prefs: []
  type: TYPE_NORMAL
- en: When we analyze our profile we see the selectors that are being utilized, the
    total time for it to render, the number of matches on the page, and its source.
    This is a great breakdown of what sort of processing took place and gives us a
    good idea of the amount of time each selector takes to find and render, giving
    us a good idea of what can be improved. Given, our application for this book is
    small, but if you were working on an application that included complex animations
    or the rendering of thousands of rows of data, this would come in useful in debugging
    your mobile application.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a good idea of what is bottlenecking our application, we need to
    do something about it. Having this information gives us critical information on
    the performance of our application and what we should focus on. The optimization
    phase is based on the problem(s) and needs of the project each team or individual
    faces, so in the next section we discuss some optimization techniques that can
    be used for faster rendering and matching of our styles.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing our CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we briefly go over some industry standards that help us optimize
    our applications rendering time by providing modular styles that are efficient,
    maintainable, and well crafted. These standards have been widely discussed by
    individuals and organizations well known in the industry and have ultimately been
    adopted in various frameworks. Of course, the standards discussed here may change
    as time progresses and browsers implement better processing methods that make
    new techniques faster and more efficient, but this should be a good starting guide
    for anyone looking to create stylesheets that meet today's demands.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid universal rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not use the `*` selector in your rules. These select every element in the
    DOM and thus their traversal method is inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is extremely inefficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is inefficient for one reason, it is using a universal selector.
    Because CSS reads from right to left, the engine is saying "let''s pick up all
    elements and then see if they are immediately related to the header element."
    Because we need to traverse the entire DOM, the rendering of this selector is
    extremely slower than something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Don't qualify ID or Class rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qualifying an ID or Class involves directly attaching the tag name with the
    appropriate selector, but is extremely inefficient for the same reasons as the
    previous rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, all of the following selectors are bad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Although some of these may seem tempting, they are unnecessary and inefficient.
    However, there is an exception here; if we want to change the style by adding
    a class to an element, then qualifying a class might be necessary. Either way,
    we could do the following to correct the preceding qualifying ID or classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As it was mentioned in the preceding paragraph, the last selector might be more
    useful when changing the styles of an element based on a user action via JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Never use !important
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This rule is pretty self-explanatory. It is definitely tempting to use this
    to override styles, but don't; it will only cause headaches as your application(s)
    become more extensive. For this reason, check out the next rule.
  prefs: []
  type: TYPE_NORMAL
- en: Modularize styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s very easy to create styles that are generic to a web application or website;
    however, if we start thinking in terms of modularity, we start creating styles
    that are reserved for a part of that application. For example, take a form and
    its inputs, and let''s say we wanted all forms on a site to contain text fields
    with a brown border. We could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have reserved all fields with the class `.text-field` inside a `form`
    element to contain this style. So if any input fields with the class `.text-field`
    are outside this selector, we can then style them any way we want. Or on the other
    hand we could override the style like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we include this style after the original one, it would take precedence
    because we are actually using cascading principles that make our styling more
    efficient and manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that descendant selectors are the most expensive kind of selector.
    However they are extremely versatile, and therefore we should not sacrifice maintainability
    or semantics for efficient CSS.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, these rules should be enough, but you will most likely find it
    useful to implement some of the other best practices that have been written about
    in the industry. Of course, you should work with the practices that have been
    adopted for the framework you use, or better yet, fit your team. I have found
    these to be extremely helpful and a great starting point, and I encourage you
    to research and experiment as you see fit. Now, let's take a look at how JavaScript
    could be optimized for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered the optimization of stylesheets, let's look at our
    scripts. JavaScript has also had a history of being dropped onto the page without
    any forethought or planning, and in general has led to bad reputation for the
    language. But again, because of the complex nature of web applications, the open
    source community has helped shape the language.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, we have adopted several industry standards, including namespaces,
    closures, caching variables, and so on. However, it is also essential we validate
    and profile our scripts so they can be optimized. In this section, we will go
    through this and hopefully cover the major points needed to make high-performance
    mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Validating JavaScript using JSLint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In recent years, various tools have come out to help us validate our JavaScript.
    Tools such as JSLint and JSHint have been created to help us as we code, similar
    to CSS Lint. But why should we use these tools, especially for JavaScript? JSLint''s
    site ([http://www.jslint.com/lint.html](http://www.jslint.com/lint.html)) mentions
    the reasoning behind the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript is a young-for-its-age language. It was originally intended to do
    small tasks in webpages, tasks for which Java was too heavy and clumsy. But JavaScript
    is a surprisingly capable language, and it is now being used in larger projects.
    Many of the features that were intended to make the language easy to use are troublesome
    when projects become complicated. A lint for JavaScript is needed: JSLint, a JavaScript
    syntax checker and validator.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'JSLint''s website also mentions the following:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a sloppy language, but inside it there is an elegant, better language.
    JSLint helps you to program in that better language and to avoid most of the slop.
    JSLint will reject programs that browsers will accept because JSLint is concerned
    with the quality of your code and browsers are not. You should accept all of JSLint's
    advice.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To test out our JavaScript, we can easily visit JSLint''s website ([http://www.jslint.com/](http://www.jslint.com/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating JavaScript using JSLint](img/1024OT_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The JSLint website
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, JSLint is very similar to CSS Lint, in such a way that all you
    really need to do is input your JavaScript onto the page and the results will
    be displayed to you. So let's check out what a successful and an unsuccessful
    output would look like.
  prefs: []
  type: TYPE_NORMAL
- en: Validating a successful example using JSLint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our example, we will utilize our `App.js` JavaScript to test out with the
    JSLint utility. When we run this file, a successful output will detail out the
    methods, variables, and properties used throughout the closure. Let''s look at
    the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating a successful example using JSLint](img/1024OT_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Successful validation using JSLint – methods and variables
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example is the top view of a successful validation using JSLint.
    The validator will return to us a list beginning with a listing of all global
    objects. It will then continue on with a listing of the methods, variables, and
    some detail about each. For example, `initVideo` returns `this` or an instance
    of `App` and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating a successful example using JSLint](img/1024OT_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Successful validation using JSLint – properties
  prefs: []
  type: TYPE_NORMAL
- en: Validating an unsuccessful example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Taking the same example as the previous one without modifying the JSLint options
    would produce several errors. These errors are mostly whitespace, spacing, and
    global objects that the processor is not aware of.
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating an unsuccessful example](img/1024OT_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JSLint – unsuccessful validation
  prefs: []
  type: TYPE_NORMAL
- en: Based on the preceding output, the errors are listed in red with a description,
    sample code, and line number of where the error occurs, allowing you to easily
    debug your application. Now, let's say we didn't want whitespace or spacing to
    actually affect the outcome of our validation; then we could customize the options
    for JSLint.
  prefs: []
  type: TYPE_NORMAL
- en: Customizable options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with most of the tools we are discussing in this chapter, JSLint also comes
    packaged with options that can be customized to fit our needs. Let's briefly review
    some of the options that are available to us via the website.
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizable options](img/1024OT_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JSLint – the Options screen
  prefs: []
  type: TYPE_NORMAL
- en: The options that are available to us are extensive, from whitespace formatting
    to the correctness of the toleration of `TODO` comments that we all put in our
    JavaScript. Of course, some of these options may not fit our needs at the time
    of testing, but in general, they are very helpful in keeping with a consistent
    coding standard that delivers cross-platform valid scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating JSLint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to CSS Lint, JSLint can be used in your IDE or text editor—whichever
    environment you prefer. Many vendors have already created plugins or extensions
    to these tools to allow you to easily lint your code as you type or save. For
    example, Sublime Text has a `SublimeLinter` package that comes with CSS Lint,
    JSLint, and also some other tools that can help you code more efficiently. How
    is this possible?
  prefs: []
  type: TYPE_NORMAL
- en: '*JSLint can be run anywhere that JavaScript (or Java) can run. See for example*
    [https://github.com/douglascrockford/JSLint/wiki/JSLINT](https://github.com/douglascrockford/JSLint/wiki/JSLINT).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/douglascrockford/JSLint](https://github.com/douglascrockford/JSLint)'
  prefs: []
  type: TYPE_NORMAL
- en: In its essence, JSLint is a JavaScript method that can be passed in code and
    is then evaluated by JavaScript itself, making it extremely efficient to process
    your code and to integrate into other environments. So if it doesn't already exist
    for your text editor or IDE, you can easily create an extension that helps you
    code with quality using JSLint.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling our JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with CSS profiling, testing the performance of your JavaScript was extremely
    hard in the old days of the Web. However, we don't really need to worry about
    it too much these days, since almost every browser debugger has implemented a
    way to profile your scripts. Using Safari's built-in debugging tool, we'll check
    out how to debug our application's script performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, we will just go over the profiling of the JavaScript
    on the single-page application we built previously, similar to what we did for
    the profiling of our styles in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling our JavaScript](img/1024OT_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Safari profiling tool – JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot is a review of the scripts on page load. When we review
    the **JavaScript & Events** timeline, we are given a breakdown of the type, details,
    location, start time, and duration of each script, contributing to the scripts
    timeline outcome. Although the start time is something which we definitely want
    to know in order to see what might be blocking scripts (other scripts), duration
    is probably even more important because each script can block the process of page
    rendering if it is not brought in asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: On top of viewing the performance of the page-load impact from scripts, we can
    also profile the functionality that our scripts perform. For example, let's say
    we wanted to detect how our methods are performing when we click on the **Profile**
    button within our application. Well this can be easily accomplished using the
    same technique as profiling your CSS, by clicking the circle in the **Profile**
    tab and enabling profiling for our JavaScript; we will be able to see all the
    methods called and their performance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling our JavaScript](img/1024OT_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Safari profiling tool – JavaScript runtime
  prefs: []
  type: TYPE_NORMAL
- en: Based on our preceding use case, we can detail out the performance of our application
    pretty easily. From what we can gather in this example, our `onProfileClick` event
    takes about 8.40 ms to execute, and is called once. However, the larger picture
    is that we can see all the methods being called and the order of this execution—great
    information that can be used to help detect memory leaks and performance optimization
    that is necessary for our application.
  prefs: []
  type: TYPE_NORMAL
- en: You can see from these very basic examples that debugging our application for
    performance is easier than ever before. We can profile our JavaScript, find out
    how our application is working, and the efficiency of our code. But now that we
    have this information, what can we do to improve our codebase? Well this is what
    we tackle in the next section, general optimization tips that we can all use to
    make our application perform better without sacrificing code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing our JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript is highly extensible, allowing us to do almost anything we want—which
    is great, but can also be extremely harmful. For example, you can easily forget
    about using the keyword `var` in front of your variables. However, we don't want
    to do this because it will make our variables available at the global scope, which
    may cause conflicts with other scripts that might use that exact same variable
    name. We can also easily wrap our JavaScript in a `try...catch` statement, not
    exactly the best practice because we're not figuring out what the problem is.
    Or if we wanted to, we could `eval` or evaluate a string of JavaScript pretty
    easily without any error checking.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the industry has adopted multiple best practices that are true
    and tested, implemented by the most used open source libraries out there, including
    jQuery, Backbone, and Underscore. In this section, we briefly go over the practices
    I have based the book on and those I believe are critical to the success of any
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid globals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is extremely easy and tempting to create all your variables and functions
    in the global scope, or outside of the closures we created in our applications.
    But don't do that; it's a terrible idea and looked down upon in the community
    for several reasons. For example, if a variable is kept in the global scope, it
    must be maintained during the entire execution of your application, decreasing
    the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So instead of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding technique is very similar to what we have been doing all along.
    In fact, this is what we called closures or **immediately invoked function expression**
    (**IIFE**). When we wrap a method inside the parenthesis and then invoke it using
    `()`, we are calling that method immediately and creating a new containing scope,
    so anything inside those parenthesis is not available at the global scope, making
    our code a bit more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Leave the DOM alone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well, we probably won't be doing that, but we should definitely keep it to a
    minimum. Accessing the DOM is expensive and is an issue when it comes to application
    performance. So let's take a use case, such as updating a list of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoid doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you should do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the two is that the former touches the DOM each time
    we create a list item, while the latter pushes each item to an array, and when
    it comes to appending, joins the array with an empty string, touching the DOM
    only once.
  prefs: []
  type: TYPE_NORMAL
- en: Use literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This can be seen throughout our entire codebase for this book. This is more
    efficient since we don''t use the `new` keyword. For example, instead of declaring
    a new variable via the new keyword, we just use the `Array` literal, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Modularize functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To keep code modular, you want to make sure that each function or class has
    a specific set of functionality it is supposed to achieve. Most of the time, each
    function should probably be about 10 to 15 lines of code that achieves a certain
    goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you may write the following bit of functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of writing the preceding code, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code has been modularized to do specific sets of functionality,
    allowing us to create methods that run a specific set of instructions that each
    method, by name, describes. This is great for maintaining our codebase while delivering
    effective functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have considered performance optimization for various parts
    of our applications, including styles, scripts, and media. We went over validating,
    optimizing, and profiling our styles and scripts. In addition, we briefly covered
    how we can optimize our media, including images, audio, and video. Now that we
    have firm understanding of the techniques used throughout the book to optimize
    our applications, in the next chapter, we will take a look at frameworks that
    can help us deliver native applications using HTML5, CSS3, and JavaScript.
  prefs: []
  type: TYPE_NORMAL
