- en: Using PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PLINQ** is a parallel implementation of the **Language Integrate Query**
    (**LINQ**). PLINQ was first introduced in .NET Framework 4.0 and since then has
    been made feature-rich. Before LINQ, it was difficult for developers to fetch
    data from various data sources such as XML or databases as each source required
    different skills. LINQ is a language syntax that relies on .NET delegates and
    built-in methods to query or modify data without having to worry about learning
    low-level tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by understanding the LINQ providers in .NET.
    With PLINQ being the preferred choice for programmers, we will cover its various
    programming aspects, along with some disadvantages associated with it. Finally,
    we will understand the factors that affect the performance of PLINQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: LINQ providers in .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing PLINQ queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserving order in PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge options in PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions in PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining parallel and sequential queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PLINQ disadvantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speedups in PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you should have a good understanding of TPL and C#.
    The source code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: LINQ providers in .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LINQ is a set of APIs that help us work with XML, objects, and databases more
    easily. LINQ has many providers, including the following, all of which are commonly
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: LINQ to objects: LINQ to objects allows developers to query in-memory objects such as
    arrays, collections, generic types, and so on. It returns an `IEnumerable` and
    supports features such as sorting, filtering, grouping, ordering, and aggregate
    functions. Its functionality is defined in the `System.Linq` namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LINQ to XML: LINQ to XML, or XLINQ, allows developers to query or modify XML
    data sources. It's defined in the `System.Xml.Linq` namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LINQ to ADO.NET: LINQ to ADO.NET is not one but a group of technologies that
    allows developers to query or modify relational data sources such as the SQL Server,
    MySQL, or Oracle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LINQ to SQL: This is also known as DLINQ. DLINQ uses **Object Relational** **Mapping** (**ORM**)
    and is a legacy technology that is supported but not enhanced by Microsoft. It
    works only with the SQL Server and allows users to map database tables to .NET
    classes. It also has an adapter that works like a developer interface to a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LINQ to datasets: This allows developers to query or modify datasets in memory.
    It works with any database that ADO.NET has a provider for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LINQ to entities: This is the most advanced and sought-after technology. It
    allows developers to work with any relational database, including SQL Server,
    Oracle, IBM Db2, and MySQL. LINQ to entities also supports ORM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PLINQ: This is also known as PLINQ. PLINQ is a parallel implementation of LINQ
    for objects. LINQ queries execute sequentially and can be really slow for heavy
    computing operations. PLINQ supports the parallel execution of queries by having
    a task scheduled to be run on multiple threads and optionally on multiple cores
    as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET supports the seamless conversion of LINQ to PLINQ using the `AsParallel()` method.
    PLINQ is a very good choice for computing heavy operations. It works by portioning
    the source data into chunks, which are, in turn, executed by different threads
    running on multiple cores. PLINQ also supports XLINQ and LINQ to objects.
  prefs: []
  type: TYPE_NORMAL
- en: Writing PLINQ queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand PLINQ queries, we need to understand the `ParallelEnumerable`
    class first. Once we have an understanding of the `ParallelEnumerable` class,
    we will learn how to write parallel queries.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the ParallelEnumerable class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ParallelEnumerable` class is available in the `System.Linq` namespace and
    the `System.Core` assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from supporting most of the standard query operators defined by LINQ,
    the `ParallelEnumerable` class supports a lot of extra methods that support parallel
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsParallel()`: This is the seed method that''s required for parallelization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsSequential()`: Enables sequential execution of a parallel query by changing
    the parallel behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsOrdered()`: By default, PLINQ doesn''t preserve the order in which tasks
    are executed and results are returned. We can preserve this ordering by calling
    the `AsOrdered()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsUnordered()`:This is the default behavior of `ParallelQuery`, which can
    be overridden by the `AsOrdered()` method. We can change the behavior from ordered
    to unordered by calling this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ForAll()`:Enables query execution to be performed in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Aggregate()`: This method can be used to aggregate results from various thread-local
    partitions in a parallel query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WithDegreesOfParallelism()`:Using this method, we can specify the maximum
    number of processors that are used to parallelize query executions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WithParallelOption()`:Using this method, we can buffer the results that are
    produced by a parallel query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WithExecutionMode()`:Using this method, we can force the parallel execution
    of a query or let PLINQ decide whether the query needs to be executed as sequential
    or parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn more about these methods later in this chapter through the use
    of code examples. There is a very handy tool called LINQPad that's worth mentioning
    here. LINQPad helps us learn about LINQ/PLINQ queries since it has more than 500
    available samples and the ability to connect to a variety of data sources. You
    can download it from [https://www.linqpad.net/](https://www.linqpad.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Our first PLINQ query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that we want to find all the numbers that are divisible by three.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a range of 100,000 numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To find all the numbers that are divisible by three sequentially, use the following
    LINQ query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a parallel version of the same query using the `AsParallel`
    method but using the method syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the same version using the query syntax option in LINQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c9852c6-5fe8-414a-91aa-388584a16007.png)'
  prefs: []
  type: TYPE_IMG
- en: Preserving order in PLINQ while doing parallel executions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PLINQ executes work items in parallel and, by default, doesn't care about preserving
    the order of items to improve the performance of parallel queries. However, it
    is sometimes important that items are executed in the same order as they exist
    in the source collection. For example, imagine you are sending multiple requests
    to the server to download files in chunks and later on merging those chunks to
    recreate the file on the client side. Since the file is downloaded in parts, every
    part needs to be downloaded and merged in the correct order. Preserving the order
    while executing items in parallel has a direct impact on performance as we need
    to preserve the original ordering throughout the partitions and ensure that the
    ordering is consistent when merging items.
  prefs: []
  type: TYPE_NORMAL
- en: We can override the default behavior and turn on order preservation by using
    the `AsOrdered()` method on the source collection. If, at any point, we want to
    turn off the order preservation, we can call the `AsUnOrdered()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is sequential, so when we run it, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ee9fa01-fe43-4286-a5e7-2da1ac67513f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can make a parallel version using the `AsParallel()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code executes in parallel, but the ordering is all messed up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/109be61b-ab59-478d-82cf-ebd3186a4600.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To get the best of both worlds, that is, parallel execution with ordering,
    we can modify the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a62a7b42-bb90-4a57-8585-453ebf546d32.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when we call the `AsOrdered()` method, it executes all the work
    items in parallel while preserving the original order, whereas, in the default
    one, the order was not preserved. The performance implications of using the `AsOrdered()`
    method are huge since the order is restored at every step of the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Sequential execution using the AsUnOrdered() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have called `AsOrdered` on PLINQ, the query will execute sequentially.
    There may be situations in which we want to execute a query as ordered for a certain
    period but change to unordered after that to gain performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to generate the squares of the first 100 numbers from a
    range of numbers. One way to do this in parallel is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We need `AsOrdered()` to get the first 100 numbers. The problem is that the
    `Select` query will also perform as ordered. We can improve performance by combining
    `AsOrdered()` and `AsUnOrdered()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, the first 100 items will be retrieved in parallel and in order. After that,
    the query will execute without any order preservation.
  prefs: []
  type: TYPE_NORMAL
- en: Merge options in PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, when we create a parallel query, the source collection
    is partitioned so that multiple tasks can work on sections concurrently. Once
    the query completes, the results need to be merged so that they can be made available
    to the consuming thread. There are various ways to merge the results, depending
    on the query operators. We can specify how we want to merge the results explicitly
    using the `ParallelMergeOperation` enumeration and the `WithMergeOption()` extension
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the various merge options that are available to us.
  prefs: []
  type: TYPE_NORMAL
- en: Using the NotBuffered merge option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The results of concurrent tasks are not buffered. As soon as any of the tasks
    finish, they return the result to the consuming thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f57d286b-cd53-4c1e-a6a8-4ce2c49db628.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the AutoBuffered merge option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The results from concurrent tasks are buffered and the buffer is made available
    to consuming threads in periodic intervals. Depending on the size of the collection,
    multiple buffers might be returned. Using this option, the consuming thread needs
    to wait longer to get the first result. This is also the default option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4ff17e0-f114-4331-96ef-0cdfc05fb90d.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the FullyBuffered merge option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The results from concurrent tasks are fully buffered before they are made available
    in one go to the consuming thread. This improves the overall performance, though
    the time it takes to get the first result will be longer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3438d1bb-7fa1-4d8a-b73f-7bb47658899f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Not all query operators support all merge modes. The following is a list of
    operators, along with their restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4778fae-b79c-4ac2-9f71-ae424eea9626.png)'
  prefs: []
  type: TYPE_IMG
- en: This information can be found at [http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx](http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the preceding operators, `ForAll()` is always `NotBuffered` and `OrderBy`
    is always `FullyBuffered`. If any custom merge options are specified on these
    operators, they are just ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing and handling exceptions with PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like other parallel primitives, PLINQ throws a `System.AggregateException`
    whenever it encounters an exception. Exception handling largely depends on your
    design. You may want the program to fail as soon as possible or you may want all
    the exceptions to be returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will wrap a parallel query inside a `try`-`catch`
    block. When the query throws an exception, it will propagate back to the caller,
    wrapped in `System.AggregateException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8c67d50-21a0-4685-a992-5ed7d2be1a04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also specify a `try`-`catch` block within a delegate, which would alert
    us about error conditions as soon as possible. It can also be used in a scenario
    in which we just want to log an exception and continue the query''s execution
    by providing a default value as the query result in the case of an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a11c41a4-91fe-4229-a8ad-03dd5941f418.png)'
  prefs: []
  type: TYPE_IMG
- en: Exception handling is very important for maintaining the correct flow in the
    application, as well as to notify the user of applications with error conditions.
    With proper exception handling and logging, we can troubleshoot application errors
    in production environments as well. In the next section, we will discuss how to
    merge parallel and sequential queries.
  prefs: []
  type: TYPE_NORMAL
- en: Combining parallel and sequential LINQ queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already discussed the use of `AsParallel()` to create parallel queries.
    Sometimes, we may want to execute operators sequentially. We can force PLINQ to
    operate sequentially using the `AsSequential()` method. Once this method is applied
    to any parallel query, the following operators execute in a sequence. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first `Where` class, `Where(i => i % 2 == 0)`, will execute in parallel.
    The second `Where` class, `Where(i => i % 8 == 0)`, however, will execute sequentially.
    `OrderBy` will also be switched to parallel execution mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a54d9fe-386b-409d-891c-fb7feebc4132.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we should have a good idea about how to merge synchronous and parallel
    LINQ queries. In the next section, we will learn how to cancel PLINQ queries to
    save CPU resources.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling PLINQ queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can cancel a PLINQ query using the `CancellationTokenSource` and `CancellationToken`
    classes. The cancellation token is passed to the PLINQ query using the `WithCancellation` clause
    and then we can call `CancellationToken.Cancel` to cancel the query operation.
    When a query is canceled, it throws `OperationCancelledException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a cancellation token source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrap the PLINQ query inside a `try` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add two `catch` blocks; one to catch `OperationCanceledException` and the other
    to capture `AggregateException`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the range as a very large value that takes more than four seconds to execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code. After four seconds, we will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b9611cf2-ff56-446a-b1ec-eb8ca922b462.png)'
  prefs: []
  type: TYPE_IMG
- en: Parallel programming comes with its own caveats. In the next section, we will
    introduce the disadvantages of writing parallel code with PLINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of parallel programming with PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most cases, PLINQ performs much faster than its non-parallel counterpart
    LINQ. However, there is some performance overhead, which is related to partitioning
    and merging while parallelizing the LINQ. The following are some of the things
    we need to consider while using PLINQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallel is not always faster**:Parallelization is an overhead. Unless your
    source collection is huge or it has compute-bound operations, it makes more sense
    to execute the operations in sequence. Always measure the performance of sequential
    and parallel queries to make an informed decision.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Avoid I/O operations that involve atomicity**:All I/O operations that involve
    writing to a filesystem, database, network, or shared memory location should be
    avoided inside PLINQ. This is because these methods are not thread-safe, so using
    them may lead to exceptions. A solution would be to use synchronization primitives,
    but this would also reduce performance drastically.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Your queries may not always be running in parallel**:Parallelization in PLINQ
    is a decision that''s taken by CLR. Even if we called the `AsParallel()` method
    in the query, it isn''t guaranteed to take a parallel path and may run sequentially
    instead.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding the factors that affect the performance of PLINQ (speedups)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary purpose of PLINQ is to speed up query execution by splitting the
    task and executing it in parallel. However, there are a lot of factors that can
    impact the performance of PLINQ. These include synchronization overheads to do
    with chunking and partitioning, as well as scheduling and collecting results from
    threads. PLINQ performs best in *delightfully parallel* scenarios, where threads
    don't have to share a state and don't have to worry about the order of execution.
    Being *delightfully parallel* is ideal but not always achievable due to the nature
    of work. Let's try to understand the factors that can impact the performance of
    PLINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Degree of parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a greater number of cores at our disposal, we can achieve significant performance
    gains since TPL makes sure multiple tasks can execute concurrently on multiple
    cores. This improvement in performance may not be exponential and, while tuning
    the performance, we should try to run on different systems with multiple cores
    and compare results.
  prefs: []
  type: TYPE_NORMAL
- en: Merge option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can significantly improve the user experience in scenarios where results
    change often and the user wants to see results as soon as possible without waiting.
    The default option with PLINQ is to buffer results and later merge them and return
    them to the user. We can modify this behavior by choosing an appropriate merge
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should always check whether our work items are balanced or unbalanced. For
    unbalanced work item scenarios, custom partitioners may be introduced to improve
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding when to stay sequential with PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should always work out the computational cost of each work item and the
    entire operation as a whole so that we can decide whether we want to stay sequential
    or move to parallelism. Parallel queries may not always be fast due to the additional
    overhead of partitioning, scheduling, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Computational Cost   =  Cost to execute 1 work item * total number of work
    items*'
  prefs: []
  type: TYPE_NORMAL
- en: Parallel queries can provide significant performance gains with increasing computational
    cost per item. However, if the performance gain is very low, it makes sense to
    execute the query sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether PLINQ decides to execute sequentially or in parallel depends on the
    combination of operators in the query. Simply put, if the query has any of the
    following operators, PLINQ may decide to run a query as sequential:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Take`, `TakeWhile`, `Skip`, `SkipWhile`, `First`, `Last`, `Concat`, `Zip`,
    or `ElementAt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexed `Where` and `Select`, which are overloads of `Where` and `Select`, respectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates using indexed `Where` and `Select`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Order of operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PLINQ provides better performance with unordered collections as there are performance
    costs associated with making collections execute as ordered. This performance
    cost includes partitioning, scheduling, and gathering results, as well as calling
    `GroupJoin` and filters. As a developer, you should consider when you want to
    use `AsOrdered()`.
  prefs: []
  type: TYPE_NORMAL
- en: ForAll versus calling ToArray() or ToList()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we call `ToList()` or `ToArray()` or enumerate a result in a loop, we force
    PLINQ to merge results from all the parallel threads into a single data structure.
    This is a performance overhead. If we just want to perform some actions on a set
    of items, it is better to use the `ForAll()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PLINQ is not guaranteed to carry out parallel execution every time. It may
    decide to run sequential executions, depending on the type of query. We can control
    this using the `WithExecutionMode` method. `WithExecutionMode` is an extension
    method that works on objects of the `ParallelQuery` type. It takes `ParallelExecutionMode`
    as a parameter, which is an `enum`. The default value of `ParallelExecutionMode`
    lets PLINQ decide on the best execution mode. We can force the execution mode
    to be parallel using the `ForceParallelism` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Generating sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, we used the `Enumerable.Range()` method to generate a
    sequence of numbers. We can generate numbers in parallel as well using the `ParallelEnumerable`
    class. Let''s do a simple test comparison between `Enumerable` and the `ParallelEnumerable`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9290369-ab08-4566-9f7f-87ed4670f5c2.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, `ParallelEnumerable` works much faster than `Enumerable` for
    creating a range.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar scenario, we may want to generate a number a certain amount of
    times. We can use the `ParallelEnumerable.Repeat()` method for this scenario,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've understood the factors that affect the performance of PLINQ,
    we have come to the end of this chapter. Now, let's summarize what we've learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the basics of LINQ before moving on to understand
    how we can write parallel queries using PLINQ. We learned that PLINQ can work
    well to improve the performance of the application as a whole, but it is important
    to bear its disadvantages in mind. As a programmer, it is always a good idea to
    weigh up your options by writing both LINQ and PLINQ queries and comparing their
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about using synchronization primitives to
    preserve the consistency and state of data when data is shared across multiple
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of these LINQ providers has better support for relational objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LINQ to SQL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LINQ to entities
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can easily convert LINQ into parallel LINQ by using `AsParallel()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's not possible to switch between ordered and unordered execution in PLINQ.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of these allows the results for concurrent tasks to be buffered and made
    available to consuming threads at periodic intervals?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FullyBuffered`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AutoBuffered`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NotBuffered`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which exception will be thrown if the following code is executed inside a task?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`AggregateException`'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DivideByZeroException`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
