- en: Pythonic Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the way ideas are expressed in Python, with
    its own particularities. If you are familiar with the standard ways of accomplishing
    some tasks in programming (such as getting the last element of a list, iterating,
    searching, and so on), or if you come from more traditional programming languages
    (like C, C++, and Java), then you will find that, in general, Python provides
    its own mechanism for most common tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In programming, an idiom is a particular way of writing code in order to perform
    a specific task. It is something common that repeats and follows the same structure
    every time. Some could even argue and call them a pattern, but be careful because
    they are not designed patterns (which we will explore later on). The main difference
    is that design patterns are high-level ideas, independent from the language (sort
    of), but they do not translate into code immediately. On the other hand, idioms
    are actually coded. It is the way things should be written when we want to perform
    a particular task.
  prefs: []
  type: TYPE_NORMAL
- en: As idioms are code, they are language dependent. Every language will have its
    own idioms, which means the way things are done in that particular language (for
    example, how you would open and write a file in C, C++, and so on). When the code
    follows these idioms, it is known as being idiomatic, which in Python is often
    referred to as **Pythonic**.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple reasons to follow these recommendations and write Pythonic
    code first (as we will see and analyze), writing code in an idiomatic way usually
    performs better. It is also more compact and easier to understand. These are traits
    that we always want in our code so that it works effectively. Secondly, as introduced
    in the previous chapter, it is important that the entire development team can
    get used to the same patterns and structure of the code because this will help
    them focus on the true essence of the problem, and will help them avoid making
    mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goals of this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To understand indices and slices, and correctly implement objects that can be
    indexed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement sequences and other iterables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn good use cases for context managers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement more idiomatic code through magic methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid common mistakes in Python that lead to undesired side-effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexes and slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, as in other languages, some data structures or types support accessing
    its elements by index. Another thing it has in common with most programming languages
    is that the first element is placed in the index number zero. However, unlike
    those languages, when we want to access the elements in a different order than
    usual, Python provides extra features.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, how would you access the last element of an array in C? This is
    something I did the first time I tried Python. Thinking the same way as in C,
    I would get the element in the position of the length of the array minus one.
    This could work, but we could also use a negative index number, which will start
    counting from the last, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to getting just one element, we can obtain many by using `slice`,
    as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the syntax on the square brackets means that we get all of the
    elements on the tuple, starting from the index of the first number (inclusive),
    up to the index on the second one (not including it). Slices work this way in
    Python by excluding the end of the selected interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can exclude either one of the intervals, start or stop, and in that case,
    it will act from the beginning or end of the sequence, respectively, as shown
    in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, it will get everything up to the index in the position
    number `3`. In the second example, it will get all the numbers from the position
    `3` (inclusive), up to the end. In the second to last example, where both ends
    are excluded, it is actually creating a copy of the original tuple.
  prefs: []
  type: TYPE_NORMAL
- en: The last example includes a third parameter, which is the step. This indicates
    how many elements to jump when iterating over the interval. In this case, it would
    mean to get the elements between the positions one and seven, jumping by two.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all of these cases, when we pass intervals to a sequence, what is actually
    happening is that we are passing `slice`. Note that `slice` is a built-in object
    in Python that you can build yourself and pass directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when one of the elements is missing (start, stop, or step), it is
    considered to be none.
  prefs: []
  type: TYPE_NORMAL
- en: You should always prefer to use this built-in syntax for slices, as opposed
    to manually trying to iterate the tuple, string, or list inside a `for` loop,
    excluding the elements by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functionality we just discussed works thanks to a magic method called `__getitem__`.
    This is the method that is called, when something like `myobject[key]` is called,
    passing the key (value inside the square brackets) as a parameter. A sequence,
    in particular, is an object that implements both `__getitem__` and `__len__`,
    and for this reason, it can be iterated over. Lists, tuples, and strings are examples
    of sequence objects in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we care more about getting particular elements from an object
    by a key than building sequences or iterable objects, which is a topic explored
    in [Chapter 7](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml), *Using Generators*.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement `__getitem__` in a custom class in your domain,
    you will have to take into account some considerations in order to follow a Pythonic
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case that your class is a wrapper around a standard library object,
    you might as well delegate the behavior as much as possible to the underlying
    object. This means that if your class is actually a wrapper on the list, call
    all of the same methods on that list to make sure that it remains compatible.
    In the following listing, we can see an example of how an object wraps a list,
    and for the methods we are interested in, we just delegate to its corresponding
    version on the `list` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example uses encapsulation. Another way of doing it is through inheritance,
    in which case we will have to extend the `collections.UserList` base class, with
    the considerations and caveats mentioned in the last part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, you are implementing your own sequence, that is not a wrapper
    or does not rely on any built-in object underneath, then keep in mind the following
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: When indexing by a range, the result should be an instance of the same type
    of the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the range provided by the `slice`, respect the semantics that Python uses,
    excluding the element at the end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first point is a subtle error. Think about it—when you get `slice` of a
    list, the result is a list; when you ask for a range in a tuple, the result is
    a tuple; and when you ask for a substring, the result is a string. It makes sense
    in each case that the result is of the same type of the original object. If you
    are creating, let''s say, an object that represents an interval of dates, and
    you ask for a range on that interval, it would be a mistake to return a list or
    tuple, and many more. Instead, it should return a new instance of the same class
    with the new interval set. The best example of this is in the standard library,
    with the range function. Previously, in Python 2, the `range` function used to
    build a list. Now, if you call `range` with an interval, it will construct an
    iterable object that knows how to produce the values in the selected range. When
    you specify an interval for range, you get a new range (which makes sense), not
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The second rule is also about consistency—users of your code will find it more
    familiar and easier to use if it is consistent with Python itself. As Python developers,
    we are already used to the idea of how the slices work, how the `range` function
    works, and so on. Making an exception on a custom class will create confusion,
    which means that it will be harder to remember and it might lead to bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Context managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Context managers are a distinctively useful feature that Python provides. The
    reason why they are so useful is that they correctly respond to a pattern. The
    pattern is actually every situation where we want to run some code, and has preconditions
    and postconditions, meaning that we want to run things before and after a certain
    main action.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, we see context managers around resource management. For example,
    on situations when we open files, we want to make sure that they are closed after
    processing (so we do not leak file descriptors), or if we open a connection to
    a service (or even a socket), we also want to be sure to close it accordingly,
    or when removing temporary files, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all of these cases, you would normally have to remember to free all of the
    resources that were allocated and that is just thinking about the best case—but
    what about exceptions and error handling? Given the fact that handling all possible
    combinations and execution paths of our program makes it harder to debug, the
    most common way of addressing this issue is to put the cleanup code on a `finally`
    block so that we are sure we do not miss it. For example, a very simple case would
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Nonetheless, there is a much elegant and Pythonic way of achieving the same
    thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `with` statement (PEP-343) enters the context manager. In this case, the
    `open` function implements the context manager protocol, which means that the
    file will be automatically closed when the block is finished, even if an exception
    occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Context managers consist of two magic methods: `__enter__` and `__exit__`.
    On the first line of the context manager, the `with` statement will call the first
    method, `__enter__`, and whatever this method returns will be assigned to the
    variable labeled after `as`. This is optional—we don''t really need to return
    anything specific on the `__enter__` method, and even if we do, there is still
    no strict reason to assign it to a variable if it is not required.'
  prefs: []
  type: TYPE_NORMAL
- en: After this line is executed, the code enters a new context, where any other
    Python code can be run. After the last statement on that block is finished, the
    context will be exited, meaning that Python will call the `__exit__` method of
    the original context manager object we first invoked.
  prefs: []
  type: TYPE_NORMAL
- en: If there is an exception or error inside the context manager block, the `__exit__`
    method will still be called, which makes it convenient for safely managing cleaning
    up conditions. In fact, this method receives the exception that was triggered
    on the block in case we want to handle it in a custom fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that context managers are very often found when dealing with
    resources (like the example we mentioned with files, connections, and so on),
    this is not the sole application they have. We can implement our own context managers
    in order to handle the particular logic we need.
  prefs: []
  type: TYPE_NORMAL
- en: Context managers are a good way of separating concerns and isolating parts of
    the code that should be kept independent, because if we mix them, then the logic
    will become harder to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider a situation where we want to run a backup of our database
    with a script. The caveat is that the backup is offline, which means that we can
    only do it while the database is not running, and for this we have to stop it.
    After running the backup, we want to make sure that we start the process again,
    regardless of how the process of the backup itself went. Now, the first approach
    would be to create a huge monolithic function that tries to do everything in the
    same place, stop the service, perform the backup task, handle exceptions and all
    possible edge cases, and then try to restart the service again. You can imagine
    such a function, and for that reason, I will spare you the details, and instead
    come up directly with a possible way of tackling this issue with context managers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we don't need the result of the context manager inside the
    block, and that's why we can consider that, at least for this particular case,
    the return value of `__enter__` is irrelevant. This is something to take into
    consideration when designing context managers—what do we need once the block is
    started? As a general rule, it should be good practice (although not mandatory),
    to always return something on the `__enter__`.
  prefs: []
  type: TYPE_NORMAL
- en: In this block, we only run the task for the backup, independently from the maintenance
    tasks, as we saw previously. We also mentioned that even if the backup task has
    an error, the `__exit__` will still be called.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the signature of the `__exit__` method. It receives the values for the
    exception that was raised on the block. If there was no exception on the block,
    they are all none.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return value of `__exit__` is something to consider. Normally, we would
    want to leave the method as it is, without returning anything in particular. If
    this method returns `True`, it means that the exception that was potentially raised;
    it will not propagate to the caller and will stop there. Sometimes, this is the
    desired effect, maybe even depending on the type of exception that was raised,
    but in general it is not a good idea to swallow the exception. Remember: errors
    should never pass silently.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind not to accidentally return `True` on the `__exit__`. If you do,
    make sure that this is exactly what you want, and that there is a good reason
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing context managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, we can implement context managers like the one in the previous example.
    All we need is just a class that implements the `__enter__` and `__exit__` magic
    methods, and then that object will be able to support the context manager protocol.
    While this is the most common way for context managers to be implemented, it is
    not the only one.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see not only different (sometimes more compact) ways
    of implementing context managers but also how to take full advantage of them by
    using the standard library, in particular with the `contextlib` module.
  prefs: []
  type: TYPE_NORMAL
- en: The `contextlib` module contains a lot of helper functions and objects to either
    implement context managers or use some already provided ones that can help us
    write more compact code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the `contextmanager` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: When the `contextlib.contextmanager` decorator is applied to a function, it
    converts the code on that function into a context manager. The function in question
    has to be a particular kind of function called a **generator** function, which
    will separate the statements into what is going to be on the `__enter__` and `__exit__` magic
    methods, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If at this point you are not familiar with decorators and generators, this is
    not a problem because the examples we will be looking at will be self-contained,
    and the recipe or idiom can be applied and understood regardless. These topics
    are discussed in detail in [Chapter 7](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml),
    *Using Generators*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent code of the previous example can be rewritten with the `contextmanager`
    decorator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define the generator function and apply the `@contextlib.contextmanager`
    decorator to it. The function contains a `yield` statement, which makes it a generator
    function. Again, details on generators are not relevant in this case. All we need
    to know is that when this decorator is applied, everything before the `yield`
    statement will be run as if it were part of the `__enter__` method. Then, the
    yielded value is going to be the result of the context manager evaluation (what
    `__enter__` would return), and what would be assigned to the variable if we chose
    to assign it like `as x:`—in this case, nothing is yielded (which means the yielded
    value will be none, implicitly), but if we wanted to, we could yield a statement
    which will become something we might want to use inside the context manager block.
  prefs: []
  type: TYPE_NORMAL
- en: At that point, the generator function is suspended, and the context manager
    is entered, where, again, we run the backup code for our database. After this
    completes, the execution resumes, so we can consider that every line that comes
    after the `yield` statement will be part of the `__exit__` logic.
  prefs: []
  type: TYPE_NORMAL
- en: Writing context managers like this has the advantage that it is easier to refactor
    existing functions, reuse code, and in general is a good idea when we need a context
    manager that doesn't belong to any particular object. Adding the extra magic methods
    would make another object of our domain more coupled, with more responsibilities,
    and supporting something that it probably shouldn't. When we just need a context
    manager function, without preserving many states, and completely isolated and
    independent from the rest of our classes, this is probably a good way to go.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, more ways in which we can implement context manager, and
    once again, the answer is in the `contextlib` package from the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Another helper we could use is `contextlib.ContextDecorator`. This is a mixin
    base class that provides the logic for applying a decorator to a function that
    will make it run inside the context manager, while the logic for the context manager
    itself has to be provided by implementing the aforementioned magic methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use it, we have to extend this class and implement the logic on
    the required methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Do you notice something different from the previous examples? There is no `with`
    statement. We just have to call the function, and `offline_backup()` will automatically
    run inside a context manager. This is the logic that the base class provides to
    use it as a decorator that wraps the original function so that it runs inside
    a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: The only downside of this approach is that by the way the objects work, they
    are completely independent (which is a good trait)—the decorator doesn't know
    anything about the function that is decorating, and vice versa. This, however
    good, means that you cannot get an object that you would like to use inside the
    context manager (for example, assigning `with offline_backup() as bp:`), so if
    you really need to use the object returned by the `__exit__` method, one of the
    previous approaches will have to be the one of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Being a decorator, this also poses the advantage that the logic is defined only
    once, and we can reuse it as many times as we want by simply applying the decorators
    to other functions that require the same invariant logic.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore one last feature of `contextlib`, to see what we can expect from
    context managers and get an idea of the sort of thing we could use them for.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `contextlib.suppress` is a `util` package that enters a context manager,
    which, if one of the provided exceptions is raised, doesn't fail. It's similar
    to running that same code on a `try`/`except` block and passing an exception or
    logging it, but the difference is that calling the `suppress` method makes it
    more explicit that those exceptions that are controlled as part of our logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the presence of the exception means that the input data is already in
    the expected format, so there is no need for conversion, hence making it safe
    to ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: Properties, attributes, and different types of methods for objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the properties and functions of an object are public in Python, which
    is different from other languages where properties can be public, private, or
    protected. That is, there is no point in preventing caller objects from invoking
    any attributes an object has. This is another difference with respect to other
    programming languages in which you can mark some attributes as private or protected.
  prefs: []
  type: TYPE_NORMAL
- en: There is no strict enforcement, but there are some conventions. An attribute
    that starts with an underscore is meant to be private to that object, and we expect
    that no external agent calls it (but again, there is nothing preventing this).
  prefs: []
  type: TYPE_NORMAL
- en: Before jumping into the details of properties, it's worth mentioning some traits
    of underscores in Python, understanding the convention, and the scope of attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Underscores in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some conventions and implementation details that make use of underscores
    in Python, which is an interesting topic that's worthy of analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like we mentioned previously, by default all attributes of an object are public.
    Consider the following example to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, a `Connector` object is created with `source`, and it starts with two
    attributes—the aforementioned `source` and `timeout`. The former is public, and
    the latter private. However, as we can see from the following lines when we create
    an object like this, we can actually access both of them.
  prefs: []
  type: TYPE_NORMAL
- en: The interpretation of this code is that `_timeout` should be accessed only within
    `connector` itself and never from a caller. This means that you should organize
    the code in a way so that you can safely refactor the timeout at all of the times
    it's needed, relying on the fact that it's not being called from outside the object
    (only internally), hence preserving the same interface as before. Complying with
    these rules makes the code easier to maintain and more robust because we don't
    have to worry about ripple effects when refactoring the code if we maintain the
    interface of the object. The same principle applies to methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: Objects should only expose those attributes and methods that are relevant to
    an external caller object, namely, entailing its interface. Everything that is
    not strictly part of an object's interface should be kept prefixed with a single
    underscore.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the Pythonic way of clearly delimiting the interface of an object.
    There is, however, a common misconception that some attributes and methods can
    be actually made private. This is, again, a misconception. Let''s imagine that
    now the `timeout` attribute is defined with a double underscore instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Some developers use this method to hide some attributes, thinking, like in this
    example, that `timeout` is now `private` and that no other object can modify it.
    Now, take a look at the exception that is raised when trying to access `__timeout`.
    It's `AttributeError`, saying that it doesn't exist. It doesn't say something
    like `"this is private"` or `"this can't be accessed"` and so on. It says it does
    not exist. This should give us a clue that, in fact, something different is happening
    and that this behavior is instead just a side effect, but not the real effect
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s actually happening is that with the double underscores, Python creates
    a different name for the attribute (this is called **name mangling**). What it
    does is create the attribute with the following name instead: `"_<class-name>__<attribute-name>"`.
    In this case, an attribute named `''_Connector__timeout''`, will be created, and
    such an attribute can be accessed (and modified) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice the side effect that we mentioned earlier—the attribute only exists with
    a different name, and for that reason the `AttributeError` was raised on our first
    attempt to access it.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of the double underscore in Python is completely different. It was
    created as a means to override different methods of a class that is going to be
    extended several times, without the risk of having collisions with the method
    names. Even that is a too far-fetched use case as to justify the use of this mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Double underscores are a non-Pythonic approach. If you need to define attributes
    as private, use a single underscore, and respect the Pythonic convention that
    it is a private attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use double underscores.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the object needs to just hold values, we can use regular attributes. Sometimes,
    we might want to do some computations based on the state of the object and the
    values of other attributes. Most of the time, properties are a good choice for
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Properties are to be used when we need to define access control to some attributes
    in an object, which is another point where Python has its own way of doing things.
    In other programming languages (like Java), you would create access methods (getters
    and setters), but idiomatic Python would use properties instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have an application where users can register and we want to
    protect certain information about the user from being incorrect, such as their
    email, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: By putting email under a property, we obtain some advantages for free. In this
    example, the first `@property` method will return the value held by the private
    attribute `email`. As mentioned earlier, the leading underscore determines that
    this attribute is intended to be used as private, and therefore should not be
    accessed from outside this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the second method uses `@email.setter`, with the already defined property
    of the previous method. This is the one that is going to be called when `<user>.email
    = <new_email>` runs from the caller code, and `<new_email>` will become the parameter
    of this method. Here, we explicitly defined a validation that will fail if the
    value that is trying to be set is not an actual email address. If it is, it will
    then update the attribute with the new value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This approach is much more compact than having custom methods prefixed with
    `get_` or `set_`. It's clear what is expected because it's just `email`.
  prefs: []
  type: TYPE_NORMAL
- en: Don't write custom `get_*` and `set_*` methods for all attributes on your objects.
    Most of the time, leaving them as regular attributes is just enough. If you need
    to modify the logic for when an attribute is retrieved or modified, then use properties.
  prefs: []
  type: TYPE_NORMAL
- en: You might find that properties are a good way to achieve command and query separation
    (CC08). Command and query separation state that a method of an object should either
    answer to something or do something, but not both. If a method of an object is
    doing something and at the same time it returns a status answering a question
    of how that operation went, then it's doing more than one thing, clearly violating
    the principle that functions should do one thing, and one thing only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the name of the method, this can create even more confusion, making
    it harder for readers to understand what the actual intention of the code is.
    For example, if a method is called `set_email`, and we use it as `if self.set_email("a@j.com"):
    ...`, what is that code doing? Is it setting the email to `a@j.com`? Is it checking
    if the email is already set to that value? Both (setting and then checking if
    the status is correct)?'
  prefs: []
  type: TYPE_NORMAL
- en: With properties, we can avoid this kind of confusion. The `@property` decorator
    is the query that will answer to something, and the `@<property_name>.setter`
    is the command that will dosomething.
  prefs: []
  type: TYPE_NORMAL
- en: Another piece of good advice derived from this example is as follows—don't do
    more than one thing on a method. If you want to assign something and then check
    the value, break that down into two or more sentences.
  prefs: []
  type: TYPE_NORMAL
- en: Methods should do one thing only. If you have to run an action and then check
    for the status, so that in separate methods that are called by different statements.
  prefs: []
  type: TYPE_NORMAL
- en: Iterable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, we have objects that can be iterated by default. For example, lists,
    tuples, sets, and dictionaries can not only hold data in the structure we want
    but also be iterated over a `for` loop to get those values repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: However, the built-in iterable objects are not the only kind that we can have
    in a `for` loop. We could also create our own iterable, with the logic we define
    for iteration.
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve this, we rely on, once again, magic methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iteration works in Python by its own protocol (namely the iteration protocol).
    When you try to iterate an object in the form `for e in myobject:...`, what Python
    checks at a very high level are the following two things, in order:'
  prefs: []
  type: TYPE_NORMAL
- en: If the object contains one of the iterator methods—`__next__` or `__iter__`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the object is a sequence and has `__len__` and `__getitem__`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, as a fallback mechanism, sequences can be iterated, and so there
    are two ways of customizing our objects to be able to work on `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: Creating iterable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we try to iterate an object, Python will call the `iter()` function over
    it. One of the first things this function checks for is the presence of the `__iter__`
    method on that object, which, if present, will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates an object that allows iterating over a range of
    dates, producing one day at a time on every round of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This object is designed to be created with a pair of dates, and when iterated,
    it will produce each day in the interval of specified dates, which is shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `for` loop is starting a new iteration over our object. At this point,
    Python will call the `iter()` function on it, which in turn will call the `__iter__`
    magic method. On this method, it is defined to return self, indicating that the
    object is an iterable itself, so at that point every step of the loop will call
    the `next()` function on that object, which delegates to the `__next__` method.
    In this method, we decide how to produce the elements and return one at a time.
    When there is nothing else to produce, we have to signal this to Python by raising
    the `StopIteration` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that what is actually happening is similar to Python calling `next()`
    every time on our object until there is a `StopIteration` exception, on which
    it knows it has to stop the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This example works, but it has a small problem—once exhausted, the iterable
    will continue to be empty, hence raising `StopIteration`. This means that if we
    use this on two or more consecutive `for` loops, only the first one will work,
    while the second one will be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because of the way the iteration protocol works— an iterable constructs
    an iterator, and this one is the one being iterated over. In our example, `__iter__`
    just returned `self`, but we can make it create a new iterator every time it is
    called. One way of fixing this would be to create new instances of `DateRangeIterable`,
    which is not a terrible issue, but we can make `__iter__` use a generator (which
    are iterator objects), which is being created every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And this time, it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that each `for` loop is calling `__iter__` again, and each
    one of those is creating the generator again.
  prefs: []
  type: TYPE_NORMAL
- en: This is called a **container** iterable.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is a good idea to work with container iterables when dealing
    with generators.
  prefs: []
  type: TYPE_NORMAL
- en: Details on generators will be explained in more detail in [Chapter 7](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml),
    *Using Generators*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maybe our object does not define the `__iter__()` method, but we still want
    to be able to iterate over it. If `__iter__` is not defined on the object, the
    `iter()` function will look for the presence of `__getitem__`, and if this is
    not found, it will raise `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: A sequence is an object that implements `__len__` and `__getitem__` and expects
    to be able to get the elements it contains, one at a time, in order, starting
    at zero as the first index. This means that you should be careful in the logic
    so that you correctly implement `__getitem__` to expect this type of index, or
    the iteration will not work.
  prefs: []
  type: TYPE_NORMAL
- en: The example from the previous section had the advantage that it uses less memory.
    This means that is only holding one date at a time, and knows how to produce the
    days one by one. However, it has the drawback that if we want to get the n^(th)
    element, we have no way to do so but iterate n-times until we reach it. This is
    a typical trade-off in computer science between memory and CPU usage.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation with an iterable will use less memory, but it takes up to
    *O(n)* to get an element, whereas implementing a sequence will use more memory
    (because we have to hold everything at once), but supports indexing in constant
    time, *O(1)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the new implementation might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the object behaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that negative indices also work. This is because
    the `DateRangeSequence` object delegates all of the operations to its wrapped
    object (a `list`), which is the best way to maintain compatibility and a consistent
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the trade-off between memory and CPU usage when deciding which one
    of the two possible implementations to use. In general, the iteration is preferable
    (and generators even more), but keep in mind the requirements of every case.
  prefs: []
  type: TYPE_NORMAL
- en: Container objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are objects that implement a `__contains__` method (that usually
    returns a Boolean value). This method is called in the presence of the `in` keyword
    of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When used in Python becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can imagine how much more readable (and Pythonic!) the code can be when
    this method is properly implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have to mark some points on a map of a game that has two-dimensional
    coordinates. We might expect to find a function like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, the part that checks the condition of the first `if` statement seems convoluted;
    it doesn't reveal the intention of the code, it's not expressive, and worst of
    all it calls for code duplication (every part of the code where we need to check
    the boundaries before proceeding will have to repeat that `if` statement).
  prefs: []
  type: TYPE_NORMAL
- en: 'What if the map itself (called `grid` on the code) could answer this question?
    Even better, what if the map could delegate this action to an even smaller (and
    hence more cohesive) object? Therefore, we can ask the map if it contains a coordinate,
    and the map itself can have information about its limit, and ask this object the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This code alone is a much better implementation. First, it is doing a simple
    composition and it's using delegation to solve the problem. Both objects are really
    cohesive, having the minimal possible logic; the methods are short, and the logic
    speaks for itself—`coord in self.limits` is pretty much a declaration of the problem
    to solve, expressing the intention of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the outside, we can also see the benefits. It''s almost as if Python is
    solving the problem for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic attributes for objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to control the way attributes are obtained from objects by means
    of the `__getattr__` magic method. When we call something like `<myobject>.<myattribute>`,
    Python will look for `<myattribute>` in the dictionary of the object, calling
    `__getattribute__` on it. If this is not found (namely, the object does not have
    the attribute we are looking for), then the extra method, `__getattr__`, is called,
    passing the name of the attribute (`myattribute`) as a parameter. By receiving
    this value, we can control the way things should be returned to our objects. We
    can even create new attributes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following listing, the `__getattr__`method is demonstrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some calls to an object of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first call is straightforward—we just request an attribute that the object
    has and get its value as a result. The second is where this method takes action
    because the object does not have anything called `fallback_test`, so the `__getattr__`
    will run with that value. Inside that method, we placed the code that returns
    a string, and what we get is the result of that transformation.
  prefs: []
  type: TYPE_NORMAL
- en: The third example is interesting because there a new attribute named `fallback_new`
    is created (actually, this call would be the same as running `dyn.fallback_new
    = "new value"`)*,* so when we request that attribute, notice that the logic we
    put in `__getattr__`does not apply, simply because that code is never called.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the last example is the most interesting one. There is a subtle detail
    here that makes a huge difference. Take another look at the code in the `__getattr__` method.
    Notice the exception it raises when the value is not retrievable `AttributeError`*. *This
    is not only for consistency (as well as the message in the exception) but also
    required by the built-in `getattr()` function. Had this exception been any other,
    it would raise, and the default value would not be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when implementing a method so dynamic as `__getattr__`, and use it
    with caution. When implementing `__getattr__`, raise `AttributeError`.
  prefs: []
  type: TYPE_NORMAL
- en: Callable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible (and often convenient) to define objects that can act as functions.
    One of the most common applications for this is to create better decorators, but
    it's not limited to that.
  prefs: []
  type: TYPE_NORMAL
- en: The magic method `__call__` will be called when we try to execute our object
    as if it were a regular function. Every argument passed to it will be passed along
    to the `__call__` method.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of implementing functions this way, through objects, is that
    objects have states, so we can save and maintain information across calls.
  prefs: []
  type: TYPE_NORMAL
- en: When we have an object, a statement like this `object(*args, **kwargs)` is translated
    in Python to `object.__call__(*args, **kwargs)`.
  prefs: []
  type: TYPE_NORMAL
- en: This method is useful when we want to create callable objects that will work
    as parametrized functions, or in some cases functions with memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing uses this method to construct an object that when called
    with a parameter returns the number of times it has been called with the very
    same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Some examples of this class in action are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Later in this book, we will find out that this method comes in handy when creating
    decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of magic methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can summarize the concepts we described in the previous sections in the
    form of a cheat sheet like the one presented as follows. For each action in Python,
    the magic method involved is presented, along with the concept that it represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Statement** | **Magic method** | **Python concept** |'
  prefs: []
  type: TYPE_TB
- en: '| `obj[key]``obj[i:j]``obj[i:j:k]` | `__getitem__(key)` | Subscriptable object
    |'
  prefs: []
  type: TYPE_TB
- en: '| `with obj: ...` | `__enter__` / `__exit__` | Context manager |'
  prefs: []
  type: TYPE_TB
- en: '| `for i in obj: ...` | `__iter__` / `__next__``__len__` / `__getitem__` |
    Iterable objectSequence |'
  prefs: []
  type: TYPE_TB
- en: '| `obj.<attribute>` | `__getattr__` | Dynamic attribute retrieval |'
  prefs: []
  type: TYPE_TB
- en: '| `obj(*args, **kwargs)` | `__call__(*args, **kwargs)` | Callable object |'
  prefs: []
  type: TYPE_TB
- en: Caveats in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides understanding the main features of the language, being able to write
    idiomatic code is also about being aware of the potential problems of some idioms,
    and how to avoid them. In this section, we will explore common issues that might
    cause you long debugging sessions if they catch you off guard.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the points discussed in this section are things to avoid entirely, and
    I will dare to say that there is almost no possible scenario that justifies the
    presence of the anti-pattern (or idiom, in this case). Therefore, if you find
    this on the code base you are working on, feel free to refactor it in the way
    that is suggested. If you find these traits while doing a code review, this is
    a clear indication that something needs to change.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable default arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, don't use mutable objects as the default arguments of functions.
    If you use mutable objects as default arguments, you will get results that are
    not the expected ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following erroneous function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This has two problems, actually. Besides the default mutable argument, the body
    of the function is mutating a mutable object, hence creating a side effect. But
    the main problem is the default argument for `user_medatada`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will actually only work the first time it is called without arguments.
    For the second time, we call it without explicitly passing something to `user_metadata`.
    It will fail with a `KeyError`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The explanation is simple—by assigning the dictionary with the default data
    to `user_metadata` on the definition of the function, this dictionary is actually
    created once and the variable `user_metadata` points to it. The body of the function
    modifies this object, which remains alive in memory so long as the program is
    running. When we pass a value to it, this will take the place of the default argument
    we just created. When we don't want this object it is called again, and it has
    been modified since the previous run; the next time we run it, will not contain
    the keys since they were removed on the previous call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix is also simple—we need to use `None` as a default sentinel value and
    assign the default on the body of the function. Because each function has its
    own scope and life cycle, `user_metadata` will be assigned to the dictionary every
    time `None` appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Extending built-in types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The correct way of extending built-in types such as lists, strings, and dictionaries
    is by means of the `collections` module.
  prefs: []
  type: TYPE_NORMAL
- en: If you create a class that directly extends dict, for example, you will obtain
    results that are probably not what you are expecting. The reason for this is that
    in CPython the methods of the class don't call each other (as they should), so
    if you override one of them, this will not be reflected by the rest, resulting
    in unexpected outcomes. For example, you might want to override `__getitem__`,
    and then when you iterate the object with a `for` loop, you will notice that the
    logic you have put on that method is not applied.
  prefs: []
  type: TYPE_NORMAL
- en: This is all solved by using `collections.UserDict`, for example, which provides
    a transparent interface to actual dictionaries, and is more robust.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want a list that was originally created from numbers to convert
    the values to strings, adding a prefix. The first approach might look like it
    solves the problem, but it is erroneous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'At first sight, it looks like the object behaves as we want it to. But then,
    if we try to iterate it (after all, it is a list), we find that we don''t get
    what we wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `join` function will try to iterate (run a `for` loop over) the list, but
    expects values of type string. This should work because it is exactly the type
    of change we made to the list, but apparently when the list is being iterated,
    our changed version of the `__getitem__`is not being called.
  prefs: []
  type: TYPE_NORMAL
- en: This issue is actually an implementation detail of CPython (a C optimization),
    and in other platforms such as PyPy it doesn't happen (see the differences between
    PyPy and CPython in the references at the end of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of this, we should write code that is portable and compatible in
    all implementations, so we will fix it by extending not from `list` but from `UserList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And now things look much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Don't extend directly from dict, use `collections.UserDict` instead. For lists,
    use `collections.UserList`, and for strings, use `collections.UserString`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored the main features of Python, with the goal
    of understanding its most distinctive features, those that make Python a peculiar
    language compared to the rest. On this path, we have explored different methods
    of Python, protocols, and their internal mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: As opposed to the previous chapter, this one is more Python-focused. A key takeaway
    of the topics of this book is that clean code goes beyond following the formatting
    rules (which, of course, are essential to a good code base). They are a necessary
    condition, but not sufficient. Over the next few chapters, we will see ideas and
    principles that relate more to the code, with the goal of achieving a better design
    and implementation of our software solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the concepts and the ideas of this chapter, we explored the core of Python:
    its protocols and magic methods. It should be clear by now that the best way of
    having Pythonic, idiomatic code is not only by following the formatting conventions
    but also by taking full advantage of all the features Python has to offer. This
    means that you should sometimes use a particular magic method, implement a context
    manager, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will put these concepts into action, relating general
    concepts of software engineering with the way they can be written in Python.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reader will find more information about some of the topics that we have
    covered in this chapter in the following references. The decision of how indices
    work in Python is based on (EWD831), which analyzes several alternatives for ranges
    in math and programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '*EWD831*: Why numbering should start at zero ([https://www.cs.utexas.edu/users/EWD/transcriptions//EWD831.html](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PEP-343*: The "with" Statement ([https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CC08*: The book written by Robert C. Martin named *Clean Code: A Handbook
    of Agile Software Craftsmanship*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python documentation, the `iter()` function ([https://docs.python.org/3/library/functions.html#iter](https://docs.python.org/3/library/functions.html#iter))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differences between PyPy and CPython ([https://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-of-built-in-types](https://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-of-built-in-types))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
