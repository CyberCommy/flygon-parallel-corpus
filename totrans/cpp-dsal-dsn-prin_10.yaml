- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: About
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section is included to assist the students to perform the activities in
    the book. It includes detailed steps that are to be performed by the students
    to achieve the objectives of the activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 1: Lists, Stacks, and Queues'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 1: Implementing a Song Playlist'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will implement a tweaked version of a doubly linked list
    which can be used to store a song playlist and supports the necessary functions.
    Follow these steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first include the header and write the node structure with the required
    data members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a basic constructor and size function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We'll discuss why we need a dummy node between the first and the last node later
    on, in the case of iterating using iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write the `insert` and `erase` functions. Both will take one value
    to be inserted or deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a basic structure for the required iterator and add members
    to access the actual data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement the core functions of an iterator – pre- and post-increments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the decrement-related operations to make it bidirectional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement equality-related operators for the iterator, which are essential
    for range-based loops:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write the `begin` and `end` functions with their `const` versions
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a copy constructor, initializer list constructor, and destructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a class for the music player''s playlist for our actual application.
    Instead of storing the songs, we''ll just go ahead and store integers indicating
    the ID of the song for ease of understanding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now implement functions to add and delete songs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement functions to print all the songs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a `main` function to use the playlist of our music player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon executing this, you should get output like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 2: Simulating a Card Game'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will simulate a card game and implement an efficient data
    structure to store the information about each player''s cards. Follow these steps
    to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s include the necessary headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a class to store the cards and a utility method to print
    them properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a deck of cards and shuffle the deck to randomly distribute
    the cards to each of the four players. We''ll write this logic inside a `game`
    class and call the functions later on in the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write the core logic to play one round. To avoid duplicating the code,
    we will write a utility function that will compare two players'' hands and remove
    both cards if required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write the main logic to find out who''s the winner. We''ll call
    the preceding function in a loop until one of the players can get rid of all their
    cards. To make the code more readable, we will write another utility function
    to check whether the game has been completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out who''s the winner, let''s write a utility function before starting
    the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s write the `main` function to execute the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the possible outputs could be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The winner could be any player from 1 to 4\. Since the game is based on randomness
    seeded by the time during execution, any of the players can win. Running the code
    multiple times may yield a different output every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3: Simulating a Queue for a Shared Printer in an Office'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we shall implement a queue for handling print requests to
    a shared printer in an office. Follow these steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s include the required headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement a `Job` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement the `Printer` class. We''ll use `std::queue` to have
    a first come, first served policy for `jobs`. We''ll keep the class templated
    based on the maximum number of jobs it can store in memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement another major functionality – printing jobs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use these classes to simulate the scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the preceding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Chapter 2: Trees, Heaps, and Graphs'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 4: Create a Data Structure for a Filesystem'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will create a data structure using N-ary tree for a file
    system. Follow these steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s include the required headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a node to store the data of a directory/file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s wrap this node in a tree structure for a good interface, and also
    add a static member so that we can store the current directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a constructor so that we can create a tree with a root directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a function to find the directory/file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a function to add a directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a function to change the current directory. This will be very
    simple since we already have a function to find the path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a function to print a directory or a file. For a file, we''ll
    just print the name of the file. For a directory, we''ll print all of its children''s
    names, just like the `ls` command in Linux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a main function so that we can use the aforementioned functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 5: K-Way Merge Using Heaps'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will merge multiple sorted arrays into a single sorted
    array. These steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the required headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement the main algorithm for merging. It will take a vector of a vector
    of `int` as input and will contain the vector of all the sorted vectors. Then,
    it will return the merged vector of `int`. First, let''s build the heap node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the heap node will contain three things – data, the position
    of the list in the input, and the position of the data item inside that list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build the heap. The idea is to have a min heap with the smallest element
    from all the lists. So, when we pop from the heap, we are guaranteed to get the
    smallest element. After removing that element, we need to insert the next element
    from the same list, if it''s available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll build the resultant vector. We''ll simply remove the elements from
    the heap until it is empty and replace it with the next element from the same
    list it belongs to, if available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a `main` function so that we can use the preceding function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Chapter 3: Hash Tables and Bloom Filters'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 6: Mapping Long URLs to Short URLs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will create a program to map shorter URLs to corresponding
    longer URLs. Follow these steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s include the required headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a struct called `URLService` that will provide the interface for
    the required services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we've created a map from the small URL to the original URL. This
    is because we use the small URL for the lookup. We want to convert it into the
    original URL. As we saw earlier, a map can do fast lookups based on a key. So,
    we have kept the smaller URL as the key of the map and the original URL as the
    value of the map. We have created aliases to avoid confusion regarding which string
    we are talking about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `lookup` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a function to register the smaller URL for the given actual
    URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `registerURL` function returns if there is already an existing entry in
    the data. If so, it will not touch the entry. Otherwise, it will register the
    entry and return `true` to indicate that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write a function to delete the entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we are using the `lookup` function instead of rewriting the find
    logic again. This function is much more readable now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write a function to print all the mappings for logging:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, write the `main` function so that we can use this service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the output of the preceding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we are getting both the valid URLs at the end, and not the one
    we deregistered successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7: Email Address Validator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will create a validator to check if an email address requested
    by a user is already taken. Complete the activity using these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s include the required headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a class for the Bloom filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a constructor for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Since we're going to use each byte in the hash value buffer as a different hash
    function value, and the size of the hash value buffer is 16 bytes (128 bits),
    we can't have more hash functions than that. Since each hash value is just 1 byte,
    its possible values are `0` to `255`. So, the size of the Bloom filter can't exceed
    `255`. Hence, we're throwing an error in the constructor itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write a hash function. It simply uses the MD5 function to calculate
    the hash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the function so that we can insert an email:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we are iterating from the the bytes `0` to `nHashes` in the hash
    value buffer and setting each bit to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, let''s add a function to find an email address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is one of the possible outputs of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This is one of the possible outputs because MD5 is a randomized algorithm. If
    we choose the number of functions and the size of the Bloom filter in a thoughtful
    way, we should get really good accuracy with the MD5 algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 4: Divide and Conquer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 8: Vaccinations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will store and lookup the vaccination status of students
    to determine if they need to be vaccinated. These steps should help you complete
    the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by including the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `Student` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function lets us generate a student from random data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is used to run and test the output of our implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function implements our logic for whether a vaccination is needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the driver code is implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we are randomizing values in *step 3*, your output may vary from the expected
    output shown for this activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9: Partial Sorting'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The partial quicksort is only a slight modification of the original quicksort
    algorithm that was demonstrated in *Exercise 20*, *Quicksort*. Compared to that
    exercise, only *step 4* is different. The following is a reference implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following header files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we shall implement the partition operation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the desired output also needs an implementation of the quicksort algorithm,
    we''ll implement one as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the partial quicksort function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The following helper functions can be then used to print the contents of a
    vector and to generate a random vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function implements the testing logic for our sorting functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the driver code, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 10: Implementing WordCount in MapReduce'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will implement the MapReduce model to solve the WordCount
    problem. The following is the solution to this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the map task as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The preceding map function is applied separately to each file in the input directory.
    The contents of the input file are accepted as the `*` character in `value`. The
    inner loop then iterates over the contents of the file, extracting different words
    and emitting *< key, value >* pairs, where *key* is a word and *value* is set
    to *1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the reduce task as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The reduce operation can then be applied to all < key, value > pairs that are
    emitted by the map function. Since the value was set to `1` in the previous step,
    we can now use `std::accumulate()` to get the total number of times a key appears
    among the input pairs of the reduce operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 5: Greedy Algorithms'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 11: The Interval Scheduling Problem'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will find the optimal scheduling of tasks to maximize
    the number of tasks that can be completed. Follow these steps to complete the
    activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the required header files and define the `Task` struct as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function can be used to generate a list of *N* tasks with random
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the scheduling algorithm as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The following utility functions are used to print the list of tasks, test our
    implementation, and include the driver code for the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 12: The Welsh-Powell Algorithm'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will implement the Welsh-Powell algorithm on the graph in this activity.
    A reference implementation is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the required header files and declare the graph that will be implemented
    later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the struct, representing edges like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function allows us to serialize and print graphs by overloading
    the `<<` operator for the graph datatype:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the graph with the edge list representation, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the set of colors that we will use in our implementation of the
    Welsh-Powell algorithm. Let this number of colors be `6`, as implemented in the
    following `unordered_map`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the Welsh-Powell graph coloring algorithm like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function outputs the vector of colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the following driver code creates the required graph, runs the vertex
    coloring algorithm, and outputs the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Chapter 6: Graph Algorithms I'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 13: Finding out Whether a Graph is Bipartite Using DFS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will check whether a graph is bipartite using depth-first
    search traversal. Follow these steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the required header files and declare the graph to be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following struct to define an edge in our graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following function to overload the `<<` operator for the graph so that
    it can be written to standard output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the edge list graph as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the graph shown in *figure 6.17*, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a function so that we can implement our algorithm and check whether
    the graph is bipartite. Write the function like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following functions to implement the test and driver code that tests
    our implementation of the bipartite checking algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program. You should see the following output:![Figure 6.34: Output
    of Activity 13'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14498_06_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.34: Output of Activity 13'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Activity 14: Shortest Path in New York'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will use the graph of various locations in New York City
    and find the shortest distance between the two given vertices. Follow these steps
    to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the required header files and declare the graph, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the weighted edge that will be used in the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Overload the `<<` operator for the `Graph` class so that it can be output to
    the C++ streams:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement an edge list graph, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following function so that you can parse the graph file and prepare
    the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a struct that implements a `Label` struct that will be assigned
    to each vertex as Dijkstra''s algorithm runs. Implement it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Dijkstra''s algorithm can be implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement the test and driver code, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program. Your output should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.35: Output of Activity 14'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_06_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.35: Output of Activity 14'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Chapter 7: Graph Algorithms II'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 15: Greedy Robot'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can solve this activity using the exact algorithm from *Exercise 33*, *Implementing
    the Bellman-Ford Algorithm (Part II)*. The potential pitfalls here are related
    to correctly interpreting the required task and representing the graph within
    the context of the problem you are actually trying to solve. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step will be identical to the exercise. We will include the same
    headers and define an `Edge` struct and an `UNKNOWN` constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main()`, we will declare an integer, `N`, which determines the height/width
    of the grid. We will then iterate from 0 to N * N - 1 in a `for` loop and read
    the adjacency data given in the input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must face the first potential problem – accurately representing the
    adjacencies. Typically, we would be inclined to think of a grid in two dimensions,
    and while it would certainly be possible to solve the problem this way, it would
    not be the optimal approach for this particular problem. To reinterpret the grid
    and adjacencies in one dimension, we must simply observe the following relationships
    between the one-dimensional index, `i`, and the corresponding two-dimensional
    grid coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We can handle these relationships by iterating through the characters of `directions`
    and containing the logic within a `switch` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads to the second problematic aspect of this activity; that is, the
    interpretation of the `power` values. These, of course, will be the values that
    define the edge weights between adjacent cells, but within the context of this
    problem, the inputs can be rather misleading. According to the problem''s description,
    we want to find the path that reaches the end with the maximum amount of energy
    compared to the baseline. A careless reading of the problem statement may lead
    us to conclude that the `power` values correspond exactly to the edge weights,
    but this would actually produce the opposite of what we intend to achieve. "Maximizing
    energy" can be viewed as the equivalent to "minimizing energy loss," and since
    the negative values actually represent the energy expenditure for each cell and
    the positive values represent energy gained, we must reverse the sign of each
    `power` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can implement `BellmanFord()`. This time, our function will take `N`
    and `edges` as arguments and return an integer equal to the maximum relative energy.
    To simplify our code, we will pass `N` as the total number of cells in the grid
    (that is, `N * N`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the standard implementation, we will also perform a check for negative
    cycles to handle the condition related to the robot''s greedy energy consumption.
    In the case that a negative cycle is found, we will return `UNKNOWN`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can perform a call to `BellmanFord()` in `main()` and handle the output
    accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 16: Randomized Graph Statistics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will generate randomized graphs for interview tests as
    described in the activity brief. Follow these steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by including the following headers, as well as defining the `UNKNOWN`
    constant and the `Edge` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first task is to handle the generation of each graph. For this activity,
    we will encapsulate our graph data within a struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure that the generated edges and the resulting graph are valid, we
    will create an adjacency matrix and check it during every attempt to create another
    edge. If an edge between the same two nodes already exists, we will begin another
    iteration. To make sure that every node has at least one incoming or outgoing
    edge, we will also set the diagonal cells in the matrix to true for each node
    that is part of an edge. If any of the diagonal cells are false after `E` edges
    are created, the graph will be invalid. We can indicate a graph as invalid by
    setting `V` to `-1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also define an enum called `RESULT` with the corresponding values for
    each type of graph we need to consider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main()`, we will receive the input, as well as declare the counters for
    each type of graph. We will then loop through the given number of iterations,
    create a new graph, and call a `TestGraph()` function that takes a `Graph` object
    as input and returns `RESULT`. Depending on the value that''s returned, we will
    increment each counter accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '`TestGraph()` will first check whether the value of `V` for each graph is equal
    to `-1` and return `INVALID` if so. Otherwise, it will perform Johnson''s algorithm
    to retrieve the shortest distances. The first step will be to retrieve the reweighting
    array using the Bellman-Ford algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of Bellman-Ford that''s used in this solution corresponds
    exactly to the one from the exercise, except that it receives a single `Graph`
    structure as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did in the exercise, we will check whether the vector that''s returned
    by `BellmanFord()` is empty. If so, we return `VALID` (the graph is valid but
    uninteresting). Otherwise, we will follow through with the rest of Johnson''s
    algorithm by reweighting the edges and performing a call to Dijkstra''s algorithm
    for each vertex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'For this solution, let''s use a more efficient form of Dijkstra''s algorithm,
    which uses a min-priority queue to determine traversal order. To do this, each
    value that''s added to the queue must consist of two values: the node''s index
    and its distance value. We will do this using `std::pair<int, int>`, which has
    been redefined here as `State`. When pushing elements to the queue, the first
    value must correspond to the distance since this is going to be the first value
    that''s considered by the priority queue''s internal ordering logic. All of this
    can be handled by `std::priority_queue`, but we will need to provide three template
    parameters corresponding to the data type, container, and comparison predicate,
    respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will calculate the averages in `TestGraph()` for each set of paths.
    We do this by iterating through the array returned by `Dijkstra()` and keeping
    a sum of distances for which the index is not equal to the starting node''s index.
    The corresponding value is not equal to `UNKNOWN`. Every time a valid distance
    is found, a counter is also incremented so that we can get the final average by
    dividing the sum by the count. Each one of these averages is then added to the
    total result, which is divided by the total number of vertices in the graph. Remember
    that we must reweight the distances again to get the correct values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to calculate the ratio between the result and the maximum
    weight in the graph. If the value is less than `0.5`, we return `INTERESTING`;
    otherwise, we return `VALID`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now return to `main()` and print the output. The first line will be
    equal to the value of `invalid`. The second line will be equal to `interesting
    / valid`, multiplied by `100`, so that it will be displayed as a percentage. Depending
    on how you do this, you may have to cast your variables as floating points to
    prevent the value from being rounded to an integer. When printing the output,
    you can easily make sure it is rounded to two decimal places by using `cout <<
    fixed << setprecision(2)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 17: Maze-Teleportation Game'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The entire activity conforms fairly closely to the standard implementations
    of the algorithms we've discussed in this chapter, but with a few slight modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The terms that were used in the problem description, that is, *maze*, *rooms*,
    *teleporters*, and *points* could, of course, just as easily have been called
    *graph*, *vertices*, *edges*, and *edge weights*. The condition in which a player
    is able to infinitely reduce their score can be redefined as a *negative weight
    cycle*. Follow these steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by including the necessary headers and setting up the variables
    and input for the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive input in the same form as our original Bellman-Ford implementation,
    but we will also build an adjacency list for our graph (represented here as a
    vector of integer vectors, `adj`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The first portion of the problem can be solved by using Bellman-Ford in an
    identical fashion to what was outlined in *Exercise 32*, *Implementing the Bellman-Ford
    Algorithm (Part I)*. However, instead of printing all the values in the distance
    array, we will set its return type to `int` and include a few extra lines of code
    so that it returns only the shortest distance from the source vertex (or `UNKNOWN`
    if a negative cycle is detected):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call this function in `main()` and populate a results vector for
    output. If `BellmanFord()` happens to return `UNKNOWN`, we output `INVALID MAZE`
    and terminate the program (as per the first condition). If a certain starting
    node has no outgoing edges, we can skip the call to `BellmanFord` entirely and
    simply append `UNKNOWN` to the vector. If we make it through every vertex, we
    can output the values in the results (or `DEAD END` if the value is `UNKNOWN`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ve come to the final condition – finding rooms in which players can
    get "stuck." Considering this case in terms of graph connectivity, we can redefine
    it as follows: find the strongly connected components that have no outgoing edges
    to other components. There are many simple ways to do this once all the strongly
    connected components have been acquired, but let''s try to maximize our program''s
    efficiency and add the necessary logic directly into our existing Kosaraju implementation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To accomplish this, we will declare two new vectors: one of type `bool`, named
    `isStuck` and another of type `int`, named `inComponent`. `inComponent` will store
    the index of the component each node belongs to, while `isStuck` will tell us
    whether or not the component with index `i` is cut off from the rest of the graph.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, let''s declare the new variables globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can really begin to appreciate the benefits of encapsulation and object-oriented
    implementations of graph structures. Having to pass such a large amount of data
    between our functions is not only difficult to keep track of mentally, but it
    greatly complicates any kind of modifications we may want to make in the future
    (to say nothing about the headache-inducing appearance of a function call such
    as `GetComponent(node, adj, visited, component, isStuck, inComponent, componentIndex)`.
    For the sake of example and readability, we opt to declare this data globally,
    but this sort of approach is highly recommended against within the context of
    an actual full-scale application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our `Kosaraju` function, we initialize the new data as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will begin our `while` loop, incrementing `componentIndex` by following
    each DFS traversal that''s performed on the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write the logic in `GetComponent()`, which will handle this case.
    We will begin by setting the value of each node''s index in `inComponent` to `componentIndex`.
    Now, as we iterate through each node''s neighbors, we will include another condition
    that occurs when the nodes have already been visited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, we are checking to see whether each previously visited neighbor's
    component matches the current node's component. If their respective component
    IDs are different, we can conclude that the neighbor's component has a path that
    extends to other parts of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why, in a directed graph, the existence of an edge from
    the current node indicates that the neighboring node has an outgoing path outside
    of its own component. The reason this logic seems 'backward' is because it is.
    Remember that we are traversing the transform of the original graph, so the directions
    between adjacencies are all reversed!
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon finishing the DFS traversals, we can now return the `components` vector
    and print the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Chapter 8: Dynamic Programming I'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 18: Travel Itinerary'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s begin by considering the base case and recurrence relation for this
    problem. Unlike some of the other examples we have discussed in this chapter,
    this particular problem has just one base case – the point at which the destination
    has been reached. The intermediate states are also quite simple: given a location
    at index `i` that has a distance limit of `x`, we can travel to any location between
    indices `i + 1` and `i + x` (inclusive). For example, let''s consider the following
    two cities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'City 1: `distance[1] = 2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'City 2: `distance[2] = 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's say we wanted to calculate the number of ways to reach the city at index
    `3`. Because we can reach *city 3* from both *city 1* and *city 2*, the number
    of ways to reach *city 3* is equivalent to the sum of the number of ways to reach
    city 1 and the number of ways to reach *city 2*. This recurrence is quite similar
    to the Fibonacci series, except that the number of previous states from which
    the current state's substructure is formed is variable according to the values
    of `distance`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s say we have the following four cities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we want to calculate the number of ways to travel to city 5\. To
    do this, we can formulate the substructure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now invert this logic to find the cities *from* which we can travel
    through to reach a given location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking this a step further, we can now devise an outline of the state logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, we can define the recurrence as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F(1) = 1* (We have reached the destination)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recurrence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.22: Formula for defining recurrence](img/C14498_08_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.22: Formula for defining recurrence'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In other words, the number of ways to reach a given location is equal to the
    sum of the number of ways to reach each location that connects to it. Using this
    logic, a recursive function for solving this problem might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a functional definition of the problem's states, let's begin
    implementing it in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this problem, we will include the following headers and the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the outputs of this problem require the computation of numbers that
    exceed 32 bits, we will use `long long int` for the result. To avoid having to
    write this repeatedly, we will use a `typedef` statement to abbreviate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will define the modulus value for outputting the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Handling the input and output in this problem can be implemented very simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now define a function called `TravelItinerary()` that takes `n` and
    `distance` as arguments and returns a long integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must convert the recursive algorithm we presented earlier into a bottom-up
    approach. In pseudocode, this might appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'To code this in C++, we will first declare a one-dimensional DP table of size
    `n + 1` and initialize all of its elements to `0`. Then, we will set its first
    element to `1` to represent the base case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the recurrence we described previously, we will first reverse
    the distance array so that we are essentially beginning our calculations from
    the destination index. There are several reasons for this, but the primary reason
    is so that our algorithm processes the current state by combining the results
    of earlier states, as opposed to calculating future states from the results of
    the current state. Though the logic described in the pseudocode will produce the
    correct result, it is generally preferable to formulate bottom-up logic in terms
    of how the solutions of the previous states form the result of the immediate state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: This is certainly a viable solution to the problem that will be completely satisfactory
    in the vast majority of cases. However, since dynamic programming is first and
    foremost an optimization technique, we should still ask ourselves if a better
    approach exists.
  prefs: []
  type: TYPE_NORMAL
- en: '`n` and the maximum `distance` value increase, even the preceding algorithm
    will eventually prove to be rather inefficient. If `n = 10000000` and the distance
    values can vary between 1 and 10000, then the inner `for` loop would have to perform
    nearly 100000000000 iterations in the worst case. Thankfully, there is a very
    simple technique that will allow us to completely remove the inner loop, which
    means we will have to perform exactly `n` iterations for any input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle this reduction, we will create a `prefix sum array`, which will allow
    us to calculate the range sums we previously handled by the inner loop in constant
    time. If you are unfamiliar with this technique, the basic concept is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an array called `sums` that has a length equal to the total number of
    values to sum plus one, with all the elements initialized to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each index `i` from `0` to `n`, use `sum[i + 1] = sum[i] + distance[i]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the sums have been calculated, the sum of all elements in any range `[L,
    R]` will be equal to `sum[R+1] – sum[L]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'We can implement this approach in our function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, there is still one more problem that you are likely to encounter, and
    that is that the result returned by the preceding function will be negative. This
    is due to the fact that the modulo operations are causing higher-indexed values
    in `sums` to be less than lower-indexed values, which leads to a negative result
    when subtracting. This sort of issue can be very common in problems requiring
    frequent modulo operations on very large numbers, but can be easily fixed by modifying
    the return statement slightly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: With these slight modifications, we now have an elegant and efficient solution
    to the problem that can handle massive input arrays in a fraction of a second!
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 19: Finding the Longest Common Subsequence by Using Memoization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we did with the subset sum problem, we will include each new approach within
    the same code file so that we can compare their relative performance. To that
    end, let''s define our `GetTime()` function in the same way as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define our new function, `LCS_Memoization()`, which will take the
    same arguments as `LCS_BruteForce()`, except that `subsequence` will instead be
    replaced by a reference to a two-dimensional integer vector, `memo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code for this function will also be quite similar to `LCS_BruteForce()`,
    except we will invert the logic by recursively traversing the prefixes of the
    two strings (beginning with the complete strings) and storing the results in our
    `memo` table at each step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s redefine our `main()` function to perform both approaches and display
    the time taken by each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try performing our two algorithms on two new strings, `ABCABDBEFBA`
    and `ABCBEFBEAB`. Your program''s output should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the time taken by the brute-force approach is going to be affected
    by the additional step of printing out the subsequences. By running our code again
    after setting the `DEBUG` constant to `0`, the output is now as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try pushing the limits of our algorithm using two much larger strings,
    `ABZCYDABAZADAEA` and `YABAZADBBEAAECYACAZ`. You should get an output something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The actual values for the time taken will vary depending on your system. Please
    note the difference in the values.
  prefs: []
  type: TYPE_NORMAL
- en: As we can clearly see, the gains in performance provided by memoization are
    quite significant!
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 20: Finding the Longest Common Subsequence Using Tabulation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we did previously, we will add a new function, `LCS_Tabulation()`, to the
    same code file that contains our brute-force and memoized solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `LCS_Tabulation()` function receives two arguments— strings `A` and `B`
    — and returns a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first step is to define our DP table, which we will represent as a two-dimensional
    vector of integers, with the first dimension''s size equal to one greater than
    the size of string `A`, and the second dimension''s size equal to one greater
    than the size of string `B`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the subset sum problem, all of our algorithm''s logic can be contained
    within two nested loops, with the first one iterating from `0` to the size of
    `A`, and the second iterating from `0` to the size of `B`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the subset sum problem, our base case will not be handled prior to the
    execution of the loops, but rather at the beginning of each loop. This is because
    our base case will occur any time the prefix of `A` or `B` is empty (that is,
    `i = 0` or `j = 0`). This is represented in our code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must handle the case where the characters at the end of *A*''s prefix
    and *B*''s prefix are equal. Remember that the LCS value for this state is always
    equal to `1`, plus the LCS value of the state where both prefixes are one character
    smaller than they are currently. This can be represented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'For the final case, the end characters are *not* equal. For this state, we
    know that the LCS is equal to the maximum of the LCS of *A*''s previous prefix
    and *B*''s current prefix, and the LCS of B''s previous prefix and A''s current
    prefix. In terms of our table''s structure, this is equivalent to saying that
    the LCS is equal to the maximum of the value contained in the same column and
    previous row of the table, and the value contained in the same row and previous
    column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'When we are done, the length of the longest common subsequence will be contained
    in `DP[A.size()][B.size()]` – the value of the LCS when the prefixes of both `A`
    and `B` are equal to the entire strings. Therefore, our complete DP logic is written
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have discussed several ways to find the length of the longest
    common subsequence, but what if we also want to output its actual characters?
    Of course, our brute-force solution does this, but very inefficiently; however,
    using the results contained in the preceding DP table, we can use backtracking
    to reconstruct the LCS quite easily. Let''s highlight the path we would need to
    follow in the table to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23: Activity 20 DP table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_08_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.23: Activity 20 DP table'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By collecting the characters associated with each column in the path where the
    value increases, we get the LCS `ABCBEFBA`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a function called `ReconstructLCS()` that takes `A`, `B`, `i`,
    `j`, and `DP` as arguments. Our backtracking logic can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++, this can be coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can return the result of `ReconstructLCS()` in the final line of `LCS_Tabulation()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code in `main()` should now be modified to accommodate the addition of
    `LCS_Tabulation()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the strings `ABCABDBEFBA` and `ABCBEFBEAB`, your program''s output should
    be similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The actual values for the time taken will vary depending on your system. Please
    note the difference in the values.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have looked at another detailed example of how the same logic can be
    applied to the same problem using different techniques and the corresponding effect
    this has on the execution time of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 21: Melodic Permutations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first question to ask ourselves is: what constitutes a single state in
    this problem?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base case --> Empty set:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider each note in the melody.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each subset of notes that was previously encountered, either append the
    current note or do nothing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the subset matches the target, add it to the solutions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Given that our options are to either append a note to a previous subset or
    leave it as-is, we could restate the logic as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For a given note in the melody, the count of subsets of size | n | containing
    the note is equal to the total count of all subsets of size | n - 1 | that did
    not contain the note.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, each state can be expressed in two dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dimension 1**: The length of the melody considered so far.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[length - 1]` of the melody to it or doing nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In pseudocode, the logic could be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: So, the primary question now is, how can we represent these states?
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that for an *n*-element collection, there are a total of *2**n* subsets
    comprising it — for example, a set of 4 elements can be divided into a total of
    *2**4* (or 16) subsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'If we iterate from *0* to *(2**4* *- 1)* inclusive in binary, we get the following
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the digits of each binary number from *0* to *2**n* correspond
    exactly to the indices of one possible subset of n elements. Since there are 12
    notes in the scale, this means there is a total of *2**12* (or 4,096) possible
    subsets of notes. By mapping each note in the scale to a power of 2, we can use
    bitwise arithmetic to represent the subsets encountered across each state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to solve this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the code, we should begin by including the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by handling the input in our `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a function called `ConvertNotes()`,that receives a vector
    of note strings as input and returns a vector of their corresponding integer values.
    Each of the 12 total notes in the scale will need to be mapped to a particular
    bit (beginning with `A`), with enharmonically equivalent notes assigned to identical
    values. We will use `std::map` to handle the conversions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will define a function called `CountMelodicPermutations()` that takes
    two integer vectors, `melody` and `set`, as arguments and returns an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first step is to define our target subset. We will do this using the bitwise
    or operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, if our target set is `{ C, F#, A }`, the mapping would look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now define a two-dimensional DP table, with the first dimension initialized
    to `melodyLength + 1`, and the second dimension initialized to one greater than
    the maximum subset value (that is, `111111111111 = 2``12` `- 1`, so the second
    dimension will contain *2**12*, or 4,096, elements):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Our DP formula can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `i` ranges from `1` to the length of the melody. We can write the preceding
    logic in C++ like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can finish our `main()` function by calling `CountMelodicPermutations`
    and outputting the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Chapter 9: Dynamic Programming II'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 22: Maximizing Profit'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will optimize our inventory for sale to maximize our profits.
    Follow these steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by including the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will define a structure, `Product`, that encapsulates the data associated
    with each item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will handle the input in the `main()` function and populate an array
    of the `Product` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'As with any DP algorithm, we must now define the states and base cases. We
    know that the subset of items that form the final result must match the following
    criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: –  The sum of the `cost` of all the products in the subset must not exceed `budget`.
  prefs: []
  type: TYPE_NORMAL
- en: –  The sum of the `quantity` of all the products in the subset must not exceed
    `capacity`.
  prefs: []
  type: TYPE_NORMAL
- en: –  The sum of the `value` of all the products in the subset must be maximized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given these criteria, we can see that each state can be defined by the following
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: –  The current item being considered
  prefs: []
  type: TYPE_NORMAL
- en: –  The number of units previously purchased
  prefs: []
  type: TYPE_NORMAL
- en: –  The total cost of the purchased items
  prefs: []
  type: TYPE_NORMAL
- en: –  The total profit gained after selling the products at retail value
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also conclude that a search will terminate when:'
  prefs: []
  type: TYPE_NORMAL
- en: –  All the items have been considered
  prefs: []
  type: TYPE_NORMAL
- en: –  The total cost exceeds the budget
  prefs: []
  type: TYPE_NORMAL
- en: –  The total number of units exceeds the capacity
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the traditional 0-1 knapsack problem, we will consider each item from
    `0` to `N-1` linearly. For each item at index `i`, our states can transition in
    one of two ways: by either including the current item or leaving it. Writing the
    recursive logic in pseudocode may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, the recurrence relation is defined according
    to the values of `i`, `count`, `cost`, and `total`. Converting this logic from
    top down to bottom up can be done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: In other words, each state is described according to the current index, total
    cost, and total count. For each pair of valid `cost` and `count` values, the current
    result for an item at index `i` will be equal either to the maximum subset sum
    that was found for the same values of `cost` and `count` at index `i – 1` (that
    is, `DP[i – 1][cost][count]`) or the sum of the current item's `value` with the
    maximum sum at index `i – 1` with `cost` and `count` equal to what they would
    have been prior to including the item (that is, `DP[i - 1][cost – price][count
    – quantity] + value`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can code the preceding logic as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the implementation is equivalent to the 0-1 knapsack solution
    with an additional dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 23: Residential Roads'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This activity has quite a few potential pitfalls if you do not approach it
    with some forethought. The most difficult aspect of it is the fact that it requires
    a number of distinct steps, and a careless mistake at any point can cause the
    entire program to fail. Therefore, it is recommended to approach the implementation
    step by step. The primary steps that are required are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling the input
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building the graph (finding adjacencies and weight values)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding the shortest distances between graph nodes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reconstructing the edges in the shortest paths
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Redrawing the input grid
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this is considerably lengthier than the other activities in this chapter,
    let's attack each of these steps individually.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 0: Preliminary Setup**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write any code related to input, we should decide how we want to
    represent our data in advance. The input we will receive is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Two integers, `H` and `W`, representing the height and width of the grid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer, `N`, representing the number of houses contained on the property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`H` strings of width `W` representing the map of the property. We can store
    this data as an `H`-element vector of strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`H` rows of `W` integers representing the ruggedness of the terrain. We can
    store these values in an integer matrix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`N` lines containing two integers, `x` and `y`, representing the coordinates
    of each house. For this, we can create a simple structure called `Point` containing
    two integers, `x` and `y`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s look at the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the required headers and define some global constants and variables
    that we will need later in this problem. We will declare most of our data globally
    for the sake of convenience, but it is worth reiterating the point that this is
    generally considered bad practice within the context of a full-scale application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 1: Handling the Input**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there is a fair amount of input required for this problem, let''s contain
    it all in its own function, `Input()`, which will return void:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 2: Building the Graph**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem description states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A road can be built between two houses if and only if there is a direct horizontal,
    vertical, or diagonal path between them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roads may not be built across bodies of water, mountains, forests, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost of building a road between two houses is equal to the sum of ruggedness
    values on the path between them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test the first condition, we simply need to compare the coordinates of two
    points and determine whether any of the following three conditions are true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A.x = B.x` (there is a horizontal line between them)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A.y = B.y` (there is a vertical line between them)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| A.x – B.x | = | A.y – B.y |` (there is a diagonal line between them)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's get back to our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, let''s write a function `DirectLine()`, that takes two points,
    `a` and `b`, as arguments and returns a Boolean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle the second and third cases, we can simply perform a linear traversal
    from point `a` to point `b` in the grid. As we consider each point in the grid,
    we can accumulate the sum of values contained in the terrain matrix. As we do
    this, we can simultaneously check the character in `grid[a.y][a.x]`, terminating
    it as soon as we encounter a character that is not equal to `EMPTY_SPACE` (that
    is, ''`.`''). If at the end of the traversal point `a` is equal to point `b`,
    we will store the sum we acquired in the `cost` matrix; otherwise, we have determined
    that there is no adjacency between `a` and `b`, in which case we return `UNKNOWN`.
    We can do this using the `GetCost()` function, which takes two integers, `start`
    and `end`, as arguments. These represent the indices of `a` and `b`, respectively,
    and return an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'The final line requires that we define `operator !=` in our `Point` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the following `GetAdjacencies()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 3: Finding the Shortest Distances between Nodes**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem states that two houses should be connected by a road that is on
    the path that minimizes the cost of reaching the exit point. For this implementation,
    we will use the Floyd-Warshall algorithm. Let''s get back to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a function, `GetShortestPaths()`, that will handle both the implementation
    of Floyd-Warshall as well as the path''s reconstruction. To handle the latter
    case, we will maintain a *N x N* integer matrix called `next` that will store
    the index of the next point on the shortest path from nodes `a` and `b`. Initially,
    its values will be set to the existing edges in the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then perform the standard implementation of Floyd-Warshall, with one
    additional line in the innermost loop setting `next[start][end]` to `next[start][mid]`
    every time we find a shorter distance between `start` and `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '`next` matrix, we can easily reconstruct the points on each path in a similar
    way to the reconstruction approaches for the LCS or 0-1 Knapsack problems. For
    this purpose, we will define another function, `GetPath()`, that has three parameters—two
    integers, `start` and `end`, and a reference to the `next` matrix — and returns
    an integer vector containing the node indices of the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning to `GetShortestPaths()`, we will now add a loop underneath our implementation
    of Floyd-Warshall that calls `GetPath()` and then draws lines in the grid corresponding
    to each pair of points in the path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 5: Redrawing the Grid**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must draw the roads in the grid. We will do this in another function,
    `DrawPath()`, which has the `start` and `end` parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to choose the correct character corresponding to the orientation
    of each road. To do this, we will define a function, `GetDirection()`, that returns
    an integer corresponding to an index in the `roads` string we defined at the beginning
    ("`-|/\`"):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now perform a linear traversal from `a` to `b`, setting each cell in
    the grid to `mark` if its value is `EMPTY_SPACE`. Otherwise, we must check to
    see whether the character in the cell is a road character of a different orientation,
    in which case we set it to `+`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left is to call our functions in `main()` and print the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
