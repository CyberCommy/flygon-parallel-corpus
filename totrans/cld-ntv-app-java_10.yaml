- en: Platform Deployment – AWS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover some of the deployment options available in the
    Amazon AWS platform. The AWS platform is one of the oldest and most mature of
    the cloud service providers. It was introduced in 2002 and has been a leader in
    the space since then. AWS has also been constantly innovating and has introduced
    several new services that have found wide adoption among a broad variety of customers,
    from single person start-ups to enterprises.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The AWS platform
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS platform deployment options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS platform
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Amazon AWS was the pioneer of cloud computing, and has been expanding its cloud
    offerings ever since to maintain its leadership position. The following diagram
    gives an indicative list of services offered by the AWS platform for application
    developers:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efc34941-6e16-428a-a07d-c08cdc5dc74e.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: This is just an indicative list and by no means an exhaustive list; refer to
    the Amazon AWS portal for a complete list.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'The categories are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure**: This is probably the core of the AWS platform that enables
    it to provide a plethora of other services. These can be further classified into:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compute**: Services such as EC2, Lambda, ECS, and ELB. We will be demonstrating
    the deployment of our sample application using primarily compute services, but
    it is relatively easy to tie them up with the other services offered by AWS.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: Services such as S3, EBS, and CloudFront.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking**: Services such as VPC, Route53, and DirectConnect.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application**: These services can be used as components to build and support
    applications.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: These services target databases, providing access to different
    **relational database management system** (**RDBMS**) and NoSQL data stores.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevOps**: These services provide the ability to construct build pipelines
    and enable continuous delivery. These include source code hosting, continuous
    integration tools, and cloud and software provisioning tools.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: These services provide **role-based access control** (**RBAC**)
    to the various services offered by AWS, and provide a mechanism to specify quotas
    and enforce them, key management, and secret storage.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile**: These services are targeted at providing backends for mobile applications
    and services such as notification.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analytics**: These services include batch systems such as MapReduce, and
    stream processing systems such as Spark are available for building analytics platforms.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS platform deployment options
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of the various services offered by the AWS platform, we will be focusing this
    chapter on covering some deployment options specifically targeted for the kind
    of web APIs that we have been using as an example. We will therefore cover the
    deployment into:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: AWS Elastic Beanstalk
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Elastic Container Service
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Lambda
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we will be running our application in the cloud environment, where we
    will not be required to manage the infrastructure directly, that is, we will not
    be launching virtual machines and installing the application within them, we will
    not require service discovery, as elastic load balancers will automatically route
    to all the instances of the application that are up. So, we will use a version
    of the `product` API that does not use the Eureka discovery client:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Deploying Spring Boot API to Beanstalk
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AWS Elastic Beanstalk** (**AEB**) is a service offered by AWS to host web
    applications on AWS without having to provision or manage the IaaS layer directly.
    AEB supports popular languages such as Java, .NET, Python, Ruby, Go, and PHP.
    Recently, it has also offered support for running Docker containers. We will take
    a simplified version of the `product` service that we have built so far in our
    journey, and deploy it in AEB as a runnable JAR and also as a Docker container.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a runnable JAR
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Log in to the AWS console, select the Elastic Beanstalk service under the Compute
    category, and click on the Get started button:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b572ac6b-6c97-4e58-a2b2-88e582e21ae1.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Fill in the application details in the next screen:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/560dd240-24b2-400f-a8a6-c83ad680c952.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'Upload the `product.jar` from the `target` folder and click on the Configure
    more options button. You will be presented with the different categories which
    you can configure by selecting Software, and under that, in the Environment properties,
    add a new environment variable called `SERVER_PORT` and set the value to `5000`.
    This is necessary, because by default the NGINX server that is created by the
    AEB environment will proxy all requests to this port, and by setting the variable
    we are making sure that our Spring Boot application will run on port `5000`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39e95de8-1379-47e4-a8d0-2455339e0eb3.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Now, a new environment with our application running will be provisioned by
    AWS:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c31356a5-b7c7-4e21-ab0d-4a3a5e0158a7.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Once the environment is provisioned, AEB will generate a URL for the application:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bebd5f7-5986-40b7-b578-f6fe06d55583.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'We can use this URL to access the API endpoint:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2451c2fd-4a87-4755-94d3-544a8d0996f4.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: Deploying Docker containers
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned how to deploy a runnable JAR to the Elastic Beanstalk
    service, let's also see a variation of the same where we will deploy a Docker
    container running the same application. The advantage offered by using a Docker
    container is that we can use languages and platforms not already supported by
    the AWS Elastic Beanstalk service and still deploy them in the cloud, reaping
    the benefits offered by the service.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: For this deployment, we will be using the Docker registry available within the
    **Elastic Container Service** (**ECS**) offering to store the Docker container
    that we build from our application. We will cover how we can push our local Docker
    containers to the ECS repository, when we are deploying to ECS. For now, let's
    assume that the Docker container that we want to deploy is available in a repository
    called `<aws-account-id>.dkr.ecr.us-west-2.amazonaws.com/product-api`. Since we
    need to access this repository, we need to add the AmazonEC2ContainerRegistryReadOnly
    policy to the default Elastic Beanstalk role, aws-elasticbeanstalk-ec2-role.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done from the IAM console under the Roles section:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df0c9e42-5a70-4c5d-815e-458437dfef96.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: 'Create a file called `Dockerfile.aws.json` with the following contents:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we are ready to deploy our Docker container. In the Elastic Beanstalk console,
    instead of choosing Java, we will choose a single Docker container and create
    a new application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a07d769-e612-486c-8d5e-9d1619d4d81a.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: 'Select and upload the `Dockerfile.aws.json` to create the environment:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db25cea9-3dd0-4102-8643-40ef14503fe7.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: 'We can test our API endpoints to verify if our Docker container is running
    correctly. We can also configure the container to use Amazon CloudWatch logging
    and monitoring to better monitor our application:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72b589b2-40fd-439c-aaee-774137effd99.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Deploying Spring Boot App to the Elastic Container Service
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS **Elastic Container Service** (**ECS**) is a service that allows a user
    to deploy applications using a managed Docker instance. Here, the AWS ECS service
    is responsible for provisioning the virtual machine and the Docker installation.
    We can deploy our application by doing the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Start ECS, click on Continue:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9c5dd2c2-6787-4539-91ca-bdb9b28e8b9f.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'Create the ECS repository with name `product-api` and click on Next step:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2be15da6-f07b-4c03-9688-e1148fc1d326.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'Build and push a Docker container to the repository, following the instructions
    given on the screen:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a35fb748-ff23-4d25-b394-590ea2f14536.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'The Docker login command generated by the GUI has an extra `http://` which
    should be excluded for:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e843f488-de3c-4c27-9d49-c59bc9ad4c70.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e843f488-de3c-4c27-9d49-c59bc9ad4c70.png)'
- en: 'We can now build and push the Docker container to the created repository:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以构建并推送Docker容器到创建的存储库：
- en: '![](img/e8072215-a0ca-40b5-9e1c-8a015e9d383b.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8072215-a0ca-40b5-9e1c-8a015e9d383b.png)'
- en: 'We will use this container repository when configuring our task definition:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置任务定义时，我们将使用此容器存储库：
- en: '![](img/39e6452a-6c6f-485b-b71c-f4fb03a62bcd.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39e6452a-6c6f-485b-b71c-f4fb03a62bcd.png)'
- en: 'In the advanced options, we can configure AWS CloudWatch logging to capture
    the logs from the Docker container, under the STORAGE AND LOGGING section:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在高级选项中，我们可以配置AWS CloudWatch日志记录，以捕获来自Docker容器的日志，在存储和日志记录部分下：
- en: '![](img/7a1d2053-56e2-4371-8b5a-5100beb71a59.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a1d2053-56e2-4371-8b5a-5100beb71a59.png)'
- en: 'We need to create a corresponding log group in the CloudWatch console to capture
    the logs created from our application:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在CloudWatch控制台中创建相应的日志组，以捕获从我们的应用程序创建的日志：
- en: '![](img/302e0cad-c1ff-4f58-ad4b-e635e80d89a9.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/302e0cad-c1ff-4f58-ad4b-e635e80d89a9.png)'
- en: We can create a service mapping to the port exposed from the container, which
    is `8080:`
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个服务映射到容器中公开的端口，即`8080：`
- en: '![](img/16a2d1fc-b921-41d6-8b8f-e987a1201dff.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16a2d1fc-b921-41d6-8b8f-e987a1201dff.png)'
- en: 'Optionally, we can picture the EC2 instance type and configure a Key pair so
    that we will be able to log in to the EC2 instance that ECS will create for our
    application:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，我们可以描绘EC2实例类型并配置密钥对，以便我们能够登录到ECS将为我们的应用程序创建的EC2实例中：
- en: '![](img/b96f9480-7312-4b84-9a4d-79e12335d242.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b96f9480-7312-4b84-9a4d-79e12335d242.png)'
- en: 'Once we review the configurations and submit, ECS will begin creating the EC2
    instance and deploying our application into it:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们审查配置并提交，ECS将开始创建EC2实例并将我们的应用程序部署到其中：
- en: '![](img/bd112413-b82d-47df-add8-b3c08c6bd29c.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd112413-b82d-47df-add8-b3c08c6bd29c.png)'
- en: 'We can click on Auto Scaling group and find the instance that was launched:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以点击自动扩展组并找到已启动的实例：
- en: '![](img/8be45561-dffd-4b6a-873e-e73cf39ff2cc.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8be45561-dffd-4b6a-873e-e73cf39ff2cc.png)'
- en: 'Find the instance:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到实例：
- en: '![](img/66100781-e44f-4520-b946-4bc202fc41fa.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66100781-e44f-4520-b946-4bc202fc41fa.png)'
- en: 'Find the instance hostname:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到实例主机名：
- en: '![](img/eecd2566-2434-4c5a-ba2d-4e70088f4358.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eecd2566-2434-4c5a-ba2d-4e70088f4358.png)'
- en: 'Access the application through the instance hostname:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实例主机名访问应用程序：
- en: '![](img/d76205d8-b879-47e8-a636-a304f16d3050.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d76205d8-b879-47e8-a636-a304f16d3050.png)'
- en: 'But it is not feasible to access applications individually by their hostnames,
    so, instead, we will create an Elastic load balancer, which will route requests
    to the instances, thereby allowing us to have a stable endpoint while scaling
    up or down:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但是逐个通过它们的主机名访问应用程序是不可行的，因此，我们将创建一个弹性负载均衡器，它将路由请求到实例，从而允许我们在扩展或缩减时拥有稳定的端点：
- en: 'We will go to the EC2 console and select Create under Application Load Balancer:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将转到EC2控制台，并在应用程序负载均衡器下选择创建：
- en: '![](img/93c7bf88-f0f4-4a01-a16e-54f6b6baa465.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93c7bf88-f0f4-4a01-a16e-54f6b6baa465.png)'
- en: 'Configure the Load Balancer Port:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置负载均衡器端口：
- en: '![](img/4a349305-fd46-46b9-b707-cd4ef596de84.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a349305-fd46-46b9-b707-cd4ef596de84.png)'
- en: 'Configure the Target group and the Health checks endpoint:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置目标组和健康检查端点：
- en: '![](img/570e525d-cd1c-419d-b3e0-19e5713b62ba.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/570e525d-cd1c-419d-b3e0-19e5713b62ba.png)'
- en: 'Register the target instances to the instance that was created by our cluster
    definition:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标实例注册到我们的集群定义创建的实例：
- en: '![](img/0dc9ccdb-c7b7-4bb6-8b7b-7cd70c4b5b05.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dc9ccdb-c7b7-4bb6-8b7b-7cd70c4b5b05.png)'
- en: 'Find the DNS record for the Load balancer:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到负载均衡器的DNS记录：
- en: '![](img/21b3b419-d99c-4c84-8884-989aa0532e6f.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21b3b419-d99c-4c84-8884-989aa0532e6f.png)'
- en: 'Connect to the load balancer endpoint and verify the application is working:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到负载均衡器端点并验证应用程序是否正常工作：
- en: '![](img/25bb98e1-320c-4504-953d-0bbc2c88468f.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25bb98e1-320c-4504-953d-0bbc2c88468f.png)'
- en: Deploying to AWS Lambda
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到AWS Lambda
- en: 'The AWS Lambda service allows the deployment of simple functions to be invoked
    on event triggers. These event triggers can be classified into four types, namely:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda服务允许部署简单函数以在事件触发器上调用。这些事件触发器可以分为四种类型，即：
- en: Data Store (for example, AWS DyanmoDB)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储（例如，AWS DyanmoDB）
- en: Queues and Streams (for example, AWS Kinesis)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列和流（例如，AWS Kinesis）
- en: Blob Store (for example, AWS S3)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blob存储（例如，AWS S3）
- en: 'API Dateways:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API数据门户：
- en: '![](img/bc0e31ba-40c8-477a-a75a-ced5421df4fd.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc0e31ba-40c8-477a-a75a-ced5421df4fd.jpg)'
- en: The complete list of event sources supported by AWS Lamda can be found at [https://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html#api-gateway-with-lambda.](https://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html#api-gateway-with-lambda)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lamda支持的事件源的完整列表可以在[https://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html#api-gateway-with-lambda.](https://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html#api-gateway-with-lambda)找到
- en: Unlike the other deployment options discussed earlier, AWS Lambda provides the
    most transparent scaling option where the AWS platform scales the instances required,
    based on the demand. We are freed from configuring instances, load balancers,
    and so on, and instead can focus on the application logic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前讨论的其他部署选项不同，AWS Lambda提供了最透明的扩展选项，AWS平台根据需求自动扩展所需的实例。我们无需配置实例、负载均衡器等，而是可以专注于应用程序逻辑。
- en: We will now build a simple AWS Lambda function and bind it to an API endpoint
    to invoke it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将构建一个简单的AWS Lambda函数，并将其绑定到API端点以调用它。
- en: 'We will begin by creating a new Spring Boot application with the following
    dependencies. We will also be using the `maven-shade-plugin` to create a runnable
    JAR:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的Spring Boot应用程序，具有以下依赖项。我们还将使用`maven-shade-plugin`创建可运行的JAR：
- en: '[PRE2]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now create `HelloHandler.java` with the following contents:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建`HelloHandler.java`，内容如下：
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since lambda functions are simple functions, we can test them quite easily
    just by using the inputs and outputs of the functions. For example, a sample test
    case could be:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于lambda函数是简单的函数，我们可以通过使用函数的输入和输出很容易地测试它们。例如，一个示例测试用例可能是：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can build the lambda function using Maven:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用Maven构建lambda函数：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have now built the `hello-lambda.jar`, which we will upload to the AWS Lambda
    function that we will create from the AWS console.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by going to the API Gateway console, which appears in the Network
    and Content Delivery category of the AWS console, and create a new API:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/334bc46e-e18e-404b-88d5-dc128fed3166.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: We will add a new resource called `hello` for the path `/hello:`
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa8a523f-d9d8-4c20-b099-165ea8f92079.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'We will also create a child resource with a path parameter:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f55c4fd3-9201-4afb-844b-5b0b314462ae.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will attach the HTTP `GET` method:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ceae71e-6427-4b32-8373-2ea5946d2b3a.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'Create a lambda function with the details shown as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fde71ba7-3782-4c20-b3e3-fc912d621c42.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'Upload the runnable JAR and set the handler method:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/36753b3c-d25b-4226-9c6d-54ecd4efa730.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'Now add this lambda function to the API method:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d953143-4597-431a-ad81-ade0d5a06fde.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 'Make sure you select Use Lambda Proxy Integration so that we can use the specific
    `RequestHandler` interface, instead of using the generic `RequestStreamHandler`.
    This will also give API Gateway permission to the lambda function:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aba7b22e-dfa9-4368-b3bc-978479ca4ea9.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'Complete the API definition with the lambda function invocation:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a9a15393-71ec-4d46-a7e5-77d41ab348a6.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'We can test the API endpoint from the console:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/400e475d-1e2c-451a-8ff9-01a6f1ff1f2e.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'Now we can deploy the API:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d90a2915-d03f-4fa9-ad68-97edba4fa417.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: 'Successful deployment of the API will result in the API endpoint:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/439bb781-b264-4f30-9f52-5a81dff1e1aa.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: 'Now we can use this API endpoint, generated for this deployment environment,
    to access the application:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c2afc5c0-6922-48c9-8f82-1cde13ab4ed5.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some options offered by the AWS platform, and how
    we can deploy our application from Elastic Beanstalk, which is for web applications.
    We deployed to ECS, which is for deploying containerized workloads and is not
    restricted to web application workloads. We then deployed an AWS Lambda function
    without any need for configuring the underlying hardware. We will look at deployment
    using Azure in the following chapter to see some of the services that it offers
    for deploying cloud-native applications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
