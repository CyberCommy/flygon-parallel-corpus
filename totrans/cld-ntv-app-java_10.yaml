- en: Platform Deployment – AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover some of the deployment options available in the
    Amazon AWS platform. The AWS platform is one of the oldest and most mature of
    the cloud service providers. It was introduced in 2002 and has been a leader in
    the space since then. AWS has also been constantly innovating and has introduced
    several new services that have found wide adoption among a broad variety of customers,
    from single person start-ups to enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The AWS platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS platform deployment options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Amazon AWS was the pioneer of cloud computing, and has been expanding its cloud
    offerings ever since to maintain its leadership position. The following diagram
    gives an indicative list of services offered by the AWS platform for application
    developers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efc34941-6e16-428a-a07d-c08cdc5dc74e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is just an indicative list and by no means an exhaustive list; refer to
    the Amazon AWS portal for a complete list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The categories are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure**: This is probably the core of the AWS platform that enables
    it to provide a plethora of other services. These can be further classified into:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compute**: Services such as EC2, Lambda, ECS, and ELB. We will be demonstrating
    the deployment of our sample application using primarily compute services, but
    it is relatively easy to tie them up with the other services offered by AWS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: Services such as S3, EBS, and CloudFront.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking**: Services such as VPC, Route53, and DirectConnect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application**: These services can be used as components to build and support
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: These services target databases, providing access to different
    **relational database management system** (**RDBMS**) and NoSQL data stores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevOps**: These services provide the ability to construct build pipelines
    and enable continuous delivery. These include source code hosting, continuous
    integration tools, and cloud and software provisioning tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: These services provide **role-based access control** (**RBAC**)
    to the various services offered by AWS, and provide a mechanism to specify quotas
    and enforce them, key management, and secret storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile**: These services are targeted at providing backends for mobile applications
    and services such as notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analytics**: These services include batch systems such as MapReduce, and
    stream processing systems such as Spark are available for building analytics platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS platform deployment options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of the various services offered by the AWS platform, we will be focusing this
    chapter on covering some deployment options specifically targeted for the kind
    of web APIs that we have been using as an example. We will therefore cover the
    deployment into:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Elastic Beanstalk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Elastic Container Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we will be running our application in the cloud environment, where we
    will not be required to manage the infrastructure directly, that is, we will not
    be launching virtual machines and installing the application within them, we will
    not require service discovery, as elastic load balancers will automatically route
    to all the instances of the application that are up. So, we will use a version
    of the `product` API that does not use the Eureka discovery client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Deploying Spring Boot API to Beanstalk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AWS Elastic Beanstalk** (**AEB**) is a service offered by AWS to host web
    applications on AWS without having to provision or manage the IaaS layer directly.
    AEB supports popular languages such as Java, .NET, Python, Ruby, Go, and PHP.
    Recently, it has also offered support for running Docker containers. We will take
    a simplified version of the `product` service that we have built so far in our
    journey, and deploy it in AEB as a runnable JAR and also as a Docker container.'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a runnable JAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Log in to the AWS console, select the Elastic Beanstalk service under the Compute
    category, and click on the Get started button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b572ac6b-6c97-4e58-a2b2-88e582e21ae1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fill in the application details in the next screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/560dd240-24b2-400f-a8a6-c83ad680c952.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Upload the `product.jar` from the `target` folder and click on the Configure
    more options button. You will be presented with the different categories which
    you can configure by selecting Software, and under that, in the Environment properties,
    add a new environment variable called `SERVER_PORT` and set the value to `5000`.
    This is necessary, because by default the NGINX server that is created by the
    AEB environment will proxy all requests to this port, and by setting the variable
    we are making sure that our Spring Boot application will run on port `5000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39e95de8-1379-47e4-a8d0-2455339e0eb3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, a new environment with our application running will be provisioned by
    AWS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c31356a5-b7c7-4e21-ab0d-4a3a5e0158a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the environment is provisioned, AEB will generate a URL for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bebd5f7-5986-40b7-b578-f6fe06d55583.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use this URL to access the API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2451c2fd-4a87-4755-94d3-544a8d0996f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Deploying Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned how to deploy a runnable JAR to the Elastic Beanstalk
    service, let's also see a variation of the same where we will deploy a Docker
    container running the same application. The advantage offered by using a Docker
    container is that we can use languages and platforms not already supported by
    the AWS Elastic Beanstalk service and still deploy them in the cloud, reaping
    the benefits offered by the service.
  prefs: []
  type: TYPE_NORMAL
- en: For this deployment, we will be using the Docker registry available within the
    **Elastic Container Service** (**ECS**) offering to store the Docker container
    that we build from our application. We will cover how we can push our local Docker
    containers to the ECS repository, when we are deploying to ECS. For now, let's
    assume that the Docker container that we want to deploy is available in a repository
    called `<aws-account-id>.dkr.ecr.us-west-2.amazonaws.com/product-api`. Since we
    need to access this repository, we need to add the AmazonEC2ContainerRegistryReadOnly
    policy to the default Elastic Beanstalk role, aws-elasticbeanstalk-ec2-role.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done from the IAM console under the Roles section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df0c9e42-5a70-4c5d-815e-458437dfef96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a file called `Dockerfile.aws.json` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to deploy our Docker container. In the Elastic Beanstalk console,
    instead of choosing Java, we will choose a single Docker container and create
    a new application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a07d769-e612-486c-8d5e-9d1619d4d81a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select and upload the `Dockerfile.aws.json` to create the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db25cea9-3dd0-4102-8643-40ef14503fe7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can test our API endpoints to verify if our Docker container is running
    correctly. We can also configure the container to use Amazon CloudWatch logging
    and monitoring to better monitor our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72b589b2-40fd-439c-aaee-774137effd99.png)'
  prefs: []
  type: TYPE_IMG
- en: Deploying Spring Boot App to the Elastic Container Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS **Elastic Container Service** (**ECS**) is a service that allows a user
    to deploy applications using a managed Docker instance. Here, the AWS ECS service
    is responsible for provisioning the virtual machine and the Docker installation.
    We can deploy our application by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start ECS, click on Continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9c5dd2c2-6787-4539-91ca-bdb9b28e8b9f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the ECS repository with name `product-api` and click on Next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2be15da6-f07b-4c03-9688-e1148fc1d326.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Build and push a Docker container to the repository, following the instructions
    given on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a35fb748-ff23-4d25-b394-590ea2f14536.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Docker login command generated by the GUI has an extra `http://` which
    should be excluded for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e843f488-de3c-4c27-9d49-c59bc9ad4c70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now build and push the Docker container to the created repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e8072215-a0ca-40b5-9e1c-8a015e9d383b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use this container repository when configuring our task definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/39e6452a-6c6f-485b-b71c-f4fb03a62bcd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the advanced options, we can configure AWS CloudWatch logging to capture
    the logs from the Docker container, under the STORAGE AND LOGGING section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7a1d2053-56e2-4371-8b5a-5100beb71a59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to create a corresponding log group in the CloudWatch console to capture
    the logs created from our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/302e0cad-c1ff-4f58-ad4b-e635e80d89a9.png)'
  prefs: []
  type: TYPE_IMG
- en: We can create a service mapping to the port exposed from the container, which
    is `8080:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/16a2d1fc-b921-41d6-8b8f-e987a1201dff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Optionally, we can picture the EC2 instance type and configure a Key pair so
    that we will be able to log in to the EC2 instance that ECS will create for our
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b96f9480-7312-4b84-9a4d-79e12335d242.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we review the configurations and submit, ECS will begin creating the EC2
    instance and deploying our application into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bd112413-b82d-47df-add8-b3c08c6bd29c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can click on Auto Scaling group and find the instance that was launched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8be45561-dffd-4b6a-873e-e73cf39ff2cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Find the instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/66100781-e44f-4520-b946-4bc202fc41fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Find the instance hostname:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eecd2566-2434-4c5a-ba2d-4e70088f4358.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Access the application through the instance hostname:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d76205d8-b879-47e8-a636-a304f16d3050.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But it is not feasible to access applications individually by their hostnames,
    so, instead, we will create an Elastic load balancer, which will route requests
    to the instances, thereby allowing us to have a stable endpoint while scaling
    up or down:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go to the EC2 console and select Create under Application Load Balancer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/93c7bf88-f0f4-4a01-a16e-54f6b6baa465.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Configure the Load Balancer Port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4a349305-fd46-46b9-b707-cd4ef596de84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Configure the Target group and the Health checks endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/570e525d-cd1c-419d-b3e0-19e5713b62ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Register the target instances to the instance that was created by our cluster
    definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0dc9ccdb-c7b7-4bb6-8b7b-7cd70c4b5b05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Find the DNS record for the Load balancer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21b3b419-d99c-4c84-8884-989aa0532e6f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect to the load balancer endpoint and verify the application is working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/25bb98e1-320c-4504-953d-0bbc2c88468f.png)'
  prefs: []
  type: TYPE_IMG
- en: Deploying to AWS Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The AWS Lambda service allows the deployment of simple functions to be invoked
    on event triggers. These event triggers can be classified into four types, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Data Store (for example, AWS DyanmoDB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queues and Streams (for example, AWS Kinesis)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blob Store (for example, AWS S3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'API Dateways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/bc0e31ba-40c8-477a-a75a-ced5421df4fd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete list of event sources supported by AWS Lamda can be found at [https://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html#api-gateway-with-lambda.](https://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html#api-gateway-with-lambda)
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the other deployment options discussed earlier, AWS Lambda provides the
    most transparent scaling option where the AWS platform scales the instances required,
    based on the demand. We are freed from configuring instances, load balancers,
    and so on, and instead can focus on the application logic.
  prefs: []
  type: TYPE_NORMAL
- en: We will now build a simple AWS Lambda function and bind it to an API endpoint
    to invoke it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by creating a new Spring Boot application with the following
    dependencies. We will also be using the `maven-shade-plugin` to create a runnable
    JAR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create `HelloHandler.java` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since lambda functions are simple functions, we can test them quite easily
    just by using the inputs and outputs of the functions. For example, a sample test
    case could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can build the lambda function using Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have now built the `hello-lambda.jar`, which we will upload to the AWS Lambda
    function that we will create from the AWS console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by going to the API Gateway console, which appears in the Network
    and Content Delivery category of the AWS console, and create a new API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/334bc46e-e18e-404b-88d5-dc128fed3166.png)'
  prefs: []
  type: TYPE_IMG
- en: We will add a new resource called `hello` for the path `/hello:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa8a523f-d9d8-4c20-b099-165ea8f92079.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will also create a child resource with a path parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f55c4fd3-9201-4afb-844b-5b0b314462ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will attach the HTTP `GET` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ceae71e-6427-4b32-8373-2ea5946d2b3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a lambda function with the details shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fde71ba7-3782-4c20-b3e3-fc912d621c42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Upload the runnable JAR and set the handler method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/36753b3c-d25b-4226-9c6d-54ecd4efa730.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now add this lambda function to the API method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d953143-4597-431a-ad81-ade0d5a06fde.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make sure you select Use Lambda Proxy Integration so that we can use the specific
    `RequestHandler` interface, instead of using the generic `RequestStreamHandler`.
    This will also give API Gateway permission to the lambda function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aba7b22e-dfa9-4368-b3bc-978479ca4ea9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Complete the API definition with the lambda function invocation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a9a15393-71ec-4d46-a7e5-77d41ab348a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can test the API endpoint from the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/400e475d-1e2c-451a-8ff9-01a6f1ff1f2e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can deploy the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d90a2915-d03f-4fa9-ad68-97edba4fa417.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Successful deployment of the API will result in the API endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/439bb781-b264-4f30-9f52-5a81dff1e1aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can use this API endpoint, generated for this deployment environment,
    to access the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c2afc5c0-6922-48c9-8f82-1cde13ab4ed5.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some options offered by the AWS platform, and how
    we can deploy our application from Elastic Beanstalk, which is for web applications.
    We deployed to ECS, which is for deploying containerized workloads and is not
    restricted to web application workloads. We then deployed an AWS Lambda function
    without any need for configuring the underlying hardware. We will look at deployment
    using Azure in the following chapter to see some of the services that it offers
    for deploying cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
