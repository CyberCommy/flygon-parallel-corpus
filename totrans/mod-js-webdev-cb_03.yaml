- en: Developing with Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recipes we will be seeing in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking Node's setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Flow with Node, directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Flow with Node through preprocessing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your Node code with Nodemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using promises instead of error first callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with streams to process requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing files with streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing external processes with exec()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using spawn() to run a command, and communicating with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fork() to run Node commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We installed `Node` in the *Installing Node and npm* section of [Chapter 1](d13c6d45-6e6b-4119-9dcd-a65ee7af9f6f.xhtml), *Working
    with JavaScript Development Tools*, but that was only for setting `npm` up. `Node` can
    be used not only as a web server, which is the most common usage, but also to
    write shell line commands or even desktop applications, as we'll see in [Chapter
    13](2aebad42-65b6-4cb7-bf4f-1e2e0907a70a.xhtml), *Creating a Desktop Application
    with Electron*. However, some configuration and development practices are common
    for all those environments, and that will be the objective of this chapter. In
    this chapter, we will get started on `Node` development.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Node's setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For starters, let's verify `Node` is working, by creating a very basic server;
    we'll get into more details in the next [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml),
    *Implementing RESTful Services with Node*, but now we just want to make sure everything
    is fine. In other chapters, we will use `Node` more seriously, but the objective
    here is to verify that it works OK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting ahead a bit, let''s set up a very basic server, which will answer all
    the requests by sending back a `''Server alive!''` string. For this, we will need
    to follow three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `require()` to import the `http` module of `Node`—we'll see more on modules
    in the next section; for the time being, just assume that `require()` is equivalent
    to `import`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, use the `createServer()` method to set up our server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, provide a function that will answer all requests by sending back
    a `text/plain` fixed answer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code represents the most basic possible server, and will let
    us know whether everything has worked correctly. I have named the file `miniserver.js`.
    The line in bold does all the work, which we''ll go over in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We wrote a server; now, let''s see it run. With this very simple project, we
    can just directly run the server code. In later sections in this chapter, we''ll
    see that using Flow types will require some extra preprocessing; we can skip that
    part for now, however. We can start our server with the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify if everything is working fine, just open a browser and go to `http://localhost:8080`.
    The following screenshot shows the (admittedly not very impressive) result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2fc0537-00c7-4548-a154-47bd8504509c.png)'
  prefs: []
  type: TYPE_IMG
- en: Our minimalistic server is running, showing that we have Node working properly
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know that everything is OK, let's get started with some basic techniques
    that we will be using in several other places of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Why are we running the server at port `8080` instead of `80`? To access ports
    below `1024`, you need administrative (root) rights. However, that would make
    your server highly unsafe; a hacker that somehow managed to get into it would
    have maximum rights at your machine! Thus, the standard practice is to run `Node`
    with normal rights, at ports over `1024` (such as `8080`, for example) and set
    up a reverse proxy to send traffic on ports `80` (HTTP) or `443` (HTTPS).
  prefs: []
  type: TYPE_NORMAL
- en: Working with modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Organizing code in modules* section of [Chapter 2](2948d1ab-ac85-4b3a-90f1-f240b7688216.xhtml),
    *Using JavaScript Modern Features*, we saw how modern JS works with modules. However,
    with `Node`, we have a little setback: it doesn''t do modules the modern JS way—unless
    you are willing to work with experimental features!'
  prefs: []
  type: TYPE_NORMAL
- en: Why doesn't `Node` work with the modern JS modules? The reason harkens back
    to several years before the new modules with `import` and `export` statements
    existed, and `Node` implemented the CommonJS module format. (We'll be seeing more
    about those modules in the next section.) Obviously, libraries meant to be used
    with `Node` were also developed using that format, and nowadays there are an uncountable
    number of modules that follow those guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: However, since the new standard for modules appeared, a pressure began to apply
    to use the new syntax—but that posed some problems beyond just adjusting the language;
    can you have *two* radically different module styles coexisting? (Because, no
    one can magically transform all the existing code that uses CommonJS into the
    new format, right?) There are some other differences. ES modules are meant to
    be used in asynchronous fashion, while CommonJS modules are synchronous; for most
    cases, this doesn't cause a difference, but there are cases that must be considered.
  prefs: []
  type: TYPE_NORMAL
- en: The solution that was arrived at isn't considered definitive yet. For the time
    being (since version 8.5) you can enable the ES modules by using the `--experimental-modules` command
    line flag. If you invoke node with it, it will recognize the ES modules, if their
    extension is `.mjs` instead of plain `.js`. Hopefully, by version 10, it won't
    be needed, but that cannot be ensured, and there's also a certain risk that some
    details might change by then!
  prefs: []
  type: TYPE_NORMAL
- en: This solution, using the new `.mjs` file extension to identify new-style modules,
    is whimsically known as the **Michael Jackson Solution** because of the initials
    of the three words.
  prefs: []
  type: TYPE_NORMAL
- en: So, if I were writing this book in one or two years' time, I'd probably be telling
    you to just go ahead, start using the `.mjs` file extension, and use the new style
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://nodejs.org/api/esm.html](https://nodejs.org/api/esm.html) for current
    information about this feature.
  prefs: []
  type: TYPE_NORMAL
- en: However, at this time, it should not be considered a totally safe step—the feature
    is clearly marked as *experimental* at this point of time—so let's keep going
    with the current (old) standard, and learn how to work with the old-fashioned
    modules. Let's create a math module you might want to use for financial coding,
    so we get to see a `Node` style module built from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `Node` modules, there are two important changes in how we export and import
    elements. Any file can be a module, as with ES modules. In a nutshell, in order
    to import something from a module, you'll have to use a `require()` function,
    and the module itself will use an `exports` object to specify what it will export.
  prefs: []
  type: TYPE_NORMAL
- en: 'JS math operators (addition, subtraction, and so on) don''t do rounding, so
    let''s write a `roundmath.js` module that will perform arithmetic, but rounding
    to cents, for an imagined business-related application. First, we get started
    with the common two lines that enable `Flow`, and set strict mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to add the `"use strict"` line in all your modules, before the
    rest of your code, as we mentioned in the *Working in strict mode* section in
    the previous chapter. JS modules are strict by definition, but that doesn't apply
    to `Node` modules, which are *not* strict.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let''s define our functions. Just for variety, we''ll have a couple of
    internal (not exported) functions, and several ones that will be exported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, as per usual conventions, all exports will be together, at the bottom,
    so it will be easy to see everything that a module exports. Instead of the modern
    `export` statement, you assign whatever you want to export, to an `exports` object.
    If you want to keep variables or functions private, all you need do is skip assigning
    them; in our case, we are only exporting four of the six functions we coded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How would we use this module, and how does it work? If we wanted to import
    some of its functions from other modules, we''d write something as follows; see
    how we use some of the operations we designed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines are the usual. Then, we `require()` whatever modules we
    need; in this case, a single one. Also, per convention, all such requirements
    are grouped together, at the start, to make it simpler to understand the needs
    of a module, without having to go all through the code. In our case, `RM` gets
    assigned the `exports` object, so you can refer to `RM.addR()`, `RM.subR()`, and
    so on, and this makes clear to the reader that you are using something from the
    `RM` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to write a bit less, you can take advantage of the *destructuring
    statement* (which we met in the *Destructuring arrays and objects* section in
    the previous chapter) and directly assign the desired methods to individual variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is better if you get used to only importing modules that you'll need. In
    other cases (which we'll see in later chapters) we can use tools to just remove
    whatever modules you don't actually use, and if you `require()` everything, that
    wouldn't be possible.
  prefs: []
  type: TYPE_NORMAL
- en: Using Flow with Node, directly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are using `Flow`, and `Node` doesn''t actually know about the data
    types, there will obviously be problems if we just try to execute our data-typed
    code. There are two solutions for this: one not so elegant, but that speeds up
    development, and another more powerful one, but that will require extra work.
    Let''s here consider the first, simpler solution, and leave the second one for
    the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It so happens that `Flow` provides two ways of specifying types: the way that
    we have been using so far, with extra type notations, and another more verbose
    one, through the comments. Of course, JS doesn''t *know* about type definitions,
    so the first style won''t work unless we do extra work (as we''ll see) but using
    comments is totally safe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To define types with comments, all `Flow` specific definitions must be enclosed
    in comments starting with `/*:` (note the extra colon) and finishing with the
    usual `*/`, for simple basic types, or `/*::` and `*/` for everything else. We
    can revisit some examples we saw earlier in [Chapter 2](2948d1ab-ac85-4b3a-90f1-f240b7688216.xhtml),
    *Using JavaScript Modern Features*. Simple cases are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'More complex definitions, including optional parameters, types and opaque types,
    class attributes, and so on, require the longer comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also export and import data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why and how does this work? `Flow` is able to recognize both the `/*::  ... 
    */` and `*/**:  ...  */` comments, and thus can do its job perfectly well. Since
    the `Flow` code is all hidden away in comments, from the point of view of the
    JS engine, the `Flow` parts do not even exist, so an obvious advantage of this
    way of working is that you can directly execute your code.
  prefs: []
  type: TYPE_NORMAL
- en: Why would you *not* like this? The evident criticism is that the code looks,
    to put it mildly, ugly. If you were used to, say, `TypeScript`, having to wrap
    all type-related things in comments can become a chore, and the code will also
    be harder to read. Also, there is a risk that you'll mistype a comment (forgetting
    one of those many colons is a possibility) and then Flow will just ignore your
    definitions, posing a possible risk of letting a bug go through.
  prefs: []
  type: TYPE_NORMAL
- en: Is there an alternative? Yes, there is, but it will require some extra processing,
    while giving us the benefit of using standard `Flow` notation; let's turn to that
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Using Flow with Node through preprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with comments is a bit overly verbose. If you'd rather work with straightforward
    type annotations and extra statements, you will have to turn to some preprocessing,
    to get rid of the `Flow` paraphernalia before attempting to run your `Node` code.
    The good thing with this is that the required processing can be quite efficient,
    and practically unnoticeable when you develop; let's get into it, and see how
    we can get to keep `Flow` definitions, while not breaking our `Node` code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to use the shorter, more concise style of `Flow`, but `Node` cannot
    execute code with such additives.The solution to our conundrum is easy: just remove
    everything related to `Flow` before attempting to run! There is a package, `flow-remove-types`,
    that does just that. To start, as usual, you''ll have to install the needed package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To continue, you will have to enable it by adding a new script. We were writing
    our code in the `src/` directory, so let''s send the `Flow`-cleaned output to
    the `out/` directory. In that directory, we will get the version of the code that
    we will use in our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish, we should also tell `Git` to ignore the `out/` directory. We were
    already ignoring the `node_modules` and `flow-typed` directories, so let''s add
    one more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We are specifying `**/out` instead of just `out/`, because we are sharing a
    single `Git` repository between many projects, for the sake of the book. If, as
    is more common, you had a separate repository for each project, then you would
    simply specify `out`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What will change from the moment you start using `flow-remove-types`? First,
    obviously, you cannot just run your project with a simple `node src/somefilename.js`;
    first you'll have to strip `Flow` by `npm run build`. The effect of this command
    will be to create a copy in `out/`, of everything in `src/`, but without type
    declarations. Then, you will be able to run the project by doing `node out/somefilename.js`—filenames
    won't be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `flow-remove-types` package cleans up your files, it replaces all type
    declarations with whitespaces, so the transformed output files have exactly the
    same number of lines, and every function starts at exactly the same line as before,
    removing the need for sourcemaps and keeping the output legible. The following
    code shows how part of our module from the *Working with modules* section would
    look after the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would rather have a smaller-sized output (after all, reading code with
    all those blank spaces can be a bit tiresome) you can produce a source map and
    remove all spaces, by adding a couple of parameters to your build script, or by
    adding a different script, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Node` debugger included in VSC fully supports source maps, so producing
    briefer code won't be a problem. We'll get to see more about this in [Chapter
    5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml), *Testing and Debugging Your Server*.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a way to keep working with `Node` and `Flow` together, but running
    our code has become just a tad more complex; let's see if we can fix that!
  prefs: []
  type: TYPE_NORMAL
- en: Running your Node code with Nodemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the work we have done so far, after each and every change, running our
    updated `Node` code would require that we perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the current version of the code, if it's still running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rerun the build process to update the `out` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the new version of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Doing all of this, for every single small change, can quickly become boring
    and tiresome. But, there is a solution: we can install a watcher, that will monitor
    our files for changes and do everything mentioned here by itself, freeing us from
    the repetitive chore. Let''s then see how we can set a tool to watch out for changes,
    and do all the steps shown on its own.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will want to install and configure `nodemon`, which will take care of everything
    for us, running updated code as necessary. First, obviously, we must install the
    mentioned package. You could do it globally with `npm install nodemon -g`, but
    I''d rather do it locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll need to add a couple of scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm start` will build the application and run our main file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run nodemon` will start the monitoring'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to monitor our application for changes, and restart it as
    needed!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command most interesting for us is the second one. When you run it, `nodemon`
    will start monitoring, meaning it will watch whatever directory you selected (`out`,
    in this case) and whenever it detects some file change, it will wait one second
    (to make sure, for example, that all files are saved) and then it will rerun the
    application. How did I do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, I started `nodemon`. When you do `npm run nodemon`, the project
    is built and then run, and `nodemon` keeps waiting for any changes; see the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb4c6879-9f4f-494f-b329-4e368b746c39.png)'
  prefs: []
  type: TYPE_IMG
- en: When you start nodemon, it builds the project, runs it, and keeps watching out
    for any changes that need a restart
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterwards, I just added a simple `console.log()` line, so a file would be
    changed; the following screenshot was the result, showing the rebuilt and restarted
    code, plus the extra output line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/591781d5-b334-44be-8f39-51cbaa44ef65.png)'
  prefs: []
  type: TYPE_IMG
- en: After any change in a watched file, nodemon will restart the project. In this
    case, I had just added a line logging ADDED TEXT JUST FOR THE CHANGE.
  prefs: []
  type: TYPE_NORMAL
- en: That's all there is to it. The application will be rebuilt and restarted automatically,
    without us having to manually rerun `npm start` each and every time; a big help!
  prefs: []
  type: TYPE_NORMAL
- en: Read more about `nodemon` at [http://nodemon.io/](http://nodemon.io/) and [https://github.com/remy/nodemon.](https://github.com/remy/nodemon)
  prefs: []
  type: TYPE_NORMAL
- en: Using promises instead of error first callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's start considering several techniques that will come in handy when
    writing services.
  prefs: []
  type: TYPE_NORMAL
- en: '`Node` runs as a single thread, so if every time it had to call a service,
    or read a file, or access a database, or do any other I/O-related operation, it
    would have to wait for it to finish, then attending requests would take a long
    time, blocking other requests from being attended, and the server would show a
    very bad performance. Instead, all operations such as those are always done asynchronically,
    and you must provide a callback that will be called whenever the operation is
    finished; meanwhile, `Node` will be available to process other clients'' requests.'
  prefs: []
  type: TYPE_NORMAL
- en: There are synchronous versions of many functions, but they can only be applied
    for desktop work, and never for web servers.
  prefs: []
  type: TYPE_NORMAL
- en: '`Node` established a standard that all callbacks should receive two parameters:
    an error and a result. If the operation failed somehow, the error argument would
    describe the reason. Otherwise, if the operation had succeeded, the error would
    be null or undefined (but, in any case, a *falsy* value) and the result would
    have the resultant value.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the usual `Node` code is full of callbacks, and if a callback
    itself needs another operation, that means yet more callbacks, which themselves
    may have even more callbacks, resulting in what is called *callback hell*. Instead
    of working in this fashion, we want to be able to opt for modern promises, and,
    fortunately, there is a simple way to do so. Let's see how we can simplify our
    code by avoiding callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by seeing how a common error first callback works. The `fs` (file
    system) module provides a `readFile()` method that can read a file, and either
    produce its text or an error. My `showFileLength1()` function attempts to read
    a file, and list its length. As usual with callbacks, we have to provide a function,
    which will receive two values: a possible error, and a possible result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function must check whether the first argument is null or not. If it isn''t
    null, it means there was a problem, and the operation wasn''t successful. On the
    other hand, if the first argument is null, then the second argument has the file
    read operation result. The following code highlights the usual programming pattern
    used with `Node` callbacks; the lines in bold are the key ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This style of coding is well-known, but doesn''t really fit modern development,
    based on promises and, even better, `async`/`await`. So, since version 8 of `Node`,
    there has been a way to automatically transform an error-first callback function
    into a promise: `util.promisify()`. If you apply that method to any old-style
    function, it will turn into a promise, which you can then work in simpler ways.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `util` module is standard with `Node`, and all you have to do to use it
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `util.promisify()` method is actually another example of a Higher Order
    Function, as we saw in the *Producing functions from functions* section of [Chapter
    2](2948d1ab-ac85-4b3a-90f1-f240b7688216.xhtml), *Using JavaScript Modern Features*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `util.promisify()`, we can make `fs.readFile()` return a promise, which
    we''ll process with the `.then()` and `.catch()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You could have also written `const { promisify } = require("util")`, and then
    it would have been `fs.readFile = promisify(fs.readFile)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also allows us the usage of `async` and `await`; I''ll be using an arrow
    `async` function, just for variety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Keep in mind that you won''t always be needing `util.promisify()`. There are
    two reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Some libraries (such as `axios`, which we already used) already return promises,
    so you don't have to do anything
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other methods (such as the `http.request()` method of `Node`; see [https://nodejs.org/dist/latest-v9.x/docs/api/http.html#http_http_request_options_callback](https://nodejs.org/dist/latest-v9.x/docs/api/http.html#http_http_request_options_callback))
    have a different signature altogether, without even an error argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In any case, aiming for a standard usage will help, so we'll adopt the promise-based
    style for the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Working with streams to process requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have to work with a large enough set of data, it's fairly obvious that
    it will cause problems. Your server may not be able to provide all the required
    memory, or even if that doesn't prove to be a problem, the needed processing time
    would surpass the standard waiting time, causing timeouts—plus the fact that your
    server would close out other requests, because it would be devoted to handling
    your long-time processing one.
  prefs: []
  type: TYPE_NORMAL
- en: '`Node` provides a way to work with collections of data as streams, being able
    to process the data as it flows, and piping it to compose functionality out of
    smaller steps, much in the fashion of Linux''s and Unix''s pipelines. Let''s see
    a basic example, which you might use if you were interested in doing low-level
    `Node` request processing. (As is, we will be using higher-level libraries to
    do this work, as we''ll see in the next chapter.) When a request comes in, its
    body can be accessed as a stream, thus allowing your server to deal with any size
    of requests.'
  prefs: []
  type: TYPE_NORMAL
- en: The response that will be sent to the client is also a stream; we'll see an
    example of this in the next section, *Compressing files with streams*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams can be of four kinds:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Readable*: Which can (obviously!) be read. You would use this to process a
    file, or, as in our following example, to get a web request''s data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writable*: To which data can be written.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Duplex*: Both readable and writable, such as a web socket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transform*: Duplex streams that can transform the data as it is read and written;
    we''ll see an example of this for zipping files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write some simple code to process a request, and just show what was
    asked. Our main code for the request process will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `processRequest()` function will be quite simple, limited to showing its
    parameters. This kind of code can become helpful if you need to better understand
    how to process requests, as we''ll see in the next chapter. We will get parameters
    both from the URL and the request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The output of this code, which we'll see next, will be the the request `url`
    object (`req.url`), its parameters, and the parameters in the body.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s run the simple server we just wrote, to see how it works. We can build
    and run it with the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After the server is running, we can test it by using `curl`—we''ll get back
    to this in the *Testing simple services from the command line* section of [Chapter
    5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml), *Testing and Debugging Your Server*,
    and we''ll see our `FINISHED...` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The quote characters around the URL are needed, because the `&` character has
    a special meaning by itself for shell line commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server console will show the following output, but what we care about right
    now are the URL parameters, that match with what was provided in the `curl` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This was easy, but if the service request had been a `POST`, we would have
    listened to events to build up the `body` of the request. Refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''data''` is fired whenever there is more data to be processed. In our case,
    on each event we add to the `body` string, so as to build up the request body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''end''` is fired when there is no more data. Here, we use it to recognize
    when we have got the complete body of the request, and are then ready to move
    on and process it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''close''` (when a stream is closed) and `''error''` events do not apply here,
    but are also available for stream processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we were to do `curl -X "POST" --data "gamma=60" --data "delta=FK" "http://127.0.0.1:8080/other/path/"` to
    perform a `POST`, passing a couple of body parameters, the console output would
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Read more about streams (a lot of information!) at [https://nodejs.org/api/stream.html](https://nodejs.org/api/stream.html).
  prefs: []
  type: TYPE_NORMAL
- en: Compressing files with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can see more examples of using streams, of several types, such as in cases
    where we wanted to zip a file. In this recipe, we will be using a readable stream
    to read from a source, and a writable stream to put the zipped result.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code is quite straightforward, and short, too. We just have to `require`
    the needed modules, create an input stream for the file that we''ll read, an output
    stream for the file that we''ll create, and pipe the first stream to the second
    one; nothing could be simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the `fs` module to produce two streams: a readable one, with which we
    will be reading a given file (here, a fixed one, but it would be trivial to read
    any other one) and a writable one, where the gzipped output will go. We will pipe
    the input stream through the `gzip` module, which will compress the input before
    passing it on to the output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could as easily have produced a server that would have sent the zipped file
    to the client, to download. The following is the required code; the key difference
    is that the zipped stream now goes to the `response` stream. We must also provide
    some headers, so the client will know that a zipped file is being sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you `npm run build` and then `node out/zip_send.js`, opening `127.0.0.1:8080`
    will get what is shown in the following screenshot; you get the zipped file to
    download:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c88deced-a53c-4c57-8b0b-568e86a2f7cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Streams are also used to zip and send a file to the browser
  prefs: []
  type: TYPE_NORMAL
- en: Read more about `fs` at [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html),
    and about `zlib` at [https://nodejs.org/api/zlib.html](https://nodejs.org/api/zlib.html).
  prefs: []
  type: TYPE_NORMAL
- en: Working with a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now see how you would access a database, such as `MySQL`, `PostgreSQL`,
    `MSSQL`, `Oracle`, or more. (We will be needing this in [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml),
    *Implementing RESTful Services with Node*, when we get to build a set of services.)
    Accessing a database is frequently done, so that's what we will be doing. I chose
    some geographical data (with countries, their regions, and the cities in those),
    to which we'll later add something else, to work with more complex examples.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting a list of countries was easy: I used the data from [https://github.com/datasets/country-codes](https://github.com/datasets/country-codes),
    which I pruned down to just the country two-character code (as in the ISO 3166-1
    norm) and name. For regions and cities, I used GeoNames'' data from [http://download.geonames.org/export/dump/](http://download.geonames.org/export/dump/);
    in particular, I used `admin1CodesASCII.txt`, which I reworked into `regions.csv`,
    and `cities15000.zip`, which I edited into `cities.csv`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to be able to view CSV files in a clearer format, check out the
    EXCEL VIEWER extension for VSC.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you need to know about these three tables is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Countries* are identified by a two-letter code (such as *UY* for Uruguay,
    or *IN* for India), and have a name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Regions* belong to a country, and are identified by the country code, plus
    a string; in addition, they have a name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cities* are identified by a numeric code, have a name, latitude and longitude,
    population, and are in a region of a country'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is enough to get started; later, we will be adding some more tables, to
    experiment a bit more. I used `MariaDB` (the open fork of `MySQL`; see [https://mariadb.com/](https://mariadb.com/))
    and `MySQL WorkBench` (see [https://www.mysql.com/products/workbench/](https://www.mysql.com/products/workbench/))
    to create the tables and import the data, just because it's even simpler than
    doing it by hand! I also created a `fkereki` user, with `modernJS!!` as the password,
    to access the tables.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use a different database, such as PostgreSQL or Oracle, the following
    code will be quite similar, so don't worry much about dealing with a specific
    DB. If you use an ORM, you'll then see some DB-independent ways of accessing data,
    which could help should you really have to deal with different DB products.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to access a `MariaDB` database, we will install the `mariasql` package
    from [https://github.com/mscdex/node-mariasql](https://github.com/mscdex/node-mariasql)
    and then promisify its `.query()` method, to work in an easier fashion. Installation
    is accomplished with `npm install mariasql --save` and, after a short while (you
    will see some object code being built), the package will be installed. Follow
    the steps mentioned next.
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility would be to use `mariasql-promise` from [https://github.com/steelbrain/mariasql-promise](https://github.com/steelbrain/mariasql-promise),
    all of whose methods already return promises. However, getting the connection
    object and storing it for later use is harder with this library, and that's why
    I opted for the original one; after all, we only need to modify `.query()` to
    return a promise.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s have some constants that we will be using later; apart from the
    `Flow` and strict usage lines, we just require the `MariaDB` library, the `promisify()`
    function, and we define four constants to access the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s get a database connection. We just create a new object, and `promisify`
    its `.query()` method. The `dbConn` variable will be passed as a parameter to
    every function that will need to access the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Executing some queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple way of testing if the connection works is by executing a trivial query
    that returns a constant value; what really matters here is that the function should
    work without throwing any exceptions. We use `await` to get the result of the
    `.query()` method, that is an array with all the found rows; in this case, the
    array will obviously have a single row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try something else: what about finding the ten countries that have more
    cities? We can use `.forEach()` to list the results in a frankly not-very-attractive
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Updating the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s do some updates. We will first add a new (invented!) country;
    we will then check whether it exists; we will update it and check the changes,
    then we will proceed to delete it, and finally we''ll verify that it''s gone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Getting everything together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we have to do now, to get a complete working example, is just call the
    three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I added a script to automate running all tests, by doing `npm run
    start-db`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze how the code works, and remark on some interesting points.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running `tryDbAccess()` isn''t hard to figure out: the constant query goes
    to the server, and an array with a single row comes back. The output of our code
    would have been as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The second query gets more interesting. Apart from the details of actually
    writing the SQL query (which is beyond the objectives of this book) the interesting
    point is the returned array, each with an object with the selected fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's get to the last example. We are seeing several ways of creating the
    statement that will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `INSERT` uses a prepared statement. A good way to prepare safe queries
    (meaning, they cannot be involved in SQL injection hacks) is by using prepared
    strings. The `.prepare()` method is interesting: given a string, it returns a
    function, that when called with the actual parameters to use, will itself return
    the string to use in the query. Of course, you can also build the function by
    hand, as I did in the other examples—but then it''s up to you to make sure that
    the resulting query is safe!'
  prefs: []
  type: TYPE_NORMAL
- en: The `.escape()` method can help building a safe query string, if you don't want
    to use `.prepare()`. See more at [https://github.com/mscdex/node-mariasql](https://github.com/mscdex/node-mariasql).
  prefs: []
  type: TYPE_NORMAL
- en: 'The subsequent `SELECT` uses a string created by hand (nothing too original
    here) but the `UPDATE` shows another style: using `?` symbols as *placeholders*.
    In that case, you must also provide an array of values that will replace the placeholders;
    it''s fundamental that the order of the values in the array matches the expected
    arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the second `SELECT` also uses placeholders, but adds a tweak: passing
    an object with the `useArray:true` option, the function performs a tad faster,
    because it doesn''t create objects for each row, and simply returns arrays. This
    has a problem, however, because now you have to remember what each position of
    the array means.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of the code are as expected: first a single line, showing that
    a country was actually created, with the values we passed; then, the same record
    but with a changed name, and finally a zero showing that the country doesn''t
    exist any more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we have gone through several examples of accessing a database
    to perform varied operations on it, by means of a direct connection, working with
    tables and cursors. You could also consider using an **Object-Relational Mapping**
    (**ORM**) library, to work with objects instead: the best known possibility is
    probably `Sequelize` (at[ http://docs.sequelizejs.com/](http://docs.sequelizejs.com/))
    but there are some more packages (such as `TinyORM`, `Objection.js`, or `CaminteJS`,
    just to mention some which are still in development, not abandoned).'
  prefs: []
  type: TYPE_NORMAL
- en: Executing external processes with exec()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are implementing some service with `Node`, there may be occasions in
    which you require to do some heavy processing, and that, as we have mentioned
    before, is a *no-no* because you will block all users. If you need to do this
    kind of work, `Node` lets you offload the work to an external process, freeing
    itself and becoming available for continuing work. The external process will work
    on its own, in an asynchronous fashion, and when it is done, you will be able
    to process its results. There are several ways of doing this; let's go into them.
  prefs: []
  type: TYPE_NORMAL
- en: The first option to run a separate command is the `child_process.exec()` method.
    This will spawn a shell, and execute a given command in it. Whatever output is
    generated will be buffered, and when the command finishes execution, a callback
    function will be called with either the produced output, or an error.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example of calling an external process, by accessing the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An example, to get a directory listing of all JS files at a given path, could
    be as follows. (Yes, of course you could and should do this using `fs.readDir()`,
    but we want to show how to do it with a child process.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the *Using Promises instead of error first callbacks* section earlier
    in this chapter, we will `promisify()` the call, to simplify coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we call the `.exec()` method, a separate shell is created, and the command
    runs in it. If the call is successful, the output will be returned; otherwise,
    an object with a `.stderr` property will be thrown as an exception. A possible
    couple of runs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter for `.exec()` provides an object with possible options.
    In our case, we are specifying the current working directory (`cwd`) for the command.
    Another interesting option can let you work with commands that produce lots of
    output. By default, the maximum buffered output will be 200K; if you need more,
    you'll have to add an object with the `maxBuffer` option set to a larger value;
    check [https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback](https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback) for
    more on these and other options.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no limit to the complexity of the command that you can execute, but
    there''s also a risk. Keep in mind the possibility of being hacked: if you are
    building up your command based on some input provided by an user, you could be
    on the end of a command injection attack. Imagine you wanted to build something
    such as ``ls ${path}`` and the user had provided `"/; rm -rf *"` as the `path`;
    what would happen?'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `.exec()` is very good for short commands, with little output. If you
    don't actually need the shell, you can do even better with `.execFile()`, which
    runs the desired command directly, without first creating a shell and then running
    the command in it. See [https://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback](https://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback)
    for more information on this.
  prefs: []
  type: TYPE_NORMAL
- en: Using spawn() to run a command, and communicating with it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `.exec()` is simple, but you are limited to small-sized outputs, and
    you cannot also get a partial answer: let''s see more about this. Imagine you
    are preparing a large file to be sent to a client. If you were to read that file
    with `.exec()`, you wouldn''t be able to start sending the file contents to a
    client until you had read all the file. However, if the file were too large, that
    would not only imply a delay, but also the possibility of a crash. Using `.spawn()`
    gives you an interesting addition: the possibility of using streams to communicate,
    in a bidirectional way, with the spawned process.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `.spawn()` is similar to `.exec()` in general terms. Let's now use a separate
    process to read a directory and send its results back. We will be passing the
    path we want to process using a stream, and we'll get the list of found files
    also through streaming.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s have the main code, which will spawn a process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish, we need the child process, which would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spawned processes show yet another case of events. The process stays there,
    waiting, and the `"data"` event is fired whenever the process receives any data
    via the `stdin` input, as done through the `child.stdin.write("/home/fkereki")`
    line. Then, the process reads the directory, with `fs.readdirSync()`, a synchronous
    call you shouldn't use in normal `Node` code, but that is safe in a subprocess,
    because it won't block anything. The results of the call are sorted, filtered
    to avoid hidden files, and then lines are written to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar fashion to the child process, the parent process listens to events
    coming from the child's `stdout`. Whenever data arrives (`"data"` events are fired)
    it is simply logged with `console.log()`. When the child signals that no more
    data will be coming, by performing `process.stdout.end()`, the `"end"` event is
    fired, and the parent recognizes it, and can do whatever it wants.
  prefs: []
  type: TYPE_NORMAL
- en: This way of spawning processes thus allows for bidirectional communication between
    the parent and child processes, which could be used in many different forms.
  prefs: []
  type: TYPE_NORMAL
- en: Using fork() to run Node commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Child_process.fork()` method is a special case of `.spawn()`, which specifically
    only spawns new `Node` processes. The spawned child process has a communication
    channel built in that makes it even simpler to pass messages between the parent
    process and itself: you just use the `.send()` method to send a message, and listen
    to the `"message"` event on the other side. Let''s see how to fork off a second
    process, and communicate with the first one.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the code of the previous section used `.spawn()` to launch a new `Node`
    instance and run some code, it's fairly obvious that we can quickly and simply
    adjust it to use `.fork()` instead. Also, we won't have to use `stdin` and `stdout`
    to communicate, opting for messaging instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s start with the parent code. It would become the following; the
    key differences are the usage of `.fork()` instead of `.spawn()`, and the way
    that the file path is sent to the child process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the child code would also show small variations, in the way messages
    are received, and data is sent to the parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `.fork()` implies that the child process is a `Node` process, so instead
    of expressly mentioning it, as we did in the previous section, we just have to
    pass the name of the JS file to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The second difference, as we mentioned, is that instead of using `stdin` and
    `stdout` for communication, we can `.send()` a message (in any direction, from
    parent to child or vice versa) and we listen to the `"message"` event instead
    of the `"data"` one.
  prefs: []
  type: TYPE_NORMAL
- en: If you analyze the highlighted differences in code, you'll realize that the
    differences are really minor, and for the special (but not uncommon) case of needing
    to run a separate `Node` process, `.fork()` is more appropriate, and possibly
    a tad simpler to use.
  prefs: []
  type: TYPE_NORMAL
