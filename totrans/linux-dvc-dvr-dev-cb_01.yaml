- en: Installing the Development System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will present and set up our working platform. In fact, even
    if we write and then test our own device drivers on our working PC, it is recommended
    to use a second device to test the code. This is because we're going to work in
    the kernel space where even a little bug can cause severe malfunctioning! Also,
    using a platform where several kinds of peripherals are available allows us to
    test a large variety of devices that are not always available on a PC. Of course,
    you are free to use your own system to write and test your drivers but, in this
    case, you should take care of the modifications needed to fit your board specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, I''m going to use the **Marvell ESPRESSObin** system, which is
    a powerful **Advanced RISC Machines **(**ARM**) 64-bit machine with a lot of interesting
    features. In the following figure, you can see the ESPRESSObin alongside a credit
    card and can gain an idea about the real dimensions of the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cd2a298-bcef-4ffd-8782-d274bab23e70.png)'
  prefs: []
  type: TYPE_IMG
- en: My board is the v5 release of ESPRESSObin while the latest version at the time
    of writing (announced on September 2018) is v7, so the reader should be able to
    get this new release by the time this book is published. The new ESPRESSObin v7
    will feature 1GB DDR4 and 2GB DDR4 configurations (while v5 has DDR3 RAM chips),
    and a new 1.2GHz chipset will replace the currently sold configurations, which
    sports 800MHz and 1GHz CPU frequency limits. Even by taking a quick look at the
    new board layout, we see that a single SATA connector has taken the place of the
    existing two-pieces combination of SATA power and interface, the LED layout is
    now rearranged in a row, and an on-board eMMC is now in place. Moreover, this
    new revision will ship with an optional 802.11ac + Bluetooth 4.2 mini PCIe Wi-Fi
    card, which is sold separately.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you will now have the option to order your v7 ESPRESSObin with a complete
    enclosure. This product has FCC and CE certifications to help to enable mass deployment.
    Further information regarding the revision v7 (and v5) can be found at [http://wiki.espressobin.net/tiki-index.php?page=Quick+User+Guide](http://wiki.espressobin.net/tiki-index.php?page=Quick+User+Guide).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test our new drivers, we will cover the following recipes in this
    first chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the host machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the serial console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and building the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the target machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing native compiling on foreign hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are some interesting URLs where we can get useful technical information
    regarding the board:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The home page: [http://espressobin.net/](http://espressobin.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation wiki: [http://wiki.espressobin.net/tiki-index.php](http://wiki.espressobin.net/tiki-index.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Forums: [http://espressobin.net/forums/](http://espressobin.net/forums/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Taking a look at the technical specifications at [http://espressobin.net/tech-spec/](http://espressobin.net/tech-spec/),
    we get the following information where we can see what the ESPRESSObin v5 can
    offer in terms of computational power, storage, networking, and expandability:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **System on chip** (**SoC**) | Marvell Armada 3700LP (88F3720) dual core
    ARM Cortex A53 processor up to 1.2GHz |'
  prefs: []
  type: TYPE_TB
- en: '| System memory | 1 GB DDR3 or optional 2GB DDR3 |'
  prefs: []
  type: TYPE_TB
- en: '| Storage | 1x SATA interface 1x micro SD card slot with footprint for an optional
    4GB EMMC |'
  prefs: []
  type: TYPE_TB
- en: '| Network connectivity | 1x Topaz Networking Switch 2x GbE Ethernet LAN'
  prefs: []
  type: TYPE_NORMAL
- en: 1x Ethernet WAN
  prefs: []
  type: TYPE_NORMAL
- en: 1x MiniPCIe slot for wireless/BLE peripherals |
  prefs: []
  type: TYPE_NORMAL
- en: '| USB | 1x USB 3.0 1x USB 2.0'
  prefs: []
  type: TYPE_NORMAL
- en: 1x micro USB port |
  prefs: []
  type: TYPE_NORMAL
- en: '| Expansion | 2x 46-pin GPIO headers for accessories and shields with I2C,
    GPIOs, PWM, UART, SPI, MMC, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Misc | Reset button and JTAG interface |'
  prefs: []
  type: TYPE_TB
- en: '| Power supply | 12V DC jack or 5V via micro USB port |'
  prefs: []
  type: TYPE_TB
- en: '| Power consumption | Less than 1W thermal dissipation at 1 GHz |'
  prefs: []
  type: TYPE_TB
- en: 'In particular, the following screenshot shows the top view of the Marvell ESPRESSObin
    v5 (from now on, please take into account that I''m not going to explicitly add
    "v5" anymore):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c50fb9d8-fdad-4677-ab8b-5931067dcbb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, we can see the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: The power connector (12V DC jack)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reset switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The micro USB device port (serial console)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethernet ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The USB host ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next screenshot shows the bottom view of the board where the microSD slot
    is located; this is where we should plug in the microSD we''re going to create
    later on in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a93e27f-64bf-41e2-99b0-d6164c1bc1db.png)'
  prefs: []
  type: TYPE_IMG
- en: In this book, we'll see how we can manage (and reinstall) a complete Debian
    distribution, something that will allow us to have a wide set of ready-to-run
    software packages, as in a normal PC (in fact, the Debian ARM64 version is equivalent
    to the Debian x86 version). Afterward, we will develop our device drivers for
    the board, and then, when possible, we will test them with real devices connected
    to the ESPRESSObin itself. A little tutorial about how to set up the host system
    is also present in this chapter, and you can use it to set up a GNU/Linux-based
    working machine or a dedicated virtual one.
  prefs: []
  type: TYPE_NORMAL
- en: The code and other files used in this chapter can be downloaded from GitHub
    at [https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_01](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_01).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the host machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As every good device driver developer knows, a host machine is absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the embedded devices are getting more powerful nowadays (and the ESPRESSObin
  prefs: []
  type: TYPE_NORMAL
- en: is one of these), there are some resource-consuming tasks where a host machine
    can help.
  prefs: []
  type: TYPE_NORMAL
- en: That's why, in this section, we're going to show how to set up our host machine.
  prefs: []
  type: TYPE_NORMAL
- en: The host machine we decide to use could be a normal PC or a virtualized one—they
    are equivalent—but the important thing is that it must run a GNU/Linux-based OS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, I will use an Ubuntu 18.04 LTS based system but you can decide
    to try to replicate some settings and installation commands that we will use during
    the course of this book into another major Linux distribution, with little effort
    for a Debian derivative, or in a bit more of a complicated manner in the case
    of non-Debian derivative distributions.
  prefs: []
  type: TYPE_NORMAL
- en: I'm not going to show how to install a fresh Ubuntu system on a PC nor on a
    virtualized machine since it's a really easy task for a real programmer; however,
    as the last step of this chapter (the *Doing native compiling on foreign hardware*
    recipe), I will introduce, with detailed steps about how to install it, an interesting
    cross-platform environment that proved useful to compile foreign target code on
    the host machine as we were on the target. This procedure is very useful when
    we need several different OSes running on your development PC.
  prefs: []
  type: TYPE_NORMAL
- en: So, at this point, the reader should have their own PC running (natively or
    virtualized) a fresh installed Ubuntu 18.04 LTS OS.
  prefs: []
  type: TYPE_NORMAL
- en: The main usage of a host PC is to edit and then cross-compile our new device
    drivers and to manage our target device via the serial console, to create its
    root filesystem, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do it properly, we need some basic tools; some of them are general
    while others depend on the specific platform onto which we are going to write
    our drivers.
  prefs: []
  type: TYPE_NORMAL
- en: General tools are surely an editor, a version control system, and a compiler
    and its related components, while specific platform tools are essentially the
    cross-compiler and its related components (on some platforms we may need additional
    tools but our mileage may vary and, in any case, each manufacturer will give us
    all of the needed requirements for a comfortable compilation environment).
  prefs: []
  type: TYPE_NORMAL
- en: 'About the editor: I''m not going to spend any words on it because the reader
    can use whatever they want (regarding myself, for example, I''m still programming
    with vi editor) but regarding others tools, I''ll have to be more specific.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our GNU/Linux distribution is up and running on our host PC we can
    start to install some programs we''re going to use in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s install the basic compiling tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you know already, the `sudo` command is used to execute a command as a privileged
    user. It should be already present in your system, otherwise you can install it
    by using the `apt install sudo` command as the root user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to test the compiling tools. We should be able to compile a C
    program. As a simple test, let''s use the following standard *Hello World* code
    stored in the `helloworld.c` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Remember that code can be downloaded from our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we should be able to compile it by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we used both the compiler and the `make` tool, which
    is required to compile every Linux driver in a comfortable and reliable manner.
  prefs: []
  type: TYPE_NORMAL
- en: You can get more information regarding `make` by taking a look at [https://www.gnu.org/software/make/](https://www.gnu.org/software/make/),
    and for `gcc`, you can go to [https://www.gnu.org/software/gcc/](https://www.gnu.org/software/gcc/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can test it on the host PC, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to install the cross-compiler. Since we''re going to work
    with an ARM64 system, we need a cross-compiler and its related tools. To install
    them, we simply use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can also use an external toolchain as reported in the ESPRESSObin
    wiki at [http://wiki.espressobin.net/tiki-index.php?page=Build+From+Source+-+Toolchain](http://wiki.espressobin.net/tiki-index.php?page=Build+From+Source+-+Toolchain);
    however, the Ubuntu toolchain works perfectly!
  prefs: []
  type: TYPE_NORMAL
- en: 'When the installation is complete, test our new cross-compiler by using the
    preceding *Hello World* program, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that I've removed the previously compiled `helloworld` program in order
    to be able to correctly compile this new version. To do so, I used the `mv helloworld
    helloworld.x86_64` command due to the fact I'll need the x86 version again.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that since Ubuntu doesn't automatically create the standard cross-compiler
    name, `aarch64-linux-gnu-gcc`, we have to do it manually by using the preceding
    `ln` command before executing `make`.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, now we can verify that newly created version of the `helloworld` program
    for ARM64 by using the following `file` command. This will point out which platform
    the program is compiled for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we again use the `file` command on the previously renamed version, `helloworld.x86_64`,
    we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To test whether this new release is really for the ARM64 platform, we can use
    **QEMU**, which is an open source and generic machine emulator and virtualizer
    that is able to execute foreign code on the running platform. To install it, we
    can use `apt` command as in the preceding code, specifying the `qemu-user-static`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can execute our ARM64 program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To get further information about QEMU, a good staring point is its home page
    at [https://www.qemu.org/](https://www.qemu.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to install the version control system. We must install the
    version control system used for the Linux project, that is, `git`. To install
    it, we can use the following command in a similar manner as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything works well, we should be able to execute it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this book, I'm going to explain every `git` command used but for complete
    knowledge of this powerful tool, I suggest you start reading [https://git-scm.com/](https://git-scm.com/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information regarding Debian's packages management, you can surf
    the internet, but a good starting point is at [https://wiki.debian.org/Apt,](https://wiki.debian.org/Apt)
    while regarding the compiling tools (`gcc`, `make`, and other GNU software), the
    best documentation is at [https://www.gnu.org/software/](https://www.gnu.org/software/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the best place for better documentation about `git` is at [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2),
    where the wonderful book *Pro Git* is available online!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the serial console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already stated (and as any real programmer of embedded devices knows), the
    serial console is a must-have during the device drivers development stages! So,
    let's see how we can get access to our ESPRESSObin through its serial console.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in the screenshot in the *Technical requirements* section, a micro
    USB connector is available and it's directly connected with ESPRESSObin's serial
    console. So, using a proper USB cable, we can connect it to our host PC.
  prefs: []
  type: TYPE_NORMAL
- en: If all connections are OK, we can execute any serial Terminal emulator to see
    data from the serial console. Regarding this tool, I have to state that, as editor
    program, we can use whatever we prefer. However, I'm going to show how to install
    two of the more used Terminal emulation programs—`minicom` and `screen`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this tool is not strictly required and its usage depends on the platform
    you're going to work on; however, in my humble opinion, this is the most powerful
    development and debugging tool ever! So, you definitely need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `minicom`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to install the Terminal emulator named `screen`**,** we just have to replace
    `minicom` string with the `screen` packet name, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Both of them need a serial port to work on and the invocation command is quite
    similar. For brevity, I'm going to report their usage to get connected with the
    ESPRESSObin only; however, for further information about them, you should refer
    to their man pages (use `man minicom` and `man screen` to show them).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test the serial connection with our target system we can do the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to locate the right serial port. Since the ESPRESSObin
    uses an USB emulated serial port (at 115,200 baud rate), usually our target port
    is named `ttyUSB0` (but your mileage may vary, so let''s verify it before continuing)
    so the `minicom` command we have to use to get connected with the ESPRESSObin
    serial console is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To correctly get access to the serial console, we may need proper privileges.
    In fact, we may try to execute the preceding `minicom` command, and we don''t
    get an output! This is because the `minicom` command silently exits if we don''t
    have enough privileges to get access to the port. We can verify our access to
    privileges by simply using another command on it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ cat /dev/ttyUSB0`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`cat: /dev/ttyUSB0: Permission denied`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the `cat` command perfectly tells us what''s wrong so we can
    fix this issue using `sudo` or, even better, by properly adding our system''s
    user to the right group as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ ls -l /dev/ttyUSB0`** `crw-rw---- 1 root dialout 188, 0 Jan 12 23:06 /dev
    /ttyUSB0`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ sudo adduser $LOGNAME dialout`**'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we log out and log in again, and we can access the serial devices without
    any problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent command by using `screen` is reported as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that, on `minicom`, I didn't specify the serial communication options (baud
    rate, parity, and so on) while, for `screen`, I've added the baud rate on the
    command line; this is because my default `minicom` configuration automatically
    uses correct communication options while `screen` uses 9,600 baud as a default
    baud rate. Please refer to the program man pages for further information about
    how to do this setting in order to fit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything works well, after executing your Terminal emulator on the right
    serial port, turn on our ESPRESSObin (simply by plugging in the power). We should
    see the following output on our Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information about how to get connected with the ESPRESSObin serial
    port, you can take a look at its wiki section about serial connections at [http://wiki.espressobin.net/tiki-index.php?page=Serial+connection+-+Linux](http://wiki.espressobin.net/tiki-index.php?page=Serial+connection+-+Linux).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and building the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to download the kernel sources and then configure and build
    them. This step is needed for several reasons: the first one is that we need a
    kernel for our ESPRESSObin in order to boot an OS, and the second one is that
    we need a configured kernel sources tree to compile our drivers into.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since our ESPRESSObin is now supported into vanilla kernel since the 4.11 release,
    we can get Linux sources by using the following `git` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This command will take a lot of time to finish so I would suggest you take a
    break by drinking your favorite cup of coffee (as real programmers should do).
  prefs: []
  type: TYPE_NORMAL
- en: 'When finished, we can enter into the `linux` directory to see the Linux sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'These sources are related to the latest kernel release that could be unstable,
    so to be sure that we''re using a stable kernel release (or a *long-term release*),
    let''s extract release 4.18, which is the current stable release at time of writing
    this chapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting the compilation, we have to configure the kernel and our compiling
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last task is quite easy and it consists of executing the following environment
    variables assignments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can select the ESPRESSObin standard kernel configuration by simply
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the kernel release you're using, the default configuration file
    may be also called `mvebu_defconfig` or either `mvebu_v5_defconfig` or `mvebu_v7_defconfig`.
    So, please take a look into the `linux/arch/arm64/configs/` directory in order
    to see which file is present that best suits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my system, I have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ ls linux/arch/arm64/configs/`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`defconfig`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wish to modify this default configuration, we can execute the `make menuconfig`
    command, which will show us a pretty menu where we can enter our modifications
    in order to fit our needs. The following screenshot shows how the kernel configuration
    menu appears on the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b6ceb4e-3a6e-4ace-b9f6-6eca264c1138.png)'
  prefs: []
  type: TYPE_IMG
- en: Before continuing, we must be sure that the **Distributed Switch Architecture**
    (**DSA**) is enabled into the kernel, otherwise we're not able to use the Ethernet
    ports at all! This is because the ESPRESSObin has a complex (and really powerful)
    internal network switch that must be managed by using this special support.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For further information regarding the DSA, you can start reading the `linux/Documentation/networking/dsa/dsa.txt`
    file, located in the kernel sources we're currently working on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable DSA support, just navigate into the kernel menu at Networking support.
    Go to Networking options and, at the end, enable the entry Distributed Switch
    Architecture support. After that, we have to go back to the menu''s top level
    and then select these entries: Device Drivers | Network device support | Distributed
    Switch Architecture drivers and then enable Marvell 88E6xxx Ethernet switch fabric
    support, which is the ESPRESSObin''s on-board switch chip.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that, to enable a kernel feature as a module or a built-in, you need
    to highlight the desired feature and then press the spacebar until the character
    inside the <> characters changes to * (which means built-in, that is, <*>) or
    to M (which means module, that is, <M>).
  prefs: []
  type: TYPE_NORMAL
- en: Note that, to enable DSA as a built-in instead of as a module, we have to disable
    802.1d Ethernet Bridging support (that is, the entry just above).
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, after all kernel settings are in place, we can start the kernel compilation
    by using the following `make` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, as the downloading command, this command will need a lot of time to
    finish, so let me suggest you take another break. However, in order to speed up
    the compilation process, you may try using the `-j` option argument in order to
    tell `make` to use several simultaneous process to compile the code. For example,
    on my machine, having eight CPU threads, I use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ make -j8 Image dtbs modules`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s try using the following `lscpu` command to get how many CPUs your
    system has:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`lscpu | grep ''^CPU(s):''`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`CPU(s): 8`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, on Ubuntu/Debian, there''s also the pre-installed `nproc` utility,
    so the following command also does the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ make -j$(nproc)`**'
  prefs: []
  type: TYPE_NORMAL
- en: When finished, we should have the kernel image into the `arch/arm64/boot/Image`
    file and the device tree binary into the `arch/arm64/boot/dts/marvell/armada-3720-espressobin.dtb`
    file, which are ready to be transferred into the microSD we're going to build
    in the next recipe, *Setting up the target machine*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information regarding available ESPRESSObin's kernel releases and
    how to get them and compile and install them, just take a look at ESPRESSObin's
    wiki pages at [http://wiki.espressobin.net/tiki-index.php?page=Build+From+Source+-+Kernel](http://wiki.espressobin.net/tiki-index.php?page=Build+From+Source+-+Kernel).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the target machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time to install whatever we needed on our target system; since the
    ESPRESSObin is sold with just the bootloader, we have to do some work in order
    to get a fully functional system with a proper OS.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I'm going to use a Debian OS for the ESPRESSObin but you may use
    other OSes as reported at [http://wiki.espressobin.net/tiki-index.php?page=Software+HowTo](http://wiki.espressobin.net/tiki-index.php?page=Software+HowTo).
    On this site, you can get more detailed information about how to properly set
    up your ESPRESSObin to fit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if the ESPRESSObin can boot from different media, we're going to use a
    microSD since it's the most easy and useful way to set up the system. For different
    media, please refer to the ESPRESSObin's wiki pages—see [http://wiki.espressobin.net/tiki-index.php?page=Boot+from+removable+storage+-+Ubuntu](http://wiki.espressobin.net/tiki-index.php?page=Boot+from+removable+storage+-+Ubuntu)
    for some examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up the microSD, we have to use our host PC, so plug it in and then locate
    the corresponding device.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re using an SD/microSD slot, as soon as we plug the media in, we''ll
    get something like this in the kernel messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To get kernel messages on the Terminal, we can use the `dmesg` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we''re going to use a microSD to USB adapter kernel, messages will
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Another easy way to locate the media is by using the `lsblk` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s now obvious that our microSD card is here listed as `/dev/mmcblk0` but
    it is not empty. Since we want to clear everything from it, we have to clear it
    first by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You may need to unmount the device before proceeding with the clearing in order
    to work safely on the media device, so let''s unmount all of the device''s partitions
    by using the `umount` command on all of them as I will do in the following with
    the only defined partition on my microSD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You have to just repeat this command for each defined partition on your microSD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a new partition, `/dev/mmcblk0p1`, on the empty SD card
    with the next command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything works well, our microSD media should appear formatted, as in
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to format it as EXT4 with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this command line works for the `e2fsprogs` version >=1.43 only!
    If you''re using an older release, you should use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ sudo mkfs.ext4 -L root /dev/mmcblk0p1`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, mount this partition on your local Linux machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, on some OSes (and especially on Ubuntu), as soon as we unplug and
    then we plug in the media device again, it is mounted automatically into `/media/$USER/root`
    where `$USER` is an environment variable holding your username. For instance,
    on my machine, I have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ ls -ld /media/$USER/root`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`drwxr-xr-x 3 root root 4096 Jan 10 14:28 /media/giometti/root/`'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Debian files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I decided to use Debian as the target OS since it''s my favorite distribution
    for development (and, when possible, for production) systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it, we use QEMU software again, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You could see warnings about keyring here; they are harmless and they can be
    safely ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '`W: Cannot check Release signature;`'
  prefs: []
  type: TYPE_NORMAL
- en: I suppose this is another coffee-break command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once finished, we should find, in `debian-stretch-arm64`, a clean Debian root
    filesystem for the ESPRESSObin but, before transferring it into the microSD, we
    should fix the `hostname` file contents as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to add the serial device `ttyMV0` to the `/etc/securetty` file
    in order to be able to log in as the root user through the serial device, `/dev/ttyMV0`.
    Use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Use `man securetty` for further information about the root login through a serial
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, as a last step, we have to set up a root password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, I used the `root` string as password for the root user (it is up to you
    to choose yours).
  prefs: []
  type: TYPE_NORMAL
- en: In order to have further information regarding this usage of the `chroot` command,
    you can use the `man chroot` command or continue reading till the end of this
    chapter where I'm going to explain a bit better how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can safely copy all files into our microSD using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what the microSD content should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Adding the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After OS files, we need also kernel images to get a running kernel and, in
    the previous section, we got the kernel image into the `arch/arm64/boot/Image`
    file and the device tree binary into the `arch/arm64/boot/dts/marvell/armada-3720-espressobin.dtb`
    file, which are ready to be transferred into our freshly created microSD:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s copy them into the `/boot` directory as done here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `/boot` directory was not present in the microSD and the preceding command
    returned an error, you can recover by using the following command and rerun the
    preceding `cp` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sudo mkdir /media/$USER/root/boot`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the `/boot` directory should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding files are sufficient to boot the system; however, to also install
    kernel modules and headers files, which are useful for compiling new software,
    we can use the next commands after all Debian files have been installed into the
    microSD (to avoid overwriting with Debian files):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Well, now we are finally ready to tie it all up and run our new Debian system,
    so let's unmount the microSD and plug it into the ESPRESSObin.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the booting variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After powering up, we should get the bootloader''s messages from the serial
    console and then we should see a timeout running to 0 before doing the autoboot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Quickly stop the countdown by hitting the *Enter* key on the keyboard to get
    the bootloader''s prompt, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The ESPRESSObin's bootloader is U-Boot, which has its home page at [https://www.denx.de/wiki/U-Boot](https://www.denx.de/wiki/U-Boot).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check again that the microSD card has the necessary files using
    the `ext4ls` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: OK, everything is in place, so there are only a few variables required to boot
    from the microSD card.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can display the currently defined variables at any point by using the `echo`
    command and optionally reconfigure them by using `setenv` command. First, check
    and set proper image and device tree paths and names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that, filenames were correct but the path names were not; that's why I
    used the `setenv` command to correctly redefine them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, define the `bootcmd` variable, which we will use to boot from the microSD
    card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We must be careful to set the preceding root path to point to where we have
    extracted the Debian filesystem (the first partition in our case).
  prefs: []
  type: TYPE_NORMAL
- en: Save the set variables at any time using the `saveenv` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we boot up the ESPRESSObin by simply typing the `reset` command and,
    if everything works well, we should see the system start and running and, at the
    end, we should get system login prompt, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, log in as root with the `root` password that was previously set up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, now our ESPRESSObin is ready to execute our code and our drivers! However,
    before ending this section, let''s take a look at the networking configuration
    since it can be further useful to log in to the board using an SSH connection
    or just to copy files from/to the board quickly (even if we can remove the microSD
    and then copy our files from the host PC directly):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking a look at available network interfaces on the ESPRESSObin, we see the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eth0` interface is the one that connects the CPU with the Ethernet switch
    while the `wan`, `lan0`, and `lan1` interfaces are the ones where we can physically
    connect our Ethernet cables (note that the system calls them `wan@eth0`, `lan0@eth0`,
    and `lan1@eth1` just to underline the fact they are slaves of `eth0`). Following
    is a photograph of the ESPRESSObin, where we can see each Ethernet port with its
    label:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef6d52cc-44e8-47c7-a928-cefca0bcfe87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Despite their names, all ports are equivalent so connect the Ethernet cable
    into one port (I''m going to use `wan`) and then enable it after `eth0`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in the preceding output, there are also kernel messages that show
    what you should see if everything is working well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can manually set an IP address or we can ask our DHCP server whatever
    we need to surf the internet with the `dhclient` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is my network configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re ready to install new software or to try to establish an SSH connection
    to the ESPRESSObin; to do so, let''s verify that we have the following SSH server''s
    configuration in the`/etc/ssh/sshd_config` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we get no output, we cannot log in as root into our ESPRESSObin, so we must
    change the `PermitRootLogin` setting to `yes` and then restart the daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on the host PC, we can try the login via SSH, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get more information regarding how to set up the ESPRESSObin even on different
    OSes, you can take a look at [http://wiki.espressobin.net/tiki-index.php?page=Software+HowTo](http://wiki.espressobin.net/tiki-index.php?page=Software+HowTo).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For further information regarding `qemu-debootstrap`, a good starting point
    is at [https://wiki.ubuntu.com/ARM/RootfsFromScratch/QemuDebootstrap](https://wiki.ubuntu.com/ARM/RootfsFromScratch/QemuDebootstrap).
    To manage Ethernet devices and for further information about networking on a Debian
    OS, you can take a look at the following: [https://wiki.debian.org/NetworkConfiguration](https://wiki.debian.org/NetworkConfiguration).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing native compiling on foreign hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before ending this chapter, I'd like to introduce an interesting cross-platform
    system that's useful when we need several different OSes running on your development
    PC. This step is very useful when we need a complete OS to compile a device driver
    or an application but we do not have a target device to compile onto. We can use
    our host PC to compile code for a foreign hardware across different OS and OS
    release.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During my career, I worked with tons of different platforms and having one virtual
    machine for all of them is very complex and really system consuming (especially
    if we decide to run several of them at the same time!). That's why it can be interesting
    to have a lightweight system that can execute foreign code on your PC. Of course,
    this method cannot be used to test a device driver (we need real hardware for
    that), but we can use it to run a native compiler and/or native userspace code
    really quickly just in case our embedded platform is not working. Let's see what
    I'm talking about.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Setting up the target machine* recipe, regarding the Debian OS installation,
    we used the `chroot` command to set up the root's password. This command worked
    thanks to QEMU; in fact, in the `debian-stretch-arm64` directory, we have an ARM64
    root filesystem, which can be executed on an x86_64 platform by using QEMU only.
    It's then clear that, in this manner, we should be able to execute whatever command
    we'd like and, of course, we will be able to execute the Bash shell as in the
    next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s time to see how `chroot` works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute an ARM64 `bash` command by using our x86_64 host, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use each ARM64 command as we did on the ESPRESSObin; for example,
    to list files into the current directory; we can use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there are some traps; for instance, we completely miss the `/proc`
    and `/sys` directories and programs, which rely on them and will fail for sure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: To resolve these problems, we can manually mount these missing directories before
    executing `chroot`, but this is quite annoying due to the fact that they are so
    many, so we can try using the `schroot` utility, which, in turn, can do all of
    these steps for us. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: For detailed information regarding `schroot`, you can see its man pages with
    `man schroot`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring schroot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This task is quite trivial in Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we install the program in the usual way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to configure it in order to correctly enter into our ARM64 system.
    To do so, let''s copy the root filesystem created before into a dedicated directory
    (where we can also add any other distributions we wish to emulate with `schroot`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must create a proper configuration for our new system by adding a
    new file into the `schroot` configuration directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `directory` parameter is set to the path holding our ARM64 system
    and `users` is set to `giometti`, which is my username (this is a comma-separated
    list of users that are allowed access to the `chroot` environment—see `man schroot.conf`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the preceding settings, we see that the `profile` parameter is set
    to `desktop`; this means that it will be taking into account all files in the
    `/etc/schroot/desktop/` directory. In particular, the `fstab` file holds all mount
    points we''d like to be mounted into our system. So, we should verify that it
    holds at least the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to restart the `schroot` service, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can also restart using the old-fashioned way:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ sudo /etc/init.d/schroot restart`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can list all available environments by asking them to `schroot`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, everything is in place and we can enter into the emulated ARM64 system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Since we haven't installed any locale support, the preceding warning is quite
    obvious and it should be safely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to verify we''re really executing ARM64 code, let''s try some commands.
    For example, we can ask for some system information with the `uname` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the system says that its platform is `aarch64`, which is ARM64\.
    Then, we can try to execute our `helloworld` program that was cross-compiled before;
    since, after `chroot`, the current directory is not changed (and our home directory
    is still the same), we can simply go back where we did the compilation and then
    execute the program as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The program still executes as when we were on an ARM64 system. Great!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the emulated OS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we just saw about `schroot` is nothing if we do not configure our new
    system to do native compilation, and to do so, we can use every Debian tool we
    use on our host PC:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install a complete compiling environment, we can issue the following command
    once inside the `schroot` environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note that `sudo` will ask your usual password, that is, the password you currently
    use to log in to your host PC.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might not get a password request from `sudo` with the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo: no tty present and no askpass program specified`'
  prefs: []
  type: TYPE_NORMAL
- en: You can try executing the preceding `sudo` command again, adding to it the `-S`
    option argument.
  prefs: []
  type: TYPE_NORMAL
- en: It could be possible that the `apt` command will notify you that some packages
    cannot be authenticated. Just ignore this warning and continue installation, answering
    yes by pressing the *Y* key.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything works well, we should now be able to execute every compiling
    command we used before. For instance, we can try to recompile the `helloworld`
    program again but natively (we should remove the current executable in order;
    `make` will try to recompile it again):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note that networking support is fully functional so we're now working on an
    emulated ARM64 environment on our hosts PC as we were on the ESPRESSObin.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the internet, there are several examples regarding `schroot` usage and a
    good starting point is [https://wiki.debian.org/Schroot](https://wiki.debian.org/Schroot).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
