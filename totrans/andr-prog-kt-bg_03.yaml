- en: Chapter 3. Exploring Android Studio and the Project Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create and run two more Android projects. The purpose
    of these exercises is to explore Android Studio and the structure of Android projects
    more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: When we build our apps ready for deployment, the code and the resource files
    need to be packed away as they are in the APK file. Therefore, all the layout
    files and other resources, which we will be looking at soon, need to be in the
    correct structures.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Android Studio handles this for us when we create a project from
    a template. However, we still need to know how to find and amend these files,
    how to add our own and sometimes remove the files created by Android Studio, and
    how the resource files are interlinked – sometimes with each other, and sometimes
    with the Kotlin code (that is, the autogenerated Kotlin code, as well as our own).
  prefs: []
  type: TYPE_NORMAL
- en: Along with understanding the composition of our projects, it will also be beneficial
    to make sure that we get the most from the emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Emulators are particularly useful when you want to make sure that your app will
    work on hardware that you don't own. Also, learning about some of the latest features
    (as we will in this book) often requires the latest handset, and an emulator is
    a cost-effective way of following along with all the mini-apps without buying
    the latest phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the file and folder structure of the **Empty Activity** project template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the difference between the **Empty Activity** and the **Basic Activity**
    templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out how to get the most from the emulator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will leave us in a good position to build and deploy multiple different
    layouts in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A quick guided tour of Android Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, take a look at this annotated diagram of Android Studio. We
    will reacquaint ourselves with the parts that we have already seen, and learn
    about the parts that we have not yet discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A quick guided tour of Android Studio](img/B12806_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It will be useful to formally point out and name the various parts of the Android
    Studio **User Interface** (**UI**), so that I can refer to them by name, rather
    than describing their location and showing screenshots all the time. So, let''s
    run through them from number **1**:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the **Project** window and will be the main focus of this chapter. It
    enables us to explore the folders, code, and resources of the project and is also
    referred to as the Project Explorer window. Double-click on a file here to open
    the file and add a new tab to area **3** on the diagram. The structure of the
    files and folders here closely resembles the structure that will eventually end
    up in the finished APK file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we will see, while the structure of folders for an Android project remains
    the same, the files, filenames, and contents of the files vary considerably. Therefore,
    we will explore two projects in this chapter, and then look at more projects as
    we progress through the book.
  prefs: []
  type: TYPE_NORMAL
- en: This is the **Editor** window. As we have already seen, the **Editor** window
    takes on a few different forms depending on what it is that we are editing. If
    we are editing Kotlin, then we can see our code neatly formatted and ready for
    editing; if we are designing a UI, then it offers us either a visual editing view
    or a text/XML code view. You can also view and edit graphics and other files in
    this window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These tabs allow us switch between the different files in our project. The **Editor**
    window will display the file we select here. We can add another tab to this section
    by double-clicking on the file in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This allows us to switch between the **Design** and **Text** (code) view on
    the file that is currently being edited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This window varies depending upon the option selected in part **6** of the diagram.
    Typically, in this book, we will switch between the **Build** window to see that
    our project has been compiled and launched without errors, and the **Logcat**
    window to view the debugging output and any errors or crash reports from our apps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This area of the UI is used to switch between the different displays described
    in part **5**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are even more tabs in Android Studio, but we won't need them in the context
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to unambiguously refer to the various parts of the UI,
    let's turn our attention to the **Project**/**Project Explorer** window.
  prefs: []
  type: TYPE_NORMAL
- en: Project Explorer and project anatomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a new Android project, we most often do so with a project template,
    just as we did in [Chapter 1](ch01.html "Chapter 1. Getting Started with Android
    and Kotlin"), *Getting Started with Android and Kotlin*. The template that we
    use determines the exact selection and contents of the files that Android Studio
    will generate. While there are big similarities across all projects that are worth
    noting, seeing the differences can also help. Let's build two different template
    projects and examine the files, their contents, and how they are all linked together
    through the code (XML and Kotlin).
  prefs: []
  type: TYPE_NORMAL
- en: The Empty Activity project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest project type with an autogenerated UI is the **Empty Activity**
    project. Here, the UI is empty, but it is ready to be added to. It is also possible
    to generate a project without a UI at all. When we create a project, even with
    an empty UI, Android Studio autogenerates the Kotlin code to display the UI. Therefore,
    when we add to it, it is ready to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an **Empty Activity** project. This is almost the same process
    as we did in [Chapter 1](ch01.html "Chapter 1. Getting Started with Android and
    Kotlin"), *Getting Started with Android and Kotlin*, but with one slight difference
    that I will point out:'
  prefs: []
  type: TYPE_NORMAL
- en: In Android Studio, select **File** | **New** | **New Project…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Choose your project** screen, select the **Empty Activity** template
    and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Name** field to `Empty Activity App`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the same package name and save location as the previous project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to select **Kotlin** as the language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Use AndroidX artifacts** checkbox as we did previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The remaining settings can be left to their default settings, so just click
    on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android Studio will generate all the code and other project resources. Now we
    can see what has been generated and compare it to what we expected in the project
    explorer window.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the emulator is not already running, launch it by selecting **Tools** |
    **AVD Manager** and then start your emulator in the **Android Virtual Devices**
    window. Run the app on the emulator by clicking on the play button in the quick
    launch bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Empty Activity project](img/B12806_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a look at the app and notice how it is a little bit different to that
    of the first project. It is, well, empty; there is no menu at the top, and no
    floating button at the bottom. It does, however, still have the **Hello World!**
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't worry about referring to the first project; we will build another one
    just like it soon.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Empty Activity project](img/B12806_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have a brand new **Empty Activity App** project, let's explore the
    files and folders that Android Studio has generated for us.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Empty Activity project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it is time to go on a deep dive into the files and folders of our app.
    This will save us lots of time and head-scratching later in the book. Please note,
    however, that there is no need to memorize where all these files go, and there
    is even less need to understand the code within the files. In fact, parts of the
    XML code will remain a mystery at the end of the book, but it will not stop you
    from designing, coding, and releasing amazing apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the project explorer window after the project is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the Empty Activity project](img/B12806_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the two arrows indicated in the previous screenshot. These, as you probably
    can guess, allow us to expand the `app` and `Gradle Scripts` folders.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We do not need to explore the `Gradle Scripts` folder in the context of this
    book. Gradle is a significant part of Android Studio, but its role is to hide
    the quite-complicated processes that Android Studio performs from the user, such
    as adding resource files, and compiling and building projects. Therefore, we don't
    need to dig into this any further. If, however, you decide to take Android to
    the next level, then gaining a good understanding of Gradle and its relationship
    with Android Studio is time well invested.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the `app` folder in more detail. Click on the arrow next to
    the `app` folder to expand its contents and we will begin exploring. The first
    level of contents is displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the Empty Activity project](img/B12806_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have revealed three more folders: `manifests`, `java`, and `res`. Let''s
    take a closer look in all three, starting at the top.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will keep our Kotlin code in the `java` folder. Additionally, since the release
    of Android Studio version 3.3, there is also a folder named `generatedjava` ,
    but we don't need to explore it.
  prefs: []
  type: TYPE_NORMAL
- en: The manifests folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `manifests` folder has just one file inside it. Expand the `manifests`
    folder and double-click on the `AndroidManifest.xml` file. Notice that the file
    has been opened in the editor window and a tab has been added so that we can easily
    switch between this and other files. The following screenshot shows the new tab
    that has been added, as well as the XML code contained in the `AndroidManifest.xml`
    file within the `manifests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The manifests folder](img/B12806_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We don't need to understand everything in this file, but it is worth pointing
    out that we will make occasional amendments here, for example, when we need to
    ask the user for permission to access some features of their device, such as the
    messaging app or the images folder. We will also edit this file when we want to
    make a fullscreen app for immersion, such as for a game.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the structure of the file is very similar to the structure of the
    layout file that we saw in the previous chapter. For instance, there are clearly
    denoted sections that start with `<section name` and end with `</section name>`.
    Real examples of this are `<application` and `</application>`, and `<activity`
    and `</activity>`.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, the entire file contents, apart from the first line, are wrapped in
    `<manifest` and `</manifest>`.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that we enter the brackets of a calculation into a calculator,
    these opening and closing parts must match or the file will cause an error in
    our project. Android Studio indents (that is, places tabs) in front of the lines
    to make the sections and their depth in this structure clearer.
  prefs: []
  type: TYPE_NORMAL
- en: A number of specific parts of this code are worth noting, so I will point out
    some of the lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line tells Android that the icon that we want to show the user
    in their app drawer/home screen, and with which they can launch the app, is contained
    in the `mipmap` folder and is called `ic_launcher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will verify this for ourselves as we continue our exploration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line has two aspects that are worth discussing. First, it denotes
    the name that we gave our app; and second, this name is contained as a **String**
    with a label of `app_name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In programming, including Kotlin and XML, a String can be any alphanumeric value.
    We will learn more about Strings throughout the book, starting in [Chapter 7,](ch07.html
    "Chapter 7. Kotlin Variables, Operators, and Expressions") *Kotlin Variables,
    Operators, and Expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: We can, therefore, guess that the alphanumeric value of the label of `app_name`
    is `Empty Activity App`, because that is what we called the app when we created
    it.
  prefs: []
  type: TYPE_NORMAL
- en: This might sound unusual, but we will see this file shortly along with its label.
    And, in later projects, we will add more labels and values to it. We will also
    come to understand the reasons why we add text to our apps in what might, at this
    stage, seem like a convoluted manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could discuss every line in the `AndroidManifest.xml` file, but we don''t
    need to. Let''s take a look at another two lines as they are related to each other.
    The following line indicates the name of our Activity, which was auto-generated
    when we created the project. I have highlighted the Activity name just to make
    it stand out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line, which appears within the `<activity` and `</activity>`
    tags, denotes that it is an attribute of the `activity` file. This tells us that
    this Activity is the one that should run when the app is started; it is the `LAUNCHER`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This implies that our apps can have more than one Activity. Very often, if you
    have an app with multiple screens, such as a home screen or settings screen, those
    screens are built from multiple Activity class **instances**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In XML, such as the `AndroidManifest` file, `activity` is in lowercase; but
    in Kotlin, the `Activity` class has an uppercase `A`. This is just convention
    and it is nothing to be concerned about.
  prefs: []
  type: TYPE_NORMAL
- en: As you have just seen, `activity` in XML has a `name` attribute with a value
    that refers to an instance of a Kotlin `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now dig into the `java` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The java folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we will find all the Kotlin code. To begin with, this consists of just
    one file, but as our projects grow further, we will add more. Expand the `java`
    folder and you will find three more folders, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The java folder](img/B12806_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For this book, we will only need one of these three folders; that is, the top
    one. The names of these folders are composed of the package name (chosen when
    we created the app), and the app name, presented in lowercase and with no spaces
    (this was also chosen when we created the app).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason there is more than one folder with the same name is due to automated
    testing, which is beyond the scope of this book. Therefore, you can safely ignore
    the folders that end with `(androidTest)` and `(test)`.
  prefs: []
  type: TYPE_NORMAL
- en: The only folder that we are interested in for this book is the top folder, which
    for this app (on my screen) is `com.gamecodeschool.emptyactivityapp`. Depending
    on your chosen package name and the name of the app that we are currently working
    on, the folder name will change, but it will always be the top folder that we
    need to access and add or edit the contents of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expand the `com.gamecodeschool.emptyactivityapp` (or whatever yours is called)
    folder now to view its contents. In the following screenshot, you can see that
    the folder has just one file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The java folder](img/B12806_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is the `MainActivity.kt` file, although the file extension isn't shown in
    the project window, even though it is in the tab above the editor window. In fact,
    all the files in the `java/packagename.appname` folder for this book will have
    the `.kt` extension.
  prefs: []
  type: TYPE_NORMAL
- en: If you double-click on the `MainActivity.kt` file, it will open in the editor
    window, although we could have just clicked on the `MainActivity.kt` tab above
    the editor window. As we add more Kotlin files to our project, knowing where they
    are kept will be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Examine the `MainActivity.kt` file and you will see that it is a simplified
    version of the Kotlin file that we worked with in the first project. It is the
    same, except that there are fewer functions and less code in the `onCreate` function.
    The functions are missing because the UI is simpler, and they are not needed;
    therefore, Android Studio didn't generate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, take a look at the contents of the `MainActivity.kt` file in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The java folder](img/B12806_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The file still has the `onCreate` function, which runs when the app is run,
    but there is much less code in it, and `onCreate` is the only function. Take a
    look at the last line of code in the `onCreate` function, which we will discuss
    before moving on to explore the `res` folder. Here is the line of code under discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code is calling a function named `setContentView` and is passing some data
    into `setContentView` for the code in the `setContentView` function to make use
    of. The data being passed to `setContentView` is `R.layout.activity.main`.
  prefs: []
  type: TYPE_NORMAL
- en: For now, I will just mention that the `setContentView` function is provided
    by the Android API and is the function that prepares and displays the UI to the
    user. So, what exactly is `R.layout.activity_main`?
  prefs: []
  type: TYPE_NORMAL
- en: Let's find out by exploring the `res` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The res folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `res` folder is where all the resources go. Left-click to expand the `res`
    folder and we will examine what''s inside. Here is a screenshot of the top level
    of folders inside the `res` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The res folder](img/B12806_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's begin with the top of the list; that is, the `drawable` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The res/drawable folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name gives things away a little bit, but the `drawable` folder holds much
    more than just graphics. As we progress through this book, we will indeed add
    graphics to this folder; however, for now, it holds just two files.
  prefs: []
  type: TYPE_NORMAL
- en: These files are `ic_launcher_foreground` and `ic_launcher_background`. We will
    not examine these files because we will never need to alter them, but I will quickly
    mention what they are.
  prefs: []
  type: TYPE_NORMAL
- en: If you open the files, you will see that they are quite long and technical.
    They include lists of coordinates, colors, and more. They are what is known as
    a **graphical mask**.
  prefs: []
  type: TYPE_NORMAL
- en: They are used by Android to adapt or mask other graphics; in this case, the
    launcher icon of the app. The files are instructions to Android on how to adapt
    the app launcher icon.
  prefs: []
  type: TYPE_NORMAL
- en: This system is made available so that different device manufacturers can create
    their own masks to suit their own Android devices. The masks, which are in the
    `drawable` folder by default (`ic_launcher_foreground` and `ic_launcher_background`),
    are default adaptive masks that add visually pleasing shadows and depth to the
    launcher icon.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the concept of adaptive icons is interesting to you, then you can refer to
    a full and a very visual explanation on the Android developer's website at [https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive](https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know enough about `drawable`, let's move on to `layout`.
  prefs: []
  type: TYPE_NORMAL
- en: The res/layout folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Expand the `layout` folder and you will see our familiar layout file that we
    edited in the previous chapter. There is less in it this time because we generated
    an Empty Activity project. It is not entirely empty, as it still holds a `ConstraintLayout`
    layout wrapping a `TextView` widget that says `Hello World!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to look at the contents – you should find that it looks as you might
    expect, but it is not the contents that are of interest here. Take a closer look
    at the name of the file (without the XML file extension): `activity_main`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now think back to the Kotlin code in the `MainActivity.kt` file. Here is the
    line of code that sets up the UI; I have highlighted a portion of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `R.layout.activity_main` code is indeed a reference to the `activity_main`
    file within the `res`/`layout` folder. This is the connection between our Kotlin
    code and our XML layout/design.
  prefs: []
  type: TYPE_NORMAL
- en: There is a difference in the first project; in the `layout` folder of the first
    project, there is an additional file. Later in this chapter, we will build another
    project using the same template (Basic Activity) that we used in the first chapter
    to understand why.
  prefs: []
  type: TYPE_NORMAL
- en: Before doing that, let's explore the final two folders and all their subfolders,
    starting with the next in the list, `mipmap`.
  prefs: []
  type: TYPE_NORMAL
- en: The res/mipmap folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `mipmap` folder is straightforward – that is, *fairly* straightforward.
    Expand the folder to see its contents, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The res/mipmap folder](img/B12806_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can see two subfolders; they are `ic_launcher` and `ic_launcher_round`.
    The contents of `ic_launcher` include the graphics for the regular launcher icon
    we see in the app drawer/home screen of the device, while `ic_launcher_round`
    holds the graphics for the devices that use round icons, as opposed to square
    icons. Double-click on one of the `.png` files from each folder to have a look.
    I have photoshopped one of each side by side in this screenshot to aid our discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The res/mipmap folder](img/B12806_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You are probably also wondering why there are five `ic_launcher….png` files
    in each folder. The reason for this is that it is good practice to provide icons
    that are suitably scaled for different sizes and resolutions of the screen. Providing
    an image with the `hdpi`, `mdpi`, `xhdpi`, `xxhdpi`, and `xxxhdpi` qualifications
    allows different Android devices to choose the icon that will look best for the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The letters `dpi` stands for **dots-per-inch**, and the `h`, `m`, `xh`, `xxh`,
    and `xxxh` prefixes stand for high, medium, extra high, extra extra high, and
    so on. These are known as **qualifiers** and you will see as you progress throughout
    this book that Android has lots of qualifiers, which help us to build our apps
    to suit the wide range of different devices available for users to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: The final conundrum from the `mipmap` folder is that there is also an XML file
    in each of the two subfolders. Open one of them up and you will see that they
    refer to the `ic_launcher_foreground` and `ic_launcher_background` files that
    we looked at in the `drawable` folder. This tells the Android device where to
    get the details for the adaptive icons. These files are not required, but they
    make the icons look better, as well as add flexibility to the appearance.
  prefs: []
  type: TYPE_NORMAL
- en: We have one more folder and all its files to explore, and then we will finally
    understand the structure of an Android app.
  prefs: []
  type: TYPE_NORMAL
- en: The res/values folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the `res`/`values` folder to reveal three files that we will talk about
    briefly in turn. All these files interlink and refer to each other and other files
    that we have seen already.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completeness, here is a screenshot of the three files in the
    `res`/`values` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The res/values folder](img/B12806_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The key to understanding is not in memorizing the connections, and certainly
    not in trying to memorize or even understand the code in the files, but rather
    to get an appreciation of the interlinked nature of all the files and code we
    have seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: Let's glance inside the files one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The colors.xml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, take a look at the contents of the `colors.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the starting and closing tags take the usual pattern we have come
    to expect from XML files. There is an opening `<resources>` tag and a closing
    `</resources>` tag. As children of resources, there are three pairs of `<color>
    … </color>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Within each `color` tag is contained a `name` attribute and some curious-looking
    code consisting of numbers and letters. The `name` attribute is the name of a
    color. We will see, in another file that follows, that the various names in this
    file are referred to from another file.
  prefs: []
  type: TYPE_NORMAL
- en: The code is what defines an actual color itself. Therefore, when the name is
    referred to, the color defined by the related code is what is produced on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code is called a hexadecimal code, because in each position of the code,
    the values `0` through `9` and the letters `a` through to `f` can be used, giving
    16 possible values. If you want to find out more about hex `colors`, visit [http://www.color-hex.com/color-wheel/](http://www.color-hex.com/color-wheel/).
    If you are intrigued about number bases, such as hexadecimal (base 16), binary
    (base 2), and others, then look at this article, which explains them and discusses
    why humans typically use base 10: [https://betterexplained.com/articles/numbers-and-bases/](https://betterexplained.com/articles/numbers-and-bases/).'
  prefs: []
  type: TYPE_NORMAL
- en: We will see where these names are referred to later.
  prefs: []
  type: TYPE_NORMAL
- en: The strings.xml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most modern apps are made for as wide an audience as possible. Furthermore,
    if the app is of significant size or complexity, then the roles in the software
    company are often divided up into many different teams. For example, the person
    writing the Kotlin code for an Android app very possibly had little to do with
    designing the layout of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: By separating the content of the app from the programming of the app, it is
    easier to make changes at any time, and it is also possible to create content
    for multiple different languages without altering the Kotlin code for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following contents of the `strings.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see that, within the now familiar `<resources>…</resources>` tags, there
    is a `<string>…</string>` tag. Within the `string` tag, there is an attribute
    called `name` with an `app_name` value and then a further value of `Empty Activity
    App`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at one more line from the `AndroidManifest.xml` file that we explored
    earlier in The manifests folder section. The line in question is displayed in
    the following code, but refer to the file itself in Android Studio if you want
    to see the line in its full context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `android:label` attribute is being assigned a value of `@string/app_name`.
    In Android, `@string` refers to all the strings in the `strings.xml` file. In
    this specific app, the `string` attribute with the `app_name` label has the `Empty
    Activity App` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the line of code in the `AndroidManifest.xml` file shown previously
    has the following effect on the screen when the app is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The strings.xml file](img/B12806_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While this system might seem convoluted at first, in practice, it separates
    design and content from coding, which is very efficient to do. If the designers
    want to change the name of the app, they simply edit the `strings.xml` file. There
    is no need to interact with the Kotlin programmers, and, if all the text in an
    app is provided as string resources, then all of it can be easily altered and
    adapted as the project proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: Android takes the flexibility further by allowing developers to use different
    files for string resources for each language and locale. This means that a developer
    can cater to a planet full of happy users with exactly the same Kotlin code. The
    Kotlin programmer just needs to refer to the `name` attribute of a string resource
    instead of **hardcoding** the text itself, and then the other departments can
    design the text content and handle tasks such as translation. We will make an
    app multilingual in [Chapter 18,](ch18.html "Chapter 18. Localization") *Localization*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to hardcode the actual text directly into the Kotlin code, instead
    of using string resources, and most of the time, we will do so for the sake of
    easily demonstrating some Kotlin code without getting bogged down with editing
    or adding to the `strings.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: We know enough about `strings.xml` to move on to the final file that we will
    explore for the Empty project template.
  prefs: []
  type: TYPE_NORMAL
- en: The styles.xml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here, you can see the pieces of the interconnectivity puzzle for this project
    template finally come together. Study the code in the `styles.xml` file and we
    can then discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is yet another resource file, but it is referring to the `colors.xml` file
    that we saw earlier. Notice that there is a `style` tag, which is enclosing multiple
    `item` tags; each `item` tag has a name, such as `colorPrimary`, `colorPrimaryDark`,
    or `colorAccent`. Then, each of these names is assigned a value, such as `@color/colorPrimary`.
  prefs: []
  type: TYPE_NORMAL
- en: You are probably wondering what is going on; `@color` refers to the `colors.xml`
    file, and `colorPrimary`, `colorPrimaryDark`, and `colorAccent` refer to the actual
    colors defined with their hexadecimal values in that file. But why bother to create
    the colors and give them names, and then in another file define `item` instances
    and assign those colors to `item` instances? Why not just assign hexadecimal color
    values directly to each `item`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the top of the code block to understand the reason behind this
    apparently unnecessary convolutedness. I have shown the relevant lines of code
    again, so that we can discuss them more easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What is going on is that items have been defined and the items are contained
    within a `style` element. As you can see, the style is called `AppTheme`. Furthermore,
    the style has a parent called `Theme.AppCompat.Light.DarkActionBar`.
  prefs: []
  type: TYPE_NORMAL
- en: The system allows designers to choose a selection of colors and then define
    them in the `colors.xml` file. They can then further build up styles that use
    those colors in different combinations – there will often be more than one style
    per app. A style can further be associated with a theme (`parent = "…"`). This
    parent theme can be one completely designed by the styles and colors of the app
    designers, or it can be one of the default themes of Android, such as `Theme.AppCompat.Light.DarkActionBar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI designers can then simply refer to a style in the `AndroidManifest.xml`
    file, like in this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: UI designers can then happily tweak the colors and where they are used (items)
    without interfering with the Kotlin code. This also allows for different styles
    to be created for different regions of the world without any changes to the actual
    layout file (in this case, `activity_main.xml`).
  prefs: []
  type: TYPE_NORMAL
- en: For example, in Western culture, green can represent themes such as nature and
    correctness; and in many Middle Eastern countries, green represents fertility
    and is the color associated with Islam. While you might just get away with distributing
    green in both of these regions, your app will be perceived very differently.
  prefs: []
  type: TYPE_NORMAL
- en: If you then roll your app out in Indonesia, you will find that green is culturally
    despised among many (although not all) Indonesians. Next, if you launch in China,
    you will find that green has potential negative connotations to do with unfaithful
    spouses. It is a minefield that the typical programmer will never learn to navigate.
    And, fortunately, because of the way we can divide up responsibilities in Android
    Studio, they don't need to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, colors, styles, and themes are very specialized topics. While we
    won't be exploring any more deeply than that quick foray into green, hopefully
    you can see the benefit of a system that separates responsibility for programming,
    layout, color, and textual content.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I thought it is also worth mentioning at this point that images can also be
    divided up into different locales so that users in different regions see different
    images within the same app. And, if you are wondering, yes, that will mean supplying
    different resolutions (such as `hdpi` and `xhdpi`, and so on) for each locale
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning that it is entirely possible to produce a fantastic
    app that is enjoyed by thousands or even millions of users without catering individually
    to every region. However, even if we are not going to employ teams of designers,
    translators, and cultural experts, we must still work within this system that
    was designed to enable them, and that is why we are going into such depth.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we have a good grasp of what goes in an Android project and how
    it all links together. Let's now build one more app to see the differences that
    different app templates make to the underlying files that Android Studio generates.
  prefs: []
  type: TYPE_NORMAL
- en: The Basic Activity project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next simplest project type with an autogenerated UI is the Basic Activity
    project. This is the same type of project that we created in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Android and Kotlin"), *Getting Started with Android
    and Kotlin*. Feel free to open that project up now, but it is recommended to generate
    a new one so that we can examine it without any of our alterations and additions
    clouding the discussions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a Basic Activity project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In Android Studio, select **File** | **New** | **New Project…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Choose your project** screen, select the **Basic Activity** template
    and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Name** field to `Basic Activity App`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the same package name and save the location as in the previous project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to select **Kotlin** as the language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Use AndroidX artifacts** checkbox as we did previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the settings can be left at their defaults, so just click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can dig into the files. We won't look at everything in the same detail
    that we did for the Empty Activity project; we will just look at the differences
    and extra bits.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Basic Activity project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's compare the Kotlin code first. Take a look at the `MainActivity.kt` tab
    in the code editor. They both contain a class called `MainActivity`. The difference
    is in the number of functions and the content of the `onCreate` function.
  prefs: []
  type: TYPE_NORMAL
- en: As already stated, the Basic Activity project has more to it than the Empty
    Activity project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can open as many instances of Android Studio as you like. If you want to
    compare projects side by side, select **File** | **Open** and choose the project,
    then when prompted, select **New Window** to open the project without closing
    any that are already open.
  prefs: []
  type: TYPE_NORMAL
- en: The first difference is that there is some extra code in the `onCreate` function.
  prefs: []
  type: TYPE_NORMAL
- en: The MainActivity.kt file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mentioned very briefly, back in [Chapter 2](ch02.html "Chapter 2. Kotlin,
    XML, and the UI Designer"), *Kotlin, XML, and the UI Designer*, the interconnections
    that exist in the Kotlin code and the XML code. Let's look through the resources
    files and point out the XML files that this Kotlin code points to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the relevant Kotlin code from the `onCreate` function; I have slightly
    reformatted it to make it more readable in a book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Understanding this code fully will take quite a few more chapters, but to point
    out where this code uses files in the resources will only take a moment, and will
    then leave us even more aware of the components that make up our projects.
  prefs: []
  type: TYPE_NORMAL
- en: The code refers to two more resources compared to the Empty Activity project.
    The first is `toolbar`, the second is `fab`, and both refer to an XML file that
    we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the `res`/`layout` folder in the project window, you can see that
    things look slightly differently to how they did in the Empty Activity project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MainActivity.kt file](img/B12806_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are now two files that were autogenerated. We will explore the `content_main.xml`
    file and gain an understanding of why it is required shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The activity_main.xml file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For now, open up the `activity_main.xml` file and you will see there are some
    elements to represent both `toolbar` and `fab`. By referring to these elements,
    the Kotlin code is setting up the toolbar and the floating action bar ready for
    use. The XML code, as we have come to expect, describes what they look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the XML code for the toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it refers to a `Toolbar`, a color, and a style, as well as some
    others. It is the line that starts with `android:id…`, which declares a widget
    of type `Toolbar` and its `@+id/toolbar` value, which makes it accessible via
    the `toolbar` instance name in the Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For clarity, this is the toolbar in the actual working app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity_main.xml file](img/B12806_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the XML code for the floating action button. I have slightly reformatted
    the first line of the code onto two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it has an `id` attribute of `fab`. It is through this `id` attribute
    that we gain access to the floating action button in our Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, `fab` in our Kotlin code can directly control the floating action button
    and all its attributes. In [Chapter 13,](ch13.html "Chapter 13. Bringing Android
    Widgets to Life") *Bringing Android Widgets to Life*, we will learn how to do
    this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the floating action button in the actual app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity_main.xml file](img/B12806_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is evident that I haven''t explained the code in detail; there is no point
    at this stage. Instead, make a mental note of the interconnections, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: XML files can refer to other XML files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin can refer to XML files (and, as we will see soon, other Kotlin files).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Kotlin, we can grab control of a specific part of the UI in an XML file via
    its `id` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have seen enough from this file; let's move on and dip into the remaining
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The extra functions in MainActivity.kt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, what do the functions do, when are they called, and who exactly calls them?
  prefs: []
  type: TYPE_NORMAL
- en: 'The next difference is this extra function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code prepares (inflates) the menu that is defined in the `menu_main.xml`
    file. And, just as with `onCreate`, the function is overridden and it is called
    by the operating system directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then there is yet another function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This function is also overridden and is called directly by the operating system.
    It handles what happens `when` an item (or option) from the menu is selected by
    the user. At the moment, it handles just one option, which is the settings option,
    and it currently takes no action.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code determines whether the settings menu option was clicked on;
    if it was, then the `return` when code executes, and control is returned to whatever
    part of the app was executing before it was interrupted by the user clicking on
    the **Settings** menu option. We will learn more about the Kotlin `when` keyword
    in [Chapter 8](ch08.html "Chapter 8. Kotlin Decisions and Loops"), *Kotlin Decisions
    and Loops*.
  prefs: []
  type: TYPE_NORMAL
- en: We nearly know enough for now; don't worry about memorizing all these connections.
    We will be coming back to each connection, investigating more deeply, and cementing
    our understanding of each.
  prefs: []
  type: TYPE_NORMAL
- en: So, why do we need that second file in the `res`/`layout` folder?
  prefs: []
  type: TYPE_NORMAL
- en: The content_main.xml file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `MainActivity.kt` file calls `setContentView` on `R.layout.activity_main`.
    Then, in turn, `activity_main` has this line of code highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line of code does `include` the `content_main` file. So, just
    after the app bar is added to the layout, the execution branches to `content_main`,
    where all its XML code is turned into the UI; then, the execution goes back to
    `activity_main` and the floating action bar is added to the layout. We will use
    `include` in [Chapter 5,](ch05.html "Chapter 5. Beautiful Layouts with CardView
    and ScrollView") *Beautiful Layouts with CardView and ScrollView*, when we build
    some neat scrolling `CardView` layouts and separate the code that defines `CardView`
    from the actual contents of `CardView`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Android emulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we progress, it helps to be familiar with exactly how to use the Android
    emulator. If you haven't used the latest version of Android, some of the ways
    to achieve even simple tasks (such as viewing all the apps) can be different to
    how your current device works. In addition, we want to know how to use the extra
    controls that come with all emulators.
  prefs: []
  type: TYPE_NORMAL
- en: The emulator control panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You probably noticed the mini control panel that appears beside the emulator
    when you run it. Let''s go through some of the most useful controls. Take a look
    at this screenshot of the emulator control panel. I have annotated it to aid the
    discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The emulator control panel](img/B12806_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I will just mention the more obvious controls and go into a bit more depth
    when necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: These are the window controls. They minimize or close the emulator window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From top to bottom, the first button is used to power-off the emulator, to simulate
    powering off the actual device. The next two icons raise and lower the volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These two buttons allow you to rotate the emulator both left and right. This
    means that you can test what your app looks like in all orientations, as well
    as how it handles orientation changes while the app is running. The icons immediately
    underneath these take a screenshot and zoom in, respectively. Here is the emulator
    after being rotated horizontally:![The emulator control panel](img/B12806_03_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These icons simulate the back button, home button, and view running apps button.
    Have a play with these buttons – we will need to use them from time to time, including
    in [Chapter 6](ch06.html "Chapter 6. The Android Lifecycle"), *The Android Lifecycle*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the button labelled **5** in the annotated image to launch the advanced
    settings menu, where you can interact with things such as sensors, GPS, the battery,
    and the fingerprint reader. Have a play around with some of these settings if
    you are curious:![The emulator control panel](img/B12806_03_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's play around with the emulator itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using the emulator as a real device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The emulator can emulate every feature of a real phone, so it is possible to
    write a whole book on it alone. If you want to write apps that your users love,
    then understanding a whole range of Android devices is well worth taking the time
    to do. I just want to point out a few of the most basic features here, because
    without these basic interactions, it will be hard to follow along with the book.
    Furthermore, if you have an old Android device, then some essential basics (such
    as accessing the app drawer) have changed and you might be left a little baffled.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the app drawer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hold the mouse cursor on the bottom of the home screen and drag upward to access
    the app drawer (with all the apps); the following screenshot shows this action
    halfway through:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the app drawer](img/B12806_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can run any app installed on the emulator. Note that when you run one
    of your apps through Android Studio, it remains installed on the emulator and,
    therefore, is runnable from the app drawer. However, every change you make to
    the app in Android Studio will require you to run or install the app again by
    clicking on the play button on the Android Studio quick launch bar, as we have
    been doing.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing active apps and switching between apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To view active apps, you can use the emulator control panel, that is, the square
    labelled as number **4** on the screenshot of the emulator control panel. To access
    the same option using the phone screen (as you will have to do on a real device),
    swipe up, just as with accessing the app drawer, but do so only for about one
    quarter of the length of the screen, as shown in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing active apps and switching between apps](img/B12806_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can now swipe left and right through the recent apps, swipe an app up to
    close it, or tap the back button to return to what you were doing before you viewed
    this option. Do try this out, as we will use these basic features quite often
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that the goal of this chapter was to familiarize ourselves with the
    system and structure of Android and an Android project. Android projects are an
    elaborate interweaving of Kotlin and a multitude of resource files. Resource files
    can contain XML to describe our layouts, textual content, styles, and colors,
    as well as images. Resources can be produced to target different languages and
    regions of the world. Other resource types that we will see and use throughout
    the book include themes and sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: It is not important to remember all the different ways in which the different
    resource files and Kotlin files are interconnected. It is only important to realize
    that they *are* interconnected, and also be able to examine files of various types
    and realize when they are dependent on code in another file. Whenever we create
    connections from our Kotlin code to the XML code, I will always point out the
    details of the connection again.
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to learn XML in addition to Kotlin, but we will become a little
    bit familiar with it over the next 25 chapters. Kotlin will be the focus of this
    book, but our Kotlin code will frequently refer to the XML code, so understanding
    and having seen some examples of the interconnections will put you in good stead
    to make quicker progress.
  prefs: []
  type: TYPE_NORMAL
- en: We have also explored the emulator to get the most out of it when testing our
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build three custom layouts using three different
    Android layout schemes. We will also write some Kotlin code so that we can switch
    between them with the tap of a button.
  prefs: []
  type: TYPE_NORMAL
