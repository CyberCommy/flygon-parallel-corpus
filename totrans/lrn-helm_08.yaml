- en: '*Chapter 6*: Testing Helm Charts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a common task that engineers must perform during software development.
    Testing is performed to validate the functionality of a product as well as to
    prevent regressions as a product evolves over time. Well-tested software is easier
    to maintain over time and allows developers to more confidently provide new releases
    to end users.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Helm chart should be properly tested in order to ensure that it delivers
    its features to the level of quality expected. In this chapter, we will discuss
    the ways that robust Helm chart testing can be achieved, including the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying Helm templating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing in a live cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving chart tests with the chart testing project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will use the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minikube`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yamllint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yamale`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chart-testing` (`ct`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to these tools, you can follow along with the samples in the Packt
    GitHub repository located at [https://github.com/PacktPublishing/-Learn-Helm](https://github.com/PacktPublishing/-Learn-Helm),
    which will be referenced throughout this chapter. In many of the example commands
    used throughout this chapter, we will reference the Packt repository, so you may
    find it helpful to clone this repository by running the `git clone` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's proceed with setting up your local `minikube` environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will create and run a series of tests for the `Guestbook`
    chart created in the previous chapter. Run the following steps to set up your
    `minikube` environment, where we will test the Guestbook chart:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start `minikube` by running the `minikube start` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new namespace called `chapter6`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With your `minikube` environment ready, let's begin by discussing how Helm charts
    can be tested. We will begin the discussion by outlining the methods you can use
    to verify your Helm templates.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying Helm templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built a Helm chart from scratch. The final product
    was quite complex, containing parameterization, conditional templating, and life
    cycle hooks. Since one of the primary purposes of Helm is to create Kubernetes
    resources, you should ensure that your resource templates are generated properly
    before they are applied to a Kubernetes cluster. This can be done in a variety
    of ways, which we will discuss in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Validating template generation locally with helm template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first way to validate your chart's templating is to use the `helm template`
    command, which can be used to render a chart template locally and display its
    fully rendered contents in the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `helm template` command has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command renders a template locally, using the `NAME` argument to satisfy
    the `.Release` built-in object and the `CHART` argument for the chart that contains
    the Kubernetes templates. The `helm-charts/charts/guestbook` folder in the Packt
    repository can be used to demonstrate the functionality of the `helm template`
    command. This folder contains the chart that was developed in the previous section
    as well as additional resources that will be used later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Render the `guestbook` chart locally by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this command will display each of the Kubernetes resources that
    would be created if they were applied to the cluster, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The ConfigMap for the guestbook chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – "helm template" output
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot displays the beginning portion of the output from the
    `helm template` command as executed against the Guestbook chart created in the
    previous chapter. As you can see, a fully rendered `ConfigMap` is shown along
    with the beginning of another `ConfigMap` that was created with the release. Rendering
    these resources locally provides you with an idea of the exact resources and specifications
    that would be created if the release was installed against a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: During chart development, you may want to use the `helm template` command regularly
    to validate that your Kubernetes resources are being generated properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common aspects of chart development that you would want to validate include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: That parameterized fields are successfully replaced by default or overridden
    values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That control actions such as `if`, `range`, and `with` successfully generates
    YAML files based on the provided values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That resources contain proper spacing and indentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That functions and pipelines are used correctly to properly format and manipulate
    the YAML file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That functions such as `required` and `fail` properly validate values based
    on user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With an understanding of how chart templates can be rendered locally, let's
    now dive into some of the specific aspects that you can test and validate by leveraging
    the `helm template` command.
  prefs: []
  type: TYPE_NORMAL
- en: Testing template parameterization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to check that your template's parameters are successfully populated
    with values. This is important because your charts will likely consist of multiple
    different values. You can ensure that your charts are properly parameterized by
    making sure each value has a sensible default value or has validation that fails
    chart rendering if a value is not provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the following deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Sensible defaults for the `replicas` and `port` values should be defined in
    the chart''s `values.yaml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the `helm template` command against this template resource renders
    the following deployment, replacing the `replicas` and `port` values with their
    defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from `helm template` allows you to verify that your parameters are
    properly replaced by their default values. You can also verify that the provided
    values are overridden successfully by passing the `--values` or `--set` arguments
    to the `helm template` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting template reflects your provided values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: While values with the default settings defined are often simple to test with
    `helm template`, it is more important to test values that require validation as
    invalid values can prevent your chart from installing properly.
  prefs: []
  type: TYPE_NORMAL
- en: You should use `helm template` to ensure that values with restrictions, such
    as those that only allow particular inputs, are successfully validated with the
    `required` and `fail` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the following deployment template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If this deployment belongs to a chart with the same `values` file defined in
    the previous code block and you expected users to provide the `imageRegistry`
    and `imageName` values to install the chart, if you then use the `helm template`
    command without providing these values, then the result is less than desirable,
    as you can see in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there was no gating in place, the rendered result is a deployment with
    an invalid image, `/`. Because we tested this with `helm template`, we know that
    we need to handle the case where these values are not defined. This can be done
    by using the `required` function to provide validation that these values are specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `helm template` command is applied to a chart with the updated deployment
    template, the result displays a message that instructs the user to provide the
    first missing value that is encountered by the templating engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can further test this validation by providing the valid values files alongside
    the `helm template` command. For this example, we will assume the following values
    are provided in a user-managed `values` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This file can then be provided when executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As a general rule of thumb for parameterization, make sure you keep track of
    your values and ensure that each value is used in your chart. Set sensible defaults
    in the `values.yaml` file and use the `required` function in cases where defaults
    cannot be set. Use the `helm template` function to ensure that values are properly
    rendered and produce the desired Kubernetes resource configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an aside, you may also want to consider including the required values in
    your `values.yaml` file as empty fields with a comment noting that they are required.
    This allows users to view your `values.yaml` file and see all the values that
    your chart supports, including the values that they are required to provide for
    themselves. Consider the following `values` file after the `imageRegistry` and
    `imageName` values are added to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Although these values are written in your chart's `values.yaml` file, these
    values still evaluate to null when the `helm template` command runs, providing
    the same behavior as they would if they were not defined as in prior executions.
    The difference is that you can now explicitly see that these values are required,
    so you won't be taken by surprise when you attempt to install the chart for the
    first time.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how generating your chart templates locally can help you
    test your chart's control actions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the control actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides basic parameterization, you should also consider using the `helm template`
    command to verify that control actions (specifically `if` and `range`) are handled
    properly to produce the desired results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following deployment template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `env` and `enableLiveness` values are both `null`, you could test whether
    this rendering will still be successful by running the `helm template` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that both the `range` and `if` actions are not generated. Null
    or empty values do not have any entries acted on them by the `range` clause and
    these values are also evaluated as `false` when provided to the `if` action. You
    can verify that you have written your template to properly generate YAML using
    these actions by providing the `env` and `enableLiveness` values to `helm template`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add these values to a `values` file, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes made, verify the desired results of the `helm template`
    command to demonstrate that the template is written properly to consume these
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You should make sure you are in the habit of regularly rendering your templates
    with `helm template` when you add additional control structures to your charts
    as they can quickly make the chart development process more difficult, especially
    if control structures are numerous or complex.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from checking that the control structures are properly generated, you
    should also check whether your functions and pipelines are working as designed,
    which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Testing functions and pipelines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `helm template` command is also useful for validating the rendering produced
    by functions and pipelines, which are often used to produce formatted YAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following template as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This template contains a pipeline that parameterizes and formats the `resources`
    value to specify the container's resource requirements. It would be wise to include
    a sensible default in your chart's `values.yaml` file to make sure the application
    has an appropriate limit to prevent over-utilization of cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the `resources` value for this template is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You need to run the `helm template` command to ensure that this value is properly
    converted into a valid `YAML` format and that the output is properly indented
    to produce a valid deployment resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `helm template` command against this template results in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will discuss how server-side validation can be enabled when rendering
    your resources with `helm template.`
  prefs: []
  type: TYPE_NORMAL
- en: Adding server-side validation to chart rendering
  prefs: []
  type: TYPE_NORMAL
- en: 'While the `helm template` command is important to the chart development process
    and should be used frequently to verify your chart rendering, it does have a key
    limitation. The main purpose of the `helm template` command is to provide client-side
    rendering, meaning it does not communicate with the Kubernetes API server to provide
    resource validation. If you would like to ensure that your resources are valid
    after they are generated, you can use the `--validate` flag to instruct `helm
    template` to communicate with the Kubernetes API server after the resources are
    generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Any generated template that does not produce a valid Kubernetes resource provides
    an error message. Imagine, for example, a deployment template was used where the
    `apiVersion` value was set to `apiVersion: v1`. In order to produce a valid deployment,
    you must set the `apiVersion` value to `apps/v1` as that is the correct name of
    the API that serves the deployment resource. Simply setting this to `v1` will
    generate what appears to be a valid resource by the client-side rendering of `helm
    template` without the `--validation` flag, but with the `--validation` flag you
    would expect to see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `--validate` flag is designed to catch errors in your generated resources.
    You should use this flag if you have access to a Kubernetes cluster and if you
    want to determine whether or not your chart is generating valid Kubernetes resources.
    Alternatively, you can use the `--dry-run` flag against the `install`, `upgrade`,
    `rollback`, and `uninstall` commands to perform validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of using this flag with the `install` command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This flag will generate the chart's templates and perform validation, similar
    to running the `helm template` command with the `--validate` flag. Using `--dry-run`
    will print each generated resource to the command line and will not create the
    resources in the Kubernetes environment. It is primarily used by end users to
    perform a sanity check before running an installation to ensure that they have
    provided the correct values and that the installation will produce the desired
    results. Chart developers can choose to use the `--dry-run` flag in this fashion
    to test chart rendering and validation, or they can choose to use `helm template`
    to generate your chart's resources locally and provide `--validate` to add additional
    server-side validation.
  prefs: []
  type: TYPE_NORMAL
- en: While it is necessary to verify that your templates are generated the way you
    intend, it is also necessary to ensure that your templates are generated in a
    way that follows best practices to simplify development and maintenance. Helm
    provides a command called `helm lint` that can be used for this purpose, which
    we will learn more about next.
  prefs: []
  type: TYPE_NORMAL
- en: Linting Helm charts and templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linting your charts is important to prevent errors in your chart''s formatting
    or the chart''s definition file and provide guidance on best practices when working
    with Helm charts. The `helm lint` command has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `helm lint` command is designed to be run against a chart directory to ensure
    that the chart is valid and properly formatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: The `helm lint` command does not validate the rendered API schemas or perform
    linting on your YAML style, but simply checks that the chart consists of the appropriate
    files and settings that a valid Helm chart should have.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the `helm lint` command against the Guestbook chart that you created
    in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265), *Building Your
    First Helm Chart*, or against the chart under the `helm-charts/charts/guestbook`
    folder in the Packt GitHub repository at [https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/charts/guestbook](https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/charts/guestbook):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This output declares that the chart is valid, which is noted by the `1 chart(s)
    linted, 0 chart(s) failed` message. The `[INFO]` message recommends the chart
    include an `icon` field in the `Chart.yaml` file, but this is not required. Other
    types of messages include `[WARNING]`, which indicates that the chart breaks the
    chart conventions, and `[ERROR]`, which indicates that the chart will fail at
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run through a few examples. Consider a chart with the following file
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that there are issues with this chart structure. This chart is missing
    the `Chart.yaml` file that defines the chart''s metadata. The linter run against
    a chart with this structure would produce the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This error indicates that Helm cannot find the `Chart.yaml` file. If an empty
    `Chart.yaml` file is added to the chart to provide the correct file structure,
    an error will still ensue as the `Chart.yaml` file contains invalid contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the linter against this chart would produce the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This output lists the required fields that are missing from the `Chart.yaml`
    file. It indicates that the file must contain the `name`, `apiVersion`, and `version`
    fields, so these fields should be added to the `Chart.yaml` file to produce a
    valid Helm chart. The linter provides additional feedback on the `apiVersion`
    and `version` settings, checking that the `apiVersion` value is set to either
    `v1` or `v2` and that the `version` setting is a proper `SemVer` version.
  prefs: []
  type: TYPE_NORMAL
- en: The linter will also check for the existence of other required or recommended
    files, such as the `values.yaml` file and the `templates` directory. It will also
    make sure that files under the `templates` directory have a `.yaml`, `.yml`, `.tpl`,
    or `.txt` file extension. The `helm lint` command is great for checking whether
    your chart contains the appropriate contents, but it does not carry out extensive
    linting on your chart's YAML style.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform this linting, you can use another tool, called `yamllint`, which
    can be found at [https://github.com/adrienverge/yamllint](https://github.com/adrienverge/yamllint).
    This tool can be installed using the `pip` package manager, across a range of
    operating systems, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It can also be installed with your operating system's package manager, as described
    in the `yamllint` quick-start instructions at [https://yamllint.readthedocs.io/en/stable/quickstart.html](https://yamllint.readthedocs.io/en/stable/quickstart.html).
  prefs: []
  type: TYPE_NORMAL
- en: In order to use `yamllint` on your chart's YAML resources, you must use it in
    combination with the `helm template` command to remove the Go templating and generate
    your YAML resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of running this command against the guestbook chart
    from the Packt GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This command will generate the resources under the `templates/` folder and pipe
    the output to `yamllint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – An example yamllint output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – An example `yamllint` output
  prefs: []
  type: TYPE_NORMAL
- en: The line numbers provided reflect the entirety of the `helm template` output,
    which can make it difficult to determine which line from the `yamllint` output
    corresponds with which line from your YAML resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can simplify this by redirecting the `helm template` output to determine
    its line numbers using the following command against the `guestbook` chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`yamllint` will lint against many different rules, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Indentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training spaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Empty lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can override the default rules by specifying your own by creating one of
    the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.yamllint`, `.yamllint.yaml`, and `.yamllint.yml` in the current working directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$XDB_CONFIG_HOME/yamllint/config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~/.config/yamllint/config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To override the indentation rule that is reported against the guestbook chart,
    you can create a `.yamllint.yaml` file in your current working directory with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration overrides `yamllint` so that it doesn''t enforce one particular
    method of indentation when adding list entries. It is configured by the `indent-sequences:
    whatever` line. Creating this file and running the linter again against the guestbook
    will eliminate the indentation errors, that were seen previously seen previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we discussed how you can validate the local rendering of your
    Helm charts by using the `helm template` and `helm lint` commands. This, however,
    does not actually test your chart's functionality or the application's ability
    to function with the resources that your chart creates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to create tests in a live Kubernetes
    environment to test your Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in a live cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating chart tests is an important part of developing and maintaining your
    Helm charts. Chart tests help verify that your chart is functioning as intended
    and they can help prevent regressions as features and fixes to your chart are
    added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing consists of two different steps. First, you need to create `pod` templates
    under your chart''s `templates/` directory that contain the helm.sh/hook`: test`
    annotation. These `pods` will run commands that test the functionality of your
    chart and application. Next, you need to run the `helm test` command, which initiates
    a `test` hook and creates resources with the aforementioned annotation.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to test in a live cluster by adding tests
    to the Guestbook chart, continuing the development of the chart you created in
    the previous chapter. As a reference, the tests that you will create can be viewed
    in the Guestbook chart in the Packt repository, located at [https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/charts/guestbook](https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/charts/guestbook).
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by adding the `test/frontend-connection.yaml` and `test/redis-connection.yaml`
    files under the `templates/` directory of your Guestbook chart. Be aware that
    chart tests do not have to be located under a `test` subdirectory, but keeping
    them there is a good way of keeping your tests organized and separated from the
    main chart templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we will populate these files with logic to validate their associated
    application components.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin writing the tests now that their placeholders have been added.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the chart tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you recall, the Guestbook chart consists of a Redis backend and a PHP frontend.
    Users enter messages in a dialog box in the frontend, and the messages are persisted
    to the backend. Let’s write a couple tests that ensure both the frontend and backend
    resources are available after an installation. We will begin with a test that
    checks the availability of the Redis backend. Add the following contents to the
    chart’s templates/test/backend-connection.yaml file (this file can also be viewed
    in the Packt repository at https://github.com/PacktPublishing/-Learn-Helm/blob/master/helm-charts/charts/guestbook/templates/test/backend-connection.yaml):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The HTTP request to the Guestbook service'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 - The backend connection test for the Guestbook Helm chart
  prefs: []
  type: TYPE_NORMAL
- en: This template defines a Pod that will be created during the test lifecycle hook.
    Also defined in this template is a hook delete policy that indicates when previous
    test pods should be removed. You could also add hook weights if the tests we will
    create needed to be run in any order.
  prefs: []
  type: TYPE_NORMAL
- en: The args field underneath the containers object displays the command that the
    test will be based on. It will use the redis-cli tool to connect to the Redis
    master and run the command MGET messages. The Guestbook frontend is designed to
    add messages entered by the user to a database key called messages. This simple
    test is designed to check that a connection to the Redis database can be made,
    and it will return the messages that a user has entered by querying the messages
    key.
  prefs: []
  type: TYPE_NORMAL
- en: The PHP frontend should also be tested for availability as well, as it is the
    user-facing component of the application. Add the following contents to the templates/test/frontend-connection.yaml
    file (these contents can also be seen in the Packt repository at https://github.com/PacktPublishing/-Learn-Helm/blob/master/helm-charts/charts/guestbook/templates/test/frontend-connection.yaml).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 - The frontend connection test for the Guestbook Helm chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.4-1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 - The frontend connection test for the Guestbook Helm chart
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simple test that runs an HTTP request to the Guestbook Service.
    Traffic sent to the Service will load-balance between Guestbook frontend instances.
    This test will check that the load balancing is being successfully performed and
    that the frontend is available.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have finished the templates needed for chart tests. Be advised that
    these templates can also be rendered locally by the helm template command and
    linted using helm lint and yamllint as described in earlier sections within this
    chapter. When developing your own Helm charts, you may find this to be useful
    for more advanced test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the tests are written, we will continue by running them in the Minikube
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Running the chart tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to run a chart''s tests, the chart must first be installed on a Kubernetes
    environment using the `helm install` command. Because the tests that are written
    are designed to run after the installation is complete, the `--wait` flag can
    be used when installing the chart so that it is easier to determine when pods
    are ready. Run the following command to install the Guestbook chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the chart is installed, you can use the `helm test` command to execute
    the `test` life cycle hook and create the test resources. The syntax for the `helm
    test` command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `helm test` command against the `my-guestbook` release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If your test is successful, you will see the following results in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When running your tests, you can also use the `--logs` flag to print your logs
    to the command line from the execution of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests again using this flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the same test summary as before, in addition to each test''s associated
    container logs. The following is the first portion of the frontend connection
    test log output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the backend connection `test` log output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The logs for this test will appear empty because you haven't yet entered any
    messages in the Guestbook frontend. You can run the test again after adding a
    message from the frontend to ensure the messages persist. Instructions to determine
    the URL of the Guestbook frontend are printed when you run both the installation
    and the `test` suites.
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions are again displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Add a message from the Guestbook application once you have accessed the frontend
    from a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The Guestbook application’s frontend'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4-1 – The Guestbook application's frontend
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `test` suite again once a message is added, providing the `--logs`
    flag to display the logs from the tests. You should be able to verify that this
    message was added by observing the backend connection `test` log output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a snippet displaying the backend connection `test` log output.
    You can verify that the message was persisted to the Redis database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we wrote simple tests that, as a whole, performed a smoke test
    on the installation of a chart. With these tests in place, we will feel more confident
    with making changes and adding features to this chart, provided that the chart
    tests run after each modification to ensure functionality is retained.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how the testing process can be improved
    by leveraging a tool called `ct`.
  prefs: []
  type: TYPE_NORMAL
- en: Improving chart tests with the chart testing project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tests written in the previous section are sufficient enough to test whether
    the Guestbook application can be successfully installed. However, there are some
    key limitations that are inherent to the standard Helm testing process that need
    to be called out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first limitation to consider is the difficulty of testing the different
    permutations that can occur within a chart''s values. Because the `helm test`
    command does not provide the ability to modify your release''s values beyond those
    set at the time of an installation or upgrade, the following workflow must be
    followed when running `helm test` against different values settings:'
  prefs: []
  type: TYPE_NORMAL
- en: Install your chart with an initial set of values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `helm test` against your release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete your release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install your chart with a different set of values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 2* through *4* until a significant amount of value possibilities
    are tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In addition to testing different value permutations, you should also make sure
    regressions do not occur when making modifications to your charts. The best way
    to prevent regressions while also testing the newer version of your chart is to
    use the following workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Install a previous chart version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrade your release to the newer chart version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the newer chart version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This workflow should be repeated against each set of value permutations to ensure
    that there are no regressions or intended breaking changes.
  prefs: []
  type: TYPE_NORMAL
- en: These processes sound tedious but imagine the additional strain and maintenance
    on chart developers when maintaining multiple different Helm charts where careful
    testing should take place. When maintaining multiple Helm charts, chart developers
    tend to favor a `git` monorepo design. A repository is considered monorepo when
    multiple different artifacts or modules are contained in the same repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Helm charts, a monorepo could have the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Helm charts in a well-maintained monorepo should be tested when they are modified
    to ensure that intended breaking changes did not occur. When a chart is modified,
    its `version` field in its `Chart.yaml` file should also be increased according
    to the correct `SemVer` versioning to denote the type of change that was made.
    `SemVer` versions follow a `MAJOR.MINOR.PATCH` version numbering format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following list as guideline for how to increase a `SemVer` version:'
  prefs: []
  type: TYPE_NORMAL
- en: Increment the `MAJOR` version if you are making a breaking change to your chart.
    A breaking change is a change that is not backward-compatible with the previous
    chart version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increment the `MINOR` version if you are adding a feature but you are not making
    a breaking change. You should increment this version if the change you are making
    is backward-compatible with the previous chart version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increment the `PATCH` version if you are making a patch to a bug or a security
    vulnerability that will not result in a breaking change. This version should be
    incremented if the change is backward-compatible with the previous chart version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without well-written automation, it can become increasingly difficult to make
    sure charts are tested when modified and that their versions are incremented,
    especially if maintaining a monorepo with multiple Helm charts. This challenge
    prompted the Helm community to create a tool called `ct` to provide structure
    and automation around chart tests and maintenance. We will discuss this tool next.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the chart testing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: T[he chart testing project, which can](https://github.com/helm/chart-testing)
    be found at [https://github.com/helm/chart-testing](https://github.com/helm/chart-testing),
    is designed to be used against charts in a `git` monorepo to perform automated
    linting, validation, and testing. The automated testing is achieved by using `git`
    to detect charts that are changed against a target branch. Charts that are changed
    should undergo a testing process, while charts that are unchanged do not need
    to be tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project''s CLI, `ct`, provides four primary commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lint`: Lints and validates charts that have been modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install`: Installs and tests charts that have been modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lint-and-install`: Lints, installs, and tests charts that have been modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list-changed`: Lists charts that have been modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `list-changed` command does not perform any validation or testing, while
    the `lint-and-install` command combines the `lint` and `install` commands to `lint`,
    `install`, and `test` modified charts. It also checks whether you have increased
    the modified charts' `version` fields in each of the charts' `Chart.yaml` files
    and fails testing for charts whose versions have not been increased but whose
    contents have been modified. This validation helps maintainers remain strict toward
    increasing their chart versions depending on the type of change made.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to checking the chart versions, chart testing provides the ability
    to specify multiple values files per chart for testing purposes. During the invocation
    of the `lint`, `install`, and `lint-and-install` commands, chart testing loops
    through each test `values` file to override the chart''s default values and to
    perform validation and testing based on the different values permutations provided.
    Test `values` files are written under a folder called `ci/` to keep these values
    separate from your chart''s default `values.yaml` file, as in the following example
    file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Chart testing applies each `values` file under the `ci/` folder, regardless
    of the name used for the file. You may find it helpful to name each `values` file
    based on the values that are overridden so that the maintainers and contributors
    can understand the file contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common `ct` command you are likely to use is the `lint-and-install`
    command. The following lists the steps that this command uses to lint, install,
    and test charts that are modified in a `git` monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: Detect the charts that have been modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the local Helm cache with the `helm repo update` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download each modified chart's dependencies with the `helm dependency build`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether each modified chart's version has been incremented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each chart that evaluates to `true` in *step 4*, lint the chart and each
    `values` file under the `ci/` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each chart that evaluates to `true` in *step 4*, perform the following
    additional steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the chart in an automatically created namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Run tests by executing `helm test`.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat for each `values` file under the `ci/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this command performs a variety of different steps to ensure
    that your charts are properly linted and tested by installing and testing each
    modified chart in a separate namespace, repeating the process for each `values`
    file defined under the `ci/` folder. However, by default, the `lint-and-install`
    command does not check for backward compatibility by performing an upgrade from
    an older version of the chart. This feature can be enabled by adding the `--upgrade`
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a breaking change is not indicated, the `--upgrade` flag modifies *step
    6* of the previous set of steps by running the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the older version of the chart in an automatically created namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run tests by executing `helm test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrade the release to the modified version of the chart and run the tests again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the modified version of the chart in a new, automatically created namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run tests by executing `helm test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrade the release again using the same chart version and rerun the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat for each `values` file under the `ci/` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is recommended that you add the `--upgrade` flag to perform additional testing
    on Helm upgrades and to prevent possible regressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: The `--upgrade` flag will not take effect if you have incremented the `MAJOR`
    version of your Helm chart as this indicates that you made a breaking change and
    that an in-place upgrade on this version would not be successful.
  prefs: []
  type: TYPE_NORMAL
- en: Let's install the chart testing CLI and its dependencies locally so that we
    can later see this process in action.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the chart testing tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use the chart testing CLI, you must have the following tools installed
    on your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`helm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git` (version `2.17.0` or later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yamllint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yamale`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chart testing uses each of these tools in the testing process. `helm` and `kubectl`
    were installed in [*Chapter 2*](B15458_02_Final_JM_ePub.xhtml#_idTextAnchor098),
    *Preparing a Kubernetes and Helm Environment*, Git was installed in [*Chapter
    5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265), *Building Your First Helm
    Chart*, and yamllint was installed at the beginning of this chapter. If you have
    followed along with this book so far, the only prerequisite tool you should need
    to install now is Yamale, which is a tool that chart testing uses to validate
    your charts' `Chart.yaml` files against a `Chart.yaml` schema file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yamale can be installed with the `pip` package manager, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can also ins[tall Yamale manually by downloading an archive from](https://github.com/23andMe/Yamale/archive/master.zip)
    [https://github.com/23andMe/Yamale/archive/master.zip](https://github.com/23andMe/Yamale/archive/master.zip).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once downloaded, unzip the archive and run the setup script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you install the tool using a downloaded archive, you may need to
    run the `setup.py` script with elevated permissions, such as an administrator
    or as root on macOS and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the required tooling installed, you should download the chart
    t[esting tool from the project's GitHub releases](https://github.com/helm/chart-testing/releases)
    page at [https://github.com/helm/chart-testing/releases](https://github.com/helm/chart-testing/releases).
    Each release contains an *Assets* section with a list of archives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the archive that corresponds with the platform type of your local
    machine. Version `v3.0.0-beta.1` was the version used for this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The chart testing releases page on GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – The chart testing releases page on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'Unarchive the chart testing release once you have downloaded the appropriate
    file from the GitHub releases page. Once unarchived, you will see the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You can remove the `LICENSE` and `README.md` files as they are not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `etc/chart_schema.yaml` and `etc/lintconf.yaml` files should be moved to
    either the `$HOME/.ct/` or the `/etc/ct/` location on your local machine. The
    `ct` file should be moved to somewhere that is managed by your system''s `PATH`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now, all of the required tooling is installed. For this example, we will make
    a change locally to the Packt repository and use chart testing to lint and install
    the modified charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not yet cloned the repository to your local machine, you should
    do so now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Once cloned, you may notice that this repository has a file in the top level
    called `ct.yaml` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `chart-dirs` field of this file indicates to `ct` that the `helm-charts/charts`
    directory relative to the `ct.yaml` file is the root of the chart's monorepo.
    The `chart-repos` field provides a list of repositories that chart testing should
    run `helm repo add` against to ensure it is able to download dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: There are a variety of other configurations that can be added to this file,
    which will not be discussed at this time b[ut can be reviewed in the chart testi](https://github.com/helm/chart-testing)ng
    documentation at [https://github.com/helm/chart-testing](https://github.com/helm/chart-testing).
    Each invocation of the `ct` command references the `ct.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the tooling is installed and the Packt repository has been cloned,
    let's test the `ct` tool out by executing the `lint-and-install` command.
  prefs: []
  type: TYPE_NORMAL
- en: Running the chart testing lint-and-install command
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lint-and-install` command is used against the three Helm charts included
    under `Learn-Helm/helm-charts/charts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`guestbook`: This is the Guestbook chart that you wrote in the previous chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nginx`: This is an additional Helm chart that we have included for demonstration
    purposes. This chart, created by running the `helm create` command, is used to
    deploy the `nginx` reverse proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run the tests, first, navigate to the top level of the `Learn-Helm` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ct.yaml` file displays the location of the chart''s monorepo via the `chart-dirs`
    field, so you can simply run the `ct lint-and-install` command from the top level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this command, you''ll see the following message displayed at
    the end of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The chart testing lint-and-install output when charts are not
    modified'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – The chart testing `lint-and-install` output when charts are not
    modified
  prefs: []
  type: TYPE_NORMAL
- en: 'Since none of the charts in this repository were modified, `ct` did not perform
    any actions on your charts. We should modify at least one of these charts to see
    the `lint-and-install` process take place. Modifications should take place in
    branches other than `master`, so a new branch called `chart-testing-example` should
    be created by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The modifications can be large or small; for this example, we will simply modify
    each chart''s `Chart.yaml` file. Modify the `description` field of the `Learn-Helm/helm-charts/charts/guestbook/Chart.yaml`
    file to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Previously, this value was `A Helm chart for Kubernetes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `description` field of the `Learn-Helm/helm-charts/charts/nginx/Chart.yaml`
    file to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, this value was `A Helm chart for Kubernetes`. Verify that both
    charts have been modified from their last `git` commit by running the `git status`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The git status output after both charts have been modified'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – The `git status` output after both charts have been modified
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a change in both the `guestbook` and `nginx` charts. With these
    charts modified, try running the `lint-and-install` command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, `ct` determines whether changes have occurred to two of the charts
    in this monorepo, as in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Messages denoting changes to the guestbook and nginx charts'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Messages denoting changes to the `guestbook` and `nginx` charts
  prefs: []
  type: TYPE_NORMAL
- en: 'This process, however, will later fail because neither of the charts'' versions
    were modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The output when no chart changes have been made'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – The output when no chart changes have been made
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be fixed by incrementing the `guestbook` and `nginx` chart versions.
    Since this change does not introduce new features, we will increment the `PATCH`
    version. Modify both chart versions to `version 1.0.1` in their respective `Chart.yaml`
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that this change has been made to each chart by running the `git diff`
    command. If you see each version modification in the output, continue to run the
    `lint-and-install` command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the chart versions have been incremented, the `lint-and-install` command
    will follow the full chart testing workflow. You will see that each modified chart
    is linted and deployed to an automatically created namespace. Once the deployed
    application''s pods are reported as ready, `ct` will automatically run the test
    cases of each chart as denoted by resources with the `helm.sh/hook: test` annotation.
    Chart testing will also print the logs of each test pod, as well as the namespace
    events.'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice, in the `lint-and-install` output, that the `nginx` chart is
    deployed twice, while the `guestbook` chart was only deployed and tested once.
    This is because the `nginx` chart has a `ci/` folder, located at `Learn-Helm/helm-charts/charts/nginx/ci/`,
    that contains two different `values` files. The `values` files in the `ci/` folder
    are iterated on by chart testing, which installs the chart as many times as there
    are `values` files to ensure that each combination of values results in a successful
    installation. The `guestbook` chart does not include a `ci/` folder, so this chart
    was only installed once.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be observed in the following lines of the `lint-and-install` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: While the command was useful for testing the functionality of both charts, it
    did not validate whether upgrades to the newer version will be successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to provide the `--upgrade` flag to the `lint-and-install`
    command. Try, once again, to run this command, but this time with the `--upgrade`
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, an in-place upgrade will occur for each `values` file under `ci/`.
    This can be seen in the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that an in-place upgrade will only be tested if the `MAJOR` version
    between versions is the same. If you use the `--upgrade` flag but did change the
    `MAJOR` version, you will see a message similar to the following :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now, with an understanding of how to perform robust testing on your Helm charts
    with chart testing, we will conclude by cleaning up your `minikube` environment.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are finished with the examples described in this chapter, you can remove
    the `chapter6` namespace from your `minikube` cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Finally, shut down your `minikube` cluster by running `minikube stop`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the different methods you can apply to test
    your Helm charts. The most basic way of testing a chart is to run the `helm template`
    command against a local chart directory to determine whether its resources are
    properly generated. You can also use the `helm lint` command to ensure that your
    chart follows the correct format and you can use the `yamllint` command to lint
    the YAML style used in your chart.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from local templating and linting, you can also perform live tests on
    a Kubernetes environment with the `helm test` command and the `ct` tool. In addition
    to performing chart tests, chart testing also provides capabilities that make
    it easier for chart developers to maintain Helm charts in a monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how Helm can be used in a **Continuous Integration/Continuous
    Delivery** (**CI/CD**) and GitOps setting, from both the perspective of a chart
    developer that is building and testing Helm charts and from the perspective of
    an end user using Helm to deploy an application to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For additional information on the `helm template` and `helm lint` com[mands,
    please refer to the following res](https://helm.sh/docs/helm/helm_template/)ources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`helm template`: [https://helm.sh/docs/helm/helm_template/](https://helm.sh/docs/helm/helm_template/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helm lint`: [https://helm.sh/docs/helm/helm_lint/](https://helm.sh/docs/helm/helm_lint/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following pages from the Helm documentati[on discuss chart tests and the
    `helm test`](https://helm.sh/docs/topics/chart_tests/) command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chart tests: [https://helm.sh/docs/topics/chart_tests/](https://helm.sh/docs/topics/chart_tests/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `helm test` command: [https://helm.sh/docs/helm/helm_test/](https://helm.sh/docs/helm/helm_test/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, see the chart te[sting GitHub repository for more info](https://github.com/helm/chart-testing)rmation
    about the `ct` CLI: [https://github.com/helm/chart-testing](https://github.com/helm/chart-testing).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of the `helm template` command? How does it differ from
    the `helm lint` command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can you do to validate your chart templates before installing them in Kubernetes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What tool can be leveraged to lint the style of your YAML resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is a chart test created? How is a chart test executed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What additional value does the `ct` tool bring to Helm's built-in testing capabilities?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `ci/` folder when used with the `ct` tool?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the `--upgrade` flag change the behavior of the `ct lint-and-install`
    command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
