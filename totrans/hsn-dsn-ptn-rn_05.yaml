- en: Store Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The patterns built around virtual stores in JavaScript contain everything that
    is needed to decide what to show in an application. In my opinion, it is the most
    important piece necessary to understand Flux well, hence, I have dedicated a special
    chapter to store patterns, to go through many examples and compare alternatives.
    As React Native applications usually need to work offline, we will also learn
    how to transition our JavaScript store into a persistent store on a user's mobile
    device. This will take our application to the next level when it comes to user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to integrate Redux into your Flux architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Redux differs from classic Flux and the benefits of the new approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core principles of Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a store that will be a single source of truth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What effect patterns and side effects are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Redux stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It took me a while to figure out how to advertise Redux to you. Most likely,
    you expect it is some sort of Store implementation that will be used within Flux.
    This is true; however, there is more to it than that. Redux is a brilliant piece
    of code that makes a great tool. This tool can be used in many ways in many different
    projects. In this book, I strive to teach you to think in React and Redux.
  prefs: []
  type: TYPE_NORMAL
- en: This introduction was inspired by a useful talk from Cheng Lou, called *Taming
    the Meta Language*, and delivered at React Conf 2017.
  prefs: []
  type: TYPE_NORMAL
- en: Watch it at [https://goo.gl/2SkWAj](https://goo.gl/2SkWAj).
  prefs: []
  type: TYPE_NORMAL
- en: Minimal Redux application example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before I show you the Redux architecture, let's see it in action. It is vital
    to get a feeling for what the Redux API looks like. Once we develop the simplest
    hello world app in Redux, we will move on to a more high-level overview.
  prefs: []
  type: TYPE_NORMAL
- en: The hello world app we will be building is a counter app, as simple as two buttons
    (increase and decrease) and a text indicating the current count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive in, let''s install two packages using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, first, let''s create some basic Flux pieces that we already know, but
    this time using the Redux API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ActionTypes`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Store`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to two new words—`Reducer` and `rootReducer`. `rootReducer` combines
    all other reducers into one. `Reducer` is responsible for generating new versions
    of the state based on the action that has happened. Reducers can also return the
    old version of state if the current action is not relevant to the particular `Reducer`.
  prefs: []
  type: TYPE_NORMAL
- en: '`CounterReducer`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`Dispatcher`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Great, we have all the Flux pieces, so we can now move on to the actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with simple things first, the view. It should display two `Button` and
    one `Text` components. On a button press, the counter should be increased or decreased,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to provide the necessary dependencies to the view: the `inc`, `dec`,
    and `counter` props. The first two are rather straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we pass them to the view. Here, a number of specific Redux API components
    will be used. `Provider` is used to provide `store` to connect calls. This is
    optional—if you really want to do this manually, you can pass `store` directly
    to `connect`. I highly recommend using `Provider. Connect` to create a facade
    around the dispatch and state. In case of state changes, the component will be
    automatically re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Facade is another pattern entirely. It is a structural design pattern created
    to interact with complex APIs. If the typical user is not interested in all of
    the capabilities, it is handy to provide a function with some defaults already
    preset on behalf of the user. Such a function is called a `facade` function and
    is also exposed in the API. The end user can use it a lot quicker, with none of
    the additional deep-diving that is required for complex and optimized projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check how to use `Provider` and `Connect` in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We have completed the first Redux application.
  prefs: []
  type: TYPE_NORMAL
- en: How Redux fits into Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps we performed to create a `Counter` app involved connecting Flux pieces.
    Let''s look at the diagram we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4d9f0c18-5054-4873-95bf-e1b3e4db7a68.png)'
  prefs: []
  type: TYPE_IMG
- en: First of all, we have **Actions** that are dispatched. Then the root `Reducer`
    function is run and each reducer determines whether the state needs to be changed
    or not. The root **Reducer** returns a new version of **State** and the state
    is passed to the **View** root. The `connect` function determines whether a particular
    view should be re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the previous diagram follows the Flux architecture. The actual
    Redux implementation, as you could spot in the Counter example, is a little different.
    The dispatcher is encapsulated by the Store API and exposed as a `store` function.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux can do more than just very simple state management. It is also known to
    be performant and beneficial in applications with huge state objects and a lot
    of business models in it. That said, let's refactor our tasks application to Redux.
  prefs: []
  type: TYPE_NORMAL
- en: The `Tasks` application was developed in the previous chapters. If you have
    jumped straight to this chapter, please have a look at the application located
    at `src / Chapter 4 / Example 1_ Todo app with Flux`, in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The refactor steps will be similar. Replace existing Flux pieces with Redux
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ActionTypes`:The actual implementation is okay:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`TaskStore.js`: Rename to `AppStore.js`. Now, `store` has just one instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, we will need to move the `reduce` function to a separate reducer
    file. What''s left should be converted into a new syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`AppDispatcher.js`: The dispatcher is now part of the store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`taskReducer.js`: This is a new file that we need to create. Its contents,
    however, are copied from the previous `reduce` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The last required step is an app container change, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good. It works. But there are a few things that we skipped here.
    I will show you what we can do better, but first, let's learn some Redux principles.
  prefs: []
  type: TYPE_NORMAL
- en: Redux as a pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux, when done right, provides outstanding capabilities, such as **time **travelling and
    **hot reloading**. Time travelling allows us to see how an application looked
    over time based on the action log. Hot reloading, on the other hand, allows us
    to substitute parts of the code without reloading the app.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about the core principles of Redux and some commonly
    recommended approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please make the effort to read the Redux documentation. It is a great and free
    resource to learn how to think in React and Redux. It will also help you expand
    your use of Redux beyond the React ecosystem, and is available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://redux.js.org/introduction/examples](https://redux.js.org/introduction/examples).[ ](https://redux.js.org/introduction/examples)'
  prefs: []
  type: TYPE_NORMAL
- en: Core principles of Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Single source of truth**: The state of your whole application is stored in
    an object tree within a single store. Ideally, there should be a single Redux
    store that can guide your views to render the whole application. This means you
    should keep all of your states away from class components and place them directly
    in the Redux store. This will simplify the method with which we will restore the
    view in tests or when we do a time travel.'
  prefs: []
  type: TYPE_NORMAL
- en: Having a single place to store things feels unnatural to some developers, most
    likely because, over the years on the backend, we have learned that it leads to
    monolithic architecture. This is not, however, the case in an application environment.
    An application window is not expected to be scaled vertically to handle a high
    load of users. Neither should it be used by hundreds of users at the same time
    on a single device.
  prefs: []
  type: TYPE_NORMAL
- en: '**State is read-only**: The only way to change the state is to emit an action—an
    object describing what happened. It is vital that we have a single stream that
    can affect our store. The store is a representation of our application state and
    should not be mutated by random code. Instead, any code that is interested in
    changing the state should hand in a **signed paper** that is called an **action
    object**. This action object represents a known action that is registered in our
    library, called **action types**. The reducers are the logic that decides the
    state changes. The immutable state with a single stream of modifying actions is
    much easier to maintain and supervise. It is quicker to determine whether something
    has changed or not and when it changed. We can easily create an audit database. Particularly
    in sensitive industries such as banking, it is a huge advantage.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Changes are made with pure functions**: To specify how the state tree is
    transformed by actions, you write pure reducers. This is a concept that we have
    not talked about yet. Reducers need to be pure functions. Pure functions guarantee
    that no external circumstances will affect the result of a function. To put it
    in a nutshell, reducers cannot perform I/O code, time-constrained code, or code
    that relies on mutable scoped data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A pure function is a function that satisfies two requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: It returns the same output, given the same input arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function execution does not cause any side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good example are common math functions. For instance, an addition function
    given 1 and 3 always returns 4.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be obvious why all of this is beneficial and should be considered
    one of the principles. Imagine a situation where a bug was unintentionally introduced
    into your project in the development phase. Or, even worse, it leaked into production
    and blew up a critical application during one of the user's sessions. Most likely,
    you have some error tracking, and you can get the exception and stack trace, which show
    a long and vague path through minified code. However, you need to fix it, so you
    try to replay the exact same situation on a local machine of yours and eventually
    spend three consecutive days just to realize that the problem was some boring
    race condition. Imagine, instead, that you had a single stream of actions (no
    random interchanging of untracked conditions) that you track and log. Also, your
    entire app relies on a state that can only be changed based on the stream of actions.
    In case of failure, all you need to store in order to reply to the situation is
    the action trace. Voila, I've just saved you a day or two.
  prefs: []
  type: TYPE_NORMAL
- en: When I learned Redux with similar examples, I still struggled to understand
    why pure functions are so important here. Playing with time-traveling within the
    Redux tab for Chrome allowed me to see it more clearly in the flesh. When you
    go back and forth with actions, some components that are stateful (that is, that
    rely on an internal state instead of the Redux one) will not be following along.
    This is a huge issue as it breaks your time travel, leaving some parts in a future
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to a single source of truth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time for an exercise. Our new goal is to refactor the Tasks application
    so that it has a store that is a single source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we need to look for places where we rely on a component state instead
    of the Redux store. So far we have three views:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AppView.js`: This has a fairly simple division into header, footer, and main
    content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a presentational component and holds no state. Its props are provided
    by `AppContainer`, which already uses the Redux store. `AppView` delegates main
    content to the following two sub-views.
  prefs: []
  type: TYPE_NORMAL
- en: '`TaskList.js`: This is a presentational component responsible for displaying
    to-do tasks in a simple scrollable list. Its props are forwarded by `AppView`
    from `AppContainer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddTaskForm.js`: This is a container component, based on the `TextInput` component.
    This piece uses an internal state. If possible, we should refactor this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have ever read about React and Redux, you may find this example pretty
    similar to what you can find for web pages—however, it is not. If you followed
    this book for the first chapters, you may have a gut instinct as to why; if not,
    I highly recommend going back for a while to `Chapter 2 > Building Forms > Uncontrolled
    Inputs`.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to somehow move the state from `AddTaskForm` to the Redux store.
    This is where problems begin. You may have already spotted that `TextInput` is
    part of the React-Native API and we have no ability to change it. But `TextInput`
    is a stateful component. This is the first thing you should realize about Redux
    when building React Native apps—some parts need to be stateful and you cannot
    work around it.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the stateful part of `TextInput` only manages focus. It is highly unlikely
    that you would need to store information about that in the Redux store. All the
    other states belong to our `AddTaskForm` component and we can work around it.
    Let's do that straight away.
  prefs: []
  type: TYPE_NORMAL
- en: In idiomatic Redux, your state should be normalized similarly to the databases.
    There are known normalization techniques used in SQL databases that usually are
    based on ID references between entities. You can adopt this approach in your Redux
    store by using, for the instance, Normalizr library.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will rebuild the `AddTaskForm` component. It needs to dispatch a
    new action that will trigger a new reducer and alter a new key in the Redux store
    (we will develop the latter parts later on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The hardest part is behind us. It''s time to create a brand new `taskFormReducer`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, add a new action type to `TasksActionTypes`, as demonstrated
    in this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the action itself, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, register a new reducer in `AppStore`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, we need to pass the new state along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass it down the component tree up to `AppView`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have connected all the bits. Enjoy your centralized single source
    of truth Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, take a look at the `redux-form` library. As of writing this book,
    it is an industry standard for building forms in Redux. The library can be found
    at [https://redux-form.com](https://redux-form.com).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an alternative with MobX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be foolish to rely on Redux with no strong alternative. One of such
    alternatives is MobX, a state management library that is not so opinionated on
    mutations. MobX comes with as little boilerplate as possible. This is huge compared
    to Redux, which, being very explicit, requires a lot of boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: Here I must stop to remind you that the React ecosystem leans towards explicitness,
    that is, building apps without too many hidden mechanisms. You control the flow
    and you see all of the bits that are required for the app to go the full cycle
    of Flux. It's n surprise, then, that mainstream developers prefer Redux. An interesting
    fact is that Facebook Open Source is backing the MobX project.
  prefs: []
  type: TYPE_NORMAL
- en: MobX, being more implicit, can hide away some logic built around Observables
    and provide neat annotations to quickly enhance your stateful components with
    MobX flow.
  prefs: []
  type: TYPE_NORMAL
- en: Some developers may find it a much better approach, most likely those coming
    from an object-oriented background who are used to such things. I find MobX a
    much easier library to start with and develop a prototype or proof-of-concept
    application. However, as logic is hidden away from me, I'm afraid that some developers
    will never have a look under the hood. This may lead to poor performance that
    cannot easily be fixed later on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how it feels in action.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to MobX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will refactor the Tasks application to use MobX instead
    of vanilla Flux.
  prefs: []
  type: TYPE_NORMAL
- en: The Tasks application was developed in the previous chapters. If you have jumped
    straight to this chapter, please have a look at the application located at `src
    / Chapter 4 / Example 1_ Todo app with Flux`, in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive in, install the two packages using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, first, let''s clean up unneeded pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AppDispatcher.js`: Dispatching is done by MobX using observables behind the
    scenes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TaskActions.js`: Actions will now live in `TaskStore` and work on its state.
    In MobX, you will most likely end up with many stores, so this is not a big issue—we
    keep related things together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TasksActionTypes.js`: There is no need to define this. MobX will take care
    of it internally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, before we begin, we have already removed so much overhead. This
    is one of the biggest advantages of MobX that fans of the library mention.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to rebuild the store in MobX fashion. This will require some new
    keywords, so read the following snippet carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there are three new keywords that I have imported from the
    MobX library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`configure`: This is used to set up our store in such a way as to enforce mutations
    only by actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`observable`: This is used to enrich property in such a way it can now be observed.
    If you have some JavaScript background on streams or Observables, it is literally
    wrapped by these.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action`: This is just like any other action but it''s used in a decorator
    fashion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we create an instance of the store and pass it along as a default export.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to expose our new store to the views. To do this, we will use MobX
    `Provider`, a similar utility to that found in Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The last section of the preceding snippet involves refactoring the descendant
    views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AppView` component provides tasks down to `TaskList` component. Let''s
    now consume tasks from our newly created store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do something similar with `AddTaskForm`, but instead of using `tasks`,
    we will use the `addTask` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Our app is fully functional again.
  prefs: []
  type: TYPE_NORMAL
- en: Using PropTypes with annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you followed along, you may feel a little lost, as your linter probably started
    complaining about insufficient or missing `PropTypes`. Let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `AppView`, we are missing `PropTypes` validation for the `tasks` store.
    When the class is annotated with `@observer`, it is a little tricky—you need to
    write `PropTypes` for `wrappedComponent`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For `AddTaskForm`, we are missing the `PropTypes` validation for the `addTask`store
    action. Let''s fix this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That's it, the linter complaints are gone.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Redux and MobX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One day I was thinking how to compare those two and the following came to mind.
  prefs: []
  type: TYPE_NORMAL
- en: This section is highly influenced by Preethi Kasireddy's talk at React Conf
    2017\. Please spend half an hour and watch it. You can find the talk at [https://www.youtube.com/watch?v=76FRrbY18Bs](https://www.youtube.com/watch?v=76FRrbY18Bs).
  prefs: []
  type: TYPE_NORMAL
- en: MobX is like system of roads for cars. You create a road map and let people
    drive. Some will cause accidents, some will drive carefully. Some roads may be
    limited to one-way to restrict traffic a little, or even shaped in a certain way
    to allow easier reasoning about the car flow, as in Manhattan. Redux, on the other
    hand, is like a train. Only one train can move on a track at a time. If there
    are a few at the same moment and something is holding up the one in front, every
    other train waits behind, just like in a subway station. Sometimes trains need
    to transfer people as far as the other side of a continent, and this is also possible.
    All of this train flow is governed by one (distributed) agency that plans the
    movement and puts restrictions on the train flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping this example in mind, let''s take a more technical look at these libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: Redux uses plain objects, while MobX wraps objects into Observables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may expect me to mention some magic again—no. The brutal truth is that
    MobX comes at a cost. It needs to wrap observable data and add some weight to
    each single object or each member of a collection. It is fairly easy to look up
    just how much data: use `console.log` to see your observable collection.'
  prefs: []
  type: TYPE_NORMAL
- en: Redux manually tracks updates, whereas MobX automatically tracks updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Redux state is read-only and can be altered by dispatching an action, while
    a MobX state can be altered at any time, sometimes only by using actions exposed
    by your Store API. Also, in MobX, actions are not required. You can change state
    directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Redux, a state is typically normalized, or at least this is recommended.
    In MobX, your state is denormalized and computed values are nested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stateless and stateful components: here it may seem difficult. Preethi Kasireddy,
    in the lecture linked in the preceding information box, mentioned that MobX can
    be used with smart components only. To some extent, this is true, but there is
    no distinction here from Redux. Both support presentational components, as these
    are completely decoupled from state management libraries!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The learning curve—this is very subjective criteria. Some will find Redux easier,
    others will find MobX easier. The popular belief is that MobX is easier to learn.
    I'm an exception to this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux requires more boilerplate. Being more explicit, this is quite straightforward,
    but there are libraries that fix this if you don't care. No references will be
    provided here, as I recommend educated use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux is much easier to debug. This comes naturally with single flow and easy
    replay of messages. This is where Redux shines. MobX is more old-school here,
    a little harder to predict, and not so obvious, even to experienced users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux wins when it comes to scalability. MobX may pose some maintainability
    problems, especially in big projects with a lot of connections and a big domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MobX is concise and shines in small, time-constrained projects. If you go to
    a hackathon, consider using MobX. In big, long-term projects, you would need a
    more opinionated approach on top of the freedom that MobX gives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MobX follows the Flux architecture and does not alter it as much as Redux does.
    Redux leans towards one global store (although can be used with many!), while
    MobX is quite flexible with the amount of stores and its examples usually demonstrate
    similar thinking to the early ideas of Flux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While using Redux, you need to learn how to deal with different situations and
    how to structure things. When it comes to dealing with side effects especially,
    you will need to learn Redux Thunk and possibly Redux Saga, which will be introduced
    in the following chapter. In MobX, all of this is magically taken care of behind
    the scenes, using reactive streams. In this respect, MobX is opinionated, but
    takes one responsibility away from you.
  prefs: []
  type: TYPE_NORMAL
- en: Using system storage in React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those who come from a Native environment are used to persistent storage, such
    as databases or files. So far, any time our app has been relaunched, it has lost
    its state. We can fix that using system storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we will use the `AsyncStorage` API that comes with React
    Native:'
  prefs: []
  type: TYPE_NORMAL
- en: '"On iOS, AsyncStorage is backed by native code that stores small values in
    a serialized dictionary and larger values in separate files. On Android, AsyncStorage
    will use either RocksDB or SQLite based on what is available."'
  prefs: []
  type: TYPE_NORMAL
- en: '- From the React Native official documentation, which can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/asyncstorage.html](https://facebook.github.io/react-native/docs/asyncstorage.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AsyncStorage` API is pretty easy to use. First, let''s save the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, here''s how we retrieve a saved value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the documentation advises that we use some abstraction with `AsyncStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '"It is recommended that you use an abstraction on top of AsyncStorage instead
    of AsyncStorage directly for anything more than light usage since it operates
    globally."'
  prefs: []
  type: TYPE_NORMAL
- en: '- From the React Native official documentation, which can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/asyncstorage.html](https://facebook.github.io/react-native/docs/asyncstorage.html).'
  prefs: []
  type: TYPE_NORMAL
- en: So, let's follow the standard library, `redux-persist`. The topic of storage
    is huge and spans a little beyond this book, so I don't want to dive too deep
    into this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the library with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to enhance our `AppStore` definition with the new persistence
    middleware, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are done with the configuration, we need to load the state using `PersistGate.`
    You can provide a custom component to the loading prop if you have one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Voila! Whenever you relaunch the application, the state will be loaded from
    the persistent store, and you will see all of the tasks from the last application
    launch.
  prefs: []
  type: TYPE_NORMAL
- en: Effect patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with external data, you need to deal with external factors, such
    as the network or disk. These factors influence your code, so it needs to be asynchronous.
    Also, you should strive to decouple it from your predictable parts, as a network
    is unpredictable and may fail. We call such things side effects and you have already
    learned a little about them already.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this, I would like to introduce a big word: effect.'
  prefs: []
  type: TYPE_NORMAL
- en: '"We yield plain JavaScript Objects [...]. We call those Objects *Effects*.
    An Effect is simply an object that contains some information to be interpreted
    by the middleware. You can view Effects like instructions to the middleware to
    perform some operation (e.g., invoke some asynchronous function, dispatch an action
    to the store, etc.)."'
  prefs: []
  type: TYPE_NORMAL
- en: '- From the Redux Saga official documentation, which can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://redux-saga.js.org/docs/basics/DeclarativeEffects.html](https://redux-saga.js.org/docs/basics/DeclarativeEffects.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Such effects, if used outside of the immediate scope, cause a so-called **side
    effect**, hence the name. Most commonly, this means a mutation of an outer scope
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The absence of side effects is key to mathematical proofs of the correctness
    of a program. We will dive into this topic later on in [Chapter 9](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml), *Elements
    of Functional Programming Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Handling side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](71c15ec6-339c-49e3-840c-577c650f5694.xhtml), *Flux Architecture*,
    you learned what side effects are and what strategies you can follow to decouple
    them from Views and Store. When using Redux, you should stick to them. However,
    there are a few neat libraries that have been developed for Redux to solve the
    problem. You will learn more on them in the following chapter, which is dedicated
    just to this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '"We''re mixing two concepts that are very hard for the human mind to reason
    about: mutation and asynchronicity. I call them Mentos and Coke. Both can be great
    in separation, but together they create a mess. Libraries like React attempt to
    solve this problem in the view layer by removing both asynchrony and direct DOM
    manipulation. However, managing the state of your data is left up to you. This
    is where Redux enters."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Official Redux documentation'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the importance of stores in our architecture.
    You learned how to shape your application in order to fulfill different business
    needs, from very fragile ones using a mixed approach of state and global state,
    to sophisticated ones allowing time-traveling and UI reconstruction.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of focusing on one mainstream solution, that is, Redux, we also explored
    the quite different approach of the MobX library. We found it great in many areas,
    such as rapid prototyping and small projects, and you now know when and in which
    projects it is wise to choose MobX over Redux.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redux official documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://redux.js.org/](https://redux.js.org/). [](https://redux.js.org/) This
    is a particularly useful part of the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://redux.js.org/faq](https://redux.js.org/faq).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Introduction of Redux Time Travel and Hot Reloading* by Dan Abramov, on React
    Europe:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=xsSnOQynTHs](https://www.youtube.com/watch?v=xsSnOQynTHs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dan Abramov''s courses on Egghead:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://egghead.io/instructors/dan-abramov](https://egghead.io/instructors/dan-abramov).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux GitHub page with closed issues. This contains a ton of useful discussions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/reduxjs/redux/issues?q=is%3Aissue+is%3Aclosed](https://github.com/reduxjs/redux/issues?q=is%3Aissue+is%3Aclosed).'
  prefs: []
  type: TYPE_NORMAL
- en: Netflix JavaScript Talks: *RxJS + Redux + React = Amazing*!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=AslncyG8whg](https://www.youtube.com/watch?v=AslncyG8whg).'
  prefs: []
  type: TYPE_NORMAL
- en: '*How Airbnb Is Using React Native*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=8qCociUB6aQ](https://www.youtube.com/watch?v=8qCociUB6aQ).'
  prefs: []
  type: TYPE_NORMAL
- en: This is not strictly on store patterns but illustrates how to think about big
    production applications, such as Airbnb.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might need Redux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=2iPE5l3cl_s&feature=youtu.be&t=2h7m28s](https://www.youtube.com/watch?v=2iPE5l3cl_s&feature=youtu.be&t=2h7m28s).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, a very important topic brought to you by the Redux author:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*You Might Not Need Redux*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367).'
  prefs: []
  type: TYPE_NORMAL
