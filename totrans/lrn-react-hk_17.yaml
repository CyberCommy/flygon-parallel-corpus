- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Answers to questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we answer all the questions asked at the end of each chapter. You can
    use these questions to review what you have learned throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1: Introducing React and React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are React's three fundamental principles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Declarative**: Instead of telling React how to do things, we tell it what we
    want. As a result, we can easily design our applications and React will efficiently
    update and render just the right components when data changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component-based**: React encapsulates components that manage their own state
    and views, then allows us to compose them to create complex user interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learn once, write anywhere:** React does not make assumptions about your
    technology stack and tries to ensure you can develop without rewriting existing
    code as much as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the two types of components in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Function components**: JavaScript functions that take the props as an argument
    and return the user interface (usually via JSX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class components**: JavaScript classes that provide a `render` method, which
    returns the user interface (usually via JSX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the problems with class components in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'JavaScript classes are hard to understand for developers: The `this` context
    can be confusing, and we sometimes have to write code in multiple places at once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are also hard to understand for machines: It is hard to tell which methods
    will be called and, as such, performance optimizations are not really possible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are not declarative and thus go against React''s fundamental principles:
    To use React features, we have to write code that tells React what to do, not
    how to do it'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the problem of using higher-order components in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using higher-order components introduces components to our view tree that do
    not actually matter in terms of view structure. Having many higher-order components
    causes the so-called **wrapper hell**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which tool can we use to set up a React project, and what is the command that
    we need to run to use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use `create-react-app`. To create a new project, we have to run `npx
    create-react-app <app-name>` or `yarn create react-app <app-name>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What do we need to do if we get the following error with class components: *TypeError:
    undefined is not an object (evaluating ''this.setState'')*?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We forgot to re-bind the `this` context of the method in the `constructor` of
    our class. As a result, `this` is not pointing to the class but, instead, to the
    context of the input field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we access and set React state using Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We make use of the `useState()` Hook as follows: `const [ name, setName ] =
    useState('''')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the advantages of using function components with Hooks, in comparison
    to class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function components with Hooks do not suffer from the same problems as classes.
    They are declarative and thus fit React's fundamental principles better. Hooks
    also make our code more concise and easier to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need to replace all class components with function components using Hooks
    when updating React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, we do not need to replace all class components. Function components with
    Hooks can work side-by-side with existing class components and are 100% backward-compatible.
    We can simply write new components using Hooks or upgrade existing components
    at our own pace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the three basic hooks provided by React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `useState`, `useEffect`, and `useContext` Hooks are the basic Hooks provided
    by React and used very frequently in projects. However, React also provides some
    more advanced Hooks out of the box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 2: Using the State Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What problems did we run into while developing our own reimplementation of the
    `useState` hook? How did we solve these problems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One problem was the initialization of the value every time the component gets
    rendered. We solved this problem by using a global variable to store the value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we had the problem that multiple Hooks write to the same global variable.
    To solve this problem, we stored the values in an array and kept track of the
    current Hook by assigning an index to each Hook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are conditional Hooks not possible in the React implementation of Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conditional Hooks are not possible, because React uses the order of Hook definitions
    to keep track of the values. If we change the order of Hooks later on, the values
    will be assigned to different Hooks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Hooks and what do they deal with?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hooks are functions that deal with state and effects in a React application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do we need to watch out for when using Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to ensure that the order of Hooks always stays the same, so we cannot
    use Hooks in loops or conditionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the common problems of alternative API ideas for Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Named Hooks have the problem of name collisions. Each Hook would have to have
    a unique name, even when using Hooks within libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hook factories require more boilerplate code, mainly instantiating each Hook
    twice, once outside of the component and once inside. Furthermore, they make it
    much harder to create custom Hooks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we implement conditional Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In simple cases, we can always define the Hook. Otherwise, we have to split
    up the components and conditionally render a separate component instead of conditionally
    rendering the Hook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we implement Hooks in loops?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In simple cases, we can store an array in the State Hook. Otherwise, we have
    to split up the components and render a separate component in a loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 3: Writing Your First Application with React Hooks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the best practice for folder structures in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start with a simple structure at first and nest more deeply when needed. Do
    not spend too much time thinking about the file structure when starting a project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which principle should we use when splitting up React components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The single responsibility principle, which states that every component should
    have responsibility over a single encapsulated part of the functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the `map` function do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `map` function applies a given function to all elements of an array and
    returns a new array with the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does destructuring work, and when do we use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With destructuring, we can get properties from an object or elements from an
    array by specifying the structure and variable names on the left side of the assignment.
    We can use destructuring to get certain props in React components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does the spread operator work, and when do we use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The spread operator inserts all properties of an object or all elements of an
    array at a certain point in another object/array. It can be used to create new
    arrays or objects or to pass on all properties of an object as props to a React
    component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we deal with input fields using React Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a State Hook for the input field value and define a handler function
    that sets the value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where should local State Hooks be defined?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local State Hooks should always be defined in the component where they are used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is global state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Global state is state that is used across multiple components throughout the
    whole application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where should global State Hooks be defined?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Global State Hooks should be defined as high up in the component tree as possible.
    In our case, we defined them in the `App` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 4: Using the Reducer and Effect Hooks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are common problems with State Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complex state changes are hard to do with State Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are actions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Actions are objects that describe a state change, for example, `{ type: ''CHANGE_FILTER'',
    byAuthor: ''Daniel Bugl'' }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are reducers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reducers are functions that process state changes. They accept the current state
    and an action object and return a new state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should we use a Reducer Hook instead of a State Hook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reducer Hooks should be used when complex state changes are needed. Usually,
    this is the case for global state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When setter functions of multiple State Hooks are called together, this is a
    good indicator for using a Reducer Hook instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which steps are needed in order to turn a State Hook into a Reducer Hook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We first need to define actions, then the reducer function, and finally a Reducer
    Hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we create actions more easily?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could define functions that return action objects, so called **action creators**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should we merge Reducer Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we want to avoid having two separate dispatch functions or when the same
    action modifies state in multiple reducers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do we need to watch out for when merging Reducer Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to make sure that each reducer returns the current state for unhandled
    actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the equivalent of an Effect Hook in class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In React class components we would use `componentDidMount` and `componentDidUpdate`
    to deal with effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the advantages of using an Effect Hook versus class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Effect Hooks we do not need to define both `componentDidMount` and `componentDidUpdate`.
    Furthermore, Effect Hooks are much easier to understand, and we do not need to
    know how React works internally to be able to use them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 5: Implementing React Context'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which problem do contexts avoid?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Contexts avoid having to pass down props through multiple levels of components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the two parts that contexts consist of?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React contexts consist of a provider and a consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are both parts required to be defined in order to use contexts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The provider is not required, as contexts will use the default value passed
    to `React.createContext` when no provider is defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the advantage of using Hooks instead of traditional context consumers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hooks do not require using a component and render props for the consumer. Using
    multiple contexts with consumer components makes our component tree very deep
    and our app harder to debug and maintain. Hooks avoid this problem by allowing
    us to consume contexts by simply calling a Hook function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an alternative to contexts, and when should we use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Contexts make reusing components more difficult. Contexts should only be used
    when we need to access data in multiple components at different nesting levels.
    Otherwise, we can either pass down props or pass down the rendered component,
    using a technique called inversion of control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we implement dynamically changing contexts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to use a State Hook to provide the value for the context provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When does it make sense to use contexts for state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Usually, it makes sense to use contexts for global state, which is used across
    multiple components at different nesting levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 6: Implementing Requests and React Suspense'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we easily create a full REST API from a simple JSON file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `json-server` tool to create a full REST API from a JSON file
    for development and testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the advantages of using a proxy to access our backend server during
    development?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using a proxy, we do not need to deal with cross-site restrictions during
    development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which combinations of Hooks can we use to implement requests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can implement requests using an Effect and a State or Reducer Hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which libraries can we use to implement requests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can also use the `axios` and `react-request-hook` libraries to implement
    requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we deal with loading states using `react-request-hook`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `result.isLoading` flag returned from the `useResource` Hook
    and conditionally display a loading message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we deal with errors using `react-request-hook`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `result.error` object returned from the `useResource` Hook and
    dispatch an error action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we prevent unnecessary re-rendering of components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `React.memo`, we can prevent unnecessary re-rendering, similarly to `shouldComponentUpdate`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we reduce the bundle size of our app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use `React.Suspense` to lazily load certain components, which means that
    they will only be requested from the server when needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 7: Using Hooks for Routing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we need to define separate pages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most large apps consist of multiple pages. For example, a separate page for
    each blog post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we define routes using the Navi library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `mount` function and pass an object mapping path to `route` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we define routes with URL parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `:parameter` syntax to specify URL parameters within the path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are static links defined with Navi?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static links can be defined using the `Link` component from `react-navi`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we implement dynamic navigation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dynamic navigation can be implemented using the `useNavigation` Hook and calling
    `navigation.navigate()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which Hook is used to access route information of the current route?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `useCurrentRoute` Hook gives us all information about the current route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which Hook is used to access route information of the currently loading route?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `useLoadingRoute` Hook gives us all information about the route that is
    currently being loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 8: Using Community Hooks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which Hook can we use to simplify input field handling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `useInput` Hook from the `react-hookedup` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are the `componentDidMount` and `componentWillUnmount` life cycles implemented
    using Effect Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`componentDidMount` can be implemented by using an Effect Hook with an empty
    array passed as the second argument. For example, `useEffect(() => console.log(''did
    mount''), [])`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentWillUnmount` can be implemented by returning a function from an Effect
    Hook with an empty array passed as the second argument, for example, `useEffect(()
    => { return () => console.log(''will unmount'') }, [])`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we use Hooks to get the behavior of `this.setState()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`this.setState()` merges the existing state object with the given state object.
    We can get the same behavior by using the `useMergeState` Hook instead of a simple
    State Hook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why should we use timer Hooks instead of calling `setTimeout` and `setInterval` directly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When defining simple timeouts or intervals they are going to reset when the
    component re-renders. To prevent this resetting from happening, we have to use
    the `useTimeout` and `useInterval` Hooks from `react-hookedup` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which Hooks can we use to simplify dealing with common data structures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `useBoolean`, `useArray`, and `useCounter` Hooks from `react-hookedup`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should we use responsive design with Hooks versus simply using CSS media
    queries?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should use Hooks for responsive design when rendering elements within a canvas
    or WebGL, or when we dynamically want to decide whether to load components based
    on the window size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which Hook can we use to implement undo/redo functionality?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `useUndo` Hook from the `use-undo` library to implement simple
    undo/redo functionality in our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is debouncing? Why do we need to do it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debouncing means that a function will only be called after a certain amount
    of time, not every time an event triggers it. Using debouncing, we can store a
    value entered in a text field in the undo history only after each second, not
    after every typed character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which Hook can we use for debouncing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `useDebounce` or the `useDebouncedCallback` Hook from the `use-debounce`
    library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 9: Rules of Hooks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where can Hooks be called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hooks can only be called at the beginning of React function components or custom
    Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we use Hooks in React class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, it is not possible to use Hooks in React class components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do we need to watch out for regarding the order of Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The order of Hooks should never change, as it is used to track the values of
    various Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can hooks be called inside conditions, loops, or nested functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, Hooks cannot be called inside conditionals, loops, or nested functions,
    because that would change the order of Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the naming convention for Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hook function names should always start with a `use` prefix and then a name
    in `CamelCase`. For example: `useSomeHookName`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we automatically enforce the rules of Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use `eslint` with `eslint-plugin-react-hooks` to enforce the rules of
    Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the exhaustive dependencies rule?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exhaustive dependencies rule ensures that in an Effect Hook all variables
    that are used are listed as dependencies via the second argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we automatically fix linter warnings?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can run the `npm run lint -- --fix` command to automatically fix linter warnings.
    Running this command will, for example, automatically enter all variables used
    in an Effect Hook as dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 10: Building Your Own Hooks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we extract a custom Hook from existing code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can simply put our code into a separate function. In custom Hook functions
    other Hook functions can be used, but we need to make sure not to violate the
    rules of Hooks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the advantage of creating API Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When defining separate functions for the various API calls, we can easily adjust
    them if the API changes later on, because we have all the API-related code in
    one place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should we extract functionality into a custom Hook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should create a custom Hook when a certain functionality is used in multiple
    places or when it could be re-used later on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we use custom Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can simply call custom Hooks just like we would call official React Hooks
    or Hooks from libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should we create local Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local Hooks can be used when we want to encapsulate a certain functionality
    in a separate function, but it will only be used in a single component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which interactions between Hooks are possible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use other Hooks in Hook functions and we can pass values from other Hooks
    to Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which library can we use to test Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `jest` test runner in combination with the React Hooks Testing
    Library (`@testing-library/react-hooks`) and the `react-test-renderer` to test
    Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we test Hook actions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hook actions can be tested by using the `act` function. For example, `act(()
    => result.current.increment())`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we test contexts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Contexts can be tested by writing a context wrapper function, which returns
    the provider. The wrapper function can then be passed to the `renderHook` function.
    For example, `const { result } = renderHook(() => useTheme(), { wrapper: ThemeContextWrapper
    })`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we test asynchronous code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the async/await construct in combination with the `waitForNextUpdate`
    function returned from `renderHook` to wait for asynchronous code to finish running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 11: Migrating from React Class Components'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are React class components defined?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React class components are defined by using `class ComponentName extends React.Component
    {`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do we need to call when using a `constructor` with class components? Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We first need to call `super(props)` to ensure that the props get passed on
    to the `React.Component` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we set the initial state with class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can set the initial state in class components by defining the `this.state`
    object in the `constructor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we change the state with class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In class components, we use `this.setState()` to change the state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need to re-bind the `this` context with class component methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When passing a method to an element as event handler, the `this` context changes
    to the element that triggered the event. We need to re-bind the `this` context
    to the class to prevent this from happening.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we re-bind the `this` context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to use `.bind(this)` on the method in the constructor. For example, `this.handleInput
    = this.handleInput.bind(this)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we use React context with class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can set the `contextType` and then access `this.context`. For example, `static
    contextType = StateContext`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to use multiple contexts, we can use context consumers. For example, `<StateContext.Consumer>{value
    => <div>State is: {value}</div>}</StateContext.Consumer>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What can we replace state management with when migrating to Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can replace `this.state` and `this.setState` with a State Hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the trade-offs of using Hooks versus class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function components with Hooks are simpler (no need to deal with constructors,
    `this`, or destructuring the same values multiple times, no magic when dealing
    with contexts, props, and state, no need to define both `componentDidMount` and
    `componentDidUpdate`). Function components also encourage making small and simple
    components, are easier to refactor and test, require less code, are easier to
    understand for beginners, and are more declarative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, class components can be fine when sticking to certain conventions and
    using the latest JavaScript features to avoid `this` re-binding. Furthermore,
    class components might be easier to understand for the team, because of existing
    knowledge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When and how should an existing project be migrated to Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Slowly replace old class components with Hook-based function components when
    appropriate. For example, when you are already refactoring a component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 12: Redux and Hooks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What kind of state should Redux be used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Redux should be used for global state, which is state that is used in multiple
    components across our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which elements does Redux consist of?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Redux consists of the **store** (an object that describes the full state of
    our application), **actions** (objects that describe state modifications), **action
    creators** (functions that create action objects), **reducers** (functions that
    take the current state and an action object and return a new state), and **connectors**
    (higher-order components that connect an existing component to Redux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the three principles of Redux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Single source of truth (data should always have a single source)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read-only state (it is not possible to modify state directly, only through dispatching
    actions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State changes are processed with pure functions (given the same state and action,
    reducers will always return the same new state)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we define action types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Action types avoid making typos when defining or comparing the `type` property
    of actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we connect components to Redux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can either use the `connect` higher-order component, or Dispatch and Selector
    Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which Hooks can we use with Redux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`useDispatch` to get the dispatch function, `useSelector` to get a certain
    part of the state, and `useStore` to get the Redux store (for special use cases,
    such as replacing reducers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why should we create reusable selectors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reusable selectors can be used in multiple components. Furthermore, they memoize
    the result and only recompute it when the state changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we migrate a Redux application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should first replace simple local state, such as input field values, with
    State Hooks. Then replace complex local state with Reducer Hooks. We keep global
    state, which is used across multiple components, in the Redux store. Finally,
    we use the Selector and Dispatch Hooks instead of the `connect` higher-order component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the trade-offs of Redux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The pros of using Redux are: It provides a certain project structure that allows
    us to easily extend and modify code later on, there are fewer possibilities for
    errors in our code, it has better performance than simply using React context
    for state, and it makes our `App` component much simpler by offloading state management
    and action creators to Redux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The downsides of using Redux are: It requires a lot of boilerplate code, the
    project structure becomes more complicated, and it requires a wrapper component
    (`Provider`) to connect the app to the store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should we use Redux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should use Redux only for applications that require complex state changes.
    For simple projects, Reducer Hooks or even just State Hooks might be enough.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 13: MobX and Hooks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which elements form the MobX life cycle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Events invoke **actions**, which modify state. **State** is observable and should
    not contain redundant or derivable data. **Computed values** are derived from
    the state through pure functions. **Reactions** are like computed values, but
    they can also produce a side-effect, such as updating the user interface in React.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which decorators does MobX provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'MobX provides decorators for the various elements: `observer`, `observable`,
    `computed`, and `action`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we connect components to MobX?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can connect our app to the MobX store by using the `Provider` component and
    then connect components via the `inject` higher-order component. If we want a
    component to automatically re-render on state changes, we also need to wrap it
    with the `observer` decorator function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which Hooks does MobX provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `useObserver` Hook to define parts of our component that should
    re-compute when the state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we access the MobX store using Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MobX provides a context, which can be used to create custom Hooks that access
    the MobX stores. We can use a normal Context Hook to access the `MobXProviderContext`
    from `mobx-react`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we store local state using MobX?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, with MobX we can create as many stores as we want. MobX even provides a
    `useLocalStore` Hook to create local stores.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How should we go about migrating an existing MobX application to Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can slowly upgrade certain parts of our MobX applications. Instead of the
    `inject` higher-order component, we can use a custom Hook that accesses a part
    of the context. Instead of the `observer` higher-order component, we can use the
    `useObserver` Hook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should first use a State Hook for simple local state, then a `useLocalState` Hook
    for complex local state, and finally keep global state in separate MobX stores.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the advantages of using MobX?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It provides a simple way of dealing with state changes, requires less boilerplate
    code, provides more flexibility in how our application code is structured, allows
    using multiple global and local stores, and makes the `App` component much simpler
    by offloading state management and actions to MobX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the disadvantages of using MobX?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows state changes to happen anywhere, not just in a single store, which
    could make our app more unpredictable. More flexibility also means it is possible
    to structure the project in a bad way and cause errors or bugs. Furthermore, MobX
    requires a wrapper component to connect the app to the store if we want to get
    all features (we could directly import and use the MobX store, but it would break
    features such as server-side rendering).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should MobX not be used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MobX should not be used if state changes are simple and only local state within
    components is used. In that case, State and Reducer Hooks might be enough.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
