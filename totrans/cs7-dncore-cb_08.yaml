- en: High Performance Programming Using Parallel and Multithreading in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter takes a look at improving your code''s performance using multithreading
    and parallel programming. In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and aborting a low-priority background thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the maximum thread pool size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking one thread until the contended resources are available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking parallel calls to methods using Parallel.Invoke
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a parallel foreach loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancelling a parallel foreach loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catching errors in parallel foreach loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you can find a single core CPU in a computer today, it will probably mean
    that you are standing in a museum. Every new computer today utilizes the advantages
    of multiple cores. Programmers can take advantage of this extra processing power
    in their own applications. As applications have grown in size and complexity,
    in many cases they actually need to utilize multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: While not every situation is always suited to the implementation of multithreaded
    code logic, it is good to know how to use multithreading to improve the performance
    of your applications. This chapter will take you through the fundamentals of this
    exciting technology in C# programming.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and aborting a low-priority background thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reason we want to take a look at a background thread specifically is because,
    by default, all threads created by the main app thread or `Thread` class constructor
    are foreground threads. So, what exactly separates a foreground thread from a
    background thread? Well, background threads are identical to foreground threads
    with the exception that if all foreground threads are terminated, the background
    threads are stopped too. This is useful if you have a process in your application
    that must not stop the application from terminating. In other words, while your
    application is running, the background threads must continue to run.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a simple application that defines the thread created as a background
    thread. It will then suspend, resume, and abort the thread.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new console application in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add a class called `Demo` to your console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `Demo` class, add a method called `DoBackgroundTask()` with the
    `public void` modifiers, and add the following console output to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you have added the `using` statements for `System.Threading`
    and `static System.Console` to your `using` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `void Main` method of your console application, create a new instance
    of your `Demo` class and add it to a new thread called `backgroundThread`. Define
    this newly created thread to be a background thread and then start it. Finally,
    set the thread to sleep for 5 seconds. We need to do this because we created a
    background thread that is set to sleep for 3 seconds. Background threads do not
    prohibit foreground threads from terminating. Therefore, if the main application
    thread (which is by default a foreground thread) terminates before the background
    thread completes, the application will terminate and also terminate the background
    thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your console application by pressing *F5*. You will see that we have created
    a background thread with a normal priority:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s modify our thread and set its priority down to low. Add this line of
    code to your console application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This line will downgrade the thread priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your console application again. This time, you will see that the thread
    priority has been set to the lowest priority:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go back to your `DoBackgroundTask()` method and add `Thread.CurrentThread.Abort();`
    right before `Thread.Sleep(3000);` is called. This line will prematurely kill
    the background thread. Your code should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run your console application, you will see that the thread is aborted
    before the `Thread.Sleep` method is called. Aborting a thread in this way, however
    is, generally, not recommended:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_08.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to create a background thread is a great way to work on a different
    thread from the main thread while not interfering with the process of the main
    application thread. Another added benefit is that the background thread is terminated
    as soon as the main application thread is completed. This process ensures that
    your application will terminate gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the maximum thread pool size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The thread pool in .NET resides in the `System.Threading.ThreadPool` class.
    Generally, there is a lot of discussion around creating your own threads, as opposed
    to using the thread pool. Popular thinking dictates that the thread pool should
    be used for brief jobs. This is because the thread pool is limited in size. There
    are many other processes in the system that will use the thread pool. You, therefore,
    do not want your application to hog all the threads in the thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: The rule is that you can't set the number of maximum worker or completion threads
    to be fewer than the number of processors on your computer. You are also not allowed
    to set the maximum worker or completion threads to less than the minimum thread
    pool size.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will read the number of processors on the current computer. Then, we will
    get the minimum and maximum allowable thread pool size, generate a random number
    between the minimum and maximum thread pool size, and set the maximum number of
    threads on the thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new method called `IncreaseThreadPoolSize()` in the `Demo` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by adding the code to read the number of processors on the current machine
    using `Environment.ProcessorCount`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we retrieve the maximum and minimum threads available in the thread pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we generate a random number between the maximum and minimum number of
    threads in the thread pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to attempt to set the maximum number of threads in the thread pool
    by calling the `SetMaxThreads` method, and setting it to our new random maximum
    value for the worker threads and the completion port threads. Any requests above
    this maximum number will be queued until the thread pool threads become active
    again. If the `SetMaxThreads` method is successful, the method will return true;
    otherwise, it will return `false`. It is a good idea to ensure that the `SetMaxThreads`
    method is successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Worker threads is the maximum number of worker threads in the thread pool while
    the completion port threads is the maximum number of asynchronous I/O threads
    in the thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''ve added all the code in the steps listed, your `IncreaseThreadPoolSize()`
    method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Head on over to your console application, create a new instance of your `Demo` class,
    and call the `IncreaseThreadPoolSize()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run your console application and take note of the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_09.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the console application, we can see that the processor count is `2`. The
    minimum number of thread pool threads, therefore, also equals `2`. We then read
    the maximum thread pool size and generate a random number between the minimum
    and maximum numbers. Lastly, we set the maximum thread pool size, to our randomly
    generated minimum and maximum.
  prefs: []
  type: TYPE_NORMAL
- en: While this is only a proof of concept and not something one would do in a production
    application (setting the thread pool to a random number), it clearly illustrates
    the ability to set the thread pool to a value specified by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this recipe was compiled for 32-bit. Try changing your application
    to a 64-bit application and run the code again. See the difference a 64-bit makes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we need to create multiple threads. Before we can continue, however,
    we need to wait for these threads to complete doing whatever they need to do.
    For this, the use of tasks is best suited.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure that you add the `using System.Threading.Tasks;` statement to the
    top of your `Recipes` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new method called `MultipleThreadWait()` in your `Demo` class. Then,
    create a second method called `RunThread()` with the `private` modifier that takes
    an integer of seconds to make the thread sleep. This will simulate the process
    of doing some work for a variable amount of time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In reality, you would probably not call the same method. You could, for all
    intents and purposes, call three separate methods. Here, however, for simplicity's
    sake, we will call the same method with different sleep durations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your `MultipleThreadWait()` method. You will notice
    that we are creating three tasks that then create three threads. We then fire
    off these three threads and make them sleep for `3`, `5`, and `2` seconds. Finally,
    we call the `Task.WaitAll` method to wait before continuing the execution of the
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `RunThread()` method, we read the current thread ID and then make
    the thread sleep for the amount of milliseconds supplied. This is just the integer
    value for the seconds multiplied by `1000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have completed the code, your `Demo` class should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add a new instance of the `Demo` class to your console application
    and call the `MultipleThreadWait()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your console application and view the output produced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_10.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will notice that three threads (`thread 3`, `thread 4`, and `thread 5`)
    are created. These are then paused by making them sleep for various amounts of
    time. After each thread wakes, the code waits for all three threads to complete
    before continuing the execution of the application code.
  prefs: []
  type: TYPE_NORMAL
- en: Locking one thread until the contended resources are available
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are instances where we want to give sole access to a process to a specific
    thread. We can do this using the `lock` keyword. This will, therefore, execute
    this process in a thread-safe manner. Hence, when a thread runs the process it
    will gain exclusive access to the process for the duration of the lock scope.
    If another thread tries to gain access to the process inside the locked code,
    it will be blocked and have to wait its turn until the lock is released.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example, we will use tasks. Make sure that you've added the `using
    System.Threading.Tasks;` statement to the top of your `Demo` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `Demo` class, add an object called `threadLock` with the `private` modifier.
    Then, add two methods called `LockThreadExample()` and `ContendedResource()` that
    take an integer of seconds to sleep as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It is considered to be a best practice to define the object to lock on as private.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add three tasks to the `LockThreadExample()` method. They will create threads
    that try to access the same section of code simultaneously. This code will wait
    until all the threads have completed before terminating the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ContendedResource()` method, create a lock using the `private threadLock`
    object and then make the thread sleep for the amount of seconds passed to the
    method as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the console application, add the following code to instantiate a new
    `Demo` class and call the `LockThreadExample()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the console application and look at the information output to the console
    window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_11-1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can see that `thread 4` gained exclusive access to the contended resource.
    At the same time, `thread 3` and `thread 5` tried to access the contended resource
    locked by `thread 4`. This then caused the other two threads to wait until `thread
    4` had completed and released the lock. The result of this is that the code is
    executed in an orderly manner, as can be seen in the console window output. Each
    thread waits its turn until it can access the resource and lock its thread.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking parallel calls to methods using Parallel.Invoke
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Parallel.Invoke` allows us to execute tasks in (you guessed it) parallel.
    Sometimes, you need to perform operations simultaneously and, in so doing, speed
    up the processing. You can, therefore, expect that the total time taken to process
    the tasks is equal to the longest running process. Using `Parallel.Invoke` is
    quite easy.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure that you've added the `using System.Threading.Tasks;` statement to
    the top of your `Demo` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start off by creating two methods in the `Demo` class called `ParallelInvoke()`
    and `PerformSomeTask()` that take an integer of seconds to sleep as the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `ParallelInvoke()` method. This code will call
    `Paralell.Invoke` to run the `PerformSomeTask()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `PerformSomeTask()` method, make the thread sleep for the amount of
    seconds passed to the method as the parameter (converting the seconds to milliseconds
    by multiplying it by `1000`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When you''ve added all the code, your `Demo` class should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the console application, instantiate a new instance of the `Demo` class
    and call the `ParallelInvoke()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the console application and look at the output produced in the console
    window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_12.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we are running all these threads in parallel, we can assume that the
    longest process will denote the total duration of all the tasks. This means that
    the total duration of the process will be 5 seconds because the longest task will
    take 5 seconds to complete (we set `thread 3` to sleep for a maximum of 5 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the time difference between the start and the end of `Parallel.Invoke`
    is exactly 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Using a parallel foreach loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A while ago, during a work retreat (yes, the company I work for is really that
    cool), Graham Rook, who is one of my colleagues, showed me a parallel `foreach`
    loop. It certainly speeds up processing a great deal. But here's the rub. It makes
    no sense to use a parallel `foreach` loop if you're dealing with small amounts
    of data or little tasks. The parallel `foreach` loop excels when there is bulk
    processing to do or huge amounts of data to process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start off by looking at where the parallel `foreach` loop does not perform
    better than the standard `foreach` loop. For this, we will create a small list
    of 500 items and just iterate over the list, writing the items to the console
    window.
  prefs: []
  type: TYPE_NORMAL
- en: For the second example, which illustrates the power of the parallel `foreach`
    loop, we will use the same list and create a file for each item in the list. The
    power and benefit of the parallel `foreach` loop will be evident in the second
    example. You will need to add the `using System.Diagnostics;` and `using System.IO;`
    namespaces to run this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start off by creating two methods in the `Demo` class. Call one method `ReadCollectionForEach()`
    and pass it a parameter of `List<string>`. Create a second method called `ReadCollectionParallelForEach()`
    that also accepts a parameter of `List<string>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ReadCollectionForEach()` method, add a standard `foreach` loop that
    will iterate over the collection of strings passed to it and write the value it
    finds to the console window. Then, clear the console window. Use a timer to keep
    track of the total seconds elapsed during the `foreach` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second method, called `ReadCollectionParallelForEach()`, do the same.
    However, instead of using a standard `foreach` loop, add a `Parallel.ForEach`
    loop. You will notice that the `Parallel.ForEach` loop looks slightly different.
    The signature of `Parallel.ForEach` requires that you pass it an enumerable data
    source (`List<string> intCollection`) and define an action, which is the delegate
    that is invoked for every iteration (`integer`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have added all the required code, your `Demo` class should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the console application, create the `List<string>` collection and pass it
    to the two methods created in the `Demo` class. You will notice that we are only
    creating a collection of 500 items. After the code is completed, return the time
    elapsed in seconds and output it to the console window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your application. From the output displayed, you will see the difference
    in performance. The `Parallel.ForEach` loop actually took longer to complete than
    the `foreach` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use a different example now. We will create a process-intensive task
    and measure the performance gain that the `Parallel.ForEach` loop will give us.
    Create two methods called `CreateWriteFilesForEach()` and `CreateWriteFilesParallelForEach()`
    that both take the `List<string>` collection as the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `CreateWriteFilesForEach()` method. This code
    starts the timer and executes the standard `foreach` loop on the `List<string>`
    object. It then writes the elapsed time out to the console window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `foreach` loop, add the code to check whether a file exists with
    the specific name created by appending the `integer` value to the filename portion
    of the `filePath` variable. Create the file (ensuring that you use the `Dispose`
    method so as not to lock the file when trying to write to it) and write some text
    to the newly created file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add this code to the `CreateWriteFilesParallelForEach()` method, which
    basically performs the same function as the `CreateWriteFilesForEach()` method,
    but uses a `Parallel.ForEach` loop to create and write files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the slightly modified file-creation code inside the `Parallel.ForEach`
    loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When you are done, your code needs to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Head over to the console application, modify the `List<string>` object slightly,
    and increase the count from `500` to `1000`. Then, call the file methods created
    in the `Demo` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when you are ready, make sure that you have the `C:tempoutput` directory
    and that there aren''t any other files in that directory. Run your application
    and review the output in the console window. This time round, we can see that
    the `Parallel.ForEach` loop has made a huge difference. The performance gain is
    massive and heralds a 47.42 percent performance increase over the standard `foreach`
    loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_14.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the examples used in this recipe, it is clear that use of the parallel
    `foreach` loop should be considered carefully. If you are dealing with relatively
    low volumes of data or non-process intensive transactions, the parallel `foreach`
    loop will not benefit your application's performance much. In some instances,
    the standard `foreach` loop could be much faster than the parallel `foreach` loop.
    If, however, you find your application running into performance issues when processing
    large amounts of data or running processor-intensive tasks, give the parallel
    `foreach` loop a try. It just might surprise you.
  prefs: []
  type: TYPE_NORMAL
- en: Cancelling a parallel foreach loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with parallel `foreach` loops, the obvious question is how one
    would terminate the loop prematurely based on a certain condition, such as a timeout.
    As it turns out, the parallel `foreach` loop is quite easy to terminate prematurely.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a method that takes a collection of items and loops through this
    collection in a parallel `foreach` loop. It will also be aware of a timeout value
    that, if exceeded, will terminate the loop and exit the method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start off by creating a new method called `CancelParallelForEach()` in the
    `Demo` class, which takes two parameters. One is a collection of `List<string>`,
    while the other is an integer specifying a timeout value. When the timeout value
    is exceeded, the `Parallel.ForEach` loop must terminate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `CancelParallelForEach()` method, add a timer to keep track of the
    elapsed time. This will signal the loop that the timeout threshold has been exceeded
    and that the loop needs to exit. Create a `Parallel.ForEach` method defining a
    state. In each iteration, check the elapsed time against the timeout, and if the
    time is exceeded, break out of the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the console application, create the `List<string>` object and add `1000`
    items to it. Call the `CancelParallelForEach()` method with a timeout of only
    `5` seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your console application and review the output results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_15.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can see from the console window output that, as soon as the elapsed time
    exceeded the timeout value, the parallel loop was notified to cease the execution
    of iterations beyond the current iteration at the system's earliest convenience.
    Having this kind of control over the `Parallel.ForEach` loop allows developers
    to avoid runaway loops, and gives the user control to cancel a loop operation
    by clicking on a button or automatically having the application terminate when
    the timeout value has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: Catching errors in parallel foreach loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With parallel `foreach` loops, developers can wrap the loop in a `try...catch`
    statement. Care needs to be taken, however, because the `Parallel.ForEach` will
    throw an `AggregatedException`, which has the exceptions it encounters over several
    threads rolled into one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a `List<string>` object that contains a collection of machine
    IP addresses. The `Parallel.ForEach` loop will check the IP addresses to see whether
    the machines on the other end of the given IPs are alive. It does this by pinging
    the IP address. The method that performs the `Parallel.ForEach` loop will also
    be given the minimum required alive machines as an integer value. If the minimum
    number of machines alive is not met, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `Demo` class, add a method called `CheckClientMachinesOnline()`, which
    takes as parameters a `List<string>` collection of IP addresses and an integer
    that specifies the minimum number of machines required to be online. Add a second
    method called `MachineReturnedPing()`, which will receive an IP address to ping.
    For our purpose, we will just return `false` to mimic a dead machine (the ping
    to the IP address timed out):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `CheckClientMachinesOnline()` method, add the `Parallel.ForEach`
    loop and create the `ParallelOptions` variable that will specify the degree of
    parallelism. Wrap all this code inside a `try...catch` statement and catch an `AggregateException`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Parallel.ForEach` loop, write the code to check whether the machine
    is online by calling the `MachineReturnedPing()` method. In our example, this
    method will always return `false`. You will notice that we are keeping track of
    the offline machine count via the `Interlocked.Increment` method. This is just
    a way of incrementing a variable across the threads of the `Parallel.ForEach`
    loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have added all the code correctly, your `Demo` class will look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the console application, create the `List<string>` object to store a collection
    of dummy IP addresses. Instantiate your `Demo` class and call the `CheckClientMachinesOnline()`
    method, passing the collection of IP addresses and the minimum number of machines
    required to be online to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your application and review the output in the console window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_16.png)'
  prefs: []
  type: TYPE_IMG
- en: Just a point to note. If you have Just My Code enabled, in some cases Visual
    Studio will break on the line that throws the exception. It might also say that
    the exception is not handled by the user code. You can just press *F5* to continue.
    To prevent this from happening, uncheck Enable Just My Code under Tools, Options,
    Debugging, and General.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the console window output, you can see that the minimum number of machines
    required to be online was not achieved. The application then threw an exception
    and caught it from the `Parallel.ForEach` loop. Being able to handle exceptions
    in parallel loops such as this one is essential for maintaining the stability
    of your application by being able to handle exceptions as they occur.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to play around a little with the `Parallel.ForEach` loop and
    drill into some of the inner methods of the `AggregareException` class to really
    understand it better.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging multiple threads in Visual Studio is tricky, especially since these
    threads are all running at the same time. Luckily, we have a few tools available
    to us as developers to use to get a better understanding of what is happening
    in our multithreaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While debugging multithreaded applications, you can access various windows by
    navigating to Debug | Windows in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start debugging your multithreaded application after adding a break point somewhere
    in the code. You can access various debugging windows by going to Debug | Windows
    in Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_17.png)'
  prefs: []
  type: TYPE_IMG
- en: The first window available to you is the Threads window. Access it by going
    to Debug | Windows in Visual Studio or type *Ctrl* + *D*, *T*. In here, you can
    right-click on a thread to watch and flag it. If you have given your threads names,
    you will see those names appear in the Name column. To give your thread a name,
    modify the `LockThreadExample()` method created in an earlier recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You will also be able to see the currently active thread in the debugger. It
    will be marked with a yellow arrow. Then, there is the managed ID, which is the
    same ID you will have used to create the unique thread name earlier on.
  prefs: []
  type: TYPE_NORMAL
- en: The Location column displays the current method that the thread is in. The Threads
    window allows you to view the stack of the thread by double-clicking on the Location
    field. You can also freeze and thaw threads. Freezing stops a thread from executing,
    while thawing allows the frozen thread to continue as normal.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_09_18-2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Tasks window can be accessed by going to Debug | Windows or by holding
    down *Ctrl* + *Shift* + *D*, *K*. To see this in action, place a break point in
    your `LockThreadExample()` method on the line that reads `Task.WaitAll(thread1,
    thread2, thread3);`. Debug your application again and look at the Status column
    for each thread created. The status of the task shows the status at that moment,
    and we can see that the three threads are Active, Blocked, and Scheduled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Parallel Stacks window can be accessed by going to Debug | Windows in Visual
    Studio or by holding down *Ctrl* + *D* + *S* key. Here, you can see a graphical
    view of the tasks and threads. You can switch between the Threads and Tasks view
    by making a selection in the drop-down list in the upper-left corner of the Parallel
    Stacks window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Changing the selection to Tasks will show you the current tasks in the debug
    session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_09_21.png)'
  prefs: []
  type: TYPE_IMG
- en: The next window, undoubtedly my favorite, is the Parallel Watch window. It is
    in fact identical to the standard Watch window in Visual Studio, but this watches
    values across all threads in your application. You can type any valid C# expression
    into Parallel Watch and see the values as they are at that moment in the debug
    session. Try it out by adding several break points and adding expressions into
    the Parallel Watch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to use the debugging tools for multithreaded applications effectively
    in Visual Studio makes it much easier to understand the structure of your application
    and helps you identify possible bugs, bottlenecks, and areas of concern.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to learn more about these various debugging windows available
    to you.
  prefs: []
  type: TYPE_NORMAL
