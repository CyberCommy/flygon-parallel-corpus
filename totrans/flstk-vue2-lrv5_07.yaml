- en: Building a Multi-Page App with Vue Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we learned about Vue.js components and converted Vuebnb
    to a component-based architecture. Now that we've done this, we can easily add
    new pages to our app using Vue Router.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll create a home page for Vuebnb, including a gallery of
    clickable thumbnails that showcase the full set of mock listings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An explanation of what router libraries are and why they are a critical part
    of single-page applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of Vue Router and its main features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation and basic configuration of Vue Router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `RouterLink` and `RouterView` special components to manage page navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up AJAX with Vue to retrieve data from the web service without a page
    refresh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using route navigation guards to retrieve data before a new page is loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-page applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most websites are broken up into pages in order to make the information they
    contain easier to consume. Traditionally this is done with a server/client model,
    where each page must be loaded from the server with a different URL. To navigate
    to a new page, the browser must send a request to the URL of that page. The server
    will send the data back and the browser can unload the existing page and load
    the new one. For the average internet connection, this process will likely take
    a few seconds, during which the user must wait for the new page to load.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using a powerful frontend framework and an AJAX utility, a different model
    is possible: the browser can load an initial web page, but navigating to new pages
    will not require the browser to unload the page and load a new one. Instead, any
    data required for new pages can be loaded asynchronously with AJAX. From a user''s
    perspective, such a website would appear to have pages just like any other, but
    from a technical perspective, this site really only has one page. Hence the name,
    **Single-Page Application** (**SPA**).'
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of the Single-Page Application architecture is that it can create
    a more seamless experience for the user. Data for new pages must still be retrieved,
    and will therefore create some small disruption to the user's flow, but this disruption
    is minimized since the data retrieval can be done asynchronously and JavaScript
    can continue to run. Also, since SPA pages usually require less data due to the
    reuse of some page elements, page loading is quicker.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of the SPA architecture is that it makes the client app bulkier
    due to the added functionality, so gains from speeding up page changes may be
    negated by the fact that the user must download a large app on the first page
    load. Also, handling routes adds complexity to the app as multiple states must
    be managed, URLs must be handled, and a lot of default browser functionality must
    be recreated in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are going with an SPA architecture and your app design includes multiple
    pages, you''ll want to use a *router*. A router, in this context, is a library
    that will mimic browser navigation through JavaScript and various native APIs
    so that the user gets an experience similar to that of a traditional multi-page
    app. Routers will typically include functionality to:'
  prefs: []
  type: TYPE_NORMAL
- en: Handle navigation actions from within the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Match parts of the application to routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage the address bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage the browser history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage scroll bar behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vue Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some frontend frameworks, such as Angular or Ember, include a router library
    out-of-the-box. The philosophy guiding these frameworks is that the developer
    is better served with a complete, integrated solution for their SPA.
  prefs: []
  type: TYPE_NORMAL
- en: Others frameworks/libraries, such as React and Vue.js, do not include a router.
    Instead, you must install a separate library.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Vue.js, an official router library is available called *Vue Router*.
    This library has been developed by the Vue.js core team, so it is optimized for
    usage with Vue.js and makes full use of fundamental Vue features such as components
    and reactivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Vue Router, different *pages* of the application are represented by different
    components. When you set up Vue Router, you will pass in configuration to tell
    it which URLs map to which component. Then, when a link is clicked in the app,
    Vue Router will swap the active component so as to match the new URL, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since rendering a component is an almost instantaneous process in normal circumstances,
    the transition between pages with Vue Router is as well. However, there are asynchronous
    hooks that can be invoked to give you the opportunity to load new data from the
    server, if your different pages require it.
  prefs: []
  type: TYPE_NORMAL
- en: Special components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you install Vue Router, two components are registered globally for use
    throughout your app: `RouterLink` and `RouterView`.
  prefs: []
  type: TYPE_NORMAL
- en: '`RouterLink` is generally used in place of `a` tags and gives your links access
    to the special features of Vue Router.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As explained, Vue Router will swap designated page components as a way of mimicking
    browser navigation. `RouterView` is the outlet in which this component swap takes
    place. Like a slot, you put it somewhere in your main page template. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Vuebnb routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It was never a stated goal for Vuebnb to be a single-page application. Indeed,
    Vuebnb will deviate from pure SPA architecture as we'll see later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: That said, incorporating Vue Router will be very beneficial to the user's experience
    of navigation in the app, so we'll add it to Vuebnb in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if we''re going to add a router, we''ll need some extra pages! So
    far in the project, we''ve been working on the *listing* page of Vuebnb, but are
    yet to start work on the front page of the app. So in addition to installing Vue
    Router, we will start work on the Vuebnb home page, which displays thumbnails
    and links to all our mock listings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ecdce2d9-a3cb-45ea-81f0-2f653471205e.png)Figure 7.1\. Front page
    of Vuebnb'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vue Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vue Router is an NPM package and can be installed on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put our router configuration into a new file, `router.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To add Vue Router to our project, we must import the library and then use the `Vue.use` API
    method to make Vue compatible with Vue Router. This will give Vue a new configuration
    property, `router`, that we can use to connect a new router.
  prefs: []
  type: TYPE_NORMAL
- en: We then create an instance of Vue Router with new `VueRouter()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/router.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By exporting our router instance from this new file, we've made it into a module
    that can be imported in `app.js`. If we name the imported module `router`, object
    destructuring can be used to succinctly connect it to our main configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic configuration for Vue Router is to provide a `routes` array, which
    maps URLs to the corresponding page components. This array will contain objects
    with at least two properties: `path` and `component`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that by *page components* I'm simply referring to any components that we've
    designated to represent a page in our app. They are regular components in every
    other way.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we're only going to have two routes in our app, one for our home page
    and one for our listing page. The `HomePage` component doesn't exist yet, so we'll
    keep its route commented out until we create it.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/router.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that the path for our `ListingPage` component contains a dynamic
    segment `:listing` so that this route will match paths including `/listing/1, listing/2 ... listing/whatever`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two modes for Vue Router: *hash* mode and *history* mode. Hash mode
    uses the URL hash to simulate a full URL so that the page won't be reloaded when
    the hash changes. History mode has *real* URLs and leverages the `history.pushState` API
    to change the URL without causing a page reload. The only downside to history
    mode is that URLs outside of the app, such as `/some/weird/path`, can't be handled
    by Vue and must be handled by the server. That's no problem for us, so we'll use
    history mode for Vuebnb.
  prefs: []
  type: TYPE_NORMAL
- en: App component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our router to work, we need to declare a `RouterView`component somewhere
    in our page template. Otherwise, there's nowhere for the page components to render.
  prefs: []
  type: TYPE_NORMAL
- en: We'll slightly restructure our app to do this. As it is, the `ListingPage` component
    is the `root` component of the app, as it is at the top of the component hierarchy
    and loads all other components that we use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want the router to switch between `ListingPage` and `HomePage` based
    on the URL, we need another component to be above `ListingPage`in the hierarchy
    and handle this work. We''ll call this new root component `App`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2a411013-4710-4909-ad18-255dd9144d45.png)Figure 7.2\. The relationship
    between App, ListingPage, and HomePage'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `App` component file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The root instance of Vue should render this to the page when it loads, instead
    of `ListingPage`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The following is the content of the `App` component. I've added the special `RouterView` component
    into the template, which is the outlet where either the `HomePage` or `ListingPage` component
    will render.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also notice I've moved the toolbar from `app.blade.php` into the template
    of `App`. This is so the toolbar is in the domain of Vue; before it was outside
    of the mount point and therefore untouchable by Vue. I've done this so that later
    we can make the main logo a link to the home page using `RouterLink`, as this
    is a convention for most websites. I've moved any toolbar related CSS into the `style` element
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With that done, if you now navigate the browser to a URL like `/listing/1`,
    you'll see everything looks the same as it did before. However, if you look at
    Vue Devtools, you'll see the component hierarchy has changed, reflecting the addition
    of the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also an indicator, which tells us that the `ListingPage` component
    is the active page component for Vue Router:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/41b25c67-0eeb-449c-8448-c7703091d149.png)Figure 7.3. /listing/1 with
    Vue Devtools open, showing the component hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: Home page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start work on our home page now. We''ll first create a new component, `HomePage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For now, let's add placeholder markup to the component before we set it up properly.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/HomePage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to import this component in the `router` file, and uncomment the route
    where it's used.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/router.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You might be tempted to test this new route out by putting the URL `http://vuebnb.test/`into
    your browser address bar. You'll find, though, that it results in a 404 error.
    Remember, we still haven't created a route for this on our server. Although Vue
    is managing routes from *within* the app, any address bar navigation requests
    must be served from Laravel.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now create a link to our home page in the toolbar by using the `RouterLink`component.
    This component is like an enhanced `a`tag. For example, if you give your routes
    a `name` property, you can simply use the `to` prop rather than having to supply
    an `href`. Vue will resolve this to the correct URL on render.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's also add name properties to our routes for this to work.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We'll also have to modify our CSS now since we now have another tag wrapped
    around our logo. Modify the toolbar CSS rules to match those that follow.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now open a listing page, such as `/listing/1`. If you inspect the DOM,
    you''ll see that our toolbar now has a new `a` tag inside it with a correctly
    resolved link back to the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f53a1ca6-f0d5-4c08-b75c-c6f794e81b96.png)Figure 7.4\. The toolbar
    is a link back to the home page via the RouterLink element'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click that link, you''ll be taken to the home page! Remember, the *page*
    hasn''t actually changed; Vue router simply swapped `ListingPage` for `HomePage` within `RouterView`,
    and also updated the browser URL via the `history.pushState` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4a5c5d24-13bb-45ea-8dac-a2272c4f7a4b.png)Figure 7.5\. Home page
    with Vue Devtools showing component hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: Home route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now add a server-side route for the home page so that we can load our
    app from the root path. This new route will point to a `get_home_web` method in
    our `ListingController` class.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/web.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Going to the controller now, we'll make it so the `get_home_web` method returns
    the `app` view, just as it does for the listing web route. The `app` view includes
    a template variable model which we use to pass through the initial application
    state, as set up in [Chapter 5](f7d2046c-81c6-416b-977e-2f166a911244.xhtml), *Integrating
    Laravel and Vue.js with Webpack*. For now, just assign an empty array as a placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With that done, we can now navigate to `http://vuebnb.test/` and it will work!
    When the Vue app is bootstrapped, Vue Router will check the URL value and, seeing
    that the path is `*/*`, will load the `HomePage` component inside the `RouterView` outlet
    for the first rendering of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Viewing the source of this page, it''s exactly the same page as we get when
    we load the listing route since it''s the same view, that is, `app.blade.php`.
    The only difference is that the initial state is an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c29df2f7-0487-481e-8df9-ffaac0b12063.png)Figure 7.6\. Page source
    of vuebnb.test with empty initial state'
  prefs: []
  type: TYPE_NORMAL
- en: Initial state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like our listing page, our home page will need initial state. Looking
    at the finished product, we can see that the home page displays a summary of all
    our mock listings with a thumbnail image, a title, and short description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bdfc15b5-27a5-4468-a68d-bd19e7a2ac25.png)Figure 7.7\. Completed
    home page, focusing on listings'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we inject the initial state into the home page, let's do a small refactoring
    of the code including renaming some variables and restructuring some methods.
    This will ensure that the code semantics reflect the changing requirements and
    keep our code readable and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, let's rename our template variable from `$model` to the more general `$data`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In our listing controller, we're now going to abstract any common logic from
    our listing route methods into a new helper method called `get_listing`. In this
    helper method, we will nest the `Listing` model inside a Laravel `Collection` under
    the `listing` key. `Collection` is an array-like wrapper for Eloquent models that
    offers a bunch of handy methods that we'll be putting to use shortly. `get_listing` will
    include logic from the `add_image_urls` helper method, which can now safely be
    deleted.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also need to reflect the change to our template variable when we call
    the `view` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we'll need to update our `ListingPage` component to reflect the new
    name and structure of the server data we're injecting.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Home page initial state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Eloquent ORM, it's trivial to retrieve all our listing entries using the
    method `Listing::all`. Multiple `Model` instances are returned by this method
    within a `Collection` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don't need all the fields on the model, for example, `amenities`,
    `about`, and  so on are not used in the listing summaries that populate the home
    page. To ensure our data is as lean as possible, we can pass an array of fields
    to the `Listing::all` method that will tell the database to only include those
    fields explicitly mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Adding the thumbnail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each mock listing has a thumbnail version of the first image, which can be used
    for the listing summary. The thumbnail is much smaller than the image we use for
    the header of the listing page and is ideal for the listing summaries on the home
    page. The URL for the thumbnail is `public/images/{x}/Image_1_thumb.jpg` where `{x}` is
    the ID of the listing.
  prefs: []
  type: TYPE_NORMAL
- en: '`Collection` objects have a helper method, `transform`, that we can use to
    add the thumbnail image URL to each listing. `transform` accepts a callback closure
    function that is called once per item, allowing you to modify that item and return
    it to the collection without fuss.'
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Receiving in the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the initial state now ready, let''s add it to our `HomePage` component.
    Before we can use it though there''s an additional aspect we need to consider:
    the listing summaries are grouped by *country*. Look again at *Figure 7.7* to
    see how these groups are displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: After we've parsed our injected data, let's modify the object so the listings
    are grouped by country. We can easily create a function to do this, as every listing
    object has an `address` property in which the country is always explicitly named,
    for example, *No. 51, Hanzhong Street, Wanhua District, Taipei City, Taiwan 108*.
  prefs: []
  type: TYPE_NORMAL
- en: To save you having to write this function, I have supplied one in the `helpers` module
    called `groupByCountry` which can be imported at the top of the component configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/HomePage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now see through Vue Devtools that `HomePage` has successfully loaded
    the listing summaries, grouped by country and ready for display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3936ccf7-bf87-4f1f-81b6-ba32cefb8c2c.png)Figure 7.8\. Vue Devtools
    showing the state of the HomePage component'
  prefs: []
  type: TYPE_NORMAL
- en: ListingSummary component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the `HomePage` component has data available, we can work on displaying
    it.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, clear out the existing content of the component and replace it
    with a `div`. This `div` will feature a `v-for` directive to iterate through each
    of our listing groups. Since `listing_groups` is an object with key/value pairs,
    we'll give our `v-for` two aliases: `group` and `country`, which are the value
    and key of each object item respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We will interpolate `country` inside a heading. `group` will be used in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/HomePage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the home page will now look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/858d9f59-82a4-4b37-9f17-d66fb6b3d5ee.png)Figure 7.9\. Iterating
    the listing summary groups in the HomePage component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since each listing summary will be of some complexity, we''ll create a separate
    component, `ListingSummary`, for displaying them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's declare `ListingSummary` within our `HomePage` template. We'll again use
    a `v-for` directive to iterate `group`, an array, creating a new instance of `ListingSummary` for
    each member. The data for each member will be bound to a single prop, `listing`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/HomePage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let's create some simple content for the `ListingSummary` component, just to
    test our approach.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummary.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Refreshing our page, we''ll now see this prototype of our listing summaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/914379fb-83ff-4ee2-9f2f-bf458f5c6cce.png)Figure 7.10\. Prototype
    of ListingSummary component'
  prefs: []
  type: TYPE_NORMAL
- en: Since this approach is working, let's now complete the structure of the `ListingSummary` component.
    To display the thumbnail, we bind it as a background image for a fixed width/height `div`.
    We'll also need some CSS rules to get this displaying nicely.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummary.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After you add that code, your listing summaries will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d03bd54-26e4-4b89-96ba-488b7749ccc8.png)Figure 7.11\. Complete
    listing summaries being displayed'
  prefs: []
  type: TYPE_NORMAL
- en: We gave each listing summary a fixed width/height so that we could display them
    in a neat grid. Currently, they're displaying in one tall column, so let's add
    some CSS flex rules to the `HomePage` component to get the summaries into rows.
  prefs: []
  type: TYPE_NORMAL
- en: We'll add a class `listing-summary-group` to the element that wraps the summaries.
    We'll also add a class `home-container` to the root `div` to constrain the width
    of the page and center the content.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/HomePage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we'll need to add a rule to prevent the listings from forcing the edge
    of the document to exceed the viewport. Add this to the main CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/css/style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we get a nice looking home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2af19583-0877-4a44-b9c5-44c1be1d91d5.png)Figure 7.12\. Listing summaries
    in rows'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that at full page width, we can only see three listings from
    each country group. The other seven are hidden by the CSS `overflow: hidden` rule.
    Soon, we''ll be adding image slider functionality to each group to allow the user
    to browse through all the listings.'
  prefs: []
  type: TYPE_NORMAL
- en: In-app navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we use the address bar of the browser to navigate to the home page, `http://vuebnb.test/`,
    it works because Laravel is now serving a page at this route. But, if we navigate
    to the home page *from the listing page*, there''s no longer any page content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4c4b9d22-86d4-4846-8b3d-3b5bb6f6ff55.png)Figure 7.13\. Empty home
    page after navigating from listing page'
  prefs: []
  type: TYPE_NORMAL
- en: We currently don't have any links to the listing page from the home page, but
    if we did, we'd experience a similar issue.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that our page components currently get their initial state from
    the data we've injected into the head of the document. If we navigate to a different
    page using Vue Router, which doesn't invoke a page refresh, the next page component
    will have the wrong initial state merged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to improve our architecture so that when a page is navigated to we
    check if the model injected into the head matches the current page. To facilitate
    this, we''ll add a `path`property to the model and check that it matches the active
    URL. If not, we''ll use AJAX to get the right data from the web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a22ae360-9d35-4247-b66a-1ae858d2130f.png)Figure 7.14\. How a page
    decides what data it needsIf you''re interested in reading more about this design
    pattern, check out the article *Avoid This Common Anti-Pattern In Full-Stack Vue/Laravel
    Apps* at [https://vuejsdevelopers.com/2017/08/06/vue-js-laravel-full-stack-ajax/](https://vuejsdevelopers.com/2017/08/06/vue-js-laravel-full-stack-ajax/).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a path to the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go to the listing controller and add a `path` property to the data injected
    into the head of our view. To do this, we'll add a helper function called `add_meta_data` which
    will add the path, as well as some other meta properties in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the path of the current route can be determined by the `Request` object.
    This object can be declared as the last argument of any `route-handling` functions
    and is provided in each request by the service container.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Route navigation guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to lifecycle hooks, *navigation guards* allow you to intercept Vue Router
    navigations at a particular point in their life cycle. These guards can be applied
    to a specific component, a specific route, or to all routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `afterEach` is the navigation guard called after any route is
    navigated away from. You might use this hook to store analytics information, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `beforeRouteEnter`navigation guard to fetch data from our web
    service if the data in the head is unsuitable. Consider the following pseudo-code
    for how we might implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important feature of navigation guards is that they will halt navigation
    until the `next` function is called. This allows asynchronous code to be executed
    before the navigation is resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can pass `false` to the `next` function to prevent a navigation, or you
    can pass a different route to redirect it. If you don't pass anything, the navigation
    is considered confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `beforeRouteEnter` guard is a special case. Firstly, `this` is undefined
    within it since it is called before the next page component has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: However, the `next` function in `beforeRouteEnter` can accept a callback function
    as an argument, for example, `next(component => { ... });` where `component` is
    the page component instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This callback is not triggered until the route is confirmed and the component
    instance has been created. Due to how JavaScript closures work, the callback will
    have access to the scope of the surrounding code where it was called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: HomePage component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add `beforeRouteEnter` to the `HomePage`component. Firstly, move any logic
    for retrieving data from the document head into the hook. We then check the `path`property
    of the data to see if it matches the current route. If so, we call `next`and pass
    a callback function that applies the data to the component's instance. If not,
    we'll need to use AJAX to get the right data.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/HomePage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: I've added `listing_groups` as a data property. Before, we were applying our
    data to the component instance as it was created. Now, we're applying the data
    after the component is created. To set up reactive data, Vue must know the names
    of the data properties, so we initialize with an empty value and update it when
    the data needed is available.
  prefs: []
  type: TYPE_NORMAL
- en: Home API endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll now implement the AJAX functionality. Before we do, though, we need to
    add a home page endpoint to our web service.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first add the home API route.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/api.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Looking now at the `ListingController` class, we'll abstract the bulk of the
    logic from `get_home_web` into a new function, `get_listing_summaries`. We'll
    then use this function in the `get_home_api` method and return a JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Axios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform AJAX requests to the web service, we''ll use the Axios HTTP client,
    which is included with Laravel''s default frontend code. Axios has a very simple
    API allowing us to make requests to a GET URL like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Axios is a Promise-based library, so in order to retrieve the response, you
    can simply chain a `then` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As the Axios NPM package is already installed, we can go ahead and import the `HomePage`component.
    We can then use it to perform the request to the home API endpoint, `/api/`. In
    the `then` callback, we apply the returned data to the component instance exactly
    as we did with the inlined model.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/HomePage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: And with that, we can now navigate to the home page in two ways, either via
    the address bar, or by going from a link from the listing page. Either way, we
    get the right data!
  prefs: []
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have any functionality that is common between components, you can put
    it in a `mixin` to avoid rewriting the same functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Vue `mixin` is an object in the same form as a component configuration object.
    To use it in a component, declare within an array and assign it to the configuration
    property `mixin`. When this component is instantiated, any configuration options
    of the `mixin` will be merged with what you''ve declared on the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering what happens if the component configuration has a method
    or other property that conflicts with the `mixin`. The answer is that `mixins`
    have a *merging strategy* that determines the priority of any conflicts. Generally,
    the component's specified configuration will take precedence. The details of the
    merging strategy are explained in the Vue.js documentation at [http://vuejs.org](http://vuejs.org).
  prefs: []
  type: TYPE_NORMAL
- en: Moving the solution to a mixin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s generalize the solution for getting the right data to the home page
    so that we can use it on the listing page as well. To do this, we''ll move Axios
    and the `beforeRouteEnter` hook from the `HomePage` component into a mixin that
    can then be added to both page components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: At the same time, let's improve the code by removing the repetition of the `next` function
    call. To do this, we'll create a new method, `getData`, which will be responsible
    for figuring out where to get the right data for the page and also for getting
    it. Note that this method will be asynchronous since it may need to wait for AJAX
    to resolve, so it will return a Promise rather than an actual value. This Promise
    is then resolved within the navigation guard.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/route-mixin.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We don't need a polyfill for Promise as that is already supplied in the `Axios`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: assignData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll notice that within the `next` callback we call a method on the subject
    component called `assignData`, passing the data object as an argument. We'll need
    to implement the `assignData` method in any component that uses this `mixin`.
    We do it this way so that the component can process the data, if necessary, before
    it is applied to the component instance. For example, the `ListingPage` component
    must process the data via the `populateAmenitiesAndPrices` helper function.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We'll also need to add `assignData` to the `HomePage` component.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/HomePage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Linking to the listing page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The above should work but we can't test it since there are not yet any in-app
    links to the listing page!
  prefs: []
  type: TYPE_NORMAL
- en: Each of our `ListingSummary` instances represents a single listing, and should
    therefore be a clickable link to the page for that listing. Let's use the `RouterLink` component
    to achieve this. Note that the object we bind to the `to` prop includes the name
    of the route as well as a `params` object which includes a value for the dynamic
    segment of the route, the listing ID.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummary.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, the listing summaries will now be links. Clicking from one
    to the listing page, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/47a777b4-a997-42b3-bf6b-5e8d34379b22.png)Figure 7.15\. Successful
    AJAX call after navigating to listing page'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see in *Figure 7.15* that the AJAX call to the listing API was successful
    and returned the data we wanted. If we also look at the Vue Devtools tab, as well
    as the Dev Tools console, we can see the correct data in our component instance.
    The problem is that we now have an unhandled 404 error for the header image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/99a48262-9bff-432f-8679-3a846aca5295.png)Figure 7.16\. Dev Tools
    console showing error'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that the component's first render occurs *before* the
    callback in the `next` hook is called. This means that the initialization values
    for the component data are used in the first render.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the `HeaderImage` declaration, we bind the first image like this: `:image-url="images[0]"`.
    Since the array is initially empty, this will be an undefined value and results
    in the unhandled error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The explanation is complex, but the fix is easy: just add a `v-if` to `header-image`,
    ensuring it won''t render until valid data is available.'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Scroll behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another aspect of website navigation that the browser automatically manages
    is *scroll behavior*. For example, if you scroll to the bottom of a page, then
    navigate to a new page, the scroll position is reset. But if you return to the
    previous page, the scroll position is remembered by the browser, and you're taken
    back to the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser can''t do this when we''ve hijacked navigation with Vue Router.
    So, when you scroll to the bottom of the Vuebnb home page and click a listing
    in Cuba, let''s say, the scroll position is unchanged when the listing page component
    is loaded. This feels really unnatural to the user, who would expect to be taken
    to the top of the new page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19966550-9244-468a-b9fa-2115b5b294bf.png)Figure 7.17\. Scroll position
    issue after navigating with Vue Router'
  prefs: []
  type: TYPE_NORMAL
- en: Vue Router has a `scrollbehavior` method that allows you to adjust where the
    page is scrolled when you change routes by simply defining the `x` and `y` positions
    of the horizontal and vertical scroll bars. To keep it simple, and yet to still
    keep the UX natural, let's make it so we are always at the top of the page when
    a new page is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/router.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Adding a footer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To improve the design of Vuebnb, let''s add a footer to the bottom of each
    page. We''ll make it a reusable component, so let''s begin by creating that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here is the markup. For now, it's just a stateless component.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/CustomFooter.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Let's add the footer to the `App` component, just below the `RouterView` where
    the pages are output.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how it looks on the listing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/468a31ff-2de5-4199-8290-f4dc7e2085a3.png)Figure 7.18\. Custom footer
    on listing page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now here''s how it looks on the home page. It doesn''t look as good because
    the text is not aligned left as you''d expect. This is because the container constraints
    used on this page are different to the `.container` class we''ve added to the
    footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/83c646d8-8f4f-493b-a19c-7376abe3cb57.png)Figure 7.19\. Custom footer
    on home page'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, `.container` was specifically designed for the listing page, while `.home-container` was
    designed for the home page. To fix this, and to make things less confusing, let's
    firstly rename the `.container` class to `.listing-container`. You'll also need
    to update the `ListingPage` component to ensure it's using this new class name.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, let's move `.home-container` to the main CSS file as well, since we'll
    start to use it globally as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/css/style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now we have `.home-container` and `.listing-container` as two possible containers
    for our `custom-footer` component. Let's dynamically select the class depending
    on the route, so the footer is always correctly aligned.
  prefs: []
  type: TYPE_NORMAL
- en: The route object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *route object* represents the state of the currently active route and can
    be accessed inside the root instance, or a component instance, as `this.$route`.
    This object contains parsed information of the current URL and the route records
    matched by the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Dynamically selecting the container class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to select the correct container class in `custom-footer`, we can get
    the name of the current route from the route object, and use that in a template
    literal.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/CustomFooter.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the footer will use `.home-container` when displayed on the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/efd60af9-5efc-4b8d-9c39-dd6e099f6ea5.png)Figure 7.20\. Custom footer
    on home page with the correct container class'
  prefs: []
  type: TYPE_NORMAL
- en: Listing summary image slider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On our home page, we need to make it so that a user can see more than just three
    of the possible 10 listings for each country. To do this, we will turn each listing
    summary group into an image slider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new component to house each listing summary group. We''ll then
    add arrowheads to the sides of this component, allowing the user to easily step
    through its listings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We'll now abstract the markup and logic for displaying listing summaries from `HomePage` into
    this new component. Each group will need to know the name of the country and the
    included listings, so we'll add this data as props.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Back in the `HomePage`, we will declare the `ListingSummaryGroup` with a `v-for`,
    iterating over each country group.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/HomePage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Most developers will use the terms *image carousel*and *image slider*interchangeably.
    In this book, I make a slight distinction, a *carousel* contains a single image
    that gets completely switched out with another, while a *slider* shifts the position
    of images, with several visible at once.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the slider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll now add the slider functionality to `ListingSummaryGroup`. To do this,
    we'll reuse the `CarouselControl` component we made back in [Chapter 6](c3b31042-0e33-40d8-ad31-d048ccf7082d.xhtml), *Composing
    Widgets with Vue.js Components*. We'll want to display one on either side of the
    group, so let's put them into the template, remembering to declare the `dir`attribute.
    We'll also add some structural markup and CSS for displaying the controls.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding this code, your home page will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0c9de4a0-ed44-4cdf-882d-947ab738a935.png)Figure 7.21\. Carousel
    controls on listing summary groups'
  prefs: []
  type: TYPE_NORMAL
- en: Translate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to *shift* our listing summaries in response to the carousel controls
    being clicked, we will use a CSS transform called `translate`. This moves an affected
    element from its current position by an amount specified in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The total width of each listing summary is 365px (350px fixed width plus 15px
    margin). This means if we move our group to the left by 365px, it will give the
    effect of shifting the position of all images by one. You can see here I''ve added
    the translate as inline styling to test if it works. Note that we `translate`
    in a *negative* direction to get the group to move to the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a7557439-4548-4a23-b2ff-86f078053d9a.png)Figure 7.22\. Listing group
    shifted to the left by using translate'
  prefs: []
  type: TYPE_NORMAL
- en: By binding inline style to the element with the `listing-summary` class, we
    can control the translate from JavaScript. Let's do this via a computed property
    so we can calculate the translate amount dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all of our summary groups will be shifted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/07cfeef2-c95f-4f4b-9939-85058fb8b98f.png)Figure 7.23\. Shifted listing
    groups with translate controlled by JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: The problem evident in *Figure 7.23* is that we can only see three images at
    once and that they're overflowing out of the container into the other parts of
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we''ll move the CSS rule `overflow: hidden` from `listing-summaries` to `listing-summaries-wrapper`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Carousel controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need the carousel controls to change the value of the translate. To do
    so, let's add a data property, `offset`, to `ListingSummaryGroup`. This will track
    how many images we've shifted along, that is, it will start at zero, and go up
    to a maximum of seven (not 10 because we don't want to shift so far along that
    all of the images are off-screen).
  prefs: []
  type: TYPE_NORMAL
- en: We'll also add a method `change`, which will serve as an event handling function
    for the custom event that the carousel control components emit. This method accepts
    one argument, `val`, which will either be `-1` or `1`, depending on whether the
    left or right carousel control was triggered.
  prefs: []
  type: TYPE_NORMAL
- en: '`change` will step the value of `offset`, which is then multiplied by the width
    of each listing (365px) to calculate the translate.'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we must use a `v-on` directive in the template to register a listener
    for the `change-image` event of the `CarouselControl` components.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: With that done, we have a working image slider for each listing group!
  prefs: []
  type: TYPE_NORMAL
- en: Finishing touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two more small features to add to these image sliders to give Vuebnb
    users the best possible experience. Firstly, let's add a CSS transition to animate
    the translate change over a period of half a second and give a nice *sliding*
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Sadly you can't see the effects of this in a book, so you'll have to try it
    for yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, unlike our image carousel, these sliders are not continuous; they have
    a minimum and maximum value. Let's hide the appropriate arrow if that minimum
    or maximum is reached. For example, when the sliders load, the left arrow should
    be hidden because the user cannot decrement the offset further below zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll use style bindings to dynamically add a `visibility: hidden` CSS
    rule.'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: And the computed properties.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, we can see the left arrow is hidden when the page loads, as
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6797f901-bc01-4b74-bf89-cc6e085eaa9a.png)Figure 7.24\. Hidden left
    arrow on page load'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how router libraries work and why they are a crucial
    addition to SPAs. We then got familiar with the key features of Vue Router including
    the route object, navigation guards, and the `RouterLink` and `RouterView` special
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Putting this knowledge into practice, we installed Vue Router and configured
    it for use in our app. We then built a home page for Vuebnb, including a gallery
    of listing summaries organized within image sliders.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we implemented an architecture for correctly matching pages with either
    available local data or new data retrieved from the web service via AJAX.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a substantial number of components in our app, many of which
    communicate data between one another, it''s time to investigate another key Vue.js
    tool: Vuex. Vuex is a Flux-based library that offers a superior way of managing
    application state.'
  prefs: []
  type: TYPE_NORMAL
