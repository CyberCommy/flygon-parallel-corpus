- en: Chapter 2. The First Brush with Boost's Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the course of this book, we will focus on a number of Boost libraries
    that deal with different subsystems, such as filesystems, threads, network I/O,
    and a variety of containers, among others. In each chapter, we will delve into
    the details of a few such libraries. This chapter is different, in the sense that
    we will pick up a set of useful and varied tricks that will help you in almost
    all programming situations. To that end we have the following topics lined up
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with heterogeneous values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other utilities and compile-time checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the kitchen-sink chapter that you can keep coming back to and scour
    for an interesting technique that would seem to apply to a problem at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Simple data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at two different libraries that will help you
    create simple data structures of immediate usefulness: Boost.Optional and Boost.Tuple.
    Boost.Optional can be used to represent optional values; objects that may or may
    not be there. Boost.Tuple is used to create ordered sets of heterogeneous values.'
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Optional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us consider that you need to maintain about musicians in a data store.
    Among other things, you can look up the latest album released by an artiste. You
    have written a simple API in C++ for doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For simplicity we will ignore the possibility that two or more artistes could
    share the same name. Here is a simple implementation of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We store the names of artistes and their latest albums in a map called `latest_albums`.
    The `find_latest_album_of` function takes the name of an artiste and uses the
    `find` member function of `std::map` to look up the latest album. If it does not
    find an entry, it returns an empty string. Now, it is possible that some artistes
    have not released an album yet. Returning an empty string seems legit for such
    cases until you realize that musicians have their unique whims and sometimes,
    they release an album without a name. So, how do you distinguish between the cases
    where the musician is yet to release an album, versus where the musician's latest
    album was untitled? In one case, there is no value to return while in the other
    case, it is an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `boost::optional<T>` template can be used to represent an optional value;
    one that may or may not be present. In this case, it is tailor-made for our problem.
    To represent a `std::string` value that may or may not be present, you use `boost::optional<std::string>`.
    We can rewrite the `find_latest_album_of` function using `boost::optional`, as
    shown in the following code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.1: Using Boost.Optional**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We simply return the value found (line 14), which is automatically wrapped in
    a `boost::optional` container. If there is no value to return, we return a special
    object, `boost::none` (line 16). This causes an empty `boost::optional` object
    to be returned. The code using `boost::optional` does exactly what we need; it
    checks whether a key is present in the container and returns the value or indicates
    that it is absent without any ambiguity (that is, empty versus untitled).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A default-initialized instance of `boost::optional` is always empty. If the
    value stored in `boost::optional` is movable (see [Appendix](apa.html "Appendix A. C++11
    Language Features Emulation"), *C++11 Language Features Emulation*), the wrapper
    `optional` object is also movable. If the stored value is copyable, the wrapper
    `optional` object is also copyable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can generalize the lookup function in listing 2.1 to any container with
    a map-like or dictionary interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.2: Generic lookup using optional**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have converted `lookup` to a function template that
    can be called on any `map`, `multimap`, their unordered variants, or any other
    nonstandard container, exposing a similar interface. It is parameterized on the
    container type `C`. The container type `C` must have nested type definitions:
    `key_type` and `mapped_type` corresponding to the types of keys and values the
    map stores; a constraint satisfied by `std:map` and other associative containers
    from the Standard Library.'
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `typename` keyword (lines 4, 5, 7) may need some explanation.
    If we omit the `typename` keyword from these lines, the compiler will fail to
    identify `C::mapped_type`, `C::key_type`, and `C::const_iterator` as names of
    types. Because `mapped_type`, `key_type`, and `const_iterator` are names that
    are dependent on the type template parameter `C`, the compiler needs to be told
    that they identify types. We use the `typename` keyword to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing values stored in boost::optional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can check whether an `optional` object contains a value or is empty, and
    extract the value stored in a non-empty `optional` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the code that calls `find_latest_album_of`, to test whether the returned
    value is empty, we invoke the object in a Boolean context (line 4). If it evaluates
    to `true`, it means that `album` is not empty. If it has a value, we can obtain
    a reference to the contained value using the overloaded `operator*` (line 10).
    We can access members of the underlying object using an overloaded `operator->`
    ; in this case we call the empty member function of `std::string` (line 7). We
    could also use get member function of a nonempty `boost::optional` object instead
    of the overloaded `operator*` to access the value stored. Dereferencing an empty
    optional value by calling the `operator*`, `get`, or `operator->` causes a runtime
    error, which is why we first check whether the `optional` object is empty before
    trying to dereference it.
  prefs: []
  type: TYPE_NORMAL
- en: get_value_or
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `optional`, we indicate that there may or may not be a value present
    for albums. But we would sometimes need to use APIs that should have taken optional
    values but do not. In such cases, we may want to return empty values with some
    default value. Imagine residents of Paris being asked about their favorite city
    and for those who do not name one, Paris being used as the default favorite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the imaginary `getFavoriteCity` function returns an empty value, we want
    `Paris` to be passed to the `printFavoriteCity` function. We do this using the
    `get_value_or` member function (line 14).
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Optional versus pointers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we did not use `optional`, what would the functions `find_last_album_of`
    or `lookup` return in order to indicate that there was no value found? They would
    either need to return a pointer to a dynamically-allocated object or `nullptr`
    if there was no value found. Besides using dynamic memory, it requires that the
    caller function manage the lifetime of the dynamically-allocated object that is
    returned. This condition can be mitigated using smart pointers ([Chapter 3](ch03.html
    "Chapter 3. Memory Management and Exception Safety"), *Memory Management and Exception
    Safety*), but it does not eliminate free store allocations that are costly. The
    `boost::optional` class eliminates free store allocations and stores the encapsulated
    object in its layout. In addition, it stores a Boolean flag to keep track of whether
    it is initialized or not.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Tuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boost Tuples are a cool way to group disparate types of data together into
    ordered tuples and pass them around. Structures do the same thing but a couple
    of things set tuples apart:'
  prefs: []
  type: TYPE_NORMAL
- en: You can write generic code to manipulate tuples of all kinds, for example, to
    print all their members and comparing two tuples for similarity in structure and
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each new structure or class defines a new type in your software. Types should
    represent interfaces and behaviors. Representing every ad hoc clumping of data
    with a type results in proliferation of types that have no meaning in the problem
    space or its abstraction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boost Tuple is an incredibly useful library that helps you conveniently create
    schemas for moving related data around together, such as exchanging data between
    functions. Boost Tuples are a generalization of `std::pair`, which is used to
    create 2-element tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using a C++ compiler with good C++11 support, you should use the
    `std::tuple` facility from the Standard Library—one of the Boost libraries that
    made it to the C++11 standard. The header to be included is `<tuple>`. Most of
    what we discuss here is applicable to `std::tuple`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us look at an example. Given a series of stock prices at different points
    in time, we want to find out the best two points in time to buy and sell the stock
    to maximize the profit. We can assume that there is no option to short-sell, that
    is, you must buy before you sell. For simplicity, the input can be assumed to
    be a vector of doubles. In this vector, we are interested in the pair of indices
    that represent the best time to buy and sell the stock to maximize profit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.3: Using tuples**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The function `getBestTransactDays` returns a tuple of two unsigned integers
    (`size_t`) and a double (line 4) that represent the two indices at which buying
    and selling the stock would maximize profit, and the maximum profit possible.
    The return type of the function is `boost::tuple<size_t, size_t, double>`. The
    header `boost/tuple/tuple.hpp` provides the necessary functions and types for
    working with tuples (line 1).
  prefs: []
  type: TYPE_NORMAL
- en: The function `getBestTransactDays` implements a simple linear algorithm that
    runs through the vector, keeping track of the lowest stock price seen so far.
    If the current element has a lesser value than the lowest stock price so far,
    then this is set as the new lowest, and its index is noted (lines 12-14). The
    function also keeps track of the maximum gain, that is, the maximum difference
    in prices noted so far. If we encounter an element whose difference from the lowest
    price is higher than the maximum gain, then we note this difference as the new
    maximum gain (line 15), and also note the days of transaction required to achieve
    this gain (lines 16-18).
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the tuple using `boost::make_tuple` (line 22), which is a convenience
    function for creating tuples from its elements without explicit template instantiations.
    You could have also created and returned a tuple like this in place of line 22:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `boost::make_tuple` is more compact and, being a function template,
    resolves the types of its arguments automatically to create the tuple of correct
    types. This is a frequently seen pattern where you use a factory function template
    to instantiate a class template, thus automating type detection.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing tuple elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several ways in which we can access the elements in a tuple. Look
    at the following example of calling the `getBestTransactDays` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also unpack the elements in the tuple into individual variables using
    `boost::tie`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line of code will assign the first element of the tuple to `buyDay`,
    the second to `sellDay`, and the third to `profit`. If we are interested in only
    a subset of the elements in the tuple, we can ignore the others using `boost::tuples::ignore`.
    Here is the same example, but we have ignored `sellDay` this time using `boost::tuples::ignore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Comparing tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tuples of the same length can be compared to relational operators, such as
    `==`, `<`, `>`, `<=`, and `>=`. In any such comparison, the corresponding elements
    at each position are compared. The types of elements at the corresponding positions
    need not be identical; they just need to be comparable using the relational operator
    in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that the actual types in tuples `t1` and `t2` are different, but both have
    the same length, and the elements at corresponding positions are comparable with
    each other. In general, comparison stops at the first pair of elements that determines
    the outcome of the comparison. In this example, all three elements are compared
    because the first two elements compare equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is used to define relational operators for structs with
    very little code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Writing generic code using tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now write a generic function to find the number of elements in a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function simply uses the `boost::tuples::length<T>` metafunction to compute
    the number of elements in the tuple. This computation takes place at compile time.
    A **metafunction** is just a class template that has an accessible static member
    or a nested type computed at compile time from its template arguments (see [Chapter
    7](ch07.html "Chapter 7. Higher Order and Compile-time Programming"), *Higher
    Order and Compile-time Programming*, for a more rigorous definition). In this
    case, the `boost::tuples::length<T>` metafunction has a public static member called
    `value`, which is computed as the number of elements in the tuple `T`. If you
    use tuples from the Standard Library, you should use `std::tuple_size<T>` instead
    of `boost::tuples::length<T>`. This is just a small illustration of generic programming
    using metafunctions and type computation.
  prefs: []
  type: TYPE_NORMAL
- en: Working with heterogeneous values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The need to have a value that can hold different types of data at different
    times during the lifetime of a program is not new. C++ supports the `union` construct
    of C, which essentially allows you to have a single type that can, at different
    times, assume values of different underlying POD types. **POD** or **Plain Old
    Data** types, roughly speaking, are types that do not require any special initialization,
    destruction, and copying steps and whose semantic equivalents may be created by
    copying their memory layouts byte for byte.
  prefs: []
  type: TYPE_NORMAL
- en: These restrictions mean that most C++ classes, including a majority of those
    from the Standard Library, can never be part of a union. Starting with C++11,
    these restrictions on a union have been relaxed somewhat, and you can now store
    objects of types with nontrivial construction, destruction, and copy semantics
    (that is, non-POD types) in a union. However, the life cycle management of such
    objects stored in a union is not automatic and can be a pain in the neck, hence
    it is best avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Two libraries from Boost, Variant, and Any, provide useful variant types that
    provide the same functionality as unions without many of the restrictions. Using
    Variants and Any, storing heterogeneous data in the Standard Library containers
    becomes remarkably easy and error-free. These libraries represent discriminated
    union types. Values of a range of types can be stored in discriminated unions,
    and the type information is stored along with the value.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to storing data of heterogeneous types, we frequently need to convert
    between different representations of the same data, for example, text to numeric
    and vice versa. Boost Conversion provides, among other things, a way to seamlessly
    convert between types using a uniform syntax. We look at Any, Variant, and Conversion
    libraries in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Variant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Boost Variant avoids all that is wrong with C++ unions and provides a union-like
    construct defined over a fixed set of arbitrary types, not just POD types. We
    can define a variant datatype using the Boost Variant header-only library by instantiating
    the `boost::variant` template with a list of types. The list of types identifies
    the different types of values that the variant object can assume at different
    points in time. The different types in the list can be varied and unrelated, conforming
    to only one binding condition—that each of the types be copyable or at least movable.
    You may even create variants that contain other variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our first example, we create a variant of an integer, a `std::string`, and
    two user-defined types `Foo` and `Bar`. With this, we illustrate the constraints
    on creating variant types and on operations that can be performed on such variant
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.4: Creating and using variants**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We create two bare bones types: `Foo` (line 4) and `Bar` (line 10); we can
    initialize both implicitly from `int`. We define a variant called `value` (line
    18) over three types, `Foo`, `int`, and `std::string`. A second variant, `value2`
    (line 20) is defined over `std::string`, `Foo`, and `Bar`.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, each variant instance is value-initialized to an object of its first
    type. Thus, `value` is default-constructed to a `Foo` instance—the first type
    in the list of type parameters to the variant. Similarly, `value2` is default-constructed
    to `std::string`—the first type in its list of type parameters. If the first type
    is a POD type, it is zero-initialized. Thus, the first type must be default constructible
    for the variant to be default constructible.
  prefs: []
  type: TYPE_NORMAL
- en: We assign an integer to `value` (line 22). This sets it to be an `int` and not
    `Foo`, which an integer is implicitly convertible to. We confirm this using the
    `boost::get<T>` function template on the address of `value` with `T=int` (line
    23), and we confirm that it is not null (line 24).
  prefs: []
  type: TYPE_NORMAL
- en: We assign a `const char*` to `value` (line 25), which implicitly converts to
    `std::string` that gets stored in `value`, overwriting the integer value stored
    earlier. Next, we assign an object of `Foo` (line 26), which overwrites the earlier
    `std::string` value.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to assign an integer to `value2` (line 28, commented), it will cause
    a compilation error. The variable `value2` being a variant defined over `std::string`,
    `Foo`, and `Bar`, an integer can implicitly be converted to either `Foo` or `Bar`
    and neither is a better choice—hence, it causes ambiguity and the compiler throws
    an error. In general, variant initialization and assignment should not result
    in an ambiguity over which type to instantiate within the variant.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to stream the contents of `value` to `std::cout` (line 29, commented),
    then again, we would encounter a compilation error. This would be because one
    of the types (`Foo`) supported by the variant is not *streamable*, which means
    it cannot be written to `ostreams` using the insertion operator (`<<`).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing values in a variant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use the `boost::get<T>` function template to access the value of type `T`
    in a variant, where `T` is the concrete type of the value we want. This function,
    when called on a variant reference, returns a reference to the stored value or
    throws a `boost::bad_get` exception if the stored value is not of the type specified.
    When called on a pointer to a variant, it returns the address of the stored value
    or a null pointer if the stored value is not of the specified type. The latter
    behavior can be used to test whether a variant stores a particular type of value
    or not, the way it was used in listing 2.4 (line 23). This behavior of `get<>`
    closely mirrors that of `dynamic_cast`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.5: Accessing values in a variant**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create a variant `v1` that can store a `std::string`
    or an `int` value (line 6). We set `v1` to the character string `"19937"` (line
    7). We use the `boost::get<int>` function to try and get an integer from `v1`
    (line 11) but, since `v1` stores a `string` at this point, this results in an
    exception being thrown. Next, we use the pointer overload of `boost::get<int>`
    that takes the address of the variant `v1`. This returns the pointer to the stored
    value if its type matches the one requested via `get` function's template parameter.
    If it does not, as in this case, a null pointer is returned (lines 16 and 17).
    Finally, we can get the zero-based index of the type of the value that is currently
    stored in the variant by calling the `which` member function. Since `v1` contains
    `std::string` and the declared type of `v1` is `boost::variant<std::string, int>`,
    therefore `v1.which()` should return the index of `std::string` in the variant's
    declaration—0 in this case (line 19).
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time visitation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How the value stored in a variant is consumed usually depends on the type of
    the value. Checking a variant for each possible type using an if-else ladder can
    quickly aggravate the readability and maintainability of your code. Of course,
    we can find out the zero-based index of the type of the current value using the
    `which` member method of the variant, but it would be of little immediate use.
    Instead, we will look at a very elegant and versatile compile-time visitation
    mechanism provided by the Boost Variant library without which handling variants
    would be quite a drag.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to create a visitor class that contains an overloaded function call
    operator (`operator()`) to handle each type that may be stored in the variant.
    Using the function `boost::apply_visitor`, we can invoke the appropriate overload
    in the visitor class on a variant object, based on the type of value it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'The visitor class should publicly inherit from the `boost::static_visitor<T>`
    template, where `T` is the return type of the overloaded function call operator.
    By default, `T` is `void`. Let us look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.6: Compile-time visitation of variants**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We create a variant over the types `std::string`, `long`, and `double` called
    `v1` (line 14). We set it to a value of type `double` (line 15). Finally, we invoke
    a visitor of type `SimpleVariantVistor` on `v1` (line 17). The `SimpleVariantVisitor`
    inherits from `boost::apply_visitor<void>` (line 3) and contains overloads of
    `operator()` for `std::string` (line 5) and `long` (line 8) but not `double`.
    Each overload prints its argument to the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: The resolution of overloads happens at compile time rather than at runtime.
    Thus, an overload must be available for every type of value that the variant may
    contain. A particular overload is invoked if its parameter type is the best match
    for the type of the value stored in the variant. Moreover, a single overload may
    handle multiple types if all the types are convertible to the type of the argument
    of the overload.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, in the preceding example, there is no overload available for
    `double`. However, narrowing conversions are allowed and the overload for `long`
    is invoked with potential narrowing. In this case, the overload for `long` handles
    both `long` and `double` types. On the other hand, if we had separate overloads
    available for `double` and `long` but none for `std::string`, we would have had
    a compilation error. This would happen because not even a narrowing conversion
    would be available from `std::string` to either `long` or `double`, and the overload
    resolution would fail. Being a compile-time mechanism, this is independent of
    the type of the actual value stored in a variant object at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Generic visitors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may create a member function template that handles a family of types. In
    cases where the code for handling different types does not significantly differ,
    it may make sense to have such member templates. Here is an example of a visitor
    which prints the contents of the variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.7: Generic compile-time visitation**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we define a variant over the types `std::string`, `double`,
    `long`, and `Foo`. The visitor class `PrintVisitor` contains a generic `operator()`.
    As long as all the types in the variant are *streamable*, this code will compile
    and print the value of the variant to the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: Applying visitors to variants in a container
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Often, we have an STL container of variant objects, and we want to visit each
    object using our visitor. We can utilize the `std::for_each` STL algorithm and
    a single-argument overload of `boost::apply_visitor` for the purpose. The single-argument
    overload of `boost::apply_visitor` takes a visitor instance and returns a functor
    that applies the visitor to a passed element. The following example best illustrates
    the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Defining recursive variants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last few years have seen a phenomenal growth in the popularity of one particular
    data interchange format—JavaScript Object Notation or JSON. It is a simple text-based
    format that is often less verbose XML. Originally used as object literals in JavaScript,
    the format is more readable than XML. It is also a relatively simple format that
    is easy to understand and parse. In this section, we will represent well-formed
    JSON content using `boost::variants` and see how variants can handle recursive
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON format
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To start with, we will look at an example of people records in the JSON notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is an example of a JSON object—it contains key-value pairs
    identifying the attributes of an unnamed object. The attribute names are quoted
    strings, such as `"Name"`, `"Age"`, `"PhoneNumbers"` (of which you can have more
    than one), and `"Address"`. Their values could be simple strings (`"Name"`) or
    numeric values (`"Age"`), or arrays of such values (`"PhoneNumbers"`) or other
    objects (`"Address"`). A single colon (`:`) separates keys from values. The key-value
    pairs are separated by commas. The list of key-value pairs in an object are enclosed
    in curly braces. This format allows arbitrary levels of nesting as seen in the
    case of the `"Address"` attribute whose value itself is an object. You can create
    more nested objects that are values of attributes of other nested objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may combine many such records together in an array, which are enclosed
    in square brackets and separated by commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A well-formed JSON text contains an object or an array of zero or more objects,
    numeric values, strings, Booleans, or null values. An object itself contains zero
    or more unique attributes each represented by a unique string. The value of each
    attribute can be a string, numeric value, Boolean value, null value, another object,
    or an array of such values. Thus, the basic tokens in JSON content are numeric
    values, strings, Booleans, and nulls. The aggregates are objects and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Representing JSON content with recursive variants
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we were to declare a variant to represent a basic token in a JSON, it would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The type `JSONNullType` is an empty type that may be used to represent a null
    element in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: To extend this variant to represent more complex JSON content, we will try to
    represent a JSON object—a key-value pair as a type. The keys are always strings,
    but the values can be any of the types listed above or another nested object.
    So, the definition of a JSON object is essentially recursive, and this is why
    we need a recursive variant definition to model it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include the definition of a JSON object in the preceding variant type, we
    use a metafunction called `boost::make_recursive_variant`. It takes a list of
    types and defines the resultant recursive variant type as a nested type called
    `type`. So, here is how we write a recursive definition of the variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `#define` statement on line 1 may be necessary for many compilers where
    the support for recursive variants, especially using `make_recursive_variant`,
    is limited.
  prefs: []
  type: TYPE_NORMAL
- en: We define the recursive variant using the `boost::make_recursive_variant` metafunction
    (line 6). In the list of types, we add a new type `std::map` with keys of type
    `std::string` (line 11) and values of type `boost::recursive_variant_` (line 12).
    The special type `boost::recursive_variant_` is used to indicate that the outer
    variant type can occur as a value in the map itself. Thus, we have captured the
    recursive nature of a JSON object in the variant definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'This definition is still not complete. A well-formed JSON content may contain
    arrays of elements of all these different kinds. Such arrays may also be the values
    of an object''s attributes or be nested inside other arrays. If we choose to represent
    an array by a vector, then an extension of the preceding definition is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.8a: Recursive variant for JSON**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We add one more type—`std::vector<boost::recursive_variant_>` (line 13)—which
    represents an array of `JSONValue` objects. By virtue of this one additional line,
    we now support several more possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: A top-level array consisting of JSON objects, other JSON arrays, and the basic
    types of tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array-valued attribute of an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array-valued element in another JSON array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the complete definition of `JSONValue`. In addition, we create typedefs
    for the recursive aggregate types—JSON arrays and JSON objects (line 16 and 17).
  prefs: []
  type: TYPE_NORMAL
- en: Visiting recursive variants
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We shall now write a visitor to print JSON data stored in a variant in its
    standard notation. Visiting a recursive variant is not different from visiting
    a nonrecursive one. We still need to define overloads that can handle all types
    of values that the variant may store. In addition, in the overloads for the recursive
    aggregate types (in this case, `JSONArray` and `JSONObject`), we may need to recursively
    visit each of its elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.8b: Visiting recursive variants**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The visitor `JSONPrintVisitor` inherits publicly from `boost::static_visitor<void>`
    and provides overloads of `operator()` for the different possible types of JSON
    values. There is an overload for `std::string` (line 6), which prints strings
    in double quotes (line 8) after escaping any embedded quotes and other characters
    that need escaping. For this, we assume the availability of a function called
    `escapeStr`. We have a second overload for the `JSONNullType` (line 11), which
    just prints the string `null` without quotes. Other types of values, such as `double`
    or `bool` are handled by the member template (line 17). For `bool` values, it
    prints the unquoted strings `true` and `false` using the `std::boolalpha` `ostream`
    manipulator (line 19).
  prefs: []
  type: TYPE_NORMAL
- en: The main work is done by the two overloads for `JSONArray` (line 22) and `JSONObject`
    (line 34). The `JSONArray` overload prints the elements of the array enclosed
    in square brackets and separated by commas. It prints the first element of the
    vector of `JSONValues` (line 27) and then, applies the `std::for_each` generic
    algorithm on this vector, starting with its second element to print the subsequent
    elements separated by commas (line 28). For this purpose, it passes as the third
    argument to `std::for_each`, a pointer to the function `printArrElem`. The `printArrElem`
    (line 52) function prints each element by applying `JSONPrintVisitor` (line 54).
  prefs: []
  type: TYPE_NORMAL
- en: The `JSONObject` overload prints the elements of the map as a comma-separated
    list of key-value pairs. The first pair is printed as a quoted, escaped key (line
    40), then a colon (line 41) followed by a call to `boost::apply_visitor` (line
    42). Subsequent pairs are printed separated by commas from the preceding ones
    by iterating over the remaining elements of the map using the `std::for_each`
    and `printObjAttr` function pointers (line 45). The logic is analogous to that
    in the `JSONArray` overload. The `printObjAttr` function (line 57) prints each
    key-value pair passed to it, prefixing a comma (line 58), printing the escaped,
    quoted key (line 59), prints a colon (line 60), and invoking the visitor on the
    variant value (line 61).
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Any
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Boost Any library takes a different route to store heterogeneous data than
    Boost Variant. Unlike Variant, Any allows you to store almost any type of data
    not limited to a fixed set and maintains the runtime type information of the stored
    data. Thus, it does not use templates at all and requires that **Runtime Type
    Identification** (**RTTI**) be enabled, while compiling the code using Boost Any
    (most modern compilers keep this enabled by default).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the Boost Any library to work correctly, you must not disable the generation
    of RTTI for your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we create instances of `boost::any` to store numeric
    data, character arrays, and non-POD type objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.9: Using Boost Any**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use a nonthrowing version of `any_cast` by passing the address
    of an `any` object instead of a reference. This returns a null pointer, instead
    of throwing an exception if the stored type does not match the type it is cast
    to. The following snippet illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass the address of `any` objects to `any_cast` (lines 3, 5, 8, and 9),
    and it returns null unless the type parameter to `any_cast` matches the type of
    the value stored in the `any` object. Using the pointer overload of `any_cast`,
    we can write a generic predicate to check whether an `any` variable stores a value
    of a given type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how you would use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This behavior of `boost::any_cast` emulates how `dynamic_cast` works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In listing 2.9, we used different instances of the type `boost::any` to store
    different types of values. But the same instance of `boost::any` can store different
    types of values at different times. The following snippet illustrates this using
    the `swap` member function of `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We first assign a value of type `double` to `v1` (line 7), which was carrying
    a value of type `int` (line 1). Next, we swap the contents of `v1` with `v2` (line
    8), which was carrying a value of type `std::string` (line 2). We can now expect
    `v1` to contain a `std::string` value (line 9) and `v2` to contain a `double`
    value (line 10).
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides using the pointer overload of `any_cast`, we can also use the `type`
    member function of `any` to access the type of the stored value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.10: Accessing type information in Any**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The type member function of `any` returns an object of `std::type_info` (defined
    in the Standard Library header `<typeinfo>`). To check whether this type is the
    same as a given type, we compare it with the `type_info` object obtained by applying
    the `typeid` operator on the given type (in this case, it is `int`). Instead of
    directly comparing the two `type_info` objects, we compare their hash codes obtained
    using the `hash_code` member function of `type_info`.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have ever tried parsing a text input (from a file, standard input, network,
    and so on) and tried a semantic translation of the data in it, you would have
    possibly felt the need for an easy way to convert text to numeric values. The
    opposite problem is to write text output based on values of numeric and textual
    program variables. The `basic_istream` and `basic_ostream` classes provide facilities
    for reading and writing specific types of values. However, the programming model
    for such uses is not very intuitive or robust. The C++ Standard Library and its
    extensions offer various conversion functions with various degrees of control,
    flexibility, and a general lack of usability. For example, there exists a whole
    slew of functions that convert between numeric and character formats or the other
    way round (for example, `atoi`, `strtol`, `strtod`, `itoa`, `ecvt`, `fcvt`, and
    so on). If we were trying to write generic code for converting between types,
    we would not even have the option of using any of these functions, which only
    work for conversions between specific types. How can we define a generic conversion
    syntax that can be extended to arbitrary types?
  prefs: []
  type: TYPE_NORMAL
- en: The Boost `Conversion` library introduces a couple of function templates that
    provide a very intuitive and uniform conversion syntax, which can also be extended
    through user-defined specializations. We will look at the conversion templates
    one by one.
  prefs: []
  type: TYPE_NORMAL
- en: lexical_cast
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `lexical_cast` function template can be used to convert a source type to
    a target type. Its syntax resembles the syntax of various C++ casts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how we can use `lexical_cast` to convert a string
    to an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.11: Using lexical_cast**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We apply `lexical_cast` (line 4) to convert a value of type `std::string` to
    a value of `int`. The beauty of this approach is that it can provide a uniform
    syntax to all conversions and can be extended to new types. If the string does
    not contain a valid numeric string, then the `lexical_cast` invocation will throw
    an exception of type `bad_lexical_cast`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overloads of the `lexical_cast` function template are provided to allow the
    conversion of a part of a character array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the preceding function in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When converting objects of types that are streamable, `lexical_cast` streams
    the objects to an `ostream` object, such as an instance of `stringstream`, and
    reads it back as the target type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A streamable object can be converted to a stream of characters and inserted
    into an `ostream` object, such as an instance of `stringstream`. In other words,
    a type `T`, such that `ostream& operator<<(ostream&, const T&)`, is defined is
    said to be streamable.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and tearing down stream objects for each such operation incurs some
    overhead. As a result, in some cases, the default version of `lexical_cast` may
    not give you the best possible performance. In such cases, you may specialize
    the `lexical_cast` template for the set of types involved, and use a fast library
    function or provide your own fast implementation. The `Conversion` library already
    takes care of optimizing `lexical_cast` for all common type pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the `lexical_cast` template, there are other templates available for
    conversion between different numeric types (`boost::numeric_cast`), downcasts
    and cross-casts in class hierarchies (`polymorphic_downcast`, `polymorphic_cast`).
    You can refer to the online documentation for more information on these features.
  prefs: []
  type: TYPE_NORMAL
- en: Handling command-line arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command-line arguments, like API parameters, are the remote control buttons
    that help you tune the behavior of commands to your advantage. A well-designed
    set of command-line options is behind much of the power of a command. In this
    section, we will see how the Boost.Program_Options library helps you add support
    for a rich and standardized set of command-line options to your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: Designing command-line options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C provides the most primitive abstraction for the command line of your program.
    Using the two arguments passed to the main function—the number of arguments (`argc`)
    and the list of arguments (`argv`)—you can find out about each and every argument
    passed to the program and their relative ordering. The following program prints
    `argv[0]`, which is the path to the program itself with which the program was
    invoked. When run with a set of command-line arguments, the program also prints
    each argument on a separate line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most programs need to add more logic and validation to verify and interpret
    command-line arguments and hence, a more elaborate framework is needed to handle
    command-line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The diff command – a case study
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Programs usually document a set of command-line options and switches that modify
    their behavior. Let us take a look at the example of the `diff` command in Unix.
    The `diff` command is run like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the difference between the content of the two files. There are several
    ways in which you can choose to print the differences. For each different chunk
    found, you may choose to print a few additional lines surrounding the difference
    to get a better understanding of the context in which the differing part appears.
    These surrounding lines or "context" do not differ between the two files. To do
    this, you can use one of the following alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you choose to print five additional lines of context. You can also choose
    the default of three by specifying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding examples, `-U` or `--unified` are examples of command-line
    options. The former is a short option consisting of a single leading hyphen and
    a single letter (`-U`). The latter is a long option with two leading hyphens and
    a multi-character option name (`--unified`).
  prefs: []
  type: TYPE_NORMAL
- en: The number `5` is an option value; an argument to the option (`-U` or `--unified`)
    preceding it. The option value is separated from a preceding short option by space,
    but from a preceding long option by an equals sign (`=`).
  prefs: []
  type: TYPE_NORMAL
- en: If you are "diffing" two C or C++ source files, you can get more useful information
    using a command-line switch or flag `-p`. A switch is an option that does not
    take an option value as an argument. Using this switch, you can print the name
    of the C or C++ function in the context of which a particular difference is detected.
    There is no long option corresponding to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `diff` command is a very powerful tool with which you can find differences
    in the content of files in full directories. When diffing two directories, if
    a file exists in one but not the other, `diff` ignores this file by default. However,
    you may want to instead see the contents of the new file. To do this, you will
    use the `-N` or `--new-file` switch. If we want to now run our `diff` command
    on two directories of C++ source code to identify changes, we can do it in this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You don't have to be eagle-eyed to notice that we used an option called `-pN`.
    This is actually not a single option but two switches, (`-p`) and (`-N`), collapsed
    together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Certain patterns or conventions should be evident from this case-study:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting short options with single hyphens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting long options with double hyphens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating short options and option-values with space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating long options and option-value with equals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collapsing short switches together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are *de facto* standardized conventions on highly POSIX-compliant systems,
    such as Linux. It is, however, by no means the only convention followed. Windows
    command lines often use a leading forward slash (`/`) in place of a hyphen. They
    often do not distinguish between short and long options, and sometimes use a colon
    (`:`) in place of an equals sign to separate an option and its option value. Java
    commands as well as commands in several older Unix systems use a single leading
    hyphen for both short and long options. Some of them use a space for separating
    an option and option-value irrespective of whether it is a short option or a long
    one. How can you take care of so many complex rules that vary from platform to
    platform while parsing your command line? This is where Boost Program Options
    library makes a big difference.
  prefs: []
  type: TYPE_NORMAL
- en: Using Boost.Program_Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Boost Program Options library provides you with a declarative way of parsing
    command lines. You can specify the set of options and switches and the type of
    option-values for each option that your program supports. You can also specify
    which set of conventions you want to support for your command line. You can then
    feed all of this information to the library functions that parse and validate
    the command line and extract all the command-line data into a dictionary-like
    structure from which you can access individual bits of data. We will now write
    some code to model the previously mentioned options for the `diff` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.12a: Using Boost Program Options**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we declare the structure of the command line
    using an `options_description` object. Successive options are declared using an
    overloaded function call `operator()` in the object returned by the `add_options`.
    You can cascade calls to this operator in the same way that you can print multiple
    values by cascading calls to the insertion operator (`<<`) on `std::cout`. This
    makes for a highly readable specification of the options.
  prefs: []
  type: TYPE_NORMAL
- en: We declare the `--unified` or `-U` option specifying both the long and short
    options in a single string, separated by a comma (line 10). The second argument
    indicates that we expect a numeric argument, and the default value will be taken
    as `3` if the argument is not specified on the command line. The third field is
    the description of the option and will be used to generate a documentation string.
  prefs: []
  type: TYPE_NORMAL
- en: We declare the short options `-p` and `-N` (lines 13 and 15), but as they do
    not have corresponding long options, they are introduced with a comma followed
    by a short option (`",p"` and `",N"`). They also do not take an option value,
    so we just provide their description.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far so good. We will now complete the code example by parsing the command
    line and fetching the values. First, we will specify the styles to follow in Windows
    and Unix:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.12b: Using Boost Program Options**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code highlights some important differences between Windows and
    Unix conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: A more or less standardized Unix style is available precanned and called, `unix_style`.
    However, we have to build the Windows style ourselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `short_allow_next` flag allows you to separate a short option and its option
    value with a space; this is used on both Windows and Unix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `allows_slash_for_short` and `allow_slash_for_long` flags allow the options
    to be preceded by forward slashes; a common practice on Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `case_insensitive` flag is appropriate for Windows where the usual practice
    is to have case insensitive commands and options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `long_allow_next` flag on Windows allows long options and option values
    to be separated by a space instead of equals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let us see how we can parse a conforming command line using all of this
    information. To do this, we will declare an object of type `variables_map` to
    read all the data and then parse the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.12c: Using Boost Program Options**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We create a command-line parser using the `command_line_parser` function (line
    32). We call the `options` member function on the returned parser to specify the
    parsing rules encoded in `desc` (line 33). We chain further member function calls,
    to the `style` member function of the parser for specifying the expected style
    (line 34), and to the `run` member function to actually perform the parsing. The
    call to `run` returns a data structure containing the data parsed from the command-line.
    The call to `boost::program_options::store` stores the parsed data from this data
    structure inside the `variables_map` object `vm` (lines 31-35). Finally, we check
    whether the program was invoked without arguments or with the `help` option, and
    print the help string (line 39). Streaming the `option_description` instance `desc`
    to an `ostream` prints a help string, that is automatically generated based on
    the command-line rules encoded in `desc` (line 41). All this is encapsulated in
    a try-catch block to trap any command line parsing errors thrown by the call to
    `run` (line 35). In the event of such an error, the error details are printed
    (line 45) along with the usage details (line 46).
  prefs: []
  type: TYPE_NORMAL
- en: If you notice, we call a function called `notify(…)` on line 37\. In more advanced
    uses, we may choose to use values that are read from the command line to set variables
    or object members, or perform other post-processing actions. Such actions can
    be specified for each option while declaring option descriptions, but these actions
    are only initiated by the call to `notify`. As a matter of consistency, do not
    drop the call to `notify`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now extract the values passed via the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.12d: Using Boost Program Options**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Parsing positional parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you were observant, you would have noticed that we did nothing to read the
    two file names; the two main operands of the `diff` command. We did this for simplicity,
    and we will fix this now. We run the `diff` command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `old_source_dir` and `new_source_dir` arguments are called positional parameters.
    They are not options or switches, nor are they arguments to any options. In order
    to handle them, we will have to use a couple of new tricks. First of all, we must
    tell the parser the number and type of these parameters that we expect. Second,
    we must tell the parser that these are positional parameters. Here is the code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we set up a second options description object called
    `posparams` to identify the positional parameters. We add options with names `"file1"`
    and `"file2"`, and indicate that these parameters are mandatory, using the `required()`
    member function of the `value` parameter (lines 4 and 5). We also specify two
    string variables `file1` and `file2` to store the positional parameters. All of
    this is added to the main options description object `desc` (line 6). For the
    parser to not look for actual options called `"--file1"` and `"--file2"`, we must
    tell the parser that these are positional parameters. This is done by defining
    a `positional_options_description` object (line 9) and adding the options that
    should be treated as positional options (lines 10 and 11). The second parameter
    in the call to `add(…)` specifies how many positional parameters should be considered
    for that option. Since we want one file name, each for options `file1` and `file2`,
    we specify `1` in both the calls. Positional parameters on the command line are
    interpreted according to the order in which they are added to the positional options
    description. Thus, in this case, the first positional parameter will be treated
    as `file1`, and the second parameter will be treated as `file2`.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple option values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases, a single option may take multiple option values. For example,
    during compilation, you will use the `-I` option multiple times to specify multiple
    directories. To parse such options and their option values, you can specify the
    target type as a vector, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This will work on an invocation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, however, you might want to specify multiple option values, but
    you specify the option itself only once. Let us say that you are running a command
    to discover assets (local storage, NICs, HBAs, and so on) connected to each of
    a set of servers. You can have a command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, to model the `--server` option, you would need to use the `multitoken()`
    directive as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can retrieve vector-valued parameters through the variable map like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use variable hooks at the time of option definition
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you don't forget to call `notify` after parsing the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Trying to support positional parameters and options with multi-tokens together
    in the same command can confuse the parser and should be generally avoided.
  prefs: []
  type: TYPE_NORMAL
- en: The Program Options library uses Boost Any for its implementation. For the Program
    Options library to work correctly, you must not disable the generation of RTTI
    for your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Other utilities and compile-time checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost includes a number of micro-libraries that provide small but useful functionalities.
    Most of them are not elaborate enough to be separate libraries. Instead, they
    are grouped under `Boost.Utility` and `Boost.Core`. We will look at two such libraries
    here.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at some useful ways to detect errors as early as possible,
    at compile time, and glean information about the program's compilation environment
    and tool chains using different facilities from Boost.
  prefs: []
  type: TYPE_NORMAL
- en: BOOST_CURRENT_FUNCTION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing debug logs, it is incredibly useful to be able to write function
    names and some qualifying information about functions from where logging is invoked.
    This information is (obviously) available to compilers during the compilation
    of sources. However, the way to print it is different for different compilers.
    Even for a given compiler, there may be more than one ways to do it. If you want
    to write portable code, this is one wart you have to take care to hide. The best
    tool for this is the macro `BOOST_CURRENT_FUNCTION`, formally a part of `Boost.Utility`,
    shown in action in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.13: Pretty printing current function name**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your compiler, the output you see would vary in format. GNU compilers
    tend to have a more readable output, while on Microsoft Visual Studio you will
    see some very elaborate output including details such as calling conventions.
    In particular, the output for template instantiations is much more elaborate on
    Visual Studio. Here is a sample output I see on my systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'With GNU g++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'With Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You can immediately see some differences. GNU compilers call out static methods
    from nonstatic ones. On Visual Studio, you have to differentiate based on calling
    conventions (`__cdecl` for static member methods as well as global methods, `__thiscall`
    for instance methods). You might want to take a look at the `current_function.hpp`
    header file to figure out which macros are used behind the scenes. On GNU compilers,
    for example, it is `__PRETTY_FUNCTION__`, while on Visual Studio, it is `__FUNCSIG__`.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Swap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Boost Swap library is yet another useful micro library and is part of Boost
    Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It wraps a well-known idiom around swapping objects. Let us first look at the
    problem itself to understand what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one global `swap` function in the `std` namespace. In many cases,
    for a type defined in a particular namespace, a specialized `swap` overload may
    be provided in the same namespace. When writing generic code, this can pose some
    challenges. Imagine a generic function that calls `swap` on its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we call `std::swap` on line 5 to perform the swapping.
    While this is well-formed, this may not do what is desired in some cases. Consider
    the following types and functions in the namespace `X`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Of course, `X::Foo` is a trivial type and `X::swap` is a no-op, but they can
    be replaced with a meaningful implementation and the points we make here would
    still hold.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happens if you call the function `process_values` on two arguments
    of type `X::Foo`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `process_values` (line 2) will call `std::swap` on the passed instances
    of `X::Foo`, that is, `f1` and `f2`. Yet, we would likely have wanted `X::swap`
    be called on `f1` and `f2` because it is a more appropriate overload. There is
    a way to do this; you call `boost::swap` instead. Here is the rewrite of the `process_values`
    template snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now run this code, you will see the `X::swap` overload printing its
    name to the console. To understand how `boost::swap` manages to call the appropriate
    overload, we need to understand how we could have solved this without `boost::swap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: If we did not have the `using` declaration (line 5), the call to `swap` (line
    6) would still have succeeded for a type `T` that was defined in a namespace,
    which had a `swap` overload defined for `T`—thanks to **Argument Dependent Lookup**
    (**ADL**)—`X::Foo`, accompanied by `X::swap`, is such a type. However, it would
    have failed for types defined in the global namespace (assuming you didn't define
    a generic `swap` in the global namespace). With the `using` declaration (line
    5), we create the fallback for the unqualified call to `swap` (line 6). When ADL
    succeeds in finding a namespace level `swap` overload, the call to `swap` gets
    resolved to this overload. When ADL fails to find such an overload, then `std::swap`
    is used, as dictated, by the `using` declaration. The problem is that this is
    a nonobvious trick, and you have to know it to use it. Not every engineer in your
    team will come equipped with all the name lookup rules in C++. In the meantime,
    he can always use `boost::swap`, which essentially wraps this piece of code in
    a function. You can now use just one version of `swap` and expect the most appropriate
    overload to be invoked each time.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time asserts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compile-time asserts require certain conditions to hold true at some point in
    the code. Any violation of the condition causes the compilation to fail at the
    point. It is an effective way to find errors at compile time, which otherwise
    would cause serious grief at runtime. It may also help reduce the volume and verbosity
    of compiler error messages of the sort generated due to template instantiation
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Runtime asserts are meant to corroborate the invariance of certain conditions
    that must hold true at some point in the code. Such a condition might be the result
    of the logic or algorithm used or could be based on some documented convention.
    For example, if you are writing a function to raise a number to some power, how
    do you handle the mathematically undefined case of both the number and the power
    being zero? You can use an assert to express this explicitly, as shown in the
    following snippet (line 6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Any violation of such invariants indicates a bug or a flaw, which needs to be
    fixed, and causes a catastrophic failure of the program in debug builds. Boost
    provides a macro called `BOOST_STATIC_ASSERT` that takes an expression, which
    can be evaluated at compile time and triggers a compilation failure if this expression
    evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you may have designed a memory allocator class template that is
    meant to be used only with "small" objects. Of course, smallness is arbitrary,
    but you can design your allocator to be optimized for objects of size 16 bytes
    or smaller. If you want to enforce correct usage of your class, you should simply
    prevent its instantiation for any class of size greater than 16 bytes. Here is
    our first example of `BOOST_STATIC_ASSERT` that helps you enforce the small object
    semantics of your allocator:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.16a: Using compile-time asserts**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We define our dummy allocator template called `SmallObjectAllocator` (lines
    3 and 4) and call the `BOOST_STATIC_ASSERT` macro in the class scope (line 6).
    We pass an expression to the macro that must be possible to evaluate at compile
    time. Now, `sizeof` expressions are always evaluated by the compiler and 16 is
    an integer literal, so the expression `sizeof(T) <= 16` can be entirely evaluated
    at compile time and can be passed to `BOOST_STATIC_ASSERT`. If we now instantiate
    the `SmallObjectAllocator` with a type `Foo`, whose size is 32 bytes, we will
    get a compiler error due to the static assert on line 6\. Here is the code that
    can trigger the assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.16b: Using compile-time asserts**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We define a type `Foo` whose size is 32 bytes, which is larger than the maximum
    supported by `SmallObjectAllocator` (line 13). We instantiate the `SmallObjectAllocator`
    template with the types `int` (line 18) and `Foo` (line 19) . The compilation
    fails for `SmallObjectAllocator<Foo>`, and we get an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++11 supports compile-time asserts using the new `static_assert` keyword. If
    you are using a C++11 compiler, `BOOST_STATIC_ASSERT` internally uses `static_assert`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual error message naturally varies from compiler to compiler, especially
    on C++03 compilers. On C++11 compilers, because this internally uses the `static_assert`
    keyword, the error message tends to be more uniform and meaningful. However, on
    pre-C++11 compilers too, you get a fairly accurate idea of the offending line.
    On my system, using the GNU g++ compiler in C++03 mode, I get the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line of the compiler error refers to an incomplete type `boost::STATIC_ASSERTION_FAILURE<false>`,
    which comes from the innards of the `BOOST_STATIC_ASSERT` macro. It is clear that
    there was an error on line 6, and the static assertion failed. If I switch to
    C++11 mode, the error messages are a lot saner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another variant of the static assert macro called `BOOST_STATIC_ASSERT`,
    which takes a message string as the second parameter. With C++11 compilers, it
    simply prints this message for the error message. Under pre-C++11 compilers, this
    message may or may not make it to the compiler error content. You use it this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Not all expressions can be evaluated at compile time. Mostly, expressions involving
    constant integers, sizes of types, and general type computations can be evaluated
    at compile time. The Boost TypeTraits library and the Boost **Metaprogramming
    Library** (**MPL**) offer several metafunctions using which many sophisticated
    conditions can be checked on types at compile time. We illustrate such use with
    a small example. We will see more examples of such use in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may use static assertions not only in class scope but also in function and
    namespace scope. Here is an example of a library of function templates that allow
    bitwise operations on different POD types. When instantiating these functions,
    we assert at compile time that the types passed are POD types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.17: Using compile-time asserts**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a function `bitwise_or` (lines 4 and 5) , which takes two objects,
    potentially of different types and sizes, and returns the bitwise-or of their
    content. Inside this function, we use the metafunction `boost::is_pod<T>` to assert
    that both the objects passed are of POD types (line 7). Also, because the return
    type of the function is `T`, the type of the left argument, we assert that the
    function must always be called with the larger argument first (line 9) so that
    there is no data loss.
  prefs: []
  type: TYPE_NORMAL
- en: Diagnostics using preprocessor macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number of times in my career as a software engineer, I have worked on products
    with a single code base that were built on five different flavors of Unix and
    on Windows, often in parallel. Often these build servers would be big iron servers
    with hundreds of gigs of attached storage that would be used by multiple products
    for the purpose of building. There would be myriad environments, tool chains,
    and configurations cohabiting on the same server. It must have taken ages to stabilize
    these systems to a point where everything built perfectly. One day, all hell broke
    loose when, overnight, without any significant check-ins having gone in, our software
    started acting weird. It took us almost a day to figure out that someone had tinkered
    with the environment variables, as a result of which we were linking using a different
    version of the compiler and linking with a different runtime from the one with
    which our third-party libraries were built. I don't need to tell you that this
    was not ideal for a build system even at the time that it existed. Unfortunately,
    you may still find such messed up environments that take a long time to set up
    and then get undone by a flippant change. What saved us that day after half a
    day's fruitless toil was the good sense of using preprocessor macros to dump information
    about the build system, including compiler names, versions, architecture, and
    their likes at program startup. We could soon glean enough information from this
    data dumped by the program, before it inevitably crashed and we spotted the compiler
    mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: Such information is doubly useful for library writers who might be able to provide
    the most optimal implementation of a library on each compiler or platform by leveraging
    specific interfaces and doing conditional compilation of code based on preprocessor
    macro definitions. The bane of working with such macros is, however, the absolute
    disparity between different compilers, platforms, and environments on how they
    are named and what their function is. Boost provides a much more uniform set of
    preprocessor macros for gleaning information about the software build environment
    through its `Config` and `Predef` libraries. We will look at a handful of useful
    macros from these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Predef` library is a header-only library that provides all sorts of macros
    for getting useful information about the build environment at compile time. The
    information available can fall into different categories. Rather than providing
    a long list of options and explaining what they do—a job that the online documentation
    does adequately—we will look at the following code to illustrate how this information
    is accessed and used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.18a: Using diagnostic macros from Predef**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function uses the `BOOST_OS_*` macros from the `Predef` library
    to identify the OS on which the code is built. We have only shown macros for three
    different OSes. The online documentation provides a full list of macros for identifying
    different OSes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.18b: Using diagnostic macros from Predef**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function uses the `BOOST_ARCH_*` macros from the `Predef` library
    to identify the architecture of the platform on which the code is built. We have
    only shown macros for x86 and ARM architectures; the online documentation provides
    a complete list of macros for identifying different architectures.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.18c: Using diagnostic macros from Predef**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function uses the `BOOST_COMP_*` macros from the `Predef` library
    to identify the compiler that was used to build the code. We have only shown macros
    for GNU and Microsoft Visual C++ compilers. The online documentation provides
    a complete list of macros for identifying different compilers. When defined, the
    `BOOST_COMP_*` macro for a particular compiler evaluates to its numeric version.
    For example, on Visual Studio 2010, `BOOST_COMP_MSVC` evaluates to `100030319`.
    This could be translated as version `10.0.30319`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.18d: Using diagnostic macros from Predef**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `BOOST_VERSION_NUMBER` macro to construct
    versions against which we compare the current version of the GNU or Microsoft
    Visual C++ compilers. If the GNU compiler version is less than 4.8.1 or the Microsoft
    Visual Studio C++ compiler version is less than 12.0, we print that the support
    for C++11 might be incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final example of this section, we use macros from `boost/config.hpp`
    to print compiler, platform, and runtime library names (lines 6, 7, and 8). We
    also use two macros defined in `boost/version.hpp` to print the version of Boost
    used, as a string (line 10) and as a numeric value (line 11):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.19: Using configuration information macros**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For multiple choice questions, choose all the options that apply:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages of using `boost::swap` over `std::swap`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. There is no real advantage
  prefs: []
  type: TYPE_NORMAL
- en: b. `boost::swap` invokes swap overloads supplied with the passed type, if any
  prefs: []
  type: TYPE_NORMAL
- en: c. `boost::swap` is faster than `std::swap`
  prefs: []
  type: TYPE_NORMAL
- en: d. `boost::swap` does not throw exceptions
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you apply a visitor to multiple variant arguments in a single call? (*Hint*:
    you may want to look up the online documentation)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Yes. A visitor can only be applied to one or two variant arguments
  prefs: []
  type: TYPE_NORMAL
- en: b. Yes. A visitor can be applied to one or more arguments
  prefs: []
  type: TYPE_NORMAL
- en: c. No. The member operators take only one variant argument
  prefs: []
  type: TYPE_NORMAL
- en: d. None of the above
  prefs: []
  type: TYPE_NORMAL
- en: Is the following a valid compile-time assert?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BOOST_STATIC_ASSERT(x == 0); // x is some variable`'
  prefs: []
  type: TYPE_NORMAL
- en: a. Yes, provided `x` is of an integral type
  prefs: []
  type: TYPE_NORMAL
- en: b. Yes, provided `x` is declared as a `const static` numeric variable
  prefs: []
  type: TYPE_NORMAL
- en: c. No, `x` is a variable, and its value cannot be known at compile time
  prefs: []
  type: TYPE_NORMAL
- en: d. Only expressions involving `sizeof` are valid in a `BOOST_STATIC_ASSERT`
  prefs: []
  type: TYPE_NORMAL
- en: What do we mean when we say that a type `X` is a POD type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `X` does not have a user-defined constructor or destructor
  prefs: []
  type: TYPE_NORMAL
- en: b. `X` can be copied by copying its memory layout bit-wise
  prefs: []
  type: TYPE_NORMAL
- en: c. `X` does not have a user-defined copy constructor or copy assignment operator
  prefs: []
  type: TYPE_NORMAL
- en: d. All of the above
  prefs: []
  type: TYPE_NORMAL
- en: What is the type and value stored in a default-constructed object of type `boost::variant<std::string,
    double>`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The type is `const char*` and value is `NULL`
  prefs: []
  type: TYPE_NORMAL
- en: b. The type is `double` and value is `0.0`
  prefs: []
  type: TYPE_NORMAL
- en: c. The type is `std::string` and value is the default constructed `std::string`
  prefs: []
  type: TYPE_NORMAL
- en: d. The type is `boost::optional<double>` and value is empty
  prefs: []
  type: TYPE_NORMAL
- en: Check the reference on Boost.Optional in the online documentation for the latest
    Boost libraries. What happens if you call the `get` and `get_ptr` methods on an
    empty `optional` object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Both throw the `boost::empty_optional` exception
  prefs: []
  type: TYPE_NORMAL
- en: b. `get` throws an exception, while `get_ptr` returns a null pointer
  prefs: []
  type: TYPE_NORMAL
- en: c. `get` asserts, while `get_ptr` returns a null pointer
  prefs: []
  type: TYPE_NORMAL
- en: d. Both `get` and `get_ptr` assert
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a quick tour of several Boost libraries that help you do important
    programming chores, such as parsing command lines, creating type-safe variant
    types, handling empty values, and performing compile-time checks.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you have appreciated the diversity of libraries in Boost and the
    expressive power they lend to your code. In the process, you would have also become
    more familiar with compiling code that uses the Boost libraries and linking to
    the appropriate libraries as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how you can deterministically manage heap
    memory and other resources in exception-safe ways using various flavors of Boost's
    smart pointers.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Curiously Recurring Template Pattern: [https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Curiously_Recurring_Template_Pattern](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Curiously_Recurring_Template_Pattern)'
  prefs: []
  type: TYPE_NORMAL
