- en: Chapter 2. Applications with a Cloud-based Backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will teach you how to build an app that does not need a backend
    of its own but uses a cloud-based solution instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Parse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming data from the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting data to the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications require a backend solution, allowing users to communicate
    with a server or with each other like in social apps, for example, and which application
    is not social today? You can also think of a business app, for example, one for
    logistic purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Sure, we can write our own API, host it somewhere, and write some Android code
    to communicate with it, including querying, caching, and all other functionalities
    that our application needs to support. Unfortunately, developing all this could
    be a very time-consuming process, and since this is often the most valuable asset,
    there must be another way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that you do not have to do all these things yourself. There
    are a couple of ready-made mobile backend solutions available on the Internet,
    such as QuickBlox, Firebase, Google App Engine, and Parse to mention just a few
    of the most well-known ones.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these solutions do particular things well; although, one solution will
    be more suitable than another. For example, take QuickBlox, which provides the
    quickest way to set things up, but at a price. It also is not as flexible as the
    other options. Firebase, recently acquired by Google, is a very great solution
    in particular if you need real-time support; for example, for a chat app. Parse,
    acquired by Facebook, has no real-time options but is more flexible and has some
    interesting third-party integrations to offer.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, other considerations when choosing a particular solution.
    The parties (Facebook and Google) that provide this kind of solutions might have
    access to the data that you store in the cloud, including your user base, which
    is not necessarily a bad thing right away, but it may have an impact on the strategy
    that you choose. Also, think about issues such as scalability and data lock-in
    that are both luxury problems, but nevertheless could become issues when your
    app becomes more popular.
  prefs: []
  type: TYPE_NORMAL
- en: Parse is my favourite as it currently is the most flexible solution for most
    purposes. It has no data lock-in (all data is exportable), but it is scalable
    (if you choose a paid plan instead of the free one), it is available for all relevant
    mobile platforms, and it even allows us to create cloud modules (methods that
    run in the cloud that could be scheduled on a regular base and/or that could be
    approached by your application). From all the available popular services, this
    one provides the easiest way to attach a backend to a mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In future this might change, in particular for Android developers, if the Google
    App Engine (which by the way can be used for iOS apps as well) integration with
    Android Studio is further improved. You can find the **Deploy Module to App Engine**
    option in the **Build** menu already.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Parse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Think of a scenario that goes like this: at a central point, orders are being
    collected and will be prepared for transport. Goods need to be delivered and customers
    need to sign in the app once they receive the goods that they have ordered. Each
    driver has a mobile device and an app to support this process digitally.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the process for which we will provide the next three recipes and we
    will be using Parse for it, as it is the most suitable backend for the solution
    that we are going to create.
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming recipe describes how to set up Parse, how to consume data from
    Parse into your Android app, and how to send data, such as a signature, from the
    app to Parse.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, you will need Android Studio up and running and Internet
    access. That's all folks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create an app that connects to a Parse backend first so that we have
    a fundament on which we can build our app. Let''s name our app `CloudOrder`. The
    further steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Android Studio and start a new Android Studio Project. Name your application
    `CloudOrder` and enter `packtpub.com` for the **Company Domain** field or any
    other name that suits you or your company best. Then, click on the Next button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Phone and Tablet** option and optionally change the **minimum SDK**
    field. In my case, this will be API 14 (Android 4.x), which at the time of writing
    is the best choice to both reach an audience as large as possible and to benefit
    from the SDK functionality that we need. Make sure you will be targeting at least
    API level 9 as Parse does not support lower levels than this one. Click on the
    **Next** button to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select **Blank activity** and click on the **Next** button. On the next
    page, just click on the **Finish** button. Your new project will be set up by
    Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's go to [www.parse.com](http://www.parse.com) to create a new account
    and an app. Sign up with [www.Parse.com](http://www.Parse.com). Enter your name,
    e-mail address, and chosen password, and then click on the **Sign up** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next page on [www.Parse.com](http://www.Parse.com) is the **Get Started**
    page. Enter `CloudOrder` or something similar in the field displaying the hint
    about your app name. Pick a value for **Company type** that suits your situation
    best and depending on the chosen value, complete any of the other fields. Once
    this is done, hit the **Start using Parse** button. Select **Data** as the product
    you want to start using. Choose **Mobile** as your environment. Next, select a
    platform. Choose **Android**, and in the next view, choose the **Native (Java)**
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Existing project** option. We are creating a new project; however,
    to know what is going on here, we will do the following things ourselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, download the SDK. While downloading, switch to Android Studio and change
    the project view perspective from **Android** to **Project**. Then, expand the
    `app` folder. Note that one of the underlying folders is called `libs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the `Parse-x.x.x.jar` file (where `x.x.x` indicates the version
    number) into the `libs` folder in Android Studio. If the **Non-Project Files Access**
    dialog box appears, just click on the **OK** button. When you do this, `Parse-x.x.x.jar`
    will appear under the `libs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we saw in [Chapter 1](ch01.html "Chapter 1. Welcome to Android Studio"),
    *Welcome to Android Studio*, we need to tell Gradle about this Parse library.
    Open the `build.gradle` file in the `apps` folder by double-clicking on it. In
    the dependencies section, we need to add two lines, so it will look like as shown
    in the following example. Just after the two lines that are already in there,
    add the dependencies for both the `bolts` and `parse` libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of using the local JAR file, as described through step 6 to 8, we could
    also use a dependency like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `AndroidManifest.xml` file, add permissions needed to access the Internet.
    The `Manifest` file will reside in the `/app/src/main` folder. Double-click on
    it to open it. Add the permissions for both the Internet and to access the network
    state, as shown in the following example. Also, define the name for the `package
    name` + `CloudOrderApplication` application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Select and expand the `src/main/java/com.packt.cloudorder` folder. Right-click
    on this folder. In the context menu that pops up, choose **New**, and in the submenu,
    choose **Java Class**. In the dialog box that will be shown, enter `CloudOrderApplication`
    as the content for the **Name** field. Then, click on the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the new class a descendant of the `Application` class and override the
    `onCreate` method. In the `onCreate` method, right after `super.OnCreate()`, add
    the initialization for Parse, as indicated by Parse using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Android Studio is not happy yet. You will notice that the Parse part in your
    code is highlighted in red in the Android Studio IDE. This is because your app
    is not aware of this class. Any time you change a `gradle` file, your project
    needs to be synchronized. To do so, click on the button with the tooltip that
    reads **Sync project with Gradle Files**. You will find this on the navigation
    bar. Alternatively, you may also click on the **Sync Now** link.![How to do it...](img/B04299_02_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this synchronization, Android Studio will have a clue about the Parse
    class, but you still need to add an import clause for that. If you hover over
    the part of your code that reads `Parse`, you will notice that Android Studio
    suggests that this probably refers to `com.parse.Parse`. Press *Alt* + *Enter*
    to accept this suggestion or just add the `import com.parse.Parse` line yourself.
    Finally, your class will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost done configuring our Parse-based app. Open the `MainActivity`
    file and add the following lines to your `onCreate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to add the appropriate import statement. Run your app. If everything
    is set up successfully, a new object of the `CloudOrder` class is sent to Parse
    and created at Parse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the parse web page, click on the **Core** button at the top of the navigation
    bar. Have a look at the **Data** section on the left-hand side of web page. **CloudOrder**
    should appear there, and if you click on it, you will see the entry (row), containing
    the properties (fields) that you just sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is what the data section at [www.Parse.com](http://www.Parse.com) looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04299_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If this test succeeds, remove the three lines that you have added to the `onCreate`
    method of `MainActivity` as we no longer need them.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You have just created your first Parse app! Let's move on and see
    how to extend the `CloudOrder` app!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Parse SDK will take care of retrieving or sending data. Using the `ParseObject`
    class, `Query` and other Parse classes' all data communication takes place automatically.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At [www.parse.com](http://www.parse.com), you will find additional information
    about caching policies, saving data to the cloud, and other interesting features.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming data from the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have our Parse-based app up and running. Now, let's see how we can get the
    orders from Parse into our app and display them in a list.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, you will need to have the previous recipe up and
    running, Internet access, and some coffee, although I must admit that last one
    is not strictly necessary. Tea will be just as fine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how we can extend our `CloudOrder` app by consuming orders from
    the Parse backend and display them using a list view with the help of the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the last step in the *Setting up Parse* recipe, we were looking at the newly
    created Parse entity and the data in there. Entities can be created or extended
    on the fly from your app like we did, but we can also define columns and add data
    here on the webpage. Click on the **+Col** button to add a new column to the `CargoOrder`
    entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the modal, display **Add a column**, choose **String** from **Select a type**,
    and name the new column `address`. Then, click on the **Create Column** button.
    The new column will be added to the row that is already available (you might need
    to scroll to the right to see this.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another column. From the type drop down box, choose **File** and name this
    field as `signature`. And finally, add a last column with the **Number** type
    and the `Status` name. We now have three new custom columns for each **CargoOrder**
    row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **address** column and enter an address for it; for example, let's
    say that the delivery address for the order should be `1600 Amphitheatre Pkwy,
    Mountain View, CA 94043, United States` (it's where you can find the Google headquarters,
    but you can of course enter any address you like here).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+Row** button to create a new **Cargo Order** row and enter some
    other values for the **customer** and **address** fields. Repeat this a couple
    of times to make sure that we have some data to consume in our app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To retrieve rows from the **CargoOrder** entry, we first need to create a model
    that represents the orders. Create a new class at the location where your `MainActivity`
    and `CloudOrderApplication` classes reside. Right-click on the package name and
    select **New** and **Java Class**. Name your new class `CloudOrder` and hit the
    **OK** button. Make your model a descendant of the `ParseObject` class and indicate
    to which entity this class is mapping. Your class should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add getters and setters for the columns that we have created in Parse using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, tell Parse about this new class. In the `CloudOrderApplication` class,
    add this line right before the `Parse.Initialize` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the cloud orders in our app, we need to define a query indicating what
    exactly it is that we are looking for. In its most basic form, query looks like
    the following snippet. Add it to the `onCreate` method of `MainActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to tell Parse that we want to perform this query asynchronously
    by using the `findInBackground` method. Add the following lines to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run the app and check **LogCat** (use the shortcut *Cmd* + *6* to make it appear).
    It displays the number of objects that have been found. This should return the
    numbers of rows that you have created for **CargoOrder** at [www.parse.com](http://www.parse.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Great! Now, if only we had an adapter to make these items available in the
    list view. Create a new class and name it `CloudOrderAdapter`. Make it an array
    adapter descendant with the `CloudOrder` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor, create a view holder, and add the implementation
    for all the methods that need to be overridden. Finally, your adapter will look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the `MainActivity` class and modify the code of the query call back
    so that we can feed our newly created adapter with the results over there, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To display the orders in our app, we have to create a layout for it. Expand
    the `layout` folder and double-click on the `activity_main.xml` file to open it.
    By default, a preview of the layout is shown. Change the perspective to text by
    clicking on the **Text** tab at the bottom of Android Studio, which makes the
    layout display as XML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the **TextView** widget that displays `Hello world` and add a list view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Select the `layout` folder again and right-click on it. From the menu, choose
    **New**, and from the submenu, choose **Layout resource**. Choose `adapter_main`
    for the File name and click on the **OK** button. A new layout file will be created.
    Change the perspective from design to text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two text views to the layout so that we can display both the customer name
    and the address and add some formatting, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You are done. Run your app. If everything goes well, you will see an output
    like the one shown in the following screenshot, and this is what your list view
    may look like after having the orders consumed from [www.parse.com](http://www.parse.com):![How
    to do it...](img/B04299_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you run into a `class exception error,` have a look again at step 8\. Did
    you register your `ParseOrder` subclass? In case you are running into any other
    errors, repeat each step carefully to check whether there are any missing parts
    or mismatches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is nothing but a brief introduction to Parse. At [www.parse.com](http://www.parse.com),
    you will find much more information about how to retrieve data from a cloud, including
    using **where** and **order by** statements in your queries. It also provides
    you with information that is needed to create relational or compound queries.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting data to the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have completed the previous recipes and the driver that will be
    using our `CloudOrder` app knows where to go to for a particular order, it would
    be great if, once the goods are delivered, he (or she) will be able to select
    that order and have it signed for delivery by the customer on the device.
  prefs: []
  type: TYPE_NORMAL
- en: In this last recipe, we will implement code to make the customer draws his or
    her signature on the device. The signature will be sent to Parse as an image and
    the `CloudOrder` record will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, you will need to have the previous recipes up and
    running.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class and name it `SignatureActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new layout and name it `activity_signature.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch the layout to **Text**. Add the **TextView** and the **Button** widget
    to the layout. Make sure that the layout looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To allow the customer to draw his signature, we need to create a custom widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right under the `com.packt.cloudorder` package, create a new package and name
    it `widget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within this new package, create a new class and name it `SignatureView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the `SignatureView` class descend from the `View` class and override the
    `onDraw` method to draw a path wherever we put our finger or stylus on the screen.
    Override the `onTouch` method to create the path. snippet for creating the path
    will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `getSignatureBitmap` method to the `SignatureView` class so that we
    can get the signature as a bitmap from the `Signature view` widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the `signature_activity` layout and add the signature view between
    the text view and the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Build the project. It should make any rendering issues disappear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `SignatureActivity` class. First, make it an `Activity` descendant
    and override the `onCreate` method. Set the content view to the layout we have
    just created and add an `onClick` implementation for the button in the layout,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the activity to the manifest file after the `MainActivity` declaration
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the driver selects any of the orders, we need to display the signature activity
    that in turn needs to know which order has been selected. Go to the `MainActivity`
    class and append `OnItemClickListener` on the list view at the end of the `OnCreate`
    method, just after the `Query.findInBackground` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onItemClick` event, let''s figure out which order has been selected
    using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `gotoSignatureActivity` method, we want to start the `Signature` activity,
    using an intent, and pass the selected order from `MainActivity` to `SignatureActivity`,
    using a bundle as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `SignatureActivity` class, add the following to the `OnClick` implementation
    of the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `sendSignature` method implementation, we will create a new `ParseFile`
    object and feed it with the bitmap data that comes from the signature view. We
    will send the file to Parse using the `saveInBackground` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once the saving is done, we want to update the order with information about
    the file we have created and the status, for example `10`, which could indicate
    that the order has been finished or something like that. Its actually value does
    not really matter here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If no error occurred during saving, we use the `createWithoutData` method of
    the `ParseObject` class so that we could pass the right object ID and the fields
    that we want to update. We will save these changes as well so that the record
    at Parse will be updated. (For the sake of simplicity, we use this approach; although,
    we could accomplish the same thing using the `CloudOrder` object) The implementation
    of the done call back looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Run the app, select an order, sign it, and click on the **SEND SIGNATURE** button.
    If everything goes well, a toast will be shown, indicating that the signature
    has been sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is what your signature looks like after signing by a customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04299_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Check it out for yourself at [www.parse.com](http://www.parse.com). Refresh
    the view for **Cloud order**. Notice that for the order that you have selected
    in the app, the `signature.jpg` file appears in the signature column. Double-click
    on it to see its contents. This is what your data rows may look like at [www.parse.com](http://www.parse.com)
    after submitting a signature image to it:![How to do it…](img/B04299_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Actually, you should be using string resources instead of hardcoded values.
    By reusing string resources (or constant values) not only for the class and field
    names but also for other texts, you will reduce the number of errors caused by
    typos. This will improve the quality of your app. It also will make it much easier
    to localize your app later. (In the last three chapters, we will focus more on
    these kind of things but here is some good practice to start with right away.)
    The following steps gives usage of string resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the `strings.xml` file. It resides in the `res/values` folder. Imagine
    we would have included the text for the toast being displayed in step 19\. Your
    `strings.xml` file could look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In your code, you could refer to a string resource using the `getString` method.
    You could replace the hardcoded string for the toast being displayed in step 19
    for example with a string reference, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In your layout file, you could also refer to this string resource, for example,
    in a text view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We will describe how to use strings, colors, dimensions, and other type of resources
    in depth later, but you can already get a bit familiar with the concepts by replacing
    all hardcoded strings in this recipe with string resource references or where
    applicable, use constant values for them.
  prefs: []
  type: TYPE_NORMAL
- en: With the implementation of this recipe, we have completed our `CloudOrder` app.
    Feel free to further customize it and make enhancements wherever you want to.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The custom widget draws a path on the view, for which a bitmap will be created.
    Using a `ParseFile` object, the bitmap data will be send to Parse (which in turn
    will store the file in Amazon and keep a reference to the file).
  prefs: []
  type: TYPE_NORMAL
- en: If this succeeds, we will update the **CloudOrder** row to which the signature
    applies by denoting to which file the image in the **signature** column refers
    to.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have a closer look at the documentation at [www.parse.com](http://www.parse.com).
    There are a couple of interesting features available including the `saveEventually`
    method and the cloud code options.
  prefs: []
  type: TYPE_NORMAL
- en: The `saveEventually` method will store the update locally if there is no Internet
    connection available, which is a common scenario for mobile apps. Once the Internet
    connection has been restored, this method will take of, sending the data that
    has been queued to be sent to the cloud. This option will save you much troubles
    and time.
  prefs: []
  type: TYPE_NORMAL
- en: Also check out the other features such as cloud code and the various third-party
    integrations that are available, such as Twilio, if you want to send text or voice
    messages (which could be handy for confirmation purposes in on-boarding processes)
    and SendGrid, which is a tool for e-mail delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Following the recipes in this chapter, we have implemented some very interesting
    functionalities with little effort, which is really great! The app however is
    not very eye-catching yet. By applying the concepts of Material design, which
    will be explained in the next chapter, we can make the app look great and more
    intuitive to use.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information, refer to [Chapter 3](ch03.html "Chapter 3. Material Design"),
    *Material Design*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
