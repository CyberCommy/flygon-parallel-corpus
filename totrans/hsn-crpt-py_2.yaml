- en: Hashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hashing has two main purposes: the first is to put a fingerprint on a file
    so you can tell whether it has been altered, and the second is to conceal passwords
    so you can still recognize the correct password and enable login but a person
    who steals the hash cannot easily recover the password from it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: MD5 and SHA hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows password hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux password hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenge 1 – cracking Windows hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenge 2 – cracking many-round hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenge 3 – cracking Linux hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MD5 and SHA hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After explaining what a hash function is, we will deal with MD5 and then the
    SHA family: SHA-1, SHA-2, and SHA-3\. We will also acquire a bit of information
    about cracking hashes.'
  prefs: []
  type: TYPE_NORMAL
- en: What are hashes?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, one point of using hashes is to put a fingerprint on a
    file. You can take all the bytes in the file and combine them together with a
    hash algorithm, and this creates a fixed-links hash value. If you change any part
    of the file and recalculate the hash, you get a completely different value. So,
    the idea is that if you have two files that are supposed to be identical, you
    can calculate the hash of each file, and if the hash of both files match, then
    the files are identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common hash is MD5; it''s been around for a couple of decades. It''s
    128 bits long, which is rather short for a hash function, and it''s reliable enough
    for most purposes. People use it to put a fingerprint on downloads, and malware
    samples, and all sorts of things, and they are also sometimes used to obscure
    passwords. It''s not a perfect hash function: there are some collisions known,
    and there are some algorithms that, at the expense of some computer time, can
    create collisions, which are pairs of files that hash to the same value. So, if
    you do find two files with MD5s that match, you do not know with complete certainty
    that they are identical files, but they usually are.'
  prefs: []
  type: TYPE_NORMAL
- en: It's very easy to calculate them in Python. You just import the hash library
    and then proceed with the calculation. You call the hash library to create a new
    object. The first parameter is the algorithm used, which is MD5\. The second parameter
    is the contents of the data to be hashed.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will use `HELLO` as an example, and then you need to use the hex-digest
    at the end or it will just print an address to the data structure instead of showing
    you the actual value. We will use the hash of `HELLO`, MD5, and a hexadecimal
    and it is 128 bits long. So, that's 128 over 4, or 32, hexadecimal characters,
    and if you add another character to the `HELLO`, like an exclamation point the
    hash changes completely; there's no resemblance between the hash of one value
    and the hash of the next.
  prefs: []
  type: TYPE_NORMAL
- en: The **Secure Hash Algorithm** (**SHA**) was designed to be an improvement on
    MD5, and SHA-1 had no collisions until about a year ago, when some researchers
    at Google Inc. found out how to make collisions in SHA-1, so careful people are
    switching to SHA-2\. There is another algorithm approved by the **National Institute
    of Standards**, called **SHA-3**, which almost nobody is using because as far
    as anyone expects, SHA-2 will remain secure for a very long time to coms. But,
    if something were to happen to compromise SHA-2, SHA-3 will be available for us
    to use. Both SHA-2 and SHA-3 have various lengths, but the most common lengths
    are 256 and 512 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can calculate SHA-1 and SHA-2 hashes easily in Python, but SHA-3 is not
    commonly used and it''s not part of this hash library yet. So, if you use SHA-1
    for the algorithm, you get a SHA-1 hash. It looks like an MD5 hash, but it''s
    longer. Then there are SHA-256 and SHA-512, which are both SHA-2 hashes. You can
    see that, although they''re more secure, they are much longer and somewhat less
    convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Terminal and execute the `python` command to start the Python Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can then run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You have to import `hashlib`. Then, you can add `hashlib.new`. The first parameter
    is the algorithm, which is `md5`, in this case. The next parameter is the data
    to hash, which is `HELLO`, and then `hexdigest` is added to see the hexadecimal
    value. So, there''s the hash of `HELLO`, and if we put another character at the
    end such that it reads `HELLOa`, then we get a completely different answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to use a different algorithm, we can just put in SHA-1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we get a long hash, and, if we add `sha256` as character, we get an even
    longer hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: These are enough hashes for almost any purpose.
  prefs: []
  type: TYPE_NORMAL
- en: If you have the hash value of something and you want to calculate the data it
    came from, in principle, there is not a unique solution. In practice, though,
    for short objects like passwords, there is. So, if someone uses an `MD5` function
    to obscure a password, which is done by some old web applications, then you can
    reverse it by guessing passwords until you find a match. There is no mathematical
    way to undo a hash function, so you just have to make a library. In the example
    of the `MD5` hash of `HELLO`, if you just made a series of guesses, you'd get
    the right answer. That's how hash cracking works; it's not a complicated idea,
    it's just kind of inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take the MD5 hash of `HELLO` and keep guessing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we were guessing words, we might have to guess millions of words to get down
    to the value shown, but if we are able to guess the right value, we'll know it's
    right when the hash matches. The only thing that determines the difficulty of
    this is how many hashes you can calculate per second, and MD5 and the SHA family
    are designed to calculate very fast, so you could actually try millions of passwords
    per second with them. In the next section, we'll talk about Windows password hashes.
  prefs: []
  type: TYPE_NORMAL
- en: Windows password hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to get hashes with Cain and then how MD4 and
    Unicode work. Then, we'll discuss cracking hashes with Google and cracking hashes
    with wordlists.
  prefs: []
  type: TYPE_NORMAL
- en: Getting hashes with Cain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cain is a free hacking tool that can harvest Windows hashes from a running
    operating system. In order to test it, we''ll make three accounts on Windows Server,
    the very latest version of the Windows operating system. You can use the user
    command at the Command Prompt to do this. You can add a user named `John` with
    a password `P@sw0rd`, a user named `Paul` with a password, and a user named `Ringo`
    with password `P@sw0rd999`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you run Cain, it can harvest the hashes. The following screenshot shows
    the three users and their hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The LM Hash section is an obsolete system that is no longer used by any version
    of Windows, so it just contains a dummy value that has no information. The actual
    hash used by Windows when you log in is called the NT Hash. Notice that if two
    users have the same password, they have exactly the same hash: a `464` value.
    That is one of the weaknesses in this system. It is a very weak and old password
    system, unfortunately.'
  prefs: []
  type: TYPE_NORMAL
- en: MD4 and Unicode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the algorithm Microsoft uses. It takes the password and encodes in
    Unicode instead of ASCII, and then when you run it through MD4 (which is a very
    old algorithm, even older than MD5), it produces the NT hash value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The reason Unicode is used is because Microsoft is an international operating
    system that allows you to have passwords in languages such as Chinese and Japanese
    that do not encode with 8-bits per character but 16-bits per character.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking hashes with Google
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since password hashes have no variation and any two users with the same password
    will have the same hash, all the hackers that had cracked wordlists for the last
    24 years have put their results on the internet, resulting in a situation where
    you can just Google frequently used password hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you just put a hash into Google, you'll often find that somebody has already
    cracked it for you and put on the internet. For instance, here's this one `P@sw0rd`
    that's got a known result, so you can crack it. That simple method works for a
    great many passwords but this technique does not work for the password, we used
    for the user `Ringo`, which is `P@sw0rd999`.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking hashes with wordlists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, in a case where the passwords cannot be cracked, you need to calculate
    it yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You just use the same procedure. Make a series of guesses, hash them, and hunt
    for your answer. If your list of guesses does eventually hit the right value,
    you'll of course find it here. So, you can see the password `P@sw0rd999` with
    `5c2c...`.
  prefs: []
  type: TYPE_NORMAL
- en: It's very simple, so let's give it a try in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terminal window, we''ll enter the `python` command. Next we''ll import
    the `hashlib` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Thus, you can see the line that does the encoding. We put in the password, encode `utf-16le`,
    which is the Unicode; then, we hash it with MD4 and express it as `hexdigest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s number for `P@sw0rd`. Now, if we try to get to the `Ringo` user, we
    need to have a list of two hashes to try, which will need to have some values
    that eventually reach the right value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we are just counting up sequentially using `997`, `998`, and `999`, we'll
    get that `5c2c...` value that we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Linux password hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will first discuss how to get the hashes from an operating
    system, and then look at the salting and stretching procedures that make Linux
    hashes much stronger. We will then discuss the specific hashing algorithm used
    by modern versions of Linux, and finally look at cracking hashes with wordlists
    and Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have created three users to test the software in much the same way
    as we did earlier on Windows. `John` and `Paul` have the same password and `Ringo` has
    a different password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You get the hashes from the `/etc/shadow` file, from which we will print out
    the last three records. So, you will see `John`, `Paul`, and `Ringo`, and after
    each username comes `$6`, which indicates that it is a type 6 of password, which
    is the most modern and secure form. Then there is a long, random string of characters
    that goes up to the next dollar sign, and then an even longer random string of
    characters, which is the password hash itself.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you can see is the password hash, which is much longer and more
    complicated than the Windows password hash. The next thing to observe is that
    even though `John` and `Paul` have the same password, they have completely different
    hashes, because it adds a random `salt` to each one before hashing them in order
    to obscure the fact that these passwords are the same, making the passwords much
    stronger. Salting is the procedure of adding random characters before hashing;
    stretching is also employed here. Instead of just using one round of MD4, it uses
    5,000 rounds of SHA-512, which simply makes it take much more CPU time to calculate
    the hash. The point of this is to slow down attackers who are trying to make dictionaries
    of password hashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the details of the method in the `/etc/login.defs` file, which
    shows you that modern versions of Linux using crypt methods `SHA51`2 and `5000`
    rounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Thus, the procedure requires you to combine `salt` with the password. You perform
    an algorithm that includes 5,000 rounds of SHA-512 hashing. It actually has more
    than 20 steps that involve taking two hashes together and mixing the bits together,
    but it's a little more complicated than just repeating the same hash algorithm
    over and over.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the `passlive` library. Before using it in Python, you have to install
    it with the `pip install passlib` command. Once you''ve got it, you can import
    the `sha512_crypt` module. Here''s how you use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's start the Python Terminal. Then we can import the `passlib` library as
    shown earlier, because we've already put it in `pip install`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can calculate the first one, which will use the `salt` value from the
    shadow file and hash it, as shown in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we get the correct results (starting `r7k`). And, if we were
    doing a dictionary attack, we would have a series of password guesses as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It's just a question of trying them until you get the one that matches.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 1 – cracking Windows hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After a review of Windows hashing and an example of 1-digit hashing, we will
    give you two challenges—one with a 2-digit password and one with a 7-digit password.
    Here''s how Windows hashes look in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The algorithm uses `hashlib` to do an MD4 for the hash of the password, but
    before you do that, encode in Unicode which is `utf-16le`, and then calculate
    the `hexdigest` of the results to get the long number, The number starts with
    `464`, in this case, which is a Windows password hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, you can write a program that will try all the characters in this string,
    which will consist of 10 digits, and then calculate the hash for each one of them.
    You will be left with a simple dictionary with 10 values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can crack this 1-digit hash using a 1-digit password as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, here''s a challenge. The password is a 2-digit one between 00 and 99, and
    this is the hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, you have to make a loop that tries 100 possible values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next one is a 7-digit password, and this is the hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, you'll have to try 10 million values. That will only take a few seconds,
    and that's why Windows password hashes are so very weak—you can try many millions
    of them per second.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2 – cracking many-round hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a review of how MD5 and SHA work in Python, we will see what a many round
    hash is, and then you will get two challenges to solve.
  prefs: []
  type: TYPE_NORMAL
- en: 'MD5 and SHA are both easy to calculate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the `hashlib` library, you just need to use the `hashlib.new` method and
    put the name of the algorithm in the first parameter, the password in the second
    parameter, and then add the hex-digest to it to see the actual result in hexadecimal
    instead of just an address to the object. To do many rounds, you just repeat that
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to put the password in `h` and then use the current `h`, to calculate
    the next `h` and repeat this over and over and over. Here''s a little script that
    prints out the first `10` rounds of a multi-round MD5 hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This technique is called **stretching**, and it's used by stronger password
    hashing routines, such as the Linux password hashes that we've seen in previous
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s your first challenge: a 3-digit password hashed 100 times with MD5\.
    Find it from this hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here's another challenge for you. In this one, you have an unknown number of
    rounds with SHA-1, but it's not more than 5,000\. So, you just have to try all
    values and find the 3-digit password of the results in this hash.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 3 – cracking Linux hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a review of Linux hashes, we'll show you your challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux hashes are salted and stretched, and there are various versions of them.
    We are covering the current version, which is version 6, that is, the most secure
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The hash is a long string starting with the dollar sign; the `6` indicates the
    version, then you have a dollar sign followed by `salt`, and another dollar sign
    followed by the hash. To calculate them in Python, you need to import a special
    SHA-512 `crypt` library, as you use the format shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s your third challenge: a 3-digit password in this format. The `salt` value
    is `penguins` and the `hash` is this long mess starting with a `P` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the MD5 and SHA-1 hashing algorithms, the Windows
    password hashing algorithm, and the Linux password hashing algorithm. In the challenges,
    you cracked a Windows password hash to recover a plaintext password, and another
    password hash using an unknown number of MD5 and SHA-1 rounds. Finally, you cracked
    the Linux password hashes to recover the plaintext password.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](part0048.html#1DOR00-6963dc2081804897894c8854b7cc74fd), *Strong
    Encryption*, we will cover two main methods of strong encryption, that is, AES
    and RSA.
  prefs: []
  type: TYPE_NORMAL
