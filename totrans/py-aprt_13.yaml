- en: Chapter 8 – Defining new types with classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can get a long way in Python using the built in scalar and collections types.
    For many problems the built in types, together with those available in the Python
    Standard Library, are completely sufficient. Sometimes though, they aren’t quite
    what’s required, and the ability to create custom types is where *classes* come
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve seen, all objects in Python have a type, and when we report that type
    using the `type()` built-in function the result is couched in terms of the *class*
    of that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A class is used to define the structure and behaviour of one or more objects,
    each of which we refer to as an *instance* of the class. By and large, objects
    in Python have a fixed type^([20](chap21.xhtml#fn-fixed)) from the time they are
    created – or *instantiated* – to the time they are destroyed^([21](chap21.xhtml#fn-unreachable)).
    It may be helpful to think of a class as a sort of template or cookie-cutter used
    to construct new objects. The class of an object controls its initialization and
    which attributes and methods are available through that object. For example, on
    a string object the methods we can use on that object, such as `split()`, are
    defined in the `str` class.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are an important piece of machinery for Object-Oriented Programming
    (OOP) in Python, and although it’s true that OOP can be useful for making complex
    problems more tractable, it often has the effect of making the solution to simple
    problems unnecessarily complex. A great thing about Python is that it’s highly
    object-oriented without forcing you to deal with classes until you really need
    them. This sets the language starkly apart from Java and C#.
  prefs: []
  type: TYPE_NORMAL
- en: Defining classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Class definitions are introduced by the `class` keyword followed by the class
    name. By convention, new class names in Python use camel case – sometimes known
    as Pascal case – with an initial capital letter for each and every component word,
    without separating underscores. Since classes are a bit awkward to define at the
    REPL, we’ll be using a Python module file to hold the class definitions we use
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the very simplest class, to which we’ll progressively add
    features. In our example we’ll model a passenger aircraft flight between two airports
    by putting this code into `airtravel.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `class` statement introduces a new block, so we indent on the next line.
    Empty blocks aren’t allowed, so the simplest possible class needs at least a do-nothing
    `pass` statement to be syntactically admissible.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with `def` for defining functions, `class` is a *statement* that can
    occur anywhere in a program and which binds a class definition to a class name.
    When the top-level code in the `airtravel` module is executed, the class will
    be defined.
  prefs: []
  type: TYPE_NORMAL
- en: We can now import our new class into the REPL and try it out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The thing we’ve just imported is the class object. Everything is an object in
    Python, and classes are no exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this class to mint a new object, we must call its constructor, which
    is done by *calling* the class, as we would a function. The constructor returns
    a new object, which here we assign to a name `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use the `type()` function to request the type of `f`, we get `airtravel.Flight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The type of `f` literally *is* the class.
  prefs: []
  type: TYPE_NORMAL
- en: Instance methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s make our class a little more interesting, by adding a so-called *instance
    method* which returns the flight number. Methods are just functions defined within
    the class block, and instance methods are functions which can be called on objects
    which are instances of our class, such as `f`. Instance methods must accept a
    reference to the instance on which the method was called as the first formal argument^([22](chap21.xhtml#fn-formal)),
    and by convention this argument is **always** called `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have no way of configuring the flight number value yet, so we’ll just return
    a constant string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'and from a fresh REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that when we call the method, we do not provide the instance `f` for
    the actual argument^([23](chap21.xhtml#fn-actual)) `self` in the argument list.
    That’s because the standard method invocation form with the dot, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'is syntactic sugar for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you try the latter, you’ll find that it works as expected, although you’ll
    almost never see this form used for real.
  prefs: []
  type: TYPE_NORMAL
- en: Instance initializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class isn’t very useful, because it can only represent one particular flight.
    We need to make the flight number configurable at the point a `Flight` is created.
    To do that we need to write an initializer method.
  prefs: []
  type: TYPE_NORMAL
- en: If provided, the initializer method is called as part of the process of creating
    a new object when we call the constructor. The initializer method must be called
    `__init__()` delimited by the double underscores used for Python runtime machinery.
    Like all other instance methods, the first argument to `__init__()` must be `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we also pass a second formal argument to `__init__()` which is
    the flight number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The initializer should not return anything – it modifies the object referred
    to by `self`.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re coming from a Java, C#, or C++ background it’s tempting to think of
    `__init__()` as being the constructor. This isn’t quite accurate; in Python the
    the purpose of `__init__()` is to *configure* an object that already exists by
    the time `__init__()` is called. The `self` argument is, however, analogous to
    `this` in Java, C#, or C++. In Python the actual constructor is provided by the
    Python runtime system and one of the things it does is check for the existence
    of an instance initializer and call it when present.
  prefs: []
  type: TYPE_NORMAL
- en: Within the initializer we assign to an *attribute* of the newly created instance
    called `_number` . Assigning to an object attribute that doesn’t yet exist is
    sufficient to bring it into existence.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we don’t need to declare variables until we create them, neither do
    we need to declare object attributes before we create them. We choose `_number`
    with a leading underscore for two reasons. First, because it avoids a name clash
    with the method of the same name. Methods are functions, functions are objects,
    and these functions are bound to attributes of the object, so we already have
    an attribute called `number` and we don’t want to replace it. Second, there is
    a widely followed convention that the implementation details of objects which
    are not intended for consumption or manipulation by clients of the object should
    be prefixed with an underscore.
  prefs: []
  type: TYPE_NORMAL
- en: We also modify our `number()` method to access the `_number` attribute and return
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any actual arguments passed to the flight constructor will be forwarded to
    the initializer, so to create and configure our `Flight` object we can now do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also directly access the implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Although this is not recommended for production code, it’s very handy for debugging
    and early testing.
  prefs: []
  type: TYPE_NORMAL
- en: A lack of access modifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re coming from a bondage and discipline language like Java or C# with
    `public`, `private` and `protected` access modifiers, Python’s “everything is
    public” approach can seem excessively open-minded.
  prefs: []
  type: TYPE_NORMAL
- en: The prevailing culture among Pythonistas is that “We’re all consenting adults
    here”. In practice, the leading underscore convention has proven sufficient protection
    even in large and complex Python systems we have worked with. People know not
    to use these attributes directly, and in fact they tend not to. Like so many doctrines,
    lack of access modifiers is a much bigger problem in theory than in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Validation and invariants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s good practice for the initializer of an object to establish so-called *class
    invariants*. The invariants are truths about objects of that class that should
    endure for the lifetime of the object. One such invariant for flights is that
    the flight number always begins with an upper case two-letter airline code followed
    by a three or four digit route number.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we establish class invariants in the `__init__()` method and raise
    exceptions if they can’t be attained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We use string slicing and various methods of the string class to perform validation.
    For the first time in this book we also see the logical negation operator `not`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Ad hoc* testing in the REPL is a very effective technique during development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’re sure of having a valid flight number, we’ll add a second method
    to return just the airline code. Once the class invariants have been established,
    most query methods can be very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Adding a second class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the things we’d like to do with our flight is accept seat bookings.
    To do that we need to know the seating layout, and for that we need to know the
    type of aircraft. Let’s make a second class to model different kinds of aircraft:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The initializer creates four attributes for the aircraft: registration number,
    a model name, the number of rows of seats, and the number of seats per row. In
    a production code scenario we could validate these arguments to ensure, for example,
    that the number of rows is not negative.'
  prefs: []
  type: TYPE_NORMAL
- en: This is straightforward enough, but for the seating plan we’d like something
    a little more in line with our booking system. Rows in aircraft are numbered from
    one, and the seats within each row are designated with letters from an alphabet
    which omits ‘I’ to avoid confusion with ‘1’.
  prefs: []
  type: TYPE_NORMAL
- en: '![The aircraft seating plan.](images/m08----seating-plan.png)'
  prefs: []
  type: TYPE_IMG
- en: The aircraft seating plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll add a `seating_plan()` method which returns the allowed rows and seats
    as a 2-tuple containing a `range` object and a string of seat letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It’s worth pausing for a second to make sure you understand how this function
    works. The call to the `range()` constructor produces a range object which can
    be used as an iterable series of row numbers, up to the number of rows in the
    plane. The string and its slice method return a string with one character per
    seat. These two objects – the range and the string – are bundled up into a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s construct a plane with a seating plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: See how we used keyword arguments for the rows and seats for documentary purposes.
    Recall the ranges are half-open, so 23 is correctly one-beyond-the-end of the
    range.
  prefs: []
  type: TYPE_NORMAL
- en: Collaborating classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Law of Demeter is an object-oriented design principle that says you should
    never call methods on objects you receive from other calls. Or, put another way:
    Only talk to your immediate friends.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Law of Demeter – Only talk to your immediate friends. The law is really'
  prefs: []
  type: TYPE_NORMAL
- en: only a guideline and is named after an aspect-oriented programming project,
  prefs: []
  type: TYPE_NORMAL
- en: which was, in turn, named after the Greek goddess of agriculture who signified
  prefs: []
  type: TYPE_NORMAL
- en: its bottom-up philosophy](images/m08----law-of-demeter.png)
  prefs: []
  type: TYPE_NORMAL
- en: The Law of Demeter – Only talk to your immediate friends. The law is really
    only a guideline and is named after an aspect-oriented programming project, which
    was, in turn, named after the Greek goddess of agriculture who signified its bottom-up
    philosophy
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll now modify our `Flight` class to accept an aircraft object when it is
    constructed, and we’ll follow the Law of Demeter by adding a method to report
    the aircraft model. This method will delegate to `Aircraft` on behalf of the client
    rather than allowing the client to “reach through” the `Flight` and interrogate
    the `Aircraft` object directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We’ve also added a docstring to the class. These work just like function and
    module docstrings, and must be the first non-comment line within the body of the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now construct a flight with a specific aircraft:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we construct the `Aircraft` object and directly pass it to the `Flight`
    constructor without needing an intermediate named reference for it.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Moment of zen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](images/m08----zen-complex-is-better-than-complicated.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `aircraft_model()` method is an example of ‘complex is better than complicated’:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The Flight class is more *complex* – it contains additional code to drill down
    through the aircraft reference to find the model. However, all clients of `Flight`
    can now be less *complicated*; none of them need to know about the `Aircraft`
    class, dramatically simplifying the system.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Booking seats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we can proceed with implementing a simple booking system. For each flight
    we need to keep track of who is sitting in each seat. We’ll represent the seat
    allocations using a list of dictionaries. The list will contain one entry for
    each seat row, and each entry will be a dictionary mapping from seat-letter to
    occupant name. If a seat is unoccupied, the corresponding dictionary value will
    contain `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize the seating plan in `Flight.__init__()` using this fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the first line we retrieve the seating plan for the aircraft and use tuple
    unpacking to put the row and seat identifiers into local variables `rows` and
    `seats`. In the second line we create a list for the seat allocations. Rather
    than continually deal with the fact that row indexes are one-based whereas Python
    lists use zero-based indexes, we choose to waste one entry at the beginning of
    the list. This first wasted entry is the single element list containing `None`.
    To this single element list we concatenate another list containing one entry for
    each real row in the aircraft. This list is constructed by a list comprehension
    which iterates over the `rows` object, which is the `range` of row numbers retrieved
    from the `_aircraft` on the previous line.
  prefs: []
  type: TYPE_NORMAL
- en: '![The object graph for the seating-plan data structure, which is a list'
  prefs: []
  type: TYPE_NORMAL
- en: of dictionaries.](images/m08----seating-data-structure.png)
  prefs: []
  type: TYPE_NORMAL
- en: The object graph for the seating-plan data structure, which is a list of dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not actually interested in the row number, since we know it will match
    up with the list index in the final list, so we discard it by using the dummy
    underscore variable.
  prefs: []
  type: TYPE_NORMAL
- en: The item expression part of the list comprehension is itself a comprehension;
    specifically a dictionary comprehension! This iterates over each row letter, and
    creates a mapping from the single character string to `None` to indicate an empty
    seat.
  prefs: []
  type: TYPE_NORMAL
- en: We use a list comprehension, rather than list replication with the multiplication
    operator, because we want a distinct dictionary object to be created for each
    row; remember, repetition is shallow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code after we put it into the initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we go further, let’s test our code in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the fact that everything is “public” we can access implementation
    details during development. It’s clear enough that we’re deliberately defying
    convention here during development, since the leading underscore reminds us what’s
    “public” and what’s “private”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s accurate, but not particularly beautiful. Let’s try again with pretty-print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Perfect!
  prefs: []
  type: TYPE_NORMAL
- en: Allocating seats to passengers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’ll add behavior to `Flight` to allocate seats to passengers. To keep
    this simple, a passenger will be a string name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this code is validation of the seat designator and it contains some
    interesting snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 6: Methods are functions, so deserve docstrings too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 17: We get the seat letter by using negative indexing into the `seat`
    string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 18: We test that the seat letter is valid by checking for membership of
    `seat_letters` using the `in` membership testing operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 21: We extract the row number using string slicing to take all but the
    last character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 23: We try to convert the row number substring to an integer using the
    `int()` constructor. If this fails, we catch the `ValueError` and in the handler
    raise a *new* `ValueError` with a more appropriate message payload.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 27: We conveniently validate the row number by using the `in` operator
    against the `rows` object which is a `range`. We can do this because `range()`
    objects support the *container* protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 30: We check that the requested seat is unoccupied using an identity test
    with `None`. If it’s occupied we raise a `ValueError`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 33: If we get this far, everything is is good shape, and we can assign
    the seat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code also contains a bug, which we’ll discover soon enough!
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying our seat allocator at the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Oh dear! Early on in your object-oriented Python career you’re likely to see
    `TypeError` messages like this quite often. The problem has occurred because we
    forgot to include the `self` argument in the definition of the `allocate_seat()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we fix that, we can try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The Dutchman is quite lonely there in row 12, so we’d like to move him back
    to row 15 with the Danes. To do so, we’ll need a `relocate_passenger()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Naming methods for implementation details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we’ll perform a small refactoring and extract the seat designator parsing
    and validation logic into it’s own method, `_parse_seat()`. We use a leading underscore
    here because this method is an implementation detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `_parse_seat()` method returns a tuple with an integer row number and
    a seat letter string. This has made `allocate_seat()` much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the call to `_parse_seat()` also requires explicit qualification
    with the `self` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing `relocate_passenger()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’ve laid the groundwork for our `relocate_passenger()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This parses and validates the `from_seat` and `to_seat` arguments and then moves
    the passenger to the new location.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also getting tiresome recreating the `Flight` object each time, so we’ll
    add a *module* level convenience function for that too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python it’s quite normal to mix related functions and classes in the same
    module. Now, from the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You may find it remarkable that we have access to the `Flight` class when we
    have only imported a single function, `make_flight`. This is quite normal and
    it’s a powerful aspect of Python’s dynamic type system that facilitates this very
    loose coupling between code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get on and move Guido back to row 15 with his fellow Europeans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Counting available seats
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s important during booking to know how many seats are available. To this
    end we’ll write a `num_available_seats()` method. This uses two nested generator
    expressions. The outer expression filters for all rows which are not `None` to
    exclude our dummy first row. The value of each item in the outer expression is
    the sum of the number of `None` values in each row. This inner expression iterates
    over values of the dictionary and adds 1 for each `None` found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we have split the outer expression over three lines to improve readability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick check shows that our new calculation is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes the only object you need is a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll show how it’s quite possible to write nice object-oriented code without
    needing classes. We have a requirement to produce boarding cards for our passengers
    in alphabetical order. However, we realize that the flight class is probably not
    a good home for details of printing boarding passes. We could go ahead and create
    a `BoardingCardPrinter` class, although that is probably overkill. Remember that
    functions are objects too and are perfectly sufficient for many cases. Don’t feel
    compelled to make classes without good reason.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than have a card printer query all the passenger details from the flight,
    we’ll follow the object-oriented design principle of “Tell! Don’t Ask.” and have
    the `Flight` *tell* a simple card printing function what to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'First the card printer, which is just a module level function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: A Python feature we’re introducing here is the use of line continuation backslash
    characters, ‘\’, which allow us to split long statements over several lines. This
    is used here, together with implicit string concatenation of adjacent strings,
    to produce one long string with no line breaks.
  prefs: []
  type: TYPE_NORMAL
- en: We measure the length of this output line, build some banners and borders around
    it and, concatenate the lines together using the `join()` method called on a newline
    separator. The whole card is then printed, followed by a blank line. The card
    printer doesn’t know anything about `Flights` or `Aircraft` – it’s very loosely
    coupled. You can probably easily envisage an HTML card printer that has the same
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Making `Flight` create boarding cards
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To the `Flight` class we add a new method `make_boarding_cards()` which accepts
    a `card_printer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the `card_printer` to print each passenger, having sorted a list
    of passenger-seat tuples obtained from a `_passenger_seats()` implementation detail
    method (note the leading underscore). This method is in fact a generator function
    which searches all seats for occupants, yielding the passenger and the seat number
    as they are found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run this on the REPL, we can see that the new boarding card printing
    system works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Polymorphism and duck-typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Polymorphism is a programming language feature which allows us to use objects
    of different types through a uniform interface. The concept of polymorphism applies
    to both functions and more complex objects. We’ve just seen an example of polymorphism
    with the card printing example. The `make_boarding_card()` method didn’t need
    to know about an actual – or as we say “concrete” – card printing type, only the
    abstract details of its interface. This interface is essentially just the order
    of it’s arguments. Replacing our `console_card_printer` with a putative `html_card_printer`
    would exercise polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism in Python is achieved through duck typing. Duck typing is in turn
    named after the “duck test”, attributed to James Whitcomb Riley, the American
    poet.
  prefs: []
  type: TYPE_NORMAL
- en: '![James Whitcomb Riley – American poet and author](images/m08----james-whitcomb-riley.png)'
  prefs: []
  type: TYPE_IMG
- en: James Whitcomb Riley – American poet and author
  prefs: []
  type: TYPE_NORMAL
- en: When I see a bird that walks like a duck and swims like a duck and quacks like
    a duck, I call that bird a duck.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Duck typing, where an object’s fitness for a particular use is only determined
    at runtime, is the cornerstone of Python’s object system. This is different from
    many statically typed languages where a compiler determines if an object can be
    used. In particular, it means that an object’s suitability is not based on inheritance
    hierarchies, base classes, or anything except the attributes an object has *at
    the time of use*.
  prefs: []
  type: TYPE_NORMAL
- en: This is in stark contrast to languages such as Java which depend on what is
    called *nominal sub-typing* through inheritance from base classes and interfaces.
    We’ll talk more about inheritance in the context of Python shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring `Aircraft`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s return to our `Aircraft` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The design of this class is somewhat flawed, in that objects instantiated using
    it depend on being supplied with a seating configuration that matches the aircraft
    model. For the purposes of this exercise we can assume that the seating arrangement
    is fixed per aircraft model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Better, and simpler, perhaps to get rid of the `Aircraft` class entirely and
    make separate classes for each specific model of aircraft with a fixed seating
    configuration. Here’s an Airbus A319:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s a Boeing 777:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: These two aircraft classes have no explicit relationship to each other, or to
    our original `Aircraft` class, beyond having identical interfaces (with the exception
    of the initializer, which now takes fewer arguments). As such we can use these
    new types in place of each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our `make_flight()` method to `make_flights()` so we can use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The different types of aircraft both work fine when used with `Flight` because
    they both quack like ducks. Or fly like planes. Or something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Duck typing and polymorphism is very important in Python. In fact it’s the basis
    for the collection protocols we discussed such as *iterator*, *iterable* and *sequence*.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and implementation sharing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inheritance is a mechanism whereby one class can be *derived* from a base-class
    allowing us to make behavior more specific in the subclass. In nominally typed
    languages such as Java, class-based inheritance is the means by which run-time
    polymorphism is achieved. Not so in Python, as we have just demonstrated. The
    fact that no Python method calls or attribute lookups are bound to actual objects
    until the point at which they are called – known as *late-binding* – means we
    can attempt polymorphism with any object and it will succeed if the object fits.
  prefs: []
  type: TYPE_NORMAL
- en: Although inheritance in Python can be used to facilitate polymorphism – after
    all, derived classes will have the same interfaces as base classes – inheritance
    in Python is most useful for sharing implementation between classes.
  prefs: []
  type: TYPE_NORMAL
- en: A base class for aircraft
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As usual, this will make much more sense with an example. We would like our
    aircraft classes `AirbusA319` and `Boeing777` to provide a way of returning the
    total number of seats. We’ll add a method called `num_seats()` to both classes
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The implementation can be identical in both classes, since it can be calculated
    from the seating plan.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we now have duplicate code across two classes, and as we add
    more aircraft types the code duplication will worsen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to extract the common elements of `AirbusA319` and `Boeing777`
    into a base class from which both aircraft types will derive. Let’s recreate the
    class `Aircraft`, this time with the goal of using it as a base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Aircraft` class contains just the method we want to inherit into the derived
    classes. This class isn’t usable on its own because it depends on a method called
    `seating_plan()` which isn’t available at this level. Any attempt to use it standalone
    will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The class is *abstract* insofar as it is never useful to instantiate it alone.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from `Aircraft`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now for the derived classes. We specify inheritance in Python using parentheses
    containing the base class name immediately after the class name in the `class`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the Airbus class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the Boeing class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s exercise them at the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We can see that both subtype aircraft inherited the `num_seats method()`, which
    now works as expected because the call to `seating_plan()` is successfully resolved
    on the `self` object at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Hoisting common functionality into a base class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we have the base `Aircraft` class we can refactor by hoisting into it other
    common functionality. For example, both the initializer and `registration()` methods
    are identical between the two subtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: These derived classes only contain the specifics for that aircraft type. All
    general functionality is shared from the base class by inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to duck-typing, inheritance is less used on Python than in other languages.
    This is generally seen as a good thing because inheritance is a very tight coupling
    between classes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All types in Python have a ‘class’.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes define the structure and behavior of an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class of an object is determined when the object is created and is almost
    always fixed for the lifetime of the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are the key support for Object-Oriented Programming in Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are defined using the `class` keyword followed by the class name, which
    is in CamelCase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instances of a class are created by calling the class as if it were a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance methods are functions defined inside the class which should accept
    an object instance called `self` as the first parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods are called using the `instance.method()` syntax which is syntactic sugar
    for passing the instance as the formal `self` argument to the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional special initializer method called `__init__()` can be provided which
    is used to configure the `self` object at creation time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor calls the `__init__()` method if one is present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__init__()` method is *not* the constructor. The object has been already
    constructed by the time the initializer is called. The initializer configures
    the newly created object before it it returned to the caller of the constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments passed to the constructor are forwarded to the initializer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance attributes are brought into existence by assigning to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes and methods which are implementation details are by convention prefixed
    with an underscore. There are no public, protected or private access modifiers
    in Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to implementation details from outside the class can be very useful during
    development, testing and debugging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class invariants should be established in the initializer. If the invariants
    can’t be established raise exceptions to signal failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods can have docstrings, just like regular functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes can have docstrings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even within an object method calls must be qualified with `self`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have as many classes and functions in a module as you wish. Related
    classes and global functions are usually grouped together this way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism in Python is achieved through duck typing where attributes and
    methods are only resolved at point of use - a behaviour called late-binding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism in Python does not require shared base classes or named interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class inheritance in Python is primarily useful for sharing implementation rather
    than being necessary for polymorphism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All methods are inherited, including special methods like the initialiser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along the way we found that:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings support slicing, because they implement the *sequence* protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the Law of Demeter can reduce coupling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can nest comprehensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can sometimes be useful to discard the current item in a comprehension using
    a dummy reference, conventionally the underscore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When dealing with one-based collections it’s often easier just to waste the
    zeroth list entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t feel compelled to use classes when a simple function will suffice. Functions
    are also objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex comprehensions or generator expressions can be split over multiple lines
    to aid readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements can be split over multiple lines using the backslash line continuation
    character. Use this feature sparingly and only when it improves readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented design where one object *tells* another information can be more
    loosely coupled than those where one object queries another. “Tell! Don’t ask.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
