- en: Chapter 7. Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Form workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Untrusted input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form processing with class-based views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with CRUD views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's set aside Django Forms and talk about web forms in general. Forms are
    not just long, boring pages with several items that you have to fill. Forms are
    everywhere. We use them every day. Forms power everything from Google's search
    box to Facebook's **Like** button.
  prefs: []
  type: TYPE_NORMAL
- en: Django abstracts most of the grunt work while working with forms such as validation
    or presentation. It also implements various security best practices. However,
    forms are also common sources of confusion due to one of several states they could
    be in. Let's examine them more closely.
  prefs: []
  type: TYPE_NORMAL
- en: How forms work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms can be tricky to understand because interacting with them takes more than
    one request-response cycle. In the simplest scenario, you need to present an empty
    form, and the user fills it correctly and submits it. In other cases, they enter
    some invalid data and the form needs to be resubmitted until the entire form is
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a form goes through several states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Empty form**: This form is called an unbound form in Django'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filled form**: This form is called a bound form in Django'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Submitted form with errors**: This form is called a bound form but not a
    valid form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Submitted form without errors**: This form is called a bound and valid form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the users will never see the form in the last state. They don't have
    to. Submitting a valid form should take the users to a success page.
  prefs: []
  type: TYPE_NORMAL
- en: Forms in Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django''s `form` class contains the state of each field and, by summarizing
    them up a level, of the form itself. The form has two important state attributes,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`is_bound`: If this returns false, then it is an unbound form, that is, a fresh
    form with empty or default field values. If true, then the form is bound, that
    is, at least one field has been set with a user input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_valid()`: If this returns true, then every field in the bound form has
    valid data. If false, then there was some invalid data in at least one field or
    the form was not bound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, imagine that you need a simple form that accepts a user''s name
    and age. The form class can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This class can be initiated in a bound or unbound manner, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the HTML representation changes to include the value attributes with
    the bound data in them.
  prefs: []
  type: TYPE_NORMAL
- en: Forms can be bound only when you create the form object, that is, in the constructor.
    How does the user input end up in a dictionary-like object that contains values
    for each form field?
  prefs: []
  type: TYPE_NORMAL
- en: 'To find this out, you need to understand how a user interacts with a form.
    In the following diagram, a user opens the person''s details form, fills it incorrectly
    first, submits it, and then resubmits it with the valid information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Forms in Django](img/6644_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, when the user submits the form, the view
    callable gets all the form data inside `request.POST` (an instance of `QueryDict`).
    The form gets initialized with this dictionary-like object—referred to this way
    since it behaves like a dictionary and has a bit of extra functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Forms can be defined to send the form data in two different ways: `GET` or
    `POST`. Forms defined with `METHOD="GET"` send the form data encoded in the URL
    itself, for example, when you submit a Google search, your URL will have your
    form input, that is, the search string visibly embedded, such as `?q=Cat+Pictures`.
    The `GET` method is used for idempotent forms, which do not make any lasting changes
    to the state of the world (or to be more pedantic, processing the form multiple
    times has the same effect as processing it once). For most cases, this means that
    it is used only to retrieve data.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the vast majority of the forms are defined with `METHOD="POST"`. In
    this case, the form data is sent along with the body of the HTTP request, and
    they are not seen by the user. They are used for anything that involves a side
    effect, such as storing or updating data.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of form you have defined, the view will receive the form
    data in `request.GET` or `request.POST`, when the user submits the form. As mentioned
    earlier, either of them will be like a dictionary. So, you can pass it to your
    form class constructor to get a bound `form` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The Breach**'
  prefs: []
  type: TYPE_NORMAL
- en: Steve was curled up and snoring heavily in his large three-seater couch. For
    the last few weeks, he had been spending more than 12 hours at the office, and
    tonight was no exception. His phone lying on the carpet beeped. At first, he said
    something incoherently, still deep in sleep. Then, it beeped again and again,
    in increasing urgency.
  prefs: []
  type: TYPE_NORMAL
- en: By the fifth beep, Steve awoke with a start. He frantically searched all over
    his couch, and finally located his phone. The screen showed a brightly colored
    bar chart. Every bar seemed to touch the high line except one. He pulled out his
    laptop and logged into the SuperBook server. The site was up and none of the logs
    indicated any unusual activity. However, the external services didn't look that
    good.
  prefs: []
  type: TYPE_NORMAL
- en: The phone at the other end seemed to ring for eternity until a croaky voice
    answered, "Hello, Steve?" Half an hour later, Jacob was able to zero down the
    problem to an unresponsive superhero verification service. "Isn't that running
    on Sauron?" asked Steve. There was a brief hesitation. "I am afraid so," replied
    Jacob.
  prefs: []
  type: TYPE_NORMAL
- en: Steve had a sinking feeling at the pit of his stomach. Sauron, a mainframe application,
    was their first line of defense against cyber-attacks and other kinds of possible
    attack. It was three in the morning when he alerted the mission control team.
    Jacob kept chatting with him the whole time. He was running every available diagnostic
    tool. There was no sign of any security breach.
  prefs: []
  type: TYPE_NORMAL
- en: Steve tried to calm him down. He reassured him that perhaps it was a temporary
    overload and he should get some rest. However, he knew that Jacob wouldn't stop
    until he found what's wrong. He also knew that it was not typical of Sauron to
    have a temporary overload. Feeling extremely exhausted, he slipped back to sleep.
  prefs: []
  type: TYPE_NORMAL
- en: Next morning, as Steve hurried to his office building holding a bagel, he heard
    a deafening roar. He turned and looked up to see a massive spaceship looming towards
    him. Instinctively, he ducked behind a hedge. On the other side, he could hear
    several heavy metallic objects clanging onto the ground. Just then his cell phone
    rang. It was Jacob. Something had moved closer to him. As Steve looked up, he
    saw a nearly 10-foot-tall robot, colored orange and black, pointing what looked
    like a weapon directly down at him.
  prefs: []
  type: TYPE_NORMAL
- en: His phone was still ringing. He darted out into the open barely missing the
    sputtering shower of bullets around him. He took the call. "Hey Steve, guess what,
    I found out what actually happened." "I am dying to know," Steve quipped.
  prefs: []
  type: TYPE_NORMAL
- en: '"Remember, we had used UserHoller''s form widget to collect customer feedback?
    Apparently, their data was not that clean. I mean several serious exploits. Hey,
    there is a lot of background noise. Is that the TV?" Steve dived towards a large
    sign that said "Safe Assembly Point". "Just ignore that. Tell me what happened,"
    he screamed.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Okay. So, when our admin opened their feedback page, his laptop must have
    gotten infected. The worm could reach other systems he has access to, specifically,
    Sauron. I must say Jacob, this is a very targeted attack. Someone who knows our
    security system quite well has designed this. I have a feeling something scary
    is coming our way."'
  prefs: []
  type: TYPE_NORMAL
- en: Across the lawn, a robot picked up an SUV and hurled it towards Steve. He raised
    his hands and shut his eyes. The spinning mass of metal froze a few feet above
    him. "Important call?" asked Hexa as she dropped the car. "Yeah, please get me
    out of here," Steve begged.
  prefs: []
  type: TYPE_NORMAL
- en: Why does data need cleaning?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eventually, you need to get the "cleaned data" from the form. Does this mean
    that the values that the user had entered were not clean? Yes, for two reasons.
  prefs: []
  type: TYPE_NORMAL
- en: First, anything that comes from the outside world should not be trusted initially.
    Malicious users can enter all sorts of exploits through a form that can undermine
    the security of your site. So, any form data must be sanitized before you use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best Practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Never trust the user input.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the field values in `request.POST` or `request.GET` are just strings.
    Even if your form field can be defined as an integer (say, age) or date (say,
    birthday), the browser would send them as strings to your view. Invariably, you
    would like to convert them to the appropriate Python types before use. The `form`
    class does this conversion automatically for you while cleaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The age value was passed as a string (possibly, from `request.POST`) to the
    form class. After validation, the cleaned data contains the age in the integer
    form. This is exactly what you would expect. Forms try to abstract away the fact
    that strings are passed around and give you clean Python objects that you can
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django forms also help you create an HTML representation of your form. They
    support three different representations: `as_p` (as paragraph tags), `as_ul` (as
    unordered list items), and `as_table` (as, unsurprisingly, a table).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The template code, generated HTML code, and browser rendering for each of these
    representations have been summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Template | Code | Output in Browser |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `{{ form.as_p }}` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| ![Displaying forms](img/6644_07_02.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| `{{ form.as_ul }}` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| ![Displaying forms](img/6644_07_03.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| `{{ form.as_table }}` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| ![Displaying forms](img/6644_07_04.jpg) |'
  prefs: []
  type: TYPE_TB
- en: 'Notice that the HTML representation gives only the form fields. This makes
    it easier to include multiple Django forms in a single HTML form. However, this
    also means that the template designer has a fair bit of boilerplate to write for
    each form, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that to make the HTML representation complete, you need to add the surrounding
    `form` tags, a CSRF token, the `table` or `ul` tags, and the **submit** button.
  prefs: []
  type: TYPE_NORMAL
- en: Time to be crisp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It can get tiresome to write so much boilerplate for each form in your templates.
    The `django-crispy-forms` package makes writing the form template code more crisp
    (in the sense of short). It moves all the presentation and layout into the Django
    form itself. This way, you can write more Python code and less HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows that the crispy form template tag generates a more
    complete form, and the appearance is much more native to the Bootstrap style:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Template | Code | Output in Browser |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `{% crispy form %}` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: (HTML truncated for brevity) | ![Time to be crisp](img/6644_07_05.jpg) |
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do you get crisper forms? You will need to install the `django-crispy-forms`
    package and add it to your `INSTALLED_APPS`. If you use Bootstrap 3, then you
    will need to mention this in your settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The form initialization will need to mention a helper attribute of the type
    `FormHelper`. The following code is intended to be minimal and uses the default
    layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Understanding CSRF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you must have noticed something called a **CSRF** token in the form templates.
    What does it do? It is a security mechanism against **Cross-Site Request Forgery**
    (CSRF) attacks for your forms.
  prefs: []
  type: TYPE_NORMAL
- en: It works by injecting a server-generated random string called a CSRF token,
    unique to a user's session. Every time a form is submitted, it must have a hidden
    field that contains this token. This token ensures that the form was generated
    for the user by the original site, rather than a fake form created by an attacker
    with similar fields.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF tokens are not recommended for forms using the `GET` method because the
    `GET` actions should not change the server state. Moreover, forms submitted via
    `GET` would expose the CSRF token in the URLs. Since URLs have a higher risk of
    being logged or shoulder-sniffed, it is better to use CSRF in forms using the
    `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: Form processing with Class-based views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can essentially process a form by subclassing the Class-based view itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Compare this code with the sequence diagram that we saw previously. The three
    scenarios have been separately handled.
  prefs: []
  type: TYPE_NORMAL
- en: Every form is expected to follow the **Post/Redirect/Get** (**PRG**) pattern.
    If the submitted form is found to be valid, then it must issue a redirect. This
    prevents duplicate form submissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this is not a very DRY code. The form class name and template name
    attributes have been repeated. Using a generic class-based view such as `FormView`
    can reduce the redundancy of form processing. The following code will give you
    the same functionality as the previous one in fewer lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We need to use `reverse_lazy` in this case because the URL patterns are not
    loaded when the view file is imported.
  prefs: []
  type: TYPE_NORMAL
- en: Form patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at some of the common patterns when working with forms.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern – dynamic form generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Adding form fields dynamically or changing form fields from what
    has been declared.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Add or change fields during initialization of the form.'
  prefs: []
  type: TYPE_NORMAL
- en: Problem details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Forms are usually defined in a declarative style with form fields listed as
    class fields. However, sometimes we do not know the number or type of these fields
    in advance. This calls for the form to be dynamically generated. This pattern
    is sometimes called **Dynamic Forms** or **Runtime form generation**.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a flight passenger check-in system, which allows for the upgrade of
    economy class tickets to first class. If there are any first-class seats left,
    there needs to be an additional option to the user if they would like to fly first
    class. However, this optional field cannot be declared since it will not be shown
    to all users. Such dynamic forms can be handled by this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Solution details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every form instance has an attribute called `fields`, which is a dictionary
    that holds all the form fields. This can be modified at runtime. Adding or changing
    the fields can be done during form initialization itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we need to add a checkbox to a user details form only if a
    keyword argument named "`upgrade`" is true at form initialization, then we can
    implement it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, we just need to pass the, `PersonDetailsForm(upgrade=True)` keyword argument
    to make an additional Boolean input field ( a checkbox) appear.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that a newly introduced keyword argument has to be removed or popped before
    we call `super` to avoid the `unexpected keyword` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use a `FormView` class for this example, then we need to pass the keyword
    argument by overriding the `get_form_kwargs` method of the view class, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This pattern can be used to change any attribute of a field at runtime, such
    as its widget or help text. It works for model forms as well.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, a seeming need for dynamic forms can be solved using Django formsets.
    They are used when a form needs to be repeated in a page. A typical use case for
    formsets is while designing a data grid-like view to add elements row by row.
    This way, you do not need to create a dynamic form with an arbitrary number of
    rows. You just need to create a form for the row and create multiple rows using
    a `formset_factory` function.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern – user-based forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Forms need to be customized based on the logged-in user.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Pass the logged-in user as a keyword argument to the form''s
    initializer.'
  prefs: []
  type: TYPE_NORMAL
- en: Problem details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A form can be presented in different ways based on the user. Certain users might
    not need to fill all the fields, while certain others might need to add additional
    information. In some cases, you might need to run some checks on the user's eligibility,
    such as verifying whether they are members of a group, to determine how the form
    should be constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you must have noticed, you can solve this using the solution given in the
    Dynamic form generation pattern. You just need to pass `request.user` as a keyword
    argument to the form. However, we can also use mixins from the `django-braces`
    package for a shorter and more reusable solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous example, we need to show an additional checkbox to the user.
    However, this will be shown only if the user is a member of the VIP group. Let''s
    take a look at how `PersonDetailsForm` gets simplified with the form mixin `UserKwargModelFormMixin`
    from `django-braces`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `self.user` was automatically made available by the mixin by popping
    the `user` keyword argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Corresponding to the form mixin, there is a view mixin called `UserFormKwargsMixin`,
    which needs to be added to the view, along with `LoginRequiredMixin` to ensure
    that only logged-in users can access this view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `user` argument will be passed to the `PersonDetailsForm` form automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Do check out other form mixins in `django-braces` such as `FormValidMessageMixin,`
    which are readymade solutions to common form-usage patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern – multiple form actions per view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Handling multiple form actions in a single view or page.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Forms can use separate views to handle form submissions or a
    single view can identify the form based on the `Submit` button''s name.'
  prefs: []
  type: TYPE_NORMAL
- en: Problem details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Django makes it relatively straightforward to combine multiple forms with the
    same action, for example, a single submit button. However, most web pages need
    to show several actions on the same page. For example, you might want the user
    to subscribe or unsubscribe from a newsletter in two distinct forms on the same
    page.
  prefs: []
  type: TYPE_NORMAL
- en: However, Django's `FormView` is designed to handle only one form per view scenario.
    Many other generic class-based views also share this assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Solution details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to handle multiple forms: a separate view and single view.
    Let''s take a look at the first approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Separate views for separate actions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a fairly straightforward approach with each form specifying different
    views as their actions. For example, take the subscribe and unsubscribe forms.
    There can be two separate view classes to handle just the `POST` method from their
    respective forms.
  prefs: []
  type: TYPE_NORMAL
- en: Same view for separate actions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Perhaps you find the splitting views to handle forms to be unnecessary, or you
    find handling logically related forms in a common view to be more elegant. Either
    way, we can work around the limitations of generic class-based views to handle
    more than one form.
  prefs: []
  type: TYPE_NORMAL
- en: While using the same view class for multiple forms, the challenge is to identify
    which form issued the `POST` action. Here, we take advantage of the fact that
    the name and value of the `Submit` button is also submitted. If the `Submit` button
    is named uniquely across forms, then the form can be identified while processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we define a subscribe form using crispy forms so that we can name the
    `submit` button as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `UnSubscribeForm` unsubscribe form class is defined in exactly the same
    way (and hence is, omitted), except that its `Submit` button is named `unsubscribe_butn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `FormView` is designed for a single form, we will use a simpler class-based
    view say, `TemplateView`, as the base for our view. Let''s take a look at the
    view definition and the `get` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The keyword arguments to a `TemplateView` class get conveniently inserted into
    the template context. We create instances of either form only if they don't already
    exist, with the help of the `setdefault` dictionary method. We will soon see why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will take a look at the `POST` method, which handles submissions from
    either form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, the form keyword arguments, such as `data` and `files`, are populated
    in a `form_args` dictionary. Next, the presence of the first form's `Submit` button
    is checked in `request.POST`. If the button's name is found, then the first form
    is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: If the form fails validation, then the response created by the `GET` method
    with the first form's instance is returned. In the same way, we look for the second
    forms submit button to check whether the second form was submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Instances of the same form in the same view can be implemented in the same way
    with form prefixes. You can instantiate a form with a prefix argument such as
    `SubscribeForm(prefix="offers")`. Such an instance will prefix all its form fields
    with the given argument, effectively working like a form namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern – CRUD views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Writing boilerplate for CRUD interfaces to a model is repetitive.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Use generic class-based editing views.'
  prefs: []
  type: TYPE_NORMAL
- en: Problem details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most web applications, about 80 percent of the time is spent writing, creating,
    reading, updating, and deleting (CRUD) interfaces to a database. For instance,
    Twitter essentially involves creating and reading each other's tweets. Here, a
    tweet would be the database object that is being manipulated and stored.
  prefs: []
  type: TYPE_NORMAL
- en: Writing such interfaces from scratch can get tedious. This pattern can be easily
    managed if CRUD interfaces can be automatically created from the model class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Solution details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Django simplifies the process of creating CRUD views with a set of four generic
    class-based views. They can be mapped to their corresponding operations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateView`: This view displays a blank form to create a new object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DetailView`: This view shows an object''s details by reading from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateView`: This view allows to update an object''s details through a pre-populated
    form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteView`: This view displays a confirmation page and, on approval, deletes
    the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple example. We have a model that contains important
    dates, which are of interest to everyone using our site. We need to build simple
    CRUD interfaces so that anyone can view and modify these dates. Let''s take a
    look at the `ImportantDate` model itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `get_absolute_url()` method is used by the `CreateView` and `UpdateView`
    classes to redirect after a successful object creation or update. It has been
    routed to the object's `DetailView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CRUD views themselves are simple enough to be self-explanatory, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In these generic views, the model class is the only mandatory member to be mentioned.
    However, in the case of `DeleteView`, the `success_url` function needs to be mentioned
    as well. This is because after deletion `get_absolute_url` cannot be used anymore
    to find out where to redirect users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining the `form_class` attribute is not mandatory. If it is omitted, a `ModelForm`
    method corresponding to the specified model will be created. However, we would
    like to create our own model form to take advantage of crispy forms, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to crispy forms, we need very little HTML markup in our templates to
    build these CRUD forms.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that explicitly mentioning the fields of a `ModelForm` method is a best
    practice and will soon become mandatory in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: The template paths, by default, are based on the view class and the model names.
    For brevity, we omitted the template source here. Note that we can use the same
    form for `CreateView` and `UpdateView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we take a look at `urls.py`, where everything is wired up together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Django generic views are a great way to get started with creating CRUD views
    for your models. With a few lines of code, you get well-tested model forms and
    views created for you, rather than doing the boring task yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how web forms work and how they are abstracted
    using form classes in Django. We also looked at the various techniques and patterns
    to save time while working with forms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at a systematic approach to work with
    a legacy Django codebase, and how we can enhance it to meet evolving client needs.
  prefs: []
  type: TYPE_NORMAL
