- en: Object-Oriented Programming and MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our data with a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing widgets to display information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading records from a CSV file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting data into a SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring using the MVC pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, all our applications held data in memory as local variables or attributes.
    However, we also want to be able to persist information so that it is not lost
    when the program is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss how to represent and display this data using
    **object-oriented programming** (**OOP**) principles and applying the **Model-View-Controller**
    (**MVC**) pattern. In short, this pattern proposes three components into which
    we can divide our GUI: a **model** that holds the application data, a **view** that
    displays this data, and a **controller** that handles user events and connects
    the view with the model.'
  prefs: []
  type: TYPE_NORMAL
- en: These concepts are related to how we manipulate and persist information, and
    in turn help us to improve the organization of our programs. Most of these recipes
    are not specific to Tkinter, and you can apply the same principles to other GUI
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our data with a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will take the example of a contact list application to illustrate how to
    model our data using Python classes. Even though the user interface may offer
    lots of different functionalities, we will need to define what attributes represent
    our domain model—in our case, each individual contact.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every contact will contain the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: A first and last name, which must not be empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An email address, such as `john.doe@acme.com`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A phone number with the *(123) 4567890* format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this abstraction, we can start writing the code of our `Contact` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we define a couple of utility functions that we will reuse to validate
    the fields that are mandatory or must follow a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define our `Contact` class and its `__init__` method. We set here
    all the parameters to the corresponding fields. We also store the compiled regular
    expressions as class attributes since we will use them for every instance to perform
    the field validations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this definition is not enough to enforce the validations for each
    field. To do so, we use the `@property` decorator, which allow us to wrap access
    to an internal attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The same technique is applied for `first_name` since it is also mandatory.
    The `email` and `phone` attributes follow a similar approach, using the `matches`
    function with the corresponding regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This script should be saved as `chapter5_01.py`, since we will import it later
    in future recipes with this name.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, the `property` descriptor is a mechanism for triggering
    function calls while accessing the attributes of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, they wrap access to the internal attributes with a leading
    underscore, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `property` descriptor is typically used with the `@decorated` syntax—remember
    to always use the same name for the decorated functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may find the complete implementation of our `Contact` class quite verbose
    and repetitive. For each attribute, we will need to assign it in the `__init__`
    method and write its corresponding getter and setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we have several alternatives to reduce this amount of boilerplate
    code. The `namedtuple` function from the standard library allows us to create
    lightweight tuple subclasses with named fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, we still need to add a workaround to implement the validation of the
    fields. To address this common problem, we can use the `attrs` package available
    from the Python Package Index.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, you can install it using the following command line with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, you can replace all the properties with the `attr.ib` descriptor.
    It also lets you specify a `validator` callback that takes the class instance,
    the attribute to be modified, and the value to be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'With some minor modifications, we can rewrite our `Contact` class, reducing
    the number of lines of code by half:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When adding an external dependency in your projects, note not only the productivity
    benefits, but also other important aspects, such as documentation, support, and
    licensing.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the `attrs` package on its website at [http://www.attrs.org/en/stable/](http://www.attrs.org/en/stable/).
  prefs: []
  type: TYPE_NORMAL
- en: Composing widgets to display information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is difficult to build large applications if all the code is contained in
    a single class. By splitting the GUI code into specific classes, we can modularize
    the structure of our program and create widgets with well-defined purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from importing the Tkinter package, we will import the `Contact` class
    from the preceding recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Verify that the `chapter5_01.py` file is in the same directory; otherwise, this
    `import-from` statement will raise `ImportError`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a scrollable list that will show all contacts. To represent
    each item in the list as a string, we will display the contact''s last and first
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To display and allow us to edit the details of a contact, we will also create
    a specific form. We will take the `LabelFrame` widget as a base class, with a
    `Label` and an `Entry` for each field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important detail of the `ContactList` class is that it exposes the possibility
    to attach a callback to the double-click event. It also passes the clicked index
    as an argument to this function. We do this because we want to hide the implementation
    details of the underlying `Listbox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`ContactForm` also offers an abstraction to instantiate a new contact from
    the values input in the entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since we included field validations in our `Contact` class, instantiating a
    new contact might raise a `ValueError` if an entry contains an invalid value.
    To notify the user of this, we show an error dialog with the error message.
  prefs: []
  type: TYPE_NORMAL
- en: Reading records from a CSV file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a first approach to loading read-only data into our application, we will
    use a **comma-separated values** (**CSV**) file. This format tabulates data in
    plain text files, where each file corresponds to the fields of a record, separated
    by commas, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This solution is easy to implement for simple scenarios, especially if the text
    fields do not contain line breaks. We will use the `csv` module from the standard
    library, and once the records are loaded into our application, we will populate
    the widgets developed in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will assemble the custom widgets we created in the previous recipe. Once
    the records are loaded from the CSV file, our application will look as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/4c1f3853-759d-44a7-8bd8-7b1302be4fae.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from importing the `Contact` class, we will also import the `ContactForm`
    and `ContactList` widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `load_contacts` function is responsible for reading the CSV file and transforming
    all the records into a list of `Contact` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each row read by `csv.reader` is returned as a tuple of strings, created by
    splitting the corresponding line using the comma delimiter. Since this tuple uses
    the same order as the parameters defined in the `__init__` method of the `Contact`
    class, we can simply unpack it with the `*` operator. This code can be summarized
    in a single line using a list comprehension, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There is no problem in returning the list within the `with` block, since the
    context manager automatically closes the file when the method execution finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data into a SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we want to be able to persist changes to the data through our application,
    we must implement a solution that serves both for reading and writing operations.
  prefs: []
  type: TYPE_NORMAL
- en: We could write all the records to the same plain text file we read them from
    after every modification, but this may be an ineffective solution when updating
    some records individually.
  prefs: []
  type: TYPE_NORMAL
- en: Since all the information is going to be stored locally, we can use a SQLite
    database to persist our application data. The `sqlite3` module is a part of the
    standard library, so you do not need any additional dependencies to start using
    it.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe does not pretend to be a comprehensive guide to SQLite, but a practical
    introduction to integrate it into your Tkinter applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before using the database in our application, we need to create and populate
    it with some initial data. All our contacts are stored in the CSV file, so we
    will use a migration script to read all the records and insert them into the database.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a connection to the `contacts.db` file, where our data will
    be stored. Then, we create the `contacts` table with the `last_name`, `first_name`,
    `email`, and `phone` text fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `csv.reader` returns an iterable of tuples whose fields follow the same
    order that we have defined in our `CREATE TABLE` statement, we can pass it directly
    to the `executemany` method. It will execute the `INSERT` statement for each tuple,
    replacing the question marks with the actual values of each record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `with` statement automatically commits the transaction and closes both the
    file and the SQLite connection at the end of the execution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add new contacts to our database, we will define a `Toplevel` subclass that
    reuses `ContactForm` to instantiate a new contact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following top-level window will be displayed on top of the main window
    and returns the focus once the dialog is confirmed or closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/a86cb45d-2ed0-4f5f-ae76-d9a6e4db65d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will also extend our `ContactForm` class with two additional buttons—one
    for updating the contact information, and another one for deleting the selected
    contact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `bind_save` and `bind_delete` methods allow us to attach a callback to the
    corresponding button's `command`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To integrate all these changes, we will add the following code to our `App`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to modify the `load_contacts` method to create the contacts from
    a query result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a contact to the list, we will instantiate a `NewContact` dialog and
    call its `show` method to get the details of the new contact. If these values
    are valid, we will store them in a tuple in the same order as they are specified
    in our `INSERT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Once a contact is selected, we can update its details by retrieving the current
    form values. If they are valid, we execute an `UPDATE` statement to set the columns
    of the record with the specified `rowid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the fields of this statement are in the same order as the `INSERT` statement,
    we reuse the `to_values` method to create a tuple from the contact instance—the
    only difference is that we have to append the substitution parameter for `rowid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete the selected contact, we get its `rowid` to replace it in our `DELETE`
    statement. Once the transaction is committed, the contact is removed from the
    GUI by clearing the form and deleting it from the list. The `selection` attribute
    is also set to `None` to avoid performing operations over an invalid selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will wrap the code to initialize our application in a `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With all these changes, our complete application will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/54018c9c-4b84-4521-b888-b9ca33f899e4.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This type of application is referred to using the **CRUD** acronym, which stands
    for **Create, Read, Update, and Delete**, and is easily mapped into the SQL statements
    `INSERT`, `SELECT`, `UPDATE`, and `DELETE`. We will now take a look at how to
    implement each operation using the `sqlite3.Connection` class.
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT` statements add new records to a table, specifying the column names
    with the corresponding values. If you omit the column names, the column order
    will be used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a table in SQLite, it adds, by default, a column called `rowid` and
    automatically assigns a unique value to identify each row. Since we usually need
    it for subsequent operations, we retrieve it with the `lastrowid` attribute available
    in the `Cursor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`SELECT` statements retrieve the values of one or more columns from the records
    of a table. Optionally, we can add a `WHERE` clause to filter the records to be
    retrieved. This is useful to efficiently implement searches and pagination, but
    we will omit this functionality in our sample application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`UPDATE` statements modify the value of one or more columns from the records
    in a table. Typically, we add a `WHERE` clause to update only the rows that match
    the given criteria—here, we could use `rowid` if we want to update a specific
    record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `DELETE` statements remove one or more records from a table. It is
    even more important to add the `WHERE` clause in these statements, because if
    we omit it, the statement will delete all the rows in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Composing widgets to display information* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring using the MVC pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have developed the complete functionality of our application, we
    can spot some problems in our current design. For instance, the `App` class has
    several responsibilities, from instantiating Tkinter widgets to executing SQL
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: Although it seems easy and straightforward to write methods that perform an
    operation from end to end, this approach leads to code bases that are harder to
    maintain. We can detect this flaw by anticipating possible architectural changes,
    such as replacing our relational database with a REST backend accessed via HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by defining the MVC pattern and how it maps to the different parts
    of the application we built in our previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern divides our application into three components that encapsulate
    a single responsibility, forming the MVC triad:'
  prefs: []
  type: TYPE_NORMAL
- en: The **model** represents the domain data and contains the business rules to
    interact with it. In our example, it is the `Contact` class and the SQLite-specific
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **view** is a graphical representation of the model data. In our case, it
    is made by the Tkinter widgets that compose the GUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **controller** connects the view and the model by receiving user input and
    updating the model data. This corresponds to our callbacks and event handlers
    and the attributes needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will refactor our application to achieve this separation of concerns. You
    will note that the interactions between components require additional code, but
    they also help us to define their boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, we extract all the pieces of code that interact with the database
    into a separate class. This will allow us to hide the implementations details
    of our persistence layer, only exposing the four necessary methods, `get_contacts`,
    `add_contact`, `update_contact`, and `delete_contact`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This, alongside the `Contact` class, will compose our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our view will simply contain the sufficient code to display the GUI and
    the methods to let the controller update it. We will also rename the class to
    `ContactsView` to better express its purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that user input is handled by the controller, so we added a `set_ctrl`
    method to connect it to the Tkinter callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `ContactsController` class will now contain all code missing from our initial
    `App` class, that is, the interactions between interface and persistence with
    the `selection` and `contacts` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a `__main__.py` script that will allow us not only to Bootstrap
    our application, but also to be able to launch it from a zipped file or with the
    name of the containing directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The original MVC implementation was introduced in the Smalltalk programming
    language, and it is represented by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/994bfa05-b8eb-48a8-9870-dc89e1d1df40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see that the view passes user events to the
    controller, which in turn updates the model. To propagate these changes to the
    view, the model implements the **observer pattern**. This means that views subscribed
    to the model get notified when an update occurs, so they can query the model state
    and change the displayed data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a variation of this design where there is no communication between
    the view and the model. Instead, changes to the view are made by the controller
    after it updates the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/162786bf-3623-4440-bebb-4fd75fd9d71b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This approach is known as **passive model**, and it is the most common approach
    for modern MVC implementations—especially for web frameworks. We used this variation
    in our example because it simplifies our `ContactsRepository` and does not require
    major modifications to our `ContactsController` class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have noted that update and delete operations work thanks to the `rowid`
    field, for instance, in the `update_contact` method from the `ContactsController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Since this is an implementation detail for our SQLite database, this should
    be hidden from the rest of our components.
  prefs: []
  type: TYPE_NORMAL
- en: A solution would be to add another field to the `Contact` class with a name
    such as `id` or `contact_id`—note that `id` is also a Python built-in function
    and some editors might incorrectly highlight it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can assume this field is part of our domain data as a unique identifier
    and leave the implementation details of how it is generated to the model.
  prefs: []
  type: TYPE_NORMAL
