- en: Dockerizing Your Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an understanding of continuous integration and continuous delivery/deployment
    from the previous chapter, it is the right time to dive deeply into container-based
    technologies, such as Docker, where we will deploy our application. In this chapter,
    we will take a look at Docker and its features, and we will deploy our cloud native
    application on Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker and how it is different from virtualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Docker and Docker Swarm on a different OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a cloud native app on Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a **Container Management System** (**CMS**) that enables you to separate
    your application from your infrastructure, which makes it easier to develop, ship,
    and run your application. It is useful for managing **Linux Containers** (**LXC**).
    This let's you create images, and also perform actions on the containers as well
    as run commands or operations against containers.
  prefs: []
  type: TYPE_NORMAL
- en: In simple words, Docker provides a platform to package and run your application
    in an isolated environment called a **container**, and then ship it across different
    of software release environments, such as stage, pre-production, production, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker** is lightweight in comparison to any **Traditional VMs**, as depicted
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Few facts about Docker versus virtualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot of organizations that are still working successfully on traditional
    VMs. Having said that, there are organizations that have either moved their application
    to Docker or are ready to do so. Here are a few reasons why Docker has more potential
    than virtual machines:'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to comparing Docker and virtual machines, Docker presents a lower
    system overhead than the virtual machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, applications in the Docker environment have a generally higher performance
    than the virtual machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the VM software technology named **Hypervisor**, which acts as an agent
    between the VM environment and the underlying hardware, providing the necessary
    layer of abstraction; in Docker, we have the Docker engine that gives us more
    control than the Docker machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, as you can see in the preceding image, Docker shares the **Host O.S.**
    across the Docker environment, whereas, the virtual machine needs its own OS for
    application deployment. This makes Docker lightweight and spin up and destroy
    them much faster, as compared to the virtual machine. Docker is similar to any
    other processes running on top of the host OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of a cloud native application, where we need to test our microservices
    quickly after every stage of development, Docker would be a good platform option
    to test our application, which is highly recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Engine - The backbone of Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker Engine is a client-server application that has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerd**: This is a daemon process that keeps running in the background
    of the host OS to keep a track of the Docker container attributes, such as status
    (up/running/stopped)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rest API**: This provides the interface to interact with daemon and perform
    actions on containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker command line**: This provides the command-line interface to create
    and manage Docker objects, such as images, containers, networks, and volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Docker environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at the installation procedure for Docker
    on different operating systems, such as Debian and Windows, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up Docker is pretty straightforward. There are mainly two editions of
    Docker in the marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Inc., which owns the **containerization** Docker product, renamed the
    Docker **Commercially Supported** (**CS**) edition to Docker **Enterprises Edition**
    (**EE**), and also converted the Docker Engine to Docker **Community Edition**
    (**CE**).
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of changes from EE and CE; obviously, the commercial support
    being one of them. However, in the Docker Enterprise Edition, they have built
    a couple of certifications around the container content, platform plugins, and
    many more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will use the Docker Community Edition, so we will begin by
    updating the APT repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the GPG key from the Docker official system as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let''s add the Docker repository to the APT source list of Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, in Ubuntu 14.04/16.04, the `apt-add-repository` utility is not found.
    In order to install the mentioned utility, use the following command to install
    the `software-properties-common` package: **$ sudo apt-get install software-properties-common
    -y**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update your APT package manager to download the latest Docker list as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to download and install the Docker Engine from the Docker repository
    instead of the default 14.04 repository, use the following command to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**$ apt-cache policy docker-engine**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following output on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are ready to install our Docker Engine, so let''s fire the following
    command to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Docker depends on a couple of system libraries, it might face an error
    similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you catch this kind of error, then make sure that you have these libraries
    installed with the defined version as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the Docker Engine installation is successful, it''s time to validate
    it by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you see a version similar to the one shown in the preceding terminal, then
    we are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get help on Docker, you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you really want to go with the Docker Enterprise Edition, you can go ahead
    with the installation steps shown on the official Docker website ([https://docs.docker.com/engine/installation/linux/ubuntu/](https://docs.docker.com/engine/installation/linux/ubuntu/)).
  prefs: []
  type: TYPE_NORMAL
- en: Installation on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, Windows is not suitable for Docker, and that's why you don't see the
    container technology around on the Windows system. Having said that, we have a
    couple of workarounds for it. One of them is using Chocolatey.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to install Docker on the Windows system using Chocolatey, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Chocolatey from their official website ([https://chocolatey.org/install](https://chocolatey.org/install)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are couple of ways shown in the preceding link to install Chocolatey.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Chocolatey is installed, you simply have to execute the following command
    in cmd or PowerShell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will install Docker on Windows 7 and 8 operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if you want to go with the Docker Enterprise edition, you can follow
    the steps shown in this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/docker-ee-for-windows/install/#install-docker-ee](https://docs.docker.com/docker-ee-for-windows/install/#install-docker-ee).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Swarm is a popular term for a pool of Docker machines. Docker Swarm is
    very useful for hosting your website as it can be used to scale your infrastructure
    up or down very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In the Docker Swarm, we can club together a couple of Docker machines that work
    as one unit and share their resources, such as CPU, memory, and so on, where one
    machine becomes the master that we call leader, and the remaining nodes work as
    a worker.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up the Docker environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be setting up the Docker Swarm by selecting the leader
    from the Docker machine and connecting the remaining machines with the leader.
  prefs: []
  type: TYPE_NORMAL
- en: Assumption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are a few assumptions for the Docker environment:'
  prefs: []
  type: TYPE_NORMAL
- en: We are taking two machines, which could be VM's or instances from the cloud
    platform, for the demo purpose named master and node1\. Also, we have installed
    Docker on both the machines by following the procedure described in the Docker
    installation section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port `2377` must be opened for communication between the master and node1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the required port for application access should be opened; we will
    need port `80` for nginx, just like in our example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The master Docker machine could be based on any kind of OS, such as Ubuntu,
    Windows, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's begin with our Docker Swarm setup.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Docker manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we need to decide which node should be the leader. Let''s select
    the master node as our Docker manager. So, login into the master machine and execute
    the following command to initialize this machine to be a leader for the Docker
    Swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will set the provided host to be the master (leader) and generate
    a token for the node to connect to. See the following output for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A few important points to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't share your token and IP address with anyone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, it is possible to have multiple masters in case of failovers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add node1 to master
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we selected the leader, we will need to add a new node to the cluster
    to complete the setup. Log in to node1 and execute the following command, which
    is specified in the previous command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can refer to the following screenshot for an output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This means our setup is successful. Let's check if it is added in the master
    Docker machine or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to verify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Testing the Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have set up the Docker Swarm, it''s time to run some services on
    top of it, say, the nginx service. Execute the following command on the master
    Docker machine to start your nginx service on port `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use the following Docker command to see if our service is running or
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of preceding command should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A few other commands to validate are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate which services are running and on which port, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are seeing output similar to the following screenshot, then we are good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To scale up the Docker instances for the service, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check if our nginx is up or not by accessing its default page. Try to
    hit `http://master-ip-address:80/` on your browser. If you see the following output,
    then your service is deployed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! In the upcoming section, we will deploy our cloud native application
    on Docker machines.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application on Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will deploy our cloud native application, which we developed
    in the previous chapters. However, before we begin with the creation of our application
    architecture, there are a few concepts of Docker one should be aware of, some
    of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker images**: These are basically a combination of library and the applications
    deployed on top of it. These images can be downloaded from the Docker Hub public
    repository, or you can create your customized images as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dockerfile**: This is a configuration file to build your images that can
    be used to run your Docker machine later on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Hub**: This is a centralized repository where you can keep your images,
    which can be shared across the team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use all these concepts during our application deployment. Also, we will
    keep using our Docker Swarm setup to deploy our application as we don't want to
    run out of resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow this architecture to deploy our application, where we are deploying
    our application and MongoDB (basically, application data) in separate Docker instances
    as it is recommended to always keep your application and data separate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00142.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Building and running our MongoDB Docker service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be creating the Dockerfile to build `MongoDB`, which
    will have all the information, such as base image, port to be exposed, how to
    install the `MongoDB` service, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s log in to your Docker master (leader) account and create a Dockerfile
    with the name `Dockerfile` using the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Save it, and, before we move ahead, let''s understand its different sections
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will tell you to pull the Ubuntu public image from the Docker
    Hub and make it the base image on which the following command needs to be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding section of code is similar to the one where we execute these commands
    manually for `MongoDB`; however, in this case, it is automatically taken care
    of by Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the volume section, which is kind of optional. It is creating mountable
    directories where we can store the data to keep it safe in an external volume.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section is to expose the ports by which users/clients will be able
    to communicate with the MongoDB server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have saved the file, execute the following command to build the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Building an image can take around 4-5 minutes, depending on the internet bandwidth
    and system performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screen shows the output of the Docker build command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00143.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, as it's showing a successful build, you can now
    see the images list to validate, whether the image with the mentioned tag name
    (**ms-packtpub-mongodb**) is present or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to list the images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screen lists the Docker images available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00144.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Awesome! Our image is present. Now let''s run the `mongodb` service on the
    master Docker machine using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, you will get a random Docker ID, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00145.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check the state of the Docker container by executing the `docker ps`
    command. It should have an output similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00146.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A very few developers as well as sysadmins know that there is an HTTP interface
    for the `mongoDB` service, which we exposed using port `28017`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we try to access `http://your-master-ip-address:28017/` in the browser,
    we will see a screen similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! Our MongoDB is up and running now!!
  prefs: []
  type: TYPE_NORMAL
- en: Before we move ahead with launching containers for the application, let's understand
    how the Docker Hub is useful for us.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub - what is it all about?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As per the Docker Hub official documentation, Docker Hub is a cloud-based registry
    service that allows you to link to code repositories, build your images and test
    them, and store manually pushed images, and links to Docker Cloud so you can deploy
    images to your hosts.
  prefs: []
  type: TYPE_NORMAL
- en: In simpler words, Docker Hub is a centralized store for images which anyone
    around the globe can access, provided they have the required privileges and can
    perform operations around images to deploy and run their application on their
    hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of Docker Hub are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub provides the functionality for automated create builds if any change
    in the source code repository is reported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides WebHook to trigger for application deployment after a successful
    push to the repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides functionality to create a private work space to store images and
    is accessible only within your organization or team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Hub has an integration with your version control system, such as GitHub,
    BitBucket, and so on, which is useful with continuous integration and delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's see how we can push our custom `MongoDB` images to a private repository
    that we created recently.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to create an account at [https://hub.docker.com](https://hub.docker.com)
    and activate it. Once you are logged in, you need to create a private/public repository
    based on your preference, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Create button to set up the repository and you will be redirected
    to the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Docker Hub provides only one private repository on a free account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created the repository, let''s come back to our master Docker
    machine and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ask for your credentials for the Docker Hub account, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the login is successful, it''s time to tag the image you want to push
    to the repository using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we don't specify the tag, then it will take the latest tag by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the tag is created, it''s time to push the tag to the repository. Use
    the following command to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The Following screen shows the Docker `push` command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00151.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the push is completed, you will see the image in Docker Hub in the Tags
    tab, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00152.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This means that your image is pushed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to pull this image, you will simply have to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Oh, wow! It's too simple and you can access it from anywhere, provided you have
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: There are other Docker registry providers such as AWS (EC2 container registry),
    Azure (Azure container registry), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For now, this is all we have from the Docker Hub side. We will keep on using
    Docker Hub during this chapter to push the images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving ahead now, we are ready to deploy our cloud native application to another
    container, but, before that, we need to build an image for it using the Dockerfile.
    So, let''s create a directory called `app` and also create an empty Dockerfile
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: I believe I have explained most of the section inside the Dockerfile earlier,
    although, there are a few sections that still need to be explained.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding section of the Dockerfile, we copied the contents of the application,
    that is, the code, from a local machine to the Docker container. Alternatively,
    we can also use ADD to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CMD` is short for the command that we want to execute inside the Docker
    container, which is defined as follows in the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, save the file and run the following command to build the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This might take a while as there are lot of libraries that need to be installed
    and compiled as well. It is good practice to build an image after every change
    to make sure images are updated with the current config. The output will be similar
    to one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00153.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Make sure every section of the build process is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are ready with our image, it's time to spin our container with the
    latest image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to spin the container, and always remember to
    expose port `5000` to access our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the `docker ps` command to check the container status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there are two containers running in the `myapp` container:
    we will have our application running and on the `mongodb` container, you will
    have your `mongodb` service running.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, check the application URL (`http://your-master-ip-address:5000/`). If
    you see the following screen, it means that our application is deployed successfully
    and we are live on Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00155.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can test out our application by creating new users and logging in, and
    then posting tweets. I will not do it again as we have already done it at the
    time of application creation.
  prefs: []
  type: TYPE_NORMAL
- en: From experience, I know there may be some challenges to the communication between
    your application and database, that is, MongoDB, as both, the app and the database
    are on separate containers and might be in a separate network. In order to deal
    with this kind of problem, you can create a network and connect both the containers
    to that network.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we have to do so for our container (`myapp` and `mongodb`),
    we will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to create a separate network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our network is created, we can add both containers to this network
    using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to find the IP that is assigned to these containers, we can use the
    following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This network creation is an alternative way to set up the communication between
    application and database.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, we have deployed our application on Docker and learned its different
    concepts. The only concept that is left is Docker Compose. Let's understand what
    it is and how different it is from the others.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As per the official Docker Compose website ([https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)),
    Compose is a tool for defining and running multicontainer Docker applications.
    With Compose, you use a Compose file to configure your application's services.
  prefs: []
  type: TYPE_NORMAL
- en: In simpler terms, it helps us build and run our application in a much simpler
    and faster way.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, where we were deploying our application and building
    the images, we first created a Dockerfile and then executed the `Docker build`
    command to build it. Once it is built, we usually use the `docker run` command
    to spin up the container, but, instead of that, in Docker Compose, we will define
    a `.yml` file with config details, such as ports, command to execute, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, Docker Compose is a separate utility from Docker Engine and can be
    installed using the following link, based on the type of OS you are working on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://docs.docker.com/compose/install/`.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have installed it, let's see how we can use Docker Compose to run our
    containers. Let's assume we have to run the cloud native application container
    using Docker Compose. We already have the Dockerfile generated for it, and we
    also have the application at the same location (path).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, using the following content, we will need to create a `Docker-compose.yml`
    file in the same location where the Dockerfile is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have added the config in `docker-compose.yml`, save it and execute
    the `docker-compose up` command. After building the image, we will see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00156.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, if you see the container''s state, you will find multiple containers
    (in our case, `app_web-1` and `app_flask_1`) spin by compose, which is why it
    is useful for mutlicontainer applications that need large-scale infrastructure,
    as it creates a cluster of Docker machines similar to the Docker Swarm. The following
    screen shows the status of the Docker machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! We have deployed our application through Docker-compose as well. Now
    you can try to access the public URL for the application ([http://your-ip-address:5000](http://your-ip-address:5000))
    to confirm the successful application deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, make sure you push your images to the Docker Hub to keep it in a centralized
    repository. Since we have already pushed the MongoDB images, use the following
    command to push the `cloud-native-app` image as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see similar output for, Docker `push` command as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first looked at one of the most interesting technologies--Docker--,
    which is based on containers. We looked at the different concepts around Docker,
    and we already deployed our application and looked at the way we can manage it
    over Docker. We also explored multiple ways to deploy our application using Docker
    Compose and Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, things will be a lot more interesting as we will finally
    reach a stage where we will be exposed to the cloud platform, build our infrastructure
    over the platform based on our application, and also try to deploy it as well.
    So, stay tuned for the next chapter! See you there.
  prefs: []
  type: TYPE_NORMAL
