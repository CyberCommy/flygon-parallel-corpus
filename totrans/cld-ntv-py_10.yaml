- en: Dockerizing Your Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an understanding of continuous integration and continuous delivery/deployment
    from the previous chapter, it is the right time to dive deeply into container-based
    technologies, such as Docker, where we will deploy our application. In this chapter,
    we will take a look at Docker and its features, and we will deploy our cloud native
    application on Docker.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker and how it is different from virtualization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Docker and Docker Swarm on a different OS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a cloud native app on Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker Compose
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Docker
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a **Container Management System** (**CMS**) that enables you to separate
    your application from your infrastructure, which makes it easier to develop, ship,
    and run your application. It is useful for managing **Linux Containers** (**LXC**).
    This let's you create images, and also perform actions on the containers as well
    as run commands or operations against containers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In simple words, Docker provides a platform to package and run your application
    in an isolated environment called a **container**, and then ship it across different
    of software release environments, such as stage, pre-production, production, and
    so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker** is lightweight in comparison to any **Traditional VMs**, as depicted
    in the following image:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00130.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: Few facts about Docker versus virtualization
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot of organizations that are still working successfully on traditional
    VMs. Having said that, there are organizations that have either moved their application
    to Docker or are ready to do so. Here are a few reasons why Docker has more potential
    than virtual machines:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to comparing Docker and virtual machines, Docker presents a lower
    system overhead than the virtual machine.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, applications in the Docker environment have a generally higher performance
    than the virtual machines.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the VM software technology named **Hypervisor**, which acts as an agent
    between the VM environment and the underlying hardware, providing the necessary
    layer of abstraction; in Docker, we have the Docker engine that gives us more
    control than the Docker machine.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, as you can see in the preceding image, Docker shares the **Host O.S.**
    across the Docker environment, whereas, the virtual machine needs its own OS for
    application deployment. This makes Docker lightweight and spin up and destroy
    them much faster, as compared to the virtual machine. Docker is similar to any
    other processes running on top of the host OS.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of a cloud native application, where we need to test our microservices
    quickly after every stage of development, Docker would be a good platform option
    to test our application, which is highly recommended.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Engine - The backbone of Docker
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker Engine is a client-server application that has the following components:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerd**: This is a daemon process that keeps running in the background
    of the host OS to keep a track of the Docker container attributes, such as status
    (up/running/stopped)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rest API**: This provides the interface to interact with daemon and perform
    actions on containers'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker command line**: This provides the command-line interface to create
    and manage Docker objects, such as images, containers, networks, and volumes'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Docker environment
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at the installation procedure for Docker
    on different operating systems, such as Debian and Windows, among others.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker on Ubuntu
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up Docker is pretty straightforward. There are mainly two editions of
    Docker in the marketplace.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Docker Inc., which owns the **containerization** Docker product, renamed the
    Docker **Commercially Supported** (**CS**) edition to Docker **Enterprises Edition**
    (**EE**), and also converted the Docker Engine to Docker **Community Edition**
    (**CE**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of changes from EE and CE; obviously, the commercial support
    being one of them. However, in the Docker Enterprise Edition, they have built
    a couple of certifications around the container content, platform plugins, and
    many more.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will use the Docker Community Edition, so we will begin by
    updating the APT repository:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s add the GPG key from the Docker official system as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then let''s add the Docker repository to the APT source list of Ubuntu:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sometimes, in Ubuntu 14.04/16.04, the `apt-add-repository` utility is not found.
    In order to install the mentioned utility, use the following command to install
    the `software-properties-common` package: **$ sudo apt-get install software-properties-common
    -y**.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update your APT package manager to download the latest Docker list as
    follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you want to download and install the Docker Engine from the Docker repository
    instead of the default 14.04 repository, use the following command to do so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '**$ apt-cache policy docker-engine**.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following output on the terminal:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00131.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are ready to install our Docker Engine, so let''s fire the following
    command to install it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since Docker depends on a couple of system libraries, it might face an error
    similar to the one shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00132.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: If you catch this kind of error, then make sure that you have these libraries
    installed with the defined version as well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'After the Docker Engine installation is successful, it''s time to validate
    it by executing the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you see a version similar to the one shown in the preceding terminal, then
    we are good to go.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'To get help on Docker, you can execute the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you really want to go with the Docker Enterprise Edition, you can go ahead
    with the installation steps shown on the official Docker website ([https://docs.docker.com/engine/installation/linux/ubuntu/](https://docs.docker.com/engine/installation/linux/ubuntu/)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Installation on Windows
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, Windows is not suitable for Docker, and that's why you don't see the
    container technology around on the Windows system. Having said that, we have a
    couple of workarounds for it. One of them is using Chocolatey.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to install Docker on the Windows system using Chocolatey, follow these
    steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Install Chocolatey from their official website ([https://chocolatey.org/install](https://chocolatey.org/install)).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are couple of ways shown in the preceding link to install Chocolatey.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Chocolatey is installed, you simply have to execute the following command
    in cmd or PowerShell:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will install Docker on Windows 7 and 8 operating systems.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if you want to go with the Docker Enterprise edition, you can follow
    the steps shown in this link:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/docker-ee-for-windows/install/#install-docker-ee](https://docs.docker.com/docker-ee-for-windows/install/#install-docker-ee).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Docker Swarm
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Swarm is a popular term for a pool of Docker machines. Docker Swarm is
    very useful for hosting your website as it can be used to scale your infrastructure
    up or down very quickly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: In the Docker Swarm, we can club together a couple of Docker machines that work
    as one unit and share their resources, such as CPU, memory, and so on, where one
    machine becomes the master that we call leader, and the remaining nodes work as
    a worker.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00133.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: Setting up the Docker environment
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be setting up the Docker Swarm by selecting the leader
    from the Docker machine and connecting the remaining machines with the leader.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Assumption
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are a few assumptions for the Docker environment:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: We are taking two machines, which could be VM's or instances from the cloud
    platform, for the demo purpose named master and node1\. Also, we have installed
    Docker on both the machines by following the procedure described in the Docker
    installation section.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port `2377` must be opened for communication between the master and node1.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the required port for application access should be opened; we will
    need port `80` for nginx, just like in our example.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The master Docker machine could be based on any kind of OS, such as Ubuntu,
    Windows, and so on.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's begin with our Docker Swarm setup.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Docker manager
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we need to decide which node should be the leader. Let''s select
    the master node as our Docker manager. So, login into the master machine and execute
    the following command to initialize this machine to be a leader for the Docker
    Swarm:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This command will set the provided host to be the master (leader) and generate
    a token for the node to connect to. See the following output for your reference:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00134.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 'A few important points to keep in mind:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Don't share your token and IP address with anyone
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, it is possible to have multiple masters in case of failovers
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add node1 to master
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we selected the leader, we will need to add a new node to the cluster
    to complete the setup. Log in to node1 and execute the following command, which
    is specified in the previous command output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can refer to the following screenshot for an output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00135.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: This means our setup is successful. Let's check if it is added in the master
    Docker machine or not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to verify it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/00136.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: Testing the Docker Swarm
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have set up the Docker Swarm, it''s time to run some services on
    top of it, say, the nginx service. Execute the following command on the master
    Docker machine to start your nginx service on port `80`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding command should be similar to the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00137.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use the following Docker command to see if our service is running or
    not:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of preceding command should be similar to the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00138.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: 'A few other commands to validate are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate which services are running and on which port, use the following
    command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you are seeing output similar to the following screenshot, then we are good:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00139.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'To scale up the Docker instances for the service, use the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](img/00140.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check if our nginx is up or not by accessing its default page. Try to
    hit `http://master-ip-address:80/` on your browser. If you see the following output,
    then your service is deployed successfully:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00141.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Awesome! In the upcoming section, we will deploy our cloud native application
    on Docker machines.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application on Docker
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will deploy our cloud native application, which we developed
    in the previous chapters. However, before we begin with the creation of our application
    architecture, there are a few concepts of Docker one should be aware of, some
    of which are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker images**: These are basically a combination of library and the applications
    deployed on top of it. These images can be downloaded from the Docker Hub public
    repository, or you can create your customized images as well.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dockerfile**: This is a configuration file to build your images that can
    be used to run your Docker machine later on.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Hub**: This is a centralized repository where you can keep your images,
    which can be shared across the team.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use all these concepts during our application deployment. Also, we will
    keep using our Docker Swarm setup to deploy our application as we don't want to
    run out of resources.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow this architecture to deploy our application, where we are deploying
    our application and MongoDB (basically, application data) in separate Docker instances
    as it is recommended to always keep your application and data separate:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00142.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Building and running our MongoDB Docker service
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be creating the Dockerfile to build `MongoDB`, which
    will have all the information, such as base image, port to be exposed, how to
    install the `MongoDB` service, and so on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s log in to your Docker master (leader) account and create a Dockerfile
    with the name `Dockerfile` using the following contents:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save it, and, before we move ahead, let''s understand its different sections
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code will tell you to pull the Ubuntu public image from the Docker
    Hub and make it the base image on which the following command needs to be run:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding section of code is similar to the one where we execute these commands
    manually for `MongoDB`; however, in this case, it is automatically taken care
    of by Docker.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Next is the volume section, which is kind of optional. It is creating mountable
    directories where we can store the data to keep it safe in an external volume.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next section is to expose the ports by which users/clients will be able
    to communicate with the MongoDB server:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once you have saved the file, execute the following command to build the image:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Building an image can take around 4-5 minutes, depending on the internet bandwidth
    and system performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screen shows the output of the Docker build command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00143.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, as it's showing a successful build, you can now
    see the images list to validate, whether the image with the mentioned tag name
    (**ms-packtpub-mongodb**) is present or not.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to list the images:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following screen lists the Docker images available:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00144.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: 'Awesome! Our image is present. Now let''s run the `mongodb` service on the
    master Docker machine using the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the output, you will get a random Docker ID, as shown in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00145.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check the state of the Docker container by executing the `docker ps`
    command. It should have an output similar to the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00146.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: A very few developers as well as sysadmins know that there is an HTTP interface
    for the `mongoDB` service, which we exposed using port `28017`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we try to access `http://your-master-ip-address:28017/` in the browser,
    we will see a screen similar to the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00147.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: Awesome! Our MongoDB is up and running now!!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Before we move ahead with launching containers for the application, let's understand
    how the Docker Hub is useful for us.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub - what is it all about?
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As per the Docker Hub official documentation, Docker Hub is a cloud-based registry
    service that allows you to link to code repositories, build your images and test
    them, and store manually pushed images, and links to Docker Cloud so you can deploy
    images to your hosts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: In simpler words, Docker Hub is a centralized store for images which anyone
    around the globe can access, provided they have the required privileges and can
    perform operations around images to deploy and run their application on their
    hosts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of Docker Hub are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub provides the functionality for automated create builds if any change
    in the source code repository is reported
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides WebHook to trigger for application deployment after a successful
    push to the repository
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides functionality to create a private work space to store images and
    is accessible only within your organization or team
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Hub has an integration with your version control system, such as GitHub,
    BitBucket, and so on, which is useful with continuous integration and delivery
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's see how we can push our custom `MongoDB` images to a private repository
    that we created recently.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to create an account at [https://hub.docker.com](https://hub.docker.com)
    and activate it. Once you are logged in, you need to create a private/public repository
    based on your preference, as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00148.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Create button to set up the repository and you will be redirected
    to the following screen:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“创建”按钮设置仓库，您将被重定向到以下屏幕：
- en: '![](img/00149.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00149.jpeg)'
- en: Docker Hub provides only one private repository on a free account.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub在免费帐户上只提供一个私有仓库。
- en: 'Now that we have created the repository, let''s come back to our master Docker
    machine and execute the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了仓库，让我们回到我们的主Docker机器并执行以下命令：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will ask for your credentials for the Docker Hub account, as shown in
    the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求您输入Docker Hub帐户的凭据，如下截图所示：
- en: '![](img/00150.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00150.jpeg)'
- en: 'Once the login is successful, it''s time to tag the image you want to push
    to the repository using the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，是时候使用以下命令为要推送到仓库的镜像打标签了：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we don't specify the tag, then it will take the latest tag by default.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不指定标签，那么它将默认使用最新的标签。
- en: 'Once the tag is created, it''s time to push the tag to the repository. Use
    the following command to do so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 标签创建完成后，是时候将标签推送到仓库了。使用以下命令来执行：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The Following screen shows the Docker `push` command output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕显示了Docker `push`命令的输出：
- en: '![](img/00151.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00151.jpeg)'
- en: 'Once the push is completed, you will see the image in Docker Hub in the Tags
    tab, as shown here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 推送完成后，您将在Docker Hub的“标签”选项卡中看到镜像，如此处所示：
- en: '![](img/00152.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00152.jpeg)'
- en: This means that your image is pushed successfully.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您的镜像已成功推送。
- en: 'In order to pull this image, you will simply have to use the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要拉取此镜像，您只需使用以下命令：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Oh, wow! It's too simple and you can access it from anywhere, provided you have
    credentials.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，哇！这太简单了，只要您有凭据，就可以从任何地方访问它。
- en: There are other Docker registry providers such as AWS (EC2 container registry),
    Azure (Azure container registry), and so on.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他Docker注册表提供者，如AWS（EC2容器注册表）、Azure（Azure容器注册表）等。
- en: For now, this is all we have from the Docker Hub side. We will keep on using
    Docker Hub during this chapter to push the images.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这就是我们从Docker Hub那边得到的全部内容。在本章中，我们将继续使用Docker Hub来推送镜像。
- en: 'Moving ahead now, we are ready to deploy our cloud native application to another
    container, but, before that, we need to build an image for it using the Dockerfile.
    So, let''s create a directory called `app` and also create an empty Dockerfile
    with the following contents:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续，我们准备将我们的云原生应用部署到另一个容器中，但在此之前，我们需要使用Dockerfile为其构建一个镜像。因此，让我们创建一个名为`app`的目录，并创建一个空的Dockerfile，其中包含以下内容：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I believe I have explained most of the section inside the Dockerfile earlier,
    although, there are a few sections that still need to be explained.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信我之前已经解释了Dockerfile中大部分部分，尽管还有一些部分需要解释。
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding section of the Dockerfile, we copied the contents of the application,
    that is, the code, from a local machine to the Docker container. Alternatively,
    we can also use ADD to do the same.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dockerfile的前面部分，我们将应用程序的内容，即代码，从本地机器复制到Docker容器中。或者，我们也可以使用ADD来执行相同的操作。
- en: 'The `CMD` is short for the command that we want to execute inside the Docker
    container, which is defined as follows in the Dockerfile:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`是我们想要在Docker容器内执行的命令的缩写，它在Dockerfile中定义如下：'
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, save the file and run the following command to build the image:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存文件并运行以下命令来构建镜像：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This might take a while as there are lot of libraries that need to be installed
    and compiled as well. It is good practice to build an image after every change
    to make sure images are updated with the current config. The output will be similar
    to one shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要一些时间，因为需要安装和编译许多库。每次更改后构建镜像是一个好习惯，以确保镜像与当前配置更新。输出将类似于此处显示的输出：
- en: '![](img/00153.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00153.jpeg)'
- en: Make sure every section of the build process is successful.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 确保构建过程的每个部分都成功。
- en: Now that we are ready with our image, it's time to spin our container with the
    latest image.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的镜像，是时候使用最新的镜像启动我们的容器了。
- en: 'Execute the following command to spin the container, and always remember to
    expose port `5000` to access our application:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令来启动容器，并始终记住要暴露端口`5000`以访问我们的应用程序：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, run the `docker ps` command to check the container status:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`docker ps`命令来检查容器状态：
- en: '![](img/00154.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00154.jpeg)'
- en: 'As you can see, there are two containers running in the `myapp` container:
    we will have our application running and on the `mongodb` container, you will
    have your `mongodb` service running.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`myapp`容器中有两个容器在运行：我们的应用程序在运行，而`mongodb`容器中将运行您的`mongodb`服务。
- en: 'Next, check the application URL (`http://your-master-ip-address:5000/`). If
    you see the following screen, it means that our application is deployed successfully
    and we are live on Docker:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检查应用程序的URL（`http://your-master-ip-address:5000/`）。如果看到以下屏幕，这意味着我们的应用程序已成功部署，并且我们在Docker上已经上线了：
- en: '![](img/00155.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00155.jpeg)'
- en: Now we can test out our application by creating new users and logging in, and
    then posting tweets. I will not do it again as we have already done it at the
    time of application creation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过创建新用户并登录，然后发布推文来测试我们的应用程序。我不会再次执行，因为我们在创建应用程序时已经执行过了。
- en: From experience, I know there may be some challenges to the communication between
    your application and database, that is, MongoDB, as both, the app and the database
    are on separate containers and might be in a separate network. In order to deal
    with this kind of problem, you can create a network and connect both the containers
    to that network.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验，我知道应用程序和数据库（即MongoDB）之间的通信可能会存在一些挑战，因为应用程序和数据库都在单独的容器中，可能在单独的网络中。为了解决这种问题，您可以创建一个网络，并将两个容器连接到该网络。
- en: 'For instance, if we have to do so for our container (`myapp` and `mongodb`),
    we will follow these steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，如果我们需要为我们的容器（`myapp`和`mongodb`）这样做，我们将按照以下步骤进行：
- en: 'Use the following command to create a separate network:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个单独的网络：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that our network is created, we can add both containers to this network
    using the following commands:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In order to find the IP that is assigned to these containers, we can use the
    following commands:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This network creation is an alternative way to set up the communication between
    application and database.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Alright, we have deployed our application on Docker and learned its different
    concepts. The only concept that is left is Docker Compose. Let's understand what
    it is and how different it is from the others.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As per the official Docker Compose website ([https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)),
    Compose is a tool for defining and running multicontainer Docker applications.
    With Compose, you use a Compose file to configure your application's services.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: In simpler terms, it helps us build and run our application in a much simpler
    and faster way.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, where we were deploying our application and building
    the images, we first created a Dockerfile and then executed the `Docker build`
    command to build it. Once it is built, we usually use the `docker run` command
    to spin up the container, but, instead of that, in Docker Compose, we will define
    a `.yml` file with config details, such as ports, command to execute, and so on.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, Docker Compose is a separate utility from Docker Engine and can be
    installed using the following link, based on the type of OS you are working on:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '`https://docs.docker.com/compose/install/`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Once you have installed it, let's see how we can use Docker Compose to run our
    containers. Let's assume we have to run the cloud native application container
    using Docker Compose. We already have the Dockerfile generated for it, and we
    also have the application at the same location (path).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, using the following content, we will need to create a `Docker-compose.yml`
    file in the same location where the Dockerfile is present:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once you have added the config in `docker-compose.yml`, save it and execute
    the `docker-compose up` command. After building the image, we will see the following
    output:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00156.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: 'Also, if you see the container''s state, you will find multiple containers
    (in our case, `app_web-1` and `app_flask_1`) spin by compose, which is why it
    is useful for mutlicontainer applications that need large-scale infrastructure,
    as it creates a cluster of Docker machines similar to the Docker Swarm. The following
    screen shows the status of the Docker machine:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00157.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: Awesome! We have deployed our application through Docker-compose as well. Now
    you can try to access the public URL for the application ([http://your-ip-address:5000](http://your-ip-address:5000))
    to confirm the successful application deployment.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, make sure you push your images to the Docker Hub to keep it in a centralized
    repository. Since we have already pushed the MongoDB images, use the following
    command to push the `cloud-native-app` image as well:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We should see similar output for, Docker `push` command as shown:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00158.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first looked at one of the most interesting technologies--Docker--,
    which is based on containers. We looked at the different concepts around Docker,
    and we already deployed our application and looked at the way we can manage it
    over Docker. We also explored multiple ways to deploy our application using Docker
    Compose and Dockerfile.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, things will be a lot more interesting as we will finally
    reach a stage where we will be exposed to the cloud platform, build our infrastructure
    over the platform based on our application, and also try to deploy it as well.
    So, stay tuned for the next chapter! See you there.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
