- en: Chapter 5. Working with Renderers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Renderers provide us with a medium to visualize data intuitively using different
    symbols and colors. More than a data visualization technique, renderers are increasingly
    considered as a data analytic tool. The correct use of renderers will help us
    see spatial patterns in the data and display the geographic distribution of various
    phenomena. An understanding of basic cartography, color theory, and even statistics
    will help us create better renderers and eventually better insights into the available
    data. The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about different symbols and colors provided by the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to create a `SimpleRenderer` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to create a `UniqueValueRenderer` method efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning when to use `ClassBreakRenderer` and `HeatmapRenderers`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing scenarios where `ScaleDependantRenderers` can be useful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to smart mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Esri module dealing with colors is called `esri/Color`. Before dealing with
    the color module, let's have a fundamental understanding of colors.
  prefs: []
  type: TYPE_NORMAL
- en: The RGB color model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any color in the visible spectrum (the range of colors between Violet to Red),
    can be represented using a combination of Red (R), Green (G) or Blue (B) colors.
    This is known as the **RGB color model**. There are other color models too, but
    let's stick with the RGB color model for now. And each color R, G, or B can be
    expressed in a scale from 0 to 255\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following picture shows the relationship between the three primary colors
    (R, G, and B) and their additive effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The RGB color model](graphics/B04959_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the three colors (R, G, and B) are mixed in equal proportion, the resultant
    color always lies somewhere in the grey scale. The following points are worth
    noting:'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the level of `R = 0`, `G = 0`, and `B = 0`, the mixture produces
    black.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `R = 255`, `G = 255`, and `B = 255`, the mixture produces white.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other number values, when mixed equally, produce a shade of grey.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if `R = 125`, `G = 125`, and `B = 125`, it will be grey.
  prefs: []
  type: TYPE_NORMAL
- en: The color model also shows that when Red and Green are mixed together (`R =
    255`, `G = 255`, and `B = 0`), we get yellow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Red and Blue alone are mixed (`R=255`, `G= 0`, and `B=255`), we get Magenta.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Green and Blue are mixed, we get Cyan (`R=0`, `G=255`, and `B= 255`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Esri color module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define a color using the RGB color model, the following format can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, `color` is an instance of the `esri/Color` module
    and `r`, `g`, and `b` are values for Red, Green, and Blue respectively. The colors
    should always be ordered as (`r`, `g`, and `b`) and added as an array object.
    As expected, the `color` variable stores a grey color. If we need to add transparency
    to the color, we can define the transparency value known as `alpha`, which is
    an integer between `0` and `1.0`, where `0` represents full transparency and `1.0`
    represents no transparency. The alpha value will be added as the fourth value
    in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The RGB values can be represented as a hexadecimal number. For example, `[255,
    0, 0]` can be represented as `#FF0000`. The API also allows us to represent the
    color by its English named string, for example, `blue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Working with symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Symbols are based on the geometry that they try to symbolize. Thus, the symbols
    used to represent a point, line, and polygon are different from each other. Apart
    from the geometry, the three important parameters required to define a symbol
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dimension (or size)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The style is usually provided as a module constant. For example, `SimpleLineSymbol.STYLE_DASHDOT`,
    `SimpleFillSymbol.STYLE_SOLID`, and `SimpleMarkerSymbol.STYLE_CIRCLE` where `SimpleLineSymbol`,
    `SimpleFillSymbol`, and `SimpleMarkerSymbol` are the modules used to symbolize
    the line, polygon, and point features respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: The colors of these symbols can be defined by the color modules that we discussed
    in earlier sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dimension or size means different things based on the geometry type. For
    example, for a line symbol, we use the parameter known as `width` to refer to
    the line thickness, whereas for a point, we use the parameter named `size` to
    define its dimension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss about the three geometry-based symbols first, and then we will
    deal with the non-geometry-based and special symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'The geometry-based symbols are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SimpleLineSymbol`: This is used to symbolize the line geometry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleMarkerSymbol`: This is used to symbolize the point geometry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpelFillSymbol`: This is used to symbolize the polygon geometry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SimpleLineSymbol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The line symbol constructor is the simplest, because it can be defined with
    just three parameters namely style, color, and width.
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Module name | `esri/symbols/SimpleLineSymbol` |'
  prefs: []
  type: TYPE_TB
- en: '| Constructor | `new SimpleLineSymbol(style, color, and width)` |'
  prefs: []
  type: TYPE_TB
- en: 'The `style` is a module constant. The following styles are provided by the
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`STYLE_DASH` (to create lines made of dashes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STYLE_DASHDOT` (to create lines made of a dash-dot pattern)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STYLE_DOT` (to create lines made of dots)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module provides other style constants such as `STYLE_LONGDASH`, `STYLE_LONGDASHDOT`,
    `STYLE_NULL`, `STYLE_SHORTDASH`, `STYLE_SHORTDASHDOT`, `STYLE_SHORTDASHDOTDOT`,
    `STYLE_SHORTDOT`, and `STYLE_SOLID`.
  prefs: []
  type: TYPE_NORMAL
- en: '`STYLE_SOLID` is the default style, which provides an uninterrupted solid line.'
  prefs: []
  type: TYPE_NORMAL
- en: We can set the color of the line using the `simpleLineSymbol.setColor(color)`
    method; here, `color` is Esri `Color` object, and `simpleLineSymbol` is an instance
    of `SimpleLineSymbol` object. The `style` constant can be set using the `setStyle(style)`
    method. `SimpleLineSymbol.toJson()` is an important method that converts a `SimpleLineSymbol`
    to an ArcGIS Server JSON representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet will create a solid red line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: SimpleMarkerSymbol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SimpleMarkerSymbol` method is used to symbolize a point. Symbolizing a
    point geometry has an extra layer of complexity than symbolizing a line in that
    it accepts an outline parameter which in itself is a `SimpleLineSymbol` object.
  prefs: []
  type: TYPE_NORMAL
- en: '![SimpleMarkerSymbol](graphics/B04959_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| Name | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Module name | `esri/symbols/SimpleMarkerSymbol` |'
  prefs: []
  type: TYPE_TB
- en: '| Constructor: | `new SimpleMarkerSymbol(style, size, outline, color)` |'
  prefs: []
  type: TYPE_TB
- en: 'The following style constants are provided by the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`STYLE_CIRCLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STYLE_DIAMOND`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STYLE_SQUARE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setAngle(angle)` method rotates the symbol clockwise around its center
    by a specified angle. The `setColor(color)` method sets the symbol `color`. `setOffset`
    (`x` and `y`) sets the `x` and `y` offsets of a marker in screen units. `setOutline(outline)`
    sets the outline of the marker symbol. `setSize(size)` lets us set the size of
    a marker in pixels. `setStyle(style)` sets the marker symbol style. `toJson()`
    converts objects into their ArcGIS Server JSON representation.
  prefs: []
  type: TYPE_NORMAL
- en: ArcGIS symbol playground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If selecting the appropriate color and style and other properties for a symbol
    seemed like a difficult choice, the following web page tries to help you out by
    providing a sandbox to generate any type of symbol and the code required to define
    a similar symbol in your code. The webpage is at [http://developers.arcgis.com/javascript/samples/playground/index.html](http://developers.arcgis.com/javascript/samples/playground/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigating to this URL will land you in a page similar to the following screenshot.
    We can select almost any type of symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ArcGIS symbol playground](graphics/B04959_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting one of them will navigate you to another page where you can select
    the properties and generate the symbology code.
  prefs: []
  type: TYPE_NORMAL
- en: '![ArcGIS symbol playground](graphics/B04959_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, we easily generated the code required to generate a semi-transparent,
    red-colored, diamond-shaped `SimpleMarkerSymbol` (with no outline):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: SimpleFillSymbol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SimpleFillSymbol` module helps us generate symbology for polygons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Module name: `esri/symbols/SimpleFillSymbol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new SimpleFillSymbol(style, outline, color)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the module constants for the `STYLE` parameter are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`STYLE_BACKWARD_DIAGONAL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STYLE_CROSS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STYLE_NULL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleFillSymbol.STYLE_SOLID` is the default styling.'
  prefs: []
  type: TYPE_NORMAL
- en: PictureMarkerSymbol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we need to picture an icon to symbolize a point geometry, we can use this
    module. Instead of providing the color information as a parameter, we need an
    image URL to display a picture as a marker symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Module | `esri/symbols/PictureMarkerSymbol` |'
  prefs: []
  type: TYPE_TB
- en: '| Constructor | `new PictureMarkerSymbol(url, width, height)` |'
  prefs: []
  type: TYPE_TB
- en: Searching for the appropriate `PictureMarkerSymbol` is aided by a web page found
    at [http://developers.arcgis.com/javascript/samples/portal_symbols/index.html](http://developers.arcgis.com/javascript/samples/portal_symbols/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to this URL will open a page as shown next. When a picture icon is
    selected, a code is generated below. This code can be reused to recreate `PictureMarkerSymbology`
    as the one selected in the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated code is a JSON representation of `PictureMarkerSymbol`. The JSON
    object provides the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`angle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xoffset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yoffset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contentType`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imageData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among these, `imageData` and `url` are redundant, so we can avoid the `imageData`
    property, if we can use the URL property. The `imageData` property is just the
    `Base64` representation of the image. To avoid this, we can uncheck a box at the
    top-right corner of the web page, which reads something like **Enable Base64 encoding**.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if the values for `angle`, `xoffset`, and `yoffset` are 0, we can omit
    these too.
  prefs: []
  type: TYPE_NORMAL
- en: '![PictureMarkerSymbol](graphics/B04959_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the URL of the icon provided by this web page and in ArcGIS Symbol Playground
    will enable us to further customize `PictureMarkerSymbol`.
  prefs: []
  type: TYPE_NORMAL
- en: '![PictureMarkerSymbol](graphics/B04959_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To customize `PictureMakerSymbol` use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: PictureFillSymbol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PictureFillSymbol` goes a step further and lets us fill a polygon geometry
    with an image.'
  prefs: []
  type: TYPE_NORMAL
- en: '![PictureFillSymbol](graphics/B04959_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: TextSymbol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Text symbols can be generated in lieu of labels. Text symbols lack geometry,
    so it needs to be attached to geometry.
  prefs: []
  type: TYPE_NORMAL
- en: '![TextSymbol](graphics/B04959_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following snippet generated from ArcGIS Symbol Playground demonstrates
    the components of generating `TextSymbol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Working with renderers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an application uses layers that are referenced from a web map or a GIS
    service, the web map or service itself provides default drawing properties that
    determine how the layer will be drawn. A developer can choose to override this
    behavior by working with colors, symbols, and renderers to change and enhance
    how the features are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `setSymbol()` method to apply a symbol to a single graphic.
    When you want to apply symbology to all the graphics in a dynamic, feature, or
    a graphics layer, you can use a renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Renderers make it easy to symbolize many features quickly, using either a single
    symbol or multiple symbols based on attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several of the renderers available in the ArcGIS API for JavaScript are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SimpleRenderer`: This applies the same symbol to all the graphics in a layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UniqueValueRenderer`: This applies specific symbols based on the unique attribute
    values of each graphic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClassBreaksRenderer`: This applies the symbols of different sizes or colors
    based on the ranges of attribute values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DotDensityRenderer`: This shows the variation in the spatial density of a
    discrete spatial phenomenon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HeatmapRenderer`: This converts point data into a raster display that shows
    the high density or weighted areas of concentration using a blur radius and the
    intensity value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TemporalRenderer`: This visualizes real-time or historic observations in the
    current extent of the map, factoring in relative feature aging and tracks along
    which observed incidents occur, such as a hurricane'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScaleDependentRenderer`: This applies different renderers to the same layer
    based on the current scale of the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a renderer for a scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The symbols and renderers guide in the API documentation provides a great guide
    on using symbols and renderers. The documentation can be accessed at [https://developers.arcgis.com/javascript/jshelp/inside_renderers.html](https://developers.arcgis.com/javascript/jshelp/inside_renderers.html).
  prefs: []
  type: TYPE_NORMAL
- en: '`UniqueValueRenderer` and `ClassBreaksRenderer` are attribute-based renderers.
    This means that attribute values determine how the features are symbolized. To
    determine whether to use `UniqueValueRenderer` or `ClassBreaksRenderer` in a given
    situation, consider the nature of the field values upon which the categorization
    needs to be performed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the set of unique values over the field to be rendered is small and discrete,
    consider using `UniqueValueRenderer`.
  prefs: []
  type: TYPE_NORMAL
- en: If the set of unique values over the field to be rendered has a vast range and/or
    is continuous, consider using `ClassBreaksRenderer`.
  prefs: []
  type: TYPE_NORMAL
- en: '`UniqueValueRenderer` and `ClassBreaksRenderer` have the `defaultSymbol` property
    that gets used when a value or break cannot be matched. During development, you
    can use a default symbol with a high-contrast color to quickly verify whether
    any feature has failed to match the renderer''s criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: Developing a Stream Gauge application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be developing a Stream Gauge app to demonstrate how to use the following
    renderers:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique value renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class breaks renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heatmap renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Stream Gauge data is provide by Esri as part of their Living Atlas of the
    World portal. This means that we need to have an ArcGIS Developer login to access
    the content. The URL to the Mapservice for the Stream Gauge data is [http://livefeeds.arcgis.com/arcgis/rest/services/LiveFeeds/StreamGauge/MapServer/](http://livefeeds.arcgis.com/arcgis/rest/services/LiveFeeds/StreamGauge/MapServer/).
  prefs: []
  type: TYPE_NORMAL
- en: The map service provides the readings of Stream Gauges around the United States,
    which depict the current water level in the measured areas. The application we
    are trying to develop endeavors to demonstrate different rendering techniques
    over the Gauge data. The upcoming snapshot in the next section provides a rough
    rendition of our final application that we will have developed by the end of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have an ArcGIS Developer account, refer to [Chapter 3](ch03.html
    "Chapter 3. Writing Queries"), *Writing Queries*, for instructions on how to register
    an account and use the credentials in the application proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Simple renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simple renderer is provided by the `esri/renderers/SimpleRenderer` module, and
    its constructor accepts any appropriate symbol or a JSON. Since all the Gauge
    locations are point locations, we will use `SimpleMarkerSymbol` to symbolize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have already discussed how to construct a `PictureMarkerSymbol` from
    its corresponding module, we will see how to use the JSON form of the symbol.
    Using the JSON representation of the symbol means that we no longer need to load
    the modules separately for each symbol and color. The following snapshot shows
    how JSON is formed and used in the `SimpleRenderer` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple renderer](graphics/B04959_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code, after the renderer is assigned with `SimpleRenderer`,
    the renderer object must be set to the feature layer by using the `setRenderer()`
    method. Also, the legend should be refreshed once the rendering is applied to
    the feature layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Applying unique value renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unique value renderer is provided by the `esri/renderers/UniqueValueRenderer`
    module. Unique value renderer lets us define different symbols for a set of unique
    values in the data. Up to three attribute fields can be provided to determine
    the uniqueness of the data. Unique value renderer expects the `uniqueValueInfos`
    object. This object is basically a mapping between the unique value and the symbol
    that is used to represent the value. Therefore, all the features with a specific
    value will be rendered by the corresponding mapped symbol. We can provide the
    `defaultSymbol` object to the renderer that will be used to symbolize any value
    that is not defined in the `uniqueValueInfos` object. The following is a JSON
    representation of a unique value renderer object symbolizing unique values of
    flood stages. The unique values for flood stages that we symbolize are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`major`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`moderate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code renders in the app as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying unique value renderer](graphics/B04959_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following properties can be used with feature layers to render it based
    on multiple visual properties, such as `color`, `rotation`, `size`, and `opacity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Renderer method | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `setColorInfo()` | This shows an array of continuous values using a color
    ramp |'
  prefs: []
  type: TYPE_TB
- en: '| `setRotationInfo()` | This rotates a symbol to indicate variance in direction
    (for example, a traveling vehicle or a hurricane event) |'
  prefs: []
  type: TYPE_TB
- en: '| `setSizeInfo()` | This changes the symbol size or width based on a range
    of data values |'
  prefs: []
  type: TYPE_TB
- en: '| `setOpacityInfo` | This changes the alpha values used to display a layer
    |'
  prefs: []
  type: TYPE_TB
- en: Class breaks renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the field is classified and visually differentiated it is spread over a
    range of values, we can use `ClassBreaksRenderer`. `ClassBreaksRenderer` can be
    used by loading the `esri/renderers/ClassBreaksRenderer` module.
  prefs: []
  type: TYPE_NORMAL
- en: Class break renderer is very similar to unique value renderer in that the constructor
    for Class break renderer expects a `classBreakInfos` object, which is similar
    to the `uniqueValueInfos` object.
  prefs: []
  type: TYPE_NORMAL
- en: '`classBreakInfos` is an array of `classBreakInfo` objects, which maps between
    a class range and a symbol. A class range is defined by the class'' minimum (`classMinValue`)
    and the class'' maximum (`classMaxValue`).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Class breaks renderer](graphics/B04959_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following snapshot shows how the `ClassBreakRenderer` JSON object is constructed
    with the `classBreakInfo` array and rendered on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Class breaks renderer](graphics/B04959_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: HeatmapRenderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`HeatmapRenderer` renders point data into a raster visualization that emphasizes
    areas of higher density or weighted values. This renderer normal distribution
    curve to spread value out in vertical and horizontal directions.'
  prefs: []
  type: TYPE_NORMAL
- en: This averaging function is applied horizontally and vertically to produce a
    blurred area of influence instead of a single specific point.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `HeatmapRenderer` module constructor accepts an array of colors. The first
    color is used to represent areas with *least influence*, and the last color in
    the array is used to represent pixels with the highest influence. We can also
    define other parameters for the `HeatmapRenderer` constructor such as `blurRadius`,
    the maximum pixel intensity, and the minimum pixel intensity. The following snapshot
    of the code is used to generate a `HeatmapRenderer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HeatmapRenderer](graphics/B04959_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: DotDensityRenderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DotDensityRenderer` provides the ability to create dot density visualizations
    of the data. A dot density map can be used to visualize the variation in the spatial
    density of a discrete spatial phenomenon. We can use multiple fields to visualize
    multiple variables on one map with different colors. For example, we can use different
    colors to show the distribution of various ethnic groups. The density on the map
    always changes as the user zooms in or out. Use `ScaleDependentRenderer` to set
    a unique-dot density renderer for each scale or zoom range, so `dotValue` and
    `dotSize` can vary across multiple scale ranges.'
  prefs: []
  type: TYPE_NORMAL
- en: BlendRenderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem with `ClassBreakRenderer` or `UniqueValueRenderer` is that you have
    to assign a specific color to any given value. When assigning discrete colors
    based on clear boundary values isn't desirable, we can use `BlendRenderer`.
  prefs: []
  type: TYPE_NORMAL
- en: '`BlendRenderer` lets you do a fuzzy classification of data. It lets you assign
    different colors for values from different fields and use some opacity to represent
    the magnitude of the value. The final rendering will be a blend of these colors
    since we are using opacity for each field. This diagram shows how color and opacity
    variables can be blended to provide a rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![BlendRenderer](graphics/B04959_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following map shows a map of predominant minority groups throughout the
    United States. Such illustrations give a sense of predominant features while not
    completely suppressing other details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![BlendRenderer](graphics/B04959_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SmartMapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SmartMapping` module provides a lot of helper methods that help us choose
    the best rendering method. The following illustration shows a list of methods
    available with the `SmartMapping` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SmartMapping](graphics/B04959_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Smart Mapping Module: `esri/renderers/smartMapping`'
  prefs: []
  type: TYPE_NORMAL
- en: A classification method for classed renderers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The classed renderer helper methods, such as `createClassedColorRenderer()`
    and `createClassedSizeRenderer()`, need `classificationMethod` as a parameter.
    Choosing this value is quite important if we need to understand the significance
    of each.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following classification methods are available:'
  prefs: []
  type: TYPE_NORMAL
- en: equal-interval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: natural-breaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: quantile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: standard-deviation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default method is equal-interval.
  prefs: []
  type: TYPE_NORMAL
- en: Equal interval classification divides the data equally into a predefined number
    of classes. Such a classification might not necessarily reflect the skewness in
    the data. For example, if the data range is from 0-1 million, and the majority
    of the data is concentrated between 300,000-500,000, then instead of classifying
    the data between 0-250,000, 250,000-500,000, 500,000-750,000, and 750,000-1,000,000,
    it would be a better classification scheme if there were a greater number of classification
    ranges between 300,000-500,000.
  prefs: []
  type: TYPE_NORMAL
- en: Classification methods such as natural-breaks, quintile, and standard deviation
    help to segregate the data better; hence, our data visualization technique would
    be statistically much accurate. This topic will be discussed in greater detail
    in [Chapter 7](ch07.html "Chapter 7. Map Analytics and Visualization Techniques"),
    *Map Analytics and Visualization Techniques*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter gives an in-depth treatment on the topic of colors, symbols, renderers,
    and the situations where each can be used effectively. This chapter also dealt
    with the nuances of data visualization techniques along with tips and tricks to
    create symbols and picture marker symbols easily. We demonstrated the utility
    of three basic renderers: simple renderer, unique value renderer, and class breaks
    renderer by developing a Stream Gauge app. In the following chapters, we will
    be dealing with advanced visualization techniques to visually classify data on
    spatial as well as temporal scales.'
  prefs: []
  type: TYPE_NORMAL
