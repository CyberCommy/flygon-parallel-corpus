- en: Model-View-Controller Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will dive into one of the most common architectural patterns
    used by frameworks today.
  prefs: []
  type: TYPE_NORMAL
- en: The **Model-View-Controller** (**MVC**) architectural pattern was formulated
    in 1979 by Trygve Reenskaug. This was one of the first attempts to create an organized
    method for working on graphical user interfaces. Although many years have passed
    since then, this pattern continues to be quite popular even in the most modern
    UI frameworks. This is because it is designed to build almost any type of application,
    including the most common types of applications, such as mobile, desktop, and
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: The popularity of this pattern mostly comes down to the ease of understanding
    it. MVC provides an excellent way to separate applications into three different
    components, which we will review in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of MVC:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of using MVC architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing applications using MVC:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UI frameworks: Thymeleaf'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Securing an MVC application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP and HTTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of supporting the MVC pattern was developed as a part of Trygve Reenskaug''s
    research in which he concluded the following key idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '"MVC was conceived as a general solution to the problem of users controlling
    a large and complex data set. The hardest part was to hit upon good names for
    the different architectural components. Model-View-editor was the first set. "'
  prefs: []
  type: TYPE_NORMAL
- en: – [http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html](http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the biggest problems in computer science is related to naming things,
    which is why the original name was Model-View-Editor. It later evolved into MVC,
    as mentioned in the preceding link:'
  prefs: []
  type: TYPE_NORMAL
- en: '"After long discussions, particularly with Adele Goldberg, we ended with the
    terms Model-View-Controller."'
  prefs: []
  type: TYPE_NORMAL
- en: MVC is a software architectural pattern that makes it possible to establish
    a clear separation between the domain objects of an application (where the business
    logic resides) and the elements that are used to build the UI.
  prefs: []
  type: TYPE_NORMAL
- en: With this concept in mind, the isolation and separation of concerns between
    these parts are quite important. They also constitute the underlying principles
    to build applications using this pattern. In following sections, let's review
    how the business logic and presentation layer of an application fits within the
    MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Model (M)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this context, the **Model** represents the domain objects needed to express
    the business logic supporting the requirements inherent to the application. It's
    here that all of the use cases are represented as real-world abstractions and
    a well-defined API is made available to be consumed by any kind of delivery mechanism,
    such as the web.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding traditional applications, all of the logic to interact with a database
    or middleware is implemented in the Model. However, the Model (the M in MVC) should
    expose functionalities (in terms of the business) that are easy to understand.
    We should also avoid building anemic models that only allow for interacting with
    the database and are difficult to understand for the rest of the team working
    on the project.
  prefs: []
  type: TYPE_NORMAL
- en: Once this part of the application has been coded, we should ideally be able
    to create any UI that allows the users to interact with the Model. Furthermore, since
    UIs can defer from each other (mobile, web, and desktop apps), the Model should
    be agnostic to all of them.
  prefs: []
  type: TYPE_NORMAL
- en: In a perfect world, an isolated team would be able to build this part of the
    application, but in real life, this assumption is entirely wrong. Interaction
    with the team in charge of building the GUI is required, in order to create an
    effective Model that is able to address all of the business requirements and expose
    a comprehensive API.
  prefs: []
  type: TYPE_NORMAL
- en: The View (V)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **View** is a visual representation of the Model (M in MVC) but with some
    subtle differences. As a part of these differences, the View tends to remove,
    add, and/or transform specific Model attributes, with the aim of making the Model
    understandable for the users interacting with the View.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Model is sometimes complex, many views can be used to represent one
    part of it, and, conversely, many parts of the Model can be included as only one
    part of the View.
  prefs: []
  type: TYPE_NORMAL
- en: The Controller (C)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Controller** is a link between the end user of an application and the business
    logic implemented by the Model. Controllers are objects in charge of taking user
    input and figuring out what part of the Model should be invoked to achieve defined
    business goals. As a result of this interaction, the Model is often changed, and
    these changes should be propagated to the views using Controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Direct communication between the View and the Model must never happen since
    it constitutes a violation of how this pattern works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping the preceding tip in mind, all communication should be done in a specific
    order from each part of the MVC pattern, passing the information from the View
    to the Controller and from the Controller to the Model, and never directly from
    the Model to the View, as illustrated in the following interaction diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0396a5e1-c22c-4a1b-8c43-23e0f91f3043.png)'
  prefs: []
  type: TYPE_IMG
- en: MVC interaction diagram
  prefs: []
  type: TYPE_NORMAL
- en: In order to propagate these changes, the View elements are bound to representations
    in the Controllers, which makes it possible to manipulate them as required. The
    process of updating a View occurs when the Model is updated, and it often involves
    reloading data or hiding/showing certain elements in the View.
  prefs: []
  type: TYPE_NORMAL
- en: When a change should be propagated to more than one element in the View, various
    Controllers can work together collaboratively to achieve the goal. In these cases,
    a simple implementation of the observer design pattern can often be useful for
    avoiding entangled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a graphical representation of how the pieces in this
    pattern are arranged, in either the presentation or business logic layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b43675b9-a457-4b7c-a7ea-498fd0ead679.png)'
  prefs: []
  type: TYPE_IMG
- en: MVC graphical representation
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of using MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MVC provides many benefits for applications that are implemented using it; the
    main benefit is the clear separation of concerns, with a single responsibility
    for each part of the application, thereby avoiding messing up the code and making
    the code easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Controllers and views are tied together to build the visual representation
    of the application using MVC, the Model is absolutely isolated. This makes it
    possible to reuse the same Model to create a different kind of application, including,
    but not limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might be tempted to conclude that a project developed using this Model can
    count on teams working in parallel, but separately, during the development phase,
    which is true in some cases, but not a rule in general. As mentioned previously,
    effective communication across teams is still necessary for building the application
    as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Common pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we work on applications using MVC, it''s common to find projects structured
    following the MVC acronym, as the following diagram illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dad7ede6-b98c-4094-b684-939f57a30d17.png)'
  prefs: []
  type: TYPE_IMG
- en: MVC project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'This directory structure indicates the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The project name is **abc-web**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application uses the MVC architecture (structure)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, none of these points provide meaningful information for the team
    in charge of creating or maintaining an application. That is because a team working
    on a project is not interested in the file organization. Instead, it's much more
    useful to organize your code according to business rules, use cases, or other
    factors related to the business itself, rather than the technical aspects.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this idea in mind, we will suggest that a much more useful directory structure
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98cc2f43-58d8-4774-ba84-3624b3095bf4.png)'
  prefs: []
  type: TYPE_IMG
- en: Understandable project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'From this diagram, we can infer the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: This is an **accounting** system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main features of the project are related to the following, and more:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Income
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the project layout shown in the preceding diagram, if we are tasked with
    fixing a report that is no longer working, we can think about reviewing the reporting
    folder. This approach is helpful for reducing the amount of time and effort required
    to accomplish project tasks.
  prefs: []
  type: TYPE_NORMAL
- en: We can conclude that the information provided by the second project structure
    is much more useful and practical, in comparison to the first one, since the first
    one does not provide information regarding the business at all.
  prefs: []
  type: TYPE_NORMAL
- en: Every single part of the project should communicate information regarding the
    business, rather than concerning the delivery mechanism or pattern used.
  prefs: []
  type: TYPE_NORMAL
- en: 'These details are small, but they are essential. At the beginning of this book,
    we mentioned that a good architecture is built around business requirements, and
    any goal that an architecture pursues should be understood by the whole team.
    We should approach every single detail with an aim to achieve this goal. Remember:
    details matter.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing applications using MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand the theory behind MVC architectures, it is time to put
    the concepts that you have learned into practice and to see how the Spring Framework
    implements them. We are going to start by reviewing Spring MVC, which is the project
    that allows us to achieve this architectural style.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides support for the MVC architectural pattern through Spring MVC.
    This Spring project allows for incorporating a vast set of UI frameworks, in order
    to build forms and related components that will enable users to interact with
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC is built on top of the servlet API, which is designed to create web
    applications. There is no way to create a desktop, or any other kind of application,
    using this. Even though the MVC architectural pattern can be applied to all of
    them, Spring MVC is only focused on the web.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC is formally known as Spring Web MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the large number of View technologies supported by Spring MVC, the
    one most commonly used tends to be Thymeleaf, because of its smooth integration.
    However, you can also use another framework, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: JSF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FreeMarker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Struts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring MVC is designed around the front-Controller pattern, which relies on
    a single object to handle all of the incoming requests and provide the respective
    responses. In the case of Spring MVC, this object is represented by a `Servlet`
    implemented by the `org.springframework.web.servlet.DispatcherServlet` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `Servlet` is in charge of delegating the requests to the Controllers and
    rendering the corresponding page on the screen, with the desired data. The following
    diagram shows how `DispatcherServlet` processes the requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b206a811-4848-457e-9e13-199f9655a0ec.png)'
  prefs: []
  type: TYPE_IMG
- en: DispatcherServlet request processing
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see that Controller is a Java class and **View**
    is an HTML file. In the latter case, we can also use any `tag-library/template-engine` tag
    that will later be compiled as HTML code that is rendered in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Controller in Spring is created using the `@Controller` annotation over the
    class name, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the class is marked as a Controller, we need to indicate what request
    mapping will be handled, and what actions need to be executed as a part of the
    request processing. In order to support this functionality, we need to write a
    simple method using the `@RequestMapping` annotation, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding method handles the incoming request from the `/ABC` path**,**
    and, once the processing is done, a `ui-template`is provided, to be rendered on
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: This operation is done by Spring MVC using View resolvers, which will look to
    render a file with the name `ui-template.html`. You can also write custom resolvers
    to add suffixes or prefixes to your views, if required.
  prefs: []
  type: TYPE_NORMAL
- en: When we need to pass data from the Controller to the View, we can use the `Model`
    object, enabled by Spring View resolvers. This object can be populated with any
    data that you want to use in your views. In the same way, when the user submits
    data from the views, this object is populated with the entered information, which
    the Controllers can use to perform any desired logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to send data from the Controller to the View, we need to include the
    `Model` object as an argument in the method that handles the request, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'All templates have the ability to read the attributes passed from the Controller
    using the `${...}` syntax, known as expression language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you want to pass data from View components to the Controller,
    you have to populate an object in the View (using a form, for example), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the object fields are populated and the submit button is pressed, the
    request will be sent, so that we can declare a method to handle the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you may have noticed that we are using `@ModelAttribute` to capture
    the data that was sent in the request.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is crucial to our applications. When we use Spring MVC, we can count
    on the `spring-test` module to add support for unit and integration tests that
    are context-aware, which means that we can rely on annotations to wire dependencies.
    We can also use the `@Autowired` annotation to test a specific component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how simple it is to write a test that is context-aware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review the code in bold, in order to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two annotations do all of the work for us; they will allow running
    our tests inside of a servlet container, and the Spring Boot annotations used
    for testing will wire all of the classes in the same way as the code running in
    production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we added the previously mentioned annotations, we can now wire the components
    that we want to test using the `@Autowired` annotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code validates that the class being tested has been successfully instantiated,
    and is ready to be used. This also means that all of the dependencies in the class
    have been successfully wired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an easy way to test code that has to interact with databases, message
    broker servers, or any other middleware. The approach used to validate interactions
    with a database server uses an in-memory database, such as H2, for traditional
    SQL databases such as PostgreSQL or MySQL; there are also options for NoSQL databases,
    such as an embedded Cassandra or Mongo.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when you need to test integrations with other third-party
    software, an excellent approach to keep in mind is the use of sandboxes. A sandbox
    is an environment that is similar to the production environment, provided to software
    vendors for testing purposes. These sandboxes are often deployed in production,
    but they also have some restrictions. For example, operations related to payments
    are not processed in the last stage.
  prefs: []
  type: TYPE_NORMAL
- en: This testing approach is useful when you don't have any way to deploy applications
    in your own environments, but of course, you will need to test whether the integrations
    are working with your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that you are building an application that has integration with
    Facebook. In this case, it's evident that no change is required in order to deploy
    a Facebook instance in your own staging area for testing purposes. This is a perfect
    example of when a sandbox environment is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that sandboxes test integrations using third-party software. If
    you're a software vendor, you need to consider providing sandboxes that allow
    your customers to try your products in a testing mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring MVC Test also has a fluent API that makes it possible to write highly
    expressive tests. This framework provides a `MockMvc` object that can be used
    to simulate end-user requests and then validate the provided responses. Common
    use cases include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating HTTP code statuses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying expected content in the responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL redirection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet uses the `MockMvc` object to test the previously
    described examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly review the code in bold, in order to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AutoConfigureMockMvc` annotation generates all of the required plumbing
    code to use the `MockMvc` object in the tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MockMvc` object is autowired and ready to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fluent API provided by `MockMvc` is used to validate the expected status
    code from the response. We are also testing a simple redirection, as well as the
    content expected on the page once the redirection is done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we discuss tests, it's quite common to hear the term **test coverage.**
    This is a measure used to check how much code is being executed by the suite tests,
    and it's helpful for determining what alternative paths of code are not tested
    and are hence prone to bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that you are writing a method that has an `if` statement. In that
    case, your code has two alternative paths to follow; so, if you want to achieve
    100% coverage, you will need to write tests to validate all of the alternative
    routes that your code can follow.
  prefs: []
  type: TYPE_NORMAL
- en: There are many useful libraries available for measuring the coverage that code
    has. In this chapter, we are going to introduce one of the most popular libraries
    in the Java world; the library is called JaCoCo ([http://www.eclemma.org/jacoco/](http://www.eclemma.org/jacoco/)).
  prefs: []
  type: TYPE_NORMAL
- en: In order to make JaCoCo a part of our application, we need to include it as
    a plugin, using our preferred build tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the required configuration to include JaCoCo using Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the required configuration to include JaCoCo using Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once JaCoCo has been included as a part of the project, we will have new tasks
    that can be used to measure the coverage of our code. Let''s generate a coverage
    report by executing the following Gradle task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The coverage report that is generated will be available in HTML format, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f775fbe3-e0a6-4894-82eb-af5a787e702f.png)'
  prefs: []
  type: TYPE_IMG
- en: JaCoCo report
  prefs: []
  type: TYPE_NORMAL
- en: Although it is true that we want to achieve high coverage for our code, we need
    to be careful with what kinds of tests we are writing because, with this approach
    in mind, we may be tempted to write useless tests, just to achieve 100% coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fully understand what I''m talking about here, let''s review the report
    generated by JaCoCo for one of the classes in the domain package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9caf22ac-ecd6-4807-84a1-0bf87ae0062d.png)'
  prefs: []
  type: TYPE_IMG
- en: Test coverage report for a domain class
  prefs: []
  type: TYPE_NORMAL
- en: The report shows that there are no tests at all for some methods. Some of these
    methods are standard for any Java object, and the others are only getters and
    setters (accessors), which do not need to be tested. Writing getters and setters
    often leads to building anemic domain models, and, most of the time, this is only
    used to make the code compatible with frameworks relying on the Java Beans convention.
    For this reason, there is no need to write tests to cover getters and setters.
  prefs: []
  type: TYPE_NORMAL
- en: I have seen people writing tests for these methods only to achieve 100% coverage,
    but that is a useless and impractical procedure that should be avoided, as it
    doesn't add any value to the quality of the code or the written tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s review the report for one of the classes that has some logic worth
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/beb5e7a9-44a0-4193-90c2-eb28d15de1ba.png)'
  prefs: []
  type: TYPE_IMG
- en: JaCoCo coverage report for a service class
  prefs: []
  type: TYPE_NORMAL
- en: 'Surprisingly, this class has 100% coverage. Let''s review the associated tests
    for this class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We cannot always achieve 100% coverage, as we did in this example. However,
    a good measure tends to be 80%. You must think of the previously mentioned percentage
    not as a rule, but a recommendation; if you verify that your tests are exercising
    all of the logic needed, sometimes a value less than 80% will be fine.
  prefs: []
  type: TYPE_NORMAL
- en: You need to be smart, using the generated report to figure out what logic needs
    to be tested and then work on it, rather than feel frustrated by the results.
  prefs: []
  type: TYPE_NORMAL
- en: One of the good things about using this kind of tool is that you can integrate
    it as part of your continuous integration server, to generate reports that are
    visible all of the time. In this way, the reports can be used to continually check whether
    the coverage is growing or going down and take action. We will discuss this topic
    in more detail in [Chapter 11](81e880b2-2345-4231-b7d5-d558f3c55955.xhtml), *DevOps
    and Release Management*.
  prefs: []
  type: TYPE_NORMAL
- en: UI frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are working with Spring MVC, you have the option to choose from a huge
    set of technologies to build your web pages. Depending on what framework you have
    chosen, you will need to add the corresponding configuration, in order to let
    Spring know about your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, Spring supports configuration by code, so you will need to add
    a few annotations and/or configuration classes to make your frameworks work. If
    you want to avoid these steps, you can use Thymeleaf; this framework can be easily
    integrated as part of an existing Spring application including the Thymeleaf starter
    dependency. There are different lines of codes to be used depending upon the tools
    being used which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependency when Gradle is used is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependency when Maven is used is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once the application starts, Spring Boot will do all of the boring stuff for
    you, preparing your application for using Thymeleaf.
  prefs: []
  type: TYPE_NORMAL
- en: Thymeleaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thymeleaf is a relatively new template engine; the first version was released
    in 2011\. Thymeleaf is pretty similar to HTML, which doesn't require any servlet
    containers to preview content in a browser. This is exploited in order to allow
    designers to work on the look and feel of the application, without deploying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review how to convert a web template build, using HTML and Bootstrap,
    into a Thymeleaf template, in order to see that this template engine is not intrusive.
    The following code represents a very basic HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a regular HTML file, you can open it in a browser to see how
    it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf74150a-6dcd-4e30-bddf-d45e3775f9d4.png)'
  prefs: []
  type: TYPE_IMG
- en: HTML and Bootstrap template
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement a few requirements, to make our template work in a more
    realistic way:'
  prefs: []
  type: TYPE_NORMAL
- en: The Logout option should be present only when the user is logged in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The My notification channels optionshould not be present if the user is not
    logged in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Login option should not be present once the user is logged in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the user is logged in, the Home option should show a welcome message using
    their username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These requirements are trivial when we are creating web applications, and fortunately,
    they are also easy to implement using Thymeleaf.
  prefs: []
  type: TYPE_NORMAL
- en: In order to show/hide certain elements in a web page once the user is logged
    in, we need to include an additional library to deal with this stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include the library with Gradle, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To include the library with Maven, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add a tag declaration in the HTML file, in order to use Thymeleaf
    and the new extension that was added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have included these tags, we will have the ability to use the provided
    built-in functionality. When you need to hide/show a certain element, depending
    on whether or not the user is logged in, you can use the `isAuthenticated()` condition,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also quite common to restrict access, depending on the user roles assigned.
    These checks are also easy to implement using the added extension, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish, if you need to show the username on a web page, you can use the
    following tag inside of your HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, once the template has been created by our designers or frontend
    experts, we will want to use it across the whole application, to keep a consistent
    look and feel. In order to achieve this goal, we need to define which part of
    the page will be replaced by specific content in the template, using the `layout`
    tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The pages will then need to define the template name and the content that should
    be shown in the defined fragments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We mentioned earlier that Thymeleaf is not intrusive at all, and we are going
    to show you why. Once all of the desired logic has been implemented using the
    Thymeleaf tags, you can open the template again using a regular browser, without
    deploying the application in a servlet container. You will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4575d939-9029-4f25-8eba-bfcbbe75a622.png)'
  prefs: []
  type: TYPE_IMG
- en: Thymeleaf and Bootstrap template
  prefs: []
  type: TYPE_NORMAL
- en: We have duplicate menu options, and we can still see the login and logout options,
    because the browser is not able to interpret the Thymeleaf tags. However, the
    good news is that the introduced code is not harming the template at all. This
    is exactly why your web designers can keep working and still have a preview in
    the browser. No matter how many Thymeleaf tags you have introduced in the template,
    these tags are not intrusive to the existing HTML code.
  prefs: []
  type: TYPE_NORMAL
- en: Securing an MVC application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a key aspect in software development, and we need to take it seriously
    if we want to avoid exposing our applications to common attacks. Also, we may
    want to restrict access to non-authorized people. We will review some techniques
    to keep our software safe in [Chapter 13](645d19fb-b708-4610-a98e-cb484bd48bb3.xhtml),
    *Security*. In the meantime, you will learn how to secure an MVC application using
    Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we have reviewed how to build a web application using Thymeleaf
    and Spring MVC. When working with web applications, one of the most common authentication
    mechanisms is basic authentication. Let's discuss this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic authentication, or basic access authentication, is a mechanism used to
    restrict or provide access to specific resources in the server. In a web application,
    the resources are often web pages, but this mechanism can be used to secure RESTful
    web services, as well. However, this approach is not common; a different mechanism,
    based on tokens, is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: When a website is secured using basic authentication, the users need to provide
    their credentials before requesting the website's pages. The user credentials
    are merely a simple combination of a username and password that is encoded using
    a Base64 algorithm, to calculate the value that should be in the **Authentication**
    header. This will be used by the server later, to validate whether the user is
    authenticated and authorized to access the requested resource. If the user is
    authenticated, this means that the provided username and password combination
    is valid; being authorized means that the authenticated user has permission to
    execute specific actions or View individual pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'One problem with using this authentication mechanism is that when the user
    sends the credentials to the server during the authentication process, the credentials
    are sent in plain text. If the request is then intercepted, the credentials are
    exposed. The following screenshot makes this problem evident; in this case, the
    request was intercepted using a tool called Wireshark ([https://www.wireshark.org](https://www.wireshark.org)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36c8691f-7520-44ff-926d-543720bf1767.png)'
  prefs: []
  type: TYPE_IMG
- en: Intercepted HTTP request
  prefs: []
  type: TYPE_NORMAL
- en: 'This issue can be solved easily using a secure version of HTTP, in which a
    certificate is necessary for encrypting the data that is exchanged between the
    server and the browser. The certificate should be issued by a trusted **Certificate
    Authority** (**CA**) and should be located in the server. Browsers have a list
    of trusted CA root certificates that are validated when a secured connection is
    established. Once the certificate is validated, the address bar shows a padlock,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cff6d101-4299-4113-980a-1bdf54daa13d.png)'
  prefs: []
  type: TYPE_IMG
- en: Padlock shown in the address bar
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following screenshot, the HTTPS protocol uses the `8443`
    port instead of the standard `80`, which is intended for HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da4775b6-747a-4489-86b8-7c06a2f29c7e.png)'
  prefs: []
  type: TYPE_IMG
- en: Address bar using HTTPS
  prefs: []
  type: TYPE_NORMAL
- en: For development purposes, you can generate your own certificates, but the browser
    will show you a warning indicating that the certificate could not be validated;
    you can add an exception to open the requested pages using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how a connection is established using the HTTPS
    protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a15cc8b0-106c-4136-abee-4ac95febbe38.png)'
  prefs: []
  type: TYPE_IMG
- en: HTTPS connection
  prefs: []
  type: TYPE_NORMAL
- en: 'The padlock located in the middle represents the encrypted data when it is
    going through the computer network, which makes it impossible to read. The following
    screenshot shows how the data looks when it is intercepted using Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19bc0593-e13d-4981-85da-13041ff93ff1.png)'
  prefs: []
  type: TYPE_IMG
- en: Intercepted HTTPS request
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this intercepted data is hard to understand. In this way, all
    of the information sent is protected, and, even if it is captured in transit,
    it can't be easily read. This attack is known as a man-in-the-middle attack, which
    is one of the most common types of attack.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know the basics related to Basic authentication and how it works,
    let's review how to implement it in a Spring MVC application.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we need to include the starter dependency for Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be included in Gradle as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be included in Maven as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After adding this dependency, Spring Boot will do all of the boring stuff for
    us, and we won't have to do anything to secure the application. If we don't add
    any additional configurations, Spring will generate a user for testing, and the
    password will be printed in the console. This scenario is perfect when we are
    only in the early stages of development.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we require a customized way to allow or restrict access
    to users, all that we need to do is implement the `loadUserByUsername` method, which
    is a part of the `UserDetailsService` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is fairly simple; the method retrieves the `username` provided,
    and, using that username, you will need to return a `UserDetails` object with
    the user information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review an example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `findByUsername` method is responsible for finding the users that you need
    in a database or in any other storage. Once you have customized where your users
    are, you have to work on the authorization for the web pages. This can be done
    by implementing the `WebSecurityConfigurerAdapter` interface, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review the code that has been highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: We are configuring a path to grant access to any user, whether or not the request
    is authenticated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A configuration for restricting access to only users with the `CUSTOMER` role
    is added for all of the pages under the `customers` path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A login page is configured, as well as the pages to forward successful and failed
    authentication attempts to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL `/logout` is provided, to redirect the user once the logout process
    has occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, once you have implemented the preceding configuration class,
    you will have all that you need to secure the web pages in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned earlier that a good approach to follow is to use HTTPS to encrypt
    the data that is sent between the browser and the server. To achieve this goal,
    Spring Boot offers the ability to add the following configuration properties to
    the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review the configurations in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, HTTPS uses the `8443` port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next parameter allows for specifying the digital certificate name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keystore password should also be provided. Note that this value can be provided
    when executing the application as a parameter. An even better method is to get
    these values from a configuration server, instead of having them hardcoded in
    the `application.properties` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This parameter is used to specify the store type used when the certificate was
    generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last parameter corresponds to the alias for the digital certificate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the code should not be modified to enable HTTPS in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of testing, a self-signed certificate can be created by using
    a key tool, which is part of a standard Java installation, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c5311c1-ec7b-4fee-bf15-ef64ef56e6a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Self-signed certificate creation
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the concepts related to MVC architecture and how
    they work. We also discussed the errors that people tend to make when building
    applications using this architectural style.
  prefs: []
  type: TYPE_NORMAL
- en: Then we reviewed how to create an application using Spring MVC, looking at different
    tests and how to implement them using features provided by Spring. We also reviewed
    how to use Thymeleaf with Spring MVC in order to build the UI for a web application.
    To finish this chapter, we discussed some security concepts, including how to
    apply them in a Spring MVC application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about event-driven architectures, which
    are becoming quite popular.
  prefs: []
  type: TYPE_NORMAL
