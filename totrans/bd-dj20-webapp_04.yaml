- en: Caching in on the Top 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll use the votes that our users have cast to build a list
    of the top 10 movies in MyMDB. In order to ensure that this popular page remains
    quick to load, we'll take a look at tools to help us optimize our site. Finally,
    we'll look at Django's caching API and how to use it to optimize our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a top 10 movie list using an aggregate query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about Django instrumentation tools to measure optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Django's cache API to cache results of expensive operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by making our top 10 movies list page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a top 10 movies list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For building our top 10 list, we'll start off by creating a new `MovieManager`
    method and then use it in a new view and template. We'll also update the top header
    in our base template to make the list easily accessible from every page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating MovieManager.top_movies()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `MovieManager` class needs to be able to return a `QuerySet` object of the
    most popular movies as voted by our users. We're using a naive formula for popularity,
    that is, the sum of ![](img/e7400a23-0fe5-4725-8751-68f43e1455d2.png) votes minus
    the sum of ![](img/933b0552-c3d0-4633-bbf3-87a483749b81.png)votes. Just like in
    Chapter 2, *Adding Users to MyMDB*, we will use the `QuerySet.annotate()` method
    to make an aggregate query to count the votes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our new method to `django/core/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We order our results by the sum of their votes (descending) to get our top movies
    list. However, we face the problem that some movies won't have a vote and so will
    have `NULL` as their `vote_sum` value. Unfortunately, `NULL` will be ordered first
    by Postgres. We'll solve this by adding the constraint that a movie with no votes
    will, by definition, not be one of the top movies. We use `QuerySet.exclude` (which
    is the opposite of `QuerySet.filter`) to remove movies that don't have a vote.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first time that we see a `QuerySet` object being sliced. A `QuerySet` object
    is not evaluated by slicing unless a step is provided (for example, `qs [10:20:2]`
    would make the `QuerySet` object be evaluated immediately and return rows 10,
    12, 14, 16, and 18).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a `QuerySet` object with the proper `Movie` model instances,
    we can use the `QuerySet` object in our view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the TopMovies view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since our `TopMovies` view will need to show a list, we can use Django''s `ListView`
    like we have before. Let''s update `django/core/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the previous `ListView` classes, we will need to specify a `template_name` attribute.
    Otherwise, `ListView` would try to use `core/movie_list.html`, which is used by
    the `MovieList` view.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create our template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the top_movies_list.html template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our Top 10 Movies page will not need pagination, so the template is pretty
    simple. Let''s create `django/core/templates/core/top_movies_list.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Extending `base.html`, we will redefine two template `block` tags. The new `title`
    template `block` has our new title. The `main` template `block` lists the movies
    in the `object_list`, including a link to each movie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s update `django/templates/base.html` to include a link to our
    Top 10 Movies page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's add a `path()` object to our URLConf so that Django can route requests
    to our `TopMovies` view.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a path to TopMovies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As always, we will need to add a `path()` to help Django route requests to
    our view. Let''s update `django/core/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With that, we're done. We now have a Top 10 Movies page on MyMDB.
  prefs: []
  type: TYPE_NORMAL
- en: However, looking through all the votes means scanning the largest table in the
    project. Let's look at ways to optimize our project.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing Django projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no single correct answer for how to optimize a Django project because
    different projects have different constraints. To succeed, it's important to be
    clear about what you're optimizing and what to use in hard numbers, not intuition.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to be clear about what we''re optimizing because optimization
    usually involves trade-offs. Some of the constraints you may wish to optimize
    for are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Response time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web server memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web server CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you know what you're optimizing, you will need a way to measure current
    performance and the optimized code's performance. Optimized code is often more
    complex than unoptimized code. You should always confirm that the optimization
    is effective before taking on the burden of the complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Django is just Python, so you can use a Python profiler to measure performance.
    This is a useful but complicated technique. Discussing the details of Python profiling
    goes beyond the scope of this book. However, it's important to remember that Python
    profiling is a useful tool at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at some Django-specific ways that you can measure performance.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Django Debug Toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Django Debug Toolbar is a third-party package that provides a lot of useful
    debug information right in the browser. The toolbar is composed of a list of panels.
    Each panel provides a distinct set of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most useful panels (which are enabled by default) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request Panel:** It shows information related to the request, including the
    view that processed the request, arguments it received (parsed out of the path),
    cookies, session data, and `GET`/`POST` data in the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL Panel:** It shows how many queries are made, a timeline of their execution,
    and a button to run `EXPLAIN` on the query. Data-driven web applications are often
    slowed down by their database queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates Panel:** It shows the templates that were rendered and their context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging Panel:** It shows any log messages produced by the view. We''ll discuss
    logging more in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The profile panel is an advanced panel that is available but not enabled by
    default. This panel runs a profiler on your view and shows you the results. The
    panel comes with some caveats, which are explained in the Django Debug Toolbar
    documentation online ([https://django-debug-toolbar.readthedocs.io/en/stable/panels.html#profiling](https://django-debug-toolbar.readthedocs.io/en/stable/panels.html#profiling)).
  prefs: []
  type: TYPE_NORMAL
- en: Django Debug Toolbar is useful in development, but should not be run in production.
    By default, it will only work if `DEBUG = True` (a setting you must **never**
    use in production).
  prefs: []
  type: TYPE_NORMAL
- en: Using Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django uses Python's built-in logging system, which you can configure using
    `settings.LOGGING` . It's configured using a `DictConfig`, as documented in the
    Python documentation.
  prefs: []
  type: TYPE_NORMAL
- en: As a refresher, here's how Python's logging system works. The system is composed
    of *loggers*, which receive a *message* and *log level* (for example, `DEBUG` and `INFO`)
    from our code. If the logger is configured to not filter out messages at that
    log level (or higher), it creates a *log record* that is passed to all its *handlers*.
    A handler will check whether it matches the handler's log level, then it will
    format the log record (using a *formatter*) and emit the message. Different handlers
    will emit messages differently. `StreamHandler` will write to a stream (`sys.stderr`
    by default), `SysLogHandler` writes to `SysLog`, and `SMTPHandler` sends an email.
  prefs: []
  type: TYPE_NORMAL
- en: By logging how long operations take, you can get a meaningful sense of what
    you need to optimize. Using the correct log levels and handlers, you can measure
    resource consumption in production.
  prefs: []
  type: TYPE_NORMAL
- en: Application Performance Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Application Performance Management** (**APM**) is the name for services that
    (often) run as part of your application server and trace performed operations.
    The trace is sent to a reporting server, which combines all the traces, and can
    give you code line-level insight into the performance of your production servers.
    This can be helpful for large and complicated deployments, but may be overkill
    for smaller, simpler web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of the section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we reviewed the importance of knowing what to optimize before
    you actually start optimizing. We also looked at some tools to help us measure
    whether our optimization was successful.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll take a look at how we can solve some common performance problems
    with Django's cache API.
  prefs: []
  type: TYPE_NORMAL
- en: Using Django's cache API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django provides a caching API out of the box. In `settings.py`, you can configure
    one or more caches. Caching can be used to store a whole site, a single page's
    response, a template fragment, or any pickleable object. Django provides a single
    API that can be configured with a variety of backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will perform the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at the different backends for Django's cache API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Django to cache a page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Django to cache a template fragment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Django to cache a `QuerySet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing we won't be looking at is *downstream* caching, such as **Content
    Delivery Networks** (**CDNs**) or proxy caches. These are not Django specific,
    and there is a wide variety of options. Generally speaking, these kinds of caches
    will rely on the same `VARY` headers that Django has already sent.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at configuring the backends for the cache API.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the trade-offs between Django cache backends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Different backends can be appropriate for different situations. However, the
    golden rule of caches is that they must be *faster* than the source they're caching
    or else you've made your application slower. Deciding which backend is appropriate
    for which task is best done by instrumenting your project, as discussed in the
    preceding section. Different backends have different trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Examining Memcached trade-offs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Memcached** is the most popular cache backend, but it still comes with trade-offs
    that you need to evaluate. Memcached is an in-memory key value store for small
    data that can be shared by several clients (for example, Django processes) using
    one or more Memcached hosts. However, Memcached will not be appropriate for caching
    large blocks of data (1 MB of data, by default). Also, since Memcached is all
    in-memory, if the process is restarted then the entire cache is cleared. On the
    other hand, Memcached has remained popular because it is fast and simple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Django comes with two Memcached backends, depending on the `Memcached` library
    that you want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`django.core.cache.backends.memcached.MemcachedCache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django.core.cache.backends.memcached.PyLibMCCache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must also install the appropriate library (`python-memcached` or `pylibmc`,
    respectively). To specify the address(es) of your Memcached servers set `LOCATION`
    to a list in the format `address:PORT` (for example, `['memcached.example.com:11211',]`). An
    example configuration is listed at the end of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Memcached in *development* and *testing* is unlikely to be very useful,
    unless you have evidence to the contrary (for example, you need to replicate a
    complex bug).
  prefs: []
  type: TYPE_NORMAL
- en: Memcached is popular in production environments because it is fast and easy
    to set up. It avoids duplication of data by letting all your Django processes
    connect to the same host(s). However, it uses a lot of memory (and degrades quickly
    and poorly when it runs out of available memory). It's also important to be mindful
    of the operational costs of running another service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example config for using `memcached`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Examining dummy cache trade-offs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **dummy cache** (`django.core.cache.backends.dummy.DummyCache`) will check
    whether a key is valid, but otherwise will perform no operations.
  prefs: []
  type: TYPE_NORMAL
- en: This cache can be useful for *development* and *testing* when you want to make
    sure that you're definitely seeing the results of your code changes, not something
    cached.
  prefs: []
  type: TYPE_NORMAL
- en: Don't use this cache in *production*, as it has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example config for the dummy cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Examining local memory cache trade-offs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **local memory cache** (`django.core.cache.backends.locmem.LocMemCache`)
    uses a Python dictionary as a global in-memory cache. If you want to use multiple
    separate local memory caches, give each unique string in `LOCATION`. It's called
    a local cache because it's local to each process. If you're spinning up multiple
    processes (as you would in production), then you might cache the same value multiple
    times as different processes handle requests. This inefficiency may be preferable
    for its simplicity, as it does not require another service.
  prefs: []
  type: TYPE_NORMAL
- en: This is a useful cache to use in *development* and *testing* to confirm that
    your code is caching correctly.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to use this in *production,* but keep in mind the potential inefficiency
    of different processes caching the same data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example config for the local memory cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Examine file-based cache trade-offs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django's **file-based cache** (`django.core.cache.backends.filebased.FileBasedCache`)
    uses compressed files in a specified `LOCATION` directory to cache data. Using
    files may seem strange; aren't caches supposed to be *fast* and files *slow*?
    The answer, again, depends on what you're caching. As an example, network requests
    to an external API may be slower than your local disk. Remember that each server
    will have a separate disk, so there will be some duplication of data if you're
    running a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: You probably don't want to use this in *development* or *testing* unless you
    are heavily memory constrained.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to use this in production to cache resources that are particularly
    large or slow to request. Remember that you should give your server's process
    write permission to the `LOCATION` directory. Also, make sure that you give your
    server(s) enough disk space for your cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example config to use the file-based cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Examining database cache trade-offs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **database cache** backend (`django.core.cache.backends.db.DatabaseCache`)
    uses a database table (named in `LOCATION`) to store the cache. Obviously, this
    works best if your database is fast. Depending on the scenario, this may be helpful
    even when caching results of database queries if the queries are complex but single
    row lookups are fast. There are upsides to this, as the cache is not ephemeral
    like a memory cache and can be easily shared across processes and servers (such
    as Memcached).
  prefs: []
  type: TYPE_NORMAL
- en: 'The database cache table is not managed by a migration but by a `manage.py`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You probably don't want to use this in *development* or *testing* unless you
    want to replicate your production environment locally.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to use this in *production* if your testing proves that it's appropriate.
    Remember to consider what the increased database load will do to its performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example config to use the database cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a local memory cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our case, we will use a local memory cache with a very low timeout. This
    will mean that most requests we make while writing our code will skip the cache
    (old values, if any, will have expired), but if we quickly click on refresh, we'll
    be able to get confirmation that our cache is working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update `django/config/settings.py` to use a local memory cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Although we can have multiple differently configured caches, the default cache
    is expected to be named `'default'` .
  prefs: []
  type: TYPE_NORMAL
- en: '`Timeout` is how long (in seconds) a value should be kept in the cache before
    it''s culled (removed/ignored). If `Timeout` is `None`, then the value will be
    considered to never expire.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a cache configured, let's cache the `MovieList` page.
  prefs: []
  type: TYPE_NORMAL
- en: Caching the movie list page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will proceed on the assumption that the `MovieList` page is very popular
    and expensive for us generate. To reduce the cost of serving these requests, we
    will use Django to cache the entire page.
  prefs: []
  type: TYPE_NORMAL
- en: Django provides the decorator (function) `django.views.decorators.cache.cache_page`,
    which can be used to cache a single page. It may seem strange that this is a decorator
    instead of a mixin. When Django was initially launched, it didn't have **Class-Based
    Views** (**CBVs**), only **Function-Based Views** (**FBVs**). As Django matured,
    much of the code switched to using CBVs, but there are still some features implemented
    as FBV decorators.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few different ways to use function decorators in CBVs. Our approach
    will be to build our own mixin. Much of the power of CBVs comes off from the power
    of being able to mix in new behavior to existing classes. Knowing how to do that
    is a useful skill.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first mixin – CachePageVaryOnCookieMixin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new class in `django/core/mixins.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our new mixin overrides the `as_view()` class method that we use in URLConfs
    and decorates the view with the `vary_on_cookie()` and `cache_page()` decorators.
    This effectively acts as if we were decorating the `as_view()` method with our
    function decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the `cache_page()` decorator first. `cache_page()` requires a
    `timeout` argument and optionally takes a `cache` argument. `timeout` is how long
    (in seconds) before the cached page should expire and must be recached. Our default
    timeout value is the default for the cache we're using. Classes that subclass
    `CachePageVaryOnCookieMixin` can provide a new `timeout` attribute just like our
    `MovieList` class provides a `model` attribute. The `cache` argument expects the
    string name of the desired cache. Our mixin is set up to use the `default` cache,
    but by referencing it via a class attribute, that too can be changed by a subclass.
  prefs: []
  type: TYPE_NORMAL
- en: When caching a page such as `MoveList`, we must remember that the resulting
    page is different for different users. In our case, the header of `MovieList`
    looks different for logged in users (shows a *log out* link) and for logged out
    users (shows *log in* and *register* links). Django, again, does the heavy work
    for us by providing the `vary_on_cookie()` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: The `vary_on_cookie()` decorator adds a `VARY cookie` header to the response.
    The `VARY` header is used by caches (both downstream and Django's) to let them
    know about variants of that resource. `VARY cookie` tells the cache that each
    different cookie/URL pair is a different resource and should be cached separately.
    This means that logged in users and logged out users will not see the same page
    because they will have different cookies.
  prefs: []
  type: TYPE_NORMAL
- en: This has an important impact on our hit ratio (the proportion of times a cache
    is *hit* instead of the resource being regenerated). A cache with a low hit ratio
    will have minimal effect, as most requests will *miss* the cache and result in
    a processed request.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we also use cookies for CSRF protection. While session cookies
    may lower a hit ratio a bit, depending on the circumstance (look at your user's
    activity to confirm), a CSRF cookie is practically fatal. The nature of a CSRF
    cookie is to change a lot so that attackers cannot predict it. If that constantly
    changing value is sent with many requests, then very few can be cached. Luckily,
    we can move our CSRF value out of cookies and into the server side session with
    a `settings.py` change.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding on the right CSRF strategy for your app can be complex. For example,
    AJAX applications will want to add CSRF tokens through headers. For most sites,
    the default Django configuration (using cookies) is fine. If you need to change
    it, it's worth reviewing Django's CSRF protection documentation ([https://docs.djangoproject.com/en/2.0/ref/csrf/](https://docs.djangoproject.com/en/2.0/ref/csrf/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In `django/conf/settings.py`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, Django won't send the CSRF token in a cookie, but will store it in the
    user's session (stored on the server).
  prefs: []
  type: TYPE_NORMAL
- en: If users already have CSRF cookies, they will be ignored; however, it will still
    have a dampening effect on the hit ratio. In production, you may wish to consider
    adding a bit of code to delete those CSRF cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way of easily mixing in caching behavior, let's use it in
    our `MovieList` view.
  prefs: []
  type: TYPE_NORMAL
- en: Using CachePageVaryOnCookieMixin with MovieList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s update our view in `django/core/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now when `MovieList` gets a request routed to it, `cache_page` will check whether
    it has already been cached. If it has been cached, Django will return the cached
    response without doing any more work. If it hasn't been cached, our regular `MovieList`
    view will create a new response. The new response will have a `VARY cookie` header
    added and then get cached.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's try to cache a part of our Top 10 movie list inside a template.
  prefs: []
  type: TYPE_NORMAL
- en: Caching a template fragment with {% cache %}
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, pages load slowly because a part of our template is slow. In this
    section, we'll take a look at how to solve this problem by caching a fragment
    of our template. For example, if you are using a tag that takes a long time to
    resolve (say, because it makes a network request), then it will slow down any
    page that uses that tag. If you can't optimize the tag itself, it may be sufficient
    to cache its result in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s cache our rendered Top 10 Movies list by editing `django/core/templates/core/top_movies.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This block introduces us to the `{% load %}` tag and the `{% cache %}` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The `{% load %}` tag is used to load a library of tags and filters and make
    them available for use in a template. A library may provide one or more tags and/or
    filters. For example, `{% load humanize %}` loads tags and filters to make values
    look more human. In our case, `{% load cache %}` provides only the `{% cache %}`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: '`{% cache 300 top10 %}` will cache the body of the tag for the provided number
    of seconds under the provided key. The second argument must be a hardcoded string
    (not a variable), but we can provide more arguments if the fragment needs to have
    variants (for example, `{% cache 300 mykey request.user.id %}` to cache a separate
    fragment for each user). The tag will use the `default` cache unless the last
    argument is `using=''cachename''`, in which case the named cache will be used
    instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Caching with `{% cache %}` happens at a different level than when using `cache_page`
    and `vary_on_cookie`. All the code in the view will still be executed. Any slow
    code in the view will still slow us down. Caching a template fragment solves only
    one very particular case of a slow fragment in our template code.
  prefs: []
  type: TYPE_NORMAL
- en: Since `QuerySets` are lazy by putting our `for` loop inside `{% cache %}`, we've
    avoided evaluating the `QuerySet`. If we want to cache a value to avoid querying
    it, our code would be much clearer if we did it in the view.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at how to cache an object using Django's cache API.
  prefs: []
  type: TYPE_NORMAL
- en: Using the cache API with objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most granular use of Django's cache API is to store objects compatible with
    Python's `pickle` serialization module. The `cache.get()`/`cache.set()` methods
    we'll see here are used internally by the `cache_page()` decorator and the `{%
    cache %}` tag. In this section, we'll use these methods to cache the `QuerySet`
    returned by `Movie.objects.top_movies()` .
  prefs: []
  type: TYPE_NORMAL
- en: Conveniently, `QuerySet` objects are pickleable. When a `QuerySets` is pickled,
    it will immediately be evaluated, and the resulting models will be stored in the
    built-in cache of the `QuerySet`. When unpickling a `QuerySet`, we can iterate
    over it without causing new queries. If the `QuerySet` had `select_related` or
    `prefetch_related`, those queries would execute on pickling and *not* rerun on
    unpickling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remove our `{% cache %}` tag from `top_movies_list.html` and instead
    update `django/core/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our new `TopMovies` view overrides the `get_queryset` method and checks the
    cache before using `MovieManger.top_movies()`. Pickling `QuerySet` objects does
    come with one caveat—they are not guaranteed to be compatible across Django versions,
    so we should check the version used before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: '`TopMovies` also shows a different way of accessing the default cache than
    what `VaryOnCookieCache` used. Here, we import and use `django.core.cache.cache`,
    which is a proxy for `django.core.cache.caches[''default'']` .'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to remember the importance of consistent keys when caching using
    a low-level API. In a large code base, it's easy to store the same data under
    different keys leading to inefficiency. It can be convenient to put the caching
    code into your manager or into a utility module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we made a Top 10 Movies view, reviewed tools for instrumenting
    your Django code, and covered how to use Django's cache API. Django and Django's
    community provide tools for helping you discover where to optimize your code using
    profilers, the Django Debug Toolbar, and logging. Django's caching API helps us
    with a rich API to cache whole pages with `cache_page`, the `{% cache %}` template
    tag for template fragments, and `cache.set`/`cache.get` for caching any picklable
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll deploy MyMDB with Docker.
  prefs: []
  type: TYPE_NORMAL
