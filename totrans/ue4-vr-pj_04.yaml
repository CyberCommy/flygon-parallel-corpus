- en: Getting Around the Virtual World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to take the pawn we built in the previous chapter
    and get it moving through the world. We'll begin with a commonly employed teleport
    movement scheme and cover a wide range of tasks that go into setting it up. We'll
    learn about navigation meshes in our environment, how to set up input events in
    our project and use them in Blueprints, and how to build a player pawn Blueprint
    and get it moving around the world. Finally, we'll also explore an immersive seamless
    locomotion scheme that you can use to allow your players to move through the world
    without teleporting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the course of this chapter, we''ll be discussing the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Navigation meshes—what they are, how to set them up in your level, and how to
    refine them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a Blueprint for your player pawn, and how to create input events
    that your pawn can use
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to perform traces, using both straight lines and curves, to find legal target
    locations in your environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create simple in-game indicators to show players what's going on
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a seamless locomotion scheme to provide immersive movement
    for projects where teleportation wouldn't be appropriate
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is going to be a lot of ground to cover, but it should be fun, and you're
    going to come away with a good grounding that's going to help you to figure out
    how to develop the things you want, and how to understand what other developers
    are doing when you see their Blueprints. We're going to take a slightly different
    approach in this chapter from the way most tutorials are done. To be an effective
    developer, it's far more important to learn how to think about a problem than
    simply to memorize a series of steps that may not apply to the next problem you
    face. In this chapter, we're going to walk through the processes of building elements
    and then, in some instances, *discover* bugs in them. Afterward, we'll need to
    change things to fix these bugs. This is where the real value in this approach
    lies—you'll begin to get a sense of how to develop software through iteration,
    which is the way it's really done. The goal here isn't to make you good at building
    these tutorials—it's to help you to become a developer who can make whatever you
    dream up on your own.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: With that being said, let's get building!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Teleport locomotion
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml),
    *Thinking in VR*, one of the biggest challenges we face in VR is motion sickness
    that's triggered when the user tries to move around. One of the most commonly
    used solutions for this is to *teleport* the user from place to place rather than
    to allow them to move smoothly through the space. This breaks immersion, but avoids
    the problem of motion sickness entirely because it doesn't create a sense of motion
    at all. For applications where immersive movement isn't a priority, such as architectural
    visualization, this may be an ideal scheme to employ.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Creating a navigation mesh
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we're going to need for a teleport-based locomotion scheme is
    a way to tell the engine where players are allowed to move and where they aren't.
    We can use a *navigation mesh* to do this job.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A **navigation mesh**, often shortened to **navmesh**, is an automatically generated
    set of surfaces indicating walkable floors in an Unreal level. AI-controlled agents
    use the navigation mesh to find their way around the world, but it can also be
    used as a way to identify safe destinations for the player pawn to land, as we're
    doing here in our teleport system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a navmesh in Unreal is fairly simple. From your Modes panel, select
    the Volumes tab, and find the NavMesh Bounds Volume. Drag it into your scene,
    as shown in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff62bd89-e770-45fb-8353-9dfaac605ff5.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Select the Nav Mesh Bounds Volume from Modes | Volumes
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Moving and scaling the Navmesh Bounds volume
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The NavMesh Bounds volume needs to surround any floor where you''d like the
    player to be able to teleport. Let''s make our navmesh visible so that we can
    see where the walkable floors are being set up:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Hit the *P* key to toggle navigation visibility or, from the viewport menu,
    select Show | Navigation:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0fa82e83-9f5d-4ec3-93e0-219af714867f.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: Use the P key or Show | Navigation to display the generated navmesh in the environment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: If you don't see any navigable space after you've placed a NavMesh Bounds volume,
    make sure it's intersecting a walkable floor. The volume sets the boundaries for
    the navmesh generation, so if it's above the floor, it won't generate anything.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this NavMesh Bounds volume we just placed is far too small. Let's
    extend it to cover the space in which we'd like to move. We're going to do this
    by scaling the volume.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Hit the *R* key to switch to scaling mode, or just tap the *spacebar* until
    the scaling gizmo appears.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could scale the volume from the perspective view, but for this kind of operation,
    it's often a good idea to go to an orthographic view so that we can really see
    what we're doing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Hit *Alt* + *J* or use the viewport''s view selector to switch to a top view:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00012d43-9bf3-423a-97bf-09296f64b3d5.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Switch to an orthographic top view using the menu or its associated shortcut
    key.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Scale the navmesh to surround the walkable area of the building.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With your navigation visible, you can see where it''s generating navmesh surfaces
    and whether it''s doing a sensible job of it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a43840c2-2d94-4263-aac9-5f780232ff57.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: A top view of our level showing the extents of the NavMesh bounds volume
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In our case, parts of the building that we expect to be walkable aren't yet
    covered. This is because we haven't yet done anything with the height of our bounds
    volume, and these areas are too high or low to fit inside it. Let's jump to a
    side view to fix that.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Alt* + *K* to jump to the left view, or select Left from your viewport
    view selection.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scale the bounds volume to a scale that reasonably covers the floor:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/670062aa-f965-46ee-9c43-1492e0f2e2ec.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: Side view of the level. You can see here that we're scaling the navmesh bounds
    volume to encompass the floor
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Alt* + *G* to jump back to a perspective view and see how we're doing.
    Alternatively, you can select Perspective from your view selector.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's worth memorizing these keystrokes for changing views. You'll use them all
    of the time, and it's handy to be able to switch quickly. *Alt* + *J*, *K*, and
    *H* switch view angles. *Alt* + *2* switches to a wireframe view, and *Alt* +
    *4* switches back to a shaded view. There are plenty of other hotkeys, but you'll
    use these the most.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'If we fly to the back of the temple, we can see that we have a problem here.
    Our navmesh didn''t generate as expected in the back corridor. Let''s figure out
    what''s going on here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98ead175-7c85-4f0e-92e7-24b590a92b9a.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: Here we can see that part of our level hasn't been properly covered by the navmesh.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Fixing collision problems
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are almost always two reasons why a navmesh isn''t generating where you
    expect it. Either your volume isn''t surrounding the area where you''re trying
    to generate the mesh, or there''s something wrong with the collision in the area.
    Let''s take a look:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Alt* + *C* to view the collision in the back hall, or hit Show | Collision.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It doesn't appear that there's any stray collision encroaching into the hall,
    so it's probably a missing collision on the floor.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Select the floor in the bad area.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In its details, find its Static Mesh and double-click it to open it up:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/de446944-4748-46f2-8b0e-a9430387c643.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Use the Details panel to find the static mesh for the bad floor region.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Static Mesh Editor, select the Collision toolbar item and make sure
    that Simple Collision is checked:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2b4a5c4f-4080-4f17-af62-b903b1603ca6.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: View simple collision for the static mesh
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Sure enough, our simple collision is missing. Let's fix this.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Select Collision | Add Box Simplified Collision to add a simple collision plane
    to our floor.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s much better. We should now see that the navmesh we expect has been
    generated back in our main level:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6841a774-5537-445a-853b-887083fada8e.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Simplified collision created for our floor mesh
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let's take a second to talk about what's going on here. A
    very common thing we need to do in real-time software is figure out when an object
    has hit another object. Unreal uses *collision meshes* to do this. A collision
    mesh is simplified geometry that's used to check for intersections with other
    collision meshes in the world.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Actors have two of these:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: A **Complex Collision** mesh. This is simply the model's visible mesh.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Simple Collision** mesh. This is a much less detailed convex mesh that surrounds
    the object. These are often generated when an object is imported, or can be created
    explicitly in the DCC where the model was created. If it's missing, you can create
    a simple collision in the editor, like we've done here. As a last resort, you
    can set Details | Collision | Collision Complexity to Use Complex Collision As
    Simple to use the object's visible mesh for all collision calculations. Don't
    do this for a mesh with a ton of polygons, though. It's expensive.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection and handling is its own fairly deep topic and beyond the
    scope of this book, but for our purposes in VR development, we're going to care
    a lot about the simple collision meshes of our objects, because we'll use these
    as walkable surfaces to detect when another object hits them, to detect whether
    we can grab them, and for many other purposes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Excluding areas from the navmesh
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking around our map, we have a few more problems we need to fix. Our Navmesh
    Bounds Volume is generating a navmesh in a few areas where we don''t want our
    players to teleport. Let''s fix this, too:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Alt* + *2* to switch to a wireframe view, or use the viewport's View Mode
    selector to switch to wireframe.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We probably have a few problems we can fix just by adjusting the scale of the
    NavMesh Bounds volume. If we have navmesh generating on rooftops or window sills,
    let's reduce our Bounds volume's vertical scale to exclude these areas if we can.
    This is an area where hitting *Alt* + *K* to jump to a side view can help.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: If our NavMesh Bounds volume is spreading further outside the building than
    it needs to, we can jump to a top view using *Alt* + *J* and adjust it to fit
    better.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re still going to have a few leftover stray areas that we''ll want to exclude,
    and that can''t simply be fixed by scaling the volume. For these, we''ll use Nav
    Modifier Volumes. Refer to the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Grab a Nav Modifier Volume from your Modes palette and drag it into the scene.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move and scale it until it surrounds an area where the unwanted navmesh is being
    generated.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll see the navmesh in this region disappear when the nav modifier volume
    surrounds it. Take a look at the nav modifier volume properties in your Details
    panel. Do you see that Default | Area Class is set to NavArea_Null? This tells
    the navmesh generator to omit generating a navmesh in this region. You can see
    from the pulldown menu that it can also be used to mark obstacles and crawlspaces,
    but for what we're doing here, we don't care about these. We're just interested
    in using it to clear out unwanted navigation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag as many of these into your scene as you need to clean up the stray bits.
    You can hold down the *Alt* key while dragging a modifier volume to duplicate
    it, or hit *Ctrl* + *W* to make a copy:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/27229d49-ac56-4fe2-bdba-32a5ebdc9449.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: A perspective wireframe view can be useful for finding problems with your navigation
    coverage.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: You'll find it helpful to memorize the transform hotkeys as you're moving objects
    around. *W* activates the Translate tool, which allows you to slide an object
    around. *E* activates the Rotate tool, and *R* activates the Scale tool. Tapping
    the *spacebar* also cycles through these tools. *Ctrl* + *W* duplicates an object,
    and holding *Alt* while dragging an object also copies it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动物体时，记住熟记变换热键会很有帮助。按下W键激活“平移”工具，可以让你滑动物体。按下E键激活“旋转”工具，按下R键激活“缩放”工具。按下空格键也可以循环使用这些工具。按住Ctrl键+W键可以复制一个物体，拖动物体时按住Alt键也可以复制它。
- en: When you're done, you should have a collection of Nav Modifier Volumes blocking
    off areas you don't want your player to stand on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该有一系列阻挡玩家站立的导航修改体积。
- en: Fly through your level and make sure you don't have any weird navmesh where
    you don't want it. Where you find problems, fix them by scaling your navmesh bounds
    volume, or adding nav modifier volumes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在你不希望出现奇怪的导航网格的地方飞行，确保没有问题。在发现问题时，通过缩放导航网格边界体积或添加导航修改体积来修复问题。
- en: Modifying your navmesh properties
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改导航网格属性
- en: There's one other thing you should know about before we move on, and that's
    where to adjust the properties for the navmesh you've just generated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，还有一件事情你应该知道，那就是如何调整刚刚生成的导航网格的属性。
- en: If you need to change anything about its behavior, select the `RecastNavMesh`
    object, which will have been created in your level. In its Details panel, you
    can see properties governing its generation, querying, and runtime behavior.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要改变它的行为，选择“RecastNavMesh”对象，它将在你的关卡中创建。在其详细面板中，你可以看到控制其生成、查询和运行时行为的属性。
- en: 'We''re not going to go into these here except to call attention to one of these
    properties: if you wanted to adjust the size of an area into which your player
    could fit, you can adjust the Agent Radius to do so. Making this smaller will
    allow your player to fit into tighter spots. Similarly, you can adjust the Agent
    Height and Max Height to determine acceptable ceiling heights under which navigation
    should be generated. Generally, you''ll want to make changes to these values before
    you go crazy fine-tuning your nav modifier volumes since changes here will change
    where your navmesh is generated. For our purposes, we''re going to leave these
    values alone.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里详细介绍它们，只是提醒你其中一个属性：如果你想调整一个玩家可以适应的区域的大小，你可以调整代理半径来实现。将其缩小将使玩家适应更狭窄的空间。同样，你可以调整代理高度和最大高度来确定导航应该生成的可接受天花板高度。通常，在你疯狂微调导航修改体积之前，你会想要对这些值进行更改，因为这里的更改会改变导航网格的生成位置。对于我们的目的，我们将保持这些值不变。
- en: Setting up the pawn Blueprint
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置兵棋蓝图
- en: Now that we have our navigation built and tuned in our scene, we can turn off
    navigation visualization by hitting *P*, and start working on our locomotion behavior.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在场景中构建和调整了导航，我们可以通过按下P键关闭导航可视化，并开始处理我们的运动行为。
- en: 'To implement a teleport locomotion scheme, we need to do three jobs:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现传送运动方案，我们需要做三个工作：
- en: Figure out where the player wants to move
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弄清楚玩家想要移动到哪里
- en: Figure out where the player is actually allowed to move
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弄清楚玩家实际上被允许移动到哪里
- en: Move the player to the new location
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将玩家移动到新位置
- en: Let's get to work.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始工作吧。
- en: Iterative development
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代开发
- en: We're going to develop this method iteratively, the way you really would if
    you were developing it from scratch. Most tutorials simply walk you through the
    steps to build a finished method, but the problem with this approach is that it
    doesn't teach you *why* you're doing the things you're doing. As soon as you want
    to do something similar, but not exactly the same, you're back to square one.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以迭代的方式开发这种方法，就像你从头开始开发一样。大多数教程只是带你完成构建完成方法的步骤，但这种方法的问题在于它不教你为什么要做你正在做的事情。一旦你想做类似的事情，但又不完全相同，你就又回到了原点。
- en: Instead, we're going to work in stages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将分阶段进行工作。
- en: 'Kent Beck, a pioneering software developer, gives this advice to developers:
    *Make it work, make it right, make it fast.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 杰出的软件开发者肯特·贝克给开发者提出了这样的建议：“让它工作，让它正确，让它快。”
- en: What's important here is the order in which you do things. It seems almost obvious
    at first, but few developers get it right when they're starting out. You'll save
    yourself a lot of heartache if you work in this order.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是你做事情的顺序。一开始似乎几乎是显而易见的，但很少有开发者在刚开始时就做对。如果按照这个顺序工作，你将节省很多痛苦。
- en: Make it work
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它工作
- en: Build a rough assembly of what you're trying to do. Test it early and often.
    Build it to be easy to test and easy to change. Change things around until you're
    satisfied that it's doing the right work.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个大致的组装，测试早期和频繁。使其易于测试和易于更改。不断更改，直到你满意它正在做正确的工作。
- en: Make it right
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它正确
- en: Now that you know what your code needs to do, figure out how you should really
    organize it. Are there better or cleaner ways to do what you're trying to do?
    Are there parts that can be reused? Will this code need to be used anywhere else?
    Could you debug it if you had to? Use the work you did in the *make it work* phase
    as a starting point, but now that you understand what you really need to do, write
    it correctly. It's okay to make a mess in the first stage (in fact, you're probably
    doing it wrong if you're not making a mess), but clean that mess up in this phase.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道你的代码需要做什么了，弄清楚你应该如何真正组织它。有没有更好或更清晰的方法来做你试图做的事情？有没有可以重复使用的部分？这段代码是否需要在其他地方使用？如果需要，你能调试它吗？以“让它工作”的阶段为起点，但现在你明白你真正需要做什么了，正确地编写它。在第一阶段制造混乱是可以的（事实上，如果你没有制造混乱，那么你可能做错了），但在这个阶段清理这个混乱。
- en: Make it fast
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它快
- en: Once you have reasonably clean code that's doing the right job, look for ways
    you could get it running faster. Is there a result that you're generating more
    than once that you could cache to a variable and reuse? Are you checking conditions
    repeatedly, even though you know they can only change when certain things happen?
    Are you copying data that you could just read from its original location? Figure
    out what you could be doing more efficiently, and speed things up where you can.
    Be careful here, though. Some optimizations are so minor that they may not really
    make a noticeable difference to the running application. Go for the big ones,
    and use profiling tools to understand where your problems really are. You want
    to make sure you're optimizing things that are really going to make a difference.
    Also, be careful about making your code more difficult to read or debug as you
    optimize it. A change that shaves a tiny amount off of your frame time but makes
    a class difficult or impossible to update or maintain might not be worth it. Use
    judgment when optimizing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了合理干净的代码，能够正常工作，寻找可以使其运行更快的方法。是否有一个结果，您可以将其缓存到变量中并重复使用？您是否反复检查条件，即使您知道它们只会在某些事件发生时改变？您是否复制了可以直接从其原始位置读取的数据？找出您可以更高效地做什么，并在可以的地方加快速度。但要小心，在这里有些优化可能对运行应用程序没有明显的影响。选择大的优化，并使用性能分析工具了解您真正的问题所在。您要确保优化的是真正会产生差异的东西。此外，在优化代码时要小心不要使其更难以阅读或调试。将帧时间减少一点但使类难以更新或维护的更改可能不值得。在优化时要谨慎使用判断。
- en: Do things in order
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按顺序进行操作
- en: Many new developers mess this order up, and start trying to optimize their code
    before they've really made sure they're doing the right thing. This just wastes
    time, as there's a high likelihood that some of that code will be thrown out.
    Other developers skip the *make it right* phase, and consider their work done
    as soon as it seems to work. This is a mistake too, as 80% of the life cycle of
    a piece of code is spent maintaining and debugging it. If your code works but
    it's a mess, you're going to burn a lot of extra time trying to keep it running
    later on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 许多新开发者会在优化代码之前就开始尝试优化代码，而没有确保自己正在做正确的事情。这只会浪费时间，因为很可能会丢弃其中的一些代码。其他开发者跳过了“让它正确”的阶段，并在似乎工作正常时认为他们的工作已经完成。这也是一个错误，因为代码的80%的生命周期都用于维护和调试。如果您的代码能够工作但是一团糟，您将花费大量额外的时间来保持其运行。
- en: Problems that are created by rushed or sloppy work early in development are
    often referred to as *technical debt*. This is stuff you're going to have to fix
    later because, even though it runs, it may not be flexible or robust, or might
    just be an unreadable shambles. The time to clear your technical debt is right
    after you've finished your *make it work* phase, and before you've moved onto
    other things and started to build more code on top of something that needs to
    change.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发初期匆忙或粗心的工作所造成的问题通常被称为“技术债务”。这些是你以后需要修复的东西，因为即使它能运行，但可能不够灵活、健壮，或者只是一团难以理解的混乱。清理技术债务的时间是在完成“让它工作”阶段之后，而在继续其他工作并在需要更改的基础上构建更多代码之前。
- en: Working in this order and thinking of these as discrete stages will make you
    a more effective developer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个顺序并将其视为离散阶段来进行工作将使您成为一个更有效的开发者。
- en: Setting up a line trace from the right motion controller
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从右手控制器设置一条射线追踪
- en: 'Let''s begin with the first thing we need to do to get our teleport running—figuring
    out where the player wants to go:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从获取玩家想要去的位置开始设置我们的传送功能：
- en: Open up our BP_VRPawn Blueprint, and open My Blueprint | Graphs | EventGraph,
    if it isn't already open.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开BP_VRPawn蓝图，并打开我的蓝图|图表|事件图，如果尚未打开。
- en: We should still see the `BeginPlay` event in our Event Graph where we set our
    tracking origin. Now, we're going to add some code to our Event Tick.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在事件图中仍然看到“BeginPlay”事件，其中我们设置了跟踪原点。现在，我们将在事件Tick中添加一些代码。
- en: The Tick event is called every time the engine updates the frame. Be careful
    about putting too much work into your Tick events, as they can eat performance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每次引擎更新帧时都会调用Tick事件。在Tick事件中不要放太多工作，因为它们会影响性能。
- en: If you don't already see an Event Tick node in your Event Graph, right-click
    anywhere in the graph, type `tick` in the search box, and select Add Event | Event
    Tick. If you already have a Tick event defined, this won't add a new one—it'll
    just take you to that node in the event graph. If you don't, this will create
    one now.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在事件图中还没有看到Event Tick节点，请在图中的任何位置右键单击，输入“tick”在搜索框中，然后选择添加事件|事件Tick。如果已经定义了一个Tick事件，这不会添加一个新的事件，而只会将您带到事件图中的该节点。如果没有，现在将创建一个。
- en: Right-click to the right of Event Tick, and add a Line Trace by Channel.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Event Tick的右侧单击，添加一个按通道进行线性追踪。
- en: When you perform a line trace, you supply a *start* point and an *end* point,
    and tell it what *collision channel* you're looking for. If an actor with a collision
    set to the supplied collision channel intersects the line between the start and
    end points, the trace will return `true`, and will return information about what
    it hit. We're going to use this behavior to find our teleport destination.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行线性追踪时，您提供一个“起点”和一个“终点”，并告诉它您要查找的“碰撞通道”。如果一个具有设置为提供的碰撞通道的碰撞的actor与起点和终点之间的线相交，追踪将返回“true”，并返回有关它所击中的信息。我们将利用这种行为来找到我们的传送目的地。
- en: 'Let''s start our trace at the location of the right motion controller:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从右手控制器的位置开始追踪：
- en: From your components list, grab `MotionController_R`, and drag it into your
    event graph.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从组件列表中获取MotionController_R，并将其拖动到事件图中。
- en: We want to start our trace at the motion controller's location, so let's drag
    a connector out from the `MotionController_R` return value and release.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望从运动控制器的位置开始追踪，所以让我们从MotionController_R的返回值中拖出一个连接器并释放。
- en: 'In the dialog that appears, type `getworld` into the search bar and select
    GetWorldLocation:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的对话框中，输入`getworld`并选择GetWorldLocation：
- en: '![](img/8c4a8a1c-1a1b-4ed3-9112-4bded8efdbb2.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/8c4a8a1c-1a1b-4ed3-9112-4bded8efdbb2.png)
- en: Blueprint node creation is context-sensitive by default. This means that if
    you're dragging a connection from another object, you'll only be shown actions
    that would be appropriate for that object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图节点的创建默认是上下文敏感的。这意味着如果你从另一个对象拖动连接，你只会看到适用于该对象的操作。
- en: Drag the result of `GetWorldLocation` into the Line Trace node's Start input
    pin.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GetWorldLocation`的结果拖入Line Trace节点的Start输入引脚。
- en: Now, let's set the trace end point. We're going to end our trace at a point
    10,000 units away from our start location, in the direction the controller is
    facing. Let's do a bit of simple math to figure out where that point is.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置追踪的终点。我们将在距离起始位置10,000个单位的点结束追踪，朝向控制器的方向。让我们进行一些简单的数学计算，找出那个点在哪里。
- en: From the `MotionController_R` output, create a `Get Forward Vector` node.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`MotionController_R`的输出中创建一个`Get Forward Vector`节点。
- en: This will return a vector with a length of 1 that aims in the direction the
    controller is facing. We said we wanted our end point to be 10,000 units from
    the start, so let's multiply our Forward vector by that value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个长度为1的向量，指向控制器所面向的方向。我们说过我们希望终点距离起点为10,000个单位，所以让我们将我们的Forward向量乘以该值。
- en: Drag the `Get Forward Vector` return value out and type `*` into the search
    bar. Select vector * float.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Get Forward Vector`的返回值拖出并在搜索栏中输入`*`。选择向量*浮点数。
- en: 'Now, drag a connector out from the float input to the multiply action, and
    select Promote to Variable:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从浮点输入拖出一个连接器到乘法操作，并选择Promote to Variable：
- en: '![](img/5dc6c864-8c13-42cd-8b29-f11331716833.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/5dc6c864-8c13-42cd-8b29-f11331716833.png)
- en: This is a fast way of creating variables in Blueprint. You can simply drag out
    from an input, select Promote to variable,
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在蓝图中快速创建变量的方法。你可以简单地从输入中拖出，选择Promote to variable，
- en: and a variable will be created with the correct type for the input
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 并且将创建一个具有正确类型的变量以供输入使用
- en: Name the new variable `TeleportTraceLength`, compile the Blueprint, and set
    the variable's value to `10000`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新变量命名为`TeleportTraceLength`，编译蓝图，并将变量的值设置为`10000`。
- en: You could have simply typed `10000` directly into the multiplication action's
    float input, but it's bad practice to do so. If you start hiding values all over
    the place in your Blueprints, you'll have a hard time finding them later on when
    you need to change them. Also, a number typed into an input doesn't do anything
    to explain what it is. A variable, on the other hand, can be given a name that
    describes what's actually going to change if its value is changed. Numbers buried
    without explanation in your code are called *magic numbers* by developers, and
    they're an example of *technical debt*. They're just going to turn into a hassle
    for you later on when you need to maintain or debug your code. Unless the use
    of a value is absolutely obvious in its context, use a variable instead, and give
    it a meaningful name.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在乘法操作的浮点输入中键入`10000`，但这样做是不好的实践。如果你在蓝图中随处隐藏数值，当你需要更改它们时，你将很难找到它们。此外，键入到输入中的数字并不能解释它是什么。相反，变量可以被赋予一个描述其值改变时实际发生的事情的名称。在你的代码中没有解释的数字被开发人员称为*魔法数字*，它们是*技术债务*的一个例子。当你需要维护或调试代码时，它们只会给你带来麻烦。除非一个值在其上下文中绝对明显，否则请使用一个变量，并给它一个有意义的名称。
- en: 'We now have a vector that''s 10,000 units long, aiming in the controller''s
    forward direction, but right now it would be running 10,000 units from the world''s
    center, rather than from the controller, as we intend. Let''s add the controller''s
    location to this vector to fix that:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个长度为10,000个单位的向量，指向控制器的前方，但现在它将从世界的中心运行10,000个单位，而不是从控制器开始，这不是我们的意图。让我们将控制器的位置添加到这个向量中以修正这个问题：
- en: Drag another connector from the controller's `GetWorldLocation` call, and type
    `+` in the search bar. Select vector + vector.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从控制器的`GetWorldLocation`调用中拖出另一个连接器，并在搜索栏中输入`+`。选择向量+向量。
- en: Drag the output from our forward vector multiplication into the other input.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的前向量乘法的输出拖入另一个输入。
- en: 'Connect the output of this addition to the End argument of `LineTraceByChannel`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此加法的输出连接到`LineTraceByChannel`的End参数：
- en: '![](img/eab371d1-f1f2-49ec-8133-60cc9422839a.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/eab371d1-f1f2-49ec-8133-60cc9422839a.png)
- en: Before we move on, let's set up some debug drawing to see whether everything
    is behaving as we expect so far.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们设置一些调试绘图，以查看到目前为止是否一切都按我们的预期运行。
- en: Hold down the *B* key and click on the open space to the right of the `Line
    Trace` node to create a `Branch` node. (You can also right-click and create a
    Branch node the way you usually do, but this is a useful shortcut.)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*B*键并点击`Line Trace`节点右侧的空白处，创建一个`Branch`节点。（你也可以右键单击并像通常那样创建一个Branch节点，但这是一个有用的快捷方式。）
- en: Drag a connector from the `Line Trace` node's Boolean Return Value to this branch's
    Condition.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Line Trace`节点的布尔返回值拖出一个连接器到这个分支的条件。
- en: The trace operation will return `True` if it hits something, and `False` if
    it doesn't. We're only interested in debug drawing the result if it hits something,
    so we're just going to use the `True` output from our branch.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果追踪操作命中了某个物体，它将返回`True`，如果没有命中，则返回`False`。我们只对命中物体进行调试绘图，所以我们只使用分支的`True`输出。
- en: If we did hit something, we need to know where the hit occurred.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实命中了某个物体，我们需要知道命中发生的位置。
- en: Drag a connector from Out Hit and select Break Hit Result to see the members
    of the hit result struct.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Out Hit拖出一个连接器，并选择Break Hit Result以查看命中结果结构的成员。
- en: A **struct** is a bundled collection of variables that can be given a name and
    passed around as a single unit. The `Hit Result` struct is a commonly used struct
    that describes the properties of a detected collision, telling you where it occurred,
    what actor was hit, and many other details. Calling **break** on a struct allows
    us to see its contents.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s draw a debug line representing our trace:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Drag an execution line from our `Branch` node's `True` output, and create a
    `Draw Debug Line` action.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Location from the `Hit Result` struct into the Line End input on the
    `Debug Line` call.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the hit result's Trace Start to the Line Start.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the line's thickness to `2`, and set its color to anything you like.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While we''re at it, let''s draw a debug sphere at the hit location:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Draw Debug Sphere` node.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect its execution input to the debug line's output.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its Center to the hit result''s Location:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6142e634-b112-4a9c-a7f0-9f7ff46603cb.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Be aware that `Draw Debug` calls only work in development builds. They're useful
    for understanding what's going on, but they're just debugging tools and need to
    be replaced with real visualizations for your actual software. We'll do that shortly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it. Your result should look something like this:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0c4a2841-f8a2-4b08-8320-c23637ed28a3.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Good. So far, it's doing what we expect—casting a ray from the controller, and
    showing us where it hits a surface. The problem, though, is that it's just as
    happy to hit a wall as a floor. We need to restrict it to valid teleport destinations.
    Let's do that.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Improving our Trace Hit Result
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to do this first by setting up a simple test that only accepts
    surfaces facing upward. We''ll do this by using a vector operation called a *Dot
    Product* to compare a surface normal with the world''s up vector. Follow these
    steps to get started:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Right-click somewhere to the right of our hit result breakout, and create a
    Dot Product node.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Normal from the hit result into the first input, and set the second
    input's *Z* value to 1.0.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *normal* is a vector that's perpendicular to the surface from which it extends.
    A *dot product* is a mathematical operator that returns the cosine of the angle
    between two vectors. If two vectors are exactly parallel, their dot product will
    be 1.0\. If they're facing exactly in opposite directions, their dot product will
    be -1.0\. If they're exactly perpendicular, the dot product is 0.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Since the vector (0,0,1) is the world's up vector, by testing the dot product
    of a surface normal against this vector, we can find out whether or not the normal
    is facing upward by checking whether the dot product is greater than 0.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Drag a connector from the result of the dot product, and select the `>` operator.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another branch operator using this result as its Condition.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Alt* + click the execution input to the Draw Debug Line node to disconnect
    it.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a new execution line from the return value's branch to this new branch.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the True output from the dot product''s branch with our Draw Debug
    Line node:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ecccc094-918f-4fe3-b345-7473fb1a6cfb.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Let's test it. We'll see that we now see the debug sphere drawn when our ray
    hits a floor, but not when it hits a wall or a ceiling. As we mentioned a moment
    ago, this is because the dot product of a wall's normal versus the world's up
    vector will be 0, while the dot product of a ceiling against the world up is -1.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: This is better, but what about the places we decided we didn't want the player
    to go? We spent all of that time setting up our navmesh bounds and navmesh modifiers,
    and we're not using them yet. We should fix this.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Using navmesh data
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''re going to take our test a step further, and look for the nearest
    point on the navmesh to wherever our pointer is pointing:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in our graph, and create a Project Point to Navigation node
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect our hit result's Location output to this new node's Point input
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the node''s Projected Location output with the debug line''s Line End and
    the Debug Sphere''s Center, replacing the location inputs that we''d previously
    been using there:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将节点的Projected Location输出与debug line的Line End和Debug Sphere的Center连接起来，替换之前在那里使用的位置输入：
- en: '![](img/38f742b8-1c43-4944-9ef9-e158f40cdcfd.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38f742b8-1c43-4944-9ef9-e158f40cdcfd.png)'
- en: What we're doing here is querying the navmesh we created to find the closest
    point on the mesh to the location we supplied. This will prevent a location from
    being selected that we'd excluded from our mesh.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是查询我们创建的导航网格，找到离我们提供的位置最近的网格上的点。这将防止选择我们从网格中排除的位置。
- en: As we look around the scene, though, we can start to see that we're going to
    have a problem. Casting a ray straight from the controller isn't going to allow
    us to teleport onto higher locations than where we're currently standing, because
    the ray won't be able to hit the higher floor. This is a flaw in our system, and
    we're going to need to rethink this.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们环顾四周时，我们会发现我们将会遇到一个问题。直接从控制器发射射线将无法让我们传送到比我们当前站立位置更高的位置，因为射线无法击中更高的地板。这是我们系统的一个缺陷，我们需要重新考虑这个问题。
- en: This is why it's so important to stick to our guns and do a *make it work* phase
    before we put a ton of work into cleaning up. It often happens that your first
    running prototype will reveal things you need to rethink, and it's better to discover
    these things early, before you've burned a ton of effort.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在我们投入大量工作之前坚持做一个“让它工作”的阶段非常重要的原因。通常情况下，你的第一个运行原型会揭示出你需要重新考虑的事情，最好在你付出大量努力之前尽早发现这些问题。
- en: Changing from line trace to parabolic trace
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从线追踪切换到抛物线追踪
- en: 'Thinking it through, it becomes clear that we''re going to need a curved path
    to reach points that are higher than our current viewpoint. Let''s modify our
    trace method to make this possible. This is the result we will get:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 经过思考，我们清楚地意识到，为了到达比我们当前视点更高的点，我们需要一个曲线路径。让我们修改我们的追踪方法以实现这一点。这是我们将得到的结果：
- en: '![](img/1fdd3794-85d5-4feb-946b-1ad0f19576bf.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fdd3794-85d5-4feb-946b-1ad0f19576bf.png)'
- en: 'The math used to calculate a parabola is actually fairly simple, but we have
    an even easier option available to us. The `Predict Projectile Path By TraceChannel` method
    already handles the math for us and can save us some time. Let''s use this now:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算抛物线的数学方法实际上相当简单，但我们还有一个更简单的选择。`Predict Projectile Path By TraceChannel`方法已经为我们处理了数学计算，并且可以节省我们一些时间。让我们现在使用它：
- en: Disconnect our Event Tick from the old Line Trace By Channel node.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断开我们的Event Tick与旧的Line Trace By Channel节点的连接。
- en: Right-click in our graph and create a Predict Projectile Path by TraceChannel node.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中右键单击，创建一个Predict Projectile Path by TraceChannel节点。
- en: Connect it to our Tick.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其连接到我们的Tick。
- en: Set its Trace Channel to Visibility.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Trace Channel设置为Visibility。
- en: Next, connect the output from the GetWorldLocation of MotionController_R to
    the Start Pos input.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将MotionController_R的GetWorldLocation的输出连接到Start Pos输入。
- en: 'To get our Launch Velocity, we''re going to take the Forward Vector of MotionController_R,
    and multiply it by an arbitrary value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得我们的发射速度，我们将使用MotionController_R的Forward Vector，并将其乘以一个任意值：
- en: Disconnect the old `TeleportTraceLength` variable from the Multiply node.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断开旧的`TeleportTraceLength`变量与Multiply节点的连接。
- en: Drag out a new connector from the Multiply node's float input and promote it
    to a variable. Let's name it `TeleportLaunchVelocity`.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Multiply节点的float输入处拖出一个新的连接器，并将其提升为一个变量。让我们将其命名为`TeleportLaunchVelocity`。
- en: Compile our Blueprint, and give it a value of 900.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译我们的蓝图，并给它一个值为900。
- en: 'Connect the result to the Launch Velocity input:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果连接到Launch Velocity输入：
- en: '![](img/ce8fc76f-f782-44d0-9420-f587a65d1c6d.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce8fc76f-f782-44d0-9420-f587a65d1c6d.png)'
- en: Now, let's draw the resulting path so that we can verify that it's doing what
    we expect.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们绘制结果路径，以便验证它是否按照我们的预期进行。
- en: Drawing the curved path
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制曲线路径
- en: 'The `Predict Projectile Path By TraceChannel` method is going to return an
    array of points describing the path of the parabola. We can use these points to
    draw our targeting indicator. Let''s get started:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predict Projectile Path By TraceChannel`方法将返回一个描述抛物线路径的点的数组。我们可以使用这些点来绘制我们的目标指示器。让我们开始吧：'
- en: Just as we did previously, connect a Branch to our Return Value. We're only
    interested in drawing anything if we got a good result.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，将一个Branch连接到我们的Return Value。我们只对得到一个好结果时才感兴趣。
- en: Now, to draw the curved path, we're actually going to have to draw a series
    of debug lines instead of just one.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了绘制曲线路径，我们实际上需要绘制一系列的debug line，而不仅仅是一个。
- en: 'Let''s drag a connector from Out Path Positions and create a ForEachLoop node:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从Out Path Positions拖出一个连接器并创建一个ForEachLoop节点：
- en: '![](img/e8df5cc7-1db3-44b9-b132-6ec6f6f8e7aa.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8df5cc7-1db3-44b9-b132-6ec6f6f8e7aa.png)'
- en: We should take a moment to talk about what we're doing here, since this is a
    concept you'll use quite a lot.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该花点时间来讨论我们在这里做什么，因为这是一个你将经常使用的概念。
- en: So far, all of the variables we've handled in our pawn Blueprint have contained
    single values—a number, a true or false value, and a vector. The connector for
    Out Path Positions, however, looks different. Instead of a circle, it's a 3 x
    3 grid. This icon indicates that this is an **array**. Rather than holding a single
    value, an array contains a list of values. In this case, those values are a list
    of points that make up the curved path we're going to draw.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的pawn蓝图中处理的所有变量都只包含单个值-一个数字，一个true或false值和一个向量。然而，Out Path Positions的连接器看起来不同。它不是一个圆圈，而是一个3
    x 3的网格。这个图标表示这是一个**数组**。数组不同于单个值，它包含一个值列表。在这种情况下，这些值是构成我们要绘制的曲线路径的点的列表。
- en: A *For Each Loop* is a programming structure called an **iterator**. Iterators
    loop through collections of values and allow you to perform operations on each
    element in the collection.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*For Each Loop*是一种称为**迭代器**的编程结构。迭代器循环遍历值的集合，并允许您对集合中的每个元素执行操作。'
- en: 'Let''s take a quick look at the ForEach Loop''s outputs:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看一下ForEach Loop的输出：
- en: The Loop Body will execute once for each item it finds in the array.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Array Element is the item it found.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Array Index is where it found it. Arrays are always numbered from zero,
    so the first item will have an index of 0, the second will have an index of 1,
    and so on.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Completed execution pin will be called when it reaches the end of the list.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''re going to use this loop to draw the line segments of our curve, but we''re
    going to need two points for each segment, which means we can''t draw anything
    until we reach the second point in the array:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Drag a connector from the Array Index output and connect it to an integer |
    integer node. Leave the second value as 0.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect its output to a Branch, and connect the Loop Body to the Branch input.
    This will allow us to skip the first value in the array.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Draw Debug Line node, and connect the Array Element to the Line End
    input. Since we''re starting with the second value of the array, the point at
    that location is the end of our line. We''re going to get the line start by getting
    the point before it:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6ee3a718-2a43-4df8-b60f-083d68ed88d4.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: To find our Line Start, drag another connector from the Array Index, and *subtract
    1* from it.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, drag another connector from Out Path Positions, and type `Get` into the
    search box. Select Get (a copy):'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7fbff992-33c2-4e33-bdff-647a3e5ac552.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: This will get the element stored at the location in the array corresponding
    to the index we give it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Connect the result of our Array Index -1 subtraction to the Get node's integer
    input. This will retrieve the value before the one we're currently iterating on.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the output from this Get node to the Line Start of Draw Debug Line:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6abe0f30-f3cf-4a2a-bc6e-433261e589ad.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: When you're finished, the drawing routine should look something like what's
    shown in the preceding screenshot.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: What we've just done here is looped through each of the path position vectors
    in Out Path Positions, and for each one after the first, we drew a line from the
    position before it to the current one, until we reached the end of the list.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the endpoint after all the line segments have been drawn
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s draw a debug sphere at the trace endpoint. We can reuse the
    nodes we were previously using to draw the sphere at the end of our straight line
    trace:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did before, **break** the **Hit Result** struct from Out Hit.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take its Location and feed it into a ProjectPointToNavigation node.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a Branch to its Return Value, and feed the **True** branch's execution
    into a Draw Debug Sphere node.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Projected Location as the debug sphere's Center.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rather than calling this right after the Draw Debug Line node, however, call
    it from the Completed output of ForEachLoop instead, since we only need to draw
    the sphere once after all of the line segments have been drawn.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Your graph should now look like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7bde58c-9e8b-41f4-b8af-0fbc6d824817.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: 'Let''s test it and see what happens when we run it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cc4228f-796c-44ca-98ce-0bae0b3a67a1.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: Great! We're now projecting a curved path that will allow us to get around the
    map much more easily, and we've used debug drawing to verify that it's giving
    us good results.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The Draw Debug methods we're using here will only work in debug and development
    builds. They aren't included in shipping builds. The correct way to draw this
    path would be to use the collection of points in Out Path Positions to change
    the shape of a spline mesh, but doing this is beyond the scope of this book. There's
    a good example, however, in the VR Template, and the work we've done here is a
    good starting point for understanding what they're doing in that project's Blueprints.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take care of the next job and allow our player to teleport to the
    destination they've chosen.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Teleporting the player
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do in this instance is give the player a way to tell
    the system when they intend to teleport.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Creating Input Mappings
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to use our Engine Input Mappings to set up a new named input.
    Let''s get started:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Open your Project Settings and navigate to Engine | Input.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hit the + sign beside Bindings | Action Mappings to create a new action mapping:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a39aa2d2-d39d-426c-a319-852ff1d2f7c3.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: We're going to name it `TeleportRight`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What this is going to do is create an input event with this name that we can
    then respond to in our event graphs.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: You may have already discovered that you can set up events in your event graphs
    directly to listen to controller inputs and keystrokes. For most projects, though,
    it's a better idea to map your inputs here as it gives you a central location
    from which to manage them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s indicate what inputs should trigger this teleport action. A drop-down
    menu has appeared beneath the new action mapping with a None indicator displayed.
    (Hit the expander arrow beside the action mappings if the drop-down menu isn''t
    visible.) Let''s carry on:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Under TeleportRight, use the drop-down menu to select MotionController (R) Thumbstick.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will handle our Oculus Touch controller mappings, but doesn't help us on
    the HTC Vive, which doesn't use thumbsticks.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Hit the + sign beside the TeleportRight action to add another mapping to the
    group.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select MotionController (R) FaceButton1 for this one:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b681e76-7e02-46bb-8b55-096201144bc9.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: Your bindings should now look like what's shown in the preceding screenshot.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Now, we've told the input system to send a TeleportRight input event, regardless
    of whether the player is using a motion controller with a thumbstick or one with
    face buttons.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: These bindings are stored in `DefaultInput.ini` and can be edited there, but
    it's generally more convenient to set them up here in the Project Settings UI.
    If you need to copy a bunch of input bindings from one project to another, however,
    it can be convenient to copy the contents of `DefaultInput.ini` from one project
    to another. Not every project will have `DefaultInput.ini`. If yours doesn't,
    you can simply add it and the engine will use it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s close Project Settings and return to our VRPawn''s event graph. You''ll
    find that you can now create a TeleportRight event here, since we defined it in
    our input settings. Let''s do this, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14f0af2a-817f-4ff6-b388-0d5950bbf8a3.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: Caching our teleport destination
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, before we do anything with this event, we need to store the location we
    found in our trace method previously so that we can use it here when the player
    tries to teleport:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Under My Blueprint | Variables, hit the + sign to create a new variable.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its type to Boolean, and name it `bHasValidTeleportDest`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Variable names are important. They tell the reader (who might be another developer
    maintaining your code or might be yourself in the future) what a variable represents.
    Your variable names should accurately reflect what they contain. In the case of
    True/False Boolean variables, make sure your name describes what question it's
    actually answering. So, for instance, in this case, *Teleport* would be a poor
    choice for a name, as it doesn't indicate whether the variable's value means that
    the player can teleport, is teleporting, has recently teleported, or just enjoys
    daydreaming about teleporting. Be clear about these things. `bHasValidTeleportDest`
    clearly indicates what it means.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Prefixing Boolean variable names with *b* is a practice mandated by Epic's coding
    style guide for C++, but it's a good idea to follow it in Blueprint development
    as well. (If you plan on developing in C++, you should know and follow the Unreal
    style guide, which can be found at [https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard](https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard).)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Create another variable and name it `TeleportDest`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its type to Vector.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s populate these variables. The location we care about is the Projected
    Location found by the Project Point to Navigation method we''re calling at our
    hit location. Let''s store whether we''ve found a valid location. You''ll probably
    want to drag the Draw Debug Sphere node a bit to the right to give yourself some
    room since we''re about to add a few nodes before we call it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Drag your `bHasValidTeleportDest` variable onto the event graph, and select
    set when asked.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you see where the Completed output from the ForEach loop runs into the Branch
    statement coming out of our Project Point to Navigation method?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Press *Ctrl* + drag the execution input into that Branch node to move it onto
    the `CanTeleport` setter. (Notice that the *b* prefix on Boolean variables is
    automatically hidden when the variable is used in a graph.)
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Return Value from the Project Point to Navigation method into this
    variable. You can press *Ctrl* + drag to move this too.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an execution line from Set bHasValidTeleportDest to the Branch input, and
    use the output of the setter to drive the branch.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s set our TeleportDest to the Project Point to Navigation method''s projected
    location if it returns true:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Drag our `TeleportDest` variable onto the event graph and choose to set it.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the execution line running from our Branch node into our Draw Debug Sphere
    node, and press *Ctrl* + drag it to move it into the Set Teleport Dest input.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Projected Location output into the `TeleportDest` variable.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, just because it's cleaner, let's feed the output from the `TeleportDest`
    setter into the Center input on our DrawDebugSphere node.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's worth learning about Blueprint shortcuts. Pressing *Alt* + clicking on
    a connection disconnects it. Pressing *Ctrl* + dragging a connection allows you
    to move it somewhere else.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: From the False execution pin of Branch, let's set TeleportDest to (`0.0, 0.0,
    0.0`).
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your graph should now look like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bbdda98-cb03-419b-b6b8-ecf6fff953d6.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: Can you see the extra pin on the connection between Projected Location and Set
    Teleport Dest? That's a **Reroute Node**. You can create one by dragging a connection
    out and selecting Add Reroute Node from the creation dialog, or by *double-clicking*
    on an existing connector. These are useful for organizing your connections so
    that you can easily see what's going on in your graphs. In general, try to avoid
    allowing connectors to cross underneath nodes they're not connected to, as this
    can mislead someone reading your Blueprint. You can also feed multiple inputs
    into a reroute node or branch multiple outputs from it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Now, on every tick, we have either a true or a false value in `bHasValidTeleportDest`,
    and if it's true, we have the location to which we could teleport.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Executing the teleport
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the value we''ve just stored in the `bHasValidTeleportDest` flag
    to see whether we have a valid destination, and teleport the player pawn to the
    `TeleportDest` if we do:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: From the `TeleportRight` input action we created a moment ago, we'll connect
    an execution line from its Pressed output into a Branch node.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that you can hold down *B* and click to create a Branch node. Take
    a look at the other shortcuts found on Epic's Blueprint Editor Cheat Sheet here: [https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/CheatSheet](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/CheatSheet).
    They'll save you a lot of time.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Grab your `bHasValidTeleportDest` variable and drag it onto the Branch node's
    Condition input.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the True execution output, create a SetActorLocation action, and drag
    your `TeleportDest` variable onto its New Location input:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/886789e5-a692-4944-b19c-7660d9b5930e.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: Launch it into a VR preview and give it a shot. You should now be able to teleport
    around the map. It's nice to be able to explore, right?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have everything working, let's do some work to improve things.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we'll notice when we start jumping around the map is that we
    don't have any way to change the player's orientation at their landing position.
    We can definitely improve this.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Allowing the player to choose their landing orientation
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want our player to be able to specify their facing direction when they
    land, the first thing we're going to need to do is give them a way to tell the
    system where they want to be looking.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Mapping axis inputs
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add an input to give our player a way to do this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Open up Project Settings | Engine | Input.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you see the section in Bindings | Action Mappings where we set up our TeleportRight
    input? Right below it is a list of **Axis Mappings**.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Hit the + button beside Axis Mappings to add a new mapping.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the expansion arrow to open it up, and name it `MotionControllerThumbRight_Y`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map it to MotionController (R) Thumbstick Y.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its scale to -1.0.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second mapping, named `MotionControllerThumbRight_X`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map it to `MotionController (R) Thumbstick X`, and leave its scale as 1.0.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unreal''s input system handles two kinds of mappings: **Action Mappings** and
    **Axis Mappings**. Action mappings are discrete events, such as button or key
    presses and releases. Axis mappings give you continuous information about an analog
    input, such as a joystick or a trackpad.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we scaled the Y input from our motion controller
    thumbstick by -1.0\. This is because the Y input from that device comes in reversed,
    so we need to flip it. Multiplying it by -1 simply inverts the input:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66967fe7-325a-4f12-b74d-a59c64f782fc.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: Your input mappings should now look like what's shown in the preceding screenshot.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've added our new input mappings, we can close our project settings.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up our Tick event
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's jump back to our pawn's event graph.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to check the player''s thumbstick position continuously while
    we''re setting up a teleport, we''re going to need to put this on the Event Tick.
    Our Tick event is getting a little crowded, though. Let''s clean it up before
    we start adding more:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag a marquee over the current contents of your Tick event:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b0efc0af-adb4-485b-8f96-660516a68778.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: Select all the nodes connected to your Event Tick.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click anywhere on the selected nodes and select Collapse to Function
    from the context menu:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5faa06cf-bec0-47f9-bbc3-61a8b7a92911.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: Right-click any of the selected nodes and select Collapse to Function.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Name the new function `SetTeleportDestination`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s much cleaner, isn''t it? Take a look at the following screenshot:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/229b9c0c-9109-4b4c-8416-7cb8c4c3f7d9.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: In general, it's a good idea to use functions as a way of organizing and reusing
    your code, rather than leaving things strewn all over your event graph. Remember
    that 80% of the life cycle of any piece of code will be spent in debugging and
    maintaining it, so organizing your code early can save you quite a lot of work
    later on.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The names you give your functions should be descriptive and they should be accurate.
    Think of them as a promise to the reader that the contents of the function really
    do whatever the name suggests they do. That reader might be you in the future,
    debugging or updating your code, or it might be another developer altogether.
    If you've named your functions clearly, everyone's going to have a much easier
    time understanding what your code is doing. If you modify a function in a way
    that changes what it does, change its name too. Don't let a legacy name mislead
    your reader.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Using thumbstick input to orient the player
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new function to handle our teleport orientation:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Hit the + button in My Blueprint | Functions to create a new function.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `SetTeleportOrientation`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new tab will automatically open, showing you the contents of your function.
    Right now, it just contains an entry point with an execution pin.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Right-click anywhere inside the function's graph and type `thumbright` into
    the context menu's search box. You'll see that the two Axis Mappings you created
    in your input settings are now visible here as functions.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the Get MotionControllerThumbRight_Y and Get MotionControllerthumbRight_X nodes
    here:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c18a43bd-4d09-4d9e-8c47-c982dc18ee98.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: Create a Make Vector node.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the return value from Get MotionControllerThumbRight_Y into the Make Vector node's
    X input. (This may seem backward, but it's correct—we need to transform this input
    to use it to drive our rotation.)
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed Get MotionControllerThumbRight_X into the new vector's Y input.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Normalize the new vector by adding a Normalize node to the Make Vector''s Return
    Value:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c7eb290-ddc7-496b-9f79-50783dd11647.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: '**Normalizing** a vector scales it to a length of 1\. A vector whose length
    is 1 is called a **unit vector**. Many mathematical operations on vectors will
    return incorrect results if they''re called on vectors with arbitrary lengths.
    A general rule of thumb is that, if you''re doing vector operations to figure
    out rotations or angles, make sure you''re using unit vectors.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've normalized our input vector, we need to rotate it so it's aiming
    in the direction the player intends.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the thing about designing locomotion systems for VR: when you present
    the player with a rotation, you have to decide what its basis is going to be.
    When the player pushes a stick forward or touches forward on a trackpad, how do
    we translate that into a real-world rotation? If you''ve operated a remote control
    car or been playing games long enough to remember the old *tank-style* controls
    in *Resident Evil* and *Fear Effect*, you have some notion of what we''re describing
    here. *Forward* in those systems meant the direction the car or character was
    facing, and if the character was facing the camera at the moment, those controls
    were going to feel backward.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: In traditional first-person designs over the past two decades, this isn't a
    problem we've had to address. There was no difference between the direction the
    character was facing and the direction the player was looking, so using the camera's
    look direction as a forward direction was an obvious choice.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'In VR, on the other hand, we have several options:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: We can base our rotation on the *pawn's rotation*, but that's not a great idea
    in room-scale VR, as the player can turn around in the tracking volume without
    necessarily rotating their pawn. You don't want to orient a control based on something
    the player may not be able to see.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could base it on the player''s *look direction*, which is a better choice
    since it''s consistent from the player''s perspective, but creates funky behaviors
    as the player looks around:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0be22159-18b2-4344-9e65-a967eac571d2.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: A character in VR can have several transforms at the same time - head, body,
    and hands.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: In VR, a player's head, hands, and body can rotate independently of each other,
    so it's no longer always obvious where *forward* is.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The best choice, though (and as we'll discover later on when we handle seamless
    locomotion), is to base it on the *motion controller's orientation*, since the
    player's already using it to provide input, is aware of its orientation, and can
    change its orientation easily.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set our system up this way:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Add a RotateVector node to our Normalize node's return value.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to MotionController_R onto the graph.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag a GetWorldRotation node from MotionController_R:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d80a478-519e-4f05-a674-d42280c63066.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: This will get us the right controller's orientation in the world, but we're
    only interested in the side-to-side rotation (Yaw). We don't want any Pitch or
    Roll information.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click the Return Value from GetWorldRotation and select Split Struct
    Pin:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/49174351-383e-4ef5-b593-07b7c6a0b052.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: Do the same for the RotateVector node's B input.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the Yaw output from GetWorldRotation to the Yaw input to RotateVector.
    Leave Roll and Pitch unconnected:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f04385ed-7840-4577-b0fc-eded2656a91d.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
- en: '**Splitting** struct pins in Blueprints is often cleaner than using **Break**
    and **Make** nodes to split them and reconstruct them. They do the same thing.
    It''s purely a question of what makes your Blueprint more readable.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to turn our rotated vector into a rotator we can use.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Add a RotationFromXVector node to the RotateVector's return value.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to store this vector so that we can use it later.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Drag the RotationFromXVector node's return value out and select Promote to variable.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new variable `TeleportOrientation`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create a Set node for the new variable automatically. Drag an execution
    line from your function's entry point to this setter.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an execution line from your setter and select Add Return Node to add an
    exit point to your function.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ad87534-e51e-4ae6-adef-9dd78b577393.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: We're now converting the return value from our RotateVector node to a rotator
    and using it to populate Teleport Orientation.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Adding return nodes to functions that don't return values isn't required, but
    it's good practice to do it because it makes it clear to someone maintaining or
    debugging the code where the exit points are. Nothing will break if you don't
    do this, but your code will be easier to read if you do. We're not going to do
    this with every method in this book, just to avoid adding extra steps, but it's
    a good idea to make this a habit.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to your event graph''s Event Tick, and drag the SetTeleportOrientation
    function onto the outgoing execution pin from SetTeleportDestination:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/45b7bca7-f17e-4d89-a1b2-191c6cbc8ea8.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
- en: Set Teleport Orientation will now be called on every frame after Set Teleport
    Destination finishes.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this new information:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: In your event graph, find the InputAction TeleportRight event, where we're setting
    our actor location.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, let's collapse this into a function as well. Leaving it out on the event
    graph is sloppy. Select the nodes to the right of our input action, right-click,
    and *collapse* them into a new function.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the new function `ExecuteTeleport`:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c8ba3b98-3eef-4f2a-ae12-cfbc785c2207.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
- en: Since we now have a teleport orientation value we need to accommodate, SetActorLocation
    is no longer enough for us, since it only sets location and not rotation. We could
    call a `Set Actor Rotation` method right after it, using the value stored in our
    TeleportOrientation variable, but there's a cleaner method available to us.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Select the Set Actor Location node here and **delete** it.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the graph and create a Teleport node.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the True branch from our Branch statement to its execution input.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the TeleportDest variable to its Dest Location input.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Grab the TeleportOrientation variable from our Variables list and drag it onto
    the Dest Rotation input pin:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f99cd473-5018-4afe-9028-ea81c4a67c15.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
- en: Let's try it out. Much better. Now, the position of our thumb on the trackpad
    or the orientation of the thumbstick affects our teleport orientation. We can
    look around much more easily.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: There's still one more thing we need to fix though. Our teleport orientation
    works fine if the player is still looking in the same direction as the pawn's
    rotation, but becomes confusingly inaccurate if they aren't. Let's accommodate
    this.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: What we're going to want to do here is find out where the player is looking
    relative to the pawn's orientation, and then combine this difference in rotations
    with our selected teleport orientation so that when the player lands there, they're
    looking in the direction they selected.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Right-click and create a GetActorRotation node.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're only going to want the Yaw value from this rotation, so right-click the
    node's Return Value and select Split Struct Pin to break out the rotator's components.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From your Components list, drag a reference to the Camera component onto the
    graph.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag its output and call GetWorldRotation on it.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click its Return Value and select Split Struct Pin.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the graph and create a Delta (Rotator) node. Split its A and
    B input struct pins.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GetActorRotation node's Return Value Z (Yaw) output to the Delta
    (Rotator) node's A Z (Yaw) input.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Camera's GetWorldRotation node's Return Value Z (Yaw) output to
    the Delta (Rotator) node's B Z (Yaw) input.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the graph and create a CombineRotators node.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Teleport Orientation variable's value into the CombineRotators node's
    A input.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Return Value from the Delta (Rotator) node into the CombineRotator
    node's B input.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Return Value from the CombineRotators node into the Teleport node's
    Dest Rotation input.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7aa921fb-c947-444c-bbdc-858b30300ebc.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
- en: 'Now when the player lands at the selected teleport spot, they''ll be looking
    in the direction they expect. If you''re coming from traditional flat-screen game
    development, this is a thing you''re going to have to get used to accommodating
    as a VR developer: the pawn''s rotation is not synonymous with the look direction.
    Players in VR can look around without affecting the pawn''s orientation, so you''ll
    always need to keep both orientations in mind when handling rotation in VR.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: The problem now is that we can't see where it's going to aim us when we land.
    Let's improve our target indication.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Creating a teleport destination indicator
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create a simple Blueprint actor to act as our teleport destination indicator:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: In your project's Blueprints directory, right-click and create a new blueprint
    class with `Actor` as its parent class.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `BP_TeleportDestIndicator`.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it up.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Components tab, hit Add Component, and add a Cylinder component.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the scale of the Cylinder to (`0.9, 0.9, 0.1`). (Remember to unlock the
    uniform scale lock to the right of the Scale input.)
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the Cylinder's Collision properties, set Can Character Step Up On to No,
    and set its Collision Preset to NoCollision. (This is important—this indicator
    will interfere with the pawn if it has a collision.)
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Cube component.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Location to (`60.0, 0.0, 0.0`).
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its Scale to (0.3, 0.1, 0.1):'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c0885e4f-a067-458d-b6ed-6693fdbb3381.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
- en: Our indicator should look something like this.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Compile it, save it, and close it.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Giving it a material
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the blank white material isn''t doing it for you, we can create something
    a little nicer. We''re not going to go crazy on this one, but we can improve its
    look with some quick work:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: From your project directory in your Content browser, create a new directory
    called `MaterialLibrary`.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click inside it and select Create Basic Asset | Material.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your new material **M_TeleportIndicator**.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it up.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Details | Material section, set its Blend Mode to Additive.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Shading Model to Unlit.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold down the *3* key and click anywhere in the graph to create a Constant 3
    Vector node. This is how colors are represented in materials.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click the node and choose a primary green: R=0.0, G=1.0, B=0.0.'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the output of our color node into the Emissive Color input.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click anywhere in the graph and create a Linear Gradient node.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the VGradient output into the material''s Opacity input:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c2fd06f3-9fce-4b09-b90f-3b5a32df5d85.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
- en: Save and close the material.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your BP_TeleportDestIndicator Blueprint and select the Cylider component.
    Under its Details | Materials, set its Element 0 material to the material you
    just created.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do the same for the Cube component:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd2a6360-d5d2-4fc1-8698-026e886610da.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
- en: Nice! This is a very simple material, and if we really wanted to, we could spend
    a lot of time designing something wonderful, but for what we're doing now, this
    is entirely fine.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Adding the teleport indicator to the pawn
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s add this new indicator to our pawn:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: In our VRPawn's Components tab, add a Child Actor component.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Details | Child Actor Component | Child Actor Class, select the new BP_TeleportDestIndicator
    actor we just made.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the ChildActor to `TeleportDestIndicator`. (You can use the *F2* key
    to rename objects.)
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a new function to set its position and orientation:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Create a new function in the pawn's Functions collection, and name it `UpdateTeleportIndicator`.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the TeleportDestIndicator into the function's graph.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the output from TeleportDestIndicator and create a SetWorldLocationAndRotation
    node, using it as its Target.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your TeleportDest variable onto the New Location input.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your TeleportOrientation variable onto the New Rotation input.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give it a return node:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f310cd87-18b9-4a07-88a9-6a2de2a3e243.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
- en: 'Return to your event graph, and drag an instance of the `UpdateTeleportIndicator`
    function onto your Event Tick after Set Teleport Orientation:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/008ef504-8c70-4c61-975c-345356a109db.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
- en: Let's try it out. That's better! Now, we can see where we're going to be facing
    when we land. While we're at it, let's get rid of that Debug Sphere we were using
    as a temporary solution earlier on.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: In the Set Teleport Destination function, find the Draw Debug Sphere call and
    **delete** it.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimizing and refining our teleport
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's finish things up with a bit of refinement, where we're still seeing some
    rough edges.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Displaying UI only when teleport input is pressed
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First off, we''re running the teleport indicators all of the time, regardless
    of whether or not the user is actually trying to teleport. Let''s activate these
    interfaces only when the user is pressing the teleport input:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Add a new variable to our player pawn. Set its type to Boolean, and name it
    `bTeleportPressed`.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Alt* + click on the execution line from InputAction TeleportRight to
    the `ExecuteTeleport` function call to disconnect it.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `bTeleportPressed` variable onto the Pressed execution pin from InputAction
    TeleportRight to create a setter. Set it to True here.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag another instance of `bTeleportPressed` onto the Released execution pin.
    Set it to False.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect ExecuteTeleport to the setter that''s clearing TeleportPressed, so
    the teleport will happen when the user releases the input:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f863cb00-a5ce-404e-81f8-a55b66b5756d.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
- en: Now that we have a variable that will be true when the teleport input is held,
    and false when it isn't, we can use this to manage what happens on our Tick event.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Disconnect Event Tick from SetTeleportDestination.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Branch node here, and use `bTeleportPressed` as its condition.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feed the execution line from Event Tick to the Branch input, and feed its True
    branch to `SetTeleportDestination.` This way, the teleport UI will only be updated
    or displayed when the user presses the teleport input:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3dfb86b0-ba5d-45d2-99fa-bd572fa2ac9b.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try it out. This is better, but our destination indicator is still visible
    while the input isn''t pressed, and it''s not updating. We need to hide it when
    we''re not using it:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Select the TeleportDestIndicator component from your pawn's Components tab.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Details, set Rendering | Hidden in Game to True.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your TeleportDestIndicator component onto the graph.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from it and call Set Hidden in Game on it.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an instance of **bTeleportPressed** onto your graph and **Get** its value.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from it and type `not` into the search bar. Select NOT Boolean.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug this value into the New Hidden input in your Set Hidden in Game action.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will cause the indicator to be hidden when Teleport is not pressed, and
    not hidden when it is:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b604c91-b28b-48a9-b0c2-ed813606366b.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
- en: Let's try it again. Much better. The UI is only displayed when we need it.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: We would still need to replace the teleport arc we're currently drawing with
    debug methods before we could ship. We're not going to run through that process
    here, though, because it's a bit too involved for the scope of this chapter. Basically,
    what you would do here is create a spline component on the pawn and attach a mesh
    to it. Instead of using a ForEach loop in `SetTeleportDestination` to draw a series
    of debug lines, we would save the path positions to a variable. In `UpdateTeleportIndicator`,
    we would then use these positions to set the points on the spline. If you'd like
    to give this a shot, there's a good example in the VR Template.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Creating a deadzone for our input
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we jump around the map, it's also becoming clear that we haven't given the
    player an easy way to teleport without changing orientation. Our system works
    well when they want to look around, but doesn't give them a way to opt out.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up `SetTeleportOrientation` and fix this:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Create a new variable in BP_VRPawn. Set its type to Float, and name it `TeleportDeadzone`.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the Blueprint and set its value to 0.7\. This will accept input at 70%
    of the trackpad or thumbstick's radius.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a second output from the Make Vector node that's combining the two Get
    MotionControllerThumbRight input values, and create a VectorLengthSquared node
    from it.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `TeleportDeadzone` variable onto the graph and Get its value.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Square the value of Teleport Deadzone.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the output from VectorLengthSquared and create a >= node.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the squared Teleport Deadzone value into its other input:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c75ca880-5fb3-4002-a1c6-3a9c13a1f53e.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
- en: What's going on here? We're interested in finding out whether the user's input
    is more than 70% of the way toward the edge of its range. We could find this by
    getting the vector length and comparing it with the Teleport Deadzone, and this
    would give us a correct answer, but finding the actual length of a vector involves
    a square root, which is expensive. Squaring a value, on the other hand, just involves
    multiplying it by itself, which is cheap. In our case, since we don't care what
    the real vector length is—just how it compares with the deadzone. We can skip
    the square root on our vector length and just compare it with the squared target
    length. This is a common way of optimizing vector length comparisons. You'll see
    it a lot.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Using squared vector lengths to test input deadzones will give you a properly
    round test region, so you'll get consistent results at any input angle.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use the result of this comparison to pick which rotation value
    we will use:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Place a Select node in the graph, and connect the output of the >= test to its
    Index input.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disconnect the RotationFromXVector node's output from the Set Teleport Orientation
    node.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the RotationFromXVector node's output to the Select node's True input.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a GetActorRotation node and connect its output to the Select node's False
    input.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the Select node''s Return Value to the Set Teleport Orientation node''s
    input:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/77990d2d-83c1-4b10-8e74-62f1a81527e2.png)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
- en: What we're doing here is using the result of our deadzone check to decide whether
    we should use the rotation value from the thumbstick inputs or just stick with
    the pawn's existing rotation. If the input is at 70% of the range or greater,
    we'll use the input. If not, we just use the pawn's rotation.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/449c69d1-3aa2-45c9-8c99-c45d34631011.png)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
- en: Let's run it. Now, you'll change orientation if you're hitting the edge of the
    trackpad or pushing the thumbstick a fair distance, but if they're closer to the
    center, you'll just retain your current orientation when you teleport.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Fading out and in on teleport
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our system is starting to work pretty well, but our teleport can feel a little
    jarring. Let''s fade out and back in to make a more pleasant transition:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Open our pawn's event graph.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Near our InputAction Teleport Right event, create a `Get Player Camera Manager` node.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From this node's Return Value, create a `Start Camera Fade` action.
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its To Alpha value to 1.0.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out its Duration input and promote it to a variable. Compile and set its
    value to **0.1**.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will fade the scene camera to black over a duration of one tenth of a second.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Disconnect the input to the `Execute Teleport` function call.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the execution output from the Teleport Pressed = False node to the new
    Start Camera Fade action.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll probably need to drag a few nodes off to the right to make some room.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''re going to call Start Camera Fade after the user has released the
    teleport input, since we''ve cleared the `bTeleportPressed` flag:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Drag an execution line from the Start Camera Fade node's execution output and
    put a Delay on it.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Delay duration to your Fade Duration variable.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the Delay's **Completed** output into your `Execute Teleport` function
    call so that the function will be called after the fade and delay have occurred.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user releases the teleport input, we're fading out over a tenth of
    a second, waiting another tenth of a second, and then executing the teleport.
    Now, we need to fade back in once the teleport is done.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Create another Start Camera Fade node, and connect the Execute Teleport output
    to its execution input.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output from Get Player Camera Manager to this node's Target input.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Duration to your `Fade Duration` variable.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its From Alpha value to 1.0 and its To Alpha value to 0.0.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the output from this node to the input of your Set Hidden in Game node
    of Teleport Dest Indicator:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ef14375-1ba2-4283-bcdf-b6fc98e8b2f6.png)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
- en: Your graph should now look like this.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Let's test it in-game. This is much nicer. We now have a fast fade out and in
    when the teleport action occurs. It's subtle, but adds a bit of polish to the
    application and makes the teleport less jarring.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this action takes time, however briefly, we should ensure that the player
    can''t trigger a second teleport while one is already underway:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Boolean variable and name it `bIsTeleporting`.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an instance of it onto your graph and Get its value.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert a new Branch node between InputAction TeleportRight and set Teleport
    Pressed to True.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `bIsTeleporting` as the Branch node's Condition.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect its False output to the set Teleport Pressed to True node, and leave
    its True output unconnected.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do the same for the input action''s Released execution:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/24619ec8-7d02-4d4e-b390-81232642ca8a.png)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
- en: This way, a Teleport Pressed or Released event will only be processed if `bIsTeleporting`
    is False.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to set `bIsTeleporting` to True when we start a teleport action,
    and then set it to False again when the action finishes:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: After the Set Teleport Pressed = False node coming from the input action's Released
    output, insert a setter to set `bIsTeleporting` to True.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect its output to the Start Camera Fade node.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/efc934e6-a9a1-447a-9039-f83a82849f23.png)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
- en: After the second Start Camera Fade node, add another setter to set `bIsTeleporting`
    to False.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the output of that node to the Set Hidden in Game input for the Teleport
    Dest Indicator:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/caba586b-b053-4fc6-87e7-e62c68fb5c99.png)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
- en: Now, when we execute a teleport by releasing the input, `bIsTeleporting` will
    be set to true until the teleport action has finished, and a new teleport action
    won't be accepted.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Teleport locomotion summary
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve covered a lot of ground here and created a pretty comprehensive teleport
    locomotion scheme. Let''s go over the scheme:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: It's bound to the navmesh, so it won't allow players to teleport into illegal
    locations
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's using a parabolic trace so that the player can teleport to destinations
    higher than their current position
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the player to choose their target orientation when teleporting
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does a decent job of indicating where the player is going to go and where
    they'll be facing
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes a few bits of polish, such as an input deadzone and a camera fade
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more we could do with this, but it's a reasonably complete solution.
    If we were to improve it further, we would likely want to allow it to work with
    either hand, and we would certainly need to replace our debug-drawn teleport path
    with something that will work in a shipping build. If you choose to explore further
    from here, the VR Template included with the engine is a great next step. Many
    of the methods we just wrote here are similar to the methods used in that template,
    so you should find that you're standing on good ground to understand what you
    see when you start digging around in there.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: Teleportation is an effective solution for getting around in VR because, as
    we mentioned earlier, it doesn't try to represent movement, so it doesn't generally
    trigger motion sickness in users. It works pretty well for applications that don't
    rely on a high degree of immersion in the ways players move through the world.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'For games and applications that want to maintain a higher level of immersion,
    teleportation may not be what you want, as it doesn''t behave the way movement
    in the real world does: it creates a discontinuous sense of space, and introduces
    interface elements that clearly don''t exist in the world. There''s no way around
    the reality that it''s an immersion-breaker.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to take a look at an immersive movement scheme that allows
    players to move smoothly through the world. Very sensitive players or those who
    are new to VR may not find immersive movement comfortable, so in some circumstances,
    it may be appropriate to offer teleport locomotion as an option on an application
    that also offers seamless movement.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how it works.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Seamless locomotion
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're making an immersive game or experience, that experience is going to
    be much more convincing to the player if their sense of the space around them
    isn't constantly being broken up by teleport actions. Let's take a look at a way
    to handle seamless locomotion in space.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Setting up inputs for seamless locomotion
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ordinarily, we would probably allow users to select the sort of locomotion scheme
    they're comfortable with in an options menu, but since our current character doesn't
    do anything but move around, and we haven't done anything with the left controller
    yet, we can use it to drive our seamless locomotion scheme.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a pair of input axis mappings for the left controller''s thumbstick:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Open Project Settings | Engine | Input.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the + button beside Bindings | Axis Mappings twice to add two new axis mappings.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name them `MoveForward`, and `MoveRight`.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind MoveForward to MotionController (L) Thumbstick Y.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to -1.0.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bind MoveRight to MotionController (L) Thumbstick X, and leave its Scale at
    1.0:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2054edc5-b7ed-45cf-b10e-b5eff2036e7d.png)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
- en: We're all set with our input bindings for the moment, so we can close our project
    settings.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Changing the pawn's parent class
  id: totrans-570
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our pawn to move smoothly, we're going to need to give it a way to handle
    its movement input. There are two ways we could do this. We could write our own
    input handler on our Tick event, but this is a fairly involved process, and unnecessary
    if we're interested in implementing a straightforward movement scheme.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: 'An easier way is to add a Movement Component to our pawn. In Blueprint, however,
    there''s no way to add a movement component (in C++, there is), so instead, we''re
    going to have to change our pawn''s parent class to a class that contains the
    component we need, along with several others we''re also going to want. Let''s
    get started:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your Blueprint of BP_VRPawn, and hit Class Settings on the toolbar:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f4ac2f82-d94c-452f-8fe0-d1a6e71d0d11.png)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
- en: We mentioned earlier that Unreal Engine is an **object oriented** system. An **object** is
    an instance of a **class**, and classes **inherit** from other classes, taking
    on their abilities and characteristics as they do. This is where that becomes
    important. We're going to change the capabilities of our BP_VRPawn by changing
    its parent class to a child of the Pawn class that contains the component we need.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Details | Class Options, change Parent Class from Pawn to Character:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8a164f4b-9843-45c0-95bd-da158fde6cbe.png)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
- en: 'If you look at your Components tab, you''ll see that a few new components have
    appeared:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/471bc9c7-6b98-415e-8248-b5306e4372d3.png)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the components we created earlier on, we now have the following:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: A Capsule component
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Arrow component
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Mesh component
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Character Movement component
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all inherited from the `Character` class.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: This is useful. We need the Movement component to allow us to move around, and
    we need the Capsule component to keep us from walking through walls. We don't
    really need the Mesh component, since we're not rendering the player pawn's body,
    but it doesn't hurt us in this instance to have it here and just leave its Skeletal
    Mesh property empty for now.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when changing an object's parent class. If the class you're changing
    to is a child of the previous parent class, that's generally going to be a safe
    change, because it will add new elements, but the parent's properties and functions
    will still be there. Going from a child class to a parent class can be riskier,
    since you may be relying on properties or functions that exist on the child, but
    don't exist on the parent. Changing to a class that's very different from your
    current class will probably create problems. It's fine if you know what you're
    doing, and the engine won't stop you, but you'll probably wind up cleaning up
    a lot of invalidated function calls or variable references.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the collision component
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you run the game now, you''ll see that we''re floating a little higher above
    the floor than we were previously. This is because our Capsule component is colliding
    with the floor and pushing us upward. To fix this, open your Pawn''s Viewport
    tab. (If you''ve closed it, you can reopen it by double-clicking the BP_VRPawn(self)
    entry on your Components tab.) Let''s get started:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Alt* + *K* to switch your viewport to a side view.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grab your Camera Root and drag it downward until it''s sitting at the bottom
    of the Capsule Component. Its location should now be (0.0, 0.0, -90.0):'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/9d554b16-7b84-42c7-8771-950af5758fa4.png)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
- en: If you run the game again, you'll find that you're properly on the floor.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: Handling movement input
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve given our pawn a movement component, let''s use the input bindings
    we mapped a moment ago to allow us to move around:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click in your pawn''s event graph and create an Input | Axis Events |
    MoveForward event:'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc61e844-ba4b-4a61-98ff-052b8ec60503.png)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
- en: Do the same for the MoveRight event we created in our axis bindings.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have two events that will run every frame, and allow us to feed movement
    input to our movement component.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: Create an Add Movement Input node, and connect its execution input to the output
    of InputAxis MoveForward.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Axis Value of MoveForward into the movement input's Scale Value.
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat this for InputAxis MoveRight:'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c6c2c89a-e340-41d8-a7b6-d59b6597cd29.png)'
  id: totrans-603
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to tell it the direction we''d like to move in:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Grab your Camera component from your components list, and drag it onto your
    event graph.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From its output, create a GetWorldRotation node.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the GetWorldRotation output and split the struct pin.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the graph and create a Get Forward Vector node.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Split its input pin.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Yaw output from GetWorldRotation to the In Rot Z (Yaw) input in
    Get Forward Vector.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click to create a Get Right Vector node.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Split its input, and connect Yaw output of GetWorldRotation to its In Rot Z
    (Yaw) input.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output from Get Forward Vector to the World Direction input to Add
    Movement Input of InputAxis MoveForward node.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the output from Get Right Vector to the MoveRight Add Movement Input:'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/799912e0-21eb-4e11-b2dc-8a9d89b53da6.png)'
  id: totrans-615
  prefs: []
  type: TYPE_IMG
- en: Let's give it a try in-game.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: We can still teleport using our right trackpad or thumbstick, but if we use
    the left input, it slides us smoothly through the world using our camera's look
    direction as the forward direction.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: Gamers that are used to first-person shooters are used to thinking of their
    camera direction as their forward direction. In VR, this doesn't have to be the
    case—it's perfectly reasonable for a character to be looking to the right while
    moving to the left. Our pawn has a concept of *Control Rotation*, which is its
    actual orientation in space, and is distinct from the direction the camera is
    facing. In practice, if you're going to drive movement from a pawn's control rotation
    rather than camera rotation, you need to provide visual cues to make it clear
    to the player exactly what their forward orientation is, or your movement scheme
    will just confuse them. To keep things clear in this instance, we've made our
    movement relative to the look direction.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: This works well enough, but it has some problems.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: Fixing movement speed
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''re moving too fast. Let''s fix this:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: 'Select your pawn''s CharacterMovement Component, and in Details | Character
    Movement: Walking, set its Max Walk Speed to 240.0'
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's a much more reasonable speed for walking through the world.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Letting the player look around without constantly steering
  id: totrans-624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s face it. Using the camera forward vector as the basis for our steering
    feels a little janky. Every time you turn your head to look at something, you
    have to steer to correct yourself. The world doesn''t work that way. Let''s use
    the orientation of the left controller as the basis for our movement instead:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: Grab the `MotionController_L` component and drag it into the event graph near
    where we're currently getting the Camera's world rotation.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feed MotionController_L component''s output into the GetWorldRotation node,
    replacing the Camera''s connection:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/38ba6cf2-cf89-4b75-918c-67436a637a46.png)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
- en: Now, instead of using the Camera's Yaw as our basis for our forward and right
    world directions, we're using the controller, which makes intuitive sense. Forward
    is wherever you're pointing the controller, and meanwhile, the player can execute
    fine movements using the trackpad or joystick. They can steer by pointing in the
    direction they want to go and can look around without affecting their movement.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: Implementing snap-turning
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we need to give the player is a way to change their orientation
    without having to spin their chair around in the real world.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: 'While it works well to allow your players to move smoothly through the world
    like we just have, we don''t want them to turn smoothly. We discussed the reason
    for this in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml), *Thinking
    in VR*, but to recap here, visually induced motion sickness arises when players
    see movement that they don''t feel. We''re especially attuned to movements that
    appear to be spinning. This likely arises from a number of reasons:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: A sense of spinning is a natural effect of disruptions to the vestibular system
    from poisoning. Ever had the bed-spins after a rough night out? What happened
    next? Right. Don't do that to your player.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vestibular disconnect is strongest when there's a lot of optic flow in the image.
    When the player is rotating, nearly everything in the frame is moving to the side.
    That's a lot of movement.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the real world, we naturally blink when rotating our head, or we aim our
    eyes first at the thing we want to look at (this movement is called a **saccade**),
    and then turn our head to follow. In the real world, we don't keep our eyes steady
    while we turn around.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snapping the player through a turn rather than allowing them to turn smoothly
    not only avoids creating a huge optic flow that's likely to make your user sick,
    but it actually does a better job of replicating the way we actually perceive
    turning in the real world than a smooth turn does.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: Let's set up a snap turn.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Setting up inputs for snap turning
  id: totrans-638
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a pair of action bindings to snap right and left:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Open your Project Settings | Engine | Input.
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two new Action Mappings in Engine | Input | Bindings. Name them `SnapTurnRight` and
    `SnapTurnLeft`.
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind SnapTurnRight to MotionController (L) FaceButton2.
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind SnapTurnLeft to MotionController (L) FaceButton4 and MotionController (L)
    FaceButton1.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re binding two inputs to SnapTurnLeft to accommodate both Oculus and Vive
    inputs. On Oculus Touch controllers, FaceButton1 on the left controller is the
    X button, while FaceButton2 is the Y button. On the HTC Vive, FaceButton2 is the
    left-hand side of the trackpad, and FaceButton4 is the right-hand side of the
    pad:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d05f8efb-9a27-42f1-aadd-3b6bdc73ad42.png)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
- en: Your input bindings should now look like this.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: We can close our project settings now.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: Executing the snap turn
  id: totrans-648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s execute a snap turn when these buttons are pressed:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: 'In your pawn''s event graph, add input events for your SnapTurnLeft and SnapTurnRight
    actions:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1f902968-f3a2-4811-b911-d60686b9663b.png)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
- en: Create a GetActorRotation node and split its output.
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the Return Value Z (Yaw) output and create a float - float node.
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out from the subtraction node's second input and **promote** it to a variable.
    Name the variable `SnapTurnIncrement`.
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile your Blueprint and set the SnapTurnIncrement value to 30.0.
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a SetActorRotation node, and connect the **GetActorRotation** node's
    Roll and Pitch outputs directly to their corresponding inputs.
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the result of your subtraction to the Yaw input.
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Pressed execution output from InputAction SnapTurnLeft to the SetActorRotation
    node's input.
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select these nodes and press *Ctrl* + *W* to duplicate them.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the subtraction in the duplicated set with an addition.
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the duplicated nodes to execution of the InputAction SnapTurnRight
    output:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57e4c842-4bb3-48de-9eaf-6769f4330942.png)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
- en: Give it a shot in-game. It's not bad. We could improve it further for sure—right
    now, snap turning triggers movement as well, but it's a pretty usable solution.
    If it made sense for our game, we could potentially map down a press on the Vive
    trackpad or a joystick press on the left Oculus Touch to a 180° turn.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: Going further
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few ways we could improve the work we've done here, but implementing
    them fully would fall outside the scope of this chapter. Let's take a brief moment
    to talk about ways you could improve on this class as you take things further.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: Snap turn using analog input
  id: totrans-666
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our current snap turn implementation works reasonably well on Vive wands, but
    doesn't feel great on Oculus Touch controls. It might feel better for our players
    to listen to the analog input from one of the thumbsticks and trigger a snap turn
    if it exceeds a certain threshold. This way, players could flip the thumbstick
    to the side to execute the snap, or just touch the edge of a Vive trackpad without
    having to press it.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: You could execute this by setting up an input axis binding on a motion controller
    thumbstick, and testing to see whether the input is greater than a threshold amount
    (for this test, we used 0.8) for a right turn or less than the negative threshold
    for a left turn.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: You'll need to remember to put a cooldown onto the snap so that it doesn't trigger
    repeatedly from a single press. In our case, we used a cooldown duration of 0.2.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''d like to build this into your pawn, here are the steps:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: Create an input event handler for your MotionControllerThumbRight_X input axis.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Branch, and only continue if `bTeleportPressed` is False. We don't
    want to process snap turns while we're teleporting.
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Boolean variable called `bSnapTurnCooldownActive`.
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Branch, and only continue if `bSnapTurnCooldownActive` is False.
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new float variable called `SnapTurnAnalogDeadzone`, compile, and set
    its value to 0.8.
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a >= test to see whether the incoming Axis Value from your thumbstick input
    is greater than or equal to `SnapTurnAnalogDeadzone`.
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Branch from this, and on its False output, create another Branch.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this second branch, test to see whether the incoming Axis Value is less
    than or equal to the negative SnapTurnAnalogDeadzone (multiply it by -1.0).
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bdb7c99f-4f74-419f-8777-6adc185455c7.png)'
  id: totrans-679
  prefs: []
  type: TYPE_IMG
- en: Create a new Custom Event called ExecuteSnapTurnLeft, and feed it into the SetActorRotation
    call you're making from InputAction SnapTurnLeft.
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create another one called ExecuteSnapTurnRight, and feed it in where InputAction
    SnapTurnRight is being handled:'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73b934fb-ddbd-4ba0-959f-84b9efa86ff0.png)'
  id: totrans-682
  prefs: []
  type: TYPE_IMG
- en: Now, back on your ThumbstickRight handler, call ExecuteSnapTurnRight if the
    Input Axis was >= SnapTurnAnalogDeadzone.
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call ExecuteSnapTurnLeft if the Input Axis was <= -SnapTurnAnalogDeadzone.
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e8ea2743-287e-434e-9f87-a628e146719e.png)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to set a cooldown so that we don''t get a rapid-fire series of
    snap turns when the user moves the stick:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: Add a setter to set bSnapTurnCooldownActive to true, and call it after both
    ExecuteSnapTurnRight and ExecuteSnapTurnLeft.
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a delay. The default value of 0.2 is fine here, but if you wanted to tune
    your cooldown duration, promote this value to a variable.
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the delay, set bSnapTurnCooldownActive to False again.
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c55b1d36-b0cb-4178-8381-8d5e2750dd8c.png)'
  id: totrans-690
  prefs: []
  type: TYPE_IMG
- en: With this Boolean flag and delay, we're simply setting up a gate whereby the
    snap turn input will be ignored for 0.2 seconds after the last time it was handled,
    which gives the user time to release the stick once they're oriented where they
    want to be.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: This implementation gives your player a nice natural-feeling snap turn on the
    right stick while leaving the left stick for analogue seamless movement.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-693
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We did quite a lot in this chapter.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned how to set up and refine a navigation mesh in our scene and how
    to find and fix collision problems with objects in our scene. We learned how to
    set up input actions and use them to move our player character around, and perhaps
    most importantly, we learned Kent Beck''s mantra for software development: *Make
    it work, make it right, make it fast*, and learned what it means to follow it
    as we pursue iterative development. We''re going to revisit this a lot. It''s
    a secret to effective software development.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: That was a lot of work. The exercises in this chapter covered a lot of ground,
    but should have left you with a decent sense of how the parts fit together when
    setting up a player pawn and a locomotion system.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've given our pawn feet, in the next chapter, we're going to give
    it hands. We'll learn how to use motion controllers to point, grip, and interact
    with objects in the world. We'll also build on what we've learned about setting
    up navigation meshes and drop some AI into the world to use them as well. Now
    that we can get around the world, we're going to start bringing it to life.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
