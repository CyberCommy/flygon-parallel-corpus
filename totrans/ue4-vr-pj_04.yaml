- en: Getting Around the Virtual World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to take the pawn we built in the previous chapter
    and get it moving through the world. We'll begin with a commonly employed teleport
    movement scheme and cover a wide range of tasks that go into setting it up. We'll
    learn about navigation meshes in our environment, how to set up input events in
    our project and use them in Blueprints, and how to build a player pawn Blueprint
    and get it moving around the world. Finally, we'll also explore an immersive seamless
    locomotion scheme that you can use to allow your players to move through the world
    without teleporting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the course of this chapter, we''ll be discussing the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigation meshes—what they are, how to set them up in your level, and how to
    refine them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a Blueprint for your player pawn, and how to create input events
    that your pawn can use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to perform traces, using both straight lines and curves, to find legal target
    locations in your environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create simple in-game indicators to show players what's going on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a seamless locomotion scheme to provide immersive movement
    for projects where teleportation wouldn't be appropriate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is going to be a lot of ground to cover, but it should be fun, and you're
    going to come away with a good grounding that's going to help you to figure out
    how to develop the things you want, and how to understand what other developers
    are doing when you see their Blueprints. We're going to take a slightly different
    approach in this chapter from the way most tutorials are done. To be an effective
    developer, it's far more important to learn how to think about a problem than
    simply to memorize a series of steps that may not apply to the next problem you
    face. In this chapter, we're going to walk through the processes of building elements
    and then, in some instances, *discover* bugs in them. Afterward, we'll need to
    change things to fix these bugs. This is where the real value in this approach
    lies—you'll begin to get a sense of how to develop software through iteration,
    which is the way it's really done. The goal here isn't to make you good at building
    these tutorials—it's to help you to become a developer who can make whatever you
    dream up on your own.
  prefs: []
  type: TYPE_NORMAL
- en: With that being said, let's get building!
  prefs: []
  type: TYPE_NORMAL
- en: Teleport locomotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml),
    *Thinking in VR*, one of the biggest challenges we face in VR is motion sickness
    that's triggered when the user tries to move around. One of the most commonly
    used solutions for this is to *teleport* the user from place to place rather than
    to allow them to move smoothly through the space. This breaks immersion, but avoids
    the problem of motion sickness entirely because it doesn't create a sense of motion
    at all. For applications where immersive movement isn't a priority, such as architectural
    visualization, this may be an ideal scheme to employ.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a navigation mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we're going to need for a teleport-based locomotion scheme is
    a way to tell the engine where players are allowed to move and where they aren't.
    We can use a *navigation mesh* to do this job.
  prefs: []
  type: TYPE_NORMAL
- en: A **navigation mesh**, often shortened to **navmesh**, is an automatically generated
    set of surfaces indicating walkable floors in an Unreal level. AI-controlled agents
    use the navigation mesh to find their way around the world, but it can also be
    used as a way to identify safe destinations for the player pawn to land, as we're
    doing here in our teleport system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a navmesh in Unreal is fairly simple. From your Modes panel, select
    the Volumes tab, and find the NavMesh Bounds Volume. Drag it into your scene,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff62bd89-e770-45fb-8353-9dfaac605ff5.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the Nav Mesh Bounds Volume from Modes | Volumes
  prefs: []
  type: TYPE_NORMAL
- en: Moving and scaling the Navmesh Bounds volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The NavMesh Bounds volume needs to surround any floor where you''d like the
    player to be able to teleport. Let''s make our navmesh visible so that we can
    see where the walkable floors are being set up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hit the *P* key to toggle navigation visibility or, from the viewport menu,
    select Show | Navigation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0fa82e83-9f5d-4ec3-93e0-219af714867f.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the P key or Show | Navigation to display the generated navmesh in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't see any navigable space after you've placed a NavMesh Bounds volume,
    make sure it's intersecting a walkable floor. The volume sets the boundaries for
    the navmesh generation, so if it's above the floor, it won't generate anything.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this NavMesh Bounds volume we just placed is far too small. Let's
    extend it to cover the space in which we'd like to move. We're going to do this
    by scaling the volume.
  prefs: []
  type: TYPE_NORMAL
- en: Hit the *R* key to switch to scaling mode, or just tap the *spacebar* until
    the scaling gizmo appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could scale the volume from the perspective view, but for this kind of operation,
    it's often a good idea to go to an orthographic view so that we can really see
    what we're doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hit *Alt* + *J* or use the viewport''s view selector to switch to a top view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00012d43-9bf3-423a-97bf-09296f64b3d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Switch to an orthographic top view using the menu or its associated shortcut
    key.
  prefs: []
  type: TYPE_NORMAL
- en: Scale the navmesh to surround the walkable area of the building.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With your navigation visible, you can see where it''s generating navmesh surfaces
    and whether it''s doing a sensible job of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a43840c2-2d94-4263-aac9-5f780232ff57.png)'
  prefs: []
  type: TYPE_IMG
- en: A top view of our level showing the extents of the NavMesh bounds volume
  prefs: []
  type: TYPE_NORMAL
- en: In our case, parts of the building that we expect to be walkable aren't yet
    covered. This is because we haven't yet done anything with the height of our bounds
    volume, and these areas are too high or low to fit inside it. Let's jump to a
    side view to fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Alt* + *K* to jump to the left view, or select Left from your viewport
    view selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scale the bounds volume to a scale that reasonably covers the floor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/670062aa-f965-46ee-9c43-1492e0f2e2ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Side view of the level. You can see here that we're scaling the navmesh bounds
    volume to encompass the floor
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Alt* + *G* to jump back to a perspective view and see how we're doing.
    Alternatively, you can select Perspective from your view selector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's worth memorizing these keystrokes for changing views. You'll use them all
    of the time, and it's handy to be able to switch quickly. *Alt* + *J*, *K*, and
    *H* switch view angles. *Alt* + *2* switches to a wireframe view, and *Alt* +
    *4* switches back to a shaded view. There are plenty of other hotkeys, but you'll
    use these the most.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we fly to the back of the temple, we can see that we have a problem here.
    Our navmesh didn''t generate as expected in the back corridor. Let''s figure out
    what''s going on here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98ead175-7c85-4f0e-92e7-24b590a92b9a.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we can see that part of our level hasn't been properly covered by the navmesh.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing collision problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are almost always two reasons why a navmesh isn''t generating where you
    expect it. Either your volume isn''t surrounding the area where you''re trying
    to generate the mesh, or there''s something wrong with the collision in the area.
    Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Alt* + *C* to view the collision in the back hall, or hit Show | Collision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It doesn't appear that there's any stray collision encroaching into the hall,
    so it's probably a missing collision on the floor.
  prefs: []
  type: TYPE_NORMAL
- en: Select the floor in the bad area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In its details, find its Static Mesh and double-click it to open it up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/de446944-4748-46f2-8b0e-a9430387c643.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the Details panel to find the static mesh for the bad floor region.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Static Mesh Editor, select the Collision toolbar item and make sure
    that Simple Collision is checked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2b4a5c4f-4080-4f17-af62-b903b1603ca6.png)'
  prefs: []
  type: TYPE_IMG
- en: View simple collision for the static mesh
  prefs: []
  type: TYPE_NORMAL
- en: Sure enough, our simple collision is missing. Let's fix this.
  prefs: []
  type: TYPE_NORMAL
- en: Select Collision | Add Box Simplified Collision to add a simple collision plane
    to our floor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s much better. We should now see that the navmesh we expect has been
    generated back in our main level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6841a774-5537-445a-853b-887083fada8e.png)'
  prefs: []
  type: TYPE_IMG
- en: Simplified collision created for our floor mesh
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let's take a second to talk about what's going on here. A
    very common thing we need to do in real-time software is figure out when an object
    has hit another object. Unreal uses *collision meshes* to do this. A collision
    mesh is simplified geometry that's used to check for intersections with other
    collision meshes in the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actors have two of these:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Complex Collision** mesh. This is simply the model's visible mesh.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Simple Collision** mesh. This is a much less detailed convex mesh that surrounds
    the object. These are often generated when an object is imported, or can be created
    explicitly in the DCC where the model was created. If it's missing, you can create
    a simple collision in the editor, like we've done here. As a last resort, you
    can set Details | Collision | Collision Complexity to Use Complex Collision As
    Simple to use the object's visible mesh for all collision calculations. Don't
    do this for a mesh with a ton of polygons, though. It's expensive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection and handling is its own fairly deep topic and beyond the
    scope of this book, but for our purposes in VR development, we're going to care
    a lot about the simple collision meshes of our objects, because we'll use these
    as walkable surfaces to detect when another object hits them, to detect whether
    we can grab them, and for many other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding areas from the navmesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking around our map, we have a few more problems we need to fix. Our Navmesh
    Bounds Volume is generating a navmesh in a few areas where we don''t want our
    players to teleport. Let''s fix this, too:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Alt* + *2* to switch to a wireframe view, or use the viewport's View Mode
    selector to switch to wireframe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We probably have a few problems we can fix just by adjusting the scale of the
    NavMesh Bounds volume. If we have navmesh generating on rooftops or window sills,
    let's reduce our Bounds volume's vertical scale to exclude these areas if we can.
    This is an area where hitting *Alt* + *K* to jump to a side view can help.
  prefs: []
  type: TYPE_NORMAL
- en: If our NavMesh Bounds volume is spreading further outside the building than
    it needs to, we can jump to a top view using *Alt* + *J* and adjust it to fit
    better.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re still going to have a few leftover stray areas that we''ll want to exclude,
    and that can''t simply be fixed by scaling the volume. For these, we''ll use Nav
    Modifier Volumes. Refer to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Grab a Nav Modifier Volume from your Modes palette and drag it into the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move and scale it until it surrounds an area where the unwanted navmesh is being
    generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll see the navmesh in this region disappear when the nav modifier volume
    surrounds it. Take a look at the nav modifier volume properties in your Details
    panel. Do you see that Default | Area Class is set to NavArea_Null? This tells
    the navmesh generator to omit generating a navmesh in this region. You can see
    from the pulldown menu that it can also be used to mark obstacles and crawlspaces,
    but for what we're doing here, we don't care about these. We're just interested
    in using it to clear out unwanted navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag as many of these into your scene as you need to clean up the stray bits.
    You can hold down the *Alt* key while dragging a modifier volume to duplicate
    it, or hit *Ctrl* + *W* to make a copy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/27229d49-ac56-4fe2-bdba-32a5ebdc9449.png)'
  prefs: []
  type: TYPE_IMG
- en: A perspective wireframe view can be useful for finding problems with your navigation
    coverage.
  prefs: []
  type: TYPE_NORMAL
- en: You'll find it helpful to memorize the transform hotkeys as you're moving objects
    around. *W* activates the Translate tool, which allows you to slide an object
    around. *E* activates the Rotate tool, and *R* activates the Scale tool. Tapping
    the *spacebar* also cycles through these tools. *Ctrl* + *W* duplicates an object,
    and holding *Alt* while dragging an object also copies it.
  prefs: []
  type: TYPE_NORMAL
- en: When you're done, you should have a collection of Nav Modifier Volumes blocking
    off areas you don't want your player to stand on.
  prefs: []
  type: TYPE_NORMAL
- en: Fly through your level and make sure you don't have any weird navmesh where
    you don't want it. Where you find problems, fix them by scaling your navmesh bounds
    volume, or adding nav modifier volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying your navmesh properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one other thing you should know about before we move on, and that's
    where to adjust the properties for the navmesh you've just generated.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to change anything about its behavior, select the `RecastNavMesh`
    object, which will have been created in your level. In its Details panel, you
    can see properties governing its generation, querying, and runtime behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re not going to go into these here except to call attention to one of these
    properties: if you wanted to adjust the size of an area into which your player
    could fit, you can adjust the Agent Radius to do so. Making this smaller will
    allow your player to fit into tighter spots. Similarly, you can adjust the Agent
    Height and Max Height to determine acceptable ceiling heights under which navigation
    should be generated. Generally, you''ll want to make changes to these values before
    you go crazy fine-tuning your nav modifier volumes since changes here will change
    where your navmesh is generated. For our purposes, we''re going to leave these
    values alone.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the pawn Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our navigation built and tuned in our scene, we can turn off
    navigation visualization by hitting *P*, and start working on our locomotion behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a teleport locomotion scheme, we need to do three jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: Figure out where the player wants to move
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure out where the player is actually allowed to move
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move the player to the new location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get to work.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to develop this method iteratively, the way you really would if
    you were developing it from scratch. Most tutorials simply walk you through the
    steps to build a finished method, but the problem with this approach is that it
    doesn't teach you *why* you're doing the things you're doing. As soon as you want
    to do something similar, but not exactly the same, you're back to square one.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we're going to work in stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kent Beck, a pioneering software developer, gives this advice to developers:
    *Make it work, make it right, make it fast.*'
  prefs: []
  type: TYPE_NORMAL
- en: What's important here is the order in which you do things. It seems almost obvious
    at first, but few developers get it right when they're starting out. You'll save
    yourself a lot of heartache if you work in this order.
  prefs: []
  type: TYPE_NORMAL
- en: Make it work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build a rough assembly of what you're trying to do. Test it early and often.
    Build it to be easy to test and easy to change. Change things around until you're
    satisfied that it's doing the right work.
  prefs: []
  type: TYPE_NORMAL
- en: Make it right
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know what your code needs to do, figure out how you should really
    organize it. Are there better or cleaner ways to do what you're trying to do?
    Are there parts that can be reused? Will this code need to be used anywhere else?
    Could you debug it if you had to? Use the work you did in the *make it work* phase
    as a starting point, but now that you understand what you really need to do, write
    it correctly. It's okay to make a mess in the first stage (in fact, you're probably
    doing it wrong if you're not making a mess), but clean that mess up in this phase.
  prefs: []
  type: TYPE_NORMAL
- en: Make it fast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have reasonably clean code that's doing the right job, look for ways
    you could get it running faster. Is there a result that you're generating more
    than once that you could cache to a variable and reuse? Are you checking conditions
    repeatedly, even though you know they can only change when certain things happen?
    Are you copying data that you could just read from its original location? Figure
    out what you could be doing more efficiently, and speed things up where you can.
    Be careful here, though. Some optimizations are so minor that they may not really
    make a noticeable difference to the running application. Go for the big ones,
    and use profiling tools to understand where your problems really are. You want
    to make sure you're optimizing things that are really going to make a difference.
    Also, be careful about making your code more difficult to read or debug as you
    optimize it. A change that shaves a tiny amount off of your frame time but makes
    a class difficult or impossible to update or maintain might not be worth it. Use
    judgment when optimizing.
  prefs: []
  type: TYPE_NORMAL
- en: Do things in order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many new developers mess this order up, and start trying to optimize their code
    before they've really made sure they're doing the right thing. This just wastes
    time, as there's a high likelihood that some of that code will be thrown out.
    Other developers skip the *make it right* phase, and consider their work done
    as soon as it seems to work. This is a mistake too, as 80% of the life cycle of
    a piece of code is spent maintaining and debugging it. If your code works but
    it's a mess, you're going to burn a lot of extra time trying to keep it running
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: Problems that are created by rushed or sloppy work early in development are
    often referred to as *technical debt*. This is stuff you're going to have to fix
    later because, even though it runs, it may not be flexible or robust, or might
    just be an unreadable shambles. The time to clear your technical debt is right
    after you've finished your *make it work* phase, and before you've moved onto
    other things and started to build more code on top of something that needs to
    change.
  prefs: []
  type: TYPE_NORMAL
- en: Working in this order and thinking of these as discrete stages will make you
    a more effective developer.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a line trace from the right motion controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin with the first thing we need to do to get our teleport running—figuring
    out where the player wants to go:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up our BP_VRPawn Blueprint, and open My Blueprint | Graphs | EventGraph,
    if it isn't already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should still see the `BeginPlay` event in our Event Graph where we set our
    tracking origin. Now, we're going to add some code to our Event Tick.
  prefs: []
  type: TYPE_NORMAL
- en: The Tick event is called every time the engine updates the frame. Be careful
    about putting too much work into your Tick events, as they can eat performance.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't already see an Event Tick node in your Event Graph, right-click
    anywhere in the graph, type `tick` in the search box, and select Add Event | Event
    Tick. If you already have a Tick event defined, this won't add a new one—it'll
    just take you to that node in the event graph. If you don't, this will create
    one now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click to the right of Event Tick, and add a Line Trace by Channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you perform a line trace, you supply a *start* point and an *end* point,
    and tell it what *collision channel* you're looking for. If an actor with a collision
    set to the supplied collision channel intersects the line between the start and
    end points, the trace will return `true`, and will return information about what
    it hit. We're going to use this behavior to find our teleport destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start our trace at the location of the right motion controller:'
  prefs: []
  type: TYPE_NORMAL
- en: From your components list, grab `MotionController_R`, and drag it into your
    event graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to start our trace at the motion controller's location, so let's drag
    a connector out from the `MotionController_R` return value and release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the dialog that appears, type `getworld` into the search bar and select
    GetWorldLocation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8c4a8a1c-1a1b-4ed3-9112-4bded8efdbb2.png)'
  prefs: []
  type: TYPE_IMG
- en: Blueprint node creation is context-sensitive by default. This means that if
    you're dragging a connection from another object, you'll only be shown actions
    that would be appropriate for that object.
  prefs: []
  type: TYPE_NORMAL
- en: Drag the result of `GetWorldLocation` into the Line Trace node's Start input
    pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's set the trace end point. We're going to end our trace at a point
    10,000 units away from our start location, in the direction the controller is
    facing. Let's do a bit of simple math to figure out where that point is.
  prefs: []
  type: TYPE_NORMAL
- en: From the `MotionController_R` output, create a `Get Forward Vector` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will return a vector with a length of 1 that aims in the direction the
    controller is facing. We said we wanted our end point to be 10,000 units from
    the start, so let's multiply our Forward vector by that value.
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `Get Forward Vector` return value out and type `*` into the search
    bar. Select vector * float.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, drag a connector out from the float input to the multiply action, and
    select Promote to Variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dc6c864-8c13-42cd-8b29-f11331716833.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a fast way of creating variables in Blueprint. You can simply drag out
    from an input, select Promote to variable,
  prefs: []
  type: TYPE_NORMAL
- en: and a variable will be created with the correct type for the input
  prefs: []
  type: TYPE_NORMAL
- en: Name the new variable `TeleportTraceLength`, compile the Blueprint, and set
    the variable's value to `10000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You could have simply typed `10000` directly into the multiplication action's
    float input, but it's bad practice to do so. If you start hiding values all over
    the place in your Blueprints, you'll have a hard time finding them later on when
    you need to change them. Also, a number typed into an input doesn't do anything
    to explain what it is. A variable, on the other hand, can be given a name that
    describes what's actually going to change if its value is changed. Numbers buried
    without explanation in your code are called *magic numbers* by developers, and
    they're an example of *technical debt*. They're just going to turn into a hassle
    for you later on when you need to maintain or debug your code. Unless the use
    of a value is absolutely obvious in its context, use a variable instead, and give
    it a meaningful name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a vector that''s 10,000 units long, aiming in the controller''s
    forward direction, but right now it would be running 10,000 units from the world''s
    center, rather than from the controller, as we intend. Let''s add the controller''s
    location to this vector to fix that:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag another connector from the controller's `GetWorldLocation` call, and type
    `+` in the search bar. Select vector + vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the output from our forward vector multiplication into the other input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the output of this addition to the End argument of `LineTraceByChannel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eab371d1-f1f2-49ec-8133-60cc9422839a.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we move on, let's set up some debug drawing to see whether everything
    is behaving as we expect so far.
  prefs: []
  type: TYPE_NORMAL
- en: Hold down the *B* key and click on the open space to the right of the `Line
    Trace` node to create a `Branch` node. (You can also right-click and create a
    Branch node the way you usually do, but this is a useful shortcut.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from the `Line Trace` node's Boolean Return Value to this branch's
    Condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The trace operation will return `True` if it hits something, and `False` if
    it doesn't. We're only interested in debug drawing the result if it hits something,
    so we're just going to use the `True` output from our branch.
  prefs: []
  type: TYPE_NORMAL
- en: If we did hit something, we need to know where the hit occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a connector from Out Hit and select Break Hit Result to see the members
    of the hit result struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **struct** is a bundled collection of variables that can be given a name and
    passed around as a single unit. The `Hit Result` struct is a commonly used struct
    that describes the properties of a detected collision, telling you where it occurred,
    what actor was hit, and many other details. Calling **break** on a struct allows
    us to see its contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s draw a debug line representing our trace:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag an execution line from our `Branch` node's `True` output, and create a
    `Draw Debug Line` action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Location from the `Hit Result` struct into the Line End input on the
    `Debug Line` call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the hit result's Trace Start to the Line Start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the line's thickness to `2`, and set its color to anything you like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While we''re at it, let''s draw a debug sphere at the hit location:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Draw Debug Sphere` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect its execution input to the debug line's output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its Center to the hit result''s Location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6142e634-b112-4a9c-a7f0-9f7ff46603cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Be aware that `Draw Debug` calls only work in development builds. They're useful
    for understanding what's going on, but they're just debugging tools and need to
    be replaced with real visualizations for your actual software. We'll do that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it. Your result should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0c4a2841-f8a2-4b08-8320-c23637ed28a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Good. So far, it's doing what we expect—casting a ray from the controller, and
    showing us where it hits a surface. The problem, though, is that it's just as
    happy to hit a wall as a floor. We need to restrict it to valid teleport destinations.
    Let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our Trace Hit Result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to do this first by setting up a simple test that only accepts
    surfaces facing upward. We''ll do this by using a vector operation called a *Dot
    Product* to compare a surface normal with the world''s up vector. Follow these
    steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click somewhere to the right of our hit result breakout, and create a
    Dot Product node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Normal from the hit result into the first input, and set the second
    input's *Z* value to 1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *normal* is a vector that's perpendicular to the surface from which it extends.
    A *dot product* is a mathematical operator that returns the cosine of the angle
    between two vectors. If two vectors are exactly parallel, their dot product will
    be 1.0\. If they're facing exactly in opposite directions, their dot product will
    be -1.0\. If they're exactly perpendicular, the dot product is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Since the vector (0,0,1) is the world's up vector, by testing the dot product
    of a surface normal against this vector, we can find out whether or not the normal
    is facing upward by checking whether the dot product is greater than 0.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a connector from the result of the dot product, and select the `>` operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another branch operator using this result as its Condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Alt* + click the execution input to the Draw Debug Line node to disconnect
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a new execution line from the return value's branch to this new branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the True output from the dot product''s branch with our Draw Debug
    Line node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ecccc094-918f-4fe3-b345-7473fb1a6cfb.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's test it. We'll see that we now see the debug sphere drawn when our ray
    hits a floor, but not when it hits a wall or a ceiling. As we mentioned a moment
    ago, this is because the dot product of a wall's normal versus the world's up
    vector will be 0, while the dot product of a ceiling against the world up is -1.
  prefs: []
  type: TYPE_NORMAL
- en: This is better, but what about the places we decided we didn't want the player
    to go? We spent all of that time setting up our navmesh bounds and navmesh modifiers,
    and we're not using them yet. We should fix this.
  prefs: []
  type: TYPE_NORMAL
- en: Using navmesh data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''re going to take our test a step further, and look for the nearest
    point on the navmesh to wherever our pointer is pointing:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in our graph, and create a Project Point to Navigation node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect our hit result's Location output to this new node's Point input
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the node''s Projected Location output with the debug line''s Line End and
    the Debug Sphere''s Center, replacing the location inputs that we''d previously
    been using there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/38f742b8-1c43-4944-9ef9-e158f40cdcfd.png)'
  prefs: []
  type: TYPE_IMG
- en: What we're doing here is querying the navmesh we created to find the closest
    point on the mesh to the location we supplied. This will prevent a location from
    being selected that we'd excluded from our mesh.
  prefs: []
  type: TYPE_NORMAL
- en: As we look around the scene, though, we can start to see that we're going to
    have a problem. Casting a ray straight from the controller isn't going to allow
    us to teleport onto higher locations than where we're currently standing, because
    the ray won't be able to hit the higher floor. This is a flaw in our system, and
    we're going to need to rethink this.
  prefs: []
  type: TYPE_NORMAL
- en: This is why it's so important to stick to our guns and do a *make it work* phase
    before we put a ton of work into cleaning up. It often happens that your first
    running prototype will reveal things you need to rethink, and it's better to discover
    these things early, before you've burned a ton of effort.
  prefs: []
  type: TYPE_NORMAL
- en: Changing from line trace to parabolic trace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thinking it through, it becomes clear that we''re going to need a curved path
    to reach points that are higher than our current viewpoint. Let''s modify our
    trace method to make this possible. This is the result we will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fdd3794-85d5-4feb-946b-1ad0f19576bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The math used to calculate a parabola is actually fairly simple, but we have
    an even easier option available to us. The `Predict Projectile Path By TraceChannel` method
    already handles the math for us and can save us some time. Let''s use this now:'
  prefs: []
  type: TYPE_NORMAL
- en: Disconnect our Event Tick from the old Line Trace By Channel node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in our graph and create a Predict Projectile Path by TraceChannel node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect it to our Tick.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Trace Channel to Visibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, connect the output from the GetWorldLocation of MotionController_R to
    the Start Pos input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get our Launch Velocity, we''re going to take the Forward Vector of MotionController_R,
    and multiply it by an arbitrary value:'
  prefs: []
  type: TYPE_NORMAL
- en: Disconnect the old `TeleportTraceLength` variable from the Multiply node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag out a new connector from the Multiply node's float input and promote it
    to a variable. Let's name it `TeleportLaunchVelocity`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile our Blueprint, and give it a value of 900.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Connect the result to the Launch Velocity input:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ce8fc76f-f782-44d0-9420-f587a65d1c6d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's draw the resulting path so that we can verify that it's doing what
    we expect.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the curved path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Predict Projectile Path By TraceChannel` method is going to return an
    array of points describing the path of the parabola. We can use these points to
    draw our targeting indicator. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did previously, connect a Branch to our Return Value. We're only
    interested in drawing anything if we got a good result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, to draw the curved path, we're actually going to have to draw a series
    of debug lines instead of just one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s drag a connector from Out Path Positions and create a ForEachLoop node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e8df5cc7-1db3-44b9-b132-6ec6f6f8e7aa.png)'
  prefs: []
  type: TYPE_IMG
- en: We should take a moment to talk about what we're doing here, since this is a
    concept you'll use quite a lot.
  prefs: []
  type: TYPE_NORMAL
- en: So far, all of the variables we've handled in our pawn Blueprint have contained
    single values—a number, a true or false value, and a vector. The connector for
    Out Path Positions, however, looks different. Instead of a circle, it's a 3 x
    3 grid. This icon indicates that this is an **array**. Rather than holding a single
    value, an array contains a list of values. In this case, those values are a list
    of points that make up the curved path we're going to draw.
  prefs: []
  type: TYPE_NORMAL
- en: A *For Each Loop* is a programming structure called an **iterator**. Iterators
    loop through collections of values and allow you to perform operations on each
    element in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the ForEach Loop''s outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: The Loop Body will execute once for each item it finds in the array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Array Element is the item it found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Array Index is where it found it. Arrays are always numbered from zero,
    so the first item will have an index of 0, the second will have an index of 1,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Completed execution pin will be called when it reaches the end of the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''re going to use this loop to draw the line segments of our curve, but we''re
    going to need two points for each segment, which means we can''t draw anything
    until we reach the second point in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a connector from the Array Index output and connect it to an integer |
    integer node. Leave the second value as 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect its output to a Branch, and connect the Loop Body to the Branch input.
    This will allow us to skip the first value in the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Draw Debug Line node, and connect the Array Element to the Line End
    input. Since we''re starting with the second value of the array, the point at
    that location is the end of our line. We''re going to get the line start by getting
    the point before it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6ee3a718-2a43-4df8-b60f-083d68ed88d4.png)'
  prefs: []
  type: TYPE_IMG
- en: To find our Line Start, drag another connector from the Array Index, and *subtract
    1* from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, drag another connector from Out Path Positions, and type `Get` into the
    search box. Select Get (a copy):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7fbff992-33c2-4e33-bdff-647a3e5ac552.png)'
  prefs: []
  type: TYPE_IMG
- en: This will get the element stored at the location in the array corresponding
    to the index we give it.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the result of our Array Index -1 subtraction to the Get node's integer
    input. This will retrieve the value before the one we're currently iterating on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the output from this Get node to the Line Start of Draw Debug Line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6abe0f30-f3cf-4a2a-bc6e-433261e589ad.png)'
  prefs: []
  type: TYPE_IMG
- en: When you're finished, the drawing routine should look something like what's
    shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: What we've just done here is looped through each of the path position vectors
    in Out Path Positions, and for each one after the first, we drew a line from the
    position before it to the current one, until we reached the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the endpoint after all the line segments have been drawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s draw a debug sphere at the trace endpoint. We can reuse the
    nodes we were previously using to draw the sphere at the end of our straight line
    trace:'
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did before, **break** the **Hit Result** struct from Out Hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take its Location and feed it into a ProjectPointToNavigation node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a Branch to its Return Value, and feed the **True** branch's execution
    into a Draw Debug Sphere node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Projected Location as the debug sphere's Center.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rather than calling this right after the Draw Debug Line node, however, call
    it from the Completed output of ForEachLoop instead, since we only need to draw
    the sphere once after all of the line segments have been drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your graph should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7bde58c-9e8b-41f4-b8af-0fbc6d824817.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s test it and see what happens when we run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cc4228f-796c-44ca-98ce-0bae0b3a67a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! We're now projecting a curved path that will allow us to get around the
    map much more easily, and we've used debug drawing to verify that it's giving
    us good results.
  prefs: []
  type: TYPE_NORMAL
- en: The Draw Debug methods we're using here will only work in debug and development
    builds. They aren't included in shipping builds. The correct way to draw this
    path would be to use the collection of points in Out Path Positions to change
    the shape of a spline mesh, but doing this is beyond the scope of this book. There's
    a good example, however, in the VR Template, and the work we've done here is a
    good starting point for understanding what they're doing in that project's Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take care of the next job and allow our player to teleport to the
    destination they've chosen.
  prefs: []
  type: TYPE_NORMAL
- en: Teleporting the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do in this instance is give the player a way to tell
    the system when they intend to teleport.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Input Mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to use our Engine Input Mappings to set up a new named input.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your Project Settings and navigate to Engine | Input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hit the + sign beside Bindings | Action Mappings to create a new action mapping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a39aa2d2-d39d-426c-a319-852ff1d2f7c3.png)'
  prefs: []
  type: TYPE_IMG
- en: We're going to name it `TeleportRight`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What this is going to do is create an input event with this name that we can
    then respond to in our event graphs.
  prefs: []
  type: TYPE_NORMAL
- en: You may have already discovered that you can set up events in your event graphs
    directly to listen to controller inputs and keystrokes. For most projects, though,
    it's a better idea to map your inputs here as it gives you a central location
    from which to manage them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s indicate what inputs should trigger this teleport action. A drop-down
    menu has appeared beneath the new action mapping with a None indicator displayed.
    (Hit the expander arrow beside the action mappings if the drop-down menu isn''t
    visible.) Let''s carry on:'
  prefs: []
  type: TYPE_NORMAL
- en: Under TeleportRight, use the drop-down menu to select MotionController (R) Thumbstick.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will handle our Oculus Touch controller mappings, but doesn't help us on
    the HTC Vive, which doesn't use thumbsticks.
  prefs: []
  type: TYPE_NORMAL
- en: Hit the + sign beside the TeleportRight action to add another mapping to the
    group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select MotionController (R) FaceButton1 for this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b681e76-7e02-46bb-8b55-096201144bc9.png)'
  prefs: []
  type: TYPE_IMG
- en: Your bindings should now look like what's shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we've told the input system to send a TeleportRight input event, regardless
    of whether the player is using a motion controller with a thumbstick or one with
    face buttons.
  prefs: []
  type: TYPE_NORMAL
- en: These bindings are stored in `DefaultInput.ini` and can be edited there, but
    it's generally more convenient to set them up here in the Project Settings UI.
    If you need to copy a bunch of input bindings from one project to another, however,
    it can be convenient to copy the contents of `DefaultInput.ini` from one project
    to another. Not every project will have `DefaultInput.ini`. If yours doesn't,
    you can simply add it and the engine will use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s close Project Settings and return to our VRPawn''s event graph. You''ll
    find that you can now create a TeleportRight event here, since we defined it in
    our input settings. Let''s do this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14f0af2a-817f-4ff6-b388-0d5950bbf8a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Caching our teleport destination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, before we do anything with this event, we need to store the location we
    found in our trace method previously so that we can use it here when the player
    tries to teleport:'
  prefs: []
  type: TYPE_NORMAL
- en: Under My Blueprint | Variables, hit the + sign to create a new variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its type to Boolean, and name it `bHasValidTeleportDest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Variable names are important. They tell the reader (who might be another developer
    maintaining your code or might be yourself in the future) what a variable represents.
    Your variable names should accurately reflect what they contain. In the case of
    True/False Boolean variables, make sure your name describes what question it's
    actually answering. So, for instance, in this case, *Teleport* would be a poor
    choice for a name, as it doesn't indicate whether the variable's value means that
    the player can teleport, is teleporting, has recently teleported, or just enjoys
    daydreaming about teleporting. Be clear about these things. `bHasValidTeleportDest`
    clearly indicates what it means.
  prefs: []
  type: TYPE_NORMAL
- en: Prefixing Boolean variable names with *b* is a practice mandated by Epic's coding
    style guide for C++, but it's a good idea to follow it in Blueprint development
    as well. (If you plan on developing in C++, you should know and follow the Unreal
    style guide, which can be found at [https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard](https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard).)
  prefs: []
  type: TYPE_NORMAL
- en: Create another variable and name it `TeleportDest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its type to Vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s populate these variables. The location we care about is the Projected
    Location found by the Project Point to Navigation method we''re calling at our
    hit location. Let''s store whether we''ve found a valid location. You''ll probably
    want to drag the Draw Debug Sphere node a bit to the right to give yourself some
    room since we''re about to add a few nodes before we call it:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag your `bHasValidTeleportDest` variable onto the event graph, and select
    set when asked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you see where the Completed output from the ForEach loop runs into the Branch
    statement coming out of our Project Point to Navigation method?
  prefs: []
  type: TYPE_NORMAL
- en: Press *Ctrl* + drag the execution input into that Branch node to move it onto
    the `CanTeleport` setter. (Notice that the *b* prefix on Boolean variables is
    automatically hidden when the variable is used in a graph.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Return Value from the Project Point to Navigation method into this
    variable. You can press *Ctrl* + drag to move this too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an execution line from Set bHasValidTeleportDest to the Branch input, and
    use the output of the setter to drive the branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s set our TeleportDest to the Project Point to Navigation method''s projected
    location if it returns true:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag our `TeleportDest` variable onto the event graph and choose to set it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the execution line running from our Branch node into our Draw Debug Sphere
    node, and press *Ctrl* + drag it to move it into the Set Teleport Dest input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Projected Location output into the `TeleportDest` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, just because it's cleaner, let's feed the output from the `TeleportDest`
    setter into the Center input on our DrawDebugSphere node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's worth learning about Blueprint shortcuts. Pressing *Alt* + clicking on
    a connection disconnects it. Pressing *Ctrl* + dragging a connection allows you
    to move it somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: From the False execution pin of Branch, let's set TeleportDest to (`0.0, 0.0,
    0.0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your graph should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bbdda98-cb03-419b-b6b8-ecf6fff953d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Can you see the extra pin on the connection between Projected Location and Set
    Teleport Dest? That's a **Reroute Node**. You can create one by dragging a connection
    out and selecting Add Reroute Node from the creation dialog, or by *double-clicking*
    on an existing connector. These are useful for organizing your connections so
    that you can easily see what's going on in your graphs. In general, try to avoid
    allowing connectors to cross underneath nodes they're not connected to, as this
    can mislead someone reading your Blueprint. You can also feed multiple inputs
    into a reroute node or branch multiple outputs from it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, on every tick, we have either a true or a false value in `bHasValidTeleportDest`,
    and if it's true, we have the location to which we could teleport.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the teleport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the value we''ve just stored in the `bHasValidTeleportDest` flag
    to see whether we have a valid destination, and teleport the player pawn to the
    `TeleportDest` if we do:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `TeleportRight` input action we created a moment ago, we'll connect
    an execution line from its Pressed output into a Branch node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that you can hold down *B* and click to create a Branch node. Take
    a look at the other shortcuts found on Epic's Blueprint Editor Cheat Sheet here: [https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/CheatSheet](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/CheatSheet).
    They'll save you a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: Grab your `bHasValidTeleportDest` variable and drag it onto the Branch node's
    Condition input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the True execution output, create a SetActorLocation action, and drag
    your `TeleportDest` variable onto its New Location input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/886789e5-a692-4944-b19c-7660d9b5930e.png)'
  prefs: []
  type: TYPE_IMG
- en: Launch it into a VR preview and give it a shot. You should now be able to teleport
    around the map. It's nice to be able to explore, right?
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have everything working, let's do some work to improve things.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we'll notice when we start jumping around the map is that we
    don't have any way to change the player's orientation at their landing position.
    We can definitely improve this.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing the player to choose their landing orientation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want our player to be able to specify their facing direction when they
    land, the first thing we're going to need to do is give them a way to tell the
    system where they want to be looking.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping axis inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add an input to give our player a way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up Project Settings | Engine | Input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you see the section in Bindings | Action Mappings where we set up our TeleportRight
    input? Right below it is a list of **Axis Mappings**.
  prefs: []
  type: TYPE_NORMAL
- en: Hit the + button beside Axis Mappings to add a new mapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the expansion arrow to open it up, and name it `MotionControllerThumbRight_Y`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map it to MotionController (R) Thumbstick Y.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its scale to -1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second mapping, named `MotionControllerThumbRight_X`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map it to `MotionController (R) Thumbstick X`, and leave its scale as 1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unreal''s input system handles two kinds of mappings: **Action Mappings** and
    **Axis Mappings**. Action mappings are discrete events, such as button or key
    presses and releases. Axis mappings give you continuous information about an analog
    input, such as a joystick or a trackpad.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we scaled the Y input from our motion controller
    thumbstick by -1.0\. This is because the Y input from that device comes in reversed,
    so we need to flip it. Multiplying it by -1 simply inverts the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66967fe7-325a-4f12-b74d-a59c64f782fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Your input mappings should now look like what's shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've added our new input mappings, we can close our project settings.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up our Tick event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's jump back to our pawn's event graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to check the player''s thumbstick position continuously while
    we''re setting up a teleport, we''re going to need to put this on the Event Tick.
    Our Tick event is getting a little crowded, though. Let''s clean it up before
    we start adding more:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag a marquee over the current contents of your Tick event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b0efc0af-adb4-485b-8f96-660516a68778.png)'
  prefs: []
  type: TYPE_IMG
- en: Select all the nodes connected to your Event Tick.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click anywhere on the selected nodes and select Collapse to Function
    from the context menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5faa06cf-bec0-47f9-bbc3-61a8b7a92911.png)'
  prefs: []
  type: TYPE_IMG
- en: Right-click any of the selected nodes and select Collapse to Function.
  prefs: []
  type: TYPE_NORMAL
- en: Name the new function `SetTeleportDestination`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s much cleaner, isn''t it? Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/229b9c0c-9109-4b4c-8416-7cb8c4c3f7d9.png)'
  prefs: []
  type: TYPE_IMG
- en: In general, it's a good idea to use functions as a way of organizing and reusing
    your code, rather than leaving things strewn all over your event graph. Remember
    that 80% of the life cycle of any piece of code will be spent in debugging and
    maintaining it, so organizing your code early can save you quite a lot of work
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: The names you give your functions should be descriptive and they should be accurate.
    Think of them as a promise to the reader that the contents of the function really
    do whatever the name suggests they do. That reader might be you in the future,
    debugging or updating your code, or it might be another developer altogether.
    If you've named your functions clearly, everyone's going to have a much easier
    time understanding what your code is doing. If you modify a function in a way
    that changes what it does, change its name too. Don't let a legacy name mislead
    your reader.
  prefs: []
  type: TYPE_NORMAL
- en: Using thumbstick input to orient the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new function to handle our teleport orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit the + button in My Blueprint | Functions to create a new function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `SetTeleportOrientation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new tab will automatically open, showing you the contents of your function.
    Right now, it just contains an entry point with an execution pin.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click anywhere inside the function's graph and type `thumbright` into
    the context menu's search box. You'll see that the two Axis Mappings you created
    in your input settings are now visible here as functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the Get MotionControllerThumbRight_Y and Get MotionControllerthumbRight_X nodes
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c18a43bd-4d09-4d9e-8c47-c982dc18ee98.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a Make Vector node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the return value from Get MotionControllerThumbRight_Y into the Make Vector node's
    X input. (This may seem backward, but it's correct—we need to transform this input
    to use it to drive our rotation.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed Get MotionControllerThumbRight_X into the new vector's Y input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Normalize the new vector by adding a Normalize node to the Make Vector''s Return
    Value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c7eb290-ddc7-496b-9f79-50783dd11647.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Normalizing** a vector scales it to a length of 1\. A vector whose length
    is 1 is called a **unit vector**. Many mathematical operations on vectors will
    return incorrect results if they''re called on vectors with arbitrary lengths.
    A general rule of thumb is that, if you''re doing vector operations to figure
    out rotations or angles, make sure you''re using unit vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've normalized our input vector, we need to rotate it so it's aiming
    in the direction the player intends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the thing about designing locomotion systems for VR: when you present
    the player with a rotation, you have to decide what its basis is going to be.
    When the player pushes a stick forward or touches forward on a trackpad, how do
    we translate that into a real-world rotation? If you''ve operated a remote control
    car or been playing games long enough to remember the old *tank-style* controls
    in *Resident Evil* and *Fear Effect*, you have some notion of what we''re describing
    here. *Forward* in those systems meant the direction the car or character was
    facing, and if the character was facing the camera at the moment, those controls
    were going to feel backward.'
  prefs: []
  type: TYPE_NORMAL
- en: In traditional first-person designs over the past two decades, this isn't a
    problem we've had to address. There was no difference between the direction the
    character was facing and the direction the player was looking, so using the camera's
    look direction as a forward direction was an obvious choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In VR, on the other hand, we have several options:'
  prefs: []
  type: TYPE_NORMAL
- en: We can base our rotation on the *pawn's rotation*, but that's not a great idea
    in room-scale VR, as the player can turn around in the tracking volume without
    necessarily rotating their pawn. You don't want to orient a control based on something
    the player may not be able to see.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could base it on the player''s *look direction*, which is a better choice
    since it''s consistent from the player''s perspective, but creates funky behaviors
    as the player looks around:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0be22159-18b2-4344-9e65-a967eac571d2.png)'
  prefs: []
  type: TYPE_IMG
- en: A character in VR can have several transforms at the same time - head, body,
    and hands.
  prefs: []
  type: TYPE_NORMAL
- en: In VR, a player's head, hands, and body can rotate independently of each other,
    so it's no longer always obvious where *forward* is.
  prefs: []
  type: TYPE_NORMAL
- en: The best choice, though (and as we'll discover later on when we handle seamless
    locomotion), is to base it on the *motion controller's orientation*, since the
    player's already using it to provide input, is aware of its orientation, and can
    change its orientation easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set our system up this way:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a RotateVector node to our Normalize node's return value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to MotionController_R onto the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag a GetWorldRotation node from MotionController_R:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d80a478-519e-4f05-a674-d42280c63066.png)'
  prefs: []
  type: TYPE_IMG
- en: This will get us the right controller's orientation in the world, but we're
    only interested in the side-to-side rotation (Yaw). We don't want any Pitch or
    Roll information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click the Return Value from GetWorldRotation and select Split Struct
    Pin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/49174351-383e-4ef5-b593-07b7c6a0b052.png)'
  prefs: []
  type: TYPE_IMG
- en: Do the same for the RotateVector node's B input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the Yaw output from GetWorldRotation to the Yaw input to RotateVector.
    Leave Roll and Pitch unconnected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f04385ed-7840-4577-b0fc-eded2656a91d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Splitting** struct pins in Blueprints is often cleaner than using **Break**
    and **Make** nodes to split them and reconstruct them. They do the same thing.
    It''s purely a question of what makes your Blueprint more readable.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to turn our rotated vector into a rotator we can use.
  prefs: []
  type: TYPE_NORMAL
- en: Add a RotationFromXVector node to the RotateVector's return value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to store this vector so that we can use it later.
  prefs: []
  type: TYPE_NORMAL
- en: Drag the RotationFromXVector node's return value out and select Promote to variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new variable `TeleportOrientation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create a Set node for the new variable automatically. Drag an execution
    line from your function's entry point to this setter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an execution line from your setter and select Add Return Node to add an
    exit point to your function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ad87534-e51e-4ae6-adef-9dd78b577393.png)'
  prefs: []
  type: TYPE_IMG
- en: We're now converting the return value from our RotateVector node to a rotator
    and using it to populate Teleport Orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding return nodes to functions that don't return values isn't required, but
    it's good practice to do it because it makes it clear to someone maintaining or
    debugging the code where the exit points are. Nothing will break if you don't
    do this, but your code will be easier to read if you do. We're not going to do
    this with every method in this book, just to avoid adding extra steps, but it's
    a good idea to make this a habit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to your event graph''s Event Tick, and drag the SetTeleportOrientation
    function onto the outgoing execution pin from SetTeleportDestination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/45b7bca7-f17e-4d89-a1b2-191c6cbc8ea8.png)'
  prefs: []
  type: TYPE_IMG
- en: Set Teleport Orientation will now be called on every frame after Set Teleport
    Destination finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this new information:'
  prefs: []
  type: TYPE_NORMAL
- en: In your event graph, find the InputAction TeleportRight event, where we're setting
    our actor location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, let's collapse this into a function as well. Leaving it out on the event
    graph is sloppy. Select the nodes to the right of our input action, right-click,
    and *collapse* them into a new function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the new function `ExecuteTeleport`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c8ba3b98-3eef-4f2a-ae12-cfbc785c2207.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we now have a teleport orientation value we need to accommodate, SetActorLocation
    is no longer enough for us, since it only sets location and not rotation. We could
    call a `Set Actor Rotation` method right after it, using the value stored in our
    TeleportOrientation variable, but there's a cleaner method available to us.
  prefs: []
  type: TYPE_NORMAL
- en: Select the Set Actor Location node here and **delete** it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the graph and create a Teleport node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the True branch from our Branch statement to its execution input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the TeleportDest variable to its Dest Location input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Grab the TeleportOrientation variable from our Variables list and drag it onto
    the Dest Rotation input pin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f99cd473-5018-4afe-9028-ea81c4a67c15.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's try it out. Much better. Now, the position of our thumb on the trackpad
    or the orientation of the thumbstick affects our teleport orientation. We can
    look around much more easily.
  prefs: []
  type: TYPE_NORMAL
- en: There's still one more thing we need to fix though. Our teleport orientation
    works fine if the player is still looking in the same direction as the pawn's
    rotation, but becomes confusingly inaccurate if they aren't. Let's accommodate
    this.
  prefs: []
  type: TYPE_NORMAL
- en: What we're going to want to do here is find out where the player is looking
    relative to the pawn's orientation, and then combine this difference in rotations
    with our selected teleport orientation so that when the player lands there, they're
    looking in the direction they selected.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click and create a GetActorRotation node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're only going to want the Yaw value from this rotation, so right-click the
    node's Return Value and select Split Struct Pin to break out the rotator's components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From your Components list, drag a reference to the Camera component onto the
    graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag its output and call GetWorldRotation on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click its Return Value and select Split Struct Pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the graph and create a Delta (Rotator) node. Split its A and
    B input struct pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GetActorRotation node's Return Value Z (Yaw) output to the Delta
    (Rotator) node's A Z (Yaw) input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Camera's GetWorldRotation node's Return Value Z (Yaw) output to
    the Delta (Rotator) node's B Z (Yaw) input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the graph and create a CombineRotators node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Teleport Orientation variable's value into the CombineRotators node's
    A input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Return Value from the Delta (Rotator) node into the CombineRotator
    node's B input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Return Value from the CombineRotators node into the Teleport node's
    Dest Rotation input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7aa921fb-c947-444c-bbdc-858b30300ebc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now when the player lands at the selected teleport spot, they''ll be looking
    in the direction they expect. If you''re coming from traditional flat-screen game
    development, this is a thing you''re going to have to get used to accommodating
    as a VR developer: the pawn''s rotation is not synonymous with the look direction.
    Players in VR can look around without affecting the pawn''s orientation, so you''ll
    always need to keep both orientations in mind when handling rotation in VR.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem now is that we can't see where it's going to aim us when we land.
    Let's improve our target indication.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a teleport destination indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create a simple Blueprint actor to act as our teleport destination indicator:'
  prefs: []
  type: TYPE_NORMAL
- en: In your project's Blueprints directory, right-click and create a new blueprint
    class with `Actor` as its parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `BP_TeleportDestIndicator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Components tab, hit Add Component, and add a Cylinder component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the scale of the Cylinder to (`0.9, 0.9, 0.1`). (Remember to unlock the
    uniform scale lock to the right of the Scale input.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the Cylinder's Collision properties, set Can Character Step Up On to No,
    and set its Collision Preset to NoCollision. (This is important—this indicator
    will interfere with the pawn if it has a collision.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Cube component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Location to (`60.0, 0.0, 0.0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its Scale to (0.3, 0.1, 0.1):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c0885e4f-a067-458d-b6ed-6693fdbb3381.png)'
  prefs: []
  type: TYPE_IMG
- en: Our indicator should look something like this.
  prefs: []
  type: TYPE_NORMAL
- en: Compile it, save it, and close it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Giving it a material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the blank white material isn''t doing it for you, we can create something
    a little nicer. We''re not going to go crazy on this one, but we can improve its
    look with some quick work:'
  prefs: []
  type: TYPE_NORMAL
- en: From your project directory in your Content browser, create a new directory
    called `MaterialLibrary`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click inside it and select Create Basic Asset | Material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your new material **M_TeleportIndicator**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Details | Material section, set its Blend Mode to Additive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Shading Model to Unlit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold down the *3* key and click anywhere in the graph to create a Constant 3
    Vector node. This is how colors are represented in materials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click the node and choose a primary green: R=0.0, G=1.0, B=0.0.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the output of our color node into the Emissive Color input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click anywhere in the graph and create a Linear Gradient node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the VGradient output into the material''s Opacity input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c2fd06f3-9fce-4b09-b90f-3b5a32df5d85.png)'
  prefs: []
  type: TYPE_IMG
- en: Save and close the material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your BP_TeleportDestIndicator Blueprint and select the Cylider component.
    Under its Details | Materials, set its Element 0 material to the material you
    just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do the same for the Cube component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd2a6360-d5d2-4fc1-8698-026e886610da.png)'
  prefs: []
  type: TYPE_IMG
- en: Nice! This is a very simple material, and if we really wanted to, we could spend
    a lot of time designing something wonderful, but for what we're doing now, this
    is entirely fine.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the teleport indicator to the pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s add this new indicator to our pawn:'
  prefs: []
  type: TYPE_NORMAL
- en: In our VRPawn's Components tab, add a Child Actor component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Details | Child Actor Component | Child Actor Class, select the new BP_TeleportDestIndicator
    actor we just made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the ChildActor to `TeleportDestIndicator`. (You can use the *F2* key
    to rename objects.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a new function to set its position and orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new function in the pawn's Functions collection, and name it `UpdateTeleportIndicator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the TeleportDestIndicator into the function's graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the output from TeleportDestIndicator and create a SetWorldLocationAndRotation
    node, using it as its Target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your TeleportDest variable onto the New Location input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your TeleportOrientation variable onto the New Rotation input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give it a return node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f310cd87-18b9-4a07-88a9-6a2de2a3e243.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Return to your event graph, and drag an instance of the `UpdateTeleportIndicator`
    function onto your Event Tick after Set Teleport Orientation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/008ef504-8c70-4c61-975c-345356a109db.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's try it out. That's better! Now, we can see where we're going to be facing
    when we land. While we're at it, let's get rid of that Debug Sphere we were using
    as a temporary solution earlier on.
  prefs: []
  type: TYPE_NORMAL
- en: In the Set Teleport Destination function, find the Draw Debug Sphere call and
    **delete** it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimizing and refining our teleport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's finish things up with a bit of refinement, where we're still seeing some
    rough edges.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying UI only when teleport input is pressed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First off, we''re running the teleport indicators all of the time, regardless
    of whether or not the user is actually trying to teleport. Let''s activate these
    interfaces only when the user is pressing the teleport input:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new variable to our player pawn. Set its type to Boolean, and name it
    `bTeleportPressed`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Alt* + click on the execution line from InputAction TeleportRight to
    the `ExecuteTeleport` function call to disconnect it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `bTeleportPressed` variable onto the Pressed execution pin from InputAction
    TeleportRight to create a setter. Set it to True here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag another instance of `bTeleportPressed` onto the Released execution pin.
    Set it to False.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect ExecuteTeleport to the setter that''s clearing TeleportPressed, so
    the teleport will happen when the user releases the input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f863cb00-a5ce-404e-81f8-a55b66b5756d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have a variable that will be true when the teleport input is held,
    and false when it isn't, we can use this to manage what happens on our Tick event.
  prefs: []
  type: TYPE_NORMAL
- en: Disconnect Event Tick from SetTeleportDestination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Branch node here, and use `bTeleportPressed` as its condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feed the execution line from Event Tick to the Branch input, and feed its True
    branch to `SetTeleportDestination.` This way, the teleport UI will only be updated
    or displayed when the user presses the teleport input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3dfb86b0-ba5d-45d2-99fa-bd572fa2ac9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try it out. This is better, but our destination indicator is still visible
    while the input isn''t pressed, and it''s not updating. We need to hide it when
    we''re not using it:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the TeleportDestIndicator component from your pawn's Components tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Details, set Rendering | Hidden in Game to True.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your TeleportDestIndicator component onto the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from it and call Set Hidden in Game on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an instance of **bTeleportPressed** onto your graph and **Get** its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from it and type `not` into the search bar. Select NOT Boolean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug this value into the New Hidden input in your Set Hidden in Game action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will cause the indicator to be hidden when Teleport is not pressed, and
    not hidden when it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b604c91-b28b-48a9-b0c2-ed813606366b.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's try it again. Much better. The UI is only displayed when we need it.
  prefs: []
  type: TYPE_NORMAL
- en: We would still need to replace the teleport arc we're currently drawing with
    debug methods before we could ship. We're not going to run through that process
    here, though, because it's a bit too involved for the scope of this chapter. Basically,
    what you would do here is create a spline component on the pawn and attach a mesh
    to it. Instead of using a ForEach loop in `SetTeleportDestination` to draw a series
    of debug lines, we would save the path positions to a variable. In `UpdateTeleportIndicator`,
    we would then use these positions to set the points on the spline. If you'd like
    to give this a shot, there's a good example in the VR Template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a deadzone for our input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we jump around the map, it's also becoming clear that we haven't given the
    player an easy way to teleport without changing orientation. Our system works
    well when they want to look around, but doesn't give them a way to opt out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up `SetTeleportOrientation` and fix this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new variable in BP_VRPawn. Set its type to Float, and name it `TeleportDeadzone`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the Blueprint and set its value to 0.7\. This will accept input at 70%
    of the trackpad or thumbstick's radius.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a second output from the Make Vector node that's combining the two Get
    MotionControllerThumbRight input values, and create a VectorLengthSquared node
    from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `TeleportDeadzone` variable onto the graph and Get its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Square the value of Teleport Deadzone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the output from VectorLengthSquared and create a >= node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the squared Teleport Deadzone value into its other input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c75ca880-5fb3-4002-a1c6-3a9c13a1f53e.png)'
  prefs: []
  type: TYPE_IMG
- en: What's going on here? We're interested in finding out whether the user's input
    is more than 70% of the way toward the edge of its range. We could find this by
    getting the vector length and comparing it with the Teleport Deadzone, and this
    would give us a correct answer, but finding the actual length of a vector involves
    a square root, which is expensive. Squaring a value, on the other hand, just involves
    multiplying it by itself, which is cheap. In our case, since we don't care what
    the real vector length is—just how it compares with the deadzone. We can skip
    the square root on our vector length and just compare it with the squared target
    length. This is a common way of optimizing vector length comparisons. You'll see
    it a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Using squared vector lengths to test input deadzones will give you a properly
    round test region, so you'll get consistent results at any input angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use the result of this comparison to pick which rotation value
    we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: Place a Select node in the graph, and connect the output of the >= test to its
    Index input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disconnect the RotationFromXVector node's output from the Set Teleport Orientation
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the RotationFromXVector node's output to the Select node's True input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a GetActorRotation node and connect its output to the Select node's False
    input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the Select node''s Return Value to the Set Teleport Orientation node''s
    input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/77990d2d-83c1-4b10-8e74-62f1a81527e2.png)'
  prefs: []
  type: TYPE_IMG
- en: What we're doing here is using the result of our deadzone check to decide whether
    we should use the rotation value from the thumbstick inputs or just stick with
    the pawn's existing rotation. If the input is at 70% of the range or greater,
    we'll use the input. If not, we just use the pawn's rotation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/449c69d1-3aa2-45c9-8c99-c45d34631011.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's run it. Now, you'll change orientation if you're hitting the edge of the
    trackpad or pushing the thumbstick a fair distance, but if they're closer to the
    center, you'll just retain your current orientation when you teleport.
  prefs: []
  type: TYPE_NORMAL
- en: Fading out and in on teleport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our system is starting to work pretty well, but our teleport can feel a little
    jarring. Let''s fade out and back in to make a more pleasant transition:'
  prefs: []
  type: TYPE_NORMAL
- en: Open our pawn's event graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Near our InputAction Teleport Right event, create a `Get Player Camera Manager` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From this node's Return Value, create a `Start Camera Fade` action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its To Alpha value to 1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out its Duration input and promote it to a variable. Compile and set its
    value to **0.1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will fade the scene camera to black over a duration of one tenth of a second.
  prefs: []
  type: TYPE_NORMAL
- en: Disconnect the input to the `Execute Teleport` function call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the execution output from the Teleport Pressed = False node to the new
    Start Camera Fade action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll probably need to drag a few nodes off to the right to make some room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''re going to call Start Camera Fade after the user has released the
    teleport input, since we''ve cleared the `bTeleportPressed` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag an execution line from the Start Camera Fade node's execution output and
    put a Delay on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Delay duration to your Fade Duration variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the Delay's **Completed** output into your `Execute Teleport` function
    call so that the function will be called after the fade and delay have occurred.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user releases the teleport input, we're fading out over a tenth of
    a second, waiting another tenth of a second, and then executing the teleport.
    Now, we need to fade back in once the teleport is done.
  prefs: []
  type: TYPE_NORMAL
- en: Create another Start Camera Fade node, and connect the Execute Teleport output
    to its execution input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output from Get Player Camera Manager to this node's Target input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Duration to your `Fade Duration` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its From Alpha value to 1.0 and its To Alpha value to 0.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the output from this node to the input of your Set Hidden in Game node
    of Teleport Dest Indicator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ef14375-1ba2-4283-bcdf-b6fc98e8b2f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Your graph should now look like this.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test it in-game. This is much nicer. We now have a fast fade out and in
    when the teleport action occurs. It's subtle, but adds a bit of polish to the
    application and makes the teleport less jarring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this action takes time, however briefly, we should ensure that the player
    can''t trigger a second teleport while one is already underway:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Boolean variable and name it `bIsTeleporting`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an instance of it onto your graph and Get its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert a new Branch node between InputAction TeleportRight and set Teleport
    Pressed to True.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `bIsTeleporting` as the Branch node's Condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect its False output to the set Teleport Pressed to True node, and leave
    its True output unconnected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do the same for the input action''s Released execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/24619ec8-7d02-4d4e-b390-81232642ca8a.png)'
  prefs: []
  type: TYPE_IMG
- en: This way, a Teleport Pressed or Released event will only be processed if `bIsTeleporting`
    is False.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to set `bIsTeleporting` to True when we start a teleport action,
    and then set it to False again when the action finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: After the Set Teleport Pressed = False node coming from the input action's Released
    output, insert a setter to set `bIsTeleporting` to True.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect its output to the Start Camera Fade node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/efc934e6-a9a1-447a-9039-f83a82849f23.png)'
  prefs: []
  type: TYPE_IMG
- en: After the second Start Camera Fade node, add another setter to set `bIsTeleporting`
    to False.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the output of that node to the Set Hidden in Game input for the Teleport
    Dest Indicator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/caba586b-b053-4fc6-87e7-e62c68fb5c99.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, when we execute a teleport by releasing the input, `bIsTeleporting` will
    be set to true until the teleport action has finished, and a new teleport action
    won't be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Teleport locomotion summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve covered a lot of ground here and created a pretty comprehensive teleport
    locomotion scheme. Let''s go over the scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: It's bound to the navmesh, so it won't allow players to teleport into illegal
    locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's using a parabolic trace so that the player can teleport to destinations
    higher than their current position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the player to choose their target orientation when teleporting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does a decent job of indicating where the player is going to go and where
    they'll be facing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes a few bits of polish, such as an input deadzone and a camera fade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more we could do with this, but it's a reasonably complete solution.
    If we were to improve it further, we would likely want to allow it to work with
    either hand, and we would certainly need to replace our debug-drawn teleport path
    with something that will work in a shipping build. If you choose to explore further
    from here, the VR Template included with the engine is a great next step. Many
    of the methods we just wrote here are similar to the methods used in that template,
    so you should find that you're standing on good ground to understand what you
    see when you start digging around in there.
  prefs: []
  type: TYPE_NORMAL
- en: Teleportation is an effective solution for getting around in VR because, as
    we mentioned earlier, it doesn't try to represent movement, so it doesn't generally
    trigger motion sickness in users. It works pretty well for applications that don't
    rely on a high degree of immersion in the ways players move through the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'For games and applications that want to maintain a higher level of immersion,
    teleportation may not be what you want, as it doesn''t behave the way movement
    in the real world does: it creates a discontinuous sense of space, and introduces
    interface elements that clearly don''t exist in the world. There''s no way around
    the reality that it''s an immersion-breaker.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to take a look at an immersive movement scheme that allows
    players to move smoothly through the world. Very sensitive players or those who
    are new to VR may not find immersive movement comfortable, so in some circumstances,
    it may be appropriate to offer teleport locomotion as an option on an application
    that also offers seamless movement.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Seamless locomotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're making an immersive game or experience, that experience is going to
    be much more convincing to the player if their sense of the space around them
    isn't constantly being broken up by teleport actions. Let's take a look at a way
    to handle seamless locomotion in space.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up inputs for seamless locomotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ordinarily, we would probably allow users to select the sort of locomotion scheme
    they're comfortable with in an options menu, but since our current character doesn't
    do anything but move around, and we haven't done anything with the left controller
    yet, we can use it to drive our seamless locomotion scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a pair of input axis mappings for the left controller''s thumbstick:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Project Settings | Engine | Input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the + button beside Bindings | Axis Mappings twice to add two new axis mappings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name them `MoveForward`, and `MoveRight`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind MoveForward to MotionController (L) Thumbstick Y.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to -1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bind MoveRight to MotionController (L) Thumbstick X, and leave its Scale at
    1.0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2054edc5-b7ed-45cf-b10e-b5eff2036e7d.png)'
  prefs: []
  type: TYPE_IMG
- en: We're all set with our input bindings for the moment, so we can close our project
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the pawn's parent class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our pawn to move smoothly, we're going to need to give it a way to handle
    its movement input. There are two ways we could do this. We could write our own
    input handler on our Tick event, but this is a fairly involved process, and unnecessary
    if we're interested in implementing a straightforward movement scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'An easier way is to add a Movement Component to our pawn. In Blueprint, however,
    there''s no way to add a movement component (in C++, there is), so instead, we''re
    going to have to change our pawn''s parent class to a class that contains the
    component we need, along with several others we''re also going to want. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your Blueprint of BP_VRPawn, and hit Class Settings on the toolbar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f4ac2f82-d94c-452f-8fe0-d1a6e71d0d11.png)'
  prefs: []
  type: TYPE_IMG
- en: We mentioned earlier that Unreal Engine is an **object oriented** system. An **object** is
    an instance of a **class**, and classes **inherit** from other classes, taking
    on their abilities and characteristics as they do. This is where that becomes
    important. We're going to change the capabilities of our BP_VRPawn by changing
    its parent class to a child of the Pawn class that contains the component we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Details | Class Options, change Parent Class from Pawn to Character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8a164f4b-9843-45c0-95bd-da158fde6cbe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look at your Components tab, you''ll see that a few new components have
    appeared:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/471bc9c7-6b98-415e-8248-b5306e4372d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the components we created earlier on, we now have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Capsule component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Arrow component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Mesh component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Character Movement component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all inherited from the `Character` class.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful. We need the Movement component to allow us to move around, and
    we need the Capsule component to keep us from walking through walls. We don't
    really need the Mesh component, since we're not rendering the player pawn's body,
    but it doesn't hurt us in this instance to have it here and just leave its Skeletal
    Mesh property empty for now.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when changing an object's parent class. If the class you're changing
    to is a child of the previous parent class, that's generally going to be a safe
    change, because it will add new elements, but the parent's properties and functions
    will still be there. Going from a child class to a parent class can be riskier,
    since you may be relying on properties or functions that exist on the child, but
    don't exist on the parent. Changing to a class that's very different from your
    current class will probably create problems. It's fine if you know what you're
    doing, and the engine won't stop you, but you'll probably wind up cleaning up
    a lot of invalidated function calls or variable references.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the collision component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you run the game now, you''ll see that we''re floating a little higher above
    the floor than we were previously. This is because our Capsule component is colliding
    with the floor and pushing us upward. To fix this, open your Pawn''s Viewport
    tab. (If you''ve closed it, you can reopen it by double-clicking the BP_VRPawn(self)
    entry on your Components tab.) Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Alt* + *K* to switch your viewport to a side view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grab your Camera Root and drag it downward until it''s sitting at the bottom
    of the Capsule Component. Its location should now be (0.0, 0.0, -90.0):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/9d554b16-7b84-42c7-8771-950af5758fa4.png)'
  prefs: []
  type: TYPE_IMG
- en: If you run the game again, you'll find that you're properly on the floor.
  prefs: []
  type: TYPE_NORMAL
- en: Handling movement input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve given our pawn a movement component, let''s use the input bindings
    we mapped a moment ago to allow us to move around:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click in your pawn''s event graph and create an Input | Axis Events |
    MoveForward event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc61e844-ba4b-4a61-98ff-052b8ec60503.png)'
  prefs: []
  type: TYPE_IMG
- en: Do the same for the MoveRight event we created in our axis bindings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have two events that will run every frame, and allow us to feed movement
    input to our movement component.
  prefs: []
  type: TYPE_NORMAL
- en: Create an Add Movement Input node, and connect its execution input to the output
    of InputAxis MoveForward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Axis Value of MoveForward into the movement input's Scale Value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat this for InputAxis MoveRight:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c6c2c89a-e340-41d8-a7b6-d59b6597cd29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to tell it the direction we''d like to move in:'
  prefs: []
  type: TYPE_NORMAL
- en: Grab your Camera component from your components list, and drag it onto your
    event graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From its output, create a GetWorldRotation node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the GetWorldRotation output and split the struct pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the graph and create a Get Forward Vector node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Split its input pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Yaw output from GetWorldRotation to the In Rot Z (Yaw) input in
    Get Forward Vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click to create a Get Right Vector node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Split its input, and connect Yaw output of GetWorldRotation to its In Rot Z
    (Yaw) input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output from Get Forward Vector to the World Direction input to Add
    Movement Input of InputAxis MoveForward node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the output from Get Right Vector to the MoveRight Add Movement Input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/799912e0-21eb-4e11-b2dc-8a9d89b53da6.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's give it a try in-game.
  prefs: []
  type: TYPE_NORMAL
- en: We can still teleport using our right trackpad or thumbstick, but if we use
    the left input, it slides us smoothly through the world using our camera's look
    direction as the forward direction.
  prefs: []
  type: TYPE_NORMAL
- en: Gamers that are used to first-person shooters are used to thinking of their
    camera direction as their forward direction. In VR, this doesn't have to be the
    case—it's perfectly reasonable for a character to be looking to the right while
    moving to the left. Our pawn has a concept of *Control Rotation*, which is its
    actual orientation in space, and is distinct from the direction the camera is
    facing. In practice, if you're going to drive movement from a pawn's control rotation
    rather than camera rotation, you need to provide visual cues to make it clear
    to the player exactly what their forward orientation is, or your movement scheme
    will just confuse them. To keep things clear in this instance, we've made our
    movement relative to the look direction.
  prefs: []
  type: TYPE_NORMAL
- en: This works well enough, but it has some problems.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing movement speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''re moving too fast. Let''s fix this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select your pawn''s CharacterMovement Component, and in Details | Character
    Movement: Walking, set its Max Walk Speed to 240.0'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's a much more reasonable speed for walking through the world.
  prefs: []
  type: TYPE_NORMAL
- en: Letting the player look around without constantly steering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s face it. Using the camera forward vector as the basis for our steering
    feels a little janky. Every time you turn your head to look at something, you
    have to steer to correct yourself. The world doesn''t work that way. Let''s use
    the orientation of the left controller as the basis for our movement instead:'
  prefs: []
  type: TYPE_NORMAL
- en: Grab the `MotionController_L` component and drag it into the event graph near
    where we're currently getting the Camera's world rotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feed MotionController_L component''s output into the GetWorldRotation node,
    replacing the Camera''s connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/38ba6cf2-cf89-4b75-918c-67436a637a46.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, instead of using the Camera's Yaw as our basis for our forward and right
    world directions, we're using the controller, which makes intuitive sense. Forward
    is wherever you're pointing the controller, and meanwhile, the player can execute
    fine movements using the trackpad or joystick. They can steer by pointing in the
    direction they want to go and can look around without affecting their movement.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing snap-turning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we need to give the player is a way to change their orientation
    without having to spin their chair around in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it works well to allow your players to move smoothly through the world
    like we just have, we don''t want them to turn smoothly. We discussed the reason
    for this in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml), *Thinking
    in VR*, but to recap here, visually induced motion sickness arises when players
    see movement that they don''t feel. We''re especially attuned to movements that
    appear to be spinning. This likely arises from a number of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: A sense of spinning is a natural effect of disruptions to the vestibular system
    from poisoning. Ever had the bed-spins after a rough night out? What happened
    next? Right. Don't do that to your player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vestibular disconnect is strongest when there's a lot of optic flow in the image.
    When the player is rotating, nearly everything in the frame is moving to the side.
    That's a lot of movement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the real world, we naturally blink when rotating our head, or we aim our
    eyes first at the thing we want to look at (this movement is called a **saccade**),
    and then turn our head to follow. In the real world, we don't keep our eyes steady
    while we turn around.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snapping the player through a turn rather than allowing them to turn smoothly
    not only avoids creating a huge optic flow that's likely to make your user sick,
    but it actually does a better job of replicating the way we actually perceive
    turning in the real world than a smooth turn does.
  prefs: []
  type: TYPE_NORMAL
- en: Let's set up a snap turn.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up inputs for snap turning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a pair of action bindings to snap right and left:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your Project Settings | Engine | Input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two new Action Mappings in Engine | Input | Bindings. Name them `SnapTurnRight` and
    `SnapTurnLeft`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind SnapTurnRight to MotionController (L) FaceButton2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind SnapTurnLeft to MotionController (L) FaceButton4 and MotionController (L)
    FaceButton1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re binding two inputs to SnapTurnLeft to accommodate both Oculus and Vive
    inputs. On Oculus Touch controllers, FaceButton1 on the left controller is the
    X button, while FaceButton2 is the Y button. On the HTC Vive, FaceButton2 is the
    left-hand side of the trackpad, and FaceButton4 is the right-hand side of the
    pad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d05f8efb-9a27-42f1-aadd-3b6bdc73ad42.png)'
  prefs: []
  type: TYPE_IMG
- en: Your input bindings should now look like this.
  prefs: []
  type: TYPE_NORMAL
- en: We can close our project settings now.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the snap turn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s execute a snap turn when these buttons are pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your pawn''s event graph, add input events for your SnapTurnLeft and SnapTurnRight
    actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1f902968-f3a2-4811-b911-d60686b9663b.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a GetActorRotation node and split its output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the Return Value Z (Yaw) output and create a float - float node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out from the subtraction node's second input and **promote** it to a variable.
    Name the variable `SnapTurnIncrement`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile your Blueprint and set the SnapTurnIncrement value to 30.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a SetActorRotation node, and connect the **GetActorRotation** node's
    Roll and Pitch outputs directly to their corresponding inputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the result of your subtraction to the Yaw input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Pressed execution output from InputAction SnapTurnLeft to the SetActorRotation
    node's input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select these nodes and press *Ctrl* + *W* to duplicate them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the subtraction in the duplicated set with an addition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the duplicated nodes to execution of the InputAction SnapTurnRight
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57e4c842-4bb3-48de-9eaf-6769f4330942.png)'
  prefs: []
  type: TYPE_IMG
- en: Give it a shot in-game. It's not bad. We could improve it further for sure—right
    now, snap turning triggers movement as well, but it's a pretty usable solution.
    If it made sense for our game, we could potentially map down a press on the Vive
    trackpad or a joystick press on the left Oculus Touch to a 180° turn.
  prefs: []
  type: TYPE_NORMAL
- en: Going further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few ways we could improve the work we've done here, but implementing
    them fully would fall outside the scope of this chapter. Let's take a brief moment
    to talk about ways you could improve on this class as you take things further.
  prefs: []
  type: TYPE_NORMAL
- en: Snap turn using analog input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our current snap turn implementation works reasonably well on Vive wands, but
    doesn't feel great on Oculus Touch controls. It might feel better for our players
    to listen to the analog input from one of the thumbsticks and trigger a snap turn
    if it exceeds a certain threshold. This way, players could flip the thumbstick
    to the side to execute the snap, or just touch the edge of a Vive trackpad without
    having to press it.
  prefs: []
  type: TYPE_NORMAL
- en: You could execute this by setting up an input axis binding on a motion controller
    thumbstick, and testing to see whether the input is greater than a threshold amount
    (for this test, we used 0.8) for a right turn or less than the negative threshold
    for a left turn.
  prefs: []
  type: TYPE_NORMAL
- en: You'll need to remember to put a cooldown onto the snap so that it doesn't trigger
    repeatedly from a single press. In our case, we used a cooldown duration of 0.2.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''d like to build this into your pawn, here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an input event handler for your MotionControllerThumbRight_X input axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Branch, and only continue if `bTeleportPressed` is False. We don't
    want to process snap turns while we're teleporting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Boolean variable called `bSnapTurnCooldownActive`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Branch, and only continue if `bSnapTurnCooldownActive` is False.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new float variable called `SnapTurnAnalogDeadzone`, compile, and set
    its value to 0.8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a >= test to see whether the incoming Axis Value from your thumbstick input
    is greater than or equal to `SnapTurnAnalogDeadzone`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Branch from this, and on its False output, create another Branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this second branch, test to see whether the incoming Axis Value is less
    than or equal to the negative SnapTurnAnalogDeadzone (multiply it by -1.0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bdb7c99f-4f74-419f-8777-6adc185455c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a new Custom Event called ExecuteSnapTurnLeft, and feed it into the SetActorRotation
    call you're making from InputAction SnapTurnLeft.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create another one called ExecuteSnapTurnRight, and feed it in where InputAction
    SnapTurnRight is being handled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73b934fb-ddbd-4ba0-959f-84b9efa86ff0.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, back on your ThumbstickRight handler, call ExecuteSnapTurnRight if the
    Input Axis was >= SnapTurnAnalogDeadzone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call ExecuteSnapTurnLeft if the Input Axis was <= -SnapTurnAnalogDeadzone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e8ea2743-287e-434e-9f87-a628e146719e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to set a cooldown so that we don''t get a rapid-fire series of
    snap turns when the user moves the stick:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a setter to set bSnapTurnCooldownActive to true, and call it after both
    ExecuteSnapTurnRight and ExecuteSnapTurnLeft.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a delay. The default value of 0.2 is fine here, but if you wanted to tune
    your cooldown duration, promote this value to a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the delay, set bSnapTurnCooldownActive to False again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c55b1d36-b0cb-4178-8381-8d5e2750dd8c.png)'
  prefs: []
  type: TYPE_IMG
- en: With this Boolean flag and delay, we're simply setting up a gate whereby the
    snap turn input will be ignored for 0.2 seconds after the last time it was handled,
    which gives the user time to release the stick once they're oriented where they
    want to be.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation gives your player a nice natural-feeling snap turn on the
    right stick while leaving the left stick for analogue seamless movement.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We did quite a lot in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned how to set up and refine a navigation mesh in our scene and how
    to find and fix collision problems with objects in our scene. We learned how to
    set up input actions and use them to move our player character around, and perhaps
    most importantly, we learned Kent Beck''s mantra for software development: *Make
    it work, make it right, make it fast*, and learned what it means to follow it
    as we pursue iterative development. We''re going to revisit this a lot. It''s
    a secret to effective software development.'
  prefs: []
  type: TYPE_NORMAL
- en: That was a lot of work. The exercises in this chapter covered a lot of ground,
    but should have left you with a decent sense of how the parts fit together when
    setting up a player pawn and a locomotion system.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've given our pawn feet, in the next chapter, we're going to give
    it hands. We'll learn how to use motion controllers to point, grip, and interact
    with objects in the world. We'll also build on what we've learned about setting
    up navigation meshes and drop some AI into the world to use them as well. Now
    that we can get around the world, we're going to start bringing it to life.
  prefs: []
  type: TYPE_NORMAL
