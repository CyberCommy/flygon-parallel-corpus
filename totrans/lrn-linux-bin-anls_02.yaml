- en: Chapter 2. The ELF Binary Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to reverse-engineer Linux binaries, you must understand the binary
    format itself. ELF has become the standard binary format for Unix and Unix-flavor
    OSes. In Linux, BSD variants, and other OSes, the ELF format is used for executables,
    shared libraries, object files, coredump files, and even the kernel boot image.
    This makes ELF very important to learn for those who want to better understand
    reverse engineering, binary hacking, and program execution. Binary formats such
    as ELF are not generally a quick study, and to learn ELF requires some degree
    of application of the different components that you learn as you go. Real, hands-on
    experience is necessary to achieve proficiency. The ELF format is complicated
    and dry, but can be learned with some enjoyment when applying your developing
    knowledge of it in reverse engineering and programming tasks. ELF is really quite
    an incredible composition of computer science at work, with program loading, dynamic
    linking, symbol table lookups, and many other tightly orchestrated components.
  prefs: []
  type: TYPE_NORMAL
- en: I believe that this chapter is perhaps the most important in this entire book
    because it will give the reader a much greater insight into topics pertaining
    to how a program is actually mapped out on disk and loaded into memory. The inner
    workings of program execution are complicated, and understanding it is valuable
    knowledge to the aspiring binary hacker, reverse engineer, or low-level programmer.
    In Linux, program execution implies the ELF binary format.
  prefs: []
  type: TYPE_NORMAL
- en: My approach to learning ELF is through investigation of the ELF specifications
    as any Linux reverse engineer should, and then applying each aspect of what we
    learn in a creative way. Throughout this book, you will visit many facets of ELF
    and see how knowledge of it is pertinent to viruses, process-memory forensics,
    binary protection, rootkits, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will cover the following ELF topics:'
  prefs: []
  type: TYPE_NORMAL
- en: ELF file types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Section headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic linking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding an ELF parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ELF file types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An ELF file may be marked as one of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ET_NONE`: This is an unknown type. It indicates that the file type is unknown,
    or has not yet been defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ET_REL`: This is a relocatable file. ELF type relocatable means that the file
    is marked as a relocatable piece of code or sometimes called an object file. Relocatable
    object files are generally pieces of **Position independent code** (**PIC**) that
    have not yet been linked into an executable. You will often see `.o` files in
    a compiled code base. These are the files that hold code and data suitable for
    creating an executable file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ET_EXEC`: This is an executable file. ELF type executable means that the file
    is marked as an executable file. These types of files are also called programs
    and are the entry point of how a process begins running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ET_DYN`: This is a shared object. ELF type dynamic means that the file is
    marked as a dynamically linkable object file, also known as shared libraries.
    These shared libraries are loaded and linked into a program''s process image at
    runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ET_CORE`: This is an ELF type core that marks a core file. A core file is
    a dump of a full process image during the time of a program crash or when the
    process has delivered an SIGSEGV signal (segmentation violation). GDB can read
    these files and aid in debugging to determine what caused the program to crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we look at an ELF file with the command `readelf -h`, we can view the initial
    ELF file header. The ELF file header starts at the 0 offset of an ELF file and
    serves as a map to the rest of the file. Primarily, this header marks the ELF
    type, the architecture, and the entry point address where execution is to begin,
    and provides offsets to the other types of ELF headers (section headers and program
    headers), which will be explained in depth later. More of the file header will
    be understood once we explain the meaning of section headers and program headers.
    Looking at the ELF(5) man page in Linux shows us the ELF header structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Later in this chapter, we will see how to utilize the fields in this structure
    to map out an ELF file with a simple C program. First, we will continue looking
    at the other types of ELF headers that exist.
  prefs: []
  type: TYPE_NORMAL
- en: ELF program headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ELF program headers are what describe segments within a binary and are necessary
    for program loading. Segments are understood by the kernel during load time and
    describe the memory layout of an executable on disk and how it should translate
    to memory. The program header table can be accessed by referencing the offset
    found in the initial ELF header member called `e_phoff` (program header table
    offset), as shown in the `ElfN_Ehdr` structure in display `1.7`.
  prefs: []
  type: TYPE_NORMAL
- en: There are five common program header types that we will discuss here. Program
    headers describe the segments of an executable file (shared libraries included)
    and what type of segment it is (that is, what type of data or code it is reserved
    for). First, let's take a look at the `Elf32_Phdr` structure that makes up a program
    header entry in the program header table of a 32-bit ELF executable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We sometimes refer to program headers as Phdrs throughout the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `Elf32_Phdr` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: PT_LOAD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An executable will always have at least one `PT_LOAD` type segment. This type
    of program header is describing a loadable segment, which means that the segment
    is going to be loaded or mapped into memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, an ELF executable with dynamic linking will generally contain
    the following two loadable segments (of type `PT_LOAD`):'
  prefs: []
  type: TYPE_NORMAL
- en: The text segment for program code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the data segment for global variables and dynamic linking information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding two segments are going to be mapped into memory and aligned in
    memory by the value stored in `p_align`. I recommend reading the ELF man pages
    in Linux to understand all of the members in a Phdr structure as they describe
    the layout of both the segments in the file as well as in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Program headers are primarily there to describe the layout of a program for
    when it is executing and in memory. We will be utilizing Phdrs later in this chapter
    to demonstrate what they are and how to use them in reverse engineering software.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The text segment (also known as the code segment) will generally have segment
    permissions set as `PF_X` | `PF_R` (`READ+EXECUTE`).
  prefs: []
  type: TYPE_NORMAL
- en: The data segment will generally have segment permissions set to `PF_W` | `PF_R`
    (`READ+WRITE`).
  prefs: []
  type: TYPE_NORMAL
- en: A file infected with a polymorphic virus might have changed these permissions
    in some way such as modifying the text segment to be writable by adding the `PF_W`
    flag into the program header's segment flags (`p_flags`).
  prefs: []
  type: TYPE_NORMAL
- en: PT_DYNAMIC – Phdr for the dynamic segment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dynamic segment is specific to executables that are dynamically linked
    and contains information necessary for the dynamic linker. This segment contains
    tagged values and pointers, including but not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: List of shared libraries that are to be linked at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The address/location of the **Global offset table** (**GOT**) discussed in the
    *ELF Dynamic Linking* section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about relocation entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following is a complete list of the tag names:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Tag name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_HASH` | Address of symbol hash table |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_STRTAB` | Address of string table |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_SYMTAB` | Address of symbol table |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_RELA` | Address of Rela relocs table |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_RELASZ` | Size in bytes of Rela table |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_RELAENT` | Size in bytes of a Rela table entry |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_STRSZ` | Size in bytes of string table |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_STRSZ` | Size in bytes of string table |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_STRSZ` | Size in bytes of string table |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_SYMENT` | Size in bytes of a symbol table entry |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_INIT` | Address of the initialization function |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_FINI` | Address of the termination function |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_SONAME` | String table offset to name of shared object |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_RPATH` | String table offset to library search path |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_SYMBOLIC` | Alert linker to search this shared object before the executable
    for symbols |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_REL` | Address of Rel relocs table |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_RELSZ` | Size in bytes of Rel table |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_RELENT` | Size in bytes of a Rel table entry |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_PLTREL` | Type of reloc the PLT refers (Rela or Rel) |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_DEBUG` | Undefined use for debugging |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_TEXTREL` | Absence of this indicates that no relocs should apply to a
    nonwritable segment |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_JMPREL` | Address of reloc entries solely for the PLT |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_BIND_NOW` | Instructs the dynamic linker to process all relocs before
    transferring control to the executable |'
  prefs: []
  type: TYPE_TB
- en: '| `DT_RUNPATH` | String table offset to library search path |'
  prefs: []
  type: TYPE_TB
- en: The dynamic segment contains a series of structures that hold relevant dynamic
    linking information. The `d_tag` member controls the interpretation of `d_un`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 32-bit ELF dynamic struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will explore more about **dynamic linking** later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: PT_NOTE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A segment of type `PT_NOTE` may contain auxiliary information that is pertinent
    to a specific vendor or system. Following is a definition of `PT_NOTE` from the
    formal ELF specification:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a vendor or system builder needs to mark an object file with special
    information that other programs will check for conformance, compatibility, and
    so on. Sections of type `SHT_NOTE` and program header elements of type `PT_NOTE`
    can be used for this purpose. The note information in sections and program header
    elements holds any number of entries, each of which is an array of 4-byte words
    in the format of the target processor. Labels appear below to help explain note
    information organization, but they are not part of the specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'A point of interest: because of the fact that this segment is only used for
    OS specification information, and is actually not necessary for an executable
    to run (since the system will just assume the executable is native either way),
    this segment becomes an interesting place for virus infection, although not necessarily
    the most practical way to go about it due to size constraints. Some information
    on NOTE segment infections can be found at [http://vxheavens.com/lib/vhe06.html](http://vxheavens.com/lib/vhe06.html).'
  prefs: []
  type: TYPE_NORMAL
- en: PT_INTERP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This small segment contains only the location and size to a null terminated
    string describing where the program interpreter is; for instance, `/lib/linux-ld.so.2`
    is generally the location of the dynamic linker, which is also the program interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: PT_PHDR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This segment contains the location and size of the program header table itself.
    The Phdr table contains all of the Phdr's describing the segments of the file
    (and in the memory image).
  prefs: []
  type: TYPE_NORMAL
- en: Consult the ELF(5) man pages or the ELF specification paper to see all possible
    Phdr types. We have covered the most commonly seen ones that are vital to program
    execution or that we will be seeing most commonly in our reverse engineering endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `readelf -l <filename>` command to view a file''s Phdr table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can see the entry point of the executable as well as some of the different
    segment types we just finished discussing. Notice the offsets to the right of
    the permission flags and alignment flags of the two first `PT_LOAD` segments.
  prefs: []
  type: TYPE_NORMAL
- en: The text segment is `READ+EXECUTE` and the data segment is `READ+WRITE`, and
    both segments have an alignment of `0x1000` or 4,096 which is a page size on a
    32-bit executable, and this is for alignment during program loading.
  prefs: []
  type: TYPE_NORMAL
- en: ELF section headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've looked at what program headers are, it is time to look at section
    headers. I really want to point out here the distinction between the two; I often
    hear people calling sections, segments, and vice versa. A section is not a segment.
    Segments are necessary for program execution, and within each segment, there is
    either code or data divided up into sections. A section header table exists to
    reference the location and size of these sections and is primarily for linking
    and debugging purposes. Section headers are not necessary for program execution,
    and a program will execute just fine without having a section header table. This
    is because the section header table doesn't describe the program memory layout.
    That is the responsibility of the program header table. The section headers are
    really just complimentary to the program headers. The `readelf –l` command will
    show which sections are mapped to which segments, which helps to visualize the
    relationship between sections and segments.
  prefs: []
  type: TYPE_NORMAL
- en: If the section headers are stripped (missing from the binary), that doesn't
    mean that the sections are not there; it just means that they can't be referenced
    by section headers and less information is available for debuggers and disassembler
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: Each section contains either code or data of some type. The data could range
    from program data, such as global variables, or dynamic linking information that
    is necessary for the linker. Now, as mentioned previously, every ELF object has
    sections, but not all ELF objects have **section headers**, primarily when someone
    has deliberately removed the section header table, which is not the default.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, this is because the executable has been tampered with (for example,
    the section headers have been stripped so that debugging is harder). All of GNU's
    binutils such as `objcopy`, `objdump`, and other tools such as `gdb` rely on the
    section headers to locate symbol information that is stored in the sections specific
    to containing symbol data. Without section headers, tools such as `gdb` and `objdump`
    are nearly useless.
  prefs: []
  type: TYPE_NORMAL
- en: Section headers are convenient to have for granular inspection over what parts
    or sections of an ELF object we are viewing. In fact, section headers make reverse
    engineering a lot easier since they provide us with the ability to use certain
    tools that require them. For instance, if the section header table is stripped,
    then we can't access a section such as `.dynsym`, which contains imported/exported
    symbols describing function names and offsets/addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if a section header table has been stripped from an executable, a moderate
    reverse engineer can actually reconstruct a section header table (and even part
    of a symbol table) by getting information from certain program headers since these
    will always exist in a program or shared library. We discussed the dynamic segment
    earlier and the different `DT_TAG` that contain information about the symbol table
    and relocation entries. We can use this to reconstruct other parts of the executable
    as shown in [Chapter 8](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "Chapter 8. ECFS – Extended Core File Snapshot Technology"), *ECFS – Extended
    Core File Snapshot Technology*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what a 32-bit ELF section header looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at some of the most important sections and section types,
    once again allowing room to study the ELF(5) man pages and the official ELF specification
    for more detailed information about the sections.
  prefs: []
  type: TYPE_NORMAL
- en: The .text section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `.text` section is a code section that contains program code instructions.
    In an executable program where there are also Phdr's, this section would be within
    the range of the text segment. Because it contains program code, it is of section
    type `SHT_PROGBITS`.
  prefs: []
  type: TYPE_NORMAL
- en: The .rodata section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `rodata` section contains read-only data such as strings from a line of
    C code, such as the following command are stored in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This section is read-only and therefore must exist in a read-only segment of
    an executable. So you will find `.rodata` within the range of the text segment
    (not the data segment). Because this section is read-only, it is of type `SHT_PROGBITS`.
  prefs: []
  type: TYPE_NORMAL
- en: The .plt section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **procedure linkage table** (**PLT**) will be discussed in depth later in
    this chapter, but it contains code necessary for the dynamic linker to call functions
    that are imported from shared libraries. It resides in the text segment and contains
    code, so it is marked as type `SHT_PROGBITS`.
  prefs: []
  type: TYPE_NORMAL
- en: The .data section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `data` section, not to be confused with the data segment, will exist within
    the data segment and contain data such as initialized global variables. It contains
    program variable data, so it is marked `SHT_PROGBITS`.
  prefs: []
  type: TYPE_NORMAL
- en: The .bss section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `bss` section contains uninitialized global data as part of the data segment
    and therefore takes up no space on disk other than 4 bytes, which represents the
    section itself. The data is initialized to zero at program load time and the data
    can be assigned values during program execution. The `bss` section is marked `SHT_NOBITS`
    since it contains no actual data.
  prefs: []
  type: TYPE_NORMAL
- en: The .got.plt section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Global offset table** (**GOT**) section contains the global offset table.
    This works together with the PLT to provide access to imported shared library
    functions and is modified by the dynamic linker at runtime. This section in particular
    is often abused by attackers who gain a pointer-sized write primitive in heap
    or `.bss` exploits. We will discuss this in the *ELF Dynamic Linking* section
    of this chapter. This section has to do with program execution and therefore is
    marked `SHT_PROGBITS`.
  prefs: []
  type: TYPE_NORMAL
- en: The .dynsym section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dynsym` section contains dynamic symbol information imported from shared
    libraries. It is contained within the text segment and is marked as type `SHT_DYNSYM`.
  prefs: []
  type: TYPE_NORMAL
- en: The .dynstr section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dynstr` section contains the string table for dynamic symbols that has
    the name of each symbol in a series of null terminated strings.
  prefs: []
  type: TYPE_NORMAL
- en: The .rel.* section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Relocation sections contain information about how parts of an ELF object or
    process image need to be fixed up or modified at linking or runtime. We will discuss
    more about relocations in the *ELF Relocations* section of this chapter. Relocation
    sections are marked as type `SHT_REL` since they contain relocation data.
  prefs: []
  type: TYPE_NORMAL
- en: The .hash section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `hash` section, sometimes called `.gnu.hash`, contains a hash table for
    symbol lookup. The following hash algorithm is used for symbol name lookups in
    Linux ELF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`h = h * 33 + c` is often seen coded as `h = ((h << 5) + h) + c`'
  prefs: []
  type: TYPE_NORMAL
- en: The .symtab section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `symtab` section contains symbol information of type `ElfN_Sym`, which we
    will analyze more closely in the ELF symbols and relocations section of this chapter.
    The `symtab` section is marked as type `SHT_SYMTAB` as it contains symbol information.
  prefs: []
  type: TYPE_NORMAL
- en: The .strtab section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `.strtab` section contains the symbol string table that is referenced by
    the `st_name` entries within the `ElfN_Sym` structs of `.symtab` and is marked
    as type `SHT_STRTAB` since it contains a string table.
  prefs: []
  type: TYPE_NORMAL
- en: The .shstrtab section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `shstrtab` section contains the section header string table that is a set
    of null terminated strings containing the names of each section, such as `.text`,
    `.data`, and so on. This section is pointed to by the ELF file header entry called
    `e_shstrndx` that holds the offset of `.shstrtab`. This section is marked `SHT_STRTAB`
    since it contains a string table.
  prefs: []
  type: TYPE_NORMAL
- en: The .ctors and .dtors sections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `.ctors` (**constructors**) and `.dtors` (**destructors**) sections contain
    function pointers to initialization and finalization code that is to be executed
    before and after the actual `main()` body of program code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `__constructor__` function attribute is sometimes used by hackers and virus
    writers to implement a function that performs an anti-debugging trick such as
    calling `PTRACE_TRACEME` so that the process traces itself and no debuggers can
    attach to it. This way the anti-debugging code gets executed before the program
    enters into `main()`.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other section names and types, but we have covered most of the
    primary ones found in a dynamically linked executable. One can now visualize how
    an executable is laid out with both `phdrs` and `shdrs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text segments will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[.text]`: This is the program code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[.rodata]`: This is read-only data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[.hash]`: This is the symbol hash table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[.dynsym ]`: This is the shared object symbol data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[.dynstr ]`: This is the shared object symbol name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[.plt]`: This is the procedure linkage table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[.rel.got]`: This is the G.O.T relocation data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data segments will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[.data]`: These are the globally initialized variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[.dynamic]`: These are the dynamic linking structures and objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[.got.plt]`: This is the global offset table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[.bss]`: These are the globally uninitialized variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at an `ET_REL` file (object file) section header with the
    `readelf –S` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are 12 section headers, starting at offset 0 x 124:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: No program headers exist in relocatable objects (ELF files of type `ET_REL`)
    because `.o` files are meant to be linked into an executable, but not meant to
    be loaded directly into memory; therefore, readelf -l will yield no results on
    `test.o`. Linux loadable kernel modules are actually `ET_REL` objects and are
    an exception to the rule because they do get loaded directly into kernel memory
    and relocated on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that many of the sections we talked about are present, but there
    are also some that are not. If we compile `test.o` into an executable, we will
    see that many new sections have been added, including `.got.plt`, `.plt`, `.dynsym`,
    and other sections that are related to dynamic linking and runtime relocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are 30 section headers, starting at offset 0 x 1140:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As observed, a number of sections have been added, most notably the ones related
    to dynamic linking and constructors. I strongly suggest that the reader follows
    the exercise of deducing which sections have been changed or added and what purpose
    the added sections serve. Consult the ELF(5) man pages or the ELF specifications.
  prefs: []
  type: TYPE_NORMAL
- en: ELF symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Symbols are a symbolic reference to some type of data or code such as a global
    variable or function. For instance, the `printf()` function is going to have a
    symbol entry that points to it in the dynamic symbol table `.dynsym`. In most
    shared libraries and dynamically linked executables, there exist two symbol tables.
    In the `readelf -S` output shown previously, you can see two sections: `.dynsym`
    and `.symtab`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `.dynsym` contains global symbols that reference symbols from an external
    source, such as `libc` functions like `printf`, whereas the symbols contained
    in `.symtab` will contain all of the symbols in `.dynsym`, as well as the local
    symbols for the executable, such as global variables, or local functions that
    you have defined in your code. So `.symtab` contains all of the symbols, whereas
    `.dynsym` contains just the dynamic/global symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the question is: Why have two symbol tables if `.symtab` already contains
    everything that''s in `.dynsym`? If you check out the `readelf -S` output of an
    executable, you will see that some sections are marked **A** (**ALLOC**) or **WA**
    (**WRITE/ALLOC**) or **AX** (**ALLOC/EXEC**). If you look at `.dynsym`, you will
    see that it is marked ALLOC, whereas `.symtab` has no flags.'
  prefs: []
  type: TYPE_NORMAL
- en: ALLOC means that the section will be allocated at runtime and loaded into memory,
    and `.symtab` is not loaded into memory because it is not necessary for runtime.
    The `.dynsym` contains symbols that can only be resolved at runtime, and therefore
    they are the only symbols needed at runtime by the dynamic linker. So, while the
    `.dynsym` symbol table is necessary for the execution of dynamically linked executables,
    the `.symtab` symbol table exists only for debugging and linking purposes and
    is often stripped (removed) from production binaries to save space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what an ELF symbol entry looks like for 64-bit ELF files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Symbol entries are contained within the `.symtab` and `.dynsym` sections, which
    is why the `sh_entsize` (section header entry size) for those sections are equivalent
    to `sizeof(ElfN_Sym)`.
  prefs: []
  type: TYPE_NORMAL
- en: st_name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `st_name` contains an offset into the symbol table's string table (located
    in either `.dynstr` or `.strtab`), where the name of the symbol is located, such
    as `printf`.
  prefs: []
  type: TYPE_NORMAL
- en: st_value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `st_value` holds the value of the symbol (either an address or offset of
    its location).
  prefs: []
  type: TYPE_NORMAL
- en: st_size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `st_size` contains the size of the symbol, such as the size of a global
    function `ptr`, which would be 4 bytes on a 32-bit system.
  prefs: []
  type: TYPE_NORMAL
- en: st_other
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This member defines the symbol visibility.
  prefs: []
  type: TYPE_NORMAL
- en: st_shndx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every symbol table entry is *defined* in relation to some section. This member
    holds the relevant section header table index.
  prefs: []
  type: TYPE_NORMAL
- en: st_info
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `st_info` specifies the symbol type and binding attributes. For a complete
    list of these types and attributes, consult the **ELF(5) man page**. The symbol
    types start with STT whereas the symbol bindings start with STB. As an example,
    a few common ones are as explained in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Symbol types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve got the following symbol types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`STT_NOTYPE`: The symbols type is undefined'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STT_FUNC`: The symbol is associated with a function or other executable code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STT_OBJECT`: The symbol is associated with a data object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol bindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve got the following symbol bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`STB_LOCAL`: Local symbols are not visible outside the object file containing
    their definition, such as a function declared static.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STB_GLOBAL`: Global symbols are visible to all object files being combined.
    One file''s definition of a global symbol will satisfy another file''s undefined
    reference to the same symbol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STB_WEAK`: Similar to global binding, but with less precedence, meaning that
    the binding is weak and may be overridden by another symbol (with the same name)
    that is not marked as `STB_WEAK`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are macros for packing and unpacking the binding and type fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ELF32_ST_BIND(info)` or `ELF64_ST_BIND(info)` extract a binding from an `st_info`
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ELF32_ST_TYPE(info)` or `ELF64_ST_TYPE(info)` extract a type from an `st_info`
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ELF32_ST_INFO(bind, type)` or `ELF64_ST_INFO(bind, type)` convert a binding
    and a type into an `st_info` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the symbol table for the following source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the command to see the symbol table entries for functions
    `foochu` and `func1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `foochu` function is a value of `0x80480da`, and is a function
    (`STT_FUNC`) that has a local symbol binding (`STB_LOCAL`). If you recall, we
    talked a little bit about `LOCAL` bindings, which mean that the symbol cannot
    be seen outside the object file it is defined it, which is why `foochu` is local,
    since we declared it with the **static keyword** in our source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Symbols make life easier for everyone; they are a part of ELF objects for the
    purpose of linking, relocation, readable disassembly, and debugging. This brings
    me to the topic of a useful tool that I coded in 2013, named `ftrace`. Similar
    to, and in the same spirit of `ltrace` and `strace`, `ftrace` will trace all of
    the function calls made within the binary and can also show other branch instructions
    such as jumps. I originally designed `ftrace` to help in reversing binaries for
    which I didn''t have the source code while at work. The `ftrace` is considered
    to be a dynamic analysis tool. Let''s take a look at some of its capabilities.
    We compile a binary with the following source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, assuming that we don''t have the preceding source code and we want to
    know the inner workings of the binary that it compiles into, we can run `ftrace`
    on it. First let''s look at the synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[-p]`: This traces by PID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-t]`: This is for the type detection of function args'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-s]`: This prints string values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-v]`: This gives a verbose output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-e]`: This gives miscellaneous ELF information (symbols, dependencies)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-S]`: This shows function calls with stripped symbols'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-C]`: This completes the control flow analysis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A clever individual might now be asking: What happens if a binary''s symbol
    table has been stripped? That''s right; you can strip a binary of its symbol table;
    however, a dynamically linked executable will always retain `.dynsym` but will
    discard `.symtab` if it is stripped, so only the imported library symbols will
    show up.'
  prefs: []
  type: TYPE_NORMAL
- en: If a binary is compiled statically (`gcc-static`) or without `libc` linking
    (`gcc-nostdlib`), and it is then stripped with the `strip` command, a binary will
    have no symbol table at all since the dynamic symbol table is no longer imperative.
    The `ftrace` behaves differently with the `–S` flag that tells `ftrace` to show
    every function call even if there is no symbol attached to it. When using the
    `–S` flag, `ftrace` will display function names as `SUB_<address_of_function>`,
    similar to how IDA pro will show functions that have no symbol table reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following very simple source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding source code simply calls the `foo()` function and exits. The
    reason we are using `_start()` instead of `main()` is because we compile it with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gcc` flag `-nostdlib` directs the linker to omit standard `libc` linking
    conventions and to simply compile the code that we have and nothing more. The
    default entry point is a symbol called `_start()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We now notice that `foo()` function has been replaced by `sub_400144()`, which
    shows that the function call is happening at address `0x400144`. Now if we look
    at the binary `test2` before we stripped the symbols, we can see that `0x400144`
    is indeed where `foo()` is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, to give you a really good idea of how helpful symbols can be to reverse
    engineers (when we have them), let''s take a look at the `test2` binary, this
    time without symbols to demonstrate how it becomes slightly less obvious to read.
    This is primarily because branch instructions no longer have a symbol name attached
    to them, so analyzing the control flow becomes more tedious and requires more
    annotation, which some disassemblers like IDA-pro allow us to do as we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The only thing to give us an idea where a new function starts is by examining
    the **procedure prologue**, which is at the beginning of every function, unless
    (`gcc -fomit-frame-pointer`) has been used, in which case it becomes less obvious
    to identify.
  prefs: []
  type: TYPE_NORMAL
- en: This book assumes that the reader already has some knowledge of assembly language,
    since teaching x86 asm is not the goal of this book, but notice the preceding
    emboldened procedure prologue, which helps denote the start of each function.
    The procedure prologue just sets up the stack frame for each new function that
    has been called by backing up the base pointer on the stack and setting its value
    to the stack pointers before the stack pointer is adjusted to make room for local
    variables. This way variables can be referenced as positive offsets from a fixed
    address stored in the base pointer register `ebp/rbp`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've gotten a grasp on symbols, the next step is to understand relocations.
    We will see in the next section how symbols, relocations, and sections are all
    closely tied together and live at the same level of abstraction within the ELF
    format.
  prefs: []
  type: TYPE_NORMAL
- en: ELF relocations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the ELF(5) man pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Relocation is the process of connecting symbolic references with symbolic
    definitions. Relocatable files must have information that describes how to modify
    their section contents, thus allowing executable and shared object files to hold
    the right information for a process''s program image. Relocation entries are these
    data.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The process of relocation relies on symbols and sections, which is why we covered
    symbols and sections first. In relocations, there are *relocation records*, which
    essentially contain information about how to patch the code related to a given
    symbol. Relocations are literally a mechanism for binary patching and even hot-patching
    in memory when the dynamic linker is involved. The linker program: `/bin/ld` that
    is used to create executable files, and shared libraries must have some type of
    metadata that describes how to patch certain instructions. This metadata is stored
    as what we call relocation records. I will further explain relocations by using
    an example.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine having two object files linked together to create an executable. We
    have `obj1.o` that contains the code to call a function named `foo()` that is
    located in `obj2.o`. Both obj1.o and `obj2.o` are analyzed by the linker program
    and contain relocation records so that they may be linked to create a fully working
    executable program. Symbolic references will be resolved into symbolic definitions,
    but what does that even mean? Object files are relocatable code, which means that
    it is code that is meant to be relocated to a location at a given address within
    an executable segment. Before the relocation process happens, the code has symbols
    and code that will not properly function or cannot be properly referenced without
    first knowing their location in memory. These must be patched after the position
    of the instruction or symbol within the executable segment is known by the linker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at a 64-bit relocation entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And some relocation entries require an addend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `r_offset` points to the location that requires the relocation action. A
    relocation action describes the details of how to patch the code or data contained
    at `r_offset`.
  prefs: []
  type: TYPE_NORMAL
- en: The `r_info` gives both the symbol table index with respect to which the relocation
    must be made and the type of relocation to apply.
  prefs: []
  type: TYPE_NORMAL
- en: The `r_addend` specifies a constant addend used to compute the value stored
    in the relocatable field.
  prefs: []
  type: TYPE_NORMAL
- en: The relocation records for 32-bit ELF files are the same as for 64-bit, but
    use 32-bit integers. The following example for are object file code will be compiled
    as 32-bit so that we can demonstrate **implicit addends**, which are not as commonly
    used in 64-bit. An implicit addend occurs when the relocation records are stored
    in ElfN_Rel type structures that don't contain an `r_addend` field and therefore
    the addend is stored in the relocation target itself. The 64-bit executables tend
    to use the `ElfN_Rela` structs that contain an **explicit addend**. I think it
    is worth understanding both scenarios, but implicit addends are a little more
    confusing, so it makes sense to bring light to this area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that it calls the `foo()` function. However, the `foo()` function is
    not located directly within that source code file; so, upon compiling, there will
    be a relocation entry created that is necessary for later satisfying the symbolic
    reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the call to `foo()` is highlighted and it contains the value
    `0xfffffffc`, which is the *implicit addend*. Also notice the `call 7`. The number
    `7` is the offset of the relocation target to be patched. So when `obj1.o` (which
    calls `foo()` located in `obj2.o`) is linked with `obj2.o` to make an executable,
    a relocation entry that points at offset `7` is processed by the linker, telling
    it which location (offset 7) needs to be modified. The linker then patches the
    4 bytes at offset 7 so that it will contain the real offset to the `foo()` function,
    after `foo()` has been positioned somewhere within the executable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The call instruction `e8 fc ff ff ff` contains the implicit addend and is important
    to remember for this lesson; the value `0xfffffffc` is `-(4)` or `-(sizeof(uint32_t))`.
    A dword is 4 bytes on a 32-bit system, which is the size of this relocation target.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, a relocation field at offset 7 is specified by the relocation
    entry's `r_offset` field.
  prefs: []
  type: TYPE_NORMAL
- en: '`R_386_PC32` is the relocation type. To understand all of these types, read
    the ELF specs. Each relocation type requires a different computation on the relocation
    target being modified. `R_386_PC32` modifies the target with `S + A – P`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S` is the value of the symbol whose index resides in the relocation entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A` is the addend found in the relocation entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`P` is the place (section offset or address) of the storage unit being relocated
    (computed using `r_offset`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the final output of our executable after compiling `obj1.o`
    and `obj2.o` on a 32-bit system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the call instruction **(the relocation target) at 0x80480de**
    has been modified with the 32-bit offset value of `5`, which points `foo()`. The
    value `5` is the result of the `R386_PC_32` relocation action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `0xfffffffc` is the same as `–4` if a signed integer, so the calculation
    can also be seen as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate an offset into a virtual address, use the following computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Which in this case is `0x80480de + 5 + 5 = 0x80480e8`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pay attention to this computation as it is important to remember and can be
    used when calculating offsets to addresses frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'An address may also be computed into an offset with the following computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, the ELF specs cover ELF relocations in depth, and we
    will be visiting some of the types used in dynamic linking in the next section,
    such as `R386_JMP_SLOT` relocation entries.
  prefs: []
  type: TYPE_NORMAL
- en: Relocatable code injection-based binary patching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Relocatable code injection is a technique that hackers, virus writers, or anyone
    who wants to modify the code in a binary may utilize as a way to relink a binary
    after it's already been compiled and linked into an executable. That is, you can
    inject an object file into an executable, update the executable's symbol table
    to reflect newly inserted functionality, and perform the necessary relocations
    on the injected object code so that it becomes a part of the executable.
  prefs: []
  type: TYPE_NORMAL
- en: A complicated virus might use this technique rather than just appending position-independent
    code. This technique requires making room in the target executable to inject the
    code, followed by applying the relocations. We will cover binary infection and
    code injection more thoroughly in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](part0015_split_000.html#E9OE2-1d4163ae11644cc2802846625b2dc985
    "Chapter 1. The Linux Environment and Its Tools"), *The Linux Environment and
    Its Tools*, there is an amazing tool called *Eresi* ([http://www.eresi-project.org](http://www.eresi-project.org)),
    which is capable of relocatable code injection (aka `ET_REL` injection). I also
    designed a custom reverse engineering tool for ELF, namely, **Quenya**. It is
    very old but can be found at [http://www.bitlackeys.org/projects/quenya_32bit.tgz](http://www.bitlackeys.org/projects/quenya_32bit.tgz).
    Quenya has many features and capabilities, and one of them is to inject object
    code into an executable. This can be very useful for patching a binary by hijacking
    a given function. Quenya is only a prototype and was never developed to the extent
    that the *Eresi* project was. I am only using it as an example because I am more
    familiar with it; however, I will say that for more reliable results, it may be
    desirable to either use *Eresi* or write your own tooling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us pretend we are an attacker and we want to infect a 32-bit program that
    calls `puts()` to print `Hello World`. Our goal is to hijack `puts()` so that
    it calls `evil_puts()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we compile `evil_puts.c` into `evil_puts.o` and inject it into our program
    called `./hello_world`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This program calls the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We now use `Quenya` to inject and relocate our `evil_puts.o` file into `hello_world`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `write()` function from our `evil_puts.o` object file has
    been relocated and assigned an address at `0x804861e` in the executable file `hello_world`.
    The next command hijack overwrites the global offset table entry for `puts()`
    with the address of `evil_puts()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: And Whammi!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully relocated an object file into an executable and modified
    the executable's control flow so that it executes the code that we injected. If
    we use `readelf -s` on `hello_world`, we can actually now see a symbol for `evil_puts()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For your interest, I have included a small snippet of code that contains the
    ELF relocation mechanics in Quenya; it may be a little bit obscure without seeing
    the rest of the code base, but it is also somewhat straightforward if you have
    retained what we learned about relocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the relocation target that `RelocPtr` points
    to is modified according to the relocation action requested by the relocation
    type (such as `R_386_32`).
  prefs: []
  type: TYPE_NORMAL
- en: Although relocatable code binary injection is a good example of the idea behind
    relocations, it is not a perfect example of how a linker actually performs it
    with multiple object files. Nevertheless, it still retains the general idea and
    application of a relocation action. Later on we will talk about shared library
    (`ET_DYN`) injection, which brings us now to the topic of dynamic linking.
  prefs: []
  type: TYPE_NORMAL
- en: ELF dynamic linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the old days, everything was statically linked. If a program used external
    library functions, the entire library was compiled directly into the executable.
    ELF supports dynamic linking, which is a much more efficient way to go about handling
    shared libraries.
  prefs: []
  type: TYPE_NORMAL
- en: When a program is loaded into memory, the dynamic linker also loads and binds
    the shared libraries that are needed to that process address space. The topic
    of dynamic linking is rarely understood by people in any depth as it is a relatively
    complex procedure and seems to work like magic under the hood. In this section,
    we will demystify some of its complexities and reveal how it works and also how
    it can be abused by attackers.
  prefs: []
  type: TYPE_NORMAL
- en: Shared libraries are compiled as position-independent and can therefore be easily
    relocated into a process address space. A shared library is a dynamic ELF object.
    If you look at `readelf -h lib.so`, you will see that the `e_type` (**ELF file
    type**) is called `ET_DYN`. Dynamic objects are very similar to executables. They
    do not typically have a `PT_INTERP` segment since they are loaded by the program
    interpreter, and therefore will not be invoking a program interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: When a shared library is loaded into a process address space, it must have any
    relocations satisfied that reference other shared libraries. The dynamic linker
    must modify the GOT (Global offset table) of the executable (located in the section
    `.got.plt`), which is a table of addresses located in the data segment. It is
    in the data segment because it must be writeable (at least initially; see read-only
    relocations as a security feature). The dynamic linker patches the GOT with resolved
    shared library addresses. We will explain the process of **lazy linking** shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The auxiliary vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a program gets loaded into memory by the `sys_execve()` syscall, the executable
    is mapped in and given a stack (among other things). The stack for that process
    address space is set up in a very specific way to pass information to the dynamic
    linker. This particular setup and arrangement of information is known as the **auxiliary
    vector** or **auxv**. The bottom of the stack (which is its highest memory address
    since the stack grows down on x86 architecture) is loaded with the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The auxiliary vector](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*[argc][argv][envp][auxiliary][.ascii data for argv/envp]*'
  prefs: []
  type: TYPE_NORMAL
- en: The auxiliary vector (or auxv) is a series of ElfN_auxv_t structs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `a_type` describes the auxv entry type, and the a_val provides its value.
    The following are some of the most important entry types that are needed by the
    dynamic linker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The dynamic linker retrieves information from the stack about the executing
    program. The linker must know where the program headers are, the entry point of
    the program, and so on. I listed only a few of the auxv entry types previously,
    taken from `/usr/include/elf.h`.
  prefs: []
  type: TYPE_NORMAL
- en: The auxiliary vector gets set up by a kernel function called `create_elf_tables()`
    that resides in the Linux source code `/usr/src/linux/fs/binfmt_elf.c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the execution process from the kernel looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sys_execve()` →.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls `do_execve_common()` →.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls `search_binary_handler()` →.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls `load_elf_binary()` →.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls `create_elf_tables()` →.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is some of the code from `create_elf_tables()` in `/usr/src/linux/fs/binfmt_elf.c`
    that adds auxv entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the ELF entry point and the address of the program headers,
    among other values, are placed onto the stack with the `NEW_AUX_ENT()` macro in
    the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Once a program is loaded into memory and the auxiliary vector has been filled
    in, control is passed to the dynamic linker. The dynamic linker resolves symbols
    and relocations for shared libraries that are linked into the process address
    space. By default, an executable is dynamically linked with the GNU C library
    `libc.so`. The `ldd` command will show you the shared library dependencies of
    a given executable.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the PLT/GOT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PLT (procedure linkage table) and GOT (Global offset table) can be found
    in executable files and shared libraries. We will be focusing specifically on
    the PLT/GOT of an executable program. When a program calls a shared library function
    such as `strcpy()` or `printf()`, which are not resolved until runtime, there
    must exist a mechanism to dynamically link the shared libraries and resolve the
    addresses to the shared functions. When a dynamically linked program is compiled,
    it handles shared library function calls in a specific way, far differently from
    a simple `call` instruction to a local function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a call to the libc.so function `fgets()` in a 32-bit
    compiled ELF executable. We will use a 32-bit executable in our examples because
    the relationship with the GOT is easier to visualize since IP relative addressing
    is not used, as it is in 64-bit executables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The address `0x8048360` corresponds to the PLT entry for `fgets()`. Let''s
    take a look at that address in our executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: So the call to `fgets()` leads to 8048360, which is the PLT jump table entry
    for `fgets()`. As we can see, there is an indirect jump to the address stored
    at `0x804a000` in the preceding disassembled code output. This address is a GOT
    (Global offset table) entry that holds the address to the actual `fgets()` function
    in the libc shared library.
  prefs: []
  type: TYPE_NORMAL
- en: However, the first time a function is called, its address has not yet been resolved
    by the dynamic linker, when the default behavior lazy linking is being used. Lazy
    linking implies that the dynamic linker should not resolve every function at program
    loading time. Instead, it will resolve the functions as they are called, which
    is made possible through the `.plt` and `.got.plt` sections (which correspond
    to the Procedure linkage table, and the Global offset table, respectively). This
    behavior can be changed to what is called strict linking with the `LD_BIND_NOW`
    environment variable so that all dynamic linking happens right at program loading
    time. Lazy linking increases performance at load time, which is why it is the
    default behavior, but it also can be unpredictable since a linking error may not
    occur until after the program has been running for some time. I have actually
    only experienced this myself one time over the course of years. It is also worth
    noting that some security features, namely, read-only relocations cannot be applied
    unless strict linking is enabled because the `.plt.got` section (among others)
    is marked read-only; this can only occur after the dynamic linker has finished
    patching it, and thus strict linking must be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the relocation entry for `fgets()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`R_386_JUMP_SLOT` is a relocation type for PLT/GOT entries. On `x86_64`, it
    is called `R_X86_64_JUMP_SLOT`.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the relocation offset is the address 0x804a000, the same address
    that the `fgets()` PLT jumps into. Assuming that `fgets()` is being called for
    the first time, the dynamic linker has to resolve the address of `fgets()` and
    place its value into the GOT entry for `fgets()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the GOT in our test program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The address `0x08048366` is highlighted in the preceding and is found at `0x804a000`
    in the GOT. Remember that little endian reverses the byte order, so it appears
    as `66 83 04 08`. This address is not the address to the `fgets()` function since
    it has not yet been resolved by the linker, but instead points back down into
    the PLT entry for `fgets()`. Let''s look at the PLT entry for `fgets()` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: So, `jmp *0x804a000` jumps to the contained address there within `0x8048366`,
    which is the `push $0x0` instruction. That push instruction has a purpose, which
    is to push the GOT entry for `fgets()` onto the stack. The GOT entry offset for
    `fgets()` is 0x0, which corresponds to the first GOT entry that is reserved for
    a shared library symbol value, which is actually the fourth GOT entry, GOT[3].
    In other words, the shared library addresses don't get plugged in starting at
    GOT[0] and they begin at GOT[3] (the fourth entry) because the first three are
    reserved for other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take note of the following GOT offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: GOT[0] contains an address that points to the dynamic segment of the executable,
    which is used by the dynamic linker for extracting dynamic linking-related information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GOT[1] contains the address of the `link_map` structure that is used by the
    dynamic linker to resolve symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GOT[2] contains the address to the dynamic linkers `_dl_runtime_resolve()` function
    that resolves the actual symbol address for the shared library function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last instruction in the `fgets()` PLT stub is a jmp 8048350\. This address
    points to the very first PLT entry in every executable, known as PLT-0.
  prefs: []
  type: TYPE_NORMAL
- en: '**PLT-0** from our executable contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The first `pushl` instruction pushes the address of the second GOT entry, GOT[1],
    onto the stack, which, as noted earlier, contains the address of the `link_map`
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: The `jmp *0x8049ffc` performs an indirect jmp into the third GOT entry, GOT[2],
    which contains the address to the dynamic linkers `_dl_runtime_resolve()` function,
    therefore transferring control to the dynamic linker and resolving the address
    for `fgets()`. Once `fgets()` has been resolved, all future calls to the PLT entry
    `forfgets()` will result in a jump to the `fgets()` code itself, rather than pointing
    back into the PLT and going through the lazy linking process again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a summary of what we have just covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `fgets@PLT` (to call the `fgets` function).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PLT code does an indirect `jmp` to the address in the GOT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The GOT entry contains the address that points back into PLT at the `push` instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `push $0x0` instruction pushes the offset of the `fgets()` GOT entry onto
    the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final `fgets()` PLT instruction is a jmp to the PLT-0 code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first instruction of PLT-0 pushes the address of GOT[1] onto the stack that
    contains an offset into the `link_map` struct for `fgets()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second instruction of PLT-0 is a jmp to the address in GOT[2] that points
    to the dynamic linker's `_dl_runtime_resolve()`, which then handles the `R_386_JUMP_SLOT`
    relocation by adding the symbol value (memory address) of `fgets()` to its corresponding
    GOT entry in the `.got.plt` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next time `fgets()` is called, the PLT entry will jump directly to the function
    itself rather than having to perform the relocation procedure again.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic segment revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I earlier referenced the dynamic segment as a section named `.dynamic`. The
    dynamic segment has a section header referencing it, but it also has a program
    header referencing it because it must be found during runtime by the dynamic linker;
    since section headers don't get loaded into memory, there has to be an associated
    program header for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dynamic segment contains an array of structs of type `ElfN_Dyn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `d_tag` field contains a tag that matches one of the numerous definitions
    that can be found in the ELF(5) man pages. I have listed some of the most important
    ones used by the dynamic linker.
  prefs: []
  type: TYPE_NORMAL
- en: DT_NEEDED
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This holds the string table offset to the name of a needed shared library.
  prefs: []
  type: TYPE_NORMAL
- en: DT_SYMTAB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This contains the address of the dynamic symbol table also known by its section
    name `.dynsym`.
  prefs: []
  type: TYPE_NORMAL
- en: DT_HASH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This holds the address of the symbol hash table, also known by its section name
    `.hash` (or sometimes named `.gnu.hash`).
  prefs: []
  type: TYPE_NORMAL
- en: DT_STRTAB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This holds the address of the symbol string table, also known by its section
    name `.dynstr`.
  prefs: []
  type: TYPE_NORMAL
- en: DT_PLTGOT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This holds the address of the global offset table.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding dynamic tags demonstrate how the location of certain sections
    can be found through the dynamic segment that can aid in the forensics reconstruction
    task of rebuilding a section header table. If the section header table has been
    stripped, a clever individual can rebuild parts of it by getting information from
    the dynamic segment (that is, the .dynstr, .dynsym, and .hash, among others).
  prefs: []
  type: TYPE_NORMAL
- en: Other segments such as text and data can yield information that you need as
    well (such as for the `.text` and `.data` sections).
  prefs: []
  type: TYPE_NORMAL
- en: The `d_val` member of `ElfN_Dyn` holds an integer value that has various interpretations
    such as being the size of a relocation entry to give one instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `d_ptr` member holds a virtual memory address that can point to various
    locations needed by the linker; a good example would be the address to the symbol
    table for the `d_tag` `DT_SYMTAB`.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic linker utilizes the `ElfN_Dyn` `d_tags` to locate the different
    parts of the dynamic segment that contain a reference to a part of the executable
    through the `d_tag` such as `DT_SYMTAB`, which has a `d_ptr` to give the virtual
    address to the symbol table.
  prefs: []
  type: TYPE_NORMAL
- en: When the dynamic linker is mapped into memory, it first handles any of its own
    relocations if necessary; remember that the linker is a shared library itself.
    It then looks at the executable program's dynamic segment and searches for the
    `DT_NEEDED` tags that contain pointers to the strings or pathnames of the necessary
    shared libraries. When it maps a needed shared library into the memory, it accesses
    the library's dynamic segment (yes, they too have dynamic segments) and adds the
    library's symbol table to a chain of symbol tables that exists to hold the symbol
    tables for each mapped library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The linker creates a struct `link_map` entry for each shared library and stores
    it in a linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Once the linker has finished building its list of dependencies, it handles the
    relocations on each library, similar to the relocations we discussed earlier in
    this chapter, as well as fixing up the GOT of each shared library. **Lazy linking**
    still applies to the PLT/GOT of shared libraries as well, so GOT relocations (of
    type `R_386_JMP_SLOT`) won't happen until the point when a function has actually
    been called.
  prefs: []
  type: TYPE_NORMAL
- en: For more detailed information on ELF and dynamic linking, read the ELF specification
    online or take a look at some of the interesting glibc source code available.
    Hopefully, dynamic linking has become less of a mystery and more of an intrigue
    at this point. In [Chapter 7](part0069_split_000.html#21PMQ1-1d4163ae11644cc2802846625b2dc985
    "Chapter 7. Process Memory Forensics"), *Process Memory Forensics* we will be
    covering PLT/GOT poisoning techniques to redirect shared library function calls.
    A very fun technique is to subvert dynamic linking.
  prefs: []
  type: TYPE_NORMAL
- en: Coding an ELF Parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help summarize some of what we have learned, I have included some simple
    code that will print the program headers and section names of a 32-bit ELF executable.
    Many more examples of ELF-related code (and much more interesting ones) will be
    shown throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have explored ELF, I urge the reader to continue to explore the
    format. You will encounter a number of projects throughout this book that will
    hopefully inspire you to do so. It has taken years of passion and exploration
    to learn what I have. I am grateful to be able to share what I have learned and
    present it in a way that will help the reader learn this difficult material in
    a fun and creative way.
  prefs: []
  type: TYPE_NORMAL
