- en: API Testing â€“ Guards on the Gates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we fixed the issues that we had identified and completed
    the remaining things in our RESTful web service. However, to ensure quality we
    need to test our endpoints, and manual testing is not enough. In real-world projects,
    we can't test each endpoint repeatedly because in the real world there are a lot
    more endpoints. So, we move towards automated testing. We write test cases and
    execute them in an automated way. In fact, it makes more sense to write test cases
    first, run them, and then write code to fulfill the requirements of that test.
    This method of development is called **TDD** (**Test-driven Development**).
  prefs: []
  type: TYPE_NORMAL
- en: 'TDD is good and ensures that we are working exactly according to our test cases.
    However, in this book, we didn''t use TDD because there were a lot of things to
    understand and we didn''t want to include one more thing at the same time. So
    now, when we are done with the concepts, understanding, and writing the RESTful
    web service in Lumen (which was also new for many of us), now we can do this missing
    thing, that is, testing. TDD is not essential, but testing is. If we haven''t
    written tests till now in favor of understanding other stuff, then we should do
    it now. The following are the topics that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The need for automated API tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Types of tests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What type of tests will we write?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing frameworks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to CodeCeption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup and configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing API tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary and more resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier, in the real world, we can't test every endpoint repeatedly
    after every major feature or change. We can try but we are human and we can miss
    out on that. The bigger problem is that we may sometimes think that we tested
    it but miss it and because there is no record of what we tested, we can't know.
    If we have a separate quality assurance team or person, they will most probably
    test and keep a record of that. However, in case of a RESTful web service, it
    will take more of their time or the possibility is that the QA person will test
    the end product as a whole and not RESTful web service.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the RESTful web service works as one component or one side of a product,
    there are more low-level components of the RESTful web service as well. Not just
    endpoints but those endpoints depends on more low-level code. So in order to make
    our debugging easier, we write tests for these low-level components as well. Also,
    this way we can ensure that these low-level components are working fine and doing
    what they intend to. In case of any issues, we can run tests and know exactly
    what is not working properly.
  prefs: []
  type: TYPE_NORMAL
- en: Although, writing tests takes time at first but it is good in the long run.
    First of all, it saves the time of testing the same endpoints repeatedly after
    every change. Then, it helps a lot in case of refactoring something. It lets us
    know where the ripple effect is and what is affected because of our refactoring.
    Although, it takes time initially to write tests but it's worth it if we intend
    to make something that will remain there. In fact, the software development cost
    is less than the maintenance cost. This is because it will be developed once but
    to maintain and do the changes, it will consume more time. So, if we have written
    automated tests, it will ensure that everything is working exactly as required
    because the person who is maintaining the code is probably not the one who wrote
    it the first time.
  prefs: []
  type: TYPE_NORMAL
- en: There is no one type of testing that provides all these benefits but there are
    different types of testing, with each having their own benefits. Now that we know
    the importance of automated testing and writing test cases, let's learn about
    the different types of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Types of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different types of testing in different contexts. In our case, we
    will discuss four major types of automated testing. These are the different types,
    based on how and what we test:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In unit testing, we test different units separately. By unit, we mean very small
    independent components. Obviously, components depend on each other but we consider
    a very small unit. In our case that small unit is class. The class is a unit that
    should have a single responsibility and it should be abstract from others and
    depend on the minimum number of other classes or components. Anyway, we can say
    in unit testing, we test class by creating an object of that class irrespective
    of whether it fulfills the required behavior.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to understand is that during unit tests, our test shouldn't
    touch code other than class/code under testing. If this code is interacting with
    some other object or external stuff during unit testing, we should mock these
    objects instead of interacting with actual objects so that the result of other
    object's methods should not affect the result of the unit/class we are testing.
    You are probably wondering what do we mean by mocking? **Mocking** means providing
    a fake object and setting it as per the desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we are testing using the `User` class and it depends on the
    `Role` class, then a problem in the `Role` class shouldn't let the `User` class
    test fail. To achieve that, we will mock the `Role` object and inject in the `User`
    class object and then set the fixed return value for the method of the `Role`
    class that the `User` class is using. So next, it will actually invoke the `Role`
    class and will not depend on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of unit testing:'
  prefs: []
  type: TYPE_NORMAL
- en: It will let us know if a class is not doing what it intends to do. After some
    time, when the project is in maintenance, another developer will be able to understand
    what this class intends to do. What its methods are intended to do. So it will
    be like a manual of class written by a developer who knew why they wrote that
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, as we just discussed we should mock objects, on which class under testing
    depends, we should be able to inject the mocked object inside the object of the
    class under testing. If we will be able to do that and are able to manage without
    invoking an outside object, only then we can call our code, a testable code. If
    our code is not testable, then we cannot write a unit test for it. So, unit testing
    helps us make our code testable which actually is more loosely coupled code. So
    having the testable code is an advantage (as it is loosely coupled and more maintainable),
    even if we are not writing tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will let us debug where exactly the problem is if we are having any problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As unit tests don't interact with outside objects, they are faster than some
    other types of testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers who write unit tests are considered to be better developers, as code
    with tests is consider cleaner code because the developer has ensured that unit
    level components are not tightly coupled. And units tests can be used as a manual
    to what a class provides and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Acceptance testing is the complete opposite of unit testing. Unit testing is
    done at the lowest level while acceptance testing is done at the highest level.
    Acceptance testing is how an end-user will see the product and how an end-user
    will interact with it. In case of a website, in acceptance testing, we write the
    test that hits the URL from outside. Testing tools simulate a browser or external
    client to hit the URL. In fact, some testing tools also provide an option to use
    a web browser, such as Chrome or Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, these tests are written by a QA team. It is because they are
    the people who are there to ensure that system is working for the end user, exactly
    how it is intended to. Also, these tests execution is slow. And for user interfaces,
    sometimes there is a lot of detail to test so a separate QA team does this type
    of testing. However, it is just a common practice, so there can be an exception
    to that depending on the situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of acceptance testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance testing lets you see how an end user will see and interact with your
    software from outside
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also lets you catch the problem, that will occur in any specific web browser
    because it uses a real web browser to execute tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As acceptance tests are written to be performed from outside, it doesn't matter
    which system you are testing and what technology or framework is used to write
    the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if you are writing test cases using a tool written in PHP, then
    you can use it for systems written in other languages as well. So it doesn't matter
    if development language is PHP, Python, Golang, or .Net. It is because acceptance
    tests hit the system from outside without any internal knowledge of the system.
    And it is the only one of these four types of tests which test the system without
    considering any inner detail.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests are very useful as they interact with your system with a real
    browser. So if some thing will not work in the specific browser, then these things
    can be identified. But keep in mind that with a real browser, these tests take
    time to execute. It is also slow if the browser simulation is used but still the
    browser simulation will take less time than the real browser. Note that acceptance
    testing is considered the slowest and most time consuming among these four types
    of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional testing is similar to acceptance testing; however, it is from a different
    aspect. Functional testing is about testing functional requirements. It tests
    functional requirements and tests from outside the system. However, it has visibility
    inside and it can execute some code of the system in the test case.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to acceptance testing it hits the URL; however, even to hit the URL,
    it executes code the browser or external client will execute on that specific
    the URL. However, it doesn't actually hit the URL from outside. Tests don't hit
    URL in reality, they just simulate it. It is because unlike acceptance testing,
    we are not interested in how exactly an end user will interact with it, instead
    if code is executed from that URL then we want to know the response.
  prefs: []
  type: TYPE_NORMAL
- en: We are more interested in if our functional requirements are met, and if not
    met then where is the problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of functional testing:'
  prefs: []
  type: TYPE_NORMAL
- en: With functional testing, the testing tool has access to the system, so it shows
    better error detail than acceptance testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional tests don't actually open the browser or external client, so they
    are faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In functional tests, we can also execute system code directly through the testing
    tool, so in some cases, we can do so to either save test case writing time, or
    to make test case execution faster. There are many testing tools available for
    that. We will use one of them named CodeCeption shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration testing is very similar to unit testing in a way that in both types
    of testing we test classes by making their objects invoke their methods. But they
    are different in how we test classes. In case of unit testing, we don't touch
    other objects with which our class under test is interacting with. But in integration
    testing, we want to see how it all works together. We let them interact with each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, everything is working fine as per the unit test but not at higher-level
    tests (functional test or acceptance test) where we test it on the basis of requirements
    by hitting the URL. So, in some cases, higher-level tests are failing and unit
    tests are passing so to narrow down where the problem is, integration tests are
    very useful. So, you can consider that the integration test stands somewhere between
    functional tests and unit tests. Functional testing is about testing the functional
    requirement while unit testing is about testing a single unit. So, an integration
    test is in the middle of both, it tests how these single units work together;
    however, it tests by testing small components from code but lets them interact
    with each other as well.
  prefs: []
  type: TYPE_NORMAL
- en: Some developers write integration tests and call it a unit test. Actually, integration
    tests just let code under the test to interact with other objects, so it can test
    how those classes work when they interact with system components. So, some people
    write integration tests if the code under test is very simple that needs to be
    tested while interacting with the system. However, it is not necessary to only
    write one unit test or integration test, you can write both if you have time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of integration testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing is useful when unit tests are not enough to catch bugs and
    high-level tests keep telling you that there is something wrong. So, integration
    tests helps in debugging the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the nature of integration testing, it helps a lot in case of refactoring
    while telling you exactly what is affected by the new change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What type of testing will we do?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every type of testing has its own importance, especially unit testing. However,
    we will mainly do API testing that will be testing our RESTful web service endpoints.
    It never means that unit testing is less important, it is just that we are mainly
    focusing on API testing in this chapter because the book is focused on RESTful
    web services. In fact, testing is a big topic and you will be able to see complete
    books written on testing and TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, **BDD** (**Behavior-driven Development**) is a more popular term.
    It is not completely different than TDD. It is just a different way of stating
    test cases. In fact, in BDD, there are no test cases instead there are specs.
    They serve the same purpose but BDD has a more friendly way to address the problem
    that is by stating specs and implementing them and that's how TDD works. So TDD
    and BDD are not different, just a different way to address the same problem.
  prefs: []
  type: TYPE_NORMAL
- en: We can perform API testing in both functional and acceptance testing ways. However,
    it makes more sense to write API tests as functional tests. Because functional
    tests will be fast as well as having an insight to our code base. It also makes
    more sense because acceptance tests are for end users and end users don't use
    API. The end user uses a user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Testing frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like we have frameworks for writing software, we have frameworks for writing
    test cases as well. As we are PHP developers, we will use a testing framework
    that is written in PHP or in which we can write test cases in PHP so that we can
    use it easily.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, there are different testing frameworks that we can use in PHP,
    no matter which development framework we are using for application development.
    However, there are also testing tools that come with Laravel and Lumen. We can
    also use them for writing test cases. In fact, it will be easier to write test
    cases for Lumen but it will be Lumen and Laravel specific. Here, we will use a
    framework that you will be able to use outside the Lumen and Laravel ecosystems
    as well as for any PHP project, no matter which development framework you are
    using to write the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different testing frameworks in PHP so how will we decide which
    one we want to use? We are going to use a framework that will not be so low level
    that we need to write everything by ourselves because we are not going to write
    unit tests but functional tests so we are picking up a bit of a high-level framework.
    A famous framework for unit testing is PHPUnit: [https://phpunit.de/](https://phpunit.de/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another unit testing framework in **BDD** (**Behavior-driven Development**)
    style named as PHPSpec: [http://www.phpspec.net](http://www.phpspec.net) and PHPSpec
    is awesome if you are trying to learn or write unit tests. However, here we will
    be using a framework that is good for both functional and unit tests. Although,
    we are not writing unit tests but we want to consider a framework that you can
    later use for unit testing as well. The framework I have picked is CodeCeption:
    [http://codeception.com/](http://codeception.com/) because it seems very good
    at API testing. Another BDD-style alternative could be Behat: [http://behat.org/en/latest/](http://behat.org/en/latest/).
    It is a high-level testing framework but it is better if we are doing acceptance
    testing or even better if we have a separate QA team who will be writing many
    test cases in the Gherkin syntax ([https://github.com/cucumber/cucumber/wiki/Gherkin](https://github.com/cucumber/cucumber/wiki/Gherkin))
    that is very close to the natural language. However, Behat and Gherkin may have
    a bit more of a learning curve for PHP developers while CodeCeption is simply
    PHP (although it can use Gherkin if required), so as many readers will be new
    to writing test cases I will keep things simple and close to PHP. However, here
    is a detailed comparison I wrote 2 years ago on which framework to use for API
    testing, it is old but still valid for most of the stuff. If you are interested
    then you can have a look at [http://haafiz.me/programming/api-testing-selecting-testing-framework](http://haafiz.me/programming/api-testing-selecting-testing-framework).'
  prefs: []
  type: TYPE_NORMAL
- en: CodeCeption introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CodeCeption is written in PHP and it is powered by PHPUnit. CodeCeption claims
    that *CodeCeption uses PHPUnit as a backend for running its tests. Thus, any PHPUnit
    test can be added to a CodeCeption test suite and then executed*.
  prefs: []
  type: TYPE_NORMAL
- en: Tests other than acceptance tests require a testing framework that has some
    insight or connection with code under the test. If we are using a development
    framework than a testing framework should has some sort of module or plugin for
    that framework. CodeCeption is good at this. It provides modules for different
    frameworks and CMS, such as Symfony, Joomla, Laravel, Lumen, Yii2, WordPress,
    and Zend frameworks. Just to let you know, these are just a few frameworks. CodeCeption
    has support for many other modules that can be helpful in different cases.
  prefs: []
  type: TYPE_NORMAL
- en: Setup and understanding the structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different ways to install CodeCeption but I prefer composer and it
    is a standard way to install different PHP tools as PHP packages. So let''s install
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using the `--dev` flag so that it will add CodeCeption
    in the `require-dev` block in the `composer.json` file. So, in production it will
    not be installed when you run `composer install --no-dev`, it will not install
    dependencies in the `require-dev` block. In case of confusion, check the composer-related
    chapter that is [Chapter 5](2221827f-3115-4141-a9c1-f4a30cf0f2a9.xhtml), *Load
    and resolve with Composer, an Evolutionary*.
  prefs: []
  type: TYPE_NORMAL
- en: After installing it, we need to set it up for writing test cases and to make
    it a part of our project. Installation just means that it is now in the `vendors`
    directory and now we can execute CodeCeption commands through composer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up, we need to run the CodeCeption bootstrap command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`codecept` is CodeCeption''s executable in the `vendor/bin` directory, so we
    executed it through composer and gave it an argument to run the `bootstrap` command.
    So after executing this command, some files and directories will be added in your
    project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the mentioned list of files, then you will notice that we have
    one file at root, that is, `codeception.yml`, which contains the basic configurations
    of CodeCeption tests. It tells us about paths and basic settings. If you read
    this file, you will be able to easily understand it. If you don't understand something,
    ignore it for now. Other than this file, everything is in the `tests/` directory.
    This stuff is more important to us.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, there are two empty directories in the `tests/` directory. `_output`
    contains output of test cases in case of failure and `_data` contains database
    queries in case we want to set up a default database for testing before and after
    running tests.
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, you can see there are three groups of files having similar
    files with the difference of testing type. In CodeCeption, we know these groups
    as test suites. So, by default CodeCeption comes with three test suites. The acceptance,
    functional, and unit suites. All these three suites contain four files and one
    empty directory. So, let's look into the purpose of each of these files and directory.
  prefs: []
  type: TYPE_NORMAL
- en: tests/{suite-name}/
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, `{suite-name}` will be replaced by the suite's actual name; like in case
    of unit suite, it will be `tests/unit/`.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, this directory will be used to save test cases that we will write.
  prefs: []
  type: TYPE_NORMAL
- en: tests/{suite-name}.suite.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This file is a configuration file specific to that suite. It contains `ActorName`
    for this particular suite. Actor is nothing else than one with specific settings
    and capabilities. Based on actor settings, it runs tests differently. Settings
    include the module's configurations and enabling modules.
  prefs: []
  type: TYPE_NORMAL
- en: tests/_support/_generated/{suite-name}TesterActions.php
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This file is an auto generated file based on settings in `tests/{suite-name}.suite.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: tests/_support/{suite-name}Tester.php
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This file uses the generated file in the `_generated` directory and the developer
    can customize it more, if required. However, normally it isn't required.
  prefs: []
  type: TYPE_NORMAL
- en: tests/_support/Helper/{suite-name}.php
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This file in the suite is the helper file. Here, you can add more methods in
    class and use that in your test cases. Just like other code has libraries and
    helpers, your test-cases code can also have helper methods in the helper class
    for that suite.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can add more files, if you need different helper classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the API suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our case, we need unit tests and API tests. Although, we can use the functional
    tests suite for API tests because these are at the functional testing level but
    for the sake of clarity and understanding, we can create a separate API suite
    through this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in this command, `g` is short for generate and it will generate an API
    suite. `api` is just the name of another suite, and this command has created these
    files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `api.suite.yml` file will have basic settings without much detail. It is
    because the `api.suite.yml` file will have basic settings without much detail.
    It is because `api` here is just a name. You could even say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It should have created `abc` suite with the same file structure and settings.
    So, our API Suite is just another test suite that we created separately for the
    sake of clarity and understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the API suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'API needs REST client to fetch RESTful web service endpoints. Other than that
    it depends on Lumen. We said Lumen because it will be integrated with our code
    as we are writing functional level tests not acceptance tests. So, our testing
    framework should have insight and interaction with Lumen. What else will we need
    in our configuration? We need to set the testing `.env` file. So, with that here
    is what our configuration file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Before proceeding further, note that we have specified a different environment
    file option here under the `config/Lumen`, that is, `environment_file: .env.testing`.
    So, if we are specifying `.env.testing` here, then we should have a `.env.testing`.
    Nothing big, just copy and paste your `.env` file. From the command line, execute
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Change the database credentials so that it points to the different database,
    having a copy of your current database schema and data, based on which you want
    to write test cases. Although, database-related stuff we will do during testing
    in Laravel/Lumen will be rollback, and will not affect our actual database, so
    the same database will be fine in the development. However, it is not recommended,
    in fact, prohibited on staging to have the same database for testing; so, better
    to keep different databases and configurations from the start.
  prefs: []
  type: TYPE_NORMAL
- en: We don't run tests in production. We don't even install tests related tool in
    production, as you can see we installed CodeCeption with the `--dev` flag. So,
    when our code is in production and we want to deploy a new feature, our test cases
    are run on a different server and then the code is deployed on the production
    server. There are several **CI** (**Continuous Integration**) tools available
    for that.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time to write test cases. The first thing is how we decide what we
    should test. Should we start testing every endpoint and then every class?
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to understand is that we should only test the code that is written
    by us. By us, I mean someone from our team. We don't intend to test the code that
    is third-party, framework code, or a package. Also, we don't want to test each
    and every class and every method. In an ideal case, we can test each and every
    minor function's details but it has its drawbacks. First of all in the real world,
    we don't have time for that. We intend to test most parts but not all parts. Another
    reason is that all the tests that we are writing are a liability as well. We also
    need to maintain these tests over time. So, we do unit test for the parts where
    it makes sense to do so; where it is actually doing something which have some
    complexity. If you have a function that is as simple as that it calls another
    function and returns the result then I don't think that such piece of code should
    have its own test.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing is, if we are doing unit testing as well as API testing then from
    where should we start writing tests? Should we write tests for all endpoints and
    then all classes or we will do the opposite so we will first test all classes
    and then all endpoints? How will we do that? We obviously intend to test our endpoints.
    And we also intend to test code under those endpoints. This is something that
    different people can do differently but I and many other people, I have seen,
    start writing both API tests and unit tests side by side. I prefer to write API
    tests and keep writing them for one resource. After that, we will go towards unit
    testing of controller. In our case, we don't have much stuff in the model other
    than what is being inherited from Eloquent or relations. During API testing of
    a resource, if we need more detail to fix a bug, then we can start writing unit
    tests for that class. But there is no hard and fast rule. It is just a matter
    of preference.
  prefs: []
  type: TYPE_NORMAL
- en: API tests for post resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can either write test cases in a structural approach or we can write it
    in class. Both ways are fine, I recommend class, so you can take advantage of
    your OOP concepts, if you want at some point. So let''s create a file for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a class in `tests/api/CreatePostCest.php` with content similar
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `_before()` method is here so that you can write any code, which you want
    to execute before your test cases and the `_after()` method is there to execute
    after your test cases. The next method there is just for an example that we are
    going to modify.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are going to write two types of tests. One while trying to create a
    post without login that should returns unauthorized error and the other to create
    a post after login which should be successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before writing that, let''s set up our database factory to get random content
    for post, so we can use it during testing. Let''s modify `app/database/factories/ModelFactory.php`,
    so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code is that I just added. So, we are telling it to return an
    array of parameters, title, content, and status generated through `Faker\Generator`
    class' object. So, based on how we have defined different fields here, we can
    generate random content for Post user through `ModelFactory`, so that data will
    be random and dynamic instead of static content. During testing, it is better
    to have random data in test cases to test it properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now let''s write our test case in the `CreatePostCest.php` file, here
    is the function that we will write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, comments are explaining everything there, so there is no need
    to tell anything explicitly except that we have used the `sendPost()` method to
    send a Post request, we could also say `sendGet()` or `sendPut()` for different
    HTTP methods, and so on. So, now we need to run this test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run it through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It will not give us that clear output on the console. We can add `-v`, `-vv`,
    or `-vvv` to make the output more and more verbose, but in this command, it will
    make composer exec-related information more and more verbose. So let''s execute
    it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Feel free to add `-v` up to three times to get more and more verbose output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make an alias of path `vendor/bin/codecept` and during that session
    in console, we can use shorthand like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, execute it and you will see a lot of detail in the console. Use `-v`, `-vv`,
    or `-vvv` based on how you want it. For now let''s execute it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, our first test should have passed. Now, we should write our second
    test case, that is, to create a post after login. It involves more things that
    we need to understand. So let''s first see the code for this test case and then
    we will review it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you look at this test case, you will find it very similar to the previous
    test case code except for a few statements. So, I have highlighted these statements
    in bold. The first thing is that as the test case is different, so is our `wantTo()`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we are getting the first user from DB and generating a token based on
    the user object. Here, we are calling our application code because we are using
    the Lumen module as configured in the `api.suite.yml` file. Then, we are using
    CodeCeption's `$I->amBearerAuthenticated($token)` method with `$token` that we
    generated. This means we are sending a valid token so the server will consider
    it as a logged-in user. This time response code will be 200, so by saying `$I->seeResponseCodeIs(200)`,
    we are telling it that it should have 200 response code or else the test should
    fail. That's all this code does.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, there can be a lot more test cases similar to this, like test if it
    returns `400 Bad Request` response in case of an incomplete request.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running tests, you will see this at the end of the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that we are asserting two things. <q>Assertion means stating an
    expectation or fact that we want to be true.</q> In simple words, it is something
    that we are checking on response. Like, right now we are testing response code
    only. But in the real world, we test the whole response with a lot more test cases.
    CodeCeption also offers us to test those things. So, let''s modify our current
    two test cases with more assertions. Here are two more things that we are going
    to test:'
  prefs: []
  type: TYPE_NORMAL
- en: Will assert that we get JSON in response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will assert that we get the right data in response based on our input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So here is our code to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see the highlighted text in the preceding code snippet, we have
    added three more assertions and you can see how simple it is. Actually, checking
    something in response can be tricky when we don''t know what values an object
    can have. For example, what if we want to request and see posts list. So, how
    we will assert when we don''t know the values? In such cases, you can use JSON
    path-based assertion, documented here: [http://codeception.com/docs/modules/REST#seeResponseJsonMatchesJsonPath](http://codeception.com/docs/modules/REST#seeResponseJsonMatchesJsonPath).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will use it something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also what you see in Response but there is even a method which tests
    if that record exists now in DB as well. You should try it on your own. Here you
    can find its documentation: [http://codeception.com/docs/modules/Db#seeInDatabase](http://codeception.com/docs/modules/Db#seeInDatabase).'
  prefs: []
  type: TYPE_NORMAL
- en: Other test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot more test cases related to other Post operations (endpoints).
    However, the way to write test cases will remain same. So, I am skipping the so
    that you can write those test cases by yourself. However, just as a hint, here
    are some test cases you should write for practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then related to update Post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then related to post listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then related to getting a single post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So, I would highly recommend that you write these test cases. In case you need
    more examples or if you want to see examples of testing authentication-related
    endpoints, then here you can find some examples that you can read to understand
    it better: [https://github.com/Haafiz/REST-API-for-basic-RPG/tree/master/tests/api](https://github.com/Haafiz/REST-API-for-basic-RPG/tree/master/tests/api).'
  prefs: []
  type: TYPE_NORMAL
- en: For more information related to CodeCeption, refer to the CodeCeption documentation
    at [http://codeception.com/](http://codeception.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned testing types, the importance of automated testing,
    and wrote API tests for our RESTful web service endpoints. One thing I again want
    to say here is that we wrote only API tests to keep our focus on our topic but
    unit testing is of no less importance. However, testing is a huge topic and unit
    testing has its own complexity, so couldn't be discussed in this one chapter.
  prefs: []
  type: TYPE_NORMAL
- en: More resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to know more about automated testing in PHP, then here are some
    important resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Test Driven Laravel (Video course by Adam Wathan) [https://adamwathan.me/test-driven-Laravel/](https://adamwathan.me/test-driven-laravel/),
    however this is mainly focused on Laravel. But still, this will teach you important
    things.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there is Laravel Testing Decoded (an old book by Jeffrey Way) at
    [https://leanpub.com/Laravel-testing-decoded](https://leanpub.com/laravel-testing-decoded)
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, this is a Laravel-specific book but teaches you a lot in general. There
    is Jeffrey Way''s new upcoming book that is in general on PHP testing named Testing
    PHP: [https://leanpub.com/testingphp](https://leanpub.com/testingphp)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding mentioned book that is on PHP is still not completed so you can
    learn from Jeffrey Way''s awesome screencasts testing videos: [https://laracasts.com/skills/testing](https://laracasts.com/skills/testing)
    In fact, Laracasts is not only good for testing but for learning overall PHP and
    Laravel.'
  prefs: []
  type: TYPE_NORMAL
- en: No matter which source you pick, the important thing is that you do practice.
    The same is true for both development and testing. In fact, if you haven't done
    testing before then practicing testing is even more important. To start, you will
    find it a bit overwhelming but it is worth it.
  prefs: []
  type: TYPE_NORMAL
