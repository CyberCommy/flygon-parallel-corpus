- en: Envisioning the Future with Asynchronous PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to determine what are the best strategies
    when coping with I/O calls and how to implement these strategies. We will see
    what distinguishes multithreading from multitasking, when to implement one or
    the other, and how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will learn how to use the `ReactPHP` library and how to benefit from
    event-driven programming when dealing with asynchronous I/O calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, in this chapter, we will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing I/O calls with asynchronous non-blocking code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading with the `POSIX Threads` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a `ReactPHP` solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous non-blocking I/O calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the previous chapters of this book, I/O calls will always
    offer the worst performance due to the underlying latency of establishing, using
    and closing streams and sockets. Since PHP is basically a synchronous language
    that waits for a called function to return before resuming code execution, I/O
    calls are especially problematic if the called function has to wait for a stream
    to close before returning to the calling code. This becomes even worse when a
    PHP application has thousands of I/O calls to do every few minutes for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since PHP 5.3, it has become possible to interrupt PHP''s normal flow of execution
    by using generators and thus, to execute code asynchronously. As we have seen
    previously, even if dynamic structures can be less performant in general, they
    can still be useful in speeding up blocking code. This is particularly true for
    I/O calls that usually have very high latency. In order to better grasp the orders
    of magnitude of I/O latency, we can consult the following well-known graph published
    by Google:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Latency Comparison Numbers--------------------------L1 cache reference 0.5
    nsBranch mispredict 5 nsL2 cache reference 7 ns 14x L1 cacheMutex lock/unlock
    25 nsMain memory reference 100 ns 20x L2 cache, 200x L1 cacheCompress 1K bytes
    with Zippy 3,000 ns 3 usSend 1K bytes over 1 Gbps network 10,000 ns 10 usRead
    4K randomly from SSD* 150,000 ns 150 us ~1GB/sec SSDRead 1 MB sequentially from
    memory 250,000 ns 250 usRound trip within same data center 500,000 ns 500 usRead
    1 MB sequentially from SSD* 1,000,000 ns 1,000 us 1 ms ~1GB/sec SSD, 4X memoryDisk
    seek 10,000,000 ns 10,000 us 10 ms 20x data center roundtripRead 1 MB sequentially
    from disk 20,000,000 ns 20,000 us 20 ms 80x memory, 20X SSDSend packet CA->Netherlands->CA
    150,000,000 ns 150,000 us 150 msNotes-----1 ns = 10^-9 seconds1 us = 10^-6 seconds
    = 1,000 ns1 ms = 10^-3 seconds = 1,000 us = 1,000,000 nsCredit------By Jeff Dean:
    [http://research.google.com/people/jeff/](http://research.google.com/people/jeff/)Originally
    by Peter Norvig: [http://norvig.com/21-days.html#answers](http://norvig.com/21-days.html#answers)Contributions-------------Some
    updates from: [https://gist.github.com/2843375](https://gist.github.com/2843375)"Humanized"
    comparison: [https://gist.github.com/2843375](https://gist.github.com/2843375)Visual
    comparison chart: [http://i.imgur.com/k0t1e.png](http://i.imgur.com/k0t1e.png)Animated
    presentation: [http://prezi.com/pdkvgys-r0y6/latency-numbers-for-programmers-web-development/latency.txt](http://prezi.com/pdkvgys-r0y6/latency-numbers-for-programmers-web-development/latency.txt)[https://gist.github.com/jboner/2841832](https://gist.github.com/jboner/2841832)[https://gist.github.com/andrewscaya/2f9e68d4b41f9d747b92fb26b1b60d9f](https://gist.github.com/andrewscaya/2f9e68d4b41f9d747b92fb26b1b60d9f)
    |'
  prefs: []
  type: TYPE_TB
- en: It comes as no great surprise that reading from disk is always slower than memory
    and that network I/O calls remain the slowest of them all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s delve a little deeper by having a look at some code that makes a series
    of I/O calls. Our first example will use `cURL`. Let''s have a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s execute the PHP script. We should now see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/041f22c2-984d-4212-8917-08acaed35201.png)Time elapsed and memory
    consumed when running the blocking code script'
  prefs: []
  type: TYPE_NORMAL
- en: This code takes a long time to complete because of the high latency associated
    with accessing the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we profile the previous code using `Blackfire.io`, we can see that the 10
    calls to `cURL` take over a second to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c3b80dd-fb42-4039-8ffe-7d89fd600ce5.png)Profiling the code shows
    us that the 10 calls to cURL make up the greater part of the script''s total execution
    time'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our PHP script in order to use asynchronous code to run our `cURL`
    requests simultaneously. Here is the new version of the previous PHP code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the code, we now get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/50c5d212-bd0b-4736-8287-512eddb64286.png)Time elapsed and memory
    consumed when running the non-blocking code script'
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, the PHP script is faster as it no longer has to wait for the I/O
    calls to complete before continuing to execute the rest of the code. What is actually
    happening under the hood is multitasking within the same thread. The code''s flow
    of execution is in fact interrupted in order to allow for concurrent execution
    of the many I/O calls. This is possible due to non-blocking code that will yield
    control back to the caller code while waiting for some task to complete, and possibly
    call a callback function when done. If we profile the previous code using `Blackfire.io`,
    we will see this looping in actionâ€”the yielding function is actually called more
    than 45,000 times in order to complete all 10 requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/69d0a7a5-8fc4-4e0a-aecc-acc8658e1584.png)The yielding function is
    called more than 45,000 times in order to complete all 10 cURL requests'
  prefs: []
  type: TYPE_NORMAL
- en: Introduced in PHP 5.5, generators allow for what seems to be simultaneous execution
    of different parts of the code and thus easier asynchronous programming. A generator
    is actually an invokable object that implements the iterator interface. The underlying
    principle is therefore to have a loop that will repeatedly call a generator function
    that will, in turn, yield control back to the loop until there is nothing left
    to process, in which case the generator function will return definitely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s dig a little deeper into asynchronous programming with a simple
    code example. To do so, let''s program a basic car race using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the runner function, which is the main loop, processes the
    three generator functions in random order until none of them have anything left
    to process. The end result is that we never know which car is going to win the
    race, although some of these cars seem to be going faster than others! Let''s
    run this code three times. Here are the results for the first run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ec329fa0-43c6-471b-a0dd-cf765d695fa6.png)Car 2 wins the race!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results for the second run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dff2210f-16df-48f2-8bfc-b7e5e66e63f0.png)Car 3 wins the race!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results for the third and final run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aed09156-4ab1-4595-b31d-1406c6b68970.png)Car 1 wins the race!'
  prefs: []
  type: TYPE_NORMAL
- en: The end result is what seems to be the simultaneous execution of three different
    functions within the same thread. This is what asynchronous programming is all
    about in its essential principle. Indeed, it is easy to understand how multitasking
    can, for example, be used to help mitigate the effects of a heavy workload on
    a single PHP script by interrupting the script's execution in order to queue some
    tasks using third-party software, like RabbitMQ and Redis. Thus, it becomes possible
    to delay the processing of these tasks until such time as processing is deemed
    appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have had a look at multitasking, let's have a look at multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading with pthreads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`POSIX Threads`, better known as `pthreads`, is a library that allows a computer
    program to execute multiple processes or threads concurrently by forking child
    processes from its parent process. The `pthreads` library can be used in PHP,
    making it therefore possible to fork processes in the background while executing
    something else simultaneously. Thus, multithreading is another way to cope with
    latency in I/O calls. In order to accomplish this, we will need a thread-safe
    version of PHP with the `pthreads` extension enabled. In our case, we will use
    a Linux for PHP container that is running a **Zend thread-safe** (**ZTS**) version
    of PHP 7.0.29\. Open a new Terminal window, `cd` into the project''s directory
    and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are done entering this command, you should see the following information
    if you enter the `php -v` command in the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c9c89704-5a3c-487f-aa71-c3d8db23b34c.png)The ZTS container''s command-line
    interface (CLI)'
  prefs: []
  type: TYPE_IMG
- en: 'This message confirms we are using a thread-safe (ZTS) version of PHP. Then,
    on the container''s CLI, enter these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now check that the `pthreads` extension is properly installed by entering
    the commandÂ `php -i`. The last command should allow you to see the extension''s
    version number. If this is the case, then the extension was installed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b96c3395-6a96-4d2c-9b65-d33ab7230bad.png)Version 3.1.6 of the pthreads
    extension is now installed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the `pthreads` library is installed and enabled, let''s proceed to
    use it by trying to create multiple threads that will truly execute simultaneously
    on the computer''s CPUs. To do so, we will use the following source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once executed, we obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e355a456-01b0-4f24-a56a-2311798b9121.png)Threads were executed simultaneously'
  prefs: []
  type: TYPE_NORMAL
- en: The results clearly show that the threads were executed simultaneously as the
    total elapsed time for the script was 10 seconds even though each thread slept
    for at least a few seconds. If this synchronous blocking code was executed without
    multithreading, it would have taken approximately 40 seconds in all to complete
    execution. Multitasking would not have been an appropriate solution in this case,
    as the blocking calls to the `sleep()` function would have prevented each generator
    from yielding control to the main loop.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen both multitasking via asynchronous programming and multithreading
    via the `POSIX Threads` library, we will turn our attention to a PHP library that
    can be very useful when it comes to programming asynchronously, namely the `ReactPHP`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ReactPHP library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ReactPHP` is an event-driven, non-blocking I/O library. This library relies
    essentially on an event loop that polls file descriptors, uses timers and defers
    callbacks by registering and executing outstanding ticks on each iteration of
    the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReactPHP` is based on the Reactor pattern which, according to Douglas C. Schmidt,
    is a "*design pattern that handles service requests that are delivered concurrently
    to an application by one or more clients. Each service in an application may consist
    of several methods and is represented by a separate event handler that is responsible
    for dispatching service-specific requests. Dispatching of event handlers is performed
    by an initiation dispatcher, which manages the registered event handlers. Demultiplexing
    of service requests is performed by a synchronous event demultiplexer.*" In Schmidtâ€™s
    original paper *Reactor: An Object Behavioral Pattern for Demultiplexing and Dispatching
    Handles for Synchronous Events*, we can find this UML representation of this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/68abe73f-bedb-4e6b-81ed-91e79c423c02.png)The Reactor pattern according
    to Douglas C. Schmidt'
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s start exploring this asynchronous programming library by installing it
    in our code repository. On the containerâ€™s CLI, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the library is installed through Composer, you can try any of the example
    scripts that you can find in the examples directory. These code examples come
    from *ReactPHP*''s main code repository. In our case, we will start by having
    a look at the `parallel-download.php`Â script. Here is its source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, this script creates two streams, sets them to the non-blocking
    mode and registers the streams with the loop. A timer is added to the loop in
    order to echo a message every 5 seconds. Finally, it runs the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at this script in action using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ff636036-744b-4547-a6ee-a5cb40ad8c40.png)The two packages are downloaded
    asynchronously'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the downloads were executed in a parallel, asynchronous and
    reactive way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue our short journey into the world of ReactPHP by having a little
    bit of fun with the `tcp-chat.php`Â script that is included in the code examples.
    Here is the source code of this code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The script creates a socket server that listens on port 4000 and is informed
    by the loop of incoming connections by listening for a connectionÂ event. Upon
    notification of the event, the socket server injects the connection object into
    the handler. The connection object then starts listening for the data event which
    will trigger it to do something with the data received from the socket server's
    client. In the case of this chat script, the connection object will trigger the
    write methods of all registered connection objects found in the `SplObjectStorage`Â object,
    thus effectively sending the message to all currently connected chat clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start the chat server by running the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open three new Terminal windows and connect to our *Linux for PHP* *Docker*
    container by entering the following commands in each window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On each container''s CLI, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once connected through `telnet`, just have fun sending messages back and forth
    from one Terminal window to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5ef175eb-8d2b-4bf4-b304-06c76043129b.png)Sending messages from one
    terminal window to the others'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, what has been done here using Terminal windows within the same container
    could have been done using Terminal windows on different computers through networking.
    This example shows us just how powerful asynchronous programming can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s complete our survey of *ReactPHP*''s code examples by having a look
    at the `scalability.php`Â script. Here is its source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The script creates a socket server which is then attached to the main event
    loop in order to call a lambda function when a request is sent to the server.
    The lambda function then executes the code that will send the answer back to the
    client by writing it to the accepted stream socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run this code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open another Terminal window and connect it to our *Linux for PHP* *Docker*
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, query the server using `wget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, you should get the following responses for each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9153e175-979f-4747-bf75-1a6799310991.png)Connecting to each available
    port of the web server'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what you should see on the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1e99bfc2-3c61-4949-8724-c490a238df88.png)The server confirms having
    served all these requests on all these ports'
  prefs: []
  type: TYPE_NORMAL
- en: Again, you can see how powerful *ReactPHP* can be, as only a few lines of code
    are enough to create a scalable web server.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we highly recommend that all the files from the *ReactPHP* project
    that are included in our repository be explored and tried out so you can fully
    appreciate what this library can do for you as a developer when it comes to asynchronous
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there are other great asynchronous PHP libraries that can help you as
    you master this new way to develop and speed up high latency I/O applications.
    One such library is *Amp* ([https://amphp.org/](https://amphp.org/)). It is well
    worth the time to explore these very useful libraries while mastering the art
    of asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for more information on asynchronous programming in PHP, you can listen
    to a great presentation given on this topic by *Christopher Pitt* at *Nomad PHP*
    ([https://nomadphp.com/asynchronous-php/](https://nomadphp.com/asynchronous-php/)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to determine the best strategies to cope
    with I/O calls and how to implement these strategies. Moreover, we have seen how
    to use the `ReactPHP` library and how to benefit from event-driven programming
    when dealing with asynchronous I/O calls.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to measure database performance, ranging
    from applying simple measurement techniques to using advanced benchmarking tools.
  prefs: []
  type: TYPE_NORMAL
