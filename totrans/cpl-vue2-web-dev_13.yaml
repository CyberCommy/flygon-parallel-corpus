- en: Transitions and Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with third-party CSS animation libraries such as animate.css
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding your own transition classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating with JavaScript instead of CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning on the initial render
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning between elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letting an element leave before the enter phase in a transition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding entering and leaving transitions for elements of a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning elements that move in a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the state of your components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging reusable transitions into components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains recipes related to transitions and animations. Vue has
    its own tags for dealing with transitions intended for when an element enters
    or leaves the scene: `<transition>` and `<transition-group>`. You will learn all
    about them and how to use them to give your customers a better user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Vue transitions are pretty powerful in that they are completely customizable and
    can easily combine JavaScript and CSS styling while having very intuitive defaults
    that will let you write less code in case you don't want all the frills.
  prefs: []
  type: TYPE_NORMAL
- en: You can animate a great deal of what happens in your components even without
    transition tags since all you have to do is bind your state variables to some
    visible property.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once you have mastered everything that there is to know about Vue transitions
    and animations, you can easily package these in layered components and reuse them
    throughout your application. This is what makes them not only powerful, but also
    easy to use and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with third-party CSS animation libraries such as animate.css
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphical interfaces not only need to be usable and easy to understand; they
    should also provide affordability and be pleasant to use. Having transitions can
    help a great deal by giving cues of how a website works in a fun way. In this
    recipe, we will examine how to use a CSS library with our application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting, you can take a look at [https://daneden.github.io/animate.css/](https://daneden.github.io/animate.css/),
    as shown, just to get an idea of the available animations, but you don''t really
    need any special knowledge to proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f9ba4864-e66a-485c-a49f-10a17ecd5ecc.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are creating an app to book taxis. The interface we will create
    will be simple and fun.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, add the `animate.css` library to the list of dependencies (refer
    to the *Choosing a development environment* recipe to learn how to do it).
  prefs: []
  type: TYPE_NORMAL
- en: 'To proceed, we need our usual wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside, we will put a button to call for a taxi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can already tell that we will use the `taxiCalled` variable to keep track
    of whether the button has been pressed or not
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an emoji that will confirm to the user when the taxi is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can add some JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and you will see the taxi appear instantly when you press
    the button. We are a cool taxi company, so let''s make the taxi drive to us with
    a transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run your application; if you call the taxi, it will get to you by sliding
    from the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/888029b7-74d1-4c9a-8bff-f82c8f721b3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The taxi will slide from right to left, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d0e494f6-2f43-401d-a551-cea5cfa6aebc.png)'
  prefs: []
  type: TYPE_IMG
- en: How does it work...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every transition applies four classes. Two are applied when the element enters
    the *scene* and the other two are applied when it leaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Applied when** | **Removed when** |'
  prefs: []
  type: TYPE_TB
- en: '| `v-enter` | Before the element is inserted | After one frame |'
  prefs: []
  type: TYPE_TB
- en: '| `v-enter-active` | Before the element is inserted | When transition ends
    |'
  prefs: []
  type: TYPE_TB
- en: '| `v-enter-to` | After one frame | When transition ends |'
  prefs: []
  type: TYPE_TB
- en: '| `v-leave` | Transition starts | After one frame |'
  prefs: []
  type: TYPE_TB
- en: '| `v-leave-active` | Transition starts | When transition ends |'
  prefs: []
  type: TYPE_TB
- en: '| `v-leave-to` | After one frame | When transition ends |'
  prefs: []
  type: TYPE_TB
- en: Here, the initial *v* stands for the name of your transition. If you don't specify
    a name, *v* will be used.
  prefs: []
  type: TYPE_NORMAL
- en: While the beginning of the transition is a well-defined instant, the end of
    the transition is a bit of work for the browser to figure out. For example, if
    a CSS animation loops, the duration of the animation will only be one iteration.
    Also, this may change in future releases, so keep this in mind.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we wanted to provide a third-party `v-enter-active` instead of
    writing our own. The problem is that our library already has a different name
    for the class of the animation we want to use (`slideInRight`). Since we can't
    change the name of the class, we tell Vue to use `slideInRight` instead of looking
    for a `v-enter-active` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we used the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This means that our `v-enter-active` is called animated `slideInRight` now.
    Vue will append those two classes before the element is inserted and drop them
    when the transition ends. Just note that animated is a kind of helper class that
    comes with `animate.css`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding your own transition classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your application is rich in animations and you would like to reuse your CSS classes
    in other projects by mixing and matching them, this is the recipe for you. You
    will also understand an important technique for performant animations, called
    **FLIP** (**First Last Invert Play**). While the latter technique is normally
    triggered automatically by Vue, we will implement it manually to get a better
    understanding of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this recipe, you should understand how CSS animations and transitions
    work. This is out of the scope of this book, but you can find a good primer at [http://css3.bradshawenterprises.com/](https://daneden.github.io/animate.css/).
    This website is also great because it will explain when you can use animations
    and transitions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will build an interface for a taxi company (similar to the preceding recipe)
    that will enable users to call a taxi at the click of a button and will provide
    a nice animated feedback when the taxi is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'To code the button, write the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you initialize the `taxiCalled` variable to `false`, as shown in the
    following JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we will create our own custom transition in CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrap your car emoji in a Vue transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When you run your code and hit the Call a cab button, you will see a taxi stopping
    by.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we click on the button, the `taxiCalled` variable turns `true` and Vue
    inserts the taxi into your page. Before actually doing this, it reads the classes
    you specified in `enter-class` (in this case, only `slideInRight`) and applies
    it to the wrapped element (the `<p>` element with the taxi emoji). It also applies
    the classes specified in `enter-class-active` (in this case, only go).
  prefs: []
  type: TYPE_NORMAL
- en: The classes in `enter-class` are removed after the first frame, and the classes
    in `enter-class-active` are also removed when the animation ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The animation created here follows the FLIP technique that is composed of four
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First (F)**: You take the property as it is in the first frame of your animation;
    in our case, we want the taxi to start somewhere from the right of the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last (L)**: You take the property as it is in the last frame of your animation,
    which is the taxi at the left of the screen in our case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invert (I)**: You invert the property change you registered between the first
    and last frame. Since our taxi moved to the left, at the final frame it will be
    at say -200 pixel offset. We invert that and set the `slideInRight` class to have
    transform as `translateX(200px)` so that the taxi will be at +200 pixel offset
    when it appears.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Play (P)**: We create a transition for every property we have touched. In
    the taxi example, we use the transform property and so, we use `writetransition:
    all 2s ease-out` to tween the taxi smoothly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This technique is used automatically by Vue under the cover to make transitions
    work inside the `<transition-group>` tag. More on that in the *Adding entering
    and leaving transition for elements of a list* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Animating with JavaScript instead of CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s a common misconception that animating with JavaScript is slower and that
    animations should be done in CSS. The reality is that if used correctly, animation
    in JavaScript can have similar or superior performance. In this recipe, we will
    create an animation with the help of the simple but powerful Velocity.js ([http://velocityjs.org/](http://velocityjs.org/)) library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ba4a4bef-77a9-4d77-9b99-92d7dcc8a914.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe, while it presupposes no knowledge of the Velocity library, assumes
    that you are quite familiar with animations either in CSS or with JavaScript libraries,
    such as jQuery. If you've never seen a CSS animation and you want a speedy introduction,
    just complete the two preceding recipes and you should be able to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're still looking for the perfect transition for a taxi company (the same
    as in the preceding recipe) that will entertain our clients while waiting for
    a taxi. We have a button to call a cab and a little taxi emoji that will appear
    when we make a reservation.
  prefs: []
  type: TYPE_NORMAL
- en: Before anything else, add the Velocity library as a dependency to your project--[https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js](http://velocityjs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the HTML to create the skeleton of our interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Vue model is very simple and consists only of the `taxiCalled` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the animation by wrapping the little taxi in a Vue transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The enter method will be called as soon as the taxi emoji is inserted at the
    press of a button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The enter method, which you have to add to your Vue instance, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Run your code and press the button to book your taxi!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have noted, there is no CSS in your code. The animation is purely
    driven by JavaScript. Let''s dissect our Vue transition a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Although this is still a transition that could use CSS, we want to tell Vue
    to shut down the CSS and save precious CPU cycles by setting `:css="false"`. This
    will make Vue skip all the code related to CSS animation and will prevent CSS
    from interfering with our pure JavaScript animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The juicy part is in the `@enter="enter"` bit. We are binding the hook that
    triggers when the element is inserted in to the `enter` method. The method itself
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are calling the Velocity library. The `el` parameter is passed for
    free by Vue, and it refers to the element that was inserted (in our case, the
    `<p>` element containing the emoji of the car).
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the Velocity function is as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Other syntaxes are possible, but we will stick to this one.
  prefs: []
  type: TYPE_NORMAL
- en: In our call to this function, we passed our paragraph element as the first argument;
    we then said that the opacity should change from 0 to 1 and, at the same time,
    the element should move from a starting position of 200 pixels on the x axis toward
    its origin. As options, we specified that the animation should last for two seconds
    and that we want to ease the animation near the end.
  prefs: []
  type: TYPE_NORMAL
- en: I think everything is pretty clear maybe except how we are passing the `opacity`
    and `translateX` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: This is what Velocity calls **forcefeeding**--we are telling Velocity that the
    opacity should start from 0 and go to 1\. Likewise, we are telling Velocity that
    the `translateX` property should start at 200 pixels, ending at 0 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we can avoid passing arrays to specify the initial value for the
    properties; Velocity will calculate how to transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could have had the following CSS class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we rewrite the Velocity call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The car will slowly appear. Velocity queried the DOM for the initial value of
    the element and then transitioned it to 1\. The problem with this approach is
    that since a query to the DOM is involved, some animations could be slower, especially
    when you have a lot of concurrent animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way we can obtain the same effect as force-feeding is by using the
    begin option, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will set the opacity to zero just before the animation begins (and hence,
    before the element is inserted). This will help in slower browsers in which forcefeeding
    will still display a flash of the car before bringing it all the way to the right
    and starting the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The possible hooks for JavaScript animations are summarized in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `@before-enter` | This function is called before the element is inserted.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@enter` | This function is called when the element is inserted. |'
  prefs: []
  type: TYPE_TB
- en: '| `@after-enter` | This function is called when the element is inserted and
    the animation is finished. |'
  prefs: []
  type: TYPE_TB
- en: '| `@enter-cancelled` | This function is called when the animation is still
    in progress, but the element has to leave. If you use Velocity you can do something
    like `Velocity(el, "stop")`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@before-leave` | This function is called before the leave function is triggered.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@leave` | This function is called when the element leaves. |'
  prefs: []
  type: TYPE_TB
- en: '| `@after-leave` | This function is called when the element leaves the page.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@leave-cancelled` | This is called in case the element has to be inserted
    before the leave call is finished. It works only with v-show. |'
  prefs: []
  type: TYPE_TB
- en: Just be reminded that these hooks are valid for any library, not just Velocity.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can try another take with this interface by implementing a cancel button.
    If the user booked a cab by mistake, hitting cancel will delete the reservation,
    and it will be apparent by the fact that the little taxi emoji disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a cancel button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy enough; now we add our leave transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That brings us to our leave method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing is making the emoji disappear while scaling it down.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to run your code, you will encounter some problems.
  prefs: []
  type: TYPE_NORMAL
- en: When you click on the cancel button, what should happen is the leave animation
    should start and the taxi should become smaller and eventually disappear. Instead,
    nothing happens and the taxi disappears abruptly.
  prefs: []
  type: TYPE_NORMAL
- en: The reason the cancel animation doesn't play as planned is because since the
    animation is written in JavaScript instead of CSS, Vue has no way to tell when
    the animation is finished. In particular, what happens is that Vue thinks that
    the leave animation is finished before it even starts. That is what makes our
    car disappear.
  prefs: []
  type: TYPE_NORMAL
- en: The trick lies in the second argument. Every hook calls a function with two
    arguments. We have already seen the first, `el`, which is the subject of the animation.
    The second is a callback that when called, tells Vue that the animation is finished.
  prefs: []
  type: TYPE_NORMAL
- en: We will leverage the fact that Velocity has an option called `complete`, which
    expects a function to call when the animation (from the Velocity perspective)
    is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our code with this new information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the done arguments to our function lets Vue know that we want a callback
    to call when the animation is finished. We don''t need to explicitly use the callback
    as Vue will figure it out by itself, but since it''s always a bad idea to rely
    on default behaviors (they can change if they are not documented), let''s call
    the done function when the animation is finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Run your code and press the Cancel button to cancel your taxi!
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning on the initial render
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `appear` keyword, we are able to package transition for elements when
    they are first loaded. This helps the user experience in that it gives the impression
    that the page is more responsive and faster to load when you apply it to many
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe doesn't assume any particular knowledge, but if you have completed
    at least the *Adding some fun to your app with CSS transitions* recipe, it will
    be a piece of cake.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will build a page about the American actor Fill Murray; no, not Bill Murray.
    You can find more information about him at [http://www.fillmurray.com](https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js).
    We will use images from this site to fill our page about him.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our HTML, let''s write a header as the title of our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After the title, we will place our Vue application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Which when rendered in a browser would appear like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6132613a-c762-478c-9751-3dd4d3e38999.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our page is very plain right now. We want the Fill Murray picture to fade in.
    We have to wrap it inside a transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the CSS classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Running our page now will make the image appear slowly, but it will also move
    the text. To fix it, we have to specify the image size in advance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This way, our browser will set aside some space for the image that will appear
    slowly.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `appear` directive in the `transition` tag will make the components appear
    for the first time with an associated transition (if it is found).
  prefs: []
  type: TYPE_NORMAL
- en: There are many possible ways to specify a transition on the first rendering
    of the component. In all cases, the `appear` directive must be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first things Vue will look for when this directive is present are JavaScript
    hooks or CSS classes specified in the tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, if a name is specified, Vue will look for an entrance transition
    for that element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will look for classes named as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Vue will look for the default CSS classes for the element insertion (`v-enter`
    and `v-enter-active`) if everything else fails. Incidentally, this is what we
    have done in our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Relying on these defaults is not a good practice; here, we have done it just
    as a demonstration. You should always give names to your transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe it's worth mentioning why we had to add the width and height to our image.
    The reason is that when we specify an image URL in our HTML, the browser doesn't
    know the size of the image in advance, so it doesn't reserve any space for it
    by default. Only by specifying the size of the image in advance, the browser is
    able to correctly compose the page even before an image is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning between elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything on a web page is an element. You can easily make them appear and
    disappear, thanks to Vue `v-if` and `v-show` directives. With transitions, you
    can easily control how they appear and even add magic effects. This recipe explains
    how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you should have some familiarity with Vue transitions and how
    CSS works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we talked about magic, we will turn a frog into a princess. The transformation
    itself will be a transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will instantiate a button that, when pressed, will represent a kiss to the
    frog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time the button is pressed, the variable kisses increases. The variable
    will be initialized to zero, as the following code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need the frog and the princess that we will add immediately after
    the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The fade transition is the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it work properly, we need a last CSS selector to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application and click enough times the kiss button, you should
    see your frog turn into a princess:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3a709d1d-79ed-4bb9-86a8-aeaeeadcaf9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This transition will have a fade effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d17f58dc-50cd-4e11-b234-c4633095a802.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The frog emoji will turn into a princess emoji:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/297edc0a-d809-41d8-9490-b59770387e70.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we wrote the two elements, we used the `key` attribute specifying who is
    the frog and who is the princess. This is because, Vue optimization system will
    kick in otherwise. It will see that the content of the two elements can be swapped
    without swapping the elements themselves and no transition will ensue since the
    element was the same and only the content changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we remove the `key` attribute, we can see for ourselves that the frog and
    the princess will change, but without any transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider that we use two different elements, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we modify our CSS selector for `<p>` accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now if we launch our application again, everything works without using any `key`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Using keys is generally recommended even when not necessary, like in the preceding
    case. This is especially true when items have a different semantic meaning. There
    are a couple of reasons for this. The main reason is that when multiple people
    work on the same line of code, modifying the `key` attribute will not break the
    application as easily as switching a `span` element back into a `p` element, which
    will ruin the transition as we just saw.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we cover two subcases of the preceding recipe: switching between more
    than two elements and binding the `key` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning between more than two elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can expand on the recipe we just completed in a straightforward manner.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that if we kiss the princess too many times, she will turn into
    Santa Claus, which may or may not be appealing, depending on your age I guess.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add the third element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can launch the application immediately and when we kiss the princess/frog
    more than five times, Santa will appear with the same fading transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ee62f5c3-adb1-4d2e-819b-cfe0888084b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Using this setup, we are limited in using the same transition we used between
    the first two elements.
  prefs: []
  type: TYPE_NORMAL
- en: There is a workaround for this explained in the *Dynamic transitions* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the key attribute dynamically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We don''t have to write the key for all our elements if we already have some
    data available. Another way we could write the same app, but without repeating
    the element is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This, of course, means that we have to provide a sensible value for the `transformation`
    and `emoji` variables, depending on the number of kisses.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will tie them to computed properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We traded off some complexity in the template for some more logic in our Vue
    instance. This can be good in the long run if we expect more complex logic in
    the future or if the number of transformation rises.
  prefs: []
  type: TYPE_NORMAL
- en: Letting an element leave before the enter phase in a transition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Transitioning between elements* recipe, we explored how to make the
    transition between two elements. The default behavior of Vue is to start the transition
    of the element that is entering at the same time that the first element is leaving;
    this is not always desirable.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about this important corner case and how to work around it in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds on top of the transitioning between two elements and solves
    a specific problem. If you don't know what we are talking about, go back one recipe
    and you'll be on track in no time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, you will see the problem if you have not encountered it yet. Next, we'll
    see what Vue offers us to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: The two elements problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a carousel effect on our website. The user will view one product at
    a time and then he will swipe to the next product. To swipe to the next product
    the user will need to click a button.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need our list of products in the Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In our HTML, we will only need a button and the view of an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The modulo 4 (product % 4) is only because we want to start all over again when
    the list of products finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up our sliding transition, we will need the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, to make everything look good, we finish up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the code now, you will see a nice carousel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/27675ea7-0d13-48b1-83d1-91270017df29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try to remove the `position: absolute` from the last rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try your code now, you will see a weird jumping from the products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/90d782ed-fe42-4226-885d-4d370ff4d49c.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the problem we are trying to solve. The second transition starts before
    the first product has left. If the positioning is not absolute, we will see some
    weird effects.
  prefs: []
  type: TYPE_NORMAL
- en: Transition modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fix this problem, we will change the transition mode. Let''s modify the
    `<transition>` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now run your program and you will see the products taking a little more time
    before sliding inside the screen. They are waiting for the previous item to go
    away before entering.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recapitulate, you have two different ways to manage transitions between
    components in Vue. The default way is to start the *in* transition at the same
    time with the *out* transition. We can make that explicit with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change this default behavior by waiting for the *out* part to be finished
    before starting the *in* animation. We achieved it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: While the former is useful when elements have the absolute style position, the
    latter is more relevant when we really need to wait to have a clear way before
    putting more stuff on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Absolute positioning won't care about having elements on top of each other because
    they don't follow the flow of the page. On the other hand, static positioning
    will append the second element after the first, making the transition awkward
    if both the elements are shown at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Adding entering and leaving transitions for elements of a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will try to add a visual way to suggest that an element is added or
    removed from the list. This can add a lot to UX since you have an opportunity
    to suggest to the user why an element was added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some familiarity with CSS and transition will help. If you feel like this is
    needed, just browse the other recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll build a syllabus to study programming. When we are done with a topic,
    we'll feel relieved and we want to incorporate that feeling in our app by making
    the topic float away from the syllabus as we learn it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data of the list will be in our Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The list will be printed in our HTML with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When we press a button, we want the topic to disappear from the list. For this
    to happen, we need to modify the code we have written.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a Done button before each topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the completed method will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Running the code now will reveal a simple application for checking off the topics
    we already studied. What we want though is an animation that will make us feel
    relieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we need to edit the container of our list. We remove the `<ul>` tag
    and, instead, tell the `<transition-group>` to compile to a `<ul>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we also added a key to each list element according to the topic.
    The last thing we need is adding the transition rules to our CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the subjects will disappear with the transition on clicking the Done button,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1dc697d3-26c5-4957-86c6-2ed79cc3966b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<transition-group>` tag represents a container for a group of elements
    that will be displayed at the same time. By default, it represents the `<span>`
    tag, but by setting the tag attribute to `ul`, we made it represent an unordered
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Every element in the list must have a unique key or the transitions won't work.
    Vue will take care of applying a transition to every element that enters or leaves.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning elements that move in a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will build a list of elements that move according to how
    the list changes. This particular animation is useful when you want to tell your
    user that something has changed and the list is now updated accordingly. It will
    also help the user identify the point in which the element was inserted.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is a little advanced; I would suggest you complete some of the recipes
    in this chapter if you are not very familiar with transitions in Vue. If you can
    complete the *Adding entering and leaving transitions for elements of a lists*
    recipe without much difficulty, you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will build a little game--a bus station simulator!
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever a bus--represented by its emoji--leaves the station, all the other
    buses will drive a little ahead to take its place. Every bus is identified by
    a number, as you can see from the Vue instance data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever a new bus arrives, it will have a progressive number assigned. We
    want a new bus to leave or go every two seconds. We can achieve this by hooking
    a timer when our component is mounted on screen. Immediately after data, write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML of our app will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the buses move around, we need to specify some CSS rules under the
    prefix station:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Launching the app now will result in an orderly queue of buses in which one
    leaves or arrives every two seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c4f025b1-b825-45e3-8ab4-9f362737ccd2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core of our app is the `<transition-group>` tag. It manages all the buses
    identified by their key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a bus enters or leaves the scenes, a FLIP animation (see the *Adding
    your own transition classes* recipe) will be automatically triggered by Vue.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix ideas, let''s say we have buses [1, 2, 3] and bus 1 leaves the scene.
    What happens next is that the properties of the first bus''s `<span>` element
    will be memorized before the animation actually starts. So we may retrieve the
    following object describing the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Vue does this for all the elements keyed inside the `<transition-group>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, the `station-leave-active` class will be applied to the first bus.
    Let''s briefly review what the rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We note that the position becomes absolute. This means that the element is
    removed from the normal flow of the page. This in turn means that all the buses
    behind him will suddenly move to fill the space left blank. Vue records all the
    properties of the buses at this stage also and this is considered the final frame
    of the animation. This frame is not actually a real displayed frame; it is just
    used as an abstraction to calculate the final position of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/43cd7f74-3133-418b-bd7b-48893eb924a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Vue will calculate the difference between the final frame and the starting
    frame and will apply styles to make the buses appear in the initial frame even
    if they are not. The styles will be removed after one frame. The reason the buses
    slowly crawl to their final frame position instead of immediately moving in their
    new position is that they are `span` elements and we specified that any transform
    style (the one used by Vue to fake their position for one frame) must be transitioned
    for two seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In other words, at frame -1, the three buses are all in place and their position
    is recorded.
  prefs: []
  type: TYPE_NORMAL
- en: At frame 0, the first bus is removed from the flow of the page and the other
    buses are instantaneously moved behind it. In the very same frame, Vue records
    their new position and applies a transform that will move the buses back to where
    they were at frame -1 giving the appearance that nobody moved.
  prefs: []
  type: TYPE_NORMAL
- en: At frame 1, the transform is removed, but since we have a transition, the buses
    will slowly move to their final position.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the state of your components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computers, everything is a number. In Vue, everything that is a number can
    be animated in one way or other. In this recipe, you will control a bouncy ball
    that will smoothly position itself with a tween animation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this recipe, you will need at least some familiarity with JavaScript.
    The technicalities of JavaScript are out of the scope of this book, but I will
    break the code down for you in the *How it works...* section, so don't worry too
    much about it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our HTML, we will add only two elements: an input box in which we will enter
    the desired position of our bouncy ball and the ball itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To properly render the ball, write this CSS rule and it will appear on the
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to control the bar *Y* position. To do that, we will bind the `top`
    property of the ball:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Height will be part of our Vue instance model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, since we want the ball to animate in the new position whenever the `enteredHeight`
    changes, one idea would be to bind the `@change` event of the input element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The move method will be the one responsible for taking the current height of
    the ball and slowly transitioning it to the specified value.
  prefs: []
  type: TYPE_NORMAL
- en: Before doing this, you will add the **Tween.js** library as a dependency. The
    official repository is at [https://github.com/tweenjs/tween.js](https://github.com/tweenjs/tween.js).
    You can add the CDN link specified in the README.md page if you are using JSFiddle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the move method after adding the library, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to launch the app and see the ball bounce while you edit its height:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1f7dd650-3963-4f71-9d27-2c6ebdc95ef9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we change the height, the position of the ball also changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/069a6b5b-0417-4316-b6b7-d755712488be.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The general principle here is that you have a state for an element or component.
    When the state is numeric in nature, you can "tween" (from between) from one value
    to the other following a specific curve or acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: Let's break down the code, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do is to take the specified new height for the ball and
    save it to the `newHeight` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next line, we are also saving our Vue instance in a `_this` helper variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we do so will be clear in a minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are wrapping all of our animation in a function.
    This is idiomatic to the Tween.js library and identifies the main loop we will
    use to animate. If we have other tweens, this is the place to trigger them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the API call to our library. First, we are creating an object that
    will hold a copy of the height value in lieu of our component. Normally, here
    you put the object that represents the state itself. Due to Vue limitations (or
    Tween.js limitations), we are using a different strategy; we are animating a copy
    of the state and we are syncing the true state for every frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line initializes this copy to be equal to the current actual height
    of the ball:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We choose the easing to resemble a bouncy ball:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This line sets the target height and the number of milliseconds the animation
    should last for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are copying the height of the animation back to the real thing. As
    this function binds this to the copied state, we are forced to use ES5 syntax
    to have access to it. This is why we had a variable ready to reference the Vue
    instance. Had we used the ES6 syntax, we would not have any way to get the value
    of `H` directly.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging reusable transitions into components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may have a significant transition in our website that we want to reuse throughout
    the user funnel. Packaging transition into components can be a good strategy if
    you are trying to keep your code organized. In this recipe, you will build a simple
    transition component.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following this recipe makes sense if you have already worked your way through
    the transition with Vue. Also, since we are working with components, you should
    at least have an idea of what they are. Skim through the next chapter for a primer
    on components. In particular, we will create a functional component, the anatomy
    of which is detailed in the *Creating a functional component* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will build a signature transition for a news portal. Actually, we will use
    a premade transition in the excellent magic library ([https://github.com/miniMAC/magic](https://github.com/miniMAC/magic)),
    so you should add it to your project as a dependency. You can find the CDN link
    at [https://cdnjs.com/libraries/magic](https://cdnjs.com/libraries/magic) [(go
    to the page to find the link, don't copy it as a link).](https://github.com/miniMAC/magic)
  prefs: []
  type: TYPE_NORMAL
- en: First, you will build the website page, then you will build the transition itself.
    Lastly, you will just add the transition to different elements.
  prefs: []
  type: TYPE_NORMAL
- en: Building the basic web page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our web page will consist of two buttons each that will display a card: one
    is a recipe and the other is the last breaking news:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The cards will have their unique touch, thanks to the following CSS rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript part will be a very simple Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code will already display your web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ed375e27-7280-4136-94b9-add992772c44.png)'
  prefs: []
  type: TYPE_IMG
- en: Building the reusable transition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We decided that our website will feature a transition whenever a card is displayed.
    Since we intend to reuse the animation with everything in our website, we'd better
    package it in a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the Vue instance, we declare the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `puffIn` and `puffOut` animations are defined in `magic.css`.
  prefs: []
  type: TYPE_NORMAL
- en: Using our transition with the elements in our page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will just edit our web page to add the `<puff>` component to our cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The cards will now appear and disappear when pressing the button with a "puff"
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only tricky part in our code is building the `<puff>` component. Once we
    have that in place, whatever we put inside will appear and disappear according
    to our transition. In our example, we used an already made transition. In the
    real world, we may craft a seriously complex animation that can be difficult to
    apply every time in the same manner. Having it packaged in a component is much
    easier and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things make the `<puff>` component work as a reusable transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specify the classes the component must adopt when entering and leaving;
    there is nothing too special here, we have already done it in the *Integrating
    with third-party CSS animation libraries such as animate.css* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end we return the actual element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This line creates the root of our element that is a `<transition>` tag with
    only one child--`context.children`. This means that the child is unspecified;
    the component will put as child whatever actual child is passed in the template.
    In our examples, we passed some cards that were promptly displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vue, a constant theme is reactivity and, of course, transitions can be dynamic
    because of that. Not only the transition themselves, but all their properties
    can be bound to reactive variables. This gives us a lot of control over which
    transition to use at any given moment.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds on top of the *Transitioning between elements* recipe. You
    don't need to go back if you already know about transitions, but if you feel like
    you're missing something, it might be a good idea to complete that first.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will transform a frog into a princess with some kisses, but if we kiss too
    much the princess will turn into Santa. Of course, we are talking about emojis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our HTML setup is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Just note that most of the attributes here are bound to variables. Here is how
    the JavaScript unfolds.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a simple Vue instance with all of our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The fade transformation we are referring to is the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables transformation and emoji are defined by two computed properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'While we are using the fade transition between the frog and the princess, we
    want something else between the princess and the frog. We will use the following
    transition classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, since we bound the name of the transition to a variable, we can easily
    switch that programmatically. We can do that by adding the following highlighted
    lines to the computed property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The first added line is to avoid having an overlap while the zoom transition
    starts (more on that in the *Letting an element leave before the enter phase in
    a transition* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: The second added line switches the animation to "zoom".
  prefs: []
  type: TYPE_NORMAL
- en: 'To make everything appear the right way, we need one more CSS rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This is much nicer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the app and see how the two different transitions are used dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0019baba-8d2b-4051-9b82-f9a8dbae600b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As the number of kisses increase, the princess zooms out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bca613d9-9f69-4f92-b620-fbecfa645773.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With this, the Santa zooms in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6827d454-44cf-4588-850d-b4dd0f82efdb.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you understand how reactivity works in Vue, there is not much to add. We
    bound the name of the transition to the `kindOfTransformation` variable and switched
    from fade to zoom in our code. We also demonstrated that the other attributes
    of the `<transition>` tag can be changed on the fly as well.
  prefs: []
  type: TYPE_NORMAL
