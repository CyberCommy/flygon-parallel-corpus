- en: Learning Docker Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn some essential Docker commands. While we focus
    on one of the most important commands, the `container run` command, we will also
    cover many other commands that you will be using every day. These commands include
    the list container command, the stop container command, and the remove container
    command. Along the way, we will also discover other container commands such as
    logs, inspect, stats, attach, exec, and commit. I think you will find this chapter
    to be an excellent foundation for Docker education.
  prefs: []
  type: TYPE_NORMAL
- en: 'BIC: The Bureau of International des Containers was founded in 1933 as a neutral,
    non-profit, international organization whose mission is to promote the safe, secure,
    and sustainable expansion of containerization and intermodal transportation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The current and previous command-line syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both ways to use the version commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `container run` command and many of its optional parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to start and stop your containers, view information about your containers,
    interact with running containers, and how to save and reuse changes made to your
    containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be pulling Docker images from Docker's public repo, and installing
    the jq software package, so basic internet access is required to execute the examples
    within this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter02](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter02)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action: [http://bit.ly/2P43WNT](http://bit.ly/2P43WNT)'
  prefs: []
  type: TYPE_NORMAL
- en: Information about command syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into learning about Docker commands and their many options, I
    want to inform you of a change to the Docker CLI that happened in January 2017.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of commands and associated options have been increasing with each
    new release of Docker. Docker decided that the complexity this was creating needed
    to be addressed. So, with the release of Docker version 1.13 (Docker also changed
    the version numbing scheme in 2017), the CLI commands have been divided into management
    functional groups. For example, there is now a container management group of commands,
    and an image management group of commands. This changes how you run Docker commands.
    Here is an example of the use of the old and new `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This change provides better command organization, but also adds some verbosity
    to the command line. It's a trade-off. For now, as far as I know, the old command
    syntax still works for all Docker commands, but for the rest of the examples in
    this book, I am planning to use the new syntax. At least I'll try, as old habits
    die hard.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other note I would like to make here is that most command options have
    a short and long format. I will try to share the long format as an option in my
    examples at least once so you will know what the short version stands for. If
    you installed the Docker command-line completion, it will be a helpful resource
    for remembering both the new Docker management-based commands and the parameters
    that can be used with them. Here is a look at the top-level command-completion
    help for the container commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f5fa4bbe-0891-4883-8c95-ddb910ca7e9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That command list gives us a sneak peek at some of the commands we are going
    to review in this chapter, so let''s get started with learning Docker commands.
    In [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml), *Setting up a Docker
    Development Environment*, we used two very common Docker commands: the `version`
    command and the `run` command. While you think you know pretty much everything
    there is to know about the `version` command, you may be surprised to learn that
    it has another trick up its sleeve. There is another version of Docker''s version
    command.'
  prefs: []
  type: TYPE_NORMAL
- en: The version command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have already used the `docker --version` command as a quick test to confirm
    that Docker was installed. Now try the command without the dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This version of the command gives you greater detail about the version of Docker
    installed on your system. It is worth noting that the docker-compose command,
    which we will talk about later, also has two versions of the version command—one
    with the dashes providing a single-line response, and one without the dashes that
    delivers more details.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that all the Docker commands have a rich help system built in. Try
    it by entering any part of a Docker command and using the `--help` parameter.
    For example, `docker container run --help`.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker run command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we will be using the `run` command a lot, we should take a look at that
    now. You have already used the `run` command in its most basic form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command tells Docker that you want to run a container based on the image
    described as hello-world. You may be asking yourself, did the hello-world container
    image get installed when I installed Docker? The answer is no. The `docker run`
    command will look at the local container image cache to see whether there is a
    container image that matches the description of the requested container. If there
    is, Docker will run the container from the cached image. If the desired container
    image is not found in the cache, Docker will reach out to a Docker registry to
    try to download the container image, storing it in the local cache in the process.
    Docker will then run the newly-downloaded container from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Docker registry is just a centralized location to store and retrieve Docker
    images. We will talk more about registries and the Docker registry specifically
    later. For now, just understand that there is a local image cache and a remote
    image store. You saw the container not found locally process occur when we ran
    the hello-world container in [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml), *Setting
    up a Docker Development Environment. *Here is what it looks like when Docker does
    not find the container image in the local cache and has to download it from the
    registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8d336a4c-94d9-4a62-832f-c6a370eb84de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can pre-seed the local docker cache with container images you plan to run
    by using the docker `pull` command; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you prefetch the container image with a `pull` command, when you execute
    the docker `run` command, it will find the image in the local cache and not need
    to download it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed in the preceding screenshot that you requested the hello-world container
    image and Docker unsuccessfully searched the local cache and then downloaded the `hello-world:latest` container
    image from the repository. Each container image description is made up of three
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker registry host name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slash-separated name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first part, the registry host name, we have not seen or used yet, but it
    was included via a default value of the public Docker registry. Whenever you do
    not specify a registry host name, Docker will invisibly use the public Docker
    registry. This registry host name is `docker.io`. The contents of the Docker registry
    can be browsed at [https://hub.docker.com/explore](https://hub.docker.com/explore).
    This is the main public store for Docker images. It is possible to set up and
    use other public or private image registries, and many corporations will do just
    that, setting up their own private Docker image registry. We will talk a little
    more about that in Chapter 8, *Docker and Jenkins*. For now, just understand that
    the first part of a Docker image description is the registry host name that hosts
    the container image. It is worth noting that the registry host name can include
    a port number. This can be used for registries that are configured to serve data
    on a non-default port value.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the container image description is the slash-separated name.
    This part is like a path to, and name of, the container image. There are certain
    official container images that do not need to specify the path. For those images,
    you can simply specify the name portion of the slash-separated name. In our example,
    that is the hello-world part of the description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the container image description is the tag name. This part
    is considered the version tag for the image, but it does not need to be made up
    of just numbers. The tag name can be any set of ASCII characters, including uppercase
    and lowercase letters, numbers, dashes, underscores, or periods. About the only
    restrictions on tag names are that they cannot start with a period or dash, and
    have to be 128 characters or fewer. The tag name is separated from the slash-separated
    name by a colon. This brings us back to the `hello-world:latest` image description
    we saw earlier. Like the registry host name, there is a default value for the
    tag name. That default value is `latest`. In our example, the tag name being used
    is the default, and it is shown in the search and download as `hello-world:latest`.
    You can see all of this in action in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8e50f5e2-4ba1-4a13-962d-84665c6b3369.png)'
  prefs: []
  type: TYPE_IMG
- en: We confirmed that our local image cache is empty, with the `docker images` command,
    and we then pulled the fully qualified hello-world image to prefetch it into our
    local cache. Then we used the same short description as we did in all of our previous
    hello-world examples, and Docker runs the container without downloading again,
    showing that the default values are used and that they match the fully-qualified
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now that we have all of the basics of the Docker `run` command out of
    the way, let''s dig a little deeper and examine some of the optional parameters
    that you can use with the `run` command. If you look at the full `run` command
    syntax, you will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the last parts of the command are `[COMMAND] [ARG...]`. This tells
    us that the `container run` command has an optional command parameter that can
    also include its own optional parameters. Docker container images are built with
    a default command that is executed when you run a container based on the image.
    For the hello-world container, the default command is `/hello`. For a full Ubuntu
    OS container, the default command is `bash`. Whenever you run an Ubuntu container
    and don''t specify a command to run in the container, the default command will
    be used. Don''t worry if this doesn''t make much sense yet—we will cover the default
    command and overriding it at runtime later in this chapter in the *Back to the
    Docker run command* section. For now, it is enough to know that when you run a
    container, it will execute a command that is either the default command or, if
    provided to the `container run` command, an override command to execute in the
    running container. One last note: when the command being executed by the running
    container (either default or override) terminates, the container will exit. In
    our examples using the hello-world container, as soon as the `/hello` command
    terminates inside the container, the hello-world container exits. In a moment,
    you will learn more about the difference between a running container and one that
    has exited.'
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will continue our `run` command discussion with one of my favorite
    optional parameters, the `--rm` parameter. A little background information is
    required here. As you may recall from [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml), *Setting
    up a Docker Development Environment*, a Docker image is made up of layers. Whenever
    you run a docker container, it is really just using the locally-cached docker
    image (which is a stack of layers), and creating a new layer on top that is a
    read/write layer. All of the execution and changes that occur during the running
    of a container are stored in its own read/write layer.
  prefs: []
  type: TYPE_NORMAL
- en: The list container command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The indication of a running container can be shown using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is the list containers command, and without any additional parameters,
    it will list the currently-running containers. What do I mean by currently running?
    A container is a special process running on the system, and like other processes
    on the system, a container can stop or exit. However, unlike other types of processes
    on your system, the default behavior for a container is to leave behind its read/write
    layer when it stops. This is because you can restart the container if desired,
    keeping the state data it had when it exited. As an example, imagine you run a
    container that is an OS, such as Ubuntu, and in that container you install `wget`.
    After the container exits, you can restart it, and it will still have `wget` installed.
    Remember that each running container has its own read/write layer, so, if you
    run one Ubuntu container and install `wget`, then you run another Ubuntu container,
    it will not have `wget`. The read/write layers are not shared between containers.
    However, if you restart a container that had the `wget` installed, it will still
    be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the difference between a running container and a stopped one is that the
    process is either running or it has exited, leaving behind its own read/write
    layer. There is a parameter to the list containers command that allows you to
    list all of the containers, both those running and those that have exited. As
    you may have guessed, it is the `--all` parameter, and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s go back to one of my favorite optional run command parameters,
    the `--rm` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This parameter instructs Docker to remove the container''s read/write layer
    automatically when the container exits. When you run a docker container without
    the `--rm` parameter, the container data is left behind when the container exits
    so that the container can be restarted again later. If, however, you include the
    `--rm` parameter when you run a container, all of the container''s read/write
    data is removed at the time the container exits. This parameter provides an easy
    clean up on `exit` function that you will often find very helpful. Let''s see
    this with a quick example using the run and `container ls` commands we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/537bbccb-96a6-49ac-8ed4-f80ef15988f7.png)'
  prefs: []
  type: TYPE_IMG
- en: First, we confirmed we had the hello-world image in our local cache. Next, we
    listed all of the containers on our system, both running and exited. Note the
    distinction between images and containers. If you are familiar with VMware, the
    analogy would be somewhat like a template and a VM. Next, we ran the hello-world
    container using the `--rm` parameter. The hello-world container prints its message
    and then immediately exits (we redirected the output to `/dev/null` to keep the
    example output short). Next, we listed the containers again, as we saw that the
    hello-world container's read/write data was automatically removed when the container
    exited. After that, we ran the hello-world container again, but this time did
    not use the `--rm` parameter. When we listed the containers this time, we saw
    the indication of the (exited) container. Often you will run a container, knowing
    that you will never need to restart it later, and using the `--rm` parameter to
    automatically clean it up is very handy. But what if you don't use the `--rm`
    parameter? Are you stuck with an ever-growing list of containers? Of course not.
    Docker has a command for that. It is the `container rm` command.
  prefs: []
  type: TYPE_NORMAL
- en: The remove container command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The remove container command looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The command requires a value that uniquely identifies a container; in this
    case, I used the full container ID for the hello-world container that we just
    ran. You can use the first few characters of a container''s ID, as long as it
    provides a unique identifier between all of the containers on your system. Another
    way to uniquely identify the container is by the `name` assigned to it. Docker
    will provide a unique randomly-generated name for your container when you run
    it. In the preceding example, the random name assigned was `competent_payne`.
    So we could have used the remove command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While the randomly-generated names provided by docker are more human-readable
    than the container IDs it assigns, they still may not be as relevant as you would
    like. This is why docker has provided an optional parameter to the `run` command
    for naming your containers. Here is an example using the `--name` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now when we list all of the containers, we can see our container has the name
    `hi-earl`. Of course, you would probably want to use a better container name,
    perhaps one that describes the function performed by the container, such as `db-for-earls-app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Like the container IDs, the container names must be unique on a host.
    You cannot have two containers (even if one has exited) that have the same name.
    If you will have more than one container running the same image, such as web server
    image, name them uniquely, for example, web01 and web02.![](Images/9d9bae7d-2569-4d62-b104-0f77cef7e52c.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can delete multiple containers at the same time by providing the unique
    identifier for each on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, you will remove containers only after they have exited, such as the
    hello-world containers that we have been using. However, sometimes you will want
    to remove a container even if it is currently running. You can use the `--force`
    parameter to handle that situation. Here is an example of using the force parameter
    to remove a running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what that would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e6d64ba5-07f6-4495-a2d1-b8e9b6964384.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that in the first `container ls` command, we didn't use the `--all` parameter.
    This reminds us that the web server container is running. When we tried to remove
    it, we were informed that the container is still running and would not be removed.
    This is a good safeguard to help prevent the removal of running containers. Next,
    we used the force command, and the running container was removed without any warning.
    Finally, we did another `container ls` command, including the `--all` parameter
    to show that the read/write data for our container was actually removed this time.
  prefs: []
  type: TYPE_NORMAL
- en: If you have set up Docker command completion, you can type in the command up
    to where you need to enter the unique identifier for the container(s) and then
    use the *Tab *key to get a list of containers, tabbing to the one you want to
    delete. Once you've highlighted the container to delete, use the space or *Enter*
    key to select it. You can hit *Tab* again to select another container to delete
    more than one at a time. Once you have all the containers selected, press *Enter*
    to execute the command. Remember that you will only see stopped containers when
    you tab for the `rm` command unless you include the force parameter, `rm -f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you may want to remove all of the containers on your system, running
    or not. There is a useful way to handle that situation. You can combine the `container
    ls` command and the container remove command to get the job done. You will be
    using a new parameter on the `container ls` command to accomplish this—the `--quiet`
    parameter. This command instructs Docker to only return the container IDs instead
    of the full list with a header. Here is the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can *feed* the values returned by the `container ls` command as input
    parameters to the container remove command. It will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will remove *all* of the containers *both running and exited* from your
    system, so be careful!
  prefs: []
  type: TYPE_NORMAL
- en: You will probably use this shortcut often, so creating a system alias for it
    is pretty handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add something like the following to your `~/.bash_profile` or `~/zshrc`
    file: `alias RMAC=''docker container rm --force $(docker container ls --all --quiet)''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many containers are designed to run and exit immediately, such as the hello-world
    example we''ve used several times already. Other container''s images are created
    so that, when you run a container using it, the container will continue running,
    providing some ongoing useful function, such as serving web pages. When you run
    a container that persists, it will hold onto the foreground process until it exits,
    attaching to the processes: standard input, standard output, and standard error.
    This is okay for some testing and development use cases, but normally, this would
    not be desired for a production container. Instead, it would be better to have
    the `container run` as a background process, giving you back control of your terminal
    session once it launches. Of course, there is a parameter for that. It is the
    `--detach` parameter. Here is what using that parameter looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using this parameter detaches the process from the foreground session and returns
    control to you as soon as the container has started. Your next question is probably,
    how do I stop a detached container? Well, I am glad you asked. You use the `container
    stop` command.
  prefs: []
  type: TYPE_NORMAL
- en: The stop container command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stop command is easy to use. Here are the syntax and an example of the
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we used the `--rm` parameter when running the container, so as
    soon as the container is stopped, the read/write layer will be automatically deleted.
    Like many of the Docker commands, you can provide more than one unique container
    identifier as parameters to stop more than one container with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: Now you might be wondering if I use the `--detach` parameter, how do I see what
    is happening with the container? There are several ways you can get information
    from, and about, the container. Let's take a look at some of them before we continue
    with our run parameter exploration.
  prefs: []
  type: TYPE_NORMAL
- en: The container logs command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you run a container in the foreground, all of the output the container
    sends to standard output and standard error is displayed in the console for the
    session that ran the container. However, when you use the `--detach` parameter,
    control of the session is returned as soon as the container starts so you don''t
    see the data sent to `stdout` and `stderr`. If you want to see that data, you
    use the `container logs` command. That command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `--details`, `--follow`, `--timestamps`, and `--tail` parameters are all
    optional, but I have included them here for reference. When you use the `container
    logs` command with no optional parameters, it will just dump all of the contents
    of the container's logs to the console. You can use the `--tail` parameter with
    a number to dump just the last number of lines. You can combine the parameters
    (except for `--tail` and `--follow`) to get the results you want. The `--follow`
    parameter is like using a `tail -f` command when viewing logs that are being continually
    written to, and will display each line as it is written to the log. You use *Ctrl *+ *C* to
    exit the log being followed. The `--timestamps` parameter is great for evaluating
    the frequency at which lines have been written to the container's logs.
  prefs: []
  type: TYPE_NORMAL
- en: The container top command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may not always want to simply view the logs of a container; sometimes you
    want to know what processes are running inside a container. That''s where the
    `container top` command comes in. Ideally, each container is running a single
    process, but the world is not always ideal, so you can use a command such as this
    to view all the processes running in the targeted container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect, the `container top` command is only used for viewing the
    processes of a single container at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The container inspect command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you run a container, there is a lot of metadata that gets associated with
    the container. There are many times that you will want to review that metadata.
    The command for doing that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, this command returns a lot of data. You may only be interested
    in a subset of the metadata. You can use the `--format` parameter to narrow the
    data returned. Check out these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting some State data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting some `NetworkSettings` data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting data for more than one container with a single command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of these examples use the json processor, `jq`. If you haven''t already
    installed it on your system, now is a good time to do so. Here are the commands
    to install `jq` on each of the OSes we''ve used in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `--format` parameter of the inspect command uses go templates. You can find
    more information about them on the Docker document pages for formatting output: [https://docs.docker.com/config/formatting](https://docs.docker.com/config/formatting).
  prefs: []
  type: TYPE_NORMAL
- en: The container stats command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another very useful Docker command is the stats command. It provides live,
    continually-updated usage statistics for one or more running containers. It is
    a bit like using the Linux `top` command. You can run the command with no parameters
    to view the stats for all running containers, or you can provide one or more unique
    container identifiers to view the stats for one or more container''s specific
    containers. Here are some examples of using the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When you have seen enough stats, you use C*trl* + *C* to exit the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to `run` command parameters, next, we''ll discuss two parameters
    for the `run` command that are usually used together. Sometimes you run a container,
    and you want to have an interactive session with it. For example, you may run
    a container that executes some application inside a more or less full OS, such
    as Ubuntu, and you want to have access inside that container to change the configuration
    or debug some issue, similar to using SSH to connect to a server. As with most
    things Docker, there is more than one way to accomplish this. One common method
    is to use two optional parameters for the run command: `--interactive` and `--tty`.
    Let''s take a look at how that works now. You have already seen how we can use
    the `--detach` parameter startup disconnected from the container we are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this command to start up our nginx web server and browse to `http://localhost`,
    we find that it is not serving the welcome page we expect. So we decide to do
    some debugging, and, instead of detaching from our container, we decide to run
    it interactively using the two `--interactive` and `--tty` parameters. Now, since
    this is a nginx container, it has a default command that is executed when the
    container starts. That command is `nginx -g ''daemon off;''`. Since that is the
    default command, it won''t do us any good to interact with the container. So we
    are going to override the default command by providing one as a parameter to our
    run command. It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will run the container as before, but instead of executing the
    default command, it will execute the `bash` command. It will also open a terminal
    session with the container that we can interact with. As needed, we can execute
    commands inside of the container as the `root` user. We can view folders and files,
    we can edit configuration settings, we can install packages, and so on. We can
    even run the image''s default command to see whether we have resolved any issues.
    Here is a somewhat contrived example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5355ddb7-ef52-4406-9397-c7839cf8de8f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may have noticed the `-p 80:80` parameter. That is the short form of the
    publish parameter, which we will discuss shortly in the *Back to the Docker run
    command* section. Using the `container ls` command, you can see the differences
    between running the container using the default command versus running the container
    using an override command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/339ffd7a-c93b-466f-b9f1-e389a763598b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Web-server run used the default CMD, and web-server2 used the override CMD
    `bash`. This is a contrived example to help you understand these concepts. A real-world
    example might be when you want to interactively connect with an OS-based container,
    such as Ubuntu. You may recall that at the beginning of [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml),
    *Setting up a Docker Development Environment*, it said that the default command
    run in an Ubuntu container is `bash`. Since that is the case, you don''t have
    to supply a command to override the default. You can use a run command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With this `container run` command, you are connected to an interactive terminal
    session of your running Ubuntu container. You can do pretty much anything you
    would normally do when ssh-ed into an Ubuntu server. You can install software
    with `apt-get`, you can view running processes, you can execute a `top` command,
    and so on. That might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9fafd0d2-f070-4432-bea9-b6d2a7a141ba.png)'
  prefs: []
  type: TYPE_IMG
- en: There are a couple of other container commands that help you interact with a
    container that is already running and is detached. Let's take a quick look at
    these commands now.
  prefs: []
  type: TYPE_NORMAL
- en: The container attach command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you have a running container. It is currently detached from your terminal
    session. You can use the `container attach` command to bring that container''s
    executing process to be the foreground process of your terminal session. Let''s
    use the web-server example we used earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When you attach to the running container, its executing command becomes the
    foreground process for your terminal session. To detach from the container, you
    need to issue a*Ctrl* + *PQ* keystroke. If you issue a *Ctrl* + *C* keystroke,
    the container's executing process will receive a sig-term signal and will terminate,
    which in turn will exit the container. This is usually not desired. So remember
    to detach by using a *Ctrl* + *PQ* keystroke.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a known issue on macOS: for Docker on Mac, the *Ctrl* + *PQ* keystroke
    does not work, and unless you use another parameter, the `--sig-proxy=false` parameter,
    on the `attach` command, you will not be able to detach from the container without
    terminating it with a *Ctrl *+ *C* keystroke:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When you provide the `--sig-proxy=false` parameter to the `attach` command,
    you can issue a *Ctrl *+ *C* keystroke to the attached container and it will detach
    without sending the sig-term signal to the container process, thus keeping the
    container running, once again detached from your terminal session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fcf8b70a-0e46-4ad1-a260-d783fadf9ca6.png)'
  prefs: []
  type: TYPE_IMG
- en: The container exec command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, when you have a container running detached, you might want to get
    access to it, but don''t want to attach to the executing command. You can accomplish
    this by using the container exec command. This command allows you to execute another
    command in the running container, without attaching to or interfering with the
    already-running command. This command is often used to create an interactive session
    with an already-running container or to execute a single command within the container.
    The command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `exec` command completes, you exit the bash shell, or the file contents
    have been displaced, then it exits back to the terminal session leaving the container
    running detached:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fb344e4d-5ba7-440f-af71-9b42c8c4ccce.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at another Docker command before we continue our discussion
    of the many optional `container run` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The container commit command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is important to know that when you are attached to a running container and
    make changes to it, such as installing new packages, or changing configuration
    files, that those changes only apply to that running container. If, for example,
    you use an Ubuntu image to run a container and then install `curl` into that container,
    the change does not apply back to the image you ran the container from, in this
    example, Ubuntu. If you were to start another container from the same Ubuntu image,
    you would need to install `curl` again. However, if you want to have the changes
    you make inside a running container persist and be available when you run new
    containers, you can use the `container commit` command. The `container commit`
    command allows you to save the current read/write layer of a container along with
    the layers of the original image, creating a brand new image. When you run containers
    using the new image, it will include the changes you made and saved with the `container
    commit` command. Here is what the `container commit` command looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is an example of using the `container commit` command to install `curl`
    to a running container, and then creating a new container that includes the installed
    `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/47f18f01-68e7-42e5-80de-4dacdf2aad16.png)'
  prefs: []
  type: TYPE_IMG
- en: With this example, I can now run new containers from the `ubuntu-curl` image,
    and all of them will have the `curl` command already installed.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the Docker run command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s return to our discussion of the `container run` command. Earlier,
    you saw an example of using the `run` command with the `--publish` parameter.
    Using the optional publish parameter allows you to specify what ports will be
    opened related to the run container. The `--publish` parameter includes pairs
    of port numbers separated by a colon. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The first port number is associated with the host running the container. In
    the nginx example, `8080` is exposed on the host; in our case that would be `http://localhost:8080`.
    The second port number is the port that is open on the running container. In this
    case, it would be `80`. Speaking out the description of the `--publish 8080:80`
    parameter, you would say something like, the traffic sent to port `8080` *o*n
    the host is redirected to port `80` on the running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3309bf24-df9f-47bf-b97c-9bc3112928fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is an important distinction to make between the host ports and the container
    ports. I can run several containers on the same system that all expose port `80`,
    but only one container can have traffic from each port on the host. Look at the
    following examples to better understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Know that this is a limitation of networking in general, not a limitation of
    Docker or containers. Here we can see these commands and their output. Notice
    the ports and names, and how the use of a port already used as an endpoint fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/60594bf1-705f-48cf-9ecd-60d4691320be.png)'
  prefs: []
  type: TYPE_IMG
- en: That was a lot of data on various options parameters for the `container run`
    command. It's not all the options parameters, but it should be enough to get you
    off to a great start. If you want to learn more about the optional parameters
    we explored, or find out about the ones we didn't cover here, be sure to visit
    the docker documents page for the `container run` command, which can be found
    at [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Docker image descriptions and a little about
    Docker registries. Then we saw that there is another form of the version command.
    After that, we explored a lot of Docker container commands, including `run`, `stop`,
    `ls`, `logs`, `top`, `stats`, `attach`, `exec`, and the `commit` command. Finally,
    we found out how to expose your containers by opening ports from your host and
    to your containers. You should feel pretty good about what you can do with Docker
    already, but hang on—in [Chapter 3](ab7747ed-23c9-462c-98cb-c70e330c5d87.xhtml),
    *Creating Docker Images*, we are going to show you how to create your own Docker
    images with a `Dockerfile` and the image build command. If you're ready, turn
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker registry: [https://hub.docker.com/explore/](https://hub.docker.com/explore/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the parameters for the `container run` command: [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `--format` parameter with the container inspect command: [https://docs.docker.com/config/formatting](https://docs.docker.com/config/formatting)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The json jq parser: [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chocolatey Windows package manager: [https://chocolatey.org/](https://chocolatey.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
