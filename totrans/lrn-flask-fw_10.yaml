- en: Chapter 10. Deploying Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to deploy our Flask applications securely
    and in an automated, repeatable manner. We will see how to configure commonly
    used **WSGI** (**Web Server Gateway Interface**) capable servers such as Apache,
    Nginx, as well as the Python Webserver Gunicorn. Then we will see how to secure
    a part or the entire site using SSL, before finally wrapping up our application
    in a configuration management tool to automate our deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we shall learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring commonly-used WSGI servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SSL to secure your site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating deployment using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Flask with a WSGI server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to note that Flask, by itself, is not a web server. Web servers
    are tools that are Internet-facing, have had many years of development and patching
    applied to them, and can run many services at once.
  prefs: []
  type: TYPE_NORMAL
- en: Running Flask by itself as a Web server on the Internet will most likely be
    fine, thanks to the Werkzeug WSGI layer However, the real focus of development
    on Flask is page-routing and rendering the system. Running Flask as a web server
    may have unintended effects. Ideally, Flask will sit behind a web server and be
    called upon when the server recognizes a request for your app. To do this, the
    web server and Flask need to be able to speak the same language.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately the Werkzeug stack, upon which Flask is built, is designed to speak
    WSGI. WSGI is a common protocol used by web servers such as Apache's httpd and
    Nginx. It can be used to manage the load on your Flask app and communicate the
    important bits of information about where the requests came from and what kind
    of headers the request has, all in a way that Python can understand.
  prefs: []
  type: TYPE_NORMAL
- en: However, to get Werkzeug to talk to your web server using the WSGI protocol,
    we must use a gateway. This will take the requests from your web server and the
    Python application and translate the actions between them. Most web servers will
    speak WSGI although some need a module, and some a separate gateway such as uWSGI.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the first things to do is to create a WSGI file for the WSGI gateway
    to communicate through. This is simply a Python file with a known structure so
    that the WSGI gateway can access it. We need to create a file called `wsgi.py`
    in the same directory as the rest of your blog app and it will contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Flask, by default, is WSGI-compatible so we just need to declare the object
    in the right way for the WSGI gateway to understand. Now the web server needs
    to be configured to find this file.
  prefs: []
  type: TYPE_NORMAL
- en: Apache's httpd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apache's httpd is probably the most widely used web server on the internet right
    now. The program's name is actually httpd, and it is maintained by the Apache
    Software Foundation. However, most people refer to it as *Apache* so that is what
    we shall call it as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that Apache and the WSGI module are installed on Debian- and Ubuntu-based
    systems, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, on Red Hat- and Fedora-based systems run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To set up the Apache configuration, we must create a configuration file that
    will specify a new VirtualHost. You must locate the directory on your system where
    these files are kept. In Debian-based systems, such as Ubuntu, this will be in
    `/etc/apache2/sites-available`; create your `blog` file in there. On Red Hat/Fedora-based
    systems, we need to create a file called `blog.conf` in the `/etc/apache2/conf.d`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that configuration file, update the content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This configuration instructs Apache that, for every request to the host on port
    `80`, there is to attempt to load from the `wsgi.py` script. The directory section
    tells Apache how to handle requests to that directory and, by default, it is best
    to deny access to the files within your source directory to anyone accessing the
    web server. Be aware that, in this instance, `<path to app>` is the full absolute
    path to the directory where the `wsgi.py` file is stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now need to enable the WSGI module for Apache''s httpd server. This
    is so that Apache knows to use it when specifying the WSGI configuration. On Debian-
    and Ubuntu-based systems, we just run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However on Red Hat and CentOS systems, it is a little more tricky. We will
    need to create or modify the file `/etc/httpd/conf.d/wsgi.conf` to contain the
    following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to enable our new site on the web server on Debian- and Ubuntu-based
    systems by running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This instructs Apache to create a symbolic link from `/etc/apache2/sites-available`
    to `/etc/apache2/sites-enabled,` where Apache actually gets its configuration
    from. Now we need to restart Apache. This can be performed in many ways in your
    particular environment or distribution. The simplest may be just to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So all we need to do is connect to the web server through your browser by going
    to `http://localhost/`.
  prefs: []
  type: TYPE_NORMAL
- en: Check for any issues in your `/var/log/apache2/error.log` in Debian and Ubuntu
    systems and `/var/log/httpd/error_log` in Red Hat- and CentOS-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware that some Linux distros ship with a default configuration that must
    be disabled. This can likely be disabled in Debian- and Ubuntu-based systems by
    typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in Red Hat- and CentOS-based systems we need to remove the `/etc/httpd/conf.d/welcome.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will, of course, have to restart the server again for Debian- and Ubuntu-based
    systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And in Red Hat- and CentOS-based systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Apache also has a reload option rather than restart. This tells the server to
    have a look at the configuration files again and work with them. This is typically
    faster than restart and can keep the existing connections open. Where as, restart
    exits the server and starts again, taking open connections with it. The benefit
    of restart is that it is more definitive and, for setup purposes, more consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One very important step to go through when using Flask, through a web server,
    is to decrease the load on your app by creating a shortcut for your web server
    to the static content on your site. This offloads to the web server the relatively
    trivial task of serving basic files to the end browser, making the process faster
    and more responsive. It is also a straightforward thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit your `blog.conf` file to add the following line within the `<VirtualHost
    *:80>` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `<path to app>` is the full absolute path to the directory where your
    static directory exists. Then reload the Apache configuration for Debian- and
    Ubuntu-based systems as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And for Red Hat- and CentOS-based systems as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will now inform Apache where to look for files when `/static` is requested
    by the browser. You will be able to see this happening by looking at your Apache
    log file, `/var/log/apache2/access.log` for Debian- and Ubuntu-based systems and
    `/var/log/httpd/access.log` for Red Hat- and CentOS-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: Nginx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nginx is rapidly becoming the de facto web server to replace Apache's httpd.
    It is proven to be faster and more lightweight and its configuration, although
    quite different, can be simpler to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Nginx has supported WSGI for some time, even newer Linux distros may
    not have updated to it and therefore we must use an interface layer called **uWSGI**
    to access the Python web apps. uWSGI is a WSGI gateway written in Python that
    can translate between WSGI and your web server via sockets. We need to install
    both Nginx and uWSGI. In Debian and Ubuntu based systems run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And in Red Hat- or Fedora-based systems, the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now since uWSGI is a Python module, we can install it using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To configure Nginx in Debian- and Ubuntu-based systems, create a file called
    `blog.conf` in `/etc/nginx/sites-available` or, in Red Hat- or Fedora-based systems,
    create the file in `/etc/nginx/conf.d` and add the content with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This configuration is very much the same as the Apache configuration, although
    expressed in Nginx form. It accepts connections on port `80` and for any server
    name, it tries to access the `blog.wsgi.sock`, which is a unix socket file used
    to communicate with uWSGI. You will notice that `@blogapp` is used as a shortcut
    reference to the location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only in Debian- and Ubuntu-based systems do we now need to enable the new site,
    by creating a symlink from the available site to the enabled one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to tell uWSGI where to find the socket file so it can communicate
    with Nginx. To do this, we need to create a uWSGI configuration file in the `blog
    app` directory called `uwsgi.ini` that contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You will have to change `<path to app>` to the path where your `app.py` file
    exists. Also note how the socket is set up in the same path as specified in the
    Nginx site configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may note that the formatting and structure of the INI file are very much
    like a Windows INI file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify if this configuration works by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now Nginx knows how to talk to the gateway but isn''t yet using the site configuration
    file; we need to restart it. This can be performed in many ways in your particular
    environment. The simplest may be just to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So all we need to do is connect to the web server through your browser by going
    to `http://localhost/`.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that some Linux distros ship with a default configuration that must
    be disabled. This can normally be done in both Debian- and Ubuntu-based systems,
    and Red Hat- and CentOS-based systems, by deleting the `/etc/nginx/conf.d/default.conf`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And restarting the `nginx` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nginx also has a reload option rather than restart. This tells the server to
    have a look at the configuration files again and work with them. This is typically
    faster than restart and can keep existing connections open. Where as, restart
    exits the server and starts again, taking open connections with it. The benefit
    of restart is that it is more definitive and, for setup purposes, more consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One very important step to go through when using Flask, through a web server,
    is to decrease the load on your app by creating a shortcut for your web server
    to the static content on your site. This offloads, to the web server, the relatively
    trivial task of serving basic files to the end browser, making the process faster
    and more responsive. It is also a straightforward task to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit your `blog.conf` file to add this line within the server `{` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'where `<path to app>` is the full absolute path to the directory where your
    static directory exists. Reload the Nginx configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will now inform Nginx where to look for files when `/static` is requested
    by the browser. You will be able to see this happening by looking at your Nginx
    log file, `/var/log/nginx/access.log`.
  prefs: []
  type: TYPE_NORMAL
- en: Gunicorn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gunicorn is a web server written in Python. It already understands WSGI and
    so does Flask, so getting Gunicorn running it is as easy as entering the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'where `app:app` is your app and the module name the one we used within that
    (much the same as the uWSGI configuration). There are way more options than that,
    but it is useful, for example, to work from and set a port and binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `--bind` flag tells Gunicorn what interface to connect to and on what port.
    This is useful if we need to only use the web app internally.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful flag is the `--daemon` flag that tells Gunicorn to run in the
    background and detach from your shell. This means we no longer have direct control
    of the process but it is running and can be accessed via the bind interface and
    the port that was setup.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your site with SSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an increasingly ruthless Internet, it is important to improve the security
    of your site by proving its authenticity. A common tool for improving this for
    your site is to use SSL, or even better TLS.
  prefs: []
  type: TYPE_NORMAL
- en: SSL and TLS certificates allow your server to be verified by a trusted third-party
    based upon the domain name that your browser is connecting to. This means that,
    as a web user, we can be sure that the web site we are talking to hasn't been
    changed in transit, is the correct server we are talking to, and that the data
    being sent between the server and our browser cannot be sniffed. This obviously
    becomes important when we want to verify that the information our users are sending
    us is valid, and protected, and our users want to know that our data is protected
    in transit.
  prefs: []
  type: TYPE_NORMAL
- en: Getting your certificate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is generate your SSL certificate request. This is used
    in conjunction with a third party who signs the request to verify your server
    with any browser. There are a few ways of doing this, depending on your system,
    but the easiest is to run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now be asked a few questions about the organization you''re affiliated
    to, but the important line is the Common Name. This is the domain name (without
    `https://`) that your server will be accessed at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can see here we used `blog.example.com` as our example domain name that
    our blog app will be accessed at. You must use your own here. E-mail addresses
    and passwords are not hugely important and can be left blank, but you should fill
    in the `Organization Name` field as this will be the name your SSL certificate
    will be recognized as. If you are not a company, just use your own name.
  prefs: []
  type: TYPE_NORMAL
- en: That command generates two files for us; one is a `private.key` file, the file
    our server will use to sign our communication with the browser, and the other
    is `public.csr`, which is the certificate request file sent to the third-party
    service that handles the verification between the server and your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Public/Private key cryptography is a vast but well explored subject. In the
    light of the Heartbleed attack, it is worth having a reasonable understanding
    of this, if you are looking to secure a server.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to sign your `public.csr` request with a third party. There
    are many services that will do this for you, some free and some at a slight cost;
    some such as **Let's Encrypt** automate the entire process with a script completely
    free of cost. All of them offer essentially the same service, but they may not
    all be built-in to all browsers, and offer various levels of support for varying
    degrees of cost.
  prefs: []
  type: TYPE_NORMAL
- en: These services will go through a verification process with you, ask for your
    `public.csr` certificate request, and return you a signed `.crt` certificate file
    for your host name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that it will most likely help you to name your `.crt` and `.key` file with
    your site's host name in it, with which you applied for the certificate. In our
    case, this would be `blog.example.com.crt`.
  prefs: []
  type: TYPE_NORMAL
- en: Your new `.crt` file and your existing `.key` file can be placed anywhere on
    your server. However, typically the `.crt` files go into `/etc/ssl/certs` and
    the `.key` files in `/etc/ssl/private`.
  prefs: []
  type: TYPE_NORMAL
- en: With all the correct files in the right place, we need to reopen the existing
    Apache configuration that we used for our blog service. It would be preferable
    to run a normal HTTP and HTTPS service. However, since we have gone to the effort
    of setting up the HTTPS service, it makes sense to enforce it by redirecting our
    users. This can be done using a new specification called HSTS however not all
    builds of web servers support this yet, so we will use rewrites.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can run tests on your local machine with SSL certs by adding an entry to
    your operating system's host file for your domain. Just don't forget to remove
    it when you are done.
  prefs: []
  type: TYPE_NORMAL
- en: Apache httpd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to change is the port on the `VirtualHost` line from the default
    HTTP port of `80` to the default HTTPS port of `443`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We should also specify the server's hostname the SSL cert is being used on;
    so within the VirtualHost section add a `ServerName` parameter. This will ensure
    the certificate will not be used in the wrong domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You must replace `blog.example.com` with the host name that you will be using.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to set up the SSL configuration so as to tell Apache how to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: What is going on here is that the SSL module in Apache is being enabled, the
    public certificate and private key file are being specified for this site, and
    there is no client certificate required. It is important to disable the default
    SSL protocols and enable TLS, which is considered more secure than SSL. However,
    SSLv2 is still enabled to support older browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to test it. Let''s restart Apache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Try connecting to the web server with your browser, not forgetting that you
    are now using `https://`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that is working, the final step is to redirect plain old HTTP to HTTPS.
    In the configuration file, again add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We create a new `VirtualHost` for port `80` and specify that it is for the `ServerName
    blog.example.com` hostname. But then we use the `Rewrite` module in Apache to
    simply redirect the browser to the same URL it requested, however, using HTTPS
    at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, restart Apache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now test this configuration in your browser on the site; verify that you get
    redirected to HTTPS for whichever page you access.
  prefs: []
  type: TYPE_NORMAL
- en: Nginx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The configuration of Nginx is pretty simple. In much the same way as the Apache
    configuration, we need to change the port that Nginx will be listening to for
    our site. Since HTTPS works on port `443`, the difference here is to tell Nginx
    to expect SSL connections. In the configuration, we must update the line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to add the SSL configuration to the server element of the configuration,
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This tells Nginx to apply this configuration to requests for the `blog.example.com`
    hostname (don't forget to replace it with your own), as we wouldn't like to send
    the SSL cert for a domain that it doesn't apply to. We also specify the public
    certificate file location and the private SSL key file location on the file system.
    Finally, we specify the SSL protocols we want to use, which means enabling TLS
    (considered more secure than SSL). However SSLv2 is still enabled to support older
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to test it. Let''s restart the Nginx service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Try connecting to the web server with your browser, not forgetting you are now
    using `https://`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have proved that it is working, the final step is to redirect plain
    old HTTP to HTTPS. In the configuration file again add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This works much the same as the previous, plain old HTTP configuration; except
    that we use the `rewrite` command to tell Nginx to pick up all URLs and send a
    redirect command to the browser accessing port HTTP to go to HTTPS instead, with
    the exact path they attempted to use on HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the last time, restart Nginx:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Finally, test your browser on the site on which you get redirected to HTTPS
    whichever page you access.
  prefs: []
  type: TYPE_NORMAL
- en: Gunicorn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gunicorn has also had SSL support added to it as of 0.17\. To enable SSL from
    the command line, we need a few flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This works much the same as the Nginx and Apache SSL configurations. It specifies
    the port to bind to, as well as all the interfaces in this case. It then directs
    Gunicorn to the public certificate and private key files, and opts to use SSLv2
    for older browsers and the (commonly considered more secure) TLS cipher protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Test this in your browser by going to the host name and the HTTPS in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that is ready, let''s set up a redirection from port `80` to port `443`.
    This is quite complicated in Gunicorn as it does not have a built-in redirection
    facility. One solution is to create a really simple Flask app that is started
    on port `80` in Gunicorn and redirects to port `443`. It would be a new app with
    a new `app.py` file, and with its contents looking as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is a really simple Flask app that can be used anywhere to redirect a browser
    to the equivalent URL that was requested of it, but with HTTPS on the front. It
    builds a URL by making use of the standard Python `urlparse` library, the requested
    hostname using the header that is sent by the browser to the server, and the generic
    path variable in the route to pick up all document requests. It then uses the
    Flask `redirect` method to tell the browser where it really needs to go.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the empty strings are important to the urlunparse function as it is
    expecting a complete URL tuple, much like that generated by urlparse.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is likely you will know how to run this in Gunicorn by now, nevertheless
    the command to use is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now connect using your browser to your old HTTP host and you should be redirected
    to the HTTPS version.
  prefs: []
  type: TYPE_NORMAL
- en: Automating deployment using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a configuration management tool. It allows us to automate the deployment
    of our applications in a repeatable and manageable manner, without having to consider
    how our application is deployed each time.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible works both locally and over SSH. One of the clever things you can do
    with Ansible is to get Ansible to configure itself. Based on your own configuration,
    it can then be told to deploy the other machines that it needs.
  prefs: []
  type: TYPE_NORMAL
- en: We, however, are just going to concentrate on building our own local Flask instance
    using Apache, WSGI, and Flask.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is install Ansible on the machine that we are going to
    deploy our Flask app on to. Since Ansible is written in Python, we can achieve
    this quite simply by making use of `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We now have a configuration manager and, since a configuration manager is designed
    to set up servers, let's build up a playbook that Ansible can use to build the
    entire machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new project or directory, create a file called `blog.yml`. We are creating
    a file that Ansible calls a Playbook; it is a list of commands that will run in
    sequence and build our blog running under Apache. For simplicity, in this file
    it is assumed that you are using an Ubuntu-derivative operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: An Ansible Playbook is a YAML file that consists of a few sections; the main
    section describes the "play". The `hosts` value describes what group of machines
    the subsequent settings should apply to. `user` describes what user the play should
    run as; for you, this should be a user that Ansible can run as to install your
    application. The `sudo` setting tells Ansible to run this play with `sudo` permissions
    and not to run it as root.
  prefs: []
  type: TYPE_NORMAL
- en: The `vars` section describes variables common to the playbook. These settings
    can be found easily as they are at the top but can also be used later in the playbook
    configuration in the format `${example_variable}`, if `example_variable` was defined
    in the `vars` section here. The most important variable here is the `app_src`
    variable which tells Ansible where to find our app when it is copying it to the
    correct location. In this example, we are assuming it is in a directory called
    `blog`, but for you it may be located elsewhere on your file system and you may
    need to update this variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final and most important section is the `tasks` section. This tells Ansible
    what to run when it is updating the machine it is controlling. If you are familiar
    with Ubuntu, these tasks should be somewhat familiar. `action: apt`, for example,
    tells apt to make sure that all the packages specified in the `with_items` list
    are installed. You will notice the `$item` variable with the `pkg` argument. The
    `$item` variable is automatically populated by Ansible as it iterates over the
    `with_items` command and the `apt` command uses the `pkg` argument to verify that
    the package is installed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The subsequent tasks enable the WSGI module using the command-line command
    `a2enmod wsgi`, which is shorthand in Debian systems for enabling a module, setting
    up the Apache configuration for our blog site by populating a template. Fortunately
    for us, the language Ansible uses for its templates is Jinja, which you are most
    likely already familiar with. The contents of our template file should be relative
    to this `blog.yml`, in a directory called `templates`, and a file called `blog`.
    The contents should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This should be pretty familiar, it is a direct rip-off of the example in the
    Apache section; however, we have made use of the Ansible variables to populate
    the locations of the blog app. This means that, if we want to install the app
    to another location, it will just be a matter of updating the `app_dest` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, among the Playbook tasks, it copies our all-important blog app onto
    the machine, enables the site in Apache by using the Debian shorthand, and reloads
    Apache so it can make use of the site.
  prefs: []
  type: TYPE_NORMAL
- en: So all that is left is to run Ansible on that machine and get it to build your
    system for you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This tells Ansible to run the Playbook file `blog.yml` that we created earlier
    and to use it on the `local` connection type, which means applying to the local
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Ansible Tips**'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting this may not be the best way to use Ansible in a large distributed
    environment. For one, you may want to apply it to remote machines or to separate
    out the Apache configuration, Apache WSGI configuration, Flask app configuration,
    and blog configuration into separate files that Ansible calls a role; this will
    make them reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful tip would be to to specify the configuration file used and set
    up the static directory in Apache. Read the Ansible documentation for more ideas
    about ways to improve your deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.ansible.com/](http://docs.ansible.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Read more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information on how to secure your Flask deployment more effectively
    in Apache and WSGI by creating shell-less users that can only run the Flask app,
    see [http://www.subdimension.co.uk/2012/04/24/Deploying_Flask_to_Apache.html](http://www.subdimension.co.uk/2012/04/24/Deploying_Flask_to_Apache.html).
  prefs: []
  type: TYPE_NORMAL
- en: This guide has more examples for CentOS systems along with Lighttpd and Gunicorn
    all through Ansible [https://www.zufallsheld.de/2014/11/19/deploying-lighttpd-your-flask-apps-gunicorn-and-supervisor-with-ansible-on-centos/](https://www.zufallsheld.de/2014/11/19/deploying-lighttpd-your-flask-apps-gunicorn-and-supervisor-with-ansible-on-centos/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen many ways in which you can run your Flask app,
    including securing it for privacy and security in multiple web servers and serving
    static files to reduce load on your Flask app. We have also made a configuration
    file for Ansible that will enable repeatable application deployment so that if
    the machine ever needs to be built again, it will be a simple task.
  prefs: []
  type: TYPE_NORMAL
