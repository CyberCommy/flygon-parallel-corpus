- en: Chapter 6. Building an Administrative Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build an administrative dashboard for our website.
    Our admin dashboard will give certain, selected, users the ability to manage all
    the content across the entire site. In essence, the admin site will be a graphical
    frontend for the database, supporting operations for creating, editing, and deleting
    rows in our application's tables. The excellent Flask-Admin extension provides
    almost all these functionalities out-of-the- box, but we will go beyond the defaults
    to extend and customize the admin pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Flask-Admin and add it to our website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add views for working with the `Entry`, `Tag,` and `User` models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a view for managing the website's static assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate the admin with the Flask-Login framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a column to identify a user as an administrator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a custom index page for the admin dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Flask-Admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask-Admin provides a readymade admin interface for Flask applications. Flask-Admin
    also integrates nicely with SQLAlchemy to provide views for managing your application's
    models.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image gives is a sneak preview of what the **Entry** admin will
    look like by the end of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Flask-Admin](img/1709_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While this amount of functionality requires relatively little code, we still
    have a lot to cover, so let's get started. Begin by installing `Flask-Admin` into
    `virtualenv` using `pip`. At the time of writing, the current version of Flask-Admin
    is 1.0.7.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test that it installed correctly if you wish by entering the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Adding Flask-Admin to our app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike the other extensions in our app, which we instantiated in the `app`
    module, we will be setting up the admin extension in its own module. We will be
    writing several admin-specific classes, so it makes sense to put them in their
    own module. Create a new module named `admin.py` in the `app` directory, and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Because our `admin` module depends on the `app` module, in order to avoid a
    circular import we need to be sure that `admin` is loaded *after* `app`. Open
    the `main.py` module and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to start the development server and navigate to `/admin/`
    to view a barebones admin–the default dashboard, as seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Flask-Admin to our app](img/1709_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you progress through this chapter, we will turn this boring and plain admin
    interface into a rich and powerful dashboard for managing your blog.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing models through the Admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask-Admin comes with a `contrib` package that contains special view classes
    designed to work with SQLAlchemy models. These classes provide out-of-the-box
    create, read, update, and delete functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `admin.py` and update the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note how we call `admin.add_view()` and pass instances of the `ModelView` class,
    as well as the `db` session, for it to access the database with. Flask-Admin works
    by providing a central endpoint to which we, the developers, can then add our
    own views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server and try pulling up your admin site again. It should
    look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing models through the Admin](img/1709_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Try clicking into one of our model''s views by selecting its link in the navigation
    bar. Clicking the **Entry** link displays all the entries in the database in a
    clean, tabular format. There are even links to create, edit, or delete entries
    as seen in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing models through the Admin](img/1709_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The defaults provided by Flask-Admin are great, but if you start exploring the
    interface you will start to notice subtle things that could be improved or cleaned
    up. For example, it's probably not necessary to include the Entry's body text
    as a column. Similarly, the **Status** column is displaying the status as an integer,
    but we would prefer to see the name associated with that integer. We can also
    click the *Pencil* icon in each of the `Entry` rows. This will take you to the
    default edit form view that you can use to modify that entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'It all looks something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing models through the Admin](img/1709_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding screenshot, Flask-Admin does an impressive
    job of handling our foreign key-to-key and many-to-many fields (author and tags).
    It also does a pretty good job choosing which HTML widget to use for a given field
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Tags can be added and removed using a nice multi-select widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author can be selected using a drop-down menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entry body is conveniently presented as a text area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unfortunately, there are some obvious problems with this form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The ordering of the fields seems arbitrary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Slug** field appears as an editable text input since this is managed by
    the database model. This field should, instead, be generated automatically from
    the Entry's title.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Status** field is a free-form text input field, but should be a drop-down
    menu with human-readable status labels rather than numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Created Timestamp** and **Modified Timestamp** fields appear editable,
    but should be generated automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we'll see how to customize the `Admin` class and the
    `ModelView` class, so that the admin really works for our app.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the list views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's set aside the forms for a moment and focus on cleaning up the list. To
    do this, we will create a subclass of the Flask-Admin, `ModelView`. The `ModelView`
    class provides numerous extension points and attributes that control the look
    and feel of the list display.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by cleaning up the list columns by manually specifying the attributes
    we wish to display. Additionally, since we are going to be displaying the author
    in its own column, we will ask Flask-Admin to efficiently fetch it from the database.
    Open `admin.py` and update the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that `tease` and `tag_list` are not actually the names of columns
    in our `Entry` model. Flask-Admin gives you the ability to use any attribute as
    a column value. We also specify the column to use for creating references to other
    models. Open the `models.py` module and add the following properties to the `Entry`
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you visit the **Entry** admin, you should be presented with a clean,
    readable table as seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the list views](img/1709_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s also fix the display of the **Status** column. Those numbers are difficult
    to remember – it would be preferable to display a human-readable value. Flask-Admin
    comes with a helper for *enumerated* fields (such as **Status**). We simply need
    to provide a mapping of the status value to display the value, and Flask-Admin
    does the rest. Make the following additions to the `EntryModelView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Entry` list view is looking much better. Let''s make some improvements
    to the `User` list view now. Again, we will subclass `ModelView` and specify the
    attributes that we wish to override. Add the following class to `admin.py` below
    `EntryModelView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how the `User` list view looks with our changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the list views](img/1709_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding search and filtering to the list view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to displaying lists of our model instances, Flask-Admin comes with
    powerful search and filtering capabilities. Let's suppose we have a large number
    of entries and want to find those that contain a certain keyword, such as Python.
    It would be beneficial if, from the list view, we could enter our search and have
    Flask-Admin list only those entries that contain the word 'Python' in the title
    or the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might expect, this is very easy to accomplish. Open `admin.py` and add
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When you re-load the `Entry` list view, you will see a new textbox that will
    allow you to search the `title` and `body` fields as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding search and filtering to the list view](img/1709_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As useful as a full-text search can be, for non-textual fields such as **Status**
    or **Created Timestamp**, it would be nice to have more powerful filtering capabilities.
    Again, Flask-Admin comes to the rescue, providing easy-to-use, easy-to-configure
    filtering options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how filters work by adding several to the `Entry` list. Once again,
    we will be modifying the `EntryModelView as follows`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `column_filters` attribute contains a mixture of the names of columns on
    the `Entry` model, as well as fields on *related* models such as from `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you access the `Entry` list view, you will now see a new drop-down menu
    labeled **Add Filter**. Experiment with the various data types. Note that, when
    you attempt to filter on the **Status** column, Flask-Admin automatically uses
    the `Public`, `Draft`, and `Deleted` labels. Also note that, when you filter on
    the **Created Timestamp**, Flask-Admin presents a nice date/time picker widget.
    In the following screenshot, I''ve set up a variety of filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding search and filtering to the list view](img/1709_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, the `Entry` list view is very functional. As an exercise, set
    up the `column_filters` and `column_searchable_list` attributes for the `User`
    `ModelView`.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Admin model forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will wrap up the discussion of model views by showing how to customize the
    form class. As you will recall, there were several limitations with the default
    forms provided by Flask-Admin. We will show in this section how to customize the
    display of the form fields used for creating and editing model instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal will be to remove the superfluous fields, and to use a more appropriate
    widget for the **Status** field, achieving what is seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing Admin model forms](img/1709_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to achieve this, we will first manually specify the list of fields
    that we wish to display on the form. This is done by specifying a `form_columns`
    attribute on the `EntryModelView class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we wish the `status` field to be a drop-down widget using human-readable
    labels for the various states. Since we already have defined the status choices,
    we will instruct Flask-Admin to override the `status` field with a WTForms `SelectField`,
    and pass in the list of valid choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By default, the user field will be displayed as a drop-down with simple type
    ahead. Imagine, though, if this list contained thousands of users! That would
    result in a very large query and a slow rendering time, due to all the `<option>`
    elements that would need to be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a form containing a foreign key is rendered to a very large table, Flask-Admin
    allows us to use Ajax to fetch the desired row. Add the following attribute to
    the `EntryModelView`, and now your users will be loaded efficiently using Ajax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This directive tells Flask-Admin that, when we are looking up the **Author**,
    it should allow us to search on the author''s name or e-mail. The following screenshot
    shows what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing Admin model forms](img/1709_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have a very nice looking `Entry` form.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the User form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because passwords are stored as hashes in the database, there is little value
    in displaying or editing them directly. On the `User` form, however, we will make
    it possible to enter a new password, replacing the old one. Like we did with the
    `status` field on the `Entry` form, we will specify a form-field override. Then,
    in the model change handler, we will update the user's password on-save.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following additions to the `UserModelView module`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows what the new `User` form looks like now. If you
    wish to change a user's password, simply enter the new one in the **New password**
    field.
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhancing the User form](img/1709_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generating slugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is still one aspect that we need to address. When creating new `Entry`,
    `User` or `Tag` objects, Flask-Admin will not correctly generate `slug` for them.
    This is due to the way Flask-Admin instantiates new model instances when saving.
    To remedy this, we will create some subclasses of `ModelView` that will ensure
    that `slug` is generated correctly for `Entry`, `User,` and `Tag` objects
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `admin.py` and, at the top of the module, add the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These changes instruct Flask-Admin that, whenever a model is changed, slug should
    be re-generated.
  prefs: []
  type: TYPE_NORMAL
- en: In order to start using this functionality, update the `EntryModelView` and
    `UserModelView` modules to extend the `SlugModelView class`. For the `Tag` model,
    it is sufficient to simply register it directly with the `SlugModelView` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, your code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These changes ensure that slugs are generated correctly, whether saving existing
    objects or creating new ones.
  prefs: []
  type: TYPE_NORMAL
- en: Managing static assets via the Admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask-Admin provides a convenient interface for managing static assets (or other
    files on disk) as an extension to the admin dashboard. Let's add a `FileAdmin`
    to our site that will allow us to upload or modify files in our application's
    `static` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `admin.py` and import the following module at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, below the various `ModelView` implementations, add the following highlighted
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Pulling up the admin in your browser, you should see a new tab labeled **Static
    Files**. Clicking this link will take you to a familiar file-browser, as seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing static assets via the Admin](img/1709_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you run into issues managing your files, make sure that you have the correct
    permissions set up for the `static` directory and its children.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the admin website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have noticed while testing the new admin website, it does not do
    any sort of authentication. In order to protect our admin site from anonymous
    users (or even certain logged-in users), we will add a new column to the `User`
    model to indicate that a user can access the admin website. Then we will use a
    hook provided by Flask-Admin to ensure that the requesting user has permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to add a new column to our `User` model. Add the `admin`
    column to the `User` model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will generate a schema migration using the Flask-Migrate extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add a method to the `User` model that will tell us if the given
    user is an admin. Add the following method to the `User` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This may seem silly, but it's good code-hygiene should you ever wish to change
    the semantics of how your app determines whether a user is an admin.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing on to the next section, you may want to modify the `UserModelView`
    class to include the `admin` column in `column_list`, `column_filters`, and `form_columns`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an authentication and authorization mixin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have created several views in our admin view, we need a reusable way
    of expressing our authentication logic. We will achieve this reuse through composition.
    You've seen composition already in the form of view decorators (`@login_required`)
    – decorators are just a way of composing multiple functions. Flask-Admin is a
    little different in that it uses Python classes to represent an individual view.
    Instead of function decorators, we will use a class-friendly method of composition
    called **mixins**.
  prefs: []
  type: TYPE_NORMAL
- en: A mixin is a class that provides a method override. In the case of Flask-Admin,
    the method we wish to override is the `is_accessible` method. Inside this method,
    we will check whether the current user is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to access the current user, we must import the special `g` object
    at the top of the `admin` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the import statements, add the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will be *mixing* it in with several other classes through Python''s
    multiple inheritances. Make the following changes to the `BaseModelView class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And also to the `BlogFileAdmin class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you attempt to access an admin view URL such as /admin/entry/ without meeting
    the `is_accessible` criteria, Flask-Admin will return an HTTP 403 Forbidden response
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an authentication and authorization mixin](img/1709_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have not made changes to the `Tag` admin model this is still accessible.
    We will leave it up to you to work out how to protect it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a custom index page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The landing page for our admin (`/admin/`) is very boring. In fact, it has no
    content at all besides a navigation bar. Flask-Admin allows us to specify a custom
    index view, which we will use to display a simple greeting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add a custom index view, we need to import several new helpers.
    Add the following highlighted imports to the top of the `admin` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`from flask import redirect` request provides the `@expose` decorator much
    like Flask itself uses `@route`. Since this view is the index, the URL we will
    be exposing is `/`. The following code will create a simple index view that renders
    a template. Note that we specify the index view as a parameter when initializing
    the `Admin` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'One final piece is missing: authentication. Since users will commonly access
    the admin by going directly to `/admin/`, it would be handy to redirect unauthenticated
    users to a login page. We can do that by checking, in the index view, whether
    the current user is authenticated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Flask-Admin templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flask-Admin provides a simple master template that you can extend to create
    a uniform look to your admin site. The Flask-Admin master template comprises the
    following blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Block Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `head_meta` | Page metadata in header |'
  prefs: []
  type: TYPE_TB
- en: '| `title` | Page title |'
  prefs: []
  type: TYPE_TB
- en: '| `head_css` | CSS links in header |'
  prefs: []
  type: TYPE_TB
- en: '| `head` | Arbitrary content in document header |'
  prefs: []
  type: TYPE_TB
- en: '| `page_body` | Page layout |'
  prefs: []
  type: TYPE_TB
- en: '| `brand` | Logo in the menu bar |'
  prefs: []
  type: TYPE_TB
- en: '| `main_menu` | Main menu |'
  prefs: []
  type: TYPE_TB
- en: '| `menu_links` | Navigation bar |'
  prefs: []
  type: TYPE_TB
- en: '| `access_control` | Section to the right of the menu that can be used to add
    login/logout buttons |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | Alerts and various messages |'
  prefs: []
  type: TYPE_TB
- en: '| `body` | Main content area |'
  prefs: []
  type: TYPE_TB
- en: '| `tail` | Empty area below content |'
  prefs: []
  type: TYPE_TB
- en: The `body` block will be of most interest to us for this example. In your application's
    `templates` directory, create a new sub-directory named `admin` containing a blank
    file named `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s customize the admin landing page to display the current date and time
    on the server. We will extend the `master` template provided by Flask-Admin, overriding
    just the body block. Create the `admin` directory in templates and add the following
    code to `templates/admin/index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot of our new landing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flask-Admin templates](img/1709_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is just an example to illustrate how simple it is to extend and customize
    your admin dashboard. Experiment with the various template blocks, and see if
    you can add a logout button to the navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: Reading more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask-Admin is a versatile, highly-configurable Flask extension. While we covered
    a number of the more commonly-used features of Flask-Admin, there are simply too
    many features to discuss in a single chapter. So, I strongly suggest that you
    visit the project's documentation if you would like to continue learning. The
    documentation can be found online at [https://flask-admin.readthedocs.org/](https://flask-admin.readthedocs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create an administrative dashboard for our
    app using the Flask-Admin extension. We learned how to expose our SQLAlchemy models
    as lists of editable objects, as well as how to customize the look and feel of
    the tables and the forms. We added a file-browser to assist in managing our app's
    static assets. We also integrated the admin with our authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about adding APIs to our application so that
    we can access it programmatically.
  prefs: []
  type: TYPE_NORMAL
