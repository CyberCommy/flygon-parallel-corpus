- en: Chapter 4. Let's Build a Side Scroller Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will build a very basic side scroller game using both ImpactJS
    and Box2D. Box2D is an open source C++ physics engine. With it, the forces of
    gravity and friction are simulated like you would see in a game of Angry Birds.
    Although not perfectly integrated, but given enough effort, Box2D can be used
    within an ImpactJS game. Just like the previous chapter, a game will be built
    from the ground up. The main difference will be in the use of a physics engine
    and the side scroller game setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Side scroller game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Box2D with ImpactJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a side scroller level with the ImpactJS Weltmeister
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing a playable character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding some enemies to the side scroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arming the player with bullets and bombs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the enemy smarter with artificial intelligence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating items which can be picked up by the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping score and adding points every time an enemy dies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting two different side scroller levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ending the game with a strong foe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The side scroller game setting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A side scroller videogame is a game which is viewed from a side angle and the
    player generally moves from left to right while playing through a level. The screen
    basically scrolls to the side, whether it is from the left to the right or any
    other direction, hence the name, side scroller. Well known side scroller games
    are 2D Mario, Sonic, Donkey Kong, the old Mega Man, Super Nintendo and Gameboy
    Metroid games, and the ancient but successful Double Dragon.
  prefs: []
  type: TYPE_NORMAL
- en: Most games of this type feature a long level through which the hero needs to
    find his way by battling or avoiding monsters and death traps. On reaching the
    end of the level, there is usually no way back except for replaying that particular
    level from the start. Metroid was a slight oddity in this respect, since it was
    one of the first side scrollers to feature an enormous world you could explore
    just like you would in a standard Role-playing game (RPG). Metroid set the stage
    for a new way of thinking about side scrollers; you needed to find your way in
    any possible direction through virtual miles of caves and you would occasionally
    find yourself back at the starting point. Castlevania is another example of a
    side scrolling adventure game, this time using a medieval setting.
  prefs: []
  type: TYPE_NORMAL
- en: '![The side scroller game setting](img/4568_4_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have taken a look at what a side scroller is, let's get to building
    one with ImpactJS.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the game for Box2D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can start in earnest, we need to make sure all files are correctly
    in position:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a copy from the original ImpactJS downloadable folder we prepared in [Chapter
    1](ch01.html "Chapter 1. Firing Up Your First Impact Game"), *Firing Up Your First
    Impact Game*. Alternatively, you can again download a fresh one and also put it
    in your XAMPP server's `htdocs` directory. Give your folder a name; let's be totally
    original and call it `chapter4`. Any other name will be fine too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the physics demo from the ImpactJS website and go to its `plugins`
    folder. Here you should find the `Box2D` plugin. Create your own `plugins` folder
    and drop the `Box2D` extension there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test if everything works so far by visiting `localhost/chapter4` in your browser.
    The **it works!** message should once again be waiting there for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, we will need to change some Box2D core files. Box2D is not a product
    of ImpactJS but was invented for C++ based games before a JavaScript equivalent
    was developed. This JavaScript version was then integrated with ImpactJS by Dominic
    Szablewski (creator of ImpactJS). However, there are some flaws, one of them being
    faulty collision detection. Therefore, we will need to swap one of the original
    files with an adapted one that takes care of this problem. Take the `game.js`
    and `collision.js` scripts from the downloadable files for the `chapter4` folder
    and place them in your local `Box2D` folder. The `collision.js` script is with
    thanks to Abraham Walters who supplied the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `chapter4` folder's media files to your local `media` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to make an adaption to the main script. Our game will no longer be an
    extension of the standard Impact game class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead it will be an extension of the modified Box2D version. So make sure
    to change the following piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We require the Box2D `game` file in order to work with this extension, so include
    it at the beginning of the `main.js` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in order to test whether everything is working fine, we will need to
    load in a level with a collision layer. This is because Box2D needs the collision
    layer to create its world environment and their boundaries. Without a level, you
    will come across an error, that looks like the following:![Preparing the game
    for Box2D](img/4568_4_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do this, copy the `testsetup.js` script from the `level` subfolder of the
    `chapter4` folder, and place it in your local `levels` folder. Add the level to
    your required files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Insert a `loadlevel()` function in the main script's `init()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Reload the game in your browser and you should see the **it works!** message.
    Now you have seen it, you can delete it from your code. It is inside the main
    script's `draw()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Great! We should now have everything ready to go. The first thing we will do
    is build a small level to have a playground of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Building a side scroller level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to build a level, we once again need to rely on the ImpactJS Weltmeister:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Weltmeister in your browser `localhost/chapter4/Weltmeister.html`.
    We don't have any entities to play around with, so all that we will add for now
    is some graphics and a collision layer. This collision layer is especially important
    since the Box2D extension code will look for it and lack of it will crash the
    game. Suffice to say Box2D for ImpactJS is still in its infancy and minor bugs
    like this are to be expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a layer and name it `collision`; the Weltmeister will automatically recognize
    it as a collision layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its tilesize to `8` and the layer dimensions to `100 x 75`. We now have
    an 800 x 600 pixel canvas to play with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now draw a box around the edges so we have a closed environment from which no
    entity can escape. This will be very important when gravity comes into play. Without
    a solid ground you will get some unintended results for sure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add a new layer and call it `background`. We will use a single picture as
    background for this level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `church.png` file from the `media` folder as tileset. Our picture
    is 800 x 600 pixels so it should fit exactly in the area we created with our collision
    layer. Set the tilesize to `100` and the layer dimensions to `8 x 6`. Paint the
    picture of the church on the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your level as `level1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Great, we now have a basic level of our own. It is pretty empty though and
    some extra obstacles would be nice. Just follow the next steps to add some obstacles:'
  prefs: []
  type: TYPE_NORMAL
- en: Add another layer called `platforms`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `tiles.png` file as tileset. They are simple in design but will do just
    fine as the building blocks for any platform you like to construct. Set the tilesize
    to `8` and dimensions to `100 x 75`, exactly like the collision layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn on the option **link with collision layer** before you start painting the
    platforms. This way, you don't need to trace the platforms with your collision
    layer afterwards. If you don't want every part of a platform to be solid, you
    can, of course, temporarily turn off the link, paint the tiles, and turn it back
    on; the link is not made retrospectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a few floating platforms to the level; follow your heart's desire on what
    they should look like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your level when you feel the stage is set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the level to the `require()` function of your `main.js` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that the level called `level1` is loaded at the beginning, instead
    of our `testsetup` level, by changing the `loadLevel()` function parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Building a side scroller level](img/4568_4_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is time to add a playable entity to the game so that we can discover the
    breathtaking level we have just created.
  prefs: []
  type: TYPE_NORMAL
- en: The playable character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are working with Box2D, we will not use the standard ImpactJS entity
    but the adapted version. Especially the way an entity moves in a Box2D world is
    what makes all the difference. In standard ImpactJS, this is the very straightforward
    process of moving your character image a few pixels in a certain direction. However,
    Box2D works with forces; so, in order to move, you need to overcome gravity and
    even air friction. But let''s start by setting up a basic entity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `player.js` in the `entities` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the basic Box2D entity code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the term `entity` is an extension of the Box2D entity and, as
    such, requires the Box2D entity plugin file. Once again, make sure the naming
    conventions are respected or your player entity will not show up in Weltmeister.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `'game.entities.player'` parameter to the `main.js` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you were to visit your Weltmeister after making these modifications, you
    would find the player in your entity's layer. He doesn't represent much yet though;
    currently it is nothing more than an invisible square over which you don't have
    any control. Time to change his invisibility by adding an animation sheet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the previous block of code, we gave the player a size and a name; but more
    importantly, we added graphics. The animation sheet contains just two images,
    one for the player standing idle and the second one for when the player flies.
    This is not much but it will suffice for a simple game. A side scroller game has
    a considerable advantage when it comes to its need for graphics. In theory, you
    only need two images to represent a character; that is, one for the character
    standing still and another one for the character in motion. For a top-down game
    you would need at least six images to accomplish the same thing. This is because,
    in addition to a side-view, you need an image of the back and the front of the
    character. Consequently, if you would add an animation for the player firing a
    bullet, this would result in an extra drawing for the side scroller but three
    for the top-down game. It's clear how a side scroller game is better, if you have
    only limited resources to get your graphics.
  prefs: []
  type: TYPE_NORMAL
- en: It's just great that we can now add our player to the game and he is actually
    visible, but we don't have any control over him yet.
  prefs: []
  type: TYPE_NORMAL
- en: Adding player control is done at two places, namely, the main and the player
    script. In the main script, add controls to the game's `init()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the player script, we need to change our `update()` function so the player
    can react to our input commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In Box2D the entity has an extra property, a body. In order to move the body,
    we need to exert a force upon it. This is exactly what happens when we use the
    body's `ApplyForce()` method. We apply a force in a certain direction, so we actually
    use a vector. The use of vectors is what Box2D is all about. As long as we keep
    the right, left, or fly button pressed, the force is applied. However, when released,
    the entity doesn't stop immediately. No further force is applied but it takes
    a certain amount of time for the effects of the applied force to wear out; this
    is a big difference from the velocity we used in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add the player to the level, make sure he is somewhere on top of a platform
    in the top-left corner. The top-left corner is what will be visible by default
    and we don''t have an adaptable viewport to follow our player around just yet.
    To be precise, he doesn''t really need a platform to stand on just yet, since
    we have no gravity in our world. Let''s do something about that. Add the gravity
    property to your game in the `main.js` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's take our player for a test-flight shall we?
  prefs: []
  type: TYPE_NORMAL
- en: '![The playable character](img/4568_4_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You might have noticed that even though he flies rather smoothly, any solid
    object our jetpack frog encounters will make him go into a spin. Probably you
    don''t actually want this to happen. This is especially annoying since he can
    end up with his head facing down, at which point his jetpack flame is facing upwards.
    Now with the jetpack flame facing upwards, it doesn''t make a lot of sense if
    activating the jetpack still results in an upwards thrust. Therefore, we need
    to do something about his stability. This can be done by fixing the body on the
    horizontal axis. Add the following code to the frog''s `update()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now the player's body is fixed at an angle of 0 degrees towards the x axis.
    Try changing it to 45; you now have a crazy frog, always flying with his body
    tilted to the right, even when facing to the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a flying and steady frog now. Just too bad we can''t see him once we
    move a bit too far to the right or gravity takes us to the bottom of the level.
    It''s definitely time to introduce a following camera. To do this we need to make
    a modification to our game''s `update()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The player is put in a local variable and its location is checked once per frame
    to update the screen's position. Because we subtract half of the viewport's size
    from the players position, our player is kept neatly in the center of the screen.
    Leaving out the subtraction will keep the player in the top-left corner of the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Save all the modifications and fly around the level you created; enjoy the peace
    and silence as much as you can because soon hostiles will stir up the place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly recap what we have covered about the Box2D entity and how we
    can make a playable character with it. A Box2D entity is different from an ImpactJS
    entity, such that Box2D makes use of vectors to move around. A vector is a combination
    of direction and force:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `player.js`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert the standard Box2D entity extension code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include the player entity in the main script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add animation to the player. Also make use of the `flip` property, which flips
    your image over a vertical axis and cuts the needed character graphics in half
    for a side scroller game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add player controls which grant the ability to move left, right, and upwards.
    Notice how force is applied on the body in order for it to move. Once the input
    button is released and no more force is applied, the entity will proceed on course
    and completely stop, once the force is totally dissipated or he hits a solid wall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce gravity as a property of the game. As gravity is a constant downward
    force, it will drag everything down to the first solid object it encounters, unless
    a counter-force is provided. For our flying frog, his jetpack is his counter-force
    against gravity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our frog doesn't know how to fly a steady course just yet. Fix him to the horizontal
    axis so he doesn't go spinning every time he hits a solid object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we need a camera to keep track of where we are going. Incorporate the
    automatically following camera in the game's `update()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a minor foe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need some opposition, something we can shoot out of the sky once we have
    the weapons to do so. Therefore, let''s introduce some more frogs! Hostile ones
    this time:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and save it as `enemy.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the following code into the file. It is the minimum code necessary to
    get a representation of our enemy in the Weltmeister. As such, it already includes
    the animation sheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Require the enemy entity in our `main.js` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Add an enemy to the level with the Weltmeister.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since our enemy is currently pretty defenseless, we could just knock him off
    a platform as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a minor foe](img/4568_4_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In normal ImpactJS code, we would have to set collision variables for this to
    happen, otherwise, the player and the enemy frog would just go straight through
    each other. In Box2D, this is not necessary as collision is automatically assumed
    and a force is applied on every movable object we hit with our flying frog.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have gravity working, a great alternative for placing our enemies at
    a certain location is spawning them in at the top of the level. Add the `spawnEntity()`
    function in the game's `init()` function. An enemy will spawn there and gravity
    will drag it down to the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the `spawnEntity()` function is used after the level loads or an error
    occurs. Once the enemy has intelligence of its own, spawning enemies at the top
    of the level will make more sense. They will drop down, either to the very bottom
    or until they reach a platform, where they will wait for the player and attack
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We will turn our red frog into a really annoying creature once we provide him
    with some basic artificial intelligence. However, let's first prepare ourselves
    by adding some weapons to the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s briefly recap how we created our enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `enemy.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert the standard Box2D entity extension, attach an animation sheet, and add
    animation sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include the enemy entity in the main script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an enemy to the level with the Weltmeister and the `spawnentity()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing formidable weapons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Weapons are great, especially if they are subjected to gravity or if they can
    apply some force to other entities. We will have a look at two types of weapons
    here, namely, the projectile and the bomb.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting a projectile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The projectile will be our main weapon against the rival frogs, so let''s start
    by setting up the basics:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `projectile.js` in the `entities`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the basic Box2D entity code with animation sheet and sequences as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Apart from a name, size, and the necessary elements to perform the animation,
    we have already included a property called `lifetime`. Every projectile starts
    with a `lifetime` of `60`. We will make this drop and kill off the bullet when
    it reaches `0`. This way we don't get an overload of entities in a single game.
    Every entity needs its own calculations and having too many of them on screen
    at once might significantly drop the game's performance. Keeping track of this
    performance can be done using the ImpactJS debugger, which can be turned on by
    including the `'impact.debug.debug'` command, in the main script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `game.entities.projectile` script to the `main.js` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now add projectiles to the game by using Weltmeister if we want. However,
    adding them manually is not of much use to us. Let's adapt the player's code instead
    so our frog can spawn the projectiles. First, bind the `'shoot'` state to a key
    in the main script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Then add the following code to the player's `update()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Spawning the projectile needs to be done at a certain location and it has to
    point in a specific direction, either left or right. We arbitrarily set the y
    coordinate of the spawnpoint as `6` pixels lower than our player's position; we
    can make this 10, 20, or 200 pixels as well. Though, in the case of the last option,
    it would look as if the bullet was spawned way below the player, which would be
    rather unusual. However, let's not forget that the player's position is always
    at the top-left corner of its image. Given that the height of our frog is 24 pixels,
    it will appear as if the bullet is spawned from the mouth, which is pretty cool
    for a frog. The x coordinate is another matter. If the frog is facing left, we
    don't adjust the spawn coordinate; if he's facing right, we adjust it by 6 pixels.
    The information about whether the player is flipped is not only used to adjust
    the spawn coordinate. It is also transferred to the projectile itself as an optional
    input parameter. Here it will be used to determine what side it should face and
    fly. While firing the bullet you might notice the frog being kicked back a little,
    not unlike the recoil of a gun. This is because the frog initially occupies a
    space the bullet comes to occupy, when spawned. If you want to avoid this cool
    effect, all you need to do is spawn the bullet a bit farther away from the frog.
    If you were to load the game at this point, you would notice your bullet spawns
    but doesn't fly away. That is because we didn't tell the bullet to do so whenever
    it comes into existence.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the following two lines of code to the projectile's `init()` function
    will rectify this situation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Upon spawning the projectile we now apply an impulse instead of a force. There
    is a significant difference between the `ApplyImpulse()` and `ApplyForce()` functions.
    While the `ApplyForce()` function applies a constant force on the body, the `ApplyImpulse()`
    function only applies it once, but abruptly. You could compare it to pushing a
    rock versus running up to it and slamming into it with your full force and all
    the momentum you gathered. A bullet in real life works the same way as we try
    to simulate it here; it is flung away by a small explosion and never pushed again
    thereafter. The local variable, `var.velocity`, is there to adapt the bullet's
    direction in the same way the animation depends on the value of the `settings.flip`
    parameter. If the value of the `flip` property is false, the bullet will be facing
    right and flying to the right. If the value of the `flip` property is true, the
    animation is flipped, making it face left. Because the velocity then takes a negative
    number, the bullet also flies to the left.
  prefs: []
  type: TYPE_NORMAL
- en: We could still adapt our impulse on the y axis which is currently set at `0`.
    Putting a negative number will make our frog shoot upwards like an anti-air gun.
    A positive number will make him shoot downwards like a bomber. Try playing around
    with this to see the effects.
  prefs: []
  type: TYPE_NORMAL
- en: Our projectiles are still lingering around, cluttering the screen, because we
    haven't put our `lifetime` property to good use yet.
  prefs: []
  type: TYPE_NORMAL
- en: Let's modify the `update()` function in order to limit the lifespan of our bullets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Every time the game goes through the update loop, which is once per frame, the
    remaining lifetime of the projectile is shortened by 1\. Given a total lifetime
    value of 60 in a 60 frames per second game, the bullet has 1 second to live after
    being spawned.
  prefs: []
  type: TYPE_NORMAL
- en: We can shoot at our enemies with it and actually push them away with the force
    of the bullet, but we don't really damage them yet. For this to happen we need
    to check if we hit an enemy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding this modified `check()` function, which will make the projectile deal
    damage before killing itself, is not enough. Even though collision is automatically
    handled by Box2D, the parameters necessary for a `check()` function to work are
    not. We need to do a few more things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tell the enemy it is a type B entity by adding the `TYPE` property as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Make the projectile check for collision with type B entities using the `checkAgainst`
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now save and reload the game. You can now kill those nasty red frogs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try making your player a type B entity. Your bullets will now kill you. This
    is because we made them spawn in a space already occupied by our frog. As we have
    seen before, this is also the reason why we have this recoil effect upon firing
    a bullet. However, this time it's more than recoil; it can actually kill the player.
    So we better not make our player a type B entity or we should spawn our bullet
    a bit farther away and lose the recoil effect. It's great to have something to
    defend ourselves with, even if the other frogs don't pose much of a threat just
    yet. Before bringing them to life, we are shortly going to have a look at something
    more explosive, a bomb.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on to the bomb, let''s again have a quick look at how we introduced
    our main weapon, the bullet:'
  prefs: []
  type: TYPE_NORMAL
- en: We need guns, lots of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `projectile.js`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert the standard Box2D entity extension, attach an animation sheet, and add
    animation sequences. Also add a `lifetime` property, which will keep track of
    how much longer the bullet should stay in the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include the projectile entity in the main script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a key bind to the shoot input state in the main script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make our flying frog spawn a projectile when the player clicks on the shoot
    button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an impulse to the bullet so it can actually fly instead of just dropping
    to the ground.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check how long the bullet is in the air and kill it off if it exceeds its preset
    lifespan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let the bullet check for enemies. If it encounters an enemy, it should deal
    damage and kill itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try making the bullet kill the player but don't keep it that way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an actual bomb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basics for making a bomb are the same as for the projectile, indeed, they
    are the same as for creating any entity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `bomb.js` in the `entities` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the basic Box2D entity code with the animation sheet and sequences as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This time we already gave our bomb a type and a type to check against for inflicting
    damage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the `game.entities.bomb` parameter as a required entity into the `main.js`
    script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a bomb we can put anywhere in the level we want to. We can add some
    bombs close to the ceiling of our level so they would fall down at level load.
    That would be great, given there would be an actual explosion. We are going to
    introduce that explosion as a separate method that only our bomb can use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `init()`, `update()`, and `check()` methods, we now insert the
    `explosion()` method into the bomb entity so it will be able to use it henceforth.
    The `explosion()` method takes in five parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimum blast-zone**: If an entity is closer than this distance, he will
    not be hit. This doesn''t make a lot of sense for bombs, except that it allows
    you to use several blasts in one bomb. This in turn makes it possible to have
    higher damage when the target is closer to the bomb and lower damage when he is
    farther away.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Maximum blast-zone**: Everything farther away than the maximum blast-zone
    will not be affected by the explosion.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Blast damage**: This is the damage an entity will receive if it is within
    the blast-zone.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Blastforcex**: This is the impulse on the x axis that will be applied to
    the affected entity. It will decide how far the target will fly to the right or
    left.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Blastforcey**: This is the impulse on the y axis that will be applied to
    the affected entity. It would determine how high the target will fly. Obviously,
    if the target is below the bomb when it explodes, it will push the target downwards,
    not upwards.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `explosion()` method works in the following manner. All entities are copied
    to a local variable. The entities are then checked one after the other to see
    what their distance from the bomb is. The distance is calculated as Euclidean
    distance here. While calculating the Euclidean or ordinary distance, you apply
    the Pythagorean formula. This formula states that, the length of any side of a
    triangle with a 90 degree angle can be calculated if the length of the other two
    sides is known. The formula is *a² + b² = c²*, with *c* being the longest side
    of the triangle. Depending on whether the hapless target is situated to the right
    or left, above or below the bomb, the direction of the force is adjusted. Finally,
    the function checks if the distance is within the limits of the blast-zone. If
    this is the case, a damage and an impulse are applied on the target. At this point
    either the entity dies or goes flying through the air; either way it's not good
    news.
  prefs: []
  type: TYPE_NORMAL
- en: Simply adding this `explosion()` method will do no good until we actually use
    it. Therefore, we need to modify our `update()` method so we can blow up our bomb
    at the end of its lifespan.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The lifespan part works exactly like it did in the projectile. However, in this
    case we don't merely call the `kill()` function, we use our newly developed explosion
    twice. We could just call the function once and put the blast-range value between
    0 and 200\. As mentioned earlier, the advantage we have now is the division between
    high damage and pressure close to the bomb, and low damage and pressure farther
    away. Technically, we can use as many explosions as we like; each one of them
    requires calculation time. Though, it's up to you on how much division you want.
  prefs: []
  type: TYPE_NORMAL
- en: Before you actually get to testing this explosion in your game, make sure to
    attribute health to all your entities. Whether they will survive the damage of
    the blast or not will depend on whether you have given them enough health. Since
    the default value is set at 10, they will not fly away, but die instantly if the
    previous numbers are used. So let's give our player and enemies a health value
    of 100 by adding this property before their respective `init()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As a final touch we can make the bomb explode when it comes into contact with
    one of our hostile frogs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We already made sure the bomb checks for contact with entities of type B by
    setting the `checkAgainst` property. The direct damage of getting this piece of
    metal on the face is set at `30`. This is followed by the explosion itself, which
    will deal damage worth 70 points because the enemy is so close. The second blast
    wave affects everything farther away before the bomb finally kills itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a bomb that can be put anywhere in the level and will do just fine.
    However, it would be even better if our player could spawn one himself. In the
    following steps, we simply repeat what we did with the projectile to make the
    player spawn a bomb by himself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign a keyboard button to your bomb input state as shown in the following
    line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the player''s `update()` function so the player can now spawn bombs
    with the help of the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The spawn coordinates defined here are different from what we did with the projectile.
    The `y` coordinate is very important; it is set at `25` because our flying frog
    has a height of `24` pixels. This way the bomb is always spawned just beneath
    the flying frog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following line of code to the bomb's `init()` function so it takes the
    `flip` parameter to know which side to face when spawned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Save, reload, and bomb the hell out of those red frogs! Watch out though, bombs
    can kill you too.![Building an actual bomb](img/4568_4_6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The bomb is our greatest weapon; let''s have a quick recap on how we built
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `bomb.js`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert the standard Box2D entity extension, attach an animation sheet, and add
    animation sequences. Add a lifespan property that will keep track of how much
    time is left until the bomb explodes, if not detonated prematurely by touching
    an enemy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include the bomb entity in the main script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a bomb to the level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce the `explosion()`method; it is a custom function which simulates the
    damage and force effects of an explosion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the `update()` function so it will make the bomb explode when its time
    is up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `check()` function to detect collision with an enemy and detonate immediately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign a keyboard shortcut to fire bombs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjust the player's `update()` function so a bomb is spawned when the player
    commands it to do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the bomb flip to the direction the player is looking at.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mess around and have fun blowing frogs to bits!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to make our red frogs a bit smarter so they stand at least a tiny
    chance against our newly developed weapons arsenal. In [Chapter 3](ch03.html "Chapter 3. Let's
    Build a Role Playing Game"), *Let's Build a Role Playing Game*, we did this completely
    by the book, by separating decisions from behavior. We made a separate Artificial
    Intelligence (AI) file for decision making, and—as always—the actual behavior
    is in the entity's `update()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This time around, we will keep it very simple and put all AI directly in the
    enemy's `update()` method. This will demonstrate that even a simple AI can seem
    to act pretty smart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our enemy''s `update()` function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Inserting this function into your enemy entity will make him try to catch the
    player. But how does it work? First, the player entity is saved in the function's
    local variable called `player`. Both the horizontal distance and the vertical
    distance between the enemy and the player are calculated. The `sign` variable
    is used to determine whether the frog should fly to the left or the right. He
    will always fly upwards; if he needs to come down because the player is below
    him, he will just let gravity do its work. While flying, the fly animation is
    active, otherwise the idle animation is used, even while moving horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: The frog's body is fixed to the x axis to prevent him from spinning, as is the
    case with the player. Finally the animation is flipped to the left or right, depending
    on where the player is relative to the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a frog that will follow us around if we are close enough to him.
    Now we need him to do some damage to the player:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the type of the enemy and the type it needs to check for are filled
    out as B and A respectively. Also introduce a new enemy property called `cooldowncounter`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `cooldowncounter` property will keep track of how many frames have passed
    since the last time the frog was able to deal damage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `cooldowncounter` property must count, therefore add it to the `update()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Extend the `check()` function so it checks whether enough frames have passed
    since the last attack and allow the frog to attack if this is the case, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The frog will now be able to use its nasty melee attacks upon the player. The
    attack, whatever done by the frogs at a close range, will lower the player's health
    by a value of 10 every time it hits the player. The player will certainly need
    to avoid these nasty creatures now if he doesn't want to lose health quickly.
    We will need to give the player something extra that allows him to survive this
    carnage.
  prefs: []
  type: TYPE_NORMAL
- en: 'AI is what makes the enemy worth fighting against. Unlike what we mentioned
    in [Chapter 3](ch03.html "Chapter 3. Let''s Build a Role Playing Game"), *Let''s
    build a Role Playing Game*, it does not always need to become a complicated matter
    though. Let''s have a quick look at how we implemented AI for the side scroller:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the `update()` function so the enemy can now fly towards the player.
    This new `update()` function is the AI of the enemy frog. As opposed to [Chapter
    3](ch03.html "Chapter 3. Let's Build a Role Playing Game"), *Let's Build a Role
    Playing Game*, both decision and behavior are wrapped in a single piece of code
    this time around.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce a cool down counter that keeps track of the number of frames since
    the last attack happened. Also make sure the enemy entity is of type B and checks
    whether it touches type A entities. The player should be a type A entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the `cooldown` property add a value of 1 for every frame that passes, by
    adding it to the modified `update()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporate the attack in the `check()` function so the frog becomes a force
    to be reckoned with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pickup items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our tiny flying frog can now officially be killed by those nasty red frogs.
    This is not good news for him and it is up to us to provide a way to replenish
    the lost health. This is done by the use of pickup items, that is, entities which
    will disappear upon touching the player, but grant beneficial effects in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Before we add an actual pickup item, which will come in the form of a health
    replenishing crate, let's first add a normal crate to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a normal crate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our crate will function as a prototype to all types of crates we could invent.
    To create the crate, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and save it as `crate.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the crate code to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This code is really straightforward since the crate is nothing but a lifeless
    object. A tough lifeless object though, since it has a health value of `2000`.
    By giving the crate so much health, it is able to survive multiple bomb explosions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file and add some to your game with the Weltmeister. Certainly try
    stacking a few of them before unleashing an explosion in their midst.![Adding
    a normal crate](img/4568_4_8.jpg)![Adding a normal crate](img/4568_4_9.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have the standard crate; making a healing crate is only a few steps away,
    since we will build it upon our normal crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before taking a look at our healing crate, let''s quickly see how we made the
    normal crate:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file and save it as `crate.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a standard Box2D entity code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save and add some crates to the game using the Weltmeister
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a healing crate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have our basic prototype crate, we only need to build upon it in order
    to create the health crate. To build the health crate perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and save it as `crate.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `healthcrate` specific code to it. The health crate is an extension
    of the normal crate, not a Box2D entity; therefore, we only need to point out
    where the health crate differs from the normal one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It has another name and animation sheet. In addition it will heal the player
    and destroy itself after healing the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the crate to the main script using the following code, so your game knows
    it's there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Save and add a crate to the game to check out its effects.![Implementing a healing
    crate](img/4568_4_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This crate heals the player by providing him a **health** value of **100**,
    as shown in the following screenshot. Thus, the player will always end up with
    more health than he started the game with. This is just a choice; you could always
    change this by implementing a health cap so as to make sure healing can't make
    the player stronger than he initially was.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a healing crate](img/4568_4_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remember you can always open Firefox with the Firebug add-on and look for the
    player properties in **Document Object Model** (**DOM**). Before picking up the
    crate, our player had a health value of 100 and it rose to a value of 200 after
    he picked up the crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The healing crate is somewhat more sophisticated than the normal one. Let''s
    once again have a look at the steps we took to make a healing crate:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file and save it as `healthcrate.js`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend the previously built crate instead of a Box2D entity. Only add the parameters
    on which the health crate will differ from the original one. This includes a `check()`
    function to see if it has been touched by the player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save and add a crate to the game using the Weltmeister.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check in the DOM if your health crate has actually increased your player's health.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Keeping track of a score within the game is a rather straightforward thing.
    In order to implement a system where a score is kept and increased every time
    an enemy is killed, we need three things:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a variable that keeps track and is within the boundaries of the game
    itself, but can be regarded as some sort of overhead variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is really important because, as we will see in [Chapter 5](ch05.html "Chapter 5. Adding
    Some Advanced Features to Your Game"), *Adding Some Advanced Features to Your
    Game*, the start and end screens are in effect different games that are being
    loaded. When a new game is loaded into memory, the old one is discarded and so
    are all of its variables. That is why we need a variable that exists outside of
    the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function is used to increase the score by a certain number of points. This
    one is allowed to be a method of the game itself. Just insert this in the main
    script underneath the other main functions of the `MyGame` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We overwrite the enemy `kill()` function as shown, so the frog does not only
    die but also supplies us with some extra points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: From now on, every time a red frog dies, we get an extra 100 points and these
    are kept safely in a variable that is not erased as long as we do not refresh
    the page. We can then later on use this variable to show up at the end of a game
    to provide our gamer with some feedback of how well or poorly he did.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping the score is a very important component for almost any game. It is
    a way to challenge the player to replay your game and do better at it. It is not
    too difficult to implement either; let''s see what we did:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a variable outside of the current game and call the variable `score`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a function to the game that can directly manipulate our `score` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the function when an enemy dies, to add points to the overall player score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning from one level to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to have a map transitioning, you will first need a second level. You
    can make one yourself or copy the one from the downloadable files for this chapter.
    You will also need the trigger end `levelchange` entity. Copy both entities to
    the `entities` folder, and the level called `level 2` to the `levels` folder on
    your local computer. Alternatively, you can devise a second level yourself and
    use the trigger entity, which comes with your Impact license. The trigger entity
    is not part of the actual engine; it can be found in downloadable examples on
    the ImpactJS website.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `levelchange` entity, we will make the following code change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might notice, it is different from the one we used in the RPG, in two
    main aspects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not take into account the use of spawnpoints. Using actual spawnpoints
    is not really necessary for most side scrollers. This is because once a level
    is completed, you can only go back to it by playing it all over again. Therefore,
    we do not need multiple spawnpoints per level, only one spawnpoint is required.
    If we only need one spawnpoint, however, it is way easier not to use the Void
    entity as we did in the previous chapters. Instead, we simply put the player entity
    on a certain location within the level and the level will thus always start there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second change to the `levelchange` entity is the backup we make of the player
    entity. Before loading the level, we copy the player entity to a local variable
    called `oldplayer`. Once the game is loaded, a new playable character is created;
    this is the one we manually added to the level, `level 2` in the Weltmeister.
    We then assign this new player to another local variable called `newplayer`. By
    overwriting `newplayer` with `oldplayer`, we can keep playing with the old frog.
    This can be important if the player is allowed to keep the previously acquired
    supplementary weapons or health.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All we need to do now is correctly set up a `trigger` and a `levelchange` entity
    in `level 1` and we have a decent level transitioning. This should be done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Once the `trigger` and `levelchange` entities are present in the `entities`
    folder, add both to the main script. Also add `level 2` to the script once you
    have created or copied it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Put both the `trigger` and the `levelchange` entities in `level 1` using the
    Weltmeister.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `name` property with the value `tolevel2` and a `level` property with
    the value `level2` to the `levelchange` entity using the Weltmeister.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a property called `target.1` with a value of `tolevel2` to the `trigger`
    entity using the Weltmeister.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double check you have a player entity present in your second level and this
    level bears the name `level2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save all changes you made and reload the game for a test run. Certainly try
    collecting a health crate before using the level transition. Once you arrive at
    `level2`, your health increase should persist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied `level2` from the downloadable files, notice how the stars move
    slower than the spaceships, which in turn move slower than some other spaceships.
    This is because of the distances of these three layers. If you open the Weltmeister,
    you can see that the star layer has a distance value of **5**, the closest star
    ships have a value of **2**, and the other ships have a value of **3**. Working
    with distances can give really nice effects for parallax games; use them wisely.
  prefs: []
  type: TYPE_NORMAL
- en: '![Transitioning from one level to another](img/4568_4_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Adding a level transitioning can be done in a relatively easier manner, if
    it goes one way only. Let''s recap how we did this:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `trigger` and `levelchange` entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build or copy a second level called `level2`. Make sure to add a player entity
    to the level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include the new level and both the `trigger` and `levelchange` entities in the
    main script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `trigger` and `levelchange` entity to `level 1`, connect them and make
    sure the `levelchange` entity points to `level2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try using the `distance` property of a layer while designing your levels. This
    can give you beautiful results in a side scroller game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final battle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every good game ends with a challenging final battle where good defeats evil,
    or vice versa, your call.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a challenging fight, let's create a separate `boss` entity,
    which is more powerful than our other frogs.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and save it as `boss.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The boss will be an extension to our normal enemy, so let's first define the
    characteristics on which he will differ from the red frogs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: His name is different; but more importantly, he will have more health and is
    much bigger than the other frogs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the boss to your main script using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Save all changes and put the boss in one of your levels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now have a bigger enemy indeed, with more health, who basically does the
    same thing as the smaller ones. This doesn''t really make for an interesting boss
    fight, so let''s give him the ability to fire bullets like the player. We need
    a separate bullet entity, since our basic projectile can only damage type B entities
    and our player is of type A; also we might want it to look a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and save it as `bossbullet.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This bullet will be a direct extension of the normal bullet except for the
    type check and the way it looks. Write the following code to create the new bullet
    entity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We need one last modification, shown in the following code, to make the boss
    fire his own bullets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The boss entity''s `update()` function differs from the others in three main
    ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since he is a bigger creature, he uses more force to move around.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We prefer him to deal damage with his bullets so he doesn't try to come into
    melee range. When he is within a distance of 1000 pixels on the x axis, he will
    approach. Once at a distance of 100 pixels, he doesn't try to come any closer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last but not least, in every frame there is a 1 out of 10 chance of him firing
    a bullet. This should on an average result in 6 bullets every second, which is
    quite a barrage. If you are very unlucky, he can fire up to 60 bullets your way,
    in a single second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pretty nice effect from the Box2D collision is that as a player, your own
    bullets can deflect those of the boss. However, this will not always be the case.
    Collision detection in Box2D is not perfect yet and sometimes two entities can
    go straight through each other. This is also why you should make sure your outer
    boundary collision wall is pretty thick. Otherwise, you will have entities flying
    outside your level, possibly resulting in game crashes.
  prefs: []
  type: TYPE_NORMAL
- en: '![The final battle](img/4568_4_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Killing the boss character should end the game and give the player a nice Victory
    screen. Dying should end in a Game Over screen instead of a Game Crash screen.
    These and many other things will be addressed in [Chapter 5](ch05.html "Chapter 5. Adding
    Some Advanced Features to Your Game"), *Adding Some Advanced Features to Your
    Game*, where we take a deeper look at some more advanced features with which you
    can enhance your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game is almost at an end, the player expects a climax. This can be
    given to him in the form of an epic battle against a worthy foe. That is exactly
    what we did earlier in this chapter. The boss character is the player''s ultimate
    enemy and his ticket to victory:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and save it as `boss.js`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the boss character's basics as an extension of the enemy entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce the boss' bullet, that is, the projectile used by the boss to kill
    the player. This is an extension of the projectile used by the player himself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrade the boss so he can make use of his lethal new bullet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a boss to your game and check out if you are able to defeat him.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned about the side scroller game and took a look at some
    famous examples. We built our own side scroller using Box2D, that is, a physics
    engine integrated with ImpactJS.
  prefs: []
  type: TYPE_NORMAL
- en: First, we built a level with the Weltmeister, so we could populate them with
    our newly created enemy and playable characters. Lifeless crates were added to
    fully display the physics of Box2D. In order to arm the player against the violent
    enemies we introduced pickup items and two interesting weapons, that is, the bullet
    and the bomb.
  prefs: []
  type: TYPE_NORMAL
- en: Our enemy was given life once we added minor AI. As a final challenge for the
    player, the formidable boss was brought to the scene. This enemy is stronger than
    regular enemies and capable of firing bullets like the player. For defeating every
    enemy, the player is awarded with extra points to his total score.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will explore some new concepts like working with data
    and go deeper into some of the features we have already touched on, such as debugging
    AI.
  prefs: []
  type: TYPE_NORMAL
