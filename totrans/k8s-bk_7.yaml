- en: '7: Other important Kubernetes stuff'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a lot more to Kubernetes than can fit in a book. If we tried, we’d fill
    volumes!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll briefly mention the following areas of Kubernetes that
    will take you to the next level:'
  prefs: []
  type: TYPE_NORMAL
- en: DaemonSets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: StatefulSets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CronJobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoscaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of these will become their own chapters in future editions of the book.
    For now, let’s have a taste of each.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously there’s even more than this, but like we already said - it could fill
    volumes!
  prefs: []
  type: TYPE_NORMAL
- en: DaemonSets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DaemonSets are a resource in the `apps` API group, and they manage Pods. Their
    use-case is when you need a replica of a particular Pod running on every node
    in the cluster. Some examples include; *monitoring Pods* and *logging Pods* that
    you need to run on every node in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: As you’d expect, it implements a controller and a watch loop. This means that
    you can dynamically add and remove nodes from the cluster, and the DaemonSet will
    ensure you always have one Pod replica on each node.
  prefs: []
  type: TYPE_NORMAL
- en: The following command shows two DaemonSets in the `kube-system` namespace that
    exist on a newly installed 3-node cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The output is trimmed so that it fits the page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice that *desired state* for each DaemonSet is 3 replicas. You do not need
    to specify this in the DaemonSet YAML file as it is automatically implied based
    on the number of nodes in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: DaemonSets are stable in the `apps/v1` API group and can be managed with the
    usual `kubectl get` , and `kubectl describe` commands etc. If you already understand
    Pods and Deployments, you will find DaemonSets really simple.
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: StatefulSets are a stable resource in the `apps/v1` API group. Their use-case
    is stateful Pods - i.e. Pods that are not intended to be ephemeral.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful components of a microservices application are usually the hardest to
    implement, and platforms like Kubernetes have been somewhat slow to implement
    features to handle them. StatefulSets are step towards improving this.
  prefs: []
  type: TYPE_NORMAL
- en: It’s useful to think of them as being like Deployments. For example, we define
    them in a YAML file that we `POST` to the API server as desired state. A controller
    implements the work on the cluster and a background watch loop makes sure current
    state matches desired state. However, there is one major difference between a
    StatefulSet and a Deployment - **Pods deployed via StatefulSet are not interchangeable**
    . This means that when a Pod managed by a StatefulSet fails, it is replaced by
    another Pod with the same ID and IP etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Potential use-cases for StatefulSets are any services in your application that
    maintain state. These can include:'
  prefs: []
  type: TYPE_NORMAL
- en: Pods that require access to specific named volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pods that require a persistent network identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where Pods must come online in a particular order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A StatefulSet guarantees all of these will be maintained across Pod failures
    and subsequent rescheduling operations.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the more complex nature of stateful applications, StatefulSets can be
    complex to configure.
  prefs: []
  type: TYPE_NORMAL
- en: Jobs and CronJobs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jobs, a.k.a. batch jobs, are stable resources in the `batch/v1` API group. They
    are useful when you need to run a specific number of a particular Pod, and you
    need guarantees that they’ll all successfully complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of subtleties worth noting:'
  prefs: []
  type: TYPE_NORMAL
- en: Jobs don’t have the concept of desired state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pods that are part of a Job are short-lived
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These two concepts separate *Jobs* from other objects like Deployments, DaemonSets,
    and StatefulSets. Whereas those objects keep a specified number of a certain Pod
    running indefinitely, *Jobs* manage a specified number of a certain Pod and make
    sure they complete and exit successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The *Job* object implements the usual controller and watch loop. If a Pod that
    the *Job* object spawns fails, the *Job* will create another in its place. The
    *Job* itself does not complete until the required number of Pods successfully
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: Use-cases include typical batch-type workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, *Jobs* can be useful even if you only need to run a single Pod
    through to completion. Basically, any time you need to run one or more short-lived
    Pods, and you need to guarantee they complete successfully, the *Job* object is
    your friend!
  prefs: []
  type: TYPE_NORMAL
- en: '*CronJobs* are just *Jobs* that run against a time-based schedule.'
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Deployments chapter showed us how to manually scale the number of Pod replicas.
    However, manually scaling a set of Pods does not scale (excuse the pun). As an
    example, if demand on your application spikes at 4:20 a.m. it’s far from ideal
    if you need to page an operator who will then log-on to the cluster and manually
    increase the number of replicas. The same applies if you need to scale the number
    of nodes to your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: With these challenges in mind, Kubernetes offers several auto-scaling technologies.
  prefs: []
  type: TYPE_NORMAL
- en: The **Horizontal Pod Autoscaler (HPA)** dynamically increases and decreases
    the number of *Pods* in a Deployment based on demand.
  prefs: []
  type: TYPE_NORMAL
- en: The **Cluster Autoscaler (CA)** dynamically increases and decreases the number
    of *nodes* in your cluster based on demand.
  prefs: []
  type: TYPE_NORMAL
- en: The **Vertical Pod Autoscaler (VPA)** attempts to right-size your Pods. Currently
    an *alpha* product.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal Pod Autoscaler (HPA)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: HPA’s are stable resources in the `autoscaling/v1` API group, and their job
    is to scale the number of replicas in a Deployment based on observed CPU metrics.
    At the time of writing, the `v2` API is being worked on, and will allow scaling
    based on more than just CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'It works like this… You define a Deployment that makes use of Pod resource
    requests - where each container in the Pod requests an amount of CPU. You deploy
    this to the cluster. You also create an HPA object that targets that Deployment
    and has a rule that says something like: *if any Pod in this Deployment uses more
    than 60% of its requested CPU, spin up an additional Pod.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the Deployment and HPA are deployed to the cluster, scaling operations
    become automatic.
  prefs: []
  type: TYPE_NORMAL
- en: One thing worth noting, is that HPAs update the `.spec.replicas` field of the
    targeted Deployment. While this update is recorded against the Deployment object
    in the cluster store, it can lead to situations where your copy of the Deployment
    YAML file in your external version control system gets out of sync with what is
    currently observed on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster Autoscaler (CA)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CAs are all about right-sizing your Kubernetes cluster. At a high-level, they
    increase and decrease the number of nodes in your cluster based on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Getting under the covers a little… CAs periodically check Kubernetes for any
    Pods that are in the *pending* state due to lack of node resources. If it finds
    any, it adds nodes to the cluster so that the pending Pod(s) can be scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: This requires integrations with your cluster’s underlying infrastructure platform
    - a public API that allows Kubernetes to add and remove nodes. The major cloud
    platforms implement Cluster Autoscaler with varying levels of support. Check your
    cloud provider documentation for the latest support info.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control (RBAC)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes implements a least-privilege RBAC subsystem. When enabled, it locks
    down a cluster and allows you to grant permissions based on specific users and
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model is based on three major components:'
  prefs: []
  type: TYPE_NORMAL
- en: Subjects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Subjects* are users and groups, and these must be managed outside of Kubernetes.
    *Operations* are what the subject is allowed to do (create, list, delete etc.).
    *Resources* are objects on the cluster such as Pods. Put the three together, and
    you have an RBAC rule. For example, **Abi** (subject) is allowed to **create**
    (operation) **Pods** (resource).'
  prefs: []
  type: TYPE_NORMAL
- en: RBAC has been stable (`v1` ) since Kubernetes 1.8 and leverages two objects
    that are defined in the `authorization.rbac.k8s.io` API group. The two objects
    are `Roles` and `RoleBindings` . The `Role` is where you define the resource and
    the operation that you want to allow, and the `RoleBinding` connects it with a
    subject.
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Storage is a vital component of most production applications. Fortunately, Kubernetes
    has a comprehensive storage subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: The high-level architecture of the model comprises storage providers, a plug-in
    interface, and the Kubernetes persistent volume subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: The storage providers are responsible for creating the actual storage, and can
    be things like enterprise-class storage arrays and cloud storage services. The
    preferred way to connect them to Kubernetes is via Container Storage Interface
    (CSI) plug-ins. The Kubernetes persistent volume subsystem exposes the storage
    to the cluster and provides ways for it to be consumed. See Figure 7.1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1
  prefs: []
  type: TYPE_NORMAL
- en: Examples of storage providers include; enterprise-class storage arrays such
    as EMC and NetApp, as well as cloud storage services such as AWS Elastic Block
    Store (EBS). These connect to Kubernetes via CSI plug-ins, and Kubernetes provides
    objects that allow the storage to be accessed and used by Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Storage resources are represented in Kubernetes via `PersistentVolume` (PV)
    objects, and Pods can access them using `PersistentVolmeClaim` (PVC) objects.
    Both are resources in `v1` of the core API group.
  prefs: []
  type: TYPE_NORMAL
- en: '`StorageClass` objects allow PVs to be dynamically created and are in the `storage.k8s.io/v1`
    API group.'
  prefs: []
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Helm is the de facto Kubernetes package manager and greatly simplifies installation
    and management of Kubernetes applications.
  prefs: []
  type: TYPE_NORMAL
- en: Helm was accepted into the Cloud Native Computing Foundation (CNCF) in 2018
    as an official top-level project. As such, it sits alongside Kubernetes, Prometheus,
    gRPC, and others.
  prefs: []
  type: TYPE_NORMAL
- en: As a *package manager* , it’s like `apt` for Ubuntu and `brew` for Mac. In the
    case of Helm, it hides all the complexities of things like Deployments, Pods,
    and Persistent Volumes in a construct called a *chart* . Think of a chart as the
    Helm equivalent of a YUM, DEB, or homebrew package. As such, you can install,
    update, and delete Kubernetes applications via the application’s Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: You can also share your charts with the community as well as re-use existing
    charts.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea of this chapter was to make you aware of *some* of the other important
    Kubernetes technologies so that you have an idea of where you might want to go
    next. However, Kubernetes is huge and we haven’t covered everything.
  prefs: []
  type: TYPE_NORMAL
- en: The plan going forward is to make some of these topics their own chapters in
    future versions of the book. If you can’t wait for that, I already cover *Autoscaling*
    , *RBAC* , and *Storage* in my **Kubernetes Deep Dive** video course on acloud.guru.
  prefs: []
  type: TYPE_NORMAL
- en: https://acloud.guru/learn/kubernetes-deep-dive
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
