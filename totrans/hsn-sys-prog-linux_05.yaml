- en: Linux Memory Issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple truism: memory issues exist. The very fact that we program in languages
    such as C (and C++) implicitly gives rise to literally infinite types of issues!
    At some point, one realizes (perhaps a bit pessimistically) that programming with
    care in a managed memory-safe language is ultimately the (only?) realistic way
    to avoid memory issues altogether.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, here we are, working with our power tool of choice: the eminent and
    venerable C programming language! So, what we can do to mitigate, if not eliminate,
    common memory issues, is the topic of this chapter. Ultimately, the goal is to
    be truly memory-safe; well, that''s easier said than done!'
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, we shall attempt to have the developer successfully undertake
    this task by throwing light on the common memory issues they will likely face.
    In the chapter that follows, we will look into how some powerful memory debug
    tools can help immensely in this effort.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the developer will learn that although the dynamic memory management
    APIs (covered in [Chapter 4](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml), *Dynamic
    Memory Allocation*) are few, they can—when used carelessly—cause seemingly endless
    amounts of trouble and bugs!
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, this chapter will throw light on the common memory issues that
    lead to hard-to-detect bugs in fielded software:'
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect memory-access issues (within this, there are a few types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory leakage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undefined behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common memory issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If one were to categorize to fine-granularity memory errors (typically caused
    via programming in C or C++), one would have a difficult time of it—hundreds of
    types exist! Instead, let''s keep the discussion manageable and check out what
    would be considered the typical or common memory errors that befall us poor C
    programmers:'
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect memory accesses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using uninitialized variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-bounds memory accesses (read/write underflow/overflow bugs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use-after-free/use-after-return (out-of-scope) bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double-free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leakage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Undefined behavior** (**UB**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data Races
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragmentation (internal implementation) issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these common memory issues (except fragmentation) are classified as UB;
    still, we keep UB as a separate entry as we will explore it more deeply. Also,
    though the word *bug* is colloquially used, one should really (and more correctly)
    think of it as *defect*.
  prefs: []
  type: TYPE_NORMAL
- en: We do not cover Data Races in this chapter (please hang on until [Chapter 15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml),
    *Multithreading with Pthreads Part II - Synchronization*).
  prefs: []
  type: TYPE_NORMAL
- en: To help test these memory issues, the `membugs` program is a collection of small
    test cases for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sidebar :: The Clang compiler**'
  prefs: []
  type: TYPE_NORMAL
- en: LLVM/Clang is an open source compiler for C. We do use the Clang compiler, notably
    in this and the next chapter, especially for the sanitizer compiler-instrumentation
    toolset (covered in the next chapter). It remains useful throughout the book (and
    indeed is used in many of our Makefiles), thus installing Clang on your Linux
    development system would be a good idea! Again, it is not completely essential
    and one can stick with the familiar GCC too—provided one is willing to edit the
    Makefile(s) to switch back to GCC wherever required!
  prefs: []
  type: TYPE_NORMAL
- en: Installing Clang on the Ubuntu 18.04 LTS desktop is easy: `sudo apt install
    clang`
  prefs: []
  type: TYPE_NORMAL
- en: The Clang documentation can be found at [https://clang.llvm.org/docs/index.html](https://clang.llvm.org/docs/index.html)[.](https://clang.llvm.org/docs/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: When the membugs program is compiled (using both GCC for the normal case as
    well as the Clang compiler for the sanitizer variants), you will see a lot of
    compiler warnings being emitted! This is expected; after all, its code is filled
    with bugs. Relax, and continue reading.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we remind you that the purpose of this chapter is to understand (and classify)
    typical Linux memory issues; identifying and fixing them using powerful tools
    is the subject matter of the next chapter. Both are required, so please read on.
  prefs: []
  type: TYPE_NORMAL
- en: Some sample output from the build is shown as follows (output clipped for readability).
    Right now, we shall not attempt to analyze it; that will happen as we wind through
    this chapter *(*remember, you will need to have Clang installed as well!*):*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We also highlight the fact that, in all the test cases we'll run, we use the
    GCC -generated *membugs* binary executable (not Clang; we shall make use of Clang
    later with the sanitizer tools).
  prefs: []
  type: TYPE_NORMAL
- en: 'During the build, one can capture all the output in to a file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`make >build.txt 2>&1`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `membugs` program with the `--help` switch to see all the available
    test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the write and read overflows have two test cases each:
    one on compile-time memory, and one on dynamically allocated memory. It''s important
    to distinguish the cases, as tools differ in which types of defects they can detect.'
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect memory accesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, bugs and issues in this class are so common as to be blithely overlooked!
    Beware, they remain very dangerous; take care to find, understand, and fix them.
  prefs: []
  type: TYPE_NORMAL
- en: All classes of overflow and underflow bugs on memory buffers are carefully documented
    and tracked via the **Common Vulnerabilities and Exposures (CVE)** and the **Common
    Weakness Enumeration (CWE)** websites. Relevant to what we are discussing, CWE-119
    is the *Improper Restriction of Operations within the Bounds of a Memory Buffer* ([https://cwe.mitre.org/data/definitions/119.html](https://cwe.mitre.org/data/definitions/119.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing and/or using uninitialized variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To give the reader a sense of the seriousness of these memory issues, we have
    written a test program, `membugs.c`. This test program allows the user to test
    various common memory bugs, which will help them better understand the underlying
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Each memory bug test case is given a test case number. So that the reader can
    easily follow the source code with the explanatory material, we also specify the
    test case as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test case 1: Uninitialized memory access'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are also known as **uninitialized memory reads** (**UMR**) bugs. A classic
    case: local (or automatic) variables are, by definition, uninitialized (unlike
    globals, whichare always preset to zero*)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, it''s undefined what will occur at runtime as `x` is
    uninitialized and will thus have random content. Now, we run this test case as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Thankfully, modern versions of the compiler (both `gcc` and `clang`) will emit
    a warning about this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Out-of-bounds memory accesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class is again among the more common—but deadly!—memory-access bugs. They
    can be classified as different kinds of bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write overflow**: A bug where a write is attempted into a memory buffer after
    its last legally accessible location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write underflow**: A write is attempted into a memory buffer before its first
    legally accessible location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read underflow**: A read is attempted on a memory buffer before its first
    legally accessible location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read overflow**: A read is attempted on a memory buffer after its first legally
    accessible location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's check these out via the source code of our `membugs.c` program.
  prefs: []
  type: TYPE_NORMAL
- en: Test case 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write or buffer overflow on compile-time allocated memory. See the code snippet
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This has caused a stack overflow (also referred to as a stack smashing or **buffer
    overflow** (**BOF**)) bug; it's a serious class of vulnerability that attackers
    have successfully exploited many a time, starting with the Morris Worm virus back
    in 1988! Check out the resources in the *Further reading* section for more on
    this vulnerability on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Very interestingly, compiling and running this portion of the code on our *Fedora
    28* workstation Linux box (by passing the appropriate parameter), shows that there
    is neither compile-time nor runtime detection of this (and other similar) dangerous
    bugs by default (more on this later!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These bugs are also sometimes called off-by-one errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s more, though (as usual); let''s do a quick experiment. In the `membugs.c:write_overflow_compilemem()` function*,*
    change the number of times we loop from 5 to 50:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Rebuild and retry; look at the output now on an *Ubuntu 18.04 LTS* Desktop
    Linux system (on Fedora too, but with a vanilla kernel):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The fact is, modern compilers use a stack-protector feature to detect stack-overflow
    bugs and more importantly, attacks. With a large enough value, the overflow was
    detected; but with the default value, the bug escaped undetected! We stress the
    importance of using tools (which includes compilers) to detect these hidden bugs in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Test case 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write or BOF on dynamically-allocated memory. See the code snippet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, no compile or runtime detection of the bug occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, BOF-related bugs and vulnerabilities tend to be quite common
    in the industry. The root cause is poorly understood, and thus results in poorly
    written, code; this is where we, as developers, must step up our game!
  prefs: []
  type: TYPE_NORMAL
- en: 'For real-world examples of security vulnerabilities, please see this table
    of 52 documented security vulnerabilities (due to various kinds of BOF bugs) on
    Linux in 2017: [https://www.cvedetails.com/vulnerability-list/vendor_id-33/year-2017/opov-1/Linux.html](https://www.cvedetails.com/vulnerability-list/vendor_id-33/year-2017/opov-1/Linux.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Test case 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write Underflow. We dynamically allocate a buffer with `malloc(3)`, decrement
    the pointer, and then write into that memory location—a write or buffer underflow
    bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test case, we don''t want the `free(3)` to fail, so we ensure the pointer
    passed to it is correct. The compiler does not detect any bug here; at runtime
    though, it does indeed crash, with modern glibc detecting errors (in this case,
    memory corruption):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Test case 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read overflow, on compile-time allocated memory. We attempt a read on a compile-time
    allocated memory buffer, after its last legally accessible location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The way this test case is designed, we have two buffers arranged sequentially
    in memory. The bug: we deliberately do not null-terminate the first buffer (but
    do so on the second one), so, the `printf(3)` that will emit on `arr` continues
    reading into the second buffer, `tmp`. What if the `tmp` buffer contains secrets?'
  prefs: []
  type: TYPE_NORMAL
- en: The point, of course is that the compiler cannot catch this seemingly obvious
    bug. Also, do realize that here we're writing small, simple, easy-to-read test
    cases; on a real project with a few million lines of code, defects such as this
    are easy to miss.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Hey, we got to read the secret memory of `tmp`.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, tools such as ASan (Address Sanitizer, seen in the next chapter), classify
    this bug as a stack buffer overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an aside, on our *Fedora 28* workstation, we just get junk from the second
    buffer in this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that these bugs can reveal themselves differently, depending on
    the compiler version, the glibc version, and the machine hardware.
  prefs: []
  type: TYPE_NORMAL
- en: An always useful testing technique is to try to run your test cases on as many
    hardware/software variants as possible. Hidden bugs may be exposed! Think of instances
    such as endianness issues, compiler optimization (padding, packing), and platform-specific
    alignments.
  prefs: []
  type: TYPE_NORMAL
- en: Test case 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read overflow, on dynamically allocated memory. Again, we attempt a read; this
    time, on a dynamically allocated memory buffer, after its last legally accessible
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The test case is pretty much the same as the preceding one (the read overflow
    on compile-time memory*)*, except that we dynamically allocate the memory buffers,
    and insert a couple more bugs for fun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Hey, Mom, look! We got the secret!
  prefs: []
  type: TYPE_NORMAL
- en: It does not even cause a crash. At first glance, bugs such as this might appear
    fairly harmless—the truth, though, is that this is a really dangerous bug!
  prefs: []
  type: TYPE_NORMAL
- en: The well known OpenSSL Heartbleed security bug (CVE-2014-0160) is a great example
    of exploiting a read overflow, or as it's often called, a buffer over-read, vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, the bug allowed a rogue client process to make a seemingly correct
    request to the OpenSSL server process; in reality, it could request and receive much
    more memory than it should have been allowed to, because of a buffer over-read
    vulnerability.In effect, this bug made it possible for attackers to bypass security
    easily and steal secrets [[http://heartbleed.com](http://heartbleed.com/)].
  prefs: []
  type: TYPE_NORMAL
- en: If interested, find more in the *Further reading* section on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Test case 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read underflow. We attempt a read on a dynamically allocated memory buffer,
    before its first legally accessible location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The test case is designed with a runtime condition; we test it both ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If the condition evaluates to true, the buffer pointer is decremented, thus
    causing a read buffer underflow on the subsequent `printf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Again, glibc comes to our aid by showing us that a double free or corruption
    has occurred—in this case, it's memory corruption.
  prefs: []
  type: TYPE_NORMAL
- en: Use-after-free/Use-after-return bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Use-****after-free** (**UAF**) and **use-after-return** (**UAR**) are dangerous,
    difficult-to-spot bugs. Check out the following test cases for each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Test case 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Use After Free (UAF).** Operating upon a memory pointer after it has been
    freed up is obviously a bug, causing UB. The pointer is sometimes called a dangling
    pointer. Here is a quick test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, neither at compile-time nor at runtime is the UAF bug detected, nor
    does it cause a crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice the neat `printf(3)` format specifier, `%.*s`, trick? This format
    is used to print a string of a specific length (no terminating null required!).
    First, specify the length in bytes to print, and then the pointer to string.
  prefs: []
  type: TYPE_NORMAL
- en: Test case 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Use After Return** (**UAR**). Another classic bug, this one involves returning
    a storage item (or pointer to it) to the calling function. The issue is that the
    storage is local or automatic, thus implying that once the return is affected,
    the storage object is now out of scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The classic example is shown here: we allocate `32` bytes to a local variable*,*
    initialize it, and return it to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the caller invokes the preceding buggy function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, once the `return` statement in the `uar()` function takes effect,
    the `name` variable is automatically out of scope! Therefore, the pointer to it
    is invalid, and when run, it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Thankfully though, modern GCC (we''re using GCC ver 7.3.0) warns us about this
    common bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned before (but it's always worth repeating), heed and fix all warnings!
  prefs: []
  type: TYPE_NORMAL
- en: Actually, there are times when this bug escapes notice—it looks like it works
    fine and there's no bug. This is because there is no actual guarantee that the
    stack memory frame is immediately destroyed upon function return—memory and compiler-optimization
    might keep the frame around (typically for reuse). Nevertheless, it is a dangerous
    bug and must be fixed!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover some memory debug tools. As a matter of fact,
    neither Valgrind nor the Sanitizer tools catch this possibly deadly bug. But,
    using the ASan toolset appropriately does catch the UAR! Read on.
  prefs: []
  type: TYPE_NORMAL
- en: Test case 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Double-free**.** Once a `malloc` family buffer is freed, one is not allowed
    to use that pointer at all. Attempting to free the same pointer again (without
    again allocating it memory via one of the `malloc` family APIs) is a bug: double
    free. It results in heap corruption; bugs like this are often exploited by attackers
    to cause **denial-of-service **(**DoS**) attacks or worse (privilege escalation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding test case, we simulate an interesting and quite realistic
    scenario: a runtime condition (simulated via the `cond` parameter) causes the
    program to perform a call that, let''s say, fails—`malloc(-1UL)` pretty much guarantees
    that.'
  prefs: []
  type: TYPE_NORMAL
- en: Why? Because, on a 64-bit OS, `-1UL = 0xffffffffffffffff = 18446744073709551615
    bytes = 16 EB`. That's the entire extent of the virtual address space on 64-bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the point: within our malloc error-handling code, an erroneous double-free—of
    the previously freed `ptr` pointer—occurs, resulting in a double free bug.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The real problem is that often, as developers, we do not write (negative) test
    cases for error-handling code paths; a defect then escapes undetected into the
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, the compiler does warn us regarding the faulty (read buggy)
    second malloc (but not regarding the double free!); see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To help emphasize the importance of detecting and fixing such bugs—and remember,
    this is just one example— we show as follows some information from the **National
    Vulnerability Database** (**NVD**) on double free bugs within the last 3 years
    (at the time of this writing): [https://nvd.nist.gov/vuln/search/results?adv_search=false&form_type=basic&results_type=overview&search_type=last3years&query=double+free](https://nvd.nist.gov/vuln/search/results?adv_search=false&form_type=basic&results_type=overview&search_type=last3years&query=double+free)
  prefs: []
  type: TYPE_NORMAL
- en: 'A partial screenshot of the search result performed on the *National Vulnerability
    Database** (NVD)* on double free bugs within the last 3 years (at the time of
    this writing) follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50802625-fc81-4ea1-b8b2-09e417c38592.png)'
  prefs: []
  type: TYPE_IMG
- en: The complete screenshot has not been shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Leakage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The golden rule for dynamic memory is to free the memory you allocate.
  prefs: []
  type: TYPE_NORMAL
- en: Memory leakage is the term used to describe the situation where one fails to
    do so. The programmer thinks that the memory region has indeed been freed up.
    But it has not—that's the bug. Therefore, this makes the thought-to-be-freed memory
    region unavailable to the process and system; in effect, it is unusable, even
    though it should have been usable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory is said to have leaked out. So why can''t the programmer just take
    care of this elsewhere in the code by calling free upon this memory pointer? That''s
    really the crux of the issue: in the typical case, because of the way the code
    is implemented, it''s essentially impossible to regain access to that leaked memory
    pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: A quick test case will demonstrate this.
  prefs: []
  type: TYPE_NORMAL
- en: The `amleaky` function is deliberately written to leak `mem` bytes of memory—its
    parameter—each time it's invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Test case 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memory leakage - case 1: a (simple) memory leak test case. See the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As one can clearly see, in the `amleaky` function, the `ptr` memory pointer
    is a local variable and is thus lost once we return from the buggy function; this
    makes it impossible to free it later. Also notice—the comment explains it—how
    we require `memset` to force the compiler to generate code for and use the memory
    region.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick build and execution of the preceding test case will reveal that, again,
    no obvious compile-time or runtime detection of the leakage occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Test case 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory leakage case 2 - leak more (in a loop). Quite often, the buggy leaking
    code might only be leaking a small amount of memory, a few bytes, by itself. The
    problem is, what if this leaky function is called in a loop hundreds, or perhaps,
    thousands of times, during process execution? Now the leakage is significant,
    and unfortunately, not immediately apparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To emulate precisely this and more, we execute two test cases (for Option 12):'
  prefs: []
  type: TYPE_NORMAL
- en: We allocate, and leak, a tiny amount of memory (32 bytes) but in a loop 100,000
    times (so, yes, we end up leaking over 3 MB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We allocate, and leak, a large amount of memory (1 MB) in a loop 12 times (so,
    we end up leaking 12 MB).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the relevant code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The logic ensures that the `printf(3)` within the leaky loop is only displayed
    on every 10,000 loop iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we would like to see whether memory has indeed leaked. To do so, albeit
    in an approximate manner, we use the `free` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `free(1)` utility displays, in kilobytes, the current (approximate) amount
    of memory used, free, and available on the system as a whole. It further divides
    the used memory between shared, buffered/page-cached; it also displays `Swap`
    partition statistics. We should also note that this approach of using `free(1)`
    to detect memory leakage is not considered very accurate; a crude approach at
    best. The memory reported as in use, free, cached, and so on by the OS can show
    variations. For our purposes, it's okay.
  prefs: []
  type: TYPE_NORMAL
- en: Our point of interest is the intersection of the `Mem` row and the `free` column;
    thus, we can see that out of a total available memory of 16 GB (RAM), the amount
    currently free is approximately 348744 KB ~= 340 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'One can quickly try out a one-liner script to display just the region of interest—the
    `Mem` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The third column after `Mem` is the `free` memory (interestingly, it's already
    reduced from the previous output; that doesn't matter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the program; we use the `system(3)` library API to run the preceding
    pipe-lined shell command within a C program (we''ll build our own small emulation
    of the `system(3)` API in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml),
    *Process Creation*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement ensures that this output only occurs if a threshold of >=
    3 MB is leaking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output upon execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the two scenarios executing; check out the values of the `free` column.
    We shall subtract them to see the memory that''s been leaked:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We allocate, and leak, a tiny amount of memory (32 bytes) but in a loop 100,000
    times: `Leaked memory = 297708 - 293120 = 4588 KB ~= 4.5 MB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We allocate, and leak, a large amount of memory (1 MB) in a loop 12 times:
    `Leaked memory = 292616 - 280992 = 11624 KB ~= 11.4 MB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, do realize that once the process dies, all its memory is freed back
    to the system. That's why we performed the one-liner script within the process,
    while it was alive.
  prefs: []
  type: TYPE_NORMAL
- en: Test case 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Complex case—wrapper APIs. At times, one can be forgiven for thinking that
    all programmers are taught: after calling malloc (or calloc, realloc), call free. malloc
    and free go together! How hard can that be? Why are there are so many sneaky leakage
    bugs if this is the case?'
  prefs: []
  type: TYPE_NORMAL
- en: A key reason that leakage defects occur and are hard to pinpoint is because some
    APIs—often, third-party library APIs—might internally perform dynamic memory allocation
    and expect the caller to free the memory. The API will (hopefully) document this
    important fact; but who (tongue in cheek) reads documentation?
  prefs: []
  type: TYPE_NORMAL
- en: That's really the crux of the issue in real-world software; it is complex and
    we work on large, complex projects. It is indeed easy to miss the fact that an
    underlying API allocates memory and the caller is responsible for freeing it.
    Precisely this occurs quite often.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another case: on complex codebases (especially those with spaghetti
    code), where a lot of deeply nested layers entangle the code, it can get especially
    hard to perform the required cleanup—including memory-frees—on every possible
    error case.'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel community offers a clean, though fairly controversial, way
    to keep cleanup code paths clean and working well, that is, the use of the local
    go to perform centralized error-handling! It helps indeed. Interested in learning
    more? Check out section 7,* Centralized exiting of functions* at [https://www.kernel.org/doc/Documentation/process/coding-style.rst](https://www.kernel.org/doc/Documentation/process/coding-style.rst).
  prefs: []
  type: TYPE_NORMAL
- en: Test case 13.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a simple example. Let''s emulate this with the following test case
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We invoke it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, no compiler or runtime warnings result. Here is the output (recognize
    that the first invocation is the buggy case, as `cond` has the value of `0` and
    thus the `free(3)` will not be called):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There is no bug apparent by looking at the output—and that is partly what makes
    these bugs so dangerous!
  prefs: []
  type: TYPE_NORMAL
- en: This case is critical for developers and testers to understand; it warrants
    checking out a couple of real-world examples.
  prefs: []
  type: TYPE_NORMAL
- en: Test case 13.2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Example—the *Motif* library**. ***Motif* is a legacy library, part of the X
    Window System; it was used (and perhaps still is) to develop GUIs for Unix (and
    Unix-like) systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of this example, we will focus on one of its APIs: `XmStringCreateLocalized(3)`.
    GUI developers use this function to create what Motif calls a "compound string"—essentially,
    just a string that holds text in a specific locale (for the purposes of I18N-internationalization).
    This is its signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: So, let's imagine the developer uses it to generate compound strings (for various
    purposes; very often, for the labels of a label or push button widget).
  prefs: []
  type: TYPE_NORMAL
- en: So, what's the problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'Leakage! How? Read the documentation from the man page ([https://linux.die.net/man/3/xmstringcreatelocalized](https://linux.die.net/man/3/xmstringcreatelocalized))
    on `XmStringCreateLocalized(3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, the developer must not only call `XmStringCreateLocalized(3)` but must
    also remember to free up the memory internally allocated by it for the compound
    string by calling `XmStringFree(3)`!
  prefs: []
  type: TYPE_NORMAL
- en: Failing to do so will result in a leak. I have personal experience with this
    scenario—a buggy application invoked the `XmStringCreateLocalized(3)` and did not
    call its counterpart, `XmStringFree(3)`. Not only that, this code ran often as
    it was invoked as part of the body of an outer loop! So, the leakage multiplied.
  prefs: []
  type: TYPE_NORMAL
- en: Test case 13.3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Example—the Nortel Porting Project.There is a story (refer to the information
    box as follows) about how developers at Nortel (a large telecom and network equipment
    multinational corporation in Canada) had a very hard time debugging what turned
    out to be a memory leakage issue. The crux of it is this: when porting a Unix
    application to VxWorks, while testing it, they noticed a small 18-byte leak occurring,
    which would eventually cause the application to crash. Finding the source of the
    leak was a nightmare— reviewing the code endlessly provided no clues. Finally,
    the game changer proved to be the use of a leak detection tool (we''ll cover this
    in the coming [Chapter 6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging
    Tools for Memory Issues*). Within minutes, they uncovered the root cause of the
    leak: an innocent-looking API, `inet_ntoa(3)` (refer to the information box),
    which worked in the usual manner on Unix, and as well as in VxWorks. The catch:
    in the VxWorks implementation, it was allocating memory under the hood—which the
    caller was responsible for freeing! This fact was documented, but it was a porting
    project! Once this fact was realized, it was quickly fixed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Article: The ten secrets of embedded debugging, Schneider and Fraleigh: [https://www.embedded.com/design/prototyping-and-development/4025015/The-ten-secrets-of-embedded-debugging](https://www.embedded.com/design/prototyping-and-development/4025015/The-ten-secrets-of-embedded-debugging)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The man page entry on `inet_ntoa(3)` states: The `inet_ntoa()` function converts
    the Internet host address in, given in network byte order, to a string in IPv4
    dotted-decimal notation. The string is returned in a statically allocated buffer,
    which subsequent calls will overwrite.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some observations on programs with leakage bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: The program behaves normally for a long, long while; suddenly, after, say, a
    month of uptime, it abruptly crashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root leakage could be very small—a few bytes at a time; but is probably
    invoked often.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempting to find leakage bugs by carefully matching your  instances of `malloc(3)` and
    `free(3)` does not work; library API wrappers often allocate memory under the
    hood and expect the caller to free it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leaks often escape unnoticed because they are inherently difficult to spot in
    large codebases, and once the process dies, the leaked memory is freed back to
    the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bottom line:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not assume anything
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the API documentation carefully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use tools (covered in the coming [Chapter 6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging
    Tools for Memory Issues*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One cannot overstate the importance of using tools to detect memory bugs!
  prefs: []
  type: TYPE_NORMAL
- en: Undefined behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve covered quite a bit of ground and seen quite a few common memory bugs,
    which include:'
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect memory accesses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using uninitialized variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-bounds memory accesses (read/write underflow/overflow bugs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use-after-free / use-after-return (out-of-scope) bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double-free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leakage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data Races *(*details follow in a later chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned earlier, all of these fall into a general categorization—UB. As
    the phrase implies, the behavior of the process (or thread) is *undefined* once
    any of these bugs are hit. Even worse, many of them do not display any directly
    noticeable side effects; but the process is unstable and will—eventually—crash.
    Leakage bugs, in particular, are major spoilsports in this: the leakage may be
    around for a long while before a crash actually occurs. Not only that, the trail
    left behind (that the developer will be breathlessly chasing) might often be a
    red herring—matters of little consequence, things that have no real bearing on
    the bug''s root cause. All of this, of course, makes debugging UB an experience
    most of us would prefer to avoid!'
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that UB is avoidable, as long as the developer understands
    the underlying causes of UB (which we have covered in the previous sections),
    and of course, the ability to use powerful tools to discover, and then fix, these
    bugs, which is our next topic area.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a deeper look at the many, many possible kinds of UB bugs, please check
    out:*Appendix J.2: Undefined behavior*: a nonnormative, non-exhaustive list of
    undefined behaviors in C: [http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf#page=571](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf#page=571).'
  prefs: []
  type: TYPE_NORMAL
- en: From the in-depth C Programming Language standards—the ISO/IEC 9899:201x Committee
    Draft dated 02 Dec 2010.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along similar lines, please see *CWE VIEW: Weaknesses in Software Written in
    C*:[https://cwe.mitre.org/data/definitions/658.html](https://cwe.mitre.org/data/definitions/658.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Fragmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fragmentation issues usually refer to problems primarily faced by the internal
    implementation of the memory allocation engine itself, and not so much by the
    typical application developer. Fragmentation issues are usually of two types:
    internal and external.'
  prefs: []
  type: TYPE_NORMAL
- en: External fragmentation usually refers to the situation where, after several
    days of uptime, even if the free memory on the system is, say, 100 MB, the physically
    contiguous free memory might be less than a megabyte. Thus, with processes taking
    and releasing various sized memory chunks, memory has become fragmented.
  prefs: []
  type: TYPE_NORMAL
- en: Internal fragmentation usually refers to the wastage of memory caused by using
    an inefficient allocation strategy; often though, this cannot be helped, since
    wastage tends to be a side effect of many heap-based allocators. The modern glibc
    engine uses memory pools, which greatly reduce internal fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: We shall not attempt to delve into fragmentation issues in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Suffice it to say that, if in a large project you suspect fragmentation issues,
    you should try using a tool that displays your process runtime memory map (on
    Linux, check out `/proc/<PID>/maps` as a starting point). Interpreting it, you
    could possibly look at redesigning your application to avoid said fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Also, do realize that it's a bug to attempt to use just a pointer to access
    memory unless the memory has already been allocated. Remember that pointers have
    no memory; they have to be allocated memory (either statically at compile time
    or dynamically at runtime).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, one writes a C function that uses the parameter as a return value—a
    common C programming trick (these are often called value-result or in-out parameters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bug; the `uptr` variable is just a pointer—it has no memory. One
    way to fix this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, even simpler, why not just use compile-time memory for cases such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we delved into a critical area: the fact that the seemingly
    simple, dynamic memory management APIs can cause deep and difficult-to-detect
    bugs in real-world fielded systems.'
  prefs: []
  type: TYPE_NORMAL
- en: The common classes of memory bugs, such as **uninitialized memory usage** (**UMR**),
    out-of-bounds accesses (read|write underflow|overflow bugs), and the double free,
    were covered. Memory leakage is a common and dangerous memory bug—we looked at three
    different cases of it.
  prefs: []
  type: TYPE_NORMAL
- en: The supplied `membugs` program helps the reader actually see and try out the
    various memory bugs covered via small test cases. In the next chapter we shall
    dive into using tools to help identify these dangerous defects.
  prefs: []
  type: TYPE_NORMAL
