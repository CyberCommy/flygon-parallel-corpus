- en: '*Chapter 12*: Managing Local Storage and Filesystems'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have learned about security and system administration.
    In this chapter, we will focus on the administration of resources—specifically,
    storage administration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Storage administration is an important part of keeping a system running: the
    system logs can eat available space, new applications might require additional
    storage set up for them (even on separate disks to improve performance), and such
    issues may require our action in order to solve them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning disks (**Master Boot Record** (**MBR**) and **Globally Unique Identifier**
    (**GUID**) **Partition Table** (**GPT**) disks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting and mounting filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting default mounts and options in `fstab`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using network filesystems with **Network File System** (**NFS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will provide us basic knowledge to build upon our storage administration
    skills to keep our systems running.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get hands-on!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can continue the practice using the **virtual machine** (**VM**) created
    at the beginning of this book in [*Chapter 1*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Installing RHEL8*. Any additional packages required for this chapter will be
    indicated alongside the text. You will also need partitioning disks (MBR and GPT
    disks).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A partition is a logical division of a storage device and it's used to logically
    separate the available storage into smaller pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to learning a bit about the origins of storage to better
    understand it.
  prefs: []
  type: TYPE_NORMAL
- en: A bit of history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storage is also related to a system's ability to use it, so let's explain a
    bit about the history of **personal computers** (**PCs**), the software that allows
    them to boot (**Basic Input/Output System** (**BIOS**)), and how that influenced
    storage administration.
  prefs: []
  type: TYPE_NORMAL
- en: It might sound a bit strange, but initial storage needs were just a small amount
    of **kilobytes** (**KB**), and for the first hard drives in PCs, storage was just
    a few **megabytes** (**MB**).
  prefs: []
  type: TYPE_NORMAL
- en: 'PCs also come with one feature and limitation: PCs were compatible, which means
    that subsequent models had compatibility with the initial **International Business
    Machines** (**IBM**) PC design.'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional disk partitioning uses a space at the beginning of disks after the
    MBR that allows four partition registers (start, end, size, partition type, active
    flag), called **primary** partitions.
  prefs: []
  type: TYPE_NORMAL
- en: When the PC is booting, BIOS will check the partition table of the disk by running
    a small program in the MBR, and then it loads the boot area of the active partition
    and executes it to get the operating system booting.
  prefs: []
  type: TYPE_NORMAL
- en: The IBM PC that contained a **Disk Operating System** (**DOS**) and compatibles
    (MS-DOS, DR-DOS, FreeDOS, and others) also used a filesystem named a **File Allocation
    Table** (**FAT**). The FAT contained several structures based on its evolution,
    indicated as the cluster addressing size (as well of some other features).
  prefs: []
  type: TYPE_NORMAL
- en: With a limit in the number of clusters, having bigger disks meant having bigger
    blocks, so if a file was using just a limited amount of space, the remaining ones
    couldn't be used by other files. Thus, it became more or less normal to break
    bigger hard drives into smaller logical partitions so that small files would not
    eat up the available space because of limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about this as an agenda with a maximum number of entries, similar to
    a speed dial in your phone: if you have only nine slots for the speed dial, a
    short number such as calling voicemail will still count as having stored a big
    international number as both still use one slot.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of those limitations became reduced by subsequent versions of the FAT sizing,
    which in parallel increased the maximum supported disk size.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, other operating systems introduced their own filesystems, but using
    this same partitioning schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, a new partition type was created: the **extended partition**, which
    used one of the four available **primary partition** slots and allowed extra partitions
    to be defined inside it, enabling us to create logical disks to be assigned as
    needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, having several primary partitions also allowed the installation
    in the same computer of different operating systems with their own dedicated space
    that were completely independent of other operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: So... partitions allowed computers to have different operating systems, have
    a better usage of the available storage, or even logically sorting the data by
    keeping it on different areas, such as keeping operating system space separate
    from user data so that a user filling the available space would not affect the
    computer's operation.
  prefs: []
  type: TYPE_NORMAL
- en: As we said, many of those designs came with the compatibility restriction of
    the original IBM PC, so when new computers using the **Extensible Firmware Interface**
    (**EFI**) appeared to overcome the limitations of traditional BIOS, a new partition
    table format called **GPT** arrived.
  prefs: []
  type: TYPE_NORMAL
- en: Systems using GPT make use of 32-bit and 64-bit support versus the 16-bit support
    used by BIOS (inherited from IBM PC compatibility), so bigger addressing can be
    used for the disks, as well as extra features such as extended controllers loading.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn about disk partitioning in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning disks (MBR and GPT disks)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, using disk partitions allows us to more efficiently use the space
    available in our computers and servers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dig into disk partitioning by first identifying the disk to act on.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Once we have learned about what caused disks to be partitioned and the limitations
    of this, we should follow one schema or another based on our system specifications,
    but bear in mind that EFI requires GPT and BIOS requires MBR, so a system supporting
    UEFI, but having a disk partitioned with MBR, will boot the system into BIOS-compatible
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Linux uses different notation for the disks based on the way those are connected
    to the system, so—for example—you can see disks as `hda` or `sda` or `mmbclk0`
    depending on that connection being used. Traditionally, disks connected using
    the `hda`, `hdb`, and so on, while disks using the `sda`, `sdb`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can list the available devices with `fdisk –l` or `lsblk –fp`, as we can
    see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – lsblk-fp and fdisk –l output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_12_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – lsblk-fp and fdisk –l output
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, our disk named `/dev/sda` has three partitions: `sda1`, `sda2`,
    and `sda3`, with `sda3` being a `LVM` volume group that has a volume named `/dev/mapper/rhel-root`.'
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate disk partitioning in a safe way and to make it easier for readers
    using a VM for testing, we will create a fake `truncate` utility that comes with
    the `coreutil` package and the `losetup` utility that comes with the `util-linux`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a VHD, we will execute the following sequence of commands
    as they appear in *Figure 12.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`truncate –s 20G myharddrive.hdd`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This command creates a 20 **gigabytes** (**GB**)-sized file but this will be
    an empty file, which means that the file is not really using 20 GB on our disk,
    just showing that size. Unless we use it, it will not consume more disk space
    (this is called a **sparse file**).
  prefs: []
  type: TYPE_NORMAL
- en: '`losetup –f`, which will find the next available device'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`losetup /dev/loop0 myharddrive.hdd`, which will associate `loop0` with the
    file created'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lsblk –fp`, to validate the newly looped disk'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fdisk –l /dev/loop0`, to list the available space in the new disk'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the preceding sequential commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Execution of the indicated commands for creating a fake hard
    drive'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_12_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – Execution of the indicated commands for creating a fake hard drive
  prefs: []
  type: TYPE_NORMAL
- en: The `losetup -f` command finds the next available loopback device, which is
    a device used for looping back accesses to a backing file. This is often used
    for mounting ISO files locally, for example.
  prefs: []
  type: TYPE_NORMAL
- en: With the third command, we use the previously available loopback device to set
    up a loop connection between device `loop0` device and the file we created with
    the first command.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, in the remaining commands, the device now appears when running
    the same commands, we executed in *Figure 12.1*, showing that we have a disk of
    20 GB available.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning operations on disks can be dangerous and can render a system unusable
    and in need of restoration or reinstallation. To reduce that chance, the examples
    in this chapter will use the `/dev/loop0` fake created disk and only interact
    with this. Pay attention when performing this over real volumes, disks, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start creating partitions by executing `fdisk /dev/loop0` on our newly
    created device, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – fdisk execution over /dev/loop0'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_12_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – fdisk execution over /dev/loop0
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 12.3*, the disk doesn't contain a recognized partition
    table, so a new DOS partition disk label is created, but the changes only remain
    in memory until written back to disk.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `fdisk` command, we can use several options to create a partition.
    The first one we should be aware of is `m`, as indicated in *Figure 12.3*, which
    shows the help functionality and available commands.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to take into consideration is our previous explanation about
    UEFI, BIOS, and so on. By default, `fdisk` is creating a DOS partition, but as
    we can see inside the manual (`m`), we can create a GPT one by running the `g`
    command inside `fdisk`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important command to remember is `p`, which prints the current disk layout
    and partition, as defined in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – fdisk creating a new partition table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_12_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – fdisk creating a new partition table
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the initial `disklabel` type was `dos` and now is `gpt`, compatible
    with EFI/UEFI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review some of the basic commands we can use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`n`: Creates a new partition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: Deletes a partition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: Shows manual page (help)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p`: Prints current layout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`: Enters advanced mode (extra functionality intended for experts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`q`: Quits without saving'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: Writes changes to disk and exits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g`: Creates new GPT disk label'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`o`: Creates a DOS disk label'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a`: In DOS mode, sets the bootable flag to one of the primary partitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What will be the sequence for creating a new traditional disk partition layout
    with a bootable partition for the operating system and another one for the user
    data with half the disk size each?
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be the sequence of commands (these are also shown in *Figure 12.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`o` and press *Enter* to create a new DOS disk label'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`n` and press *Enter* to create a new partition'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter* to accept a primary partition type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter* to confirm use of the first partition (`1`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter* to accept initial sector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`+10G` and press *Enter* to indicate 10 GB in size from first sector'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`n` and press *Enter* to create a second new partition'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter* to accept it as a primary partition type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter* to accept the partition number (`2`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter* to accept the first sector as default proposed by fdisk
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter* to accept the end sector as default proposed by fdisk
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a` and press *Enter* to mark a partition as bootable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1` and press *Enter* to mark the first partition'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, most of the options accept the defaults; the only change was
    to specify a partition size of `+10G`, meaning it should be 10 GB (the disk was
    20 GB), and then start with the second partition with the new `n` command, now
    not specifying the size as we want to use all the remaining ones. The last step
    is to mark the first partition as active for booting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, remember what we said before: unless we execute the `w` command,
    the changes are not written to disk, and we can use `p` to review them, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Disk partition layout creation and verification before writing
    it back to disk'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_12_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – Disk partition layout creation and verification before writing
    it back to disk
  prefs: []
  type: TYPE_NORMAL
- en: To conclude this section, let's write the changes to disk with the `w` command
    and let's move on to discuss filesystems in the next section. Before that, however,
    let's execute `partprobe /dev/loop0` to make the kernel update its internal view
    on the disk and find the two new partitions. Without this, the `/dev/loop0p1`
    and `/dev/loop0p2` special files might not be created and will not be usable.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some partition modifications will not be updated even after a `partprobe`
    execution and might require the system to be rebooted. This is, for example, happening
    in disks that have partitions in use, such as the one holding the root filesystem
    in our computer.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting and mounting filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to logically divide our disk, but that
    disk is still not usable for storing data. In order to enable this to do so, we
    need to define a **filesystem** on it as the first step to make it available to
    our system.
  prefs: []
  type: TYPE_NORMAL
- en: A filesystem is a logical structure that defines how files, folders, and more
    are stored and provides, based on each type, a different set of features.
  prefs: []
  type: TYPE_NORMAL
- en: The number and types of filesystems supported depends on the operating system
    version, as during its evolution, new filesystems might be added, removed, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Remember that **Red Hat Enterprise Linux** (**RHEL**) focuses on stability,
    so there are strict controls about which features are added or phased out for
    newer releases, but not within the current release. You can read more about this
    at [https://access.redhat.com/articles/rhel8-abi-compatibility](https://access.redhat.com/articles/rhel8-abi-compatibility).
  prefs: []
  type: TYPE_NORMAL
- en: In RHEL 8, the default filesystem is the **eXtended File System** (**XFS**),
    but you can see a list of available ones at the RHEL documentation found at [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/system_design_guide/overview-of-available-file-systems_system-design-guide](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/system_design_guide/overview-of-available-file-systems_system-design-guide),
    and of course, others such as **Fourth Extended Filesystem** (**EXT4**) can be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: The choice of the filesystem depends on several factors such as usage intention,
    type of files that are going to be used, and more, as different filesystems might
    have performance implications.
  prefs: []
  type: TYPE_NORMAL
- en: For example, both EXT4 and XFS are journaled filesystems that provide more protection
    against power failures, but the maximum filesystem differs in terms of other aspects
    such as the likeliness of becoming fragmented, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Before choosing a filesystem, it is a good practice to get an idea of the kind
    of files being deployed and their usage pattern, as choosing the wrong one might
    affect system performance.
  prefs: []
  type: TYPE_NORMAL
- en: As we defined in the previous section two partitions on our VHD, we can try
    creating both XFS and EXT4 filesystems. Again, however, be very careful when performing
    operations, as filesystem creation is a destructive operation that writes new
    structures back to the disk, and when operating as root user of the system, which
    is required, selecting the wrong one can destroy within seconds the available
    data we had on our system.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember to check the man page for the commands being used in order to get familiar
    with the different recommendations and options available for each one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s then use the two partitions we created to test with two filesystems,
    XFS and EXT4, by using the `mkfs.xfs` and `mkfs.ext4` commands against each one
    of the devices respectively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Filesystem creation on the VHD created'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_12_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Filesystem creation on the VHD created
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have specified the different loop device partition and we also
    specified one `-L` parameter for each command. We will look at this again later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the filesystem has been created, we can run `lsblk -fp` to verify
    this, and we can see both devices, now indicating the filesystem is in use as
    well as `LABEL` and `UUID` values (the ones shown when we created the filesystem
    with `mkfs`), as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Output of lsblk –fp after creating the filesystems'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_12_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – Output of lsblk –fp after creating the filesystems
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding output, it's important to pay attention to the `UUID` and
    `LABEL` values (if you remember, the value listed is the one we specified in the
    `mkfs` command with the `–L` option), as we will be using them later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the filesystems have been created, in order to use them we need to
    mount them, which means making the filesystem available at a path in our system
    so that every time we store inside that path, we will be using that device.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a filesystem can be done in several ways, but the simplest way is to
    use autodetection and just specify the device to mount and the local path to mount
    it at, but more complex ones that allow several options to be defined can be found
    when checking the `man mount` help page.
  prefs: []
  type: TYPE_NORMAL
- en: 'For mounting our two created filesystems, we will create two folders and then
    proceed to mounting each device by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cd`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mkdir first second`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mount /dev/loop0p1 first/`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mount /dev/loop0p2 second/`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the two filesystems will be available in our home folder (root
    user) in the subfolders named `first` and `second`.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel has automatically found which filesystem is in use for each device
    and has loaded it via the appropriate controller and this worked, but sometimes
    we might want to define specific options— for example, forcing the filesystem
    type, which was used in the past when `ext2` and `ext3` were the common filesystems
    to enable or disable journaling, or, for example, to disable the built-in features
    that update the file or directory access time to reduce the disk I/O and increase
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: All options specified on the command line, or filesystems mounted, will not
    be available once the system is rebooted as those are only runtime changes. Let's
    move on to the next section to learn how to define default options and filesystem
    mounts when the system is being started.
  prefs: []
  type: TYPE_NORMAL
- en: Setting default mounts and options in fstab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we introduced how disks and partitions can be mounted
    so that our services and users can make use of them. In this section, we will
    learn how to make those filesystems available in a persistent way.
  prefs: []
  type: TYPE_NORMAL
- en: The `/etc/fstab` file contains the filesystem definitions for our system and,
    of course, it has a dedicated manual page that can be checked with `man fstab`
    containing useful information about the formatting, fields, ordering, and so on
    that must be taken into consideration, as this file is critical for the smooth
    operation of the system.
  prefs: []
  type: TYPE_NORMAL
- en: The file format is defined by several fields separated by tabs or spaces, with
    lines starting with a `#` considered as comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we will use this line to look at each field description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first field is the device definition, which can be a special block device,
    a remote filesystem, or—as we can see—a selector made by `LABEL`, `UUID`, or,
    for `PARTUUID` or `PARTLABEL`. The `man` page for `mount`, `blkid`, and `lsblk`
    provides more information about device identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: The second field is the mount point for the filesystem, which is where to make
    the contents of that filesystem available based on our system directory hierarchy.
    Some special devices/partitions such as swap areas have this defined as `none`,
    as effectively the contents are not made available via the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The third field is the filesystem type as supported by the `mount` command or
    `swap`, for swap partitions.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth field is the mount options as supported by `mount` or `swapon` commands
    (check their `man` pages for more details), being at its default setting an alias
    for most common options (read/write, allow devices, allow execution, automount
    on boot, async access, and so on). Other common options might be `noauto`, which
    defines the filesystem but doesn't mount at boot (often used with removable devices),
    `user`, which allows users to mount and unmount it, and `_netdev`, which defines
    remote paths that require networking to be up before attempting the mount.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth field is used by `dump` to determine which filesystems should be used—its
    value defaults to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The sixth field is used by `fsck` to determine the order for filesystems to
    be checked on boot. The root filesystem should have a value of 1 and the others
    should have a value of 2 (the default is 0, not `fsck`). Checks are performed
    in parallel to speed up the booting process. Note that with filesystems that have
    a journal, the filesystem itself can perform a fast validation instead of a full
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, let''s see how it looks in our system with the
    output of `cat /etc/fstab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – fstab example from our system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_12_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – fstab example from our system
  prefs: []
  type: TYPE_NORMAL
- en: Why should we use `UUID` or `LABEL` instead of devices such as `/dev/sda1`?
  prefs: []
  type: TYPE_NORMAL
- en: Disk ordering might change when a system is booting, as some kernels might introduce
    differences in the devices in how those are accessed, and so on, causing changes
    in the enumeration of the devices; this happens not only for removable devices
    such as **Universal Serial Bus** (**USB**) ones, but also to internal devices
    such as network interfaces or hard drives.
  prefs: []
  type: TYPE_NORMAL
- en: When, instead of specifying the devices, we use `UUID` or `LABEL`, even in the
    event of a device reordering, the system will still be able to find the right
    device to use and boot from it. This was especially important when systems used
    to have **IDE** and **Serial Advanced Technology Attachment** (**SATA**) drives
    and **SCSI** drives, or even today when **internet SCSI** (**iSCSI**) devices
    might be connected in a different order than expected, resulting in device name
    changes and failures when reaching them.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to use `blkid` or `lsblk –fp` commands to check the filesystems' labels
    and **universally unique identifiers** (**UUIDs**) that could be used when referring
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'When editing the `/etc/fstab` file, be extremely careful: altering the mount
    points used by the system might render your system unusable. If in doubt, double-check
    for any change and be sure to be familiar with system recovery methods and have
    rescue media available in case this is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn about mounting a remote NFS in the next section
  prefs: []
  type: TYPE_NORMAL
- en: Using network filesystems with NFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mounting a remote NFS is not much different than mounting local devices, but
    instead of specifying a local device as we did in the previous section with our
    `/dev/loop0p1` file, we provide `server:export` as a device.
  prefs: []
  type: TYPE_NORMAL
- en: We can find a range of available options by checking the manual page via `man
    mount`, and this will show us several of the options and the way the device looks.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a NFS mount is going to be used, the administrator will need to use the
    host and the export name to mount that device—for example, based on the following
    data about the NFS export:'
  prefs: []
  type: TYPE_NORMAL
- en: '`server.example.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/isos`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mnt/nfs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the preceding data, it''s easy to construct the `mount` command, which
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we analyze the preceding command, it will define the type of filesystem to
    mount as `nfs`, provided by a `server.example.com` hostname, and using the `/isos`
    NFS export, and will be made available locally under the `/mnt/nfs` folder.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to define this filesystem as available at boot, we should add an
    entry in `/etc/fstab`, but... how should we indicate this?
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the settings explained during this chapter, the constructed entry
    would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code contains the parameters we indicated on the command
    line, but it also adds that it is a resource that required network access before
    attempting to mount it, as networking is required to be able to reach the NFS
    server, similar to what will be required for other network-based storage such
    as Samba mounts, iSCSI, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Reinstating the idea of keeping our system bootable, once we make modifications
    to the `/etc/fstab` configuration file, it is recommended to execute `mount -a`
    so that the validation is performed from a running system. If after the execution
    the new filesystems are available and shown when executing—for example, `df`—and
    no error appeared, it should be safe.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned about how a disk is divided logically for optimal
    use of storage and how to later create a filesystem on that disk division so that
    it can be used to actually store data.
  prefs: []
  type: TYPE_NORMAL
- en: Once the actual filesystem was created, we learned how to make it accessible
    in our system and how to ensure that it will be available after the next system
    restart via modification of the `/etc/fstab` configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also learned about using a remote filesystem with NFS based on the
    data that was provided for us and how to add it to our `fstab` file to make it
    persistent.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to make storage even more useful via
    **Logical Volume Management** (**LVM**), which empowers the definition of different
    logical units that can be resized, combined to provide data redundancy, and so
    on.
  prefs: []
  type: TYPE_NORMAL
