- en: Getting to Know Pymunk by Building an Angry Birds Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python, being a standalone language for half a decade in data science and machine
    learning, was not popular enough in the game development industry until open source
    packages such as pymunk evolved. These open source packages provided game developers
    with an easy interface for mimicking real-world environments through simulation,
    which allowed them to create single or multiple body objects that linked the player's
    input to physical impulses. This evolution brought the usage of a continuous physics
    model into Python game development, where some objects were allowed to rest for
    efficiency purposes and were only brought into the light with the principle of
    collision. With this model, we can handle multiple object collisions properly
    and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned about the fundamentals of
    Pythonic 2D physics library so that you know how to use classes and submodules
    to build complex games such as Angry Birds, which simulates the real-world environment
    by considering physical properties such as mass, motion, inertia, elasticity,
    and moment. You will also learn how to create 2D rigid bodies and link them to
    the player's input in order to simulate physical impulses. This will result in
    movement in the rigid bodies within the simulated environment (space). You will
    also learn how to use time interval steps (dt) by updating physical attributes
    that facilitate movement for rigid bodies within that space.
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, you have been checking collisions between two game entities (in
    [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake
    Game UI with Pygame*, you checked collisions between the snake and the boundary
    wall, while in [Chapter](6eb72797-e976-49b0-878f-4db620a59aca.xhtml) [1](6eb72797-e976-49b0-878f-4db620a59aca.xhtml)[2](6eb72797-e976-49b0-878f-4db620a59aca.xhtml)*,
    Learning About Character Animation, Collision, and Movement*, you checked collisions
    between the bird and a vertical pipe), but this chapter will be more edifying
    in the sense that you will be checking collisions between three game objects one
    by one and performing actions by creating a collision handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pymunk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a character controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a polygon class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Pythonic physics simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing sling-action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addressing collisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You must have the following requirements to be able to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The Pygame editor (IDLE) version 3.5 or higher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PyCharm IDE (refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*, for the installation procedure).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pymunk` module (an open source library that's available at [http://www.pymunk.org/en/latest/](http://www.pymunk.org/en/latest/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An external link to the sprite sheets for angry birds: [https://www.spriters-resource.com/mobile/angrybirds/sheet/59982/](https://www.spriters-resource.com/mobile/angrybirds/sheet/59982/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2oG246k](http://bit.ly/2oG246k)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pymunk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a real-world environment, objects move in ubiquitous directions arbitrarily.
    Thus, to mimic such movements, games must address the different physical behaviors
    of objects. For example, when we throw an object in the air, due to the presence
    of gravity, the object will hit the ground at some point. Similarly, we must also
    address the reduction in the velocity of objects every time an object bounces
    back from the surface. For example, if we were to take a ball and throw it in
    the air, after some time, it must hit the ground with the original velocity, V[o], and
    after one hit to the surface, it will bounce off the surface and then ascend with
    velocity V[f]. Therefore, it is obvious that V[o] > V[f]. Implementing this kind
    of behavior for objects in a game environment will leave players with a good impression
    of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Physics, being a branch of natural science, tries to simulate real-world actions
    through simulation and mathematical deduction. Different terminology is defined
    in physics, such as mass, inertia, impulse, elasticity, friction, and so on. These
    terminologies define the characteristics of objects when they''re exposed to different
    environments. Without getting bogged down in the intricacies of physics, let''s
    get down to business. The real question is, why do we need physics in games? The
    answer to this question is simple: similar to real-world objects, games also have
    objects/characters. These characters are governed by the players of the game.
    Most players love to play a game that simulates a real-world phenomenon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some physical terms you must understand before using the `pymunk` module are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mass**: Literally, mass refers to the weight of any object. While considering
    its physical definition, the mass of an object is a measure of the amount of matter
    in the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force**: A force is a push or a pull upon an object resulting from the object''s
    *interaction* with another object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gravity**: The force that causes, for example, an apple to fall toward the
    ground. Gravity is the force that attracts two bodies to each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elasticity**: A property of deformed objects where they get reshaped and
    go back to their original form. For example, a spring and a rubber band will go
    back to their original shape, even if force is applied to distort them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moment**: A moment of force is a property that causes an object to rotate
    around a specific point or axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have not played Angry Birds before, make sure to check out this link:
    [http://freeangrybirdsgame.org/play/angry_birds_online.html](http://freeangrybirdsgame.org/play/angry_birds_online.html.).
    While playing the game, observe the number of characters, structures, and catapult
    actions.'
  prefs: []
  type: TYPE_NORMAL
- en: It would be boring if both of the characters in our Angry Birds game (Bird and
    Pig) had horizontal movements. For instance, when the player shoots an Angry Bird
    from the catapult or material slingshot, what if it doesn't follow projectile
    motion (45-degree motion) and just goes in a horizontal direction (90-degree motion)?
    This violates one of the laws of physics which states that *Earth pulls down on
    you*. Maybe we could argue that's why this is a big deal. Violating such laws
    would make games asinine and absurd, which might hamper the reputation of the
    game. In order to simulate such real-world physics in games, the Python community
    has developed a 2D physics library. We can employ different characteristics for
    game objects such as mass, inertia, impulse, and friction using this library.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, I recommend that you check out the official documentation of pymunk
    at [http://www.pymunk.org/en/latest/pymunk.html.](http://www.pymunk.org/en/latest/pymunk.html)
    Since the packages and modules of `pymunk` are frequently updated, you will see
    a huge amount of resources on their official documentation page. Just don't get
    overwhelmed by how many there are—we will need only a few of them to make a game
    that uses the pymunk 2D physics library.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have gone through the documentation, I assume that you might have
    seen several submodules and classes. We will need some of them, all of which we
    will discuss. We will start with pymunk, which is the most popular and widely
    used submodule. It's named `vec2d`. To observe the working of `vec2d`, you have
    to brush up on your basics, which we learned about in [Chapter 9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml), *Data
    Model Implementation*. To recap, we used different data models to implement vector
    manipulation (we used `__add__()` to add vectors, `__str__()` to format vectors,
    and so on). We've already learned about vector manipulation, but in a Pythonic
    way; now, let's learn about it in a modular way. The Python developer community
    has created a submodule for `vec2d`; that is, the `Vec2d` class, in order to perform
    any vector-related manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Before looking at an example of the `Vec2d` class, let's set up our PyCharm
    project first. Open the PyCharm editor and create a new project. I will call it
    *Angry Bird*. After providing a name for the project, press the Create button
    to create a project. When PyCharm is ready with your project, create a new Python
    file called `test.py`. Before writing any code, we have to install the `pymunk`
    module in the current project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to do so (to get a detailed description of how to install
    any third-party library in PyCharm, refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*):'
  prefs: []
  type: TYPE_NORMAL
- en: Click on File | Settings. The Settings window will open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the left-hand side tab, click on the Project: Angry Bird tab. It will list
    all the modules that have been installed in the Python interpreter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add a new module, click on the (+) button next to the Packages tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `pymunk` and install the module (make sure your internet connection
    is up and running).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the `pymunk` module has been successfully installed, let''s get back
    to the `Vec2d` class. As we mentioned previously, this class can be used to perform
    vector manipulation. It is an alternative to using data models for vector manipulation.
    Let''s look at a simple example of creating a vector using the `Vec2d` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from performing mathematical computations, `Vec2d` can also perform different
    high-level functional computations. For instance, if you want to find the distance
    between two vectors, we can call the `get_distance()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function calculates the distance between two vectored points using
    the formula √(x2 − x1)^2 + (y2 − y1)^2, where (x1, y1) and (x2, y2) are two vectored
    coordinates. To learn more about the distance formula, please go to [https://www.purplemath.com/modules/distform.htm](https://www.purplemath.com/modules/distform.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored `Vec2d`, we will learn about `pymunk` classes. There
    are more than 10 of them but we will only learn about the important ones. You
    can explore them by going to their official documentation pages. Let's learn about
    them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring pymunk's built-in classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, we will start with the `Space` class. This class refers to the placeholders
    where all your game characters will reside. The movement of the game characters
    will also be defined within this space. The properties of rigid objects (with
    physical properties such as mass, friction, elasticity, and inertia) will change
    in this space as we begin to progress in the game. For example, an object in a
    different space will have different velocity and acceleration. In the case of
    the Angry Birds game, the velocity of an Angry Bird will differ from when the
    player initially slung it from the catapult to it then colliding with the structures
    in the game (beams and columns, which we will cover in a minute).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many methods defined inside the `pymunk` modules, so we will start
    with the most important one: `add_collision_handler(collision_type_a, collision_type_b)`.
    Recall from [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle
    – Snake Game UI with Pygame*, that you made a Snake game and added the collision
    handler by yourself, adding some logic that implies that *When the position of
    two objects is the same, they are said to have collided*. This method is a way
    of doing the same thing in an easier way, which is just by calling the `pymunk`
    built-in function. This collision handler that''s made by `pymunk` will take two
    arguments: `type_a` and `type_b`. You must remember that these two types are integers.
    We will use them to define two objects explicitly. For example, in the Angry Birds
    game, there will be three main characters: Bird, Wood, and Pig (to download the
    required assets, check the GitHub link mentioned in the *Technical requirements*
    section). Since we have three characters, we have to add a collision handler for
    each of them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**When Bird and Pig collide**: We will call `add_collision_handler(0, 1)`,
    where `0` indicates the integer type of the Bird character and 1 represents the
    integer type of the Pig game character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When Bird and Wood collide**: We will call `add_collision_handler(0, 2)`,
    where `2` indicates the integer type of the Wood game character. (Remember that,
    throughout the game, 0 must represent the Bird character and must not be used
    for any other character).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When Pig and Wood collide**: We will call `add_collision_handler(1, 2)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing this, we will get to feel the power of the collision handler defined
    inside the `Space` class. This function checks whether two objects collide and
    returns `CollisionHander` for collisions between objects represented by `type_a`
    and `type_b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned about handling collisions in pymunk, we will learn
    about two of the most important and most used classes of the `pymunk` module:
    `Body` and `Shape`. Firstly, we will start by learning about the pymunk `Body`
    class and its properties. Then, we will explore the pymunk `Shape` class, where
    we will learn how to add different physical properties such as elasticity, mass,
    and moment to geometrical figures.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the pymunk Body class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When making complex games such as Angry Birds, we have to define multiple game
    characters, such as the Bird, Pig, and Wood structures. The following illustration
    provides a visual of these game characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/435e22c6-65cf-4688-aaf9-6dd2d3186c91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All of these are images (in the sense of Pygame, they are sprites). They can''t
    be used directly until and unless we convert them into rigid bodies. The way that
    Pygame defines physical measurements (mass, motion, friction, and impulse) means
    that it will convert these sprites into rigid bodies. Here comes the power of
    the `Body` class: the `Body` class takes any shape (circular, polygon, sprites,
    and so on) and injects properties such as mass, moment, force, and many more,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we started by defining `space`. As we mentioned previously,
    `Space` is a class that represents the placeholder for the objects. Take a close
    look at the `space.add(body, object)` statement: we have used the `add()` method
    to add the object to the `space`. Similarly, we made an instance of the `Body`
    class. The `Body` class does not necessarily mean the objects or game characters;
    rather, it is a virtual place where we can add game characters. The `object =
    pymunk.Circle(body, 4)` statement will create a circular object with a radius
    of `4` units and will add it to the scope of `Body`. After creating the circular
    objects, we added density (the intensive property of the object: mass per unit
    volume occupied by an object; please refer to the following link to learn more
    about density: [https://www.nuclear-power.net/nuclear-engineering/thermodynamics/thermodynamic-properties/what-is-density-physics/](https://www.nuclear-power.net/nuclear-engineering/thermodynamics/thermodynamic-properties/what-is-density-physics/)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the `density` property to the objects, we printed the two bodies:
    the first one when the body was not added into the space and another circular
    body (along with `density`) added to the space. We printed both bodies. As expected,
    the first bodies were not into space and we didn''t define any properties for
    that body, and so its mass and moment were displayed as zero. Similarly, after
    the body was added to `space`, their mass and moment changed to 101 and 804 standard
    units, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn about another important class of the `pymunk` module, which
    goes by the name of `Shape`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the pymunk Shape class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three different class categories that come under the `Shape` class:
    `Circle`, `Poly`, and `Segment`. However, learning about the `Shape` class itself
    is enough for us to understand these categories. Let''s learn about a few important
    physical properties (all in lowercase) that we can call upon the shapes from the
    following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`copy()`: Performs the deep copy of the current shape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`density`: The density of shapes. An extremely important property that calculates
    the mass and moment of inertia of a body from which shapes are attached. We looked
    at an example of this in the *Exploring* the *pymunk Body class* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elasticity`: Defines the elasticity of a shape. This property is used to define
    the bouncing nature of shapes. If the elasticity value is 0, that shape cannot
    bounce. For a perfect bounce, the value of elasticity should be 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`friction`: Defines the `friction` coefficient for a shape. A `friction` value
    of `0` defines a frictionless surface while `1` defines a perfectly fine (no rough)
    surface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mass`: Defines the weight for a shape. When `mass` is higher, the object cannot
    bounce and move freely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`moment`: Calculates the moment for a shape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To observe the application of the preceding properties, we don't create instances
    of the `Shape` class. Instead, we use the `Circle`, `Poly` and `Segment` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Circle` class (which we used in the previous section) can be instantiated
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Properties such as density, elasticity, friction, mass, and moment can be also
    defined in the case of circular objects. We will see an example of this while
    making the Angry Birds game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can create a polygon shape using the `Poly` class. The following
    syntax represents the creation of instances using the `Poly` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, `body` is the instance of the `Body` class which
    represents the virtual space for the shape. The `vertices` argument defines the
    vertices for the convex hull of the polygon. A convex hull is calculated by the `Poly`
    class using vertices automatically. The remaining two arguments, *transform* and
    *radius*, are optional. `transform` is an object of the `Transform` class (refer
    to [http://www.pymunk.org/en/latest/pymunk.html#pymunk.Poly](http://www.pymunk.org/en/latest/pymunk.html#pymunk.Poly)
    to find out more about `transform`), which applies the transform to each vertex
    of the polygon, while the `radius` argument sets the radius of the created poly
    shape.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering what the application of the `Poly` class will be while
    making the Angry Birds game. In this game, we have two main characters, as well
    as the wood structures, consisting of beam and column, which are made using the `Poly`
    class. More on this will be discussed when we start making the Angry Birds game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have another useful class, known as the `Segment` class. Let''s
    explore how its instance is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As its name suggests, the `Segment` class is responsible for defining a line
    segment shape between two points: `point1` and `point2`. It is an important class
    since it defines the surface for the game. The `radius` argument defines the thickness
    of the line segment drawn from `point1` to `point2`. Several aforementioned properties,
    such as `mass`, `density`, `elasticity`, and `friction` can also be added to this
    shape. Mostly, friction is used to define the roughness of the surface while creating
    the surface of the game. Even in the Angry Birds game, we can create a game surface
    using the `Segment` class and associate the body with some level of friction (0—1),
    which defines the level of fineness and roughness of the surface. The value of
    0 represents 100 percent fine, while 1 represents totally rough.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are fully equipped with all the classes and properties associated
    with the `pymunk` module, we can start coding our Angry Birds game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a character controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't played Angry Birds yet, I highly encourage you to do so. Search
    for Angry Birds online and play it for a few minutes. While playing the game,
    observe the main characters (bird and pig), their actions, and their interaction
    with wooden structures. The wooden structures are made of different beam and column
    structures where a different number of wooden structures are dovetailed, one after
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: After you've taken a look at the original game, you can start coding your own
    Angry Birds game. We made the Angry Bird project previously, in PyCharm, while
    installing the `pymunk` module. We will use the same project folder to create
    this game. Create a new Python file and name it `characters.py`.
  prefs: []
  type: TYPE_NORMAL
- en: In this Angry Bird project, we are not going to write whole pieces of code within
    a single file. While coding complex games such as Angry Birds, it is important
    for us to create different modules for different tasks. Doing so, we can easily
    find bugs while testing our game. In this Angry Birds game, we will create four
    Python files: `characters.py`, `polygon.py`, `main.py`, and `level.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first file, which we just created, will contain the main game characters:
    Bird and Pig. The wooden beam and column structures will be created in the next
    file; that is, `polygon.py`. But for now, let''s concentrate on the `characters.py`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `characters.py` file will contain two classes: one for `Bird` and another
    for `Pig`. Then, we will define several attributes that govern the movement, that
    is, the physical property, for each of these classes. The following code represents
    the content of the `characters.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing the necessary modules, let''s define the class for the `Bird`
    character (Angry Bird movement is handled by the player who is playing the game):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding line of code, we defined all the physical and positional attributes
    for the Angry Birds character. We start by defining the constructor. The arguments
    for the constructor are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`distance` between the two body positions, usually calculated by the distance
    formula ([https://www.purplemath.com/modules/distform.htm](https://www.purplemath.com/modules/distform.htm))
    and passed to the `Bird` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angle` in degrees to perform the movement of the `Bird` character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`x_pos`**, **`y_pos`** represents the position of `Bird`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`space` represents the `space` object where `Bird` is rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the constructor, we have added multiple physical attributes to the `Bird`
    character. For example, `elasticity= 0.95` represents the bouncing capability
    (standard), `friction = 1` (level of roughness of surface), power = work done
    (distance) * time (53). The mass (weight) of the Bird is 20, and the `birdLife` class
    attribute represents the quantity that reduces whenever the Bird character collides
    with the ground or other characters (Pig or the wooden structures).
  prefs: []
  type: TYPE_NORMAL
- en: The values of friction, elasticity, and work done are not random (I didn't use
    them arbitrarily). They are defined on the official documentation page. Refer
    to the following URL to explore the chart: [http://www.pymunk.org/en/latest/pymunk.html#pymunk.Shape](http://www.pymunk.org/en/latest/pymunk.html#pymunk.Shape).
  prefs: []
  type: TYPE_NORMAL
- en: The two important methods of the `Bird` class (highlighted in the preceding
    code) are the built-in functions defined by the `pymunk` module. The first method,
    `moment_for_circle()`, calculates the moment of inertia (the resistance of any
    physical object to any change in its velocity) for the hollow circle. The argument
    that's passed to the function is the *mass* of the object; that is, the *inner
    radius* and the *outer radius*. Observe the inner radius, which is passed as `0`,
    which means the Angry Bird (the main character of the game is a circular solid
    circle). If the inner radius is `0`, it means this is a solid circular object.
    The outer radius defines the circular dimension of the Angry Bird. Similarly,
    observe the `collision_type = 0` attribute. This statement will add the integer
    type to the Bird game character. When checking collisions between two objects
    with `add_collision_handler(type_a, type_b)`, we use this collision type value
    to indicate that the `0` value for the character is `Bird`. For the `Bird` character,
    we have a collision type equal to `0`. The `Pig` class will have its collision
    type defined as `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the next method, `apply_impulse_at_local_point(impulse, point = (0,
    0))`, will apply a local impulse to the body. This, in turn, will represent how
    much the momentum of the angry bird will change when force is provided. Refer
    to [https://study.com/academy/lesson/impulse-definition-equation-calculation-examples.html](https://study.com/academy/lesson/impulse-definition-equation-calculation-examples.html)
    to learn more about impulse and momentum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define the class for the `Pig` character. The following code
    should be written just after the `Bird` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is similar to the `Bird` class. Like before, we defined the
    same level of elasticity and friction as the `Pig` character. We added the inertia
    and mass effects to the object. For the `Pig` character, the `collision_type`
    is added as `1`, which means that while checking the collision between Pig and
    Bird, we can simply call `add_collision_handler(0, 1)`, where `0` represents Bird
    and `1` represents Pig.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created two main classes for the Angry Birds game, that is, `RoundBird`
    and `RoundPig`, inside the `characters.py` file, we will create another game character,
    that is, the wooden structures (beams and columns).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Polygon class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For each of the game entities, we have created separate classes, that is, Bird
    and Pig. Since our final game entity is a wooden structure (that the player shoots
    at with the slingshot), we will make a different Python file and create a class
    for this entity. But before that, let's go through one of the important concepts
    regarding sprite sheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Images that are used in Python game development are usually called sprites,
    and they are the static images on which some manipulation (vectored movement)
    is done based on the user''s actions (such as moving the snake when clicking the
    arrow keys on the keyboard). In the preceding chapters ([Chapter 12](6eb72797-e976-49b0-878f-4db620a59aca.xhtml), *Learning
    About Character Animation, Collision, and Movement*, and [Chapter 13](fd4aec28-0e3c-4ba1-924a-56b9d53edd5a.xhtml),
    *Coding the Tetris Game with Pygame*), we used sprites (single images), but not
    sprite sheets (sheets containing multiple static images). The following is an
    example of a sprite sheet, and is specific to our Angry Birds game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8fc3993a-cdcb-416e-8e57-0c281a714bcb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These image files generally don''t contain a single image of a game character.
    As you can see, they usually contain a large number of distinct game characters.
    But most of the time, we will only require a single image from the entire sprite
    sheet. Thus, the question is, how can we extract a single image from such sprite
    sheets? We do so using the `Rect` class of the `Pygame` module. Do you remember
    the `Rect` class ([Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo
    Turtle – Snake Game UI with Pygame*) from the Pygame module? This class creates
    a rectangular object based on the left, top, width, and height dimensions. To
    extract an image from the aforementioned sprite sheet, we will draw a rectangle
    around one of the sprites, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b14363a3-3d91-4b5b-8802-46f4df5f996e.png)'
  prefs: []
  type: TYPE_IMG
- en: This mapping is done with the help of the `Rect` class. The `Rect` class will
    create a rectangle with the dimensions of four points on the screen (left, top,
    width, and height). In this way, by altering any four dimensions of the `Rect` object,
    we can extract the part or sub-surface of sprite sheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see this in action by creating a wooden structure. To begin, download
    the sprite assets from the following GitHub link: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15/res](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15/res).
    You will see various images, along with code assets. There will be two folders
    inside the `res` folder: one for photos and another for sound. You have to copy
    the entire folder and paste it into the Angry Bird project folder in the PyCharm
    editor.'
  prefs: []
  type: TYPE_NORMAL
- en: After you've imported the resources, I suggest that you open the `wood.png` file.
    This file contains different wooden structures. When creating a polygon out of
    these wooden structures, we have to crop one of the images using the `Rect` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same Angry Bird project, create another Python file with the name `polygon.py`.
    We will start by importing the necessary modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the `Polygon` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The attributes we''ve defined for the `Polygon` class are quite similar to
    what we did for the `Bird` and `Pig` classes: we initialized friction and added
    the `collision_type` so as to reference the Polygon shape with an integer of `2`.
    The constructor takes an argument, that is, `po*s*ition`, to tell us about the
    position of the polygon to render, the `length` and `height` of the polygon, the `space`
    object where the polygon will be rendered, and the `mass` for the polygon shape.'
  prefs: []
  type: TYPE_NORMAL
- en: The only novel thing in the preceding code is the highlighted part of the code.
    We have loaded the `wood.png` and `wood2.png` images into the Python project using
    Pygame's `load` method. The `convert_alpha()` method acts as an optimizer and
    will create a new image surface that is suitable for quick blitting. The `Rect`
    class takes four dimensions to create a rectangular surface (refer to [Chapter
    11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake Game UI
    with Pygame*). The dimensional values that are provided aren't given randomly
    and represent the values that cover the subsurface of the sprite sheets that we
    need to extract. For example, the `self.beam_image = wood.subsurface(rect).copy()` command
    will extract the horizontal beam image (the piece of wood enclosed by a red rectangle)
    from the `wood.png` file, as follows;
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d6bcbc7a-2df6-4a23-a251-a9414936d9de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have extracted horizontal and vertical wooden images (a beam and
    a column, respectively), we can start drawing a polygon containing them. However,
    there''s a problem. Since, although we have been using Pygame and `pymunk` together,
    their coordinate systems are not alike: `pymunk` uses a coordinate system with
    the origin at the bottom left, while Pygame, as you probably already know, uses
    a coordinate system with the origin at the upper left. Thus, we will make a function
    that will convert the `pymunk` coordinate system into a compatible Pygame coordinate
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function is important because the game surface will be made out
    of the `Pygame` module. Thus, we must track the position where the beam and column
    must be rendered. Now, let''s start drawing the `polygon` into the surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function will be used to place a beam on the screen in which
    an object is passed as an argument to it. The first argument to the function is
    *element*, which tells the function which polygon to draw: is it a beam or a column?
    We will add some logic to the draw column in the following code, but for now,
    let''s observe what we have written so far. The code starts by getting the *shape*
    object. Then, we check whether the element is `beam`. If it is `beam`, then we
    get the position of the image and convert it into the `Vec2d` coordinate position.
    The highlighted part of the code (getting the angle to rotate the beam image)
    will ensure that the image of the beam is within the red rectangular (virtual)
    area, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/26e3cbaf-cfb1-4870-bf97-c7e89d53e932.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Just remove that highlighted line from the preceding code and observe the result.
    You will see that the beam won''t be perfectly aligned because of the offset of
    the `Vec2d` coordinate system. Similarly, let''s add some code so that we can
    draw the column to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the first couple of lines will convert the `pymunk`
    coordinates into Pygame. Since column should be rendered in the Pygame surface,
    this conversion is necessary. Similarly, after getting the position coordinates,
    we take an angle of coordinate and make sure to add 180 or 0 to it so that it
    remains an original image with no rotation. After getting that image, we transform
    it and create a new image as a `rotated_column` image. Remember that if the rotating
    angle is not a multiple of 90, the image will be distorted. In the preceding line
    of code, if `offset` is not removed from the rotated image, the image will move
    down the surface, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/57833fcb-c2b1-4370-a67a-c2dcda32c369.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, the red line represents the surface. Thus, if you
    do not remove the offset from the column's body position, the column will be displayed
    below the surface.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finished the `Polygon` class, which will render either a beam
    or a column whenever the `draw_poly()` function is called from the main class,
    it's time to make our main class, which is the director of all the classes. This
    class will be responsible for creating instances of all the classes and for calling
    the methods that are defined inside different classes to render game objects into
    the Pygame game surface.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Pythonic physics simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, let''s start by revising what we have done so far. We started by
    defining two main game entities: `Bird` and `Pig`. All of the major physics properties,
    such as mass, inertia, and friction, were defined for each of these characters
    so as to simulate real-world physics. After creating the two major game characters,
    we made another Python file so that we could create the `Polygon` class. This
    class was created to render the wooden structures in the game with the help of
    beam and column. Now, we are going to create another Python file with the name
    `main.py`. This will be the main controller of the game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to declare the base physics in the `main.py` file. We
    will start by importing some essential modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing the necessary modules, we need to crop some subsurfaces from
    the sprites that we added previously. Obviously, we don''t want everything from
    the sprite sheets, and so we will be extracting only parts of them to create game
    characters. However, since our main character, our Angry Bird, only has a single
    image and is not present in the sprite sheets, we don''t need to crop the image
    for the Angry Bird and the slingshot. However, for the `Pig` character, we have
    to create a `Rect` object because the `Pig` images are bundled together in a sprite
    sheet. Thus, we will have to load the images by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we started by defining a game screen using the Pygame
    module. After that, we loaded all the images that exist as a single image but
    not the sprite sheets, such as `red-bird3.png`, `background3.png` and `sling-3.png`.
    As we mentioned previously, the image of the pig is part of a bundle of images
    in `full-sprite.png`. Since we need only one image of the pig, we will perform
    a similar process the one we carried out while extracting beam and column. We
    will create a `Rect` object with the exact dimensions of the pig's shape and then
    use it to extract a pig image from the sprite sheets. Then, we will crop that
    image and store it as a cropped object, which will eventually be transformed so
    that is has a height and width of `30`, `30`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have extracted the necessary images for the game objects, let''s
    get down to business by declaring the physical variables and positional variables
    for each of these objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know, the Angry Birds game is played by using a mouse to stretch the
    catapult in a slinging motion. Thus, we have to declare some variables that will
    take care of these sling actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have defined different variables so that we can track
    the position of the mouse before and after the sling action. The `sling_action()`
    function, which we will declare afterward, will manipulate these values. For now,
    let''s create a list that will track the number of pigs, birds, beams, and columns
    that are displayed in the space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have defined all the necessary variables for the Angry Birds game
    (we will add more variables later if needed), it''s time to create a surface for
    the screen. This surface is not a background surface; instead, it''s some ground
    in which all the structures will reside. The Angry Bird will also bounce off this
    surface, and so we have to add some physical properties to this ground, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code will create some static ground. While instantiating
    the static body, we can explicitly set `body-type` as `STATIC` by adding the `pymunk.Body.STATIC` constant.
    After defining the static body, we have to use the `Segment` class to create a
    line segment between one point and another (recall the `Segment` class from the *Exploring
    the pymunk Space class* section). For each line segment, we have added `elasticity` to
    support the bouncing property, `friction` to indicate the roughness, and `collision_type`
    to check whether other game objects have collided with the ground surface or not,
    which will be checked later, in the *Checking collision* section. After creating
    these static surfaces, we will add them to the `Space` object, which will render
    them onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the static surface, we need to define the sling action, that
    is, what happens when the player stretches the rope of the catapult. We will implement
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the sling action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to implement the sling action. The player is
    going to interact with the game character through the sling action. But before
    implementing the sling action, we have to take care of a few things: how far can
    the player stretch the rope of the catapult? What is the angle of impulse (the
    track of motion after the player releases the rope)? What is the distance between
    the mouse action point and the rope''s current stretch point? All of these things
    must be addressed by declaring functions. First of all, we need to convert pymunk
    coordinates into Pygame coordinates so that we can align the game objects with
    the screen properly (the reason for this conversion was discussed in the *Creating
    the Polygon class* section).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function will convert the `pymunk` coordinates to Pygame coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Although pymunk''s *x*-coordinates are the same as Pygame''s *x*-coordinates,
    due to pymunk''s origin being at the bottom left, we have to change it to the
    upper left. Similarly, let''s define another function, that is, `vector`, which
    will convert the passed point into a vector. The following code represents the
    implementation of the `vector` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to [Chapter 9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml), *Data Model
    Implementation*, to find out more about how vectors are created using positional
    vectors. Here, the arguments *a* and *b* represent the points that are converted
    into vectors from the reference point. Now that we have created a vector, let''s
    define a function that will return the distance between two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will calculate the distance formula between two points, that
    is, `(x0, y0)` and `(x1, y1)`, using the `sqrt((x1 - x0) + (y0 - yo))` distance
    formula, where `sqrt` represents `square root (math.sqrt(4) = 2)`. The ** operator
    represents the power. For example, `dx ** 2` is equivalent to `(dx)²`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve calculated the distance, we need to learn how to calculate
    unit vectors. A unit vector is a vector that has a magnitude of 1\. We don''t
    really care about the magnitude, but the significance of a unit vector is that
    it tells us about the direction of the vector. Once we have a unit vector, we
    can amplify it by any factor to achieve the new vector in that particular direction.
    While creating the sling action, having knowledge about the unit vector is important
    as this will give us information about the direction the catapult is stretched
    in. To find the unit vector in the same direction as a vector, we have to divide
    it by its magnitude. Using mathematical deduction, let''s build a function and
    create a unit vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the value of h is determined by the `sqrt(a^2 + b^2)` magnitude
    formula. To find the unit vector, each component of the vector (`v[0]`, `v[1]`)
    is divided by the magnitude (`mag`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have declared different functions to define the position, magnitude,
    and direction for the sling action, we can begin to define the method that performs
    the sling action. The following picture represents the catapult, which has two
    ends but no rope attached to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6db8057c-d225-45c0-9c97-58a21268b9e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, our main task will be to add bird (the main character) to this catapult
    and to define the position for it. Let''s start by defining some globals inside
    `sling_action`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, we have declared some globals. However, these
    attributes were initialized with some initial values at the beginning of the *Exploring
    pythonic physics simulation* section. This means we will have to do some manipulation
    to update the values of these variables. The `mouse_distance` variable will contain
    the distance value from the point where the catapult is at rest to the point where
    the player stretches the rope of the catapult. Similarly, `rope_length` represents
    the length of the rope when it's been stretched by the player. The angle represents
    the angle of impulse, which is calculated as a slope angle. The slope for the
    rope of the catapult represents how steep the rope is when it's stretched by the
    player. `mouse-x-pos` and `mouse-y-pos` represent the current position of the
    mouse when the rope of the catapult is stretched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to address three things in this `sling_action` function:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the Angry Bird to the rope of the sling (as shown in the following screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the bird stay on the rope, even when the rope of the sling is stretched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Address a situation where the rope of the sling is fully stretched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To understand what these events are, take a look at the following picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5635bd69-faaa-46bf-8169-e990b113e4c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s address all of the preceding actions in the `sling_action` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will create a view for the Angry Birds character in the sling
    action. First of all, the `v` vector is created by the two coordinate points (`sling_original`,
    `mouse_current`) for example, ((2, 3), (4, 5)), where (2, 3) represents the sling
    at the static position or the center point of the sling, while (4, 5) represents
    the position when the mouse action is activated by the player. We will create
    a unit vector from this vector to understand the direction of stretch made by
    the player. Then, we will calculate `mouse_distance`, which will be calculated
    by calling the previously defined `distance()` function. This distance represents
    the distance from the static sling's center to the current mouse position. The
    (`mouse_x_pos`, `mouse_y_pos`) value represents the final position for the bird
    after the rope has been stretched. The `uv_1` and `uv_2` unit vectors will ensure
    that the bird will remain on the rope, which is indicated by the mouse's position.
    For example, if the mouse pointer is pointed upward, the rope and the bird will
    stretch in an upward direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, let''s address the second scenario, that is, making an Angry Bird
    remain on the rope, even when the rope has been fully stretched. We will implement
    it in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A lot is going on in the preceding code, but the actions are easier and more
    mathematical. You must try to understand the logic rather than trying to understand
    the syntax. Let's delve into the code and uncover the reason behind each line
    of code. We start by decrementing the mouse position by 20 units to make sure
    that, while stretching, the bird remains at the edge of the rope. Try changing
    this value to 40 and observe the effect. Next, we checked whether `mouse_distance`
    is greater than `rope_length` to make sure that the distance of the stretch is
    within the limit. We don't want the mouse distance to be greater than the maximum
    rope length. In this situation, we will take the mouse distance and decrease it
    until and unless it comes under the maximum length of rope.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we will `blit` the redbird (Angry Birds image) at the end of the
    rope. Similarly, we have to `blit` the rope too. In the preceding picture, observe
    the rope pull where the rope has turned red. This red color will be created if
    we `blit` the rope from the center of the static sling to the maximum possible
    rope length. Observe the bold part of the code; we have drawn a line that represents
    the rope with the color code (255, 0, 0), that is, red. There are two statements
    for this: one on each side. Thus, we have implemented the condition where the
    user will stretch the rope to its maximum defined length.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to address the third and last scenario, that is, what happens
    when the player stretches the rope to its maximum length? In the preceding line
    of code we checked `if mouse_distance > rope_length`, and thus if the player stretches
    to less than `rope_length`, it should be addressed in the `else` part of the code,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the previous code, we make the distance no less than 10, which means
    that when the user even slightly stretches the rope, its `mouse_distance` will
    be equal to or more than 10\. Then, we create `third_pos` to define the position
    in which to render the rope and the Angry Bird. `uv_1` and `uv_2` are unit vectors
    that indicate the direction of stretch. After getting the position, we `blit` the
    Angry Bird and then draw a line to indicate the rope. This will be in black and
    will be done on the front and the back.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined the scenario for all our cases, let's add a line of
    code to calculate the angle of impulse. This angle will be made whenever there
    is stretch in the rope. The tan (angle of impulse) is equal to the slope of the
    stretched rope. The slope is defined as the rise by run or (`dy`/`dx`), where
    `dy` is the change in `y` and `dx` is the change in x. Thus, the angle of impulse
    can be calculated as `tan^(-1)(dy / dx)`. To learn more about the origins and
    application of this formula, check out [https://www.intmath.com/plane-analytic-geometry/1b-gradient-slope-line.php](https://www.intmath.com/plane-analytic-geometry/1b-gradient-slope-line.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this formula to calculate the angle of impulse, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding angle of impulse will be necessary to determine the path of the
    Angry Bird after the sling action is performed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have completed the sling action. Now, let's hop over to the next
    section, where we will address a collision between two game objects.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recap, answer the following question: When do we know when two game objects
    have collided? Do you have your answer? Whenever two objects are in the same location
    within the coordinate system, they are said to have collided. However, in the
    case of pymunk, we don''t have to check whether a collision has occurred or not.
    Rather, a single method call will check this for us. For example, a call to `space.add_collision_handler(0,
    1)` will add a collision handler to check whether there has been a collision between
    the Bird and Pig characters. Here, the `0` integer represents the `collision_type` that''s
    defined inside the `Bird` class. The `collision_type` that''s defined for the
    `Pig` class is `1`. Thus, these `collision_type` must be unique so that each game
    entity can identify them uniquely.'
  prefs: []
  type: TYPE_NORMAL
- en: Although we have an easier method for adding a handler to check collisions,
    the program still asks for the details; that is, what happens when two game objects
    collide? What actions must be performed? This is resolved by using `post_solve`.
    We will explicitly tell the collision handler that if there is a collision between
    *X* and *Y*, then a specific method should be called; for example, `space.add_collision_handler(0,
    1).post_solve = perform_some_action`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define each of these actions whenever there is a collision between game
    objects. We will start by defining an action that must be performed whenever there
    is a collision between Bird and Pig. Let''s write a function to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the method takes an object of the Arbiter class: `arbiter`.
    The `arbiter` object will encapsulate all the colliding objects/shapes and even
    store all of the colliding object''s positions. Since the game objects are drawn
    into the Pygame screen, we need to know their exact location in terms of the Pygame
    coordinate system. Thus, a conversion is made from pymunk coordinates into Pygame
    coordinates. Similarly, the process that we defined for the `post_solve` function
    is to address the action that must be performed instantaneously after the collision
    between Pig and Bird. The action will reduce the health of pig and then eventually
    remove it from the space. The `space.remove()` statement will remove the game
    objects from the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, let''s define another action that must be performed after the collision
    between Bird and the wooden structure. Similar to the preceding code, after a
    collision, the wooden beams and columns must be removed from the space or screen.
    The following function will address such actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Similar to before, the `arbiter` object will hold information about the colliding
    shapes and positions. Here, the `total_impulse` attribute will return the impulse
    that was applied to resolve the collision. To find out more about the `Arbiter`
    class, go to [http://www.pymunk.org/en/latest/pymunk.html](http://www.pymunk.org/en/latest/pymunk.html).
    Now, after getting the collision's impact, we will check whether `arbiter` has
    a shape of either `beam` or `column` since the arbiter object will contain the
    list of the collided object. After looping through the `beam` and `column` stored
    inside the `arbiter` object, we will remove it from the space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will address the last collision—an action that must be implemented
    when `Pig` has collided with the wooden structure. Let''s add a method to implement
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the previous two methods, this function will also check the content
    of the `arbiter` object, which is responsible for encapsulating all the information
    regarding the shape of collided objects and the position at which the collision
    happened. Using the content of the `Arbiter` class object, we have checked the
    length of after impact and then either removed or decreased the life unit of the `Pig`
    character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add a collision handler. Since we have declared all the
    `post_solve` actions that must be performed after a collision between two objects,
    let''s add it to the collision handler using `post_solve`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After adding the collision handler, all we need to do is add an event handler
    that handles the events of the player who's playing the game. But before that,
    it is easier to work on the levels. What I really mean by level is to create a
    structure using beams and columns. Although we extracted the beams and columns
    from the sprite sheets, we never created a structure out of them. Let's create
    some wooden structures using beams and columns.
  prefs: []
  type: TYPE_NORMAL
- en: Creating levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not only have we created three major game entities, but we have also made a
    collider handler and `sling_action` function. But we aren''t done yet. We have
    to add wooden structures to the space with the help of `beam` and `column` game
    objects. `beam` is a horizontal wooden rectangular structure while `column` is
    a vertical wooden rectangular structure. In this section, we''ll create another
    class and define a level for the game by defining different wooden structures.
    You will have to create a new Python file and name it `level.py`. In that file,
    start writing the following code to define the wooden structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing the essential modules, we can start creating a `Level` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the aforementioned code, we have created a `Level` class with a constructor
    that takes `pigs`, `columns`, `beams`, and `space` as arguments. These arguments
    must not be foreign to you. All of these represent the objects of different classes.
    Similarly, we initialized the class variable using a constructor. The use of the `number` attribute
    will be discussed in a minute. It won''t make sense describing its usage until
    and unless we use it. There is another attribute with a `total_number_of_birds` signature,
    which represents the number of Angry Birds that must be available for the player
    to project with the catapult. Now, let''s build the first level for the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have arranged `beam` and `column` in a window fashion
    (one layer on top of another). We also added two pigs inside the structure. To
    create such beams and columns, we have to create instances of the `Polygon` class
    (which we made in the *Creating the Polygon class* section). Although the code
    that's written inside the function seems lengthy, no novel logic is created here.
    We have just instantiated different beams and columns and provided a position
    to render. The value of `pos` is a tuple that represents the position in the space
    where the polygon should be placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create another method inside the same `level.py` file and call
    this level `0`. Remember that this is the method of the `Level` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, here is the application of the number attribute that we initialized
    while creating the constructor of the class. This `load_level()` method will perform
    string concatenation to build the function name that represents `level_levelNumber`.
    For example, the highlighted part of the preceding code will yield `build_name
    = "build_0"  [initially number = 0] and getattr(self, "build_0)()`, which is equivalent
    to `build_0()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`get_attr(object, p)` is equivalent to `object.p`. This method is important
    if you feel that there might be an Attribute Error exception. For example, `get_attr(object,
    p, 10)` will return 10 if there is an exception. Thus, this method can be used
    to provide a default value. Attribute Error occurs when an attribute with the
    given name doesn''t exist in the object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this `load_level()` method should be called explicitly from a file, we
    will do this in the `main.py` file. Open your `main.py` file and then continue
    with the code from where we left off. Write the following code to call the recently
    made `load_level()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, we import the `Level` class from the `level`
    module. We create an instance of the `Level` class by passing a list of `pig`,
    `columns`, `beams`, and `space`. Similarly, we assign an initial value of `number`
    equal to `0`, which means that the beginning of the `build_0` method should be
    called by the `load_level()` method. You can increment the value of `number` by
    adding more difficult levels.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've loaded the level into our `main.py` file, it's high time to handle
    user action events. We will handle mouse events using Pygame in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling user events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to handle user events. This won't be new to you.
    Ever since [Chapter 5](91942969-08b5-4e2d-a64e-3cd3a513b950.xhtml), *Learning
    About Curses by Building a Snake Game*, we have been handling user action events
    in various cases. While building the snake game, we handled keyboard events, and
    for Flappy Bird, we handled mouse tapping events. While handling those events,
    we found that the easiest and most universal way of doing this was by using the `pygame`
    module; it was just one line of code where we had to listen for the incoming actions
    and handle them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'But in the case of Angry Birds, handling mouse actions is a little bit tricky.
    Problems arise when we take the mouse action beyond the scope of space and try
    to perform a sling action. This must not be allowed, and so we have to check whether
    or not the mouse action should be associated with the sling action (the previously
    created function that pulls the rope of the catapult). Thus, let''s learn how
    to handle the input events of the user by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve checked for `QUIT` action events, we can get to mouse event
    handling (when the user uses the mouse to project the Angry Bird from the catapult):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we start off by checking whether the mouse action is
    within scope. We check whether the mouse click is within the scope of space of `(mouse_x_pos
    > 100 and mouse_x_pos < 250 and mouse_y_pos > 370 and mouse_y_pos < 550)`. If
    it is, we will assign a Boolean of `True` to the `mouse_pressed` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will perform the action to release the bird from the catapult or sling.
    After releasing each bird, we check whether any other birds are left or not. If
    there is, we decrease the number of birds by one and assign the value of *x-initial,
    y-initial* = 154, 156, respectively. These values are the center coordinates of
    the sling when the sling is at rest. Now, when the sling is stretched, there will
    be a new value, which we will call `mouse-x-pos`, `mouse-y-pos`. Remember that
    we don''t have to calculate the distance from (`mouse_x_pos`, `mouse_y_pos`) to
    (`x-initial`, `y-initial`) because we did this while creating the `sling_action`
    function. Thus, we will use the `mouse_distance` we calculated there to perform
    the bird release action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are adding the current `Bird` object that''s attached
    to the rope to the birds list. This list will provide us with information about
    the current bird distance from the center of the catapult, the angle of impulse,
    and the `space` object. Now that we have handled the input actions of the player,
    let''s `blit` every object into the space with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we got the current mouse position (the position in the
    space for the mouse action). Then, we drew the background with the background
    image that we loaded previously. Similarly, we `blit` the sling image into the
    screen. Now, we have to `blit` the Angry Birds that are waiting in line to be
    placed in the sling, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/16caf933-bc34-4ec3-902d-99d371fb6621.png)'
  prefs: []
  type: TYPE_IMG
- en: Since `total_number_of_birds` is an attribute that's defined inside the `Level`
    class, we have to use it by creating an instance of it. Until and unless the number
    of birds is greater than 0, we create a list representing the number of birds.
    In the `for` loop code, we have to decrease the number of birds by 1 because one
    bird will be in the sling. After getting the actual number of remaining birds,
    we have to get the position to render these birds into the space. Although the *y*-position
    (height) is constant, that is, 508 units, the *x*-position is calculated by providing
    a space between each of them by `i*35` units, where `i` represents the iterables
    that were created by the `for` loop. For example, for bird number 2, the position
    in the space will be (2*35, 508).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will call the sling action. When the mouse is pressed within the scope
    and the bird possesses some angle of impulse in the space, we have to call the `sling_action`
    method using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If we have `mouse_pressed` and the number of birds is greater than 0, we perform
    the sling action; otherwise, we just `blit` the bird in the position (`130`, `426`).
    In the `else` part of the code, we do not perform a sling action. The way to determine
    whether the sling action must be performed or not is by observing whether the
    mouse has been pressed or not (released) and the `time_of_release` after the release.
    If the current time has a significant difference, we do not perform the sling
    action. If there are differences of a significant amount, that means the bird
    hasn't been released. In order to release the bird, the current time must be equal
    to `time_of_release`. This is the case when we `blit` redbird in the sling just
    before release.
  prefs: []
  type: TYPE_NORMAL
- en: 'After performing `sling_action`, we can track the number of birds and pigs
    that must be removed from the scope with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the highlighted part of the code, we check whether the bird hits the ground.
    If it does, that means we have to append the bird to the `removed_bird_after_sling`
    list. Similarly, we get the Pygame coordinates for the bird character and `blit`
    it in the (`x_pos`, `y_pos`) position. A blue circle is made around the bird after
    the impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we have to remove birds and pigs after impact. Write the following
    code to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, let''s draw pigs into the space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: After the pig hits the ground, we have to add it to the `removed_pigs_after_sling`
    list. We get the position of the body using Pygame coordinates. Similarly, we
    perform a transformation on the `pig` objects. The rotation transformation is
    within 0.5 units. This auto transformation will make the pig move smoothly in
    the space without remaining static. If you change the value of rotation to more
    than 2 units, the pig's position will be drastically deteriorated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two primary game entities have already been rendered into the space; that is,
    pig and bird. Now, it''s time to add some other game entities to the game screen;
    that is, beam and column. We previously made a `beam` and `column` list to track
    the number of beams and columns. Let''s use it to render structures in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to update the physics: how fast the bird should travel after
    the sling action, and how many updates per frame are to be established for the
    stability of the game. First of all, let''s define the time step''s length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previously defined time interval (`dt` or time step interval), observe
    that we have moved the simulation of space forward 50 times with a `dt` of 2 units.
    If you increase the value of `dt` from 2 to 4 or more, the simulation will be
    slower. According to pymunk''s official documentation: *Performing more steps
    by using smaller `dt` creates a stable simulation*. Here, the value 50 represents
    the steps defined and a `dt` of 2 creates a movement of a total of 100 units forward
    into the space. The forward simulation in the space represents the speed at which
    the Angry Bird is projected toward the wooden structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using this time interval, let''s add these steps to the simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `step` method, which is called using the `space` object, will update the
    space for the given time step interval (`dt` or time step interval). Refer to [http://www.pymunk.org/en/latest/_modules/pymunk/space.html](http://www.pymunk.org/en/latest/_modules/pymunk/space.html)
    to find out more about the `step` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s run our game. Click on the Run tab and then click on the `main.py`
    file. The following is the result of running the Angry Birds game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7a557345-aa33-4389-a25e-af62ee6dd70c.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, our game is complete. You can test the different physical attributes
    we defined for the game entities by changing their values and observing their
    results. If I were you, I would probably change the step size value of `dt` and
    check how it affects the simulation of objects. Obviously, changing the value
    of `dt` from lower to higher would make the speed of objects slower after `sling_action`
    is triggered. For example, changing the value of step size (`dt = 4`), you would
    experience the Angry Bird going slower than before. This is due to an increase
    in the simulation forward movement by extra units.
  prefs: []
  type: TYPE_NORMAL
- en: Although our game is perfectly fine to play and test with, there are a few tweaks
    that can be implemented to make our game even more appealing. For example, we
    can add sound effects to the game and add more levels. We'll go over this in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Possible modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When testing our game, it might be the case that there is not much space for
    further modifications. However, I came up with an important one: adding `soundFx`
    to the game. To provide an active experience to the user while they''re communicating
    with the virtual world, sound effects play an important role. With this consideration,
    Python''s `Pygame` module provides an interface so that we can add a soundtrack
    to the game.'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, to add sound effects to the game, we need to load music into the
    game. Check out this book's resource folder on GitHub: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15/res](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15/res).
    Then, check out the `sounds` folder, which will contain music files that can be
    added for the game project. I will use the `angry-birds.ogg` file (you can use
    any file you like—you can even download one off the internet).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will load the music file into your Python project. Make
    sure the code is written inside the `main.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding function definition, we started by defining the path for the
    music file and stored it as a string in the `song_name` variable. Now, to load
    the playback file, we can use the `mixer.music` class, which has a predefined
    `load()` method that will load the song into the Python project. To play the music
    that we have just loaded, we will call the `play()` method. The play method takes
    two arguments: loop and start. Both of these arguments are optional. The loop
    value will be `-1`, which means the loaded music must be played continuously.
    If you want to play music continuously, for example, six times, you can call the
    `play` method with a *loop = 5* argument on it. For example, `play(5)` will make
    the music play 6 times, continuously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s call the aforementioned function within the same `main.py` file.
    You can call it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: That's it if we want to load music into our Python game. Now, you can play your
    game and enjoy the soundtrack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next modification we can make is adding different levels. Go back to the
    Python project and open the `level.py` file. It will contain the `Level `class,
    along with a single function called `build_0`. You can add as many levels as you
    want. In this section, we will add another level for the game and call it `build_1`.
    The following function should be written inside the `Level` class of the `level.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have defined a function that will create a wooden
    structure. Observe the code closely – we have created instances of the `Pig` and
    `Polygon` classes. The pig character was created at the position (1000, 10) in
    the space. Similarly, the three columns were created one after another and aligned
    vertically. The `pos` local variable denotes the position in the space where these
    game entities must be rendered. To create any random structure with the help of
    these game entities, you can test the different values for the `pos` variables.
    However, make sure that the position you defined is within the space and at the
    left-hand side corner of the space. For example, giving a position of (50 , 150)
    would render any game entities closer to the catapult and would not make the game
    competitive. Therefore, while building such structures, make sure that the entities
    are drawn far away from the catapult.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you run the program with the second level, you will see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9d4c448c-af97-457d-8144-795c8bd35bef.png)'
  prefs: []
  type: TYPE_IMG
- en: You can add as many levels as you want. All you need is a bit of creativity
    for making game levels—forming beam and column structures that would be hard to
    break by the player. If you want to add further modifications, you could add a
    score to the game. You could assign some values to the game entities (pig, beam,
    and column) and whenever the bird collides with those game entities, you could
    add that value to the player's score. We implemented similar logic in [Chapter
    12](6eb72797-e976-49b0-878f-4db620a59aca.xhtml), *Learning About Character Animation,
    Collision, and Movement*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our game is playable, and you can test the sound effects and physical
    attributes of each game entity. You can test how the elasticity property has provided
    real-world simulation for the surfaces of the game. You can also test the simulation
    speed of the space. To learn more about the simulation step and step time interval,
    check out the online resources that are available at [http://www.pymunk.org/en/latest/_modules/pymunk/space.html](http://www.pymunk.org/en/latest/_modules/pymunk/space.html).
  prefs: []
  type: TYPE_NORMAL
- en: I had a lot of fun writing this chapter, along with building this game. I hope
    it was the same for you too. In the next chapter, we will learn about other important
    skills that every Python game developer must possess—adding an artificial character
    to the game. This character will play and compete with the human player in the
    same game. To be precise, we will be creating a human-like player in the game
    and adding intelligence to it, similar to what we humans have. The next chapter
    will be an interesting and edifying one. Let's get to it!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how we can create Pythonic 2D physics simulation
    spaces by adding real-world physical attributes to game characters and the environment.
    We began by learning about the fundamentals of various `pymunk` modules, such
    as vec2d, sub-modules, different classes, and attributes that will build 2D rigid
    bodies. These bodies have the ability to simulate real-world object characteristics
    such as mass, inertia, motion, and elasticity. Using these characteristics, we
    were able to provide unique features to each of the game entities; that is, bird,
    pig, beam, and column.
  prefs: []
  type: TYPE_NORMAL
- en: The main aim of this chapter was to make you understand how to use the `pymunk`
    module effectively to create complex games such as Angry Birds. Games such as
    Angry Birds are considered intricate—not because it contains a variety of entities,
    but because they have to simulate real-world physical attributes. Since `pymunk`
    contains different classes to address such an environment, we used it to create
    a game environment, surfaces, and game entities such as Angry Birds, pigs, and
    polygons. In this chapter, you also learned how to handle collisions and movements
    between more than two game characters. So far, we've learned how to create a handler
    to address collisions between two game objects (between the snake and the boundary
    and between the flappy bird and the vertical pipes), but this chapter helped you
    understand how easily a collision handler can be created to address collisions
    between multiple game entities.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be a fun and challenging one. We will be learning about
    how to create **non-player characters** (**NPCs**)—an artificial player who is
    smart enough to compete with human players. We will create these NPCs by defining
    the moves and actions that human players would perform in the same instances.
    For example, when a human player sees a wall in front of them, they will make
    a move to omit a collision. A similar strategy will also be fed into the artificial
    player so that they can make smart moves and be able to compete with human players
    effectively.
  prefs: []
  type: TYPE_NORMAL
