- en: Chapter 2. Productive Shells – Reinvent the way you work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start off with a short introduction to Vim and look
    at the most basic commands to help you get started with basic CRUD (create, read,
    update, delete) operations. We will then upgrade the shell interpreter to zsh
    and also give it superpowers with the awesome `oh-my-zsh` framework. We will look
    at some basic regular expressions such as searching some text using grep. Then,
    we will unleash the power of Unix pipes and run embedded commands using subshells.
    The later part of the chapter will help us understand how we can boost productivity
    and automate a lot of our day-to-day work by showing some of the more advanced
    shell scripting techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Vim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing zsh using the `oh-my-zsh` framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and running super powerful one line commands using pipes and subshells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the shell scripting libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will focus on editing files. For that we need to choose a file editor. There
    are a bunch of options but considering that the fastest way to edit files is,
    of course, without leaving the terminal. We recommend Vim. Vim is an awesome editor!
    It has a lot of configuration options with a huge community that has produced
    lots of plugins and beautiful themes. It also features advanced text editing,
    which makes it ultra-configurable and super-fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s proceed. Open the terminator and type `sudo apt install vim` to
    install Vim:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Productive Shells – Reinvent the way you work](img/image_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Vim is renowned for its exotic keyboard controls and a lot of people avoid using
    Vim because of it. But once you get the basics, it's super easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start `vim` with no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Productive Shells – Reinvent the way you work](img/image_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the default screen; you can see the version on the second line.
  prefs: []
  type: TYPE_NORMAL
- en: To start editing text, press the *Insert* key; this will take us to the insert
    mode, where we can start typing. We can see we are in the insert mode at the bottom
    of the screen:![Productive Shells – Reinvent the way you work](img/image_02_003.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press the *Insert* key again to go to replace the mode and override text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press the *Esc* key to exit insert or replace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type *yy* to copy a line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type *p* to paste the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type *dd* to cut the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type *:w* to save any changes. Optionally, specify a filename:![Productive Shells
    – Reinvent the way you work](img/image_02_004.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To save the file in editing text, type `vim.txt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type `:q` to exit Vim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s open the file again and do a small change:'
  prefs: []
  type: TYPE_NORMAL
- en: '`:wq`: Write and exit at the same time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:q!`: Exit without saving'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now you are familiar with these commands, we can do basic file editing directly
    from the command line. This is the bare minimum that anybody needs to know when
    working with Vim, and we will use this knowledge in the chapters to come.
  prefs: []
  type: TYPE_NORMAL
- en: We will also have an entire section about Vim, where we will go into more detail
    about being productive in the coolest terminal editor today!
  prefs: []
  type: TYPE_NORMAL
- en: Oh-my-zsh – your terminal never felt this good before!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash is probably the most commonly used shell. It has lots of features and powerful
    scripting capabilities, but when it comes to user interaction, `zsh` is better.
    Most of its power comes from the awesome framework `oh-my-zsh`. In this section,
    we will be installing `zsh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started with the `oh-my-zsh` framework and we will be looking at
    some basic configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminator and type `sudo apt install zsh` to install `zsh`, as shown
    in the following image:![Oh-my-zsh – your terminal never felt this good before!](img/image_02_005.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After installing it, go to this link, [https://github.com/robbyrussell/oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh,),
    and follow the instructions for installing the `oh-my-zsh` framework. The installation
    process is a one-line command with `curl` or `wget`. Let''s install it using both
    the command one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Via curl:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Via wget:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that the command is giving an error saying that `git` is not installed,
    so we need to install that too. The following command-line is used to install
    git:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how easy it is to install software in Ubuntu. This is also a big productivity
    booster; every common software package we might need is already prepackaged in
    the remote software repository and it takes us just one command to add new software
    to our computer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have `git` installed, let's run the command again. We can see that
    this time it's working successfully and it's bringing us to our new shell. `Oh-my-zsh`
    also changes the default shell to `zsh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installation, the first thing to do is go pick a theme. To see all available
    themes, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also go to the `git` repo and check out the themes, together with their
    screenshots. We will be using the *candy* theme, because it has a lot of useful
    information in the prompt: *username*, *hostname*, *time*, *folder* and *git*
    branch/*git* status.'
  prefs: []
  type: TYPE_NORMAL
- en: Time can be very useful, for example if you want to know how long a command
    took to execute and you didn't use the *time* utility to measure your command's
    total runtime. Then, you can check out the prompt and see the time when the command
    started and the prompt to know when it was finished, and thus you can calculate
    the total time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the theme, `open ~/.zshrc` and modify the `ZSH_THEME` variable. Save
    the file and open a new terminal window. Let''s initialize an empty `git` directory
    so we can see how the prompt looks. You can see we are on the master branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a file, say `readme.md`. The `*` in the prompt shows that the
    directory is not clean. We can verify this with the `git status` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how it gets verified. After we've cleaned up the directory, the
    `*` is gone. If we change branch, the prompt shows that we are on the new branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly create a demo. Run the following commands on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now see the branch name in the prompt, and there are some other cool
    features that you might like to explore:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command completion**: Start typing, for example, ip, and press *Tab*. We
    can see all the commands that start with IP and we can hit *Tab* again to start
    navigating through the different options. You can use the arrow keys to navigate
    and hit *Enter* for the desired command:![Oh-my-zsh – your terminal never felt
    this good before!](img/image_02_011.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Params completion**: For example type `ls -` and press *Tab*, and we can
    see here all the options and a short description for each. Press *Tab* again to
    start navigating through them and *Enter* to select.![Oh-my-zsh – your terminal
    never felt this good before!](img/image_02_012.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**History navigation**: Click on arrow up key to search in history, filtering
    by the string that is written before the cursor. For example, if I type `vim`
    and press the arrow up key, I can see all the files opened with Vim in my history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**History search**: Press *Ctrl* + *R* and start typing, and press *Ctrl* +
    *R* again to search the same occurrence in history. For example *~*, and *Ctrl*
    + *R* to see all commands that have *~* in the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigating**: Here press *Ctrl* + arrow left/right to jump one word, *Ctrl*
    + *W* to delete one word, or *Ctrl* + *U* to delete the whole line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cd completion case insensitive**: For example, `cd doc` will expand into
    `cd Documents`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cd directory completion**: If you are lazy and want to specify only a few
    key letters in a path, we can do that too. For example, `cd /us/sh/zs` + *Tab*
    will expand into `cd /usr/share/zsh`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kill completion:** Just type `kill` and *Tab* and you will see a list of
    `pids` to kill. From there you can choose which process to kill.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**chown completion**: Type `chown` and tab to see a list of users to change
    owner to. The same applies to groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Argument expansion**: Type `ls *` and hit *Tab*. You see `*` expanded to
    all files and folders in the current directory. For a subset, type `ls Do*` and
    press *Tab*. It will only expand to documents and downloads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adds lots of aliases:** Just type alias to see a full list. Some very useful
    ones are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To see a list of shortcuts, run the `bindkey` command. The terminal is one of
    the places where you will spend a lot time, so it's really important to master
    our shell and use it as efficiently as possible. Knowing good shortcuts and viewing
    relevant and condensed information, such as our prompt, can make our job much
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: Basic regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*You have a problem and you want to solve it with regular expressions? Now
    you have two problems!* This is just one of the many regular expression jokes
    on the Internet.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how regular expressions work, as we will be
    using them in the upcoming chapters. We have prepared a file for our playground
    and if you want to try the grep commands on your own, you can take it from the
    GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by opening our text file so we can see its contents, and then splitting
    the screen so we can see both the file and the command side by side.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the simplest and probably the most common regular expression is
    to find a single word.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this we will use the `grep "joe" file.txt` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic regular expressions](img/image_02_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`joe` is the string we are searching for and `file.txt` is the file where we
    perform the search. You can see that grep printed the line that contained our
    string and the word is highlighted with another color. This will only match the
    exact case of the word (so, if we use lowercase `j`, this regex will not work
    anymore). To do a case insensitive search, `grep` has an `-i` option. What this
    means is that grep will print the line that contains our word even if the word
    is in a different case, like JoE, JOE, joE, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Basic regular expressions](img/image_02_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we don''t know exactly what characters are there in our string, we can use
    `.*` to match any number of characters. For example, to find a sentence beginning
    with "word" and ending with "day", we''d use the `grep "word.*day" file.txt` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.` - matches any character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` - matches previous character multiple times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here you can see that it matched the first line in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common scenario is to find empty lines in a file. For this we use the
    `grep "^\s$" file.txt` command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where `\s` : This stands for space,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^` : It''s for the beginning of the line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$` : It''s for its ending.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have two empty lines with no space. If we add a space between the lines,
    it will match the lines containing one space. These are called **anchors**.
  prefs: []
  type: TYPE_NORMAL
- en: '`grep` can do a neat little trick to count the number of matches. For this,
    we use the `-c` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic regular expressions](img/image_02_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To find all the lines that have only letters and space, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`grep`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`""`: Open quotes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^$`: From the beginning of the line to the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[]*`: Match these characters any number of times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A-Za-z`: Any upper and lower case letter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we run the command up to here, we get only the first line. If we add:'
  prefs: []
  type: TYPE_NORMAL
- en: '- 0-9 any number we match another two lines,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And if we add: - \s any space, we also match the empty lines and the all caps
    line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we run the command until here, we get only the first line from the output,
    the rest is not displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, if we add 0-9 we match any number (so the first two lines get matched)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And if we add \s we match any type of space (so the empty lines are matched
    as well)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Basic regular expressions](img/image_02_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes we need to search for something that''s not in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command will find all the lines that do not have only numeric characters.
    `[^]` means match all characters that are not inside, in our case, any non-number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The square brackets are markers in our regular expression. If we want to use
    them in our search string, we have to escape them. So, in order to find lines
    that have content between square brackets, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is for any line that has characters in square brackets. To find all lines
    that have these character `!`, type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s have a look at a basic `sed,` lets find `Joe` word and replace with
    `All` word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Basic regular expressions](img/image_02_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will replace every occurrence of the string `Joe` with the string `All`.
    We will deep dive into this in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions, such as Vim, are one of the things many people are afraid
    of because they seem complicated to learn in the beginning. Although they might
    seem cryptic, regular expressions are handy companions once mastered: they are
    not limited to our shell because the syntax is very similar in most programming
    languages, databases, editors, and any other place that includes searching for
    strings. We will go into more detail about regular expressions in the upcoming
    chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Pipes and subshells – your shell's salt and pepper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be looking at ways to improve your productivity using
    your shell. The Linux command line is great because it has a variety of tools
    we can use. What makes it even greater is the fact that we can chain these tools
    together to form greater, more powerful tools that will make us even more productive.
    We will not go into basic shell commands; instead we will be looking at some cool
    pipe and subshell combinations that can make our lives easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a basic pipe; in this example, we are counting the length
    of the current path using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Pipes and subshells – your shell''s salt and pepper](img/image_02_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`pwd,` as you probably know, stands for `print working directory`. The `|`
    is the pipe symbol, and what it does is send the output of the command on the
    left to the command on the right. In our case, `pwd` is sending its output to
    `wc -c`, which counts the number of characters. The coolest thing about pipes
    is that you can create a chain of any number of pipes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see another example where we will see how to find used space on the
    drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Pipes and subshells – your shell''s salt and pepper](img/image_02_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`"df -h"`: This shows the disk usage in a human-readable format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"| grep /home"`: This shows only the home directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''| tr -s " "''`: This substitutes multiple spaces for just one space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''| cut -f 2 -d " "''`: This selects the second column using a space as the
    delimiter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the command printed out `173G`, the size of the `/home` partition.
    This is a common use case when chaining multiple commands, each command reducing
    the output until we get the desired information and nothing else. In our case,
    this is the used disk space.
  prefs: []
  type: TYPE_NORMAL
- en: 'To count all the directories in a folder, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Pipes and subshells – your shell''s salt and pepper](img/image_02_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The basic idea is to count all the lines that end with `/`. Here we can see
    we have only one directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pipes are a great option to find and kill processes. Say we want to find the
    process ID of `nautilus`, and `kill all` running instances. For this we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Pipes and subshells – your shell''s salt and pepper](img/image_02_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`ps aux`: This prints all processes with PID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| grep nautilus`: Find the ones matching nautilus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| grep -v grep`: Inverts `grep` to exclude the `grep` process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| awk ''{print $2}''`: Selects the second word in the line, which is the PID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| xargs kill`: Here `xargs` is used to distribute each PID to a kill command.
    It is especially used for commands that do not read arguments from standard input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we've killed `nautilus`. This was purely a demonstrative example. There
    are other ways of doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Let's open `nautilus` again and send it to the background by hitting *Ctrl*
    + *Z* followed by the `bg` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To see all the `pids` of `nautilus` and to send the kill signal to all those
    processes, use the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time for some networking! You probably know the `ifconfig` command,
    which is used to print information about the network interfaces. To get the IP
    address of a specific interface (in our case the wireless interface `wlp3s0`),
    run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Pipes and subshells – your shell''s salt and pepper](img/image_02_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`ifconfig wlp3s0`: Prints networking information for the `wlp3s0` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| grep "inet addr:"`: Gets the line with the IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| awk ''{print $2}''`: Selects the second word in the line (we could have
    used cut as well)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| cut -f 2 -d ":"`: This is split by `":"`, and only prints the second word'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And now, we see your `private ip` address on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: A common use case that might also arise is counting the word frequency in a
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have a standard lorem ipsum text contained in `lorem.txt`. In order
    to get the word frequency, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Pipes and subshells – your shell''s salt and pepper](img/image_02_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`cat lorem.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| tr " " "\n"`: Transforms each space into a new line character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| grep -v "^\s*$"`: Eliminates empty lines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| sed "s/[,.]//g"`: Eliminates commas (,) and periods (.) to select only the
    words'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| sort`: Sort the results alphabetically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| uniq -c`: Show only unique lines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| sort -n`: Sorts by numerical value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Append `grep -w id` to find the frequency of the word ID, or `grep -w 4` to
    see all words that appear four times.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to our first subshell example. Subshells can be written by
    either enclosing them in `$()`, or using backticks (*`*). Backticks are usually
    found under the *Esc* key on your keyboard. In all our examples, we will be using
    the first form because it's easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first example is to list all the folders in our current folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ls` subshell returns the files and folders in the current directory and
    the `ls` from outside the subshell will list those individually, showing additional
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: Counting all files and directories in the current directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the fact that commas (,) and periods (.) are hard links that mark the
    current and parent directory, we need to count all entries minus these two
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be done using the `expr $(ls -a | wc -l ) - 2` command:![Pipes and
    subshells – your shell's salt and pepper](img/image_02_025.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, the subshell will return the number of entries (five, in this case). The
    number we are looking for is the number of entries minus the special folders ("`.`"
    and "`..`"). In order to do arithmetic operations, we use the `expr` command,
    as in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the subshell contains a pipe. The good thing is that we can combine
    pipes and subshells in any way in order to obtain the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine pipes and subshells as Lego pieces for your shell. They expand way beyond
    its capabilities and give you access to new possibilities with infinite combinations.
    In the end, it all depends on your imagination and how well you learn to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Shell scripting for fun and profit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipes and subshells are one way of expanding the capabilities of our shell.
    The ultimate way is by writing shell scripts. These scenarios must be taken into
    consideration when dealing with complex tasks that can't be automated with a one-line
    command.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that almost all the tasks can be automated with the use of
    shell scripts. We won't go over an introduction to shell scripts. Instead, we
    will be looking at some more advanced use cases for writing them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start our journey into shell scripting! First thing, let's open a file
    called `script.sh` and split the screen so that we can test while writing. Every
    shell should start with `#!`, followed by the interpreter it uses. This line is
    called a **shebang**. We will be using bash as our default interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a good idea to use bash, because it''s a common interpreter that comes
    with most Linux distributions and also OS X:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with a simple use case: reading the arguments passed into the
    command line. We will assign the value of the first command line argument, `$1`,
    to a variable called ARG, and then print it back to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s save our script, assign it execution permissions, and then run it with
    one argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Shell scripting for fun and profit](img/image_02_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the value test is printed back to the screen. In some cases,
    we want to assign default values to variables. In order to do this, add ":-" to
    the variable assignment, followed by the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we re-run the script, we can see that passing no arguments will `echo
    default value`. And just like pipes, we can chain multiple default value assignments
    together. We can define another variable `AUX`, assign it the value `123`, and
    use the same syntax to assign its value to the ARG variable, before using the
    `"default value"` script like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![Shell scripting for fun and profit](img/image_02_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, ARG will always receive 123 as its default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at string selectors. To select a substring, use ":", plus the
    starting position plus ":", plus the number of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![Shell scripting for fun and profit](img/image_02_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our case, we will be selecting four characters, starting from the fifth character.
    After running the script, we can see the value `long` printed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most shell scripts are designed to run from the command line and receive a
    variable number of arguments. In order to read command line arguments without
    knowing the total number of arguments, we''ll use a `while` statement that checks
    whether the first argument is not null using the -z (or not equal to 0) conditional
    expression. In the while loop, let''s echo the variable''s value and run shift,
    which shifts command line arguments one position to the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![Shell scripting for fun and profit](img/image_02_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we run our script with the arguments *a* *b* *c*, we can see that our while
    looped through the parameters and printed each one on a separate line. Now let's
    extend our CLI arguments parser and add a *case* statement for interpreting the
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that our script will have a help option. The Posix standard recommends
    doing a long argument version with `--`, and a short version with only one `-`.
    So both `-h` and `--help` will print the help message. Also, it is recommended
    to always have a default case and print a message when the user sends invalid
    options and then exits with a non-zero exit value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![Shell scripting for fun and profit](img/image_02_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we run our script with -h, we can see the help message printed, the same
    as if we had used `--help`. If we run the script with any other option, the invalid
    option text is printed and the script exits with the exit code 1\. To get the
    exit code of the last command, use `"$?"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at basic functions in shell. The syntax is pretty similar to
    other programming languages. Let''s write a function called `print_ip` that will
    print the IP of the interface specified as the first argument. We will use a subshell
    and assign the value to a variable called IP. We already have the full command
    inside our clipboard; it''s the same one we saw in the lesson about pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![Shell scripting for fun and profit](img/image_02_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s add another case to our switch statement, for the `-i` or `--ip`
    option. The option will be followed by the name of the interface, which we will
    then pass to the `print_ip` function. Having two arguments for one option means
    we need to call the shift command twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let's do an `ifconfig` to get the name of our wireless interface. We can see
    it's `wlp3s0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can see the IP address. This is a very basic use case, where we can see how
    command line arguments can be passed. We can add unlimited options to our case
    statement, define functions for handling the arguments, and even chain multiple
    options together to form complex scripts that receive well-structured information
    as command line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Being effective means running tasks faster-- really fast! And when it comes
    to speed, bash is not the first choice in terms of script interpreters. Luckily,
    we still have some tricks up our sleeves! If a shell script needs to run multiple
    independent tasks, we can use the *&* symbol to send the process to the background
    and move forward to the next command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two functions, `long_running_task 1` and `2`, and add a `sleep`
    command inside, to simulate a `long_running` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first long running task function will sleep for one second, and the next
    will sleep for two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, for testing purposes, let''s add another case to our switch statement,
    called `-p / --`parallel, and run the two long running tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take a total of three seconds for the script to finish. We can measure
    this with the *time* utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shell scripting for fun and profit](img/image_02_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we run both functions in the background, we can reduce the running time
    to the longest running time of both functions (because of the wait). When running
    long running tasks, we probably want the script to wait for the longest-running
    task to finish, in our case task 2\. We can achieve this by grabbing the `pid`
    of the second task. Here `$!` is used to grab the `pid` of the last run command.
    Then we use the wait shell built in to wait for the execution to finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After running the script again with the time utility, we can see it takes us
    a total of two seconds to complete the task.
  prefs: []
  type: TYPE_NORMAL
- en: Who would've thought we can do parallel processing in a shell?
  prefs: []
  type: TYPE_NORMAL
- en: 'If the executions take a longer time, we can add a notification when the script
    finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![Shell scripting for fun and profit](img/image_02_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This way we can start the script, work on some other tasks, and receive a notification
    when the script finishes. You can let your imagination go wild on the things you
    can achieve with parallel processing and notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we have seen some common predefined shell variables. They
    were:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$1`: First argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$?`: Return code of the last command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$!`: The `pid` of the last command run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other commonly used predefined shell variables include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$#`: Number of parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$*`: List of parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$@`: All the parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$0`: Name of the shell/script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$$`: PID of current running shell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash has a lot of features and we recommend going through its man page to get
    more information about them.
  prefs: []
  type: TYPE_NORMAL
- en: Shell scripts are amazing when used the right way. They can fine-tune system
    commands, as we saw in our example when we got only the IP address, without the
    whole `ifconfig` output and much more. You, as a pragmatic terminal user, should
    identify what tasks you most commonly do in the command line and what can be automated
    using shell scripts. You should create your own collection of shell scripts and
    add them your path, so that they are easily accessible from any directory.
  prefs: []
  type: TYPE_NORMAL
- en: Shell scripting libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To really take advantage of automating tasks using shell scripts, it's important
    to organize all common tasks into reusable commands and have them available in
    the path. To do this, it's a good idea to create a `bin` folder inside the home
    directory for the scripts, and a `bin/lib` directory for storing common pieces
    of code. When working with lots of shell scripts, it's important to reuse large
    pieces of functionality. This can be achieved by writing library functions for
    your shell scripts, functions that you can call from multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will create a library script called `util.sh`, which will be sourced
    in other scripts. By sourcing the script, we get access to functions and variables
    from inside the library script.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by adding the `print_ip` function from a previous script.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will add another function called `getarg`, which will be used by other
    scripts for reading command line arguments and values. We will simply paste it
    from our clipboard history, using ClipIt to select it.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about ClipIt by checking out our ClipIt section!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![Shell scripting libraries](img/image_02_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is just a simple function that will receive a parameter name as the first
    argument, the list of CLI arguments as the second parameter, and it will search
    inside the list of CLI arguments to find the parameter name. We will see it in
    action later on.
  prefs: []
  type: TYPE_NORMAL
- en: The last function we're going to create is called `get_public_ip`. It is similar
    in terms of functionality to the `print_ip` function, except that it will be used
    to print the computer's public IP. That means that, if you are connected to a
    wireless router and you access the Internet, you will get the IP of the router,
    which is the IP that other sites see. The `print_ip` function just shows the IP
    address from the private subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command is already copied in the clipboard. It''s called **dig** and we''re
    using it to access [https://www.opendns.com/](https://www.opendns.com/) in order
    to read the public `ip`. You can find more information about it in its man page
    or by Googling it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our library functions in place, let's go and create our productivity
    booster scripts. Let's create a script called **iputils** where we will add some
    common tasks for reading IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding the shebang, followed by a neat little trick for making
    sure we are always in the same folder as the executed script. We will be using
    the `BASH_SOURCE` variable to determine the value of the **current working directory**
    (or **CWD**) variable. You see here that we are using nested subshells in order
    to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will source the `util` script, so that the library functions are exported
    into memory. Then, we can access them from the current script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a simple call to our `getarg` function using a subshell, and search
    for the `cmd` argument. Also, let''s echo what we''ve found, so that we can test
    our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The next thing we need to do is to give the script execution rights using the
    `chmod` command. Also, in order to run the script from anywhere, the `bin` folder
    must be in the PATH variable. Echo the variable and check that the bin folder
    is there and, if not, update the variable in `~/.zshrc`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test the script by reading a command line parameter with the `getarg`
    function and echoing it.
  prefs: []
  type: TYPE_NORMAL
- en: If you are searching for the `iputils` command in the terminal using tab for
    autocomplete and the command doesn't seem to exist, that is probably because you
    need to tell `zsh` to reload its path commands. To do this, issue the "rehash"
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This should work from within any folder, and it should print `ip` on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve verified everything is alright, let''s write some code for
    our command line arguments. If we run the script with the `--cmd ip` flags, the
    script should print that on the screen. This can be done with the already-familiar
    `case` statement. Here we also want to pass in another argument, `--iface,` to
    get the interface that''s needed for printing the IP. It''s also a good practice
    to add a default case and echo a message saying `invalid` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Save the script, and let's test it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s get the interface name from the `ifconfig` command, and then
    let''s go and test the script by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![Shell scripting libraries](img/image_02_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see it's printing our private `ip` on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add our last `cmd` to the script: `publicip`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this we just call the `get_public_ip` function from our `lib` utility.
    Save it and run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the command worked; our public `ip` is printed on the screen. Here
    is the complete script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: To give you an example, a while ago there were a bunch of articles on the Internet
    about a man who used to automate everything that took him more than 90 seconds
    to do. The scripts he wrote included instructing the coffee machine to start making
    a latte, so that by the time he got to the machine, the latte was finished and
    he didn't need to wait. He also wrote a script that sent a text message "late
    at work" to his wife and automatically picked a reason from a preset list whenever
    there was activity with his login on the company's servers after 9 p.m.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this example is a little bit complex, but in the end it's all about
    your imagination. Well-written automation scripts can take care of your routine
    work and leave you to explore your creative potential.
  prefs: []
  type: TYPE_NORMAL
