- en: User-Kernel Communication Pathways
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 用户-内核通信路径
- en: 'Consider this scenario: you''ve successfully developed a device driver for,
    say, a pressure sensor device (perhaps by using the kernel''s I2C APIs to fetch
    the pressure from the chip via the I2C protocol). So, you have the current pressure
    value in a variable within the driver, which of course implies that it''s within
    kernel memory space. The issue at hand is, how exactly do you now have a *user
    space application retrieve this value?* Well, as we learned in the previous chapter,
    you can always include a `.read` method in the driver''s *fops *structure. When
    the user space app issues a `read(2)` system call, control will be diverted (via
    the **virtual file system** (**VFS**)) to your driver''s *read method.* In there,
    you perform `copy_to_user()` (or equivalent), resulting in the user mode app receiving
    the value. However, but there are other, sometimes superior, ways to do this.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况：你已经成功地为一个压力传感器设备开发了一个设备驱动程序（可能是通过使用内核的I2C API来通过I2C协议从芯片获取压力）。因此，你在驱动程序中有了当前的压力值，这当然意味着它在内核内存空间中。问题是，你现在如何让一个用户空间应用程序检索这个值呢？嗯，正如我们在上一章中学到的，你可以在驱动程序的fops结构中始终包含一个.read方法。当用户空间应用程序发出read(2)系统调用时，控制将通过虚拟文件系统（VFS）转移到你的驱动程序的read方法。在那里，你执行copy_to_user()（或等效操作），使用户模式应用程序接收到该值。然而，还有其他一些更好的方法来做到这一点。
- en: 'In this chapter, you''ll understand the various communication interfaces or
    pathways that are available – as a means to communicate or interface between user
    and kernel address spaces. This is an important aspect of writing driver code,
    for without this knowledge, how will you be able to achieve a key thing – efficiently
    transfer information between a kernel-space component (often, this is a device
    driver, but it could be anything, really) and a user space process or thread?
    Not only that, some of the techniques that we shall learn about are often used
    for debugging (and/or diagnostics) purposesas well. In this chapter, we will cover
    several techniques to effect communication between the kernel and user (virtual)
    address spaces: communication via the traditional proc filesystem, *procfs*, the
    better way for drivers via the sys filesystem, *sysfs*, via a debug filesystem,
    *debugfs*, via *netlink sockets*, and via the `ioctl(2)` system call.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解可用的各种通信接口或路径，作为在用户和内核地址空间之间进行通信或接口的手段。这是编写驱动程序代码的一个重要方面，因为如果没有这些知识，你将如何能够实现一个关键的事情——在内核空间组件（通常是设备驱动程序，但实际上可以是任何东西）和用户空间进程或线程之间高效地传输信息？不仅如此，我们将学习的一些技术通常也用于调试（和/或诊断）目的。在本章中，我们将涵盖几种技术来实现内核和用户（虚拟）地址空间之间的通信：通过传统的proc文件系统procfs进行通信，通过sys文件系统sysfs进行驱动程序的更好方式，通过调试文件系统debugfs进行通信，通过netlink套接字进行通信，以及通过ioctl(2)系统调用进行通信。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Approaches to communicating/interfacing a kernel driver with a user space C
    app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与用户空间C应用程序通信/接口的内核驱动程序的方法
- en: Interfacing via the proc filesystem (procfs)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过proc文件系统（procfs）进行接口
- en: Interfacing via the sys filesystem (sysfs)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过sys文件系统sysfs进行接口
- en: Interfacing via the debug filesystem (debugfs)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调试文件系统debugfs进行接口
- en: Interfacing via netlink sockets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过netlink套接字进行接口
- en: Interfacing via the ioctl system call
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过ioctl系统调用进行接口
- en: Comparing the interfacing methods – a table
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较接口方法-表格
- en: Let's get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: I assume you have gone through the *Preface*, the relevant section being *To
    get the most out of this book,* and have appropriately prepared a guest **virtual
    machine** (**VM**) running Ubuntu 18.04 LTS (or a later stable release) and installed
    all the required packages. If not, I recommend you do this first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你已经阅读了前言，相关部分是“充分利用本书”，并已经适当地准备了一个运行Ubuntu 18.04 LTS（或更高稳定版本）的虚拟机，并安装了所有必需的软件包。如果没有，我建议你首先这样做。
- en: To get the maximum out of this book, I strongly recommend you first set up the
    workspace environment, including cloning this book's GitHub repository ([https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/ch2))
    for the relevant code, and work on it in a hands-on fashion.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本书，我强烈建议你首先设置工作环境，包括克隆本书的GitHub存储库（[https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/ch2)）以获取相关代码，并以实际操作的方式进行工作。
- en: Approaches to communicating/interfacing a kernel driver with a user space C
    app
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与用户空间C应用程序通信/接口的内核驱动程序的方法
- en: As we mentioned in the introduction, in this chapter, we wish to learn how to
    efficiently transfer information between a kernel-space component (often, this
    is a device driver, but it could be anything, really), and a user space process
    or thread. To begin, let's simply enumerate various techniques available to the
    kernel or driver author to communicate or interface with a user space C application.
    Well, the user space component could be a C app, a shell script (both of which
    we typically show in this book), or even other apps such as C++/Java apps, Python/Perl
    scripts, and more.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中提到的，在本章中，我们希望学习如何在内核空间组件（通常是设备驱动程序，但实际上可以是任何东西）和用户空间进程或线程之间高效地传输信息。首先，让我们简单列举内核或驱动程序作者可用的各种技术，用于与用户空间C应用程序进行通信或接口。嗯，用户空间组件可以是C应用程序，shell脚本（这两者我们通常在本书中展示），甚至其他应用程序，如C++/Java应用程序，Python/Perl脚本等。
- en: 'As we saw in the companion guide, *Linux Kernel Programming*, in *Chapter 4, Writing
    Your First Kernel Module – LKMs Part 1,* in the *Library and System Call APIs* subsection,
    the essential interface between user space applications and the kernel that includes
    the device drivers are the system call APIs*.* Now, in the previous chapter, you
    learned the basics of writing a character device driver for Linux. Within that,
    you also learned how to transfer data between user and kernel address spaces by
    having a user mode application open the device file and issue `read(2)` and `write(2)`
    system calls. This resulted in the driver''s read/write method being invoked by
    the VFS and your driver performing the data transfer via the `copy_{from|to}_user()`
    APIs. So, the question here is: if we have already covered that, then what else
    is there to learn about in this regard?'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在伴随指南*Linux内核编程*的*第4章*，*编写您的第一个内核模块 - LKMs第1部分*中的*库和系统调用API*子章节中所看到的，用户空间应用程序和内核之间的基本接口包括设备驱动程序的系统调用API*。现在，在上一章中，您学习了为Linux编写字符设备驱动程序的基础知识。在其中，您还学习了如何通过让用户模式应用程序打开设备文件并发出`read(2)`和`write(2)`系统调用来在用户和内核地址空间之间传输数据。这导致VFS调用驱动程序的读/写方法，并且您的驱动程序通过`copy_{from|to}_user()`API执行数据传输。因此，这里的问题是：如果我们已经涵盖了这一点，那么在这方面还有什么其他要学习的呢？
- en: 'Ah, quite a bit! The reality is that there are several other techniques of
    interfacing between a user mode app and the kernel. Certainly, they all very much
    depend upon using system calls; after all, there is no other (synchronous, programmatic)
    way to enter the kernel from the user space! Nevertheless, the techniques differ.
    The aim of this chapter is to show you various communication interfaces that are
    available, as of course, depending on the project, one might be more suitable
    than others to use. Let''s look at the various techniques that will be used in
    this chapter to interface between the user and kernel address spaces:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，还有很多！事实上，还有其他几种用户模式应用程序和内核之间的接口技术。当然，它们都非常依赖于使用系统调用；毕竟，没有其他（同步的、程序化的）方式从用户空间进入内核！然而，这些技术是不同的。本章的目的是向您展示各种可用的通信接口，因为当然，根据项目的不同，可能有一种更适合使用。让我们来看看本章将用于用户和内核地址空间之间的接口的各种技术：
- en: Via the traditional procfs interface
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过传统的procfs接口
- en: Via sysfs
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过sysfs
- en: Via debugfs
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过debugfs
- en: Via netlink sockets
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过netlink套接字进行接口
- en: Via the `ioctl(2)` system call
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`ioctl(2)`系统调用
- en: Throughout this chapter, we will discuss these interfacing techniques in detail
    by providing driver code examples. In addition, we will also briefly explore how
    conducive they are to the purpose of *debugging.* So, let's begin with using the
    procfs interface.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过提供驱动程序代码示例详细讨论这些接口技术。此外，我们还将简要探讨它们对*调试*目的的适用性。因此，让我们从使用procfs接口开始。
- en: Interfacing via the proc filesystem (procfs)
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过proc文件系统（procfs）进行接口
- en: In this section, we shall cover what the proc filesystem is and how you can
    leverage it as an interface between user and kernel address spaces. The proc filesystem
    is a powerful and easy-to-program interface, often used for status reporting and
    debugging core kernel systems.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍proc文件系统是什么，以及您如何将其作为用户和内核地址空间之间的接口。proc文件系统是一个强大且易于编程的接口，通常用于状态报告和调试核心内核系统。
- en: Note that from version 2.6 Linux onward and for upstream contribution, this
    interface is *not* to be used by driver authors (it's strictly meant for kernel-internal
    usage only). Nevertheless, for completeness, we will cover it here.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从Linux 2.6版本开始，对于上游贡献，这个接口*不*应该被驱动程序作者使用（它严格意味着仅用于内核内部使用）。尽管如此，为了完整起见，我们将在这里介绍它。
- en: Understanding the proc filesystem
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解proc文件系统
- en: 'Linux has a virtual filesystem named *proc*; the default mount point for it
    is `/proc`. The first thing to realize regarding the proc filesystem is that its
    content is *not* on a non-volatile disk. Its content is in RAM, and is thus volatile.
    The files and directories you can see under `/proc` are pseudo files that have
    been set up by the kernel code for proc; the kernel hints at this fact by (almost)
    always showing the file''s *size* as zero:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Linux有一个名为*proc*的虚拟文件系统；它的默认挂载点是`/proc`。关于proc文件系统的第一件事是要意识到，它的内容*不*在非易失性磁盘上。它的内容在RAM中，因此是易失性的。您在`/proc`下看到的文件和目录都是内核代码为proc设置的伪文件；内核通过（几乎）总是显示文件的*大小*为零来暗示这一事实：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's summarize a few critical points regarding Linux's powerful proc filesystem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下关于Linux强大的proc文件系统的一些关键点。
- en: The objects under `/proc` (files, directories, soft links, and so on) are all
    pseudo objects; they live in RAM!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: /proc下的对象（文件、目录、软链接等）都是伪对象；它们存在于RAM中！
- en: Directories under /proc
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /proc下的目录
- en: The directories under `/proc` whose names are integer values represent processes
    currently alive on the system. The name of the directory is the PID of the process
    (technically, it's the TGID of the process. We covered TGID/PID in the companion
    guide *Linux Kernel Programming *in* Chapter 6*, *Kernel and Memory Management
    Internals Essentials*).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: /proc下的目录的名称是整数值，代表当前在系统上运行的进程。目录的名称是进程的PID（从技术上讲，它是进程的TGID。我们在伴随指南*Linux内核编程*的*第6章*，*内核和内存管理内部要点*中介绍了TGID/PID）。
- en: This folder – `/proc/PID/` – contains information regarding this process. So,
    for example, for the *init* or *systemd *process (always PID `1`), you can examine
    detailed information about this process (its attributes, open files, memory layout,
    children, and so on) under the `/proc/1/` folder.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹 - `/proc/PID/` - 包含有关此进程的信息。因此，例如，对于*init*或*systemd*进程（始终是PID `1`），您可以在`/proc/1/`文件夹下查看有关此进程的详细信息（其属性、打开文件、内存布局、子进程等）。
- en: 'As an example, here, we will gain a root shell and do `ls /proc/1`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里，我们将获得root shell并执行`ls /proc/1`：
- en: '![](img/b602d4a8-8d7b-4aca-ad53-c4f04ef4240d.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b602d4a8-8d7b-4aca-ad53-c4f04ef4240d.png)'
- en: Figure 2.1 – Screenshot of performing ls /proc/1 on an x86_64 guest system
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - 在x86_64客户系统上执行ls /proc/1的屏幕截图
- en: The complete details regarding the pseudo files and folders under `/proc/<PID>/...`
    can be found on the man page of `proc(5)` (by doing `man 5 proc`); do try it out
    and refer to it!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Note that the precise content under `/proc` varies from both the kernel version
    and the (CPU) architecture; x86_64 tends to have the richest content.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The purpose behind the proc filesystem
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *purpose* behind the proc filesystem is two-fold:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: One, it is a simple interface for developers, system administrators, and anyone
    really to look deep inside the kernel so that they can gain information regarding
    the internals of processes, the kernel, and even hardware. Using this interface
    only requires you to know basic shell commands such as `cd`, `cat`, `echo`, `ls`*,*
    and so on.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two, as the *root* user and, at times, the owner, you can write into certain
    pseudo files under `/proc/sys`, thus tuning various kernel parameters. This feature
    is called **sysctl***.* As an example, you can tune various IPv4 networking parameters
    in `/proc/sys/net/ipv4/`. They are all documented here: [https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt](https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changing the value of a proc-based tunable is easy; for example, let''s change
    the maximum number of threads allowed at any given point in time on the box. Run
    the following commands as *root*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With that, we''re done. However, it should be clear that the preceding operation
    is *volatile* – the change only applies to this session; a power cycle or reboot
    will result in it reverting back to the default value of course. How, then, do
    we make the change permanent*?* The short answer: use the `sysctl(8)` utility;
    refer to its man page for more details.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Are you ready to write some procfs-interfacing code now? Not so fast – the next
    section informs you as to why this may *not* be a great idea after all.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: procfs is off-bounds to driver authors
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though we could use the proc filesystem to interface with a user mode app,
    there is an important point to note here! You must realize that procfs is, like
    many similar facilities within the kernel, an **Application Binary Interface**
    (**ABI**). The kernel community makes no promises that it remains stable and exactly
    the way it is today, just as is the case with the kernel *APIs* and their internal
    data structures as well. In fact, ever since the 2.6 kernel, the kernel folks
    have made this very clear – *device driver authors (and the like) are not supposed
    to use procfs* for their own purposes or their interfaces, debug or otherwise.
    Earlier, with 2.6 Linux, it was quite common to use proc for said purposes (abused,
    as per the kernel community, as proc is meant for kernel internal use only!).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: So, if procfs is considered off-bounds, or deprecated, to us as driver authors,
    then what facility do we use to communicate with user space processes? Driver
    authors are to use the sysfs facility to *export* their interfaces. In reality,
    it's not just sysfs; there are several choices available to you such as sysfs,
    debugfs, netlink sockets, and the ioctl system call. We will cover these in detail
    later in this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Hang on, though; again, the reality is that this "rule" regarding the non-usage
    of procfs for driver authors are for the community. What this means is that if
    you intend to *upstream* your driver or kernel module to the mainline kernel,
    thus contributing your code under the GPLv2 license, *then* all the community
    rules definitely apply. If not, it's really up to you to decide. Of course, following
    the kernel community's guidelines and rules can only be a good thing; we definitely
    recommend that you do so. In terms of discouraging the use of proc by non-core
    stuff such as drivers, unfortunately, there is no recent kernel documentation
    available for the proc API/ABI.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: On the 5.4.0 kernel, there are around 70-odd callers of the `proc_create()`
    kernel API, several of which being (typically older) drivers and filesystems.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在5.4.0内核上，有大约70多个`proc_create()`内核API的调用者，其中有一些是（通常是较老的）驱动程序和文件系统。
- en: Nevertheless (you have been warned!), let's learn how to interact a user space
    process with kernel code via procfs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此（您已经被警告！），让我们学习如何通过procfs与内核代码交互用户空间进程。
- en: Using procfs to interface with the user space
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用procfs与用户空间进行接口
- en: As a kernel module or device driver developer, we can actually create our own
    entries under `/proc`, leveraging this as a simple interface to the user space.
    How can we do this? The kernel provides APIs that create directories and files
    under procfs. We will learn how to use them in this section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为内核模块或设备驱动程序开发人员，我们实际上可以在`/proc`下创建自己的条目，利用这作为与用户空间的简单接口。我们如何做到这一点？内核提供了API来在procfs下创建目录和文件。我们将在本节中学习如何使用它们。
- en: Basic procfs APIs
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本的procfs API
- en: 'Here, we do not intend to delve into the gory details of the procfs API set;
    rather, we shall cover just enough to have you be able to understand and use them.
    For deeper detail, do refer to the ultimate resource: the kernel code base. The
    routines we will cover here have been exported, thus making them available to
    driver authors like you. Also, as we mentioned earlier, all the procfs file objects
    are really pseudo objects, in the sense that they exist only in RAM.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不打算深入研究procfs API集的细节；相反，我们将只涵盖足够让您能够理解和使用它们。要了解更深入的细节，请参考终极资源：内核代码库。我们将在这里介绍的例程已经被导出，因此可以供像您这样的驱动程序作者使用。此外，正如我们之前提到的，所有procfs文件对象实际上都是伪对象，也就是说它们只存在于RAM中。
- en: Here, we are assuming you understand how to design and implement a simple LKM;
    you'll find more details in the companion guide to this book, *Linux Kernel Programming*,
    in the fourth and fifth chapters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设您了解如何设计和实现一个简单的LKM；您可以在本书的附属指南*Linux Kernel Programming*的第四和第五章中找到更多细节。
- en: 'Let''s begin by exploring a few simple procfs APIs that allow you to perform
    a few key tasks – creating a directory under the proc filesystem, creating (pseudo)
    files under there, and deleting them, respectively. For all of these tasks, ensure
    you include the relevant header file; that is, `#include <linux/proc_fs.h>`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索一些简单的procfs API，它们允许您执行一些关键任务-在proc文件系统下创建目录，创建（伪）文件，并分别删除它们。对于所有这些任务，请确保包含相关的头文件；也就是说，`#include
    <linux/proc_fs.h>`：
- en: 'Create a directory named `name` under `/proc`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/proc`下创建一个名为`name`的目录：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first parameter is the name of the directory, while the second parameter
    is the pointer to the parent directory to create it under. Passing `NULL` here
    creates the directory under the root; that is, under `/proc`*.* Save the return
    value, as you will typically use it as a parameter in subsequent APIs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是目录的名称，而第二个参数是要在其下创建它的父目录的指针。在这里传递`NULL`会在根目录下创建目录；也就是说，在`/proc`下。保存返回值，因为您通常会将其用作后续API的参数。
- en: The `proc_mkdir_data()` routine allows you to pass along a data item (a `void
    *`) as well; note that it's exported via `EXPORT_SYMBOL_GPL`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc_mkdir_data()`例程允许您传递一个数据项（`void *`）；请注意，它是通过`EXPORT_SYMBOL_GPL`导出的。'
- en: 'Create a procfs (pseudo) file called `/proc/parent/name`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`/proc/parent/name`的procfs（伪）文件：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The key parameter here is `struct file_operations`, which we introduced in
    the previous chapter. You are expected to populate it with the "methods" to be
    implemented (more on this follows). Think about it: this is really powerful stuff;
    using the `fops`structure, you can set up "callback" functions within your driver
    (or kernel module) that the kernel''s proc filesystem layer will honor: when a
    user space process reads from your proc file, it (the VFS) will invoke the driver''s `.read`
    method or callback function. If a user space app writes, it will invoke the driver''s `.write`
    callback!'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键参数是`struct file_operations`，我们在上一章中介绍过。您需要用要实现的“方法”填充它（后面会更多介绍）。想想看：这真的是非常强大的东西；使用`fops`结构，您可以在驱动程序（或内核模块）中设置“回调”函数，内核的proc文件系统层将会遵守它们：当用户空间进程从您的proc文件中读取时，它（VFS）将调用驱动程序的`.read`方法或回调函数。如果用户空间应用程序写入，它将调用驱动程序的`.write`回调！
- en: 'Remove a procfs entry:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除一个procfs条目：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This API removes the specified `/proc/name` entry and frees it (if not in use);
    similarly (and often much more convenient), use the `remove_proc_subtree()` API
    to remove an entire sub-tree within `/proc` (typically on cleanup or if an error
    occurs).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此API删除指定的`/proc/name`条目并释放它（如果未被使用）；类似地（通常更方便），使用`remove_proc_subtree()` API来删除`/proc`中的整个子树（通常在清理或发生错误时）。
- en: Now that we know the basics, the empirical approach demands that we put these
    APIs to practice! To do so, let's figure out what directories/files to create
    under `/proc`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了基础知识，经验法则要求我们将这些API应用到实践中！为此，让我们找出在`/proc`下创建哪些目录/文件。
- en: The four procfs files we will create
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们将创建四个procfs文件
- en: 'To help clearly illustrate the usage of procfs as an interfacing technology,
    we will have our kernel module create a directory under `/proc`. Within that directory,
    it will create four procfs (pseudo) files. Note that, by default, all procfs files
    have their *owner:group* attributes as *root:root*. Now, create a directory called `/proc/proc_simple_intf`
    and, under it, create four (pseudo) files. The names and attributes of the four
    procfs (pseudo) files under the `/proc/proc_simple_intf` directory, are shown
    in the following table:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地说明procfs作为接口技术的用法，我们将让我们的内核模块在`/proc`下创建一个目录。在该目录下，它将创建四个procfs（伪）文件。请注意，默认情况下，所有procfs文件的*owner:group*属性都是*root:root*。现在，创建一个名为`/proc/proc_simple_intf`的目录，并在其中创建四个（伪）文件。在`/proc/proc_simple_intf`目录下的四个procfs（伪）文件的名称和属性如下表所示：
- en: '| **Name of procfs ''file''** | **R: action on read callback, invoked via user
    space read** | **W: action on write callback, invoked via user space write** |
    **Procfs ''file'' permissions** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **procfs ''file''的名称** | **R：读取回调上的操作，通过用户空间读取调用** | **W：写入回调上的操作，通过用户空间写入调用**
    | **Procfs ''file''权限** |'
- en: '| `llkdproc_dbg_level` | Retrieves (to the user space) the current value of
    the global variable; that is, `debug_level` | Updates the `debug_level` global
    variable to the value written by the user space | `0644` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `llkdproc_dbg_level` | 检索（到用户空间）全局变量的当前值；即 `debug_level` | 更新 `debug_level`
    全局变量为用户空间写入的值 | `0644` |'
- en: '| `llkdproc_show_pgoff` | Retrieves (to the user space) the kernel''s `PAGE_OFFSET`
    value | – no write callback – | `0444` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `llkdproc_show_pgoff` | 检索（到用户空间）内核的 `PAGE_OFFSET` 值 | – 无写回调 – | `0444`
    |'
- en: '| `llkdproc_show_drvctx` | Retrieves (to the user space) the current values
    within the driver''s "context" structure; that is, `drv_ctx` | – no write callback
    – | `0440` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `llkdproc_show_drvctx` | 检索（到用户空间）驱动程序“上下文”结构中的当前值；即 `drv_ctx` | – 无写回调 –
    | `0440` |'
- en: '| `llkdproc_config1` (also treated as `dbg_level`) | Retrieves (to user space)
    the current value of the context variable; that is,  `drvctx->config1` | Updates
    the driver context member, `drvctx->config1`, to the value written by the user
    space | `0644` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `llkdproc_config1`（也被视为 `dbg_level`） | 检索（到用户空间）上下文变量的当前值；即 `drvctx->config1`
    | 更新驱动程序上下文成员 `drvctx->config1` 为用户空间写入的值 | `0644` |'
- en: We'll look at the APIs and actual code to create the `proc_simple_intf` directory
    under `/proc` and the four files mentioned previously under it shortly. (Due to
    a lack of space, we won't actually show all the code; just the code with respect
    to the "debug level" get-and-set; this is not an issue, the remainder of the code
    is conceptually very similar).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看用于在 `/proc` 下创建 `proc_simple_intf` 目录和其中四个文件的 API 和实际代码（由于空间不足，我们实际上不会显示所有代码；只显示与“调试级别”获取和设置相关的代码；这不是问题，其余代码在概念上非常相似）。
- en: Trying out the dynamic debug_level procfs control
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试动态调试级别 procfs 控制
- en: 'First, let''s check out the "driver context" data structure that we shall use
    throughout this chapter (in fact, we first used it in the previous chapter):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们查看我们将在本章节中始终使用的“驱动程序上下文”数据结构（实际上，在上一章节中首次使用）：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we can also see that we have a global integer named `debug_level`; this
    will provide dynamic control over the debug verbosity of the "project". The debug
    level is assigned a range of `[0-2]`, where we have the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还可以看到我们有一个名为 `debug_level` 的全局整数；这将动态控制“项目”的调试详细程度。调试级别分配了一个范围 `[0-2]`，我们有以下内容：
- en: '`0` implies *no debug messages* (the default).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 意味着*没有调试消息*（默认值）。'
- en: '`1` is *medium debug* verbosity.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 是*中等调试*详细程度。'
- en: '`2` implies *high debug* verbosity.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2` 意味着*高调试*详细程度。'
- en: The beauty of the whole schema – and indeed the whole point here – is that we
    shall be able to query and set this `debug_level` variable from the user space
    via a procfs interface that we've created! This will allow the end user (who,
    for security reasons, requires *root* access) to dynamically vary the debug level
    at runtime (a fairly common feature found in many products).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 整个架构的美妙之处 – 实际上整个重点在于 – 我们将能够通过我们创建的 procfs 接口从用户空间查询和设置这个 `debug_level` 变量！这将允许最终用户（出于安全原因，需要
    *root* 访问权限）在运行时动态地改变调试级别（这是许多产品中常见的功能）。
- en: 'Before diving into the code-level details, let''s try it out so that we know
    what to expect:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解代码级细节之前，让我们先试一下，这样我们就知道可以期待什么：
- en: 'Here, using our `lkm` convenience wrapper script, we must build and `insmod(8)`
    the kernel module (`ch2/proc_simple_intf` in this book''s source tree):'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，使用我们的 `lkm` 便捷包装脚本，我们必须构建并 `insmod(8)` 内核模块（本书源代码树中的 `ch2/proc_simple_intf`）：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we built and inserted the kernel module; `dmesg(1)` displays the kernel
    *printks* showing that one of the procfs files we created is the one pertaining
    to the dynamic debug facility (highlighted in bold here; since these are pseudo
    files, the file size will appear as `0` bytes).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们构建并插入了内核模块；`dmesg(1)` 显示了内核 *printks*，显示我们创建的 procfs 文件之一是与动态调试功能相关的文件（在这里用粗体突出显示；由于这些是伪文件，文件大小将显示为
    `0` 字节）。
- en: 'Now, let''s test it by querying the current value of `debug_level`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过查询 `debug_level` 的当前值来测试它：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Great, it''s zero – the default – as expected. Now, let''s change the debug
    level to `2`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很好，它是零 – 默认值 – 如预期的那样。现在，让我们将调试级别更改为 `2`：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice how we had to issue `echo` as *root*. As we can see, the debug level
    has indeed changed (to a value of `2`)! Attempting to set the value out of range
    is caught as well (and the `debug_level` variable''s value is reset to its last
    valid value), as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须以 *root* 身份发出 `echo`。正如我们所看到的，调试级别确实已经改变（为值 `2`）！尝试设置超出范围的值也被捕获（并且 `debug_level`
    变量的值被重置为其最后有效的值），如下所示：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Right; it worked as expected. However, the question is, how did all this work
    at the code level? Read on to find out!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它按预期工作。然而，问题是，所有这些在代码级别是如何工作的？继续阅读以了解详情！
- en: Dynamically controlling debug_level via procfs
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 procfs 动态控制 debug_level
- en: 'Let''s answer the aforementioned question – *how is it done in code?* It''s
    quite straightforward, really:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回答前面提到的问题 – *代码中是如何做到的？* 实际上非常简单：
- en: 'First off, within the `init` code of the kernel module, we must create our
    procfs directory, naming it after the name of our kernel module:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在内核模块的 `init` 代码中，我们必须创建我们的 procfs 目录，并以内核模块的名称命名它：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, within the `init` code of the kernel module, we must create the `procfs`
    file that controls the project''s "debug level":'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在内核模块的 `init` 代码中，我们必须创建控制项目“调试级别”的 `procfs` 文件：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we used the `proc_create()` API to create the *procfs* file and "linked"
    it to the supplied `file_operations` structure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `proc_create()` API 来创建 *procfs* 文件，并将其“链接”到提供的 `file_operations`
    结构。
- en: 'The fops structure (technically, `struct file_operations`) is the key data
    structure here. As we learned in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml),
    *Writing a Simple misc Character Device Driver*, it''s where we assign *functionality*
    to the various file operations on the device, or, as in this case, the procfs
    file. Here''s the code initializing our fops:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: fops结构（技术上是`struct file_operations`）在这里是关键的数据结构。正如我们在[第1章](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml)
    *编写简单的杂项字符设备驱动程序*中学到的，这是我们为设备上的各种文件操作分配*功能*的地方，或者在这种情况下，procfs文件。这是初始化我们的fops的代码：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `open` method of fops points to a function we must define:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: fops的`open`方法指向一个我们必须定义的函数：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the kernel's `single_open()` API, we register the fact that, whenever
    this file is read –  which is ultimately done via the `read(2)` system call from
    the user space – the proc filesystem will "call back" our `proc_show_debug_level()` routine
    (the second parameter to `single_open()`).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内核的`single_open()` API，我们注册了这样一个事实，即每当这个文件被读取时-最终是通过用户空间的`read(2)`系统调用完成的-
    proc文件系统将“回调”我们的`proc_show_debug_level()`例程（作为`single_open()`的第二个参数）。
- en: 'We won''t bother with the internal implementation of the `single_open()` API
    here; if you''re curious, you can always look it up here: `fs/seq_file.c:single_open()`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里打扰`single_open()` API的内部实现；如果你感兴趣，你可以在这里查找：`fs/seq_file.c:single_open()`。
- en: 'So, to summarize, to register a "read" method with procfs, we do the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，要在procfs中注册一个“读”方法，我们需要做以下工作：
- en: Initialize the `fops.open` pointer to a `foo()` function.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`fops.open`指针初始化为`foo()`函数。
- en: In the `foo()` function, call `single_open()`, providing the read callback function
    as the second parameter.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`foo()`函数中，调用`single_open()`，将读回调函数作为第二个参数。
- en: There's some history here; without getting too deep into it, suffice it to say
    that the older working of procfs had issues. Notably, you couldn't transfer more
    than a single page of data (with read or write) without manually iterating over
    the content. The *sequence iterator* functionality that was introduced with 2.6.12
    fixed these issues. Nowadays, using `single_open()` and its ilk (the `seq_read`,
    `seq_lseek`, and `seq_release` built-in kernel functions) is the simpler and correct
    approach to using procfs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些历史；不深入讨论，可以说procfs的旧工作方式存在问题。特别是，你无法在没有手动迭代内容的情况下传输超过一个页面的数据（使用读或写）。在2.6.12引入的*序列迭代器*功能解决了这些问题。如今，使用`single_open()`及其类似功能（`seq_read`、`seq_lseek`和`seq_release`内置内核函数）是使用procfs的更简单和正确的方法。
- en: 'So, what about when user space *writes* (via the `write(2)` system call) into
    a proc file? Simple: in the preceding code, you can see that we have registered
    the `fops_rdwr_dbg_level.write` method as the `myproc_write_debug_level()` function,
    implying that this function will be *called back* whenever this (pseudo) file
    is written to (it''s explained in *Step 6*, following the *read* callback).'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，当用户空间*写入*（通过`write(2)`系统调用）到一个proc文件时怎么办？简单：在前面的代码中，你可以看到我们已经注册了`fops_rdwr_dbg_level.write`方法作为`myproc_write_debug_level()`函数，这意味着每当写入这个（伪）文件时，这个函数将被*回调*（在*步骤6*中解释了*读*回调之后）。
- en: 'The code of the *read* callback function that we registered via `single_open` is
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`single_open`注册的*读*回调函数的代码如下：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`seq_printf()` is conceptually similar to the familiar `sprintf()` API. It
    correctly prints – to the `seq_file` object – the data supplied to it. When we
    say "prints" here, what we really mean is that it effectively passes the data
    buffer to the user space process or thread that issued the read system call that
    got us here in the first place, in effect *transferring the data to the user space.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`seq_printf()`在概念上类似于熟悉的`sprintf()` API。它正确地将提供给它的数据打印到`seq_file`对象上。当我们在这里说“打印”时，我们真正的意思是它有效地将数据缓冲区传递给发出了读系统调用的用户空间进程或线程，从而*将数据传输到用户空间*。'
- en: Oh yes, what's with the `mutex_{un}lock*()` APIs? They are for something critical –
    *locking.* We will provide a detailed discussion on locking in [Chapter 6](f456f2ea-ca5f-4d0f-b9c0-55b9ae92f659.xhtml),
    *Kernel Synchronization – Part 1*, and [Chapter 7](14cf1232-dfd5-428a-9c0b-30bcd84651b9.xhtml),
    *Kernel Synchronization – Part 2*; for now, just understand that these are required
    synchronization primitives.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，是的，`mutex_{un}lock*()` API是什么情况？它们用于一些关键的*锁定*。我们将在[第6章](f456f2ea-ca5f-4d0f-b9c0-55b9ae92f659.xhtml)
    *内核同步-第1部分*和[第7章](14cf1232-dfd5-428a-9c0b-30bcd84651b9.xhtml) *内核同步-第2部分*中对锁定进行详细讨论；现在，只需理解这些是必需的同步原语。
- en: 'The `write` callback function we registered via `fops_rdwr_dbg_level.write` is
    as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过`fops_rdwr_dbg_level.write`注册的*写*回调函数如下：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In our write method's implementation (notice how similar it is in structure
    to a character device driver's write method), we performed some validity checking
    and then copied in the data the user space process wrote to us (recall how we
    used the `echo` command to write to the procfs file) via the usual `copy_from_user()`
    function. We then used the kernel's built-in `kstrtoint()` API (there are several
    in a similar vein) to convert the string buffer into an integer, storing the result
    in our global variable; that is, `debug_level`! Again, we validate it, and if
    all's well, we also set (just as an example) our driver context's `config1` member
    to the same value and then return a success message.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的写方法实现中（注意它在结构上与字符设备驱动程序的写方法有多相似），我们进行了一些有效性检查，然后将用户空间进程写入的数据复制到我们这里（回想一下我们如何使用`echo`命令写入procfs文件），通过通常的`copy_from_user()`函数。然后，我们使用内核内置的`kstrtoint()`
    API（类似的还有几个）将字符串缓冲区转换为整数，并将结果存储在我们的全局变量中；也就是`debug_level`！再次验证它，如果一切正常，我们还设置（只是作为一个例子）我们驱动程序上下文的`config1`成员为相同的值，然后返回一个成功消息。
- en: The remainder of the kernel module's code is very similar – we set up the functionality
    for the remaining three procfs files. I leave it to you to browse through the
    code in detail and try it out.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核模块的其余代码非常相似-我们为剩下的三个procfs文件设置功能。我留给你详细浏览代码并尝试它。
- en: 'One more quick demo: let''s set `debug_level` to `1` and then dump the driver
    context structure (via the third procfs file we created):'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个快速演示：让我们将`debug_level`设置为`1`，然后通过我们创建的第三个procfs文件转储驱动程序上下文结构：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Okay, the `debug_level` variable will now have a value of `1`; now, let''s
    dump the driver context structure:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，`debug_level`变量现在将具有值`1`；现在，让我们转储驱动程序上下文结构：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We need *root* access to do this. Once done, we can clearly see all the members
    of our `drv_ctx` data structure. Not only that, but we verified that the `config1` member,
    highlighted in bold, now has a value of `1`, thus reflecting the "debug level"
    as designed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要*root*访问权限才能这样做。一旦完成，我们可以清楚地看到我们的`drv_ctx`数据结构的所有成员。不仅如此，我们还验证了加粗显示的`config1`成员现在的值为`1`，因此反映了设计的“调试级别”。
- en: Also, notice how the output is deliberately generated to the user space in a
    highly parseable format, almost JSON-like. Of course, as a small exercise, you
    could arrange to do precisely that!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意输出是故意以高度可解析的格式生成到用户空间，几乎类似于JSON。当然，作为一个小练习，你可以安排精确地做到这一点！
- en: A large number of recent **Internet of Things** (**IoT**) products use RESTful
    APIs to communicate; the format that's parsed is typically JSON. Getting in the
    habit of designing and implementing your kernel-to-user (and vice versa) communication
    in easily parsable formats (such as JSON) is only going to help.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最近大量的**物联网**（**IoT**）产品使用RESTful API进行通信；通常解析的格式是JSON。养成在易于解析的格式（如JSON）中设计和实现内核到用户（反之亦然）的通信的习惯只会有所帮助。
- en: With that, you have learned how exactly to create a procfs directory, a file
    within it, and, most importantly, how to create and use the read and write callback
    functions so that when a user mode process reads or writes your proc file, you
    can respond appropriately from deep within the kernel. As we mentioned earlier,
    due to a lack of space, we will not describe the code driving the remaining three
    procfs files we have created and used. This is very similar conceptually to what
    we have just covered. We expect you to read through and try it out!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你已经学会了如何创建procfs目录、其中的文件，以及最重要的是如何创建和使用读写回调函数，以便当用户模式进程读取或写入你的proc文件时，你可以从内核深处做出适当的响应。正如我们之前提到的，由于空间不足，我们将不描述驱动其余三个procfs文件的代码。从概念上讲，这与我们刚刚讨论的非常相似。我们希望你能仔细阅读并尝试一下！
- en: A few misc procfs APIs
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些杂项procfs API
- en: Let's conclude this section by looking at a few remaining miscellaneous procfs
    APIs. You can create a symbolic or soft link within `/proc` by using the `proc_symlink()`
    function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一些剩余的杂项procfs API来结束本节。你可以使用`proc_symlink()`函数在`/proc`中创建一个符号或软链接。
- en: 'Next, the `proc_create_single_data()` API can be very useful; it''s used as
    a "shortcut", where you require just a "read" method to be attached to a procfs
    file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`proc_create_single_data()` API可能非常有用；它被用作一个“快捷方式”，在那里你只需要将一个“读”方法附加到一个procfs文件：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using this API thus eliminates the need for a separate fops data structure.
    We can use this function to create and work with our second procfs file – the
    `llkdproc_show_pgoff` file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个API可以消除对单独的fops数据结构的需求。我们可以使用这个函数来创建和处理我们的第二个procfs文件——`llkdproc_show_pgoff`文件：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When read from the user space, the kernel''s VFS and proc layer code paths
    will invoke the registered method – the `proc_show_pgoff()` function of our module
    – within which we trivially invoke `seq_printf()` to send the value of `PAGE_OFFSET`
    to the user space:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户空间读取时，内核的VFS和proc层代码路径将调用已注册的方法——我们模块的`proc_show_pgoff()`函数——在其中我们轻松地调用`seq_printf()`将`PAGE_OFFSET`的值发送到用户空间：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Furthermore, note the following regarding the `proc_create_single_data` API:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`proc_create_single_data` API的以下内容：
- en: You can make use of the fifth parameter to `proc_create_single_data()` to pass
    any data item to the read callback (retrieved there as a `seq_file` member called
    `private`, very similar to how we used `filp->private_data` in the previous chapter).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以利用`proc_create_single_data()`的第五个参数将任何数据项传递给读回调（在那里作为`seq_file`成员`private`检索，非常类似于我们在上一章中使用`filp->private_data`的方式）。
- en: Several typically older drivers within the kernel mainline do make use of this
    function to create their procfs interfaces. Among them is the RTC driver (which
    sets up an entry at `/proc/driver/rtc`). The SCSI `megaraid` driver (`drivers/scsi/megaraid`) uses
    this routine no fewer than 10 times to set up its proc interfaces (when a config
    option is enabled; it is by default).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核主线中的一些通常较老的驱动程序确实使用这个函数来创建它们的procfs接口。其中之一是RTC驱动程序（在`/proc/driver/rtc`设置一个条目）。SCSI
    `megaraid`驱动程序（`drivers/scsi/megaraid`）使用这个例程至少10次来设置它的proc接口（当启用配置选项时；默认情况下是启用的）。
- en: Be careful! I find that on an Ubuntu 18.04 LTS system running the distro (default)
    kernel, this API – `proc_create_single_data()` – isn't even available, so the
    build fails. On our custom "vanilla" 5.4 LTS kernel, it works just fine.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 小心！我发现在运行分发（默认）内核的Ubuntu 18.04 LTS系统上，这个API——`proc_create_single_data()`——甚至都不可用，所以构建失败了。在我们自定义的“纯净”5.4
    LTS内核上，它运行得很好。
- en: 'In addition, there is some documentation on the procfs API we''ve set here,
    though this tends to be for internal usage and not for modules: [https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-proc-filesystem](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-proc-filesystem).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，关于我们在这里设置的procfs API，有一些文档，尽管这些文档往往是用于内部使用而不是用于模块：[https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-proc-filesystem](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-proc-filesystem)。
- en: So, as we mentioned previously, with the procfs APIs it's a case of **Your Mileage
    May Vary** (**YMMV**)! Carefully test your code before release. It's probably
    best to follow the kernel community guidelines and simply say **No** to procfs
    as a driver interfacing technique. Worry not – we'll look at better ones throughout
    this chapter!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们之前提到的，使用procfs API是一个**因人而异**（**YMMV**）的情况！在发布之前，请仔细测试你的代码。最好遵循内核社区的指南，并简单地对procfs作为驱动程序接口技术说**不**。不用担心，我们将在本章的其余部分中看到更好的方法！
- en: This completes our coverage on using procfs as a useful communication interface.
    Now, let's learn how to use a more appropriate one for drivers – the sysfs interface.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing via the sys filesystem (sysfs)
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A critical feature of the 2.6 Linux kernel release was the advent of what is
    called the modern *device model*. Essentially, a series of complex tree-like hierarchical
    data structures model all devices present on the system. Actually, it goes well
    beyond this; the **sysfs** tree encompasses the following (among other things):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Every bus present on the system (it can be a virtual or pseudo bus as well)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every device present on every bus
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every device driver bound to a device on a bus
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, it's not just peripheral devices but also the underlying system buses,
    the devices on each bus and the device driver bound or that will bind to a device,
    that are created at runtime and maintained by the device model. The inner workings
    of this model are invisible to you, as a typical driver author; you don't really
    have to worry about it. On system boot, and whenever a new device becomes visible,
    the *driver core* (part of the built-in kernel machinery) generates the required
    virtual files under the sysfs tree. (Conversely, when a device is removed or detached,
    its entry disappears from the tree.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Recall, though, from the *Interfacing with the proc filesystem* section, that
    using procfs for a device driver's interfacing purposes is not really the right
    approach, at least for code that wants to move upstream. So, what *is* the right
    approach? Ah, *creating sysfs (pseudo) files is considered the "correct way" for
    device drivers to interface with the user space.*
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we see it! sysfs is a virtual filesystem typically mounted on the `/sys` directory.
    In effect, sysfs, very similarly to procfs, is a kernel-exported tree of information
    (device and other) that''s sent to the user space. You can think of sysfs as having
    different *viewports* into the modern device model. Via sysfs, you can view the
    system in several different ways or via different "viewports"; for example, you
    can view the system via the various buses it supports (the *bus* view – PCI, USB,
    platform, I2C, SPI, among several others), via various "classes" of devices (the
    *class* view), via the *devices* themselves, via the *block* devices viewport,
    and so on. The following screenshot showing the content of `/sys` on my Ubuntu
    18.04 LTS VM shows this to be the case:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf6846b2-8f7a-47e3-98a2-be5528a87f22.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Screenshot showing the content of sysfs (/sys) on an x86_64 Ubuntu
    VM
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, with sysfs, there are several other viewports via that you can
    use to look into the system as well. Of course, in this section, we wish to understand
    how to interface a device driver to the user space via sysfs, how to write the
    code to create our driver (pseudo) files under sysfs, and how to register the
    read/write callbacks from them. Let's begin by looking at the basic sysfs APIs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sysfs (pseudo) file in code
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way to create a pseudo (or virtual) file under sysfs is via the `device_create_file()`
    API. Its signature is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's consider its two parameters one by one; first, there is a pointer to `struct
    device`. The second parameter is a pointer to a device attribute structure; we
    shall explain and work on it a bit later (in the *Setting up the device attributes
    and creating the sysfs file* section). For now, let's focus on the first parameter
    only – the device structure. It seems quite intuitive – a device is represented
    by a metadata structure called `device` (it is part of the driver core; you can
    look up its full definition in the `include/linux/device.h` header).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Note that when you write (or work on) a "real" device driver, chances are high
    that a generic *device structure* will exist or come into being. This often happens
    upon *registering* the device; an underlying device structure is usually made
    available as a member of a specialized structure for that device. For example,
    all structures, such as `platform_device`, `pci_device`, `net_device`, `usb_device`, 
    `i2c_client`, `serial_port` and so on, have a `struct device` member embedded
    within them. Thus, you can use that device structure pointer as a parameter to
    the API for the purpose of creating files under sysfs. Rest assured, you shall
    soon see this being done in code! So, let's get going by getting ourselves a device
    structure by creating a simple "platform device". You'll learn how to do this
    in the next section!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple platform device
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clearly, in order to create a (pseudo) file under sysfs, we somehow require,
    as the first parameter to `device_create_file()`, a pointer to a `struct device`.
    However, for our demo sysfs driver here and now, we don't actually have any real
    device, and therefore no `struct device`, to work on!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: So, can't we create an *artificial* or *pseudo device* and simply use it? Yes,
    but how, and more crucially, why exactly should we have to do this? It's critical
    to understand that the modern **Linux Device Model** (**LDM**) is built on three
    key components:** an underlying bus must exist that devices live on, and devices
    are "bound to" and driven by device drivers**. (We already mentioned this in [Chapter
    1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml), *Writing a Simple misc Character
    Device Driver*, in the *A quick note on the Linux Device Model *section).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: All of these must be registered to the driver core. Now, don't worry about the
    buses and the bus drivers that drive them; they will be registered and handled
    internally by the kernel's driver core subsystem. When there is no real *device*,
    however, we will have to create a pseudo one in order to work with the model.
    Again, there are several ways to do such things, but we shall create **a** ***platform
    device**.* This device will "live" on a pseudo bus (that is, it exists only in
    software) known as the ***platform bus**.*
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Platform devices
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A quick but important aside: *platform devices* are often used to represent
    the variety of devices on a **System on Chip** (**SoC**) within an embedded board.
    The SoC is typically a very sophisticated chip that integrates various components
    into its silicon. Besides processing units (CPUs/GPUs), it might house several
    peripherals too, including Ethernet MAC, USB, multimedia, serial UART, clock,
    I2C, SPI, flash chip controllers, and so on. A reason we need these components
    to be enumerated as a platform device is that there is no physical bus within
    the SoC; thus, the platform bus is used.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, the code that was used to instantiate these SoC platform devices
    was kept in a "board" file (or files) within the kernel source (`arch/<arch>/...`).
    Due to it becoming overloaded, it's been moved outside the pure kernel source
    into a useful hardware description format called the **Device Tree** (within **Device
    Tree Source** (**DTS**) files that are themselves with the kernel source tree).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'On our Ubuntu 18.04 LTS guest VM, let''s look at the platform devices under
    sysfs:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The *Bootlin* website (previously called *Free Electrons*) offers superb materials
    on embedded Linux, drivers, and so on. This link on their site leads to excellent
    material on the LDM: [https://bootlin.com/pub/conferences/2019/elce/opdenacker-kernel-programming-device-model/](https://bootlin.com/pub/conferences/2019/elce/opdenacker-kernel-programming-device-model/).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the driver: we bring our (artificial) platform device into existence
    by registering it to the (already existing) platform bus driver via the `platform_device_register_simple()`
    API. The moment we do so, the driver core will *generate* the required sysfs directories
    and a few boilerplate sysfs entries (or files). Here, in the init code of our
    sysfs demo driver, we will set up a (simplest possible) *platform device* by registering
    it to the driver core:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `platform_device_register_simple()` API returns a pointer to `struct platform_device`.
    One of this structure''s members is `struct device dev`. We now have what we''ve
    been after: a *device* *structure*. Also, it''s key to note that when this registration
    API runs, the effect is visible within sysfs*.* You can easily see the new platform
    device, plus a few boilerplate sysfs objects, being created by the driver core
    here (made visible to us via sysfs); let''s build and *insmod* our kernel module
    to see this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can create a `struct device` in different ways; the generic way is to set
    up and issue the `device_create()` API. An alternate means to creating a sysfs
    file, while bypassing the need for a device structure, is to create a "object"
    and invoke the `sysfs_create_file()` API. (Links to tutorials that use both these
    approaches can be found in the *Further reading* section). Here, we prefer to
    use a "platform device" as it's the closer approach to writing a (platform) driver.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: There's yet another valid approach. As we saw in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml),
    *Writing a simple misc Character Device Driver*, we built a simple character driver
    conforming to the kernel's `misc` framework. There, we instantiated a `struct
    miscdevice`; once registered (via the `misc_register()` API), this structure will
    contain a member called `struct device *this_device;`, thus allowing us to use
    it as a valid device pointer! Thus, we could have simply extended our earlier
    `misc` device driver and used it here. However, in order to learn a bit about
    platform drivers, we've chosen that approach. (We leave the approach of extending
    our earlier `misc` device driver so that it can use sysfs APIs and create/use
    sysfs files as an exercise to you).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our driver, compared to the init code, in the *cleanup* code, we must
    un-register our platform device:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let's tie all this knowledge together and actually see the code that generates
    the sysfs files, along with their read and write callback functions!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Tying it all together – setting up the device attributes and creating the sysfs
    file
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned at the beginning of this section, the `device_create_file()`
    API is the one we''ll use to create our sysfs file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the previous section, you learned how we obtain a device structure (the
    first parameter for our API). Now, let''s figure out how to initialize and use
    the second parameter; that is, the `device_attribute` structure. The structure
    itself is defined as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first member, `attr`, essentially consists of the *name* of the sysfs file
    and its *mode* (permission bitmask). The other two members are function pointers
    ("virtual functions", analogous to those in the **file operations** or **fops**
    structure):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '`show`: Represents the *read callback* function'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`store`: Represents the *write callback* function'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our job is to initialize this `device_attribute` structure, thus setting up
    the sysfs file. While you can always manually initialize it, there''s an easier
    approach: the kernel provides (several) macros for initializing `struct device_attribute`;
    among them is the `DEVICE_ATTR()` macro:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice the "stringification" that''s performed by `dev_attr_##_name`, ensuring
    that the structure''s name is suffixed with the name that''s passed as the first
    parameter to `DEVICE_ATTR`. Furthermore, the actual "worker" macro, named `__ATTR()`,
    actually instantiates a `device_attribute` structure in code at preprocessing
    time, with (via stringification) the name of the structure becoming `dev_attr_<name>`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Furthermore, the kernel defines additional simple wrapper macros over these
    macros in order to specify the *mode* (permissions for the sysfs file), thus making
    it even simpler for you, the driver author. Among them is `DEVICE_ATTR_RW(_name)`,
    `DEVICE_ATTR_RO(_name)`, and `DEVICE_ATTR_WO(_name)`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With this code, we can create a **read-write** (**RW**), **read-only** (**RO**),
    or **write-only** (**WO**) sysfs file. Now, we wish to set up a sysfs file that
    can be read and written to. Internally, this is a "hook" or callback for us to
    query or set a `debug_level` global variable just as we did in the sample kernel
    module on procfs earlier!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have sufficient background, let's delve into the code!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The code for implementing our sysfs file and its callbacks
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at the relevant parts of the code for our simple *sysfs interfacing
    driver* and try things out, step by step:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the device attribute structure (via the `DEVICE_ATTR_RW` macro; see
    the preceding section for more information) and create our first sysfs (pseudo)
    file:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: From the definition of the macros shown here, we can infer that `static DEVICE_ATTR_RW(SYSFS_FILE1);` instantiates
    an initialized `device_attribute` structure with the name `llkdsysfs_debug_level`
    (as that's what the `SYSFS_FILE1` macro evaluates to) and a mode of `0644`; the
    read callback name will be `llkdsysfs_debug_level_show()` and the write callback
    name will be `llkdsysfs_debug_level_store()`!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the relevant code for the read and write callbacks (again, we won''t
    show the entire code here). First, let''s look at the read callback:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How does this work? On reading our sysfs file, the preceding callback function
    is invoked. Within it, simply writing into the user-supplied buffer pointer, `buf`
    (its third parameter; we used the kernel `snprintf()` API to do so), has the effect
    of transferring the value provided *(*here, `debug_level`) to the user space!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build and `insmod(8)` the kernel module (for convenience, we will use
    our `lkm` wrapper script to do so):'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s list and read the sysfs file pertaining to the debug-level:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This reflects the fact that debug-level is currently `0`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s peek at the code of our *write callback* for the debug-level sysfs
    file:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again, it should be clear that the `kstrtoint()` kernel API is used to convert
    the user space `buf` string into an integer value, which we then validate. Also,
    the third parameter to `kstrtoint` is the integer to write to, thus updating it!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try updating the value of `debug_level` from its sysfs file:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Voila – it works!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did when we interfaced with procfs, we have provided more code in the
    sysfs code example. Here, we have another (read-only) sysfs interface to display
    the value of `PAGE_OFFSET`, plus a new one. Imagine that this driver''s job is
    to retrieve a "pressure" value (perhaps via an I2C-driven pressure sensor chip).
    Let''s imagine we have done so, and stored this pressure value in an integer global
    variable named `gpressure`. To "show" the user space the current pressure value,
    we must use a sysfs file. Here it is:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Internally, for the purpose of this demo, we have randomly set the `gpressure` global
    variable to a value of `25`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Look carefully at the output; why does the prompt appear immediately after `25`?
    Because we just printed the value as-is – no newline, nothing; that''s what is
    expected. The code that displays the "pressure" value is simple indeed:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With that, you've learned how to interface with the user space via sysfs! As
    usual, I urge you to actually write the code and try out these skills yourself;
    take a look at the *Questions* section at the end of this chapter and try out
    the (relevant) assignments yourself. Now, let's continue with sysfs, understanding
    an important *rule* regarding its ABI.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The "one value per sysfs file" rule
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have understood how to create and make use of sysfs for user space
    kernel interfacing purposes, but there is a key point that we have been ignoring.
    There is a "rule" regarding using sysfs files, which states that you must only
    read or write exactly one value! Think of this as the *one-value-per-file* rule.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: So, as in the example where we used the "pressure" value, we merely return the
    current value of the pressure, nothing more. Thus, sysfs, unlike the other interfacing
    technologies, is not quite suited to those cases where you might want to return
    arbitrary long-winded information packets (say, the contents of the driver context
    structure) to the user space; in other words, it's not suited to pure "debugging"
    purposes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel documents and "rules" regarding the usage of sysfs can be found
    here: [https://www.kernel.org/doc/html/latest/admin-guide/sysfs-rules.html#rules-on-how-to-access-information-in-sysfs](https://www.kernel.org/doc/html/latest/admin-guide/sysfs-rules.html#rules-on-how-to-access-information-in-sysfs).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, there is documentation on the sysfs API here: [https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-filesystem-for-exporting-kernel-objects](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-filesystem-for-exporting-kernel-objects).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel typically provides several different means of creating sysfs objects;
    for example, with the `sysfs_create_files()` API, you can create multiple sysfs
    files in one go: `int __must_check sysfs_create_files(struct kobject *kobj, const
    struct attribute * const *attr);`. Here, you are expected to supply a pointer
    to a `kobject` and a pointer to a list of attribute structures.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of sysfs as an interfacing technology; in summary,
    sysfs is indeed considered the *right way* for driver authors to display and/or
    set a particular driver value to and from the user space. Due to the "one value
    per sysfs file" convention, sysfs is really not ideally suited to debugging information
    dispensation. This neatly brings us to our next topic – debugfs!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing via the debug filesystem (debugfs)
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine for a moment, the quandary faced by you, a driver developer, on Linux:
    you want to implement an easy yet elegant way to provide debug "hooks" from your
    driver to the user space. For example, the user simply performing a `cat(1)` on
    a (pseudo) file should result in your driver''s "debug callback" function being
    invoked. It will then proceed to dump some status information (perhaps a "driver
    context" structure) to the user mode process, which will faithfully dump it to
    stdout.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, no problem: in the days before the 2.6 release, we could (as you learned
    in the *Interfacing via the proc filesystem (procfs)* section) happily use the
    procfs layer to interface our driver with the user space. Then, from 2.6 Linux
    onward, the kernel community vetoed this approach. We were told to strictly stop
    using procfs and instead use the sysfs layer as the means to interface our drivers
    with the user space. However, as we saw in the *Interfacing* *via the sys filesystem
    (sysfs)* section, it has a strict *one-value-per-file* rule. This is actually
    great for reporting or sending single values from and to the driver (typically,
    environment sensor values and similar), but quickly rules out all but the most
    trivial debug interfaces to the user space. We could use the ioctl approach (as
    we shall see) to set up a debug interface but it''s quite a bit harder to do so.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: So, what can you do? Luckily, there is an elegant solution in place from around
    2.6.12 Linux onward called debugfs. The "debug filesystem" is very easy to use
    and quite explicit in communicating the fact that driver authors (anyone, in fact)
    can use it for whatever purpose they choose! There is no one-value-per-file rule –
    forget that, there are no rules.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Of course, just as with the other filesystem-based approaches we have dealt
    with – procfs, sysfs, and now debugfs – the kernel community clearly claims that
    all these interfaces are an ABI, and thus, that their stability and lifespan is
    something that is *not *guaranteed. While that is the formal stance that's adopted,
    the reality is that these interfaces have become de facto ones in the real world;
    stripping them out without preamble one fine day wouldn't really serve anybody.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the content of debugfs on our x86-64 Ubuntu
    18.04.3 LTS guest (running the "custom" 5.4.0 kernel we built back in our companion
    book *Linux Kernel Programmin*g, *Chapter 3*, *Building the 5.0 Linux kernel from
    Source, Part 2*!):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d01e778c-ea1a-4934-8283-30d35557238d.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Screenshot revealing the content of the debugfs filesystem on an
    x86_64 Linux VM
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: As with procfs and sysfs, due to debugfs being a kernel feature (it's a virtual
    filesystem, after all!), the precise content within it is highly dependent on
    the kernel version and CPU architecture. As we mentioned previously, by looking
    at this screenshot, it should now be obvious that there are plenty of real-world
    "users" of debugfs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Checking for the presence of debugfs
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First off, in order to make use of the powerful *debugfs* interface, it must
    be enabled within the kernel config. The relevant Kconfig macro is `CONFIG_DEBUG_FS`.
    Let''s check whether it''s enabled on our 5.4 custom kernel:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are assuming you have the `CONFIG_IKCONFIG` and `CONFIG_IKCONFIG_PROC`
    options set to `y`, thus allowing us to use the `/proc/config.gz` pseudo file
    to access the current kernel's configuration.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Indeed it is; it's typically enabled by default in distributions.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the default mount point of debugfs is `/sys/kernel/debug`. Thus, we can
    see that it is internally dependent on the sysfs kernel feature being present
    and mounted, which it is by default. Let''s check where debugfs is mounted on
    our Ubuntu 18.04 x86_64 VM:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It is available and mounted at the expected location; that is, `/sys/kernel/debug`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, it''s always a best practice to never assume that this will always
    be the location where it''s mounted; in your script or user mode C program, take
    the trouble to check and verify it. In fact, allow me to rephrase this: *it''s
    always a good practice to never assume anything; making assumptions is a really
    good source of bugs*.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: By the way, an interesting Linux feature is that filesystems can be mounted
    in different, even multiple, locations; also, some folks prefer to create a symbolic
    link to `/sys/kernel/debug` as `/debug`; it's up to you, really.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: As usual, our intention here is to create our (pseudo) files under the debugfs
    umbrella, and then register and make use of the read/write callbacks from them,
    for the purpose of interfacing our driver with the user space. To do so, we need
    to understand the basic usage of the debugfs API. We will point you to the documentation
    for this in the next section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Looking up the debugfs API documentation
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The kernel supplies succinct and superb documentation on using the debugfs
    API (courtesy of Jonathan Corbet, LWN) here: [https://www.kernel.org/doc/Documentation/filesystems/debugfs.txt](https://www.kernel.org/doc/Documentation/filesystems/debugfs.txt)
    (of course, you can also look it up directly within the kernel codebase).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'I urge you to refer to this document to learn how to use the debugfs APIs,
    since it''s easy to read and understand; this way, you can avoid unnecessarily
    repeating the same information here. In addition to the aforementioned document,
    the modern kernel documentation system (the "Sphinx"-based one) also provides
    quite detailed debugfs API pages: [https://www.kernel.org/doc/html/latest/filesystems/api-summary.html?highlight=debugfs#the-debugfs-filesystem](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html?highlight=debugfs#the-debugfs-filesystem).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Note that all debugfs APIs are exported as GPL-only to kernel modules (thus
    necessitating the module being released under the "GPL" license (this can be dual
    licensed, but one must be "GPL")).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: An interfacing example with debugfs
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugfs, being deliberately designed with a "no particular rules" mindset, makes
    it the ideal interface to use *for debug purposes*. Why? It allows you to construct
    any arbitrary byte stream and send it off to the user space, including a binary
    "blob" with the `debugfs_create_blob()` API.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Our previous example kernel modules with procfs and sysfs constructed and used
    three to four (pseudo) files. For a quick demo with debugfs, we shall just stick
    to two "files":'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '`llkd_dbgfs_show_drvctx`: As you''ll have no doubt guessed, when read, it will
    cause the current content of our (by now familiar) "driver context" data structure
    to be dumped to the console; we shall ensure the pseudo file''s mode is read-only
    (by root).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`llkd_dbgfs_debug_level`: This file''s mode shall be read-write (by root only);
    when read, it will display the current value of `debug_level`; when an integer
    is written to it, we shall update the value of `debug_level` within the kernel
    module to the value passed.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, in the init code of our kernel module, we will first create a directory
    under `debugfs`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now that we have a starting point – a directory – let's move on and create the
    debugfs (pseudo) files under it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using the first debugfs file
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For readability and to save space, we won't show the error handling code sections
    here.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Just as in the example with procfs, we must allocate and initialize an instance
    of our "driver context" data structure (we haven't shown the code here as it's
    repetitive, so please refer to the GitHub source).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, via the generic `debugfs_create_file()` API, we must create a `debugfs` file,
    associating it with a `file_operations` structure. This, in effects, gets just
    a read callback registered:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: From 5.8 Linux onward (recall that we're working with the 5.4 LTS kernel), the
    return value of several of the debugfs creation APIs have been removed (they will
    return `void`); Greg Kroah-Hartman's patch mentions that this was done as no one
    was using them. This is quite typical of Linux – unneeded features are stripped
    off, and kernel evolution continues...
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, the "read" callback is our `dbgfs_show_drvctx()` function. As a reminder,
    this function gets auto-invoked by the debugfs layer whenever the `debugfs` file
    (`llkd_dbgfs_show_drvctx`) is read; here''s the code for our debugfs read callback
    function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice how we retrieve the "data" pointer (our driver context structure) by
    dereferencing the debugfs files' inode member, which is called `i_private`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml),
    *Writing a Simple misc Character Device Driver*, using the `data` pointer to dereference
    the driver context structure from the file's inode is one of a number of similar,
    common techniques employed by driver authors to avoid the use of globals. Here,
    `gdrvctx` *is* a global, so it's a moot point; we are simply using it to demonstrate
    the typical use case.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Using the `snprintf()` API, we can populate a local buffer with the current
    content of our driver's "context" structure, and then, via the `simple_read_from_buffer()`
    API, pass it up to the user space app that issued the read, which typically causes
    it to be displayed on the Terminal/console window. This `simple_read_from_buffer()`
    API is a wrapper over `copy_to_user()`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give it a spin:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As we can see, the two debugfs files are created as expected; let''s verify
    this (be careful here; you can only look into debugfs as *root*):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The pseudo files have been created and have the correct permissions. Now, let''s
    read (as root user) from the `llkd_dbgfs_show_drvctx` file:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It works; performing the read again a few seconds later. Notice how the value
    of `config3` has changed. Why? Recall that we set it to the `jiffies` value –
    the number of timer "ticks"/interrupts – that have occurred since system boot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Having created and used our first debugfs file, let's understand the second
    debugfs file.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using the second debugfs file
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s move on to the second debugfs file. We will create it using an interesting
    shortcut helper debugfs API named `debugfs_create_u32()`. This API *automatically*
    sets up internal callbacks, allowing you to read/write upon the specified unsigned
    32-bit global variable within the driver. The main advantage of this "helper"
    routine is that you don''t need to explicitly provide a `file_operations` structure
    or even any callback routines. The debugfs layer "understands" and internally
    sets things up so that reading or writing the numeric (global) variable will always
    just work! Take a look at the following code in the *init* codepath, which creates
    and sets up our second debugfs file:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It''s as simple as that! Now, reading this file will produce the current value
    of `debug_level`; writing to it will set it to the value written. Let''s do this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This works, but there is a downside to this "shortcut" approach: since this
    is all done internally, there is no way for us to *validate* the value being written.
    Thus, here, we wrote the value `5` to `debug_level`; it worked, but it''s an invalid
    value (at least let''s assume that''s the case)! So, how can this be corrected?
    Simple: do not use this helper method; instead, do it the "usual" way via the
    generic `debugfs_create_file()` API (as we did for the first debugfs file). The
    advantage here is that as we set up explicit callback routines for read and write,
    by specifying them within a fops structure, we have control over the value being
    written (I leave doing this to you, as an exercise). Like life, it''s a trade-off;
    you win some, you lose some.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Helper debugfs APIs for working on numeric globals
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have just learned how to use the `debugfs_create_u32()` helper API to set
    up a debugfs file to read/write an unsigned 32-bit integer global. The fact is,
    the debugfs layer provides a bunch of similar "helper" APIs to implicitly read/write
    on numeric (integer) global variables within your module.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'The helper routines for creating debugfs entries that can read/write different
    bit size unsigned integer (8-, 16-, 32-, and 64-bit) globals follow. The last
    parameter is the key one – the address of the global integer within the kernel/module:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The preceding APIs work with decimal base; to make using *hexadecimal base*
    easy, we have the following helpers:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As an aside, the kernel also provides a helper API for those cases where the
    precise *size* of the variable varies; hence, using the `debugfs_create_size_t()`
    helper creates a debugfs file appropriate for a variable of size `size_t`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: For drivers that merely need to peek at a numeric global, or update it without
    any worry about invalid values, these debugfs helper APIs are very useful and
    are indeed commonly used by several drivers in the mainline kernel (we will look
    at an example within the MMC driver shortly). To evade the "validity check" issue,
    often, we can arrange for the *user space* application (or script) to perform
    validity checking; in fact, this is typically the "right way" to do things.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'The UNIX paradigm has a saying: *provide mechanism, not policy.*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with globals that are of the *boolean* type, debugfs provides
    the following helper API:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Reading from the "file" will result in only `Y` or `N` (suffixed with a newline)
    being returned; obviously, `Y` if the current value of the fourth `value` parameter
    is non-zero, and `N` otherwise. When writing, you can write `Y` or `N` or `1`
    or `0`; other values will not be accepted.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about it: you can control your "robot" device via your robot device driver
    by writing `1` to a boolean variable called, say, `power` to turn it on, and use `0`
    to turn it off! The possibilities are endless.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The kernel documentation on debugfs provides a few more miscellaneous APIs;
    I leave it to you to have a look. Now that we've covered how to create and use
    our demo debugfs pseudo files, let's learn how to remove them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Removing the debugfs pseudo file(s)
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a module is removed (via, say, `rmmod(8)`), we must delete our debugfs
    files. The older way to do this was via the `debugfs_remove()` API, where each
    debugfs file had to be individually removed with it (painful, to say the least).
    The modern approach makes this really simple:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Pass the pointer to the overall "parent" directory (the one we created first),
    and the entire branch is recursively removed; perfect.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Not deleting your debugfs files at this point, thus leaving them there on the
    filesystem in an orphaned state, is asking for trouble! Just think about this:
    what will happen when someone (attempts to) reads or writes to any of them later?
    **A kernel bug, or an *Oops***, that''s what.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Seeing a kernel bug – an Oops!
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's make it happen – a kernel bug! Exciting, yes!?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Okay, to create a kernel bug, we must ensure that when we remove (unload) the
    kernel module, the API that cleans up (deletes) all the debugfs files, `debugfs_remove_recursive()`,
    is *not *invoked. Thus, after each module is removed, our debugfs directory and
    files seem to be present! However, if you try and operate on – read/write – any
    of them, they'll be in an *orphaned state* and, hence, upon trying to dereference
    its metadata, the internal debugfs code paths will perform an invalid memory reference,
    resulting in a (kernel-level) bug.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: In the kernel space, a bug is a very serious thing indeed; in theory, it should
    never, ever happen! This is called an *Oops;* as part of handling this, an internal
    kernel function is called, which dumps useful diagnostic information via `printk` to
    the in-memory kernel log buffer, as well as to the console device (on production
    systems, it might also be directed elsewhere so that it can be retrieved and investigated
    at a later date; for example, via the kernel's *kdump* mechanism).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce a module parameter that controls whether we (quite deliberately)
    cause an *Oops* to occur or not:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the cleanup code path of our driver, we check if the `cause_an_oops` variable
    is non-zero and deliberately do *not* (recursively) delete our debugfs file(s),
    hence setting up the bug:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When we "normally" use `insmod(8)`, the scary `cause_an_oops` module parameter
    is `0` by default, thus ensuring that everything works well. But let''s get adventurous!
    We are building the kernel module and when we insert it, we must pass the parameter
    while setting it to `1` (notice that here, we''re running as *root* on our x86_64
    Ubuntu 18.04 LTS guest system on our custom `5.4.0-llkd01` kernel):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s remove the kernel module – internally, the code that''s used to
    clean up (recursively delete) our debugfs file would not have run. Here, we are
    actually triggering the kernel bug, the *Oops,* by attempting to read one of our
    debugfs files:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `Killed` message on the console is ominous! This is a clue that something
    has gone (dramatically) wrong. Viewing the kernel log confirms that we indeed
    got an *Oops!* The following (partially cropped) screenshot shows this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b9849ec-98d3-4fa8-a772-87b4d6fa656b.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – A partial screenshot of a kernel Oops, a kernel-level bug
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Since provided kernel debugging details is beyond the scope of this book, we
    will not delve into the details here. Nevertheless, figuring out a little bit
    is quite intuitive. Look carefully at the preceding screenshot: in the `BUG:`
    statement, you can see the **kernel virtual address** (**kva**) whose lookup caused
    the bug, known as the Oops (we covered the kva space in the companion guide, *Linux
    Kernel Programming – Chapter 7, Memory Management Internals Essentials*; this
    is really key information for driver authors):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This shows the CPU (`1`) that the process context (`cat`) was running on, the
    tainted flags, and the kernel version. One of the really key pieces of output
    is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This tells you that the CPU instruction pointer (the register named RIP on the
    x86_64) was in the `debugfs_u32_get()` function at an offset of `0x5` bytes from
    the start of the machine code of the function (furthermore, the kernel figures
    out that the length of the function is `0x20` bytes)!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Combining this information with powerful tools such as `objdump(1)` and `addr2line(1)`
    can help to literally pinpoint the location of the bug in code!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'The CPU registers are dumped; even better, the *call trace *or the *call stack*
    – the *content of the kernel mode stack* of the process context (please refer
    to *Linux Kernel Programming*, in *Chapter 6*, *Kernel Internals Essentials, Processes
    and Threads,* for details on the kernel stack) – shows you the code that led up
    to this point; that is, the crash (read the stack trace bottom-up). Another quick
    tip: if a kernel function in the call trace''s output is preceded by a `?` symbol,
    just ignore it (it''s perhaps a previous "blip" that was left behind).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Realistically, a kernel bug on a production system *must* cause the entire system
    to panic (halt). On non-production systems (like what we're running on), a kernel
    panic may or may not occur; here, it doesn't. Nevertheless, a kernel bug must
    be treated with the highest level of severity, it's indeed a show-stopper and
    must be fixed. The procfs file, `/proc/sys/kernel/panic_on_oops`, is set to `0`
    by most distros, but on production systems, it will typically be set to the value `1`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'The moral here is clear: there is no auto cleanup being performed by debugfs;
    we have to do it. Right, let''s wrap up this discussion on debugfs by looking
    up some actual real-world usage within the kernel.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Debugfs – actual users
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned previously, there are several "real-world" users of the debugfs
    API; can we spot some of them? Well, here''s one way: simply search under the
    kernel source tree''s `drivers/` directory for files named `*debugfs*.c`; you
    might be surprised (I found 114 such files in the 5.4.0 kernel tree!). Let''s
    take a look at a few:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Have a look at (some of) them; their code exposes debugfs interfaces. This
    is not always done for mere debug purposes; many of the debugfs files are for
    actual production usage! As an example, the MMC driver contains the following
    line of code, which makes use of the debugfs "helper" API to get an x32 global:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This creates a debugfs file called `state` that, when read, displays the "state"
    of the card.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Okay, this completes our coverage of how to interface with the user space via
    the powerful debugfs framework. Our demo debugfs driver created a debugfs directory
    and two debugfs pseudo files within it; you then learned how to set up and use
    both read and write callback handlers for them. The "shortcut" APIs (such as `debugfs_create_u32()`
    and friends) are powerful too. Not only that, but we even managed to generate
    a kernel bug – an Oops! Now, let's learn how to communicate over a special type
    of socket, known as a netlink socket.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing via netlink sockets
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, you'll learn to interface kernel and user spaces with a familiar and indeed
    ubiquitous network abstraction – sockets! Programmers familiar with network application
    programming swear by its advantages.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Familiarity with network programming in C/C++ with socket APIs helps here. Do
    see the *Further reading* section for a couple of good tutorials on this topic.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Advantages using sockets
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Among others, socket technology provides us with several advantages (over other
    typical user mode IPC mechanisms such as pipes, SysV IPC/POSIX IPC mechanisms
    (message queues, shared memory, semaphores, and so on)), as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional simultaneous data transfer (full duplex).
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lossless on the internet, with at least with some transport layer protocols,
    such as TCP, and of course, on the localhost, which is the case here.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-speed data transfer, especially on localhost!
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow control semantics are always in effect.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous communication; messages can be queued, so the sender does not have
    to wait for the receiver.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Especially with respect to our topic, in other user<->kernel communication paths
    (such as procfs, sysfs, debugfs, and ioctl), the user space app must initiate
    the transfer to the kernel space; with netlink sockets, *the kernel can initiate
    a transfer.*
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, with all the other mechanisms we have seen so far (procfs, sysfs, and
    debugfs), the various interface files being strewn all over the filesystem(s)
    can cause kernel namespace pollution; with netlink sockets (and, incidentally,
    with ioctl), this isn't the case as there are no files.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These advantages can be helpful, depending on the type of product you're working
    on. Now, let's understand what a netlink socket is.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what a netlink socket is
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what is a netlink socket? We shall keep it simple – a *netlink socket* is
    a "special" socket family that exists only on the Linux OS since version 2.2\.
    Using it, you can set up **Inter-Process Communication** (**IPC**) between a user
    mode process (or thread) and a component within the kernel; in our case, a kernel
    module, which is typically a driver.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: It is similar to a UNIX domain datagram socket in many ways; it's meant for
    communication on the *localhost* *only* and not across systems. While UNIX domain
    sockets use a pathname as their namespace (a special "socket" file), netlink sockets
    use a PID. Pedantically, this is a port ID and not a process ID, although realistically,
    process IDs are very often used as the namespace. The modern kernel core (besides
    drivers) uses netlink sockets in many cases – as one example, the iproute2 networking
    utilities use it to configure wireless drivers. As another interesting example,
    the udev feature uses netlink sockets to effect communication between the kernel
    udev implementation and the user space daemon process (udevd or systemd-udevd,
    for things such as device discovery, device node provisioning, and so on).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will design and implement a simple user<->kernel messaging demonstration
    using netlink sockets. To do so, we shall have to write two programs (at a minimum)
    – one as the user space application that issues socket-based system calls, and
    another for the kernel-space component (here, a kernel module). We shall have
    the user space process send a "message" to the kernel module; the kernel module
    should receive it and print it (into the kernel log buffer). The kernel module
    will then reply to the user space process, which is blocking on this very event.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: So, without further ado, let's dive into writing some code using netlink sockets;
    we shall begin with the user space application. Read on!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Writing the user space netlink socket application
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps get the *user space* application running:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we must do is get ourselves a *socket*. Traditionally, a socket
    is defined as an endpoint of communication; thus, a pair of sockets forms a connection.
    We will use the `socket(2)` system call to do this. Its signature is
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int socket(int domain, int type, int protocol);`.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Without going into too much detail, here''s what we do:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: We specify `domain` as part of the special `PF_NETLINK` family, thus requesting
    a netlink socket.
  id: totrans-362
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `type` to `SOCK_RAW` using a raw socket (effectively skipping the transport
    layer).
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protocol` is the protocol to use. Since we''re using a raw socket, the protocol
    is left to be implemented either by us or by the kernel; having the kernel netlink
    code do this is the right approach. Here, we use an unused protocol number; that
    is, `31`.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to bind the socket via the usual `bind(2)` system call semantics.
    First, we must initialize a netlink source `socketaddr` structure for this purpose
    (where we specify the family as a netlink and the PID value as the calling process''
    PID (for unicast only)). The following code is for the first two steps mentioned
    here (for clarity, we won''t be displaying the error checking code here):'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we must initialize a netlink "destination address" structure. Here, we
    set the PID member to `0`, a special value indicating that the destination is
    the kernel:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we must allocate and initialize a netlink "header" data structure. Among
    other things, it specifies the source PID and, importantly, the data "payload"
    that we shall deliver to our kernel component. Here, we are making use of helper
    macros such as `NLMSG_DATA()` to specify the correct data location within the
    netlink header structure:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, an `iovec` structure must be initialized to reference the netlink header,
    and a `msghdr` data structure must be initialized to point to the destination
    address and `iovec`:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, the message is sent (transmitted) via the `sendmsg(2)` system call
    (which takes the socket descriptor and the aforementioned `msghdr` structure as
    a parameter):'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The kernel component – a kernel module, which we shall discuss shortly – should
    now receive the message via its netlink socket and display the message''s content;
    we arrange for it to then politely reply. To grab the reply, our user space app
    must now perform a blocking read on the socket:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We must employ the `recvmsg(2)` system call to do this. When it gets unblocked,
    it states that the message has been received.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Why so much abstraction and wrapping for data structures? Well, it's how things
    often evolve – the `msghdr` structure was created so that the `sendmsg(2)` API
    can use fewer parameters. But that implies the parameters have to go somewhere;
    they go deep inside `msghdr`, which points to the destination address and `iovec`,
    whose `base` member points to the netlink header structure, which contains the
    payload! Whew.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'As an experiment, what if we build and run the user mode netlink application
    prematurely – *without* the kernel-side code in place? It will fail, of course...
    But how exactly? Well, use the empirical approach. By trying this out via the
    venerable `strace(1)` utility, we can see that the `socket(2)` system call returns
    a failure, the cause being `Protocol not supported`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This is correct; there is no such `protocol # 31` (`31` = `0x1f`, the protocol
    number we''re using) in place *yet* within the kernel! We''re yet to do this.
    So, that''s the user space side of things. Now, let''s complete the puzzle and
    have it actually work! We''ll do this by seeing how the kernel component (module/driver)
    is written.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Writing the kernel-space netlink socket code as a kernel module
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The kernel provides the base infrastructure for netlink, including APIs and
    data structures; all the required ones are exported and thus available to you
    as a module author. We use several of them; the steps to program our kernel netlink
    component – our kernel module – are outlined here:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with the user space app, the first thing we must do is get ourselves
    a netlink socket. The kernel API is `netlink_kernel_create()`, and its signature
    is as follows:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The first parameter is a generic network structure; we pass the kernel''s existing
    and valid `init_net` structure here. The second parameter is the *protocol number
    (unit)* to use; we shall specify the same number (`31`) as we did for the user
    space app. The third parameter is a pointer to an (optional) netlink configuration
    structure; here, we only set the input member to a function of ours nullifying
    the rest. This function is called back when a user space process (or thread) provides
    any input (that is, transmits something) to the kernel netlink component. So,
    within our kernel module''s `init` routine, we have the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As we mentioned previously, when a user space process (or thread) provides
    any input (that is, transmits something) to our kernel (netlink) module or driver,
    the callback function is invoked. It''s important to understand that it runs in
    the process context and not any kind of interrupt context; we use our `convenient.h:PRINT_CTX()`
    macro to verify this (we will cover this in [Chapter 4](cfd1ca5d-cd0b-451d-8a35-31e65a09d2e4.xhtml),
    *Handling Hardware Interrupts*, in the *Fully figuring out the context* section).
    Here, we simply display the received message and then reply by sending a sample
    message to our user space peer process. The data payload that''s transmitted from
    our user space peer process can be retrieved from the socket buffer structure
    that is passed along to our callback function as a parameter, from a netlink header
    structure within it. You can see how the data and sender PID are retrieved here:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The *socket buffer* data structure – `struct sk_buff` – is considered the critical
    data structure within the Linux kernel's network protocol stack. It holds all
    metadata concerning the network packet, including dynamic pointers to it. It has
    to be quickly allocated and freed (especially when network code runs in interrupt
    contexts); this is indeed possible because it's on the kernel's slab (SLUB) cache
    (see details on the kernel slab allocator in the companion guide *Linux Kernel
    Programming,* *Chapters 7*, *Memory Management Internals - Essentials*, *Chapter
    8*, *Kernel Memory Allocation for Module Authors – Part 1*, and *Chapter 9*, *Kernel
    Memory Allocation for Module Authors – Part 2*).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to understand that we can retrieve the payload from the network
    packet by first dereferencing the `data` member of the socket buffer (`skb`) structure
    that's passed to our callback routine! Next, this `data` member is actually the
    pointer to the netlink message header structure that's set up by our user space
    peer. We then dereference it to get the actual payload.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'We would now like to "reply" to our user space peer process; doing so involves
    performing a few actions. First, we must allocate a new netlink message with the
    `nlmsg_new()` API, which is really a thin wrapper over `alloc_skb()`, add a netlink
    message to the just allocated socket buffer via the `nlmsg_put()` API, and then
    copy in the data (the payload) into the netlink header using an appropriate macro
    (`nlmsg_data()`):'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We send the reply to our user space peer process via the `nlmsg_unicast()`
    API (even multicasting netlink messages are possible):'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'That only leaves the cleanup (which is invoked when the kernel module is removed);
    the `netlink_kernel_release()` API is effectively the inverse of `netlink_kernel_create()` as
    it cleans up the netlink socket, shutting it down:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now that we have written both the user space app and the kernel module to interface
    via a netlink socket, let's actually try it out!
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Trying out our netlink interfacing project
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to verify it all works as advertised. Let''s get started:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'First, build and insert the kernel module into kernel memory:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `lkm` convenience script makes short work of this; this session was carried
    out on our familiar x86_64 guest VM running Ubuntu 18.04 LTS and a custom 5.4.0
    Linux kernel.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'With that, it''s loaded up and ready. Next, we will build and try out our user
    space application:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This results in the following output:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce358d89-c70a-4d5b-8804-df86245ce2b1.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Screenshot showing user<->kernel communication via our sample netlink
    socket code
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: It works; the kernel netlink module receives and displays the message that was
    sent to it from the user space process (`PID 7813`). The kernel module then replies
    with its own message to its user space peer, which successfully receives and displays
    it (via a `printf()`). Give it a try yourself. When you're done, don't forget
    to remove the kernel module with `sudo rmmod netlink_simple_intf`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'An aside: a connector driver exists within the kernel. Its purpose is to ease
    the development of netlink-based communication, making it simpler for both kernel
    and user space developers set up and use a netlink-based communication interface.
    We will not delve into this here; please refer to the documentation within the
    kernel ([https://elixir.bootlin.com/linux/v5.4/source/Documentation/driver-api/connector.rst](https://elixir.bootlin.com/linux/v5.4/source/Documentation/driver-api/connector.rst)).
    Some sample code is also provided within the kernel source tree (at `samples/connector`).'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have learned how to interface between a user mode app and a kernel
    component via the powerful netlink socket mechanism. As we mentioned earlier,
    it has several actual use cases within the kernel tree. Now, let's move on and
    cover one more user-kernel interfacing method, via the popular `ioctl(2)` system
    call.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing via the ioctl system call
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ioctl **is a system call; why the funny name *ioctl*? It''s an abbreviation
    for **input-output control**. While the read and write system calls (among others)
    are used to effectively transfer *data* from and to a device (or file; remember
    the UNIX paradigm *if it''s not a process, it''s a file!*), the *ioctl* system
    call is used to *issue* *commands* to the device (via its driver). For example,
    changing a console device''s terminal characteristics, writing a track to a disk
    when formatting it, sending a control command to a stepper motor, controlling
    a camera or audio device, and so on, are all instances of commands being sent
    to a device.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a fictitious example. We have a device and are developing a (character)
    device driver for it. The device has various *registers*, small – typically 8-,
    16-, or 32-bit pieces of hardware memory on the device – some of which are control
    registers. By appropriately performing I/O (reads and writes) on them, we control
    the device (well, that's really the whole point, isn't it; the actual subject
    matter regarding the details of working with hardware memory including device
    registers will be covered in the next chapter). So, how will you, the driver author,
    communicate or interface with a user space program that wants to perform various
    control operations on this device? We often architect the user space C (or C++)
    program to open the device typically by performing an `open(2)` on its device
    file, and subsequently issue the read and write system calls.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'But, as we just mentioned, the `read(2)` and `write(2)` system call APIs are
    appropriate when *transferring* *data* while here, instead, we intend to perform
    **control operations**. So, we need another system call to do so... Do we then
    need to create and encode a new system call (or calls)? No, it''s much simpler
    than that: we *multiplex via the* *ioctl system call,* leveraging it to perform
    any required control operations upon our device! How? Ah, recall from the previous
    chapter the all-important `file_operations` (fops) data structure; we will now
    initialize another member, the `.ioctl` one, to our ioctl method function, thus
    allowing our device driver to hook into this system call:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Realistically, we shall have to figure out whether we should use `ioctl` or
    the `unlocked_ioctl` member of the `file_operations` structure, depending on whether
    the module is running on Linux kernel version 2.6.36 or later; more on this follows.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, adding new system calls to the kernel is not something you should
    do lightly! The kernel chaps are *not *open to arbitrarily adding syscalls – it''s
    a security-sensitive interface, after all. More on this is documented here: [https://www.kernel.org/doc/html/latest/kernel-hacking/hacking.html#ioctls-not-writing-a-new-system-call](https://www.kernel.org/doc/html/latest/kernel-hacking/hacking.html#ioctls-not-writing-a-new-system-call).'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: More on using ioctl for interfacing follows.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Using ioctl in the user and kernel space
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ioctl(2)` system call''s signature is as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The parameter list is a *varargs – variable arguments –* one. Realistically
    and typically, we pass either two or three parameters:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is obvious – the file descriptor of the (in our case) device
    file that was opened.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second parameter, called `request`, is the interesting one: it''s the command
    to be passed to the driver. In reality, it''s an *encoding*, encapsulating a so-called
    ioctl magic number: a number and a type (read/write).'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The (optional) third parameter, often called `arg`, is also an `unsigned long`
    quantity; we use it to either pass some data in the usual fashion to the underlying
    driver or, often, to return data to the user space by passing its (virtual) address
    and having the kernel write into it, utilizing C's so-called **value-result**
    or **in-out** parameter style.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, using ioctl correctly is not as trivial as it is with many other APIs.
    Think about this for a moment: you can easily have a scenario where several user
    space apps are issuing `ioctl(2)` system calls (with various commands being issued)
    to their underlying device drivers. A problem becomes apparent: how will the kernel
    VFS layer direct the ioctl request to the correct driver? ioctl is typically performed
    on a char device file that has a unique *(major, minor)* number; hence, how can
    another driver receive your ioctl command (unless you intentionally, perhaps maliciously,
    set up the device file(s) in such a manner)?'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, a protocol exists to achieve safe and correct usage of ioctl; every
    application and driver defines a magic number that will be encoded into all its
    ioctl requests. First, the driver will verify that every ioctl request it receives
    contains *its* magic number; only then will it proceed to process it; otherwise,
    it will simply drop it. This, of course, brings up the need for an *ABI* – we
    need to allocate unique magic numbers (it could be a range) to each "registered"
    driver. Since this creates an ABI, the kernel document will be the same; you can
    find details on who is using which magic number (or code) here: [https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt](https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, an ioctl request to the underlying driver can be one of essentially four
    things: a command to "write" to the device, a command to "read" from (or query)
    the device, a command to do both read/write transfers, or neither. This information
    is (again) *encoded* into a request by defining certain bits to convey the meaning:
    to make this job easier, we have four helper macros that allows us to construct
    ioctl commands:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '`_IO(type,nr)`: Encodes an ioctl command with no argument'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_IO**R**(type,nr,datatype)`: Encodes an ioctl command for reading data from
    the kernel/driver'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_IO**W**(type,nr,datatype)`: Encodes an ioctl command for writing data to
    the kernel/driver'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_IO**WR**(type,nr,datatype)`: Encodes an ioctl command for read/write transfers'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These macros are defined within the user space `<sys/ioctl.h>` header and in
    the kernel at `include/uapi/asm-generic/ioctl.h`. The typical (and quite obvious)
    best practice is to create a *common header* file that defines the ioctl commands
    for an app/driver and includes that file in both the user mode app, as well as
    the device driver.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, as a demonstration, we shall design and implement a user space app and
    a kernel space device driver to drive a fictional device that communicates via
    the `ioctl(2)` system call. Thus, we must define some commands to issue via the
    *ioctl* interface. We will do this in a common header file, as shown here:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We must try and make the names we use in our macros meaningful. Our three commands
    (highlighted in bold) are all prefixed with `IOCTL_LLKD_`, indicating that they
    are all ioctl commands for our fictitious `LLKD` project; next, they are suffixed
    with `IOC{Q|S}`, with `IOC` implying that it's an ioctl command, `Q` implying
    it's a query operation, and `S` implying it's a set operation.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how we set things up at the code level from both the user space
    as well as the kernel space (driver).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: User space – using the ioctl system call
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *user space* signature of the `ioctl(2)` system call is as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here, we can see that it takes a variable argument list; the arguments to ioctl
    are as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '**First parameter**: The file descriptor of the file or device (as it will
    be in our case) to perform the ioctl operation on (we get `fd` by performing an
    *open* on the device file).'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second parameter**: The request or command being issued to the underlying
    device driver (or filesystem or whatever `fd` represents).'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An optional third (or more) parameter(s)**: Often, the third parameter is
    an integer (or a pointer to an integer or data structure); we use this method
    to either pass some additional information to the driver, when issuing a *set *kind
    of command, or to retrieve some information from the driver via the well-understood
    *pass-by-reference* C paradigm, where we pass the pointer and have the driver
    "poke" it, thus treating the parameter as, in effect, a return value.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In effect, ioctl is often used as a *generic* system call. The use of ioctl
    to perform command operations on both hardware and software is almost embarrassingly
    large! Please refer to the kernel documentation (`Documentation/ioctl/<...>`)
    to see many actual real-world examples. For example, you will find details on
    who is using which magic number (or code) within ioctl here: [https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt](https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt).'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: (Similarly, the `ioctl_list(2)` man page reveals the complete list of ioctl
    calls in the x86 kernel; these documentation files seem to be pretty old, though.
    The docs now seem to be here: [https://github.com/torvalds/linux/tree/master/Documentation/userspace-api/ioctl](https://github.com/torvalds/linux/tree/master/Documentation/userspace-api/ioctl).)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some snippets of the user space C application, particularly
    when it comes to issuing the `ioctl(2)` system calls (for brevity and readability,
    we have left out the error checking code; the full code is available in this book''s
    GitHub repository):'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: How does our driver handle these user space-issued ioctls? Let's find out.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Kernel space – using the ioctl system call
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we saw that the kernel driver will have to initialize
    its `file_operations` structure to include the `ioctl` method. There is more to
    this, though: the Linux kernel keeps evolving; in early kernel versions, the developers
    used a very coarse granularity lock that, though it worked, quite severely hurt
    its performance (we will discuss locking in detail in [Chapter 6](f456f2ea-ca5f-4d0f-b9c0-55b9ae92f659.xhtml),
    *Kernel Synchronization - Part 1*, and [Chapter 7](14cf1232-dfd5-428a-9c0b-30bcd84651b9.xhtml),
    *Kernel Synchronization - Part 2*). It was so bad that it was nicknamed the **Big
    Kernel Lock** (**BKL**)! The good news is that by kernel release 2.6.36, the developers
    got rid of this infamous lock. Doing so had some side effects, though: one of
    them was that the number of parameters that get sent to the ioctl method within
    the kernel and thus within our `file_operations` data structure changed from four
    to three with the newer method – christened `unlocked_ioctl`. Thus, for our demo
    driver, we will initialize the *ioctl* method with the following when initializing
    our driver''s `file_operations` structure:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Clearly, as it''s defined within the fops driver, ioctl is considered a private
    driver interface (`driver-private`). Also, this same fact regarding the newer
    "unlocked" version has to be taken into account in the function definition within
    the driver code; our driver does so:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The key code here is the driver''s ioctl method. Think about it: once basic
    validity checks have been done, all the driver really does is perform a *switch-case *on
    all possible valid ioctl commands issued by the user space app. Let''s take a
    look at the following code (for readability, we will skip the `#if LINUX_VERSION_CODE
    >= ...` macro directive and just show the modern ioctl function signature, as
    well as some validity checks; you can view the full code in this book''s GitHub
    repository):'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `_IOC_NR` macro is used to extract the command number from the `cmd` parameter.
    Here, we can see that the driver "reacts" to three valid cases of the `ioctl` issued
    via the user space process:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: On receiving the `IOCTL_LLKD_IOC**RESET**` command, it performs a device reset.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On receiving the `IOCTL_LLKD_IOC**Q**POWER` command, it queries (`Q` for query)
    and returns the current power status (by poking its value into the third parameter, `arg`,
    using the *value-result* C programming approach).
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On receiving the `IOCTL_LLKD_IOC**S**POWER` command, it sets (`S` for set) the
    power status (to the value passed in the third parameter, `arg`).
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, since we're working with a purely fictional device, our driver does
    not actually perform any register (or other hardware) work. This driver is simply
    a template that you can make use of.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: What if a hacker attempts to issue a command unknown to our driver in a (rather
    clumsy) hack? Well, the initial validity checks will catch it; even if they don't,
    we shall hit the `default` case in our *ioctl* method, resulting in the driver
    returning `-ENOTTY` to the user space. This will, via glibc "glue" code, set the
    user space process (or thread's) `errno` value to `ENOTTY`, informing it that
    the ioctl method cannot be serviced. Our user space `perror(3)` API will display
    the `Inappropriate ioctl for device` error message. In fact, this is precisely
    what occurs if a driver has *no* ioctl method (that is, if the ioctl member within
    the `file_operations` structure is set to `NULL`) and a user space app issues
    an `ioctl` method against it.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: I leave it to you to try out this user space/driver project example; for convenience,
    once the driver has been loaded (via insmod), you can use the `ch2/userspace_ioctl/cr8devnode.sh`
    convenience script to generate the device file. Once it's set up, run the user
    space app; you will find that running it in succession has the "power state" of
    our fictional device get repeatedly toggled.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: ioctl as a debug interface
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this chapter, what about using the *ioctl*
    interface for debug purposes? It can be used for this purpose. You can always
    insert a "debug" command into the *switch-case* block; it can be used to provide
    useful information to the user space application on the driver status, the values
    of key variables (health monitoring too), and more.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only that, but unless it''s explicitly documented to the end user or customer,
    the precise commands that are used via the ioctl interface are unknown; thus,
    you are expected to document the interface while providing sufficient detail for
    other teams or the customer to make good use of them. This leads to an interesting
    point: you might choose to deliberately leave a certain ioctl command undocumented;
    it''s now a "hidden" command that can be used by, say, field engineers to examine
    the device. (I leave doing this as an assignment to you.)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel documentation on ioctl includes this file: [https://www.kernel.org/doc/Documentation/ioctl/botching-up-ioctls.txt](https://www.kernel.org/doc/Documentation/ioctl/botching-up-ioctls.txt).
    Though biased toward kernel graphics stack devs, it describes typical design mistakes,
    trade-offs, and more.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Fantastic – you're almost done! You have learned how to interface a kernel module
    or driver with a user mode process or thread (within a user space application)
    via various technologies. We began with procfs, then moved on to using sysfs and
    debugfs. The netlink socket and the ioctl system call completed our look at these
    interfacing methods.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: But with all this choice, which one should you actually use on a project? The
    next section will help you make this decision by providing a quick comparison
    between these various interfacing methods.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the interfacing methods – a table
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we have created a quick comparison table of the various user-kernel
    interfacing methods that were described in this chapter, based on a few parameters:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter /Interfacing method** | **procfs** | **sysfs** | **        debugfs**
    | **netlink socket** | **ioctl** |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
- en: '| **Ease of development** | Easy to learn and use. | (Relatively) easy to learn
    and use. | (Very) easy to learn and use. | Harder; have to write user space C
    + driver code + understand socket APIs. | Fair/harder; have to write user space
    C + driver code. |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
- en: '| **Appropriate for what use** | Core kernel *only* (a few older drivers may
    still use it); best avoided by drivers. | Device driver interfacing. | Driver
    (and other) interfacing for production and debug purposes. | Various interfacing:
    users include device drivers, core networking code, the udev system, and more.
    | Device driver interfacing mostly (includes many). |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
- en: '| **Interface visibility** | Visible to all; use permissions to control access.
    | Visible to all; use permissions to control access. | Visible to all; use permissions
    to control access. | Hidden from the filesystem; doesn''t pollute the kernel namespace.
    | Hidden from the filesystem; doesn''t pollute the kernel namespace. |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
- en: '| **Upstream kernel ABI for driver/module authors*** | Usage in drivers is
    deprecated for mainline. | The "right way"; the formally accepted approach to
    interface drivers with user space. | Well supported and heavily used in mainline
    by drivers and other products. | Well supported (since 2.2). | Well supported.
    |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
- en: '| **Useful for (driver) debugging purposes**  | Yes (although not supposed
    to in mainline). | No/not ideal. | Yes, very useful! "No rules" by design. | No/not
    ideal. | Yes; (even) via hidden commands. |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
- en: '* As we mentioned earlier, the kernel community documents that procfs, sysfs,
    and debugfs are all *ABIs; *their stability and lifespan isn''t guaranteed. While
    that is the formal stance adopted by the community, the reality is that plenty
    of actual interfaces that use these filesystems have become de facto ones used
    by products in the real world. Nevertheless, we should follow the kernel community''s
    "rules" and guidelines regarding their usage.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered an important aspect of device driver authors – how
    exactly you can *interface between user and kernel  (driver) space*. We walked
    you through several interfacing methods; we began with an older one, which is
    interfacing via the venerable proc filesystem (and then mentioned why it's not
    the preferred method for driver authors). We then moved on to interfacing via
    the newer 2.6-based *sysfs.* This turns out to be *the* preferred interface for
    the user space, at least for a device driver. Sysfs has limitations, though (recall
    the one-value-per-sysfs-file rule). Thus, using the completely free-format *debugfs*
    interfacing technique makes writing debug (and other) interfaces very simple and
    powerful indeed. The netlink socket is a powerful interfacing technology and is
    used by the network subsystem, udev, and a few drivers; it does require some knowledge
    on socket programming and the kernel socket buffer, though. To perform generic
    command operations on device drivers, the ioctl system call turns out to be a
    tremendous multiplexer and is often used by device driver authors (and other components)
    to interface with the user space.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this knowledge, you are now in a position to practically integrate
    your driver-level code with user space applications (or scripts); often, a user
    mode **graphical user interface** (**GUI**) will want to display some values that
    have been received from the kernel or device driver. You now know how to pass
    these values from the kernel space device driver!
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you will learn about a typical task driver authors must
    perform: working with hardware chip memory! Do ensure you''re clear on this chapter''s
    material, work on the exercises provided, review the *Further reading* resources,
    and then dive into the next chapter. See you there!'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`sysfs_on_misc`: *sysfs assignment #1*: Extend one of the `misc` device drivers
    we wrote in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml), *Writing
    a Simple misc Character Device Driver*; set up two sysfs files and their read/write
    callbacks; test them from user space.'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sysfs_addrxlate`: *sysfs assignment #2 (a bit more advanced)*: *Address translation:*
    Exploiting the knowledge gained from this chapter and from the *Linux Kernel Programming* book, *Chapter
    7, Memory Management Internals - Essentials,* the *Direct-mapped RAM and address
    translation* section, write a simple platform driver that provides two sysfs interface
    files called `addrxlate_kva2pa` and `addrxlate_pa2kva`. Writing a kva into the
    sysfs file, `addrxlate_kva2pa`, should have the driver read and translate the
    *kva* into its corresponding **physical address** (**pa**); then, reading from
    the same file should cause the *pa* to be displayed. Do the same with the `addrxlate_pa2kva`
    sysfs file.'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dbgfs_disp_pgoff`: *debugfs assignment #1*: Write a kernel module that sets
    up a debugfs file here: `<debugfs_mount_point>/dbgfs_disp_pgoff`. When read, it
    should display (to user space) the current value of the `PAGE_OFFSET` kernel macro.'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dbgfs_showall_threads`: *debugfs assignment #2* : Write a kernel module that
    sets up a debugfs file here: `<debugfs_mount_point>/dbgfs_showall_threads/dbgfs_showall_threads`.
    When read, it should display some attributes of every thread that''s alive. (This
    is similar to our code from the *Linux Kernel Programming* book here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/ch6/foreach/thrd_showall](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/ch6/foreach/thrd_showall).
    Note that the threads are displayed *only* at insmod time; with a debugfs file,
    you can display information on all the threads at any time you choose to)!'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Suggested output is CSV format: *`TGID,PID,current,stack-start,name,#threads`. The
    `[name]` field in square brackets => kernel thread*;'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '* `#threads` field should only display a positive integer*;* no output here
    implies a single-threaded process; for example: `130,130,0xffff9f8b3cd38000,0xffffc13280420000,[watchdogd]`)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '*ioctl assignment #1*: Using the provided `ch2/ioctl_intf/` code as a template,
    write a user space C application and a kernel space (char) device driver implementing
    the `ioctl` method. Add an ioctl command called `IOCTL_LLKD_IOCQPGOFF` to return
    the value of `PAGE_OFFSET` (within the kernel) to the user space.'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ioctl_undoc`: *ioctl assignment #2*: Using the provided `ch2/ioctl_intf/`
    code as a template, write a user space C application and a kernel space (char)
    device driver implementing the `ioctl` method. Add a driver context data structure
    (we used these in several examples), and then allocate and initialize it. Now,
    in addition to the three previous ioctl commands we used, set up a fourth undocumented
    command (you can call it `IOCTL_LLKD_IOCQDRVSTAT`). When queried from the user
    space via `ioctl(2)`, it must return the contents of the driver context data structure
    to the user space; the user space C app must print out the current content of
    every member of that structure.'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will find some of the questions answered in the book's GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter. Some more information on using the very common I2C protocol within
    a Linux device driver can be found here:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: An article on the I2C protocol basics: *How to use I2C in STM32F103C8T6? STM32
    I2C Tutorial*, March 2020: [https://www.electronicshub.org/how-to-use-i2c-in-stm32f103c8t6/](https://www.electronicshub.org/how-to-use-i2c-in-stm32f103c8t6/)
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kernel documentation: Implementing I2C device drivers: [https://www.kernel.org/doc/html/latest/i2c/writing-clients.html](https://www.kernel.org/doc/html/latest/i2c/writing-clients.html)'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
