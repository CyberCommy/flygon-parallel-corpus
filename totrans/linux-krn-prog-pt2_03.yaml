- en: User-Kernel Communication Pathways
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this scenario: you''ve successfully developed a device driver for,
    say, a pressure sensor device (perhaps by using the kernel''s I2C APIs to fetch
    the pressure from the chip via the I2C protocol). So, you have the current pressure
    value in a variable within the driver, which of course implies that it''s within
    kernel memory space. The issue at hand is, how exactly do you now have a *user
    space application retrieve this value?* Well, as we learned in the previous chapter,
    you can always include a `.read` method in the driver''s *fops *structure. When
    the user space app issues a `read(2)` system call, control will be diverted (via
    the **virtual file system** (**VFS**)) to your driver''s *read method.* In there,
    you perform `copy_to_user()` (or equivalent), resulting in the user mode app receiving
    the value. However, but there are other, sometimes superior, ways to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll understand the various communication interfaces or
    pathways that are available – as a means to communicate or interface between user
    and kernel address spaces. This is an important aspect of writing driver code,
    for without this knowledge, how will you be able to achieve a key thing – efficiently
    transfer information between a kernel-space component (often, this is a device
    driver, but it could be anything, really) and a user space process or thread?
    Not only that, some of the techniques that we shall learn about are often used
    for debugging (and/or diagnostics) purposesas well. In this chapter, we will cover
    several techniques to effect communication between the kernel and user (virtual)
    address spaces: communication via the traditional proc filesystem, *procfs*, the
    better way for drivers via the sys filesystem, *sysfs*, via a debug filesystem,
    *debugfs*, via *netlink sockets*, and via the `ioctl(2)` system call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Approaches to communicating/interfacing a kernel driver with a user space C
    app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing via the proc filesystem (procfs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing via the sys filesystem (sysfs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing via the debug filesystem (debugfs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing via netlink sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing via the ioctl system call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing the interfacing methods – a table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I assume you have gone through the *Preface*, the relevant section being *To
    get the most out of this book,* and have appropriately prepared a guest **virtual
    machine** (**VM**) running Ubuntu 18.04 LTS (or a later stable release) and installed
    all the required packages. If not, I recommend you do this first.
  prefs: []
  type: TYPE_NORMAL
- en: To get the maximum out of this book, I strongly recommend you first set up the
    workspace environment, including cloning this book's GitHub repository ([https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/ch2))
    for the relevant code, and work on it in a hands-on fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Approaches to communicating/interfacing a kernel driver with a user space C
    app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the introduction, in this chapter, we wish to learn how to
    efficiently transfer information between a kernel-space component (often, this
    is a device driver, but it could be anything, really), and a user space process
    or thread. To begin, let's simply enumerate various techniques available to the
    kernel or driver author to communicate or interface with a user space C application.
    Well, the user space component could be a C app, a shell script (both of which
    we typically show in this book), or even other apps such as C++/Java apps, Python/Perl
    scripts, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in the companion guide, *Linux Kernel Programming*, in *Chapter 4, Writing
    Your First Kernel Module – LKMs Part 1,* in the *Library and System Call APIs* subsection,
    the essential interface between user space applications and the kernel that includes
    the device drivers are the system call APIs*.* Now, in the previous chapter, you
    learned the basics of writing a character device driver for Linux. Within that,
    you also learned how to transfer data between user and kernel address spaces by
    having a user mode application open the device file and issue `read(2)` and `write(2)`
    system calls. This resulted in the driver''s read/write method being invoked by
    the VFS and your driver performing the data transfer via the `copy_{from|to}_user()`
    APIs. So, the question here is: if we have already covered that, then what else
    is there to learn about in this regard?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ah, quite a bit! The reality is that there are several other techniques of
    interfacing between a user mode app and the kernel. Certainly, they all very much
    depend upon using system calls; after all, there is no other (synchronous, programmatic)
    way to enter the kernel from the user space! Nevertheless, the techniques differ.
    The aim of this chapter is to show you various communication interfaces that are
    available, as of course, depending on the project, one might be more suitable
    than others to use. Let''s look at the various techniques that will be used in
    this chapter to interface between the user and kernel address spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: Via the traditional procfs interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via sysfs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via debugfs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via netlink sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via the `ioctl(2)` system call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, we will discuss these interfacing techniques in detail
    by providing driver code examples. In addition, we will also briefly explore how
    conducive they are to the purpose of *debugging.* So, let's begin with using the
    procfs interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing via the proc filesystem (procfs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we shall cover what the proc filesystem is and how you can
    leverage it as an interface between user and kernel address spaces. The proc filesystem
    is a powerful and easy-to-program interface, often used for status reporting and
    debugging core kernel systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note that from version 2.6 Linux onward and for upstream contribution, this
    interface is *not* to be used by driver authors (it's strictly meant for kernel-internal
    usage only). Nevertheless, for completeness, we will cover it here.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the proc filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux has a virtual filesystem named *proc*; the default mount point for it
    is `/proc`. The first thing to realize regarding the proc filesystem is that its
    content is *not* on a non-volatile disk. Its content is in RAM, and is thus volatile.
    The files and directories you can see under `/proc` are pseudo files that have
    been set up by the kernel code for proc; the kernel hints at this fact by (almost)
    always showing the file''s *size* as zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's summarize a few critical points regarding Linux's powerful proc filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The objects under `/proc` (files, directories, soft links, and so on) are all
    pseudo objects; they live in RAM!
  prefs: []
  type: TYPE_NORMAL
- en: Directories under /proc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The directories under `/proc` whose names are integer values represent processes
    currently alive on the system. The name of the directory is the PID of the process
    (technically, it's the TGID of the process. We covered TGID/PID in the companion
    guide *Linux Kernel Programming *in* Chapter 6*, *Kernel and Memory Management
    Internals Essentials*).
  prefs: []
  type: TYPE_NORMAL
- en: This folder – `/proc/PID/` – contains information regarding this process. So,
    for example, for the *init* or *systemd *process (always PID `1`), you can examine
    detailed information about this process (its attributes, open files, memory layout,
    children, and so on) under the `/proc/1/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, here, we will gain a root shell and do `ls /proc/1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b602d4a8-8d7b-4aca-ad53-c4f04ef4240d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Screenshot of performing ls /proc/1 on an x86_64 guest system
  prefs: []
  type: TYPE_NORMAL
- en: The complete details regarding the pseudo files and folders under `/proc/<PID>/...`
    can be found on the man page of `proc(5)` (by doing `man 5 proc`); do try it out
    and refer to it!
  prefs: []
  type: TYPE_NORMAL
- en: Note that the precise content under `/proc` varies from both the kernel version
    and the (CPU) architecture; x86_64 tends to have the richest content.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose behind the proc filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *purpose* behind the proc filesystem is two-fold:'
  prefs: []
  type: TYPE_NORMAL
- en: One, it is a simple interface for developers, system administrators, and anyone
    really to look deep inside the kernel so that they can gain information regarding
    the internals of processes, the kernel, and even hardware. Using this interface
    only requires you to know basic shell commands such as `cd`, `cat`, `echo`, `ls`*,*
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two, as the *root* user and, at times, the owner, you can write into certain
    pseudo files under `/proc/sys`, thus tuning various kernel parameters. This feature
    is called **sysctl***.* As an example, you can tune various IPv4 networking parameters
    in `/proc/sys/net/ipv4/`. They are all documented here: [https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt](https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changing the value of a proc-based tunable is easy; for example, let''s change
    the maximum number of threads allowed at any given point in time on the box. Run
    the following commands as *root*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we''re done. However, it should be clear that the preceding operation
    is *volatile* – the change only applies to this session; a power cycle or reboot
    will result in it reverting back to the default value of course. How, then, do
    we make the change permanent*?* The short answer: use the `sysctl(8)` utility;
    refer to its man page for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: Are you ready to write some procfs-interfacing code now? Not so fast – the next
    section informs you as to why this may *not* be a great idea after all.
  prefs: []
  type: TYPE_NORMAL
- en: procfs is off-bounds to driver authors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though we could use the proc filesystem to interface with a user mode app,
    there is an important point to note here! You must realize that procfs is, like
    many similar facilities within the kernel, an **Application Binary Interface**
    (**ABI**). The kernel community makes no promises that it remains stable and exactly
    the way it is today, just as is the case with the kernel *APIs* and their internal
    data structures as well. In fact, ever since the 2.6 kernel, the kernel folks
    have made this very clear – *device driver authors (and the like) are not supposed
    to use procfs* for their own purposes or their interfaces, debug or otherwise.
    Earlier, with 2.6 Linux, it was quite common to use proc for said purposes (abused,
    as per the kernel community, as proc is meant for kernel internal use only!).
  prefs: []
  type: TYPE_NORMAL
- en: So, if procfs is considered off-bounds, or deprecated, to us as driver authors,
    then what facility do we use to communicate with user space processes? Driver
    authors are to use the sysfs facility to *export* their interfaces. In reality,
    it's not just sysfs; there are several choices available to you such as sysfs,
    debugfs, netlink sockets, and the ioctl system call. We will cover these in detail
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Hang on, though; again, the reality is that this "rule" regarding the non-usage
    of procfs for driver authors are for the community. What this means is that if
    you intend to *upstream* your driver or kernel module to the mainline kernel,
    thus contributing your code under the GPLv2 license, *then* all the community
    rules definitely apply. If not, it's really up to you to decide. Of course, following
    the kernel community's guidelines and rules can only be a good thing; we definitely
    recommend that you do so. In terms of discouraging the use of proc by non-core
    stuff such as drivers, unfortunately, there is no recent kernel documentation
    available for the proc API/ABI.
  prefs: []
  type: TYPE_NORMAL
- en: On the 5.4.0 kernel, there are around 70-odd callers of the `proc_create()`
    kernel API, several of which being (typically older) drivers and filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless (you have been warned!), let's learn how to interact a user space
    process with kernel code via procfs.
  prefs: []
  type: TYPE_NORMAL
- en: Using procfs to interface with the user space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a kernel module or device driver developer, we can actually create our own
    entries under `/proc`, leveraging this as a simple interface to the user space.
    How can we do this? The kernel provides APIs that create directories and files
    under procfs. We will learn how to use them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Basic procfs APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we do not intend to delve into the gory details of the procfs API set;
    rather, we shall cover just enough to have you be able to understand and use them.
    For deeper detail, do refer to the ultimate resource: the kernel code base. The
    routines we will cover here have been exported, thus making them available to
    driver authors like you. Also, as we mentioned earlier, all the procfs file objects
    are really pseudo objects, in the sense that they exist only in RAM.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are assuming you understand how to design and implement a simple LKM;
    you'll find more details in the companion guide to this book, *Linux Kernel Programming*,
    in the fourth and fifth chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by exploring a few simple procfs APIs that allow you to perform
    a few key tasks – creating a directory under the proc filesystem, creating (pseudo)
    files under there, and deleting them, respectively. For all of these tasks, ensure
    you include the relevant header file; that is, `#include <linux/proc_fs.h>`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory named `name` under `/proc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the name of the directory, while the second parameter
    is the pointer to the parent directory to create it under. Passing `NULL` here
    creates the directory under the root; that is, under `/proc`*.* Save the return
    value, as you will typically use it as a parameter in subsequent APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The `proc_mkdir_data()` routine allows you to pass along a data item (a `void
    *`) as well; note that it's exported via `EXPORT_SYMBOL_GPL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a procfs (pseudo) file called `/proc/parent/name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The key parameter here is `struct file_operations`, which we introduced in
    the previous chapter. You are expected to populate it with the "methods" to be
    implemented (more on this follows). Think about it: this is really powerful stuff;
    using the `fops`structure, you can set up "callback" functions within your driver
    (or kernel module) that the kernel''s proc filesystem layer will honor: when a
    user space process reads from your proc file, it (the VFS) will invoke the driver''s `.read`
    method or callback function. If a user space app writes, it will invoke the driver''s `.write`
    callback!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove a procfs entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This API removes the specified `/proc/name` entry and frees it (if not in use);
    similarly (and often much more convenient), use the `remove_proc_subtree()` API
    to remove an entire sub-tree within `/proc` (typically on cleanup or if an error
    occurs).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics, the empirical approach demands that we put these
    APIs to practice! To do so, let's figure out what directories/files to create
    under `/proc`.
  prefs: []
  type: TYPE_NORMAL
- en: The four procfs files we will create
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To help clearly illustrate the usage of procfs as an interfacing technology,
    we will have our kernel module create a directory under `/proc`. Within that directory,
    it will create four procfs (pseudo) files. Note that, by default, all procfs files
    have their *owner:group* attributes as *root:root*. Now, create a directory called `/proc/proc_simple_intf`
    and, under it, create four (pseudo) files. The names and attributes of the four
    procfs (pseudo) files under the `/proc/proc_simple_intf` directory, are shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name of procfs ''file''** | **R: action on read callback, invoked via user
    space read** | **W: action on write callback, invoked via user space write** |
    **Procfs ''file'' permissions** |'
  prefs: []
  type: TYPE_TB
- en: '| `llkdproc_dbg_level` | Retrieves (to the user space) the current value of
    the global variable; that is, `debug_level` | Updates the `debug_level` global
    variable to the value written by the user space | `0644` |'
  prefs: []
  type: TYPE_TB
- en: '| `llkdproc_show_pgoff` | Retrieves (to the user space) the kernel''s `PAGE_OFFSET`
    value | – no write callback – | `0444` |'
  prefs: []
  type: TYPE_TB
- en: '| `llkdproc_show_drvctx` | Retrieves (to the user space) the current values
    within the driver''s "context" structure; that is, `drv_ctx` | – no write callback
    – | `0440` |'
  prefs: []
  type: TYPE_TB
- en: '| `llkdproc_config1` (also treated as `dbg_level`) | Retrieves (to user space)
    the current value of the context variable; that is,  `drvctx->config1` | Updates
    the driver context member, `drvctx->config1`, to the value written by the user
    space | `0644` |'
  prefs: []
  type: TYPE_TB
- en: We'll look at the APIs and actual code to create the `proc_simple_intf` directory
    under `/proc` and the four files mentioned previously under it shortly. (Due to
    a lack of space, we won't actually show all the code; just the code with respect
    to the "debug level" get-and-set; this is not an issue, the remainder of the code
    is conceptually very similar).
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the dynamic debug_level procfs control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s check out the "driver context" data structure that we shall use
    throughout this chapter (in fact, we first used it in the previous chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can also see that we have a global integer named `debug_level`; this
    will provide dynamic control over the debug verbosity of the "project". The debug
    level is assigned a range of `[0-2]`, where we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` implies *no debug messages* (the default).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` is *medium debug* verbosity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` implies *high debug* verbosity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The beauty of the whole schema – and indeed the whole point here – is that we
    shall be able to query and set this `debug_level` variable from the user space
    via a procfs interface that we've created! This will allow the end user (who,
    for security reasons, requires *root* access) to dynamically vary the debug level
    at runtime (a fairly common feature found in many products).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into the code-level details, let''s try it out so that we know
    what to expect:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, using our `lkm` convenience wrapper script, we must build and `insmod(8)`
    the kernel module (`ch2/proc_simple_intf` in this book''s source tree):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we built and inserted the kernel module; `dmesg(1)` displays the kernel
    *printks* showing that one of the procfs files we created is the one pertaining
    to the dynamic debug facility (highlighted in bold here; since these are pseudo
    files, the file size will appear as `0` bytes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test it by querying the current value of `debug_level`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, it''s zero – the default – as expected. Now, let''s change the debug
    level to `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we had to issue `echo` as *root*. As we can see, the debug level
    has indeed changed (to a value of `2`)! Attempting to set the value out of range
    is caught as well (and the `debug_level` variable''s value is reset to its last
    valid value), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Right; it worked as expected. However, the question is, how did all this work
    at the code level? Read on to find out!
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically controlling debug_level via procfs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s answer the aforementioned question – *how is it done in code?* It''s
    quite straightforward, really:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, within the `init` code of the kernel module, we must create our
    procfs directory, naming it after the name of our kernel module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, within the `init` code of the kernel module, we must create the `procfs`
    file that controls the project''s "debug level":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the `proc_create()` API to create the *procfs* file and "linked"
    it to the supplied `file_operations` structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fops structure (technically, `struct file_operations`) is the key data
    structure here. As we learned in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml),
    *Writing a Simple misc Character Device Driver*, it''s where we assign *functionality*
    to the various file operations on the device, or, as in this case, the procfs
    file. Here''s the code initializing our fops:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `open` method of fops points to a function we must define:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using the kernel's `single_open()` API, we register the fact that, whenever
    this file is read –  which is ultimately done via the `read(2)` system call from
    the user space – the proc filesystem will "call back" our `proc_show_debug_level()` routine
    (the second parameter to `single_open()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t bother with the internal implementation of the `single_open()` API
    here; if you''re curious, you can always look it up here: `fs/seq_file.c:single_open()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to summarize, to register a "read" method with procfs, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the `fops.open` pointer to a `foo()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `foo()` function, call `single_open()`, providing the read callback function
    as the second parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's some history here; without getting too deep into it, suffice it to say
    that the older working of procfs had issues. Notably, you couldn't transfer more
    than a single page of data (with read or write) without manually iterating over
    the content. The *sequence iterator* functionality that was introduced with 2.6.12
    fixed these issues. Nowadays, using `single_open()` and its ilk (the `seq_read`,
    `seq_lseek`, and `seq_release` built-in kernel functions) is the simpler and correct
    approach to using procfs.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what about when user space *writes* (via the `write(2)` system call) into
    a proc file? Simple: in the preceding code, you can see that we have registered
    the `fops_rdwr_dbg_level.write` method as the `myproc_write_debug_level()` function,
    implying that this function will be *called back* whenever this (pseudo) file
    is written to (it''s explained in *Step 6*, following the *read* callback).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code of the *read* callback function that we registered via `single_open` is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`seq_printf()` is conceptually similar to the familiar `sprintf()` API. It
    correctly prints – to the `seq_file` object – the data supplied to it. When we
    say "prints" here, what we really mean is that it effectively passes the data
    buffer to the user space process or thread that issued the read system call that
    got us here in the first place, in effect *transferring the data to the user space.*'
  prefs: []
  type: TYPE_NORMAL
- en: Oh yes, what's with the `mutex_{un}lock*()` APIs? They are for something critical –
    *locking.* We will provide a detailed discussion on locking in [Chapter 6](f456f2ea-ca5f-4d0f-b9c0-55b9ae92f659.xhtml),
    *Kernel Synchronization – Part 1*, and [Chapter 7](14cf1232-dfd5-428a-9c0b-30bcd84651b9.xhtml),
    *Kernel Synchronization – Part 2*; for now, just understand that these are required
    synchronization primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `write` callback function we registered via `fops_rdwr_dbg_level.write` is
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In our write method's implementation (notice how similar it is in structure
    to a character device driver's write method), we performed some validity checking
    and then copied in the data the user space process wrote to us (recall how we
    used the `echo` command to write to the procfs file) via the usual `copy_from_user()`
    function. We then used the kernel's built-in `kstrtoint()` API (there are several
    in a similar vein) to convert the string buffer into an integer, storing the result
    in our global variable; that is, `debug_level`! Again, we validate it, and if
    all's well, we also set (just as an example) our driver context's `config1` member
    to the same value and then return a success message.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the kernel module's code is very similar – we set up the functionality
    for the remaining three procfs files. I leave it to you to browse through the
    code in detail and try it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One more quick demo: let''s set `debug_level` to `1` and then dump the driver
    context structure (via the third procfs file we created):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, the `debug_level` variable will now have a value of `1`; now, let''s
    dump the driver context structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We need *root* access to do this. Once done, we can clearly see all the members
    of our `drv_ctx` data structure. Not only that, but we verified that the `config1` member,
    highlighted in bold, now has a value of `1`, thus reflecting the "debug level"
    as designed.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice how the output is deliberately generated to the user space in a
    highly parseable format, almost JSON-like. Of course, as a small exercise, you
    could arrange to do precisely that!
  prefs: []
  type: TYPE_NORMAL
- en: A large number of recent **Internet of Things** (**IoT**) products use RESTful
    APIs to communicate; the format that's parsed is typically JSON. Getting in the
    habit of designing and implementing your kernel-to-user (and vice versa) communication
    in easily parsable formats (such as JSON) is only going to help.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have learned how exactly to create a procfs directory, a file
    within it, and, most importantly, how to create and use the read and write callback
    functions so that when a user mode process reads or writes your proc file, you
    can respond appropriately from deep within the kernel. As we mentioned earlier,
    due to a lack of space, we will not describe the code driving the remaining three
    procfs files we have created and used. This is very similar conceptually to what
    we have just covered. We expect you to read through and try it out!
  prefs: []
  type: TYPE_NORMAL
- en: A few misc procfs APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's conclude this section by looking at a few remaining miscellaneous procfs
    APIs. You can create a symbolic or soft link within `/proc` by using the `proc_symlink()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `proc_create_single_data()` API can be very useful; it''s used as
    a "shortcut", where you require just a "read" method to be attached to a procfs
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this API thus eliminates the need for a separate fops data structure.
    We can use this function to create and work with our second procfs file – the
    `llkdproc_show_pgoff` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When read from the user space, the kernel''s VFS and proc layer code paths
    will invoke the registered method – the `proc_show_pgoff()` function of our module
    – within which we trivially invoke `seq_printf()` to send the value of `PAGE_OFFSET`
    to the user space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, note the following regarding the `proc_create_single_data` API:'
  prefs: []
  type: TYPE_NORMAL
- en: You can make use of the fifth parameter to `proc_create_single_data()` to pass
    any data item to the read callback (retrieved there as a `seq_file` member called
    `private`, very similar to how we used `filp->private_data` in the previous chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several typically older drivers within the kernel mainline do make use of this
    function to create their procfs interfaces. Among them is the RTC driver (which
    sets up an entry at `/proc/driver/rtc`). The SCSI `megaraid` driver (`drivers/scsi/megaraid`) uses
    this routine no fewer than 10 times to set up its proc interfaces (when a config
    option is enabled; it is by default).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful! I find that on an Ubuntu 18.04 LTS system running the distro (default)
    kernel, this API – `proc_create_single_data()` – isn't even available, so the
    build fails. On our custom "vanilla" 5.4 LTS kernel, it works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, there is some documentation on the procfs API we''ve set here,
    though this tends to be for internal usage and not for modules: [https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-proc-filesystem](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-proc-filesystem).'
  prefs: []
  type: TYPE_NORMAL
- en: So, as we mentioned previously, with the procfs APIs it's a case of **Your Mileage
    May Vary** (**YMMV**)! Carefully test your code before release. It's probably
    best to follow the kernel community guidelines and simply say **No** to procfs
    as a driver interfacing technique. Worry not – we'll look at better ones throughout
    this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: This completes our coverage on using procfs as a useful communication interface.
    Now, let's learn how to use a more appropriate one for drivers – the sysfs interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing via the sys filesystem (sysfs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A critical feature of the 2.6 Linux kernel release was the advent of what is
    called the modern *device model*. Essentially, a series of complex tree-like hierarchical
    data structures model all devices present on the system. Actually, it goes well
    beyond this; the **sysfs** tree encompasses the following (among other things):'
  prefs: []
  type: TYPE_NORMAL
- en: Every bus present on the system (it can be a virtual or pseudo bus as well)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every device present on every bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every device driver bound to a device on a bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, it's not just peripheral devices but also the underlying system buses,
    the devices on each bus and the device driver bound or that will bind to a device,
    that are created at runtime and maintained by the device model. The inner workings
    of this model are invisible to you, as a typical driver author; you don't really
    have to worry about it. On system boot, and whenever a new device becomes visible,
    the *driver core* (part of the built-in kernel machinery) generates the required
    virtual files under the sysfs tree. (Conversely, when a device is removed or detached,
    its entry disappears from the tree.)
  prefs: []
  type: TYPE_NORMAL
- en: Recall, though, from the *Interfacing with the proc filesystem* section, that
    using procfs for a device driver's interfacing purposes is not really the right
    approach, at least for code that wants to move upstream. So, what *is* the right
    approach? Ah, *creating sysfs (pseudo) files is considered the "correct way" for
    device drivers to interface with the user space.*
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we see it! sysfs is a virtual filesystem typically mounted on the `/sys` directory.
    In effect, sysfs, very similarly to procfs, is a kernel-exported tree of information
    (device and other) that''s sent to the user space. You can think of sysfs as having
    different *viewports* into the modern device model. Via sysfs, you can view the
    system in several different ways or via different "viewports"; for example, you
    can view the system via the various buses it supports (the *bus* view – PCI, USB,
    platform, I2C, SPI, among several others), via various "classes" of devices (the
    *class* view), via the *devices* themselves, via the *block* devices viewport,
    and so on. The following screenshot showing the content of `/sys` on my Ubuntu
    18.04 LTS VM shows this to be the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf6846b2-8f7a-47e3-98a2-be5528a87f22.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Screenshot showing the content of sysfs (/sys) on an x86_64 Ubuntu
    VM
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, with sysfs, there are several other viewports via that you can
    use to look into the system as well. Of course, in this section, we wish to understand
    how to interface a device driver to the user space via sysfs, how to write the
    code to create our driver (pseudo) files under sysfs, and how to register the
    read/write callbacks from them. Let's begin by looking at the basic sysfs APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sysfs (pseudo) file in code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way to create a pseudo (or virtual) file under sysfs is via the `device_create_file()`
    API. Its signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's consider its two parameters one by one; first, there is a pointer to `struct
    device`. The second parameter is a pointer to a device attribute structure; we
    shall explain and work on it a bit later (in the *Setting up the device attributes
    and creating the sysfs file* section). For now, let's focus on the first parameter
    only – the device structure. It seems quite intuitive – a device is represented
    by a metadata structure called `device` (it is part of the driver core; you can
    look up its full definition in the `include/linux/device.h` header).
  prefs: []
  type: TYPE_NORMAL
- en: Note that when you write (or work on) a "real" device driver, chances are high
    that a generic *device structure* will exist or come into being. This often happens
    upon *registering* the device; an underlying device structure is usually made
    available as a member of a specialized structure for that device. For example,
    all structures, such as `platform_device`, `pci_device`, `net_device`, `usb_device`, 
    `i2c_client`, `serial_port` and so on, have a `struct device` member embedded
    within them. Thus, you can use that device structure pointer as a parameter to
    the API for the purpose of creating files under sysfs. Rest assured, you shall
    soon see this being done in code! So, let's get going by getting ourselves a device
    structure by creating a simple "platform device". You'll learn how to do this
    in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple platform device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clearly, in order to create a (pseudo) file under sysfs, we somehow require,
    as the first parameter to `device_create_file()`, a pointer to a `struct device`.
    However, for our demo sysfs driver here and now, we don't actually have any real
    device, and therefore no `struct device`, to work on!
  prefs: []
  type: TYPE_NORMAL
- en: So, can't we create an *artificial* or *pseudo device* and simply use it? Yes,
    but how, and more crucially, why exactly should we have to do this? It's critical
    to understand that the modern **Linux Device Model** (**LDM**) is built on three
    key components:** an underlying bus must exist that devices live on, and devices
    are "bound to" and driven by device drivers**. (We already mentioned this in [Chapter
    1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml), *Writing a Simple misc Character
    Device Driver*, in the *A quick note on the Linux Device Model *section).
  prefs: []
  type: TYPE_NORMAL
- en: All of these must be registered to the driver core. Now, don't worry about the
    buses and the bus drivers that drive them; they will be registered and handled
    internally by the kernel's driver core subsystem. When there is no real *device*,
    however, we will have to create a pseudo one in order to work with the model.
    Again, there are several ways to do such things, but we shall create **a** ***platform
    device**.* This device will "live" on a pseudo bus (that is, it exists only in
    software) known as the ***platform bus**.*
  prefs: []
  type: TYPE_NORMAL
- en: Platform devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A quick but important aside: *platform devices* are often used to represent
    the variety of devices on a **System on Chip** (**SoC**) within an embedded board.
    The SoC is typically a very sophisticated chip that integrates various components
    into its silicon. Besides processing units (CPUs/GPUs), it might house several
    peripherals too, including Ethernet MAC, USB, multimedia, serial UART, clock,
    I2C, SPI, flash chip controllers, and so on. A reason we need these components
    to be enumerated as a platform device is that there is no physical bus within
    the SoC; thus, the platform bus is used.'
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, the code that was used to instantiate these SoC platform devices
    was kept in a "board" file (or files) within the kernel source (`arch/<arch>/...`).
    Due to it becoming overloaded, it's been moved outside the pure kernel source
    into a useful hardware description format called the **Device Tree** (within **Device
    Tree Source** (**DTS**) files that are themselves with the kernel source tree).
  prefs: []
  type: TYPE_NORMAL
- en: 'On our Ubuntu 18.04 LTS guest VM, let''s look at the platform devices under
    sysfs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The *Bootlin* website (previously called *Free Electrons*) offers superb materials
    on embedded Linux, drivers, and so on. This link on their site leads to excellent
    material on the LDM: [https://bootlin.com/pub/conferences/2019/elce/opdenacker-kernel-programming-device-model/](https://bootlin.com/pub/conferences/2019/elce/opdenacker-kernel-programming-device-model/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the driver: we bring our (artificial) platform device into existence
    by registering it to the (already existing) platform bus driver via the `platform_device_register_simple()`
    API. The moment we do so, the driver core will *generate* the required sysfs directories
    and a few boilerplate sysfs entries (or files). Here, in the init code of our
    sysfs demo driver, we will set up a (simplest possible) *platform device* by registering
    it to the driver core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `platform_device_register_simple()` API returns a pointer to `struct platform_device`.
    One of this structure''s members is `struct device dev`. We now have what we''ve
    been after: a *device* *structure*. Also, it''s key to note that when this registration
    API runs, the effect is visible within sysfs*.* You can easily see the new platform
    device, plus a few boilerplate sysfs objects, being created by the driver core
    here (made visible to us via sysfs); let''s build and *insmod* our kernel module
    to see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can create a `struct device` in different ways; the generic way is to set
    up and issue the `device_create()` API. An alternate means to creating a sysfs
    file, while bypassing the need for a device structure, is to create a "object"
    and invoke the `sysfs_create_file()` API. (Links to tutorials that use both these
    approaches can be found in the *Further reading* section). Here, we prefer to
    use a "platform device" as it's the closer approach to writing a (platform) driver.
  prefs: []
  type: TYPE_NORMAL
- en: There's yet another valid approach. As we saw in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml),
    *Writing a simple misc Character Device Driver*, we built a simple character driver
    conforming to the kernel's `misc` framework. There, we instantiated a `struct
    miscdevice`; once registered (via the `misc_register()` API), this structure will
    contain a member called `struct device *this_device;`, thus allowing us to use
    it as a valid device pointer! Thus, we could have simply extended our earlier
    `misc` device driver and used it here. However, in order to learn a bit about
    platform drivers, we've chosen that approach. (We leave the approach of extending
    our earlier `misc` device driver so that it can use sysfs APIs and create/use
    sysfs files as an exercise to you).
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our driver, compared to the init code, in the *cleanup* code, we must
    un-register our platform device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's tie all this knowledge together and actually see the code that generates
    the sysfs files, along with their read and write callback functions!
  prefs: []
  type: TYPE_NORMAL
- en: Tying it all together – setting up the device attributes and creating the sysfs
    file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned at the beginning of this section, the `device_create_file()`
    API is the one we''ll use to create our sysfs file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous section, you learned how we obtain a device structure (the
    first parameter for our API). Now, let''s figure out how to initialize and use
    the second parameter; that is, the `device_attribute` structure. The structure
    itself is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first member, `attr`, essentially consists of the *name* of the sysfs file
    and its *mode* (permission bitmask). The other two members are function pointers
    ("virtual functions", analogous to those in the **file operations** or **fops**
    structure):'
  prefs: []
  type: TYPE_NORMAL
- en: '`show`: Represents the *read callback* function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`store`: Represents the *write callback* function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our job is to initialize this `device_attribute` structure, thus setting up
    the sysfs file. While you can always manually initialize it, there''s an easier
    approach: the kernel provides (several) macros for initializing `struct device_attribute`;
    among them is the `DEVICE_ATTR()` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the "stringification" that''s performed by `dev_attr_##_name`, ensuring
    that the structure''s name is suffixed with the name that''s passed as the first
    parameter to `DEVICE_ATTR`. Furthermore, the actual "worker" macro, named `__ATTR()`,
    actually instantiates a `device_attribute` structure in code at preprocessing
    time, with (via stringification) the name of the structure becoming `dev_attr_<name>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, the kernel defines additional simple wrapper macros over these
    macros in order to specify the *mode* (permissions for the sysfs file), thus making
    it even simpler for you, the driver author. Among them is `DEVICE_ATTR_RW(_name)`,
    `DEVICE_ATTR_RO(_name)`, and `DEVICE_ATTR_WO(_name)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we can create a **read-write** (**RW**), **read-only** (**RO**),
    or **write-only** (**WO**) sysfs file. Now, we wish to set up a sysfs file that
    can be read and written to. Internally, this is a "hook" or callback for us to
    query or set a `debug_level` global variable just as we did in the sample kernel
    module on procfs earlier!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have sufficient background, let's delve into the code!
  prefs: []
  type: TYPE_NORMAL
- en: The code for implementing our sysfs file and its callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at the relevant parts of the code for our simple *sysfs interfacing
    driver* and try things out, step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the device attribute structure (via the `DEVICE_ATTR_RW` macro; see
    the preceding section for more information) and create our first sysfs (pseudo)
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: From the definition of the macros shown here, we can infer that `static DEVICE_ATTR_RW(SYSFS_FILE1);` instantiates
    an initialized `device_attribute` structure with the name `llkdsysfs_debug_level`
    (as that's what the `SYSFS_FILE1` macro evaluates to) and a mode of `0644`; the
    read callback name will be `llkdsysfs_debug_level_show()` and the write callback
    name will be `llkdsysfs_debug_level_store()`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the relevant code for the read and write callbacks (again, we won''t
    show the entire code here). First, let''s look at the read callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How does this work? On reading our sysfs file, the preceding callback function
    is invoked. Within it, simply writing into the user-supplied buffer pointer, `buf`
    (its third parameter; we used the kernel `snprintf()` API to do so), has the effect
    of transferring the value provided *(*here, `debug_level`) to the user space!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build and `insmod(8)` the kernel module (for convenience, we will use
    our `lkm` wrapper script to do so):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s list and read the sysfs file pertaining to the debug-level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This reflects the fact that debug-level is currently `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s peek at the code of our *write callback* for the debug-level sysfs
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Again, it should be clear that the `kstrtoint()` kernel API is used to convert
    the user space `buf` string into an integer value, which we then validate. Also,
    the third parameter to `kstrtoint` is the integer to write to, thus updating it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try updating the value of `debug_level` from its sysfs file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Voila – it works!
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did when we interfaced with procfs, we have provided more code in the
    sysfs code example. Here, we have another (read-only) sysfs interface to display
    the value of `PAGE_OFFSET`, plus a new one. Imagine that this driver''s job is
    to retrieve a "pressure" value (perhaps via an I2C-driven pressure sensor chip).
    Let''s imagine we have done so, and stored this pressure value in an integer global
    variable named `gpressure`. To "show" the user space the current pressure value,
    we must use a sysfs file. Here it is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Internally, for the purpose of this demo, we have randomly set the `gpressure` global
    variable to a value of `25`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Look carefully at the output; why does the prompt appear immediately after `25`?
    Because we just printed the value as-is – no newline, nothing; that''s what is
    expected. The code that displays the "pressure" value is simple indeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With that, you've learned how to interface with the user space via sysfs! As
    usual, I urge you to actually write the code and try out these skills yourself;
    take a look at the *Questions* section at the end of this chapter and try out
    the (relevant) assignments yourself. Now, let's continue with sysfs, understanding
    an important *rule* regarding its ABI.
  prefs: []
  type: TYPE_NORMAL
- en: The "one value per sysfs file" rule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have understood how to create and make use of sysfs for user space
    kernel interfacing purposes, but there is a key point that we have been ignoring.
    There is a "rule" regarding using sysfs files, which states that you must only
    read or write exactly one value! Think of this as the *one-value-per-file* rule.
  prefs: []
  type: TYPE_NORMAL
- en: So, as in the example where we used the "pressure" value, we merely return the
    current value of the pressure, nothing more. Thus, sysfs, unlike the other interfacing
    technologies, is not quite suited to those cases where you might want to return
    arbitrary long-winded information packets (say, the contents of the driver context
    structure) to the user space; in other words, it's not suited to pure "debugging"
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel documents and "rules" regarding the usage of sysfs can be found
    here: [https://www.kernel.org/doc/html/latest/admin-guide/sysfs-rules.html#rules-on-how-to-access-information-in-sysfs](https://www.kernel.org/doc/html/latest/admin-guide/sysfs-rules.html#rules-on-how-to-access-information-in-sysfs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, there is documentation on the sysfs API here: [https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-filesystem-for-exporting-kernel-objects](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-filesystem-for-exporting-kernel-objects).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel typically provides several different means of creating sysfs objects;
    for example, with the `sysfs_create_files()` API, you can create multiple sysfs
    files in one go: `int __must_check sysfs_create_files(struct kobject *kobj, const
    struct attribute * const *attr);`. Here, you are expected to supply a pointer
    to a `kobject` and a pointer to a list of attribute structures.'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of sysfs as an interfacing technology; in summary,
    sysfs is indeed considered the *right way* for driver authors to display and/or
    set a particular driver value to and from the user space. Due to the "one value
    per sysfs file" convention, sysfs is really not ideally suited to debugging information
    dispensation. This neatly brings us to our next topic – debugfs!
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing via the debug filesystem (debugfs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine for a moment, the quandary faced by you, a driver developer, on Linux:
    you want to implement an easy yet elegant way to provide debug "hooks" from your
    driver to the user space. For example, the user simply performing a `cat(1)` on
    a (pseudo) file should result in your driver''s "debug callback" function being
    invoked. It will then proceed to dump some status information (perhaps a "driver
    context" structure) to the user mode process, which will faithfully dump it to
    stdout.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, no problem: in the days before the 2.6 release, we could (as you learned
    in the *Interfacing via the proc filesystem (procfs)* section) happily use the
    procfs layer to interface our driver with the user space. Then, from 2.6 Linux
    onward, the kernel community vetoed this approach. We were told to strictly stop
    using procfs and instead use the sysfs layer as the means to interface our drivers
    with the user space. However, as we saw in the *Interfacing* *via the sys filesystem
    (sysfs)* section, it has a strict *one-value-per-file* rule. This is actually
    great for reporting or sending single values from and to the driver (typically,
    environment sensor values and similar), but quickly rules out all but the most
    trivial debug interfaces to the user space. We could use the ioctl approach (as
    we shall see) to set up a debug interface but it''s quite a bit harder to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what can you do? Luckily, there is an elegant solution in place from around
    2.6.12 Linux onward called debugfs. The "debug filesystem" is very easy to use
    and quite explicit in communicating the fact that driver authors (anyone, in fact)
    can use it for whatever purpose they choose! There is no one-value-per-file rule –
    forget that, there are no rules.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, just as with the other filesystem-based approaches we have dealt
    with – procfs, sysfs, and now debugfs – the kernel community clearly claims that
    all these interfaces are an ABI, and thus, that their stability and lifespan is
    something that is *not *guaranteed. While that is the formal stance that's adopted,
    the reality is that these interfaces have become de facto ones in the real world;
    stripping them out without preamble one fine day wouldn't really serve anybody.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the content of debugfs on our x86-64 Ubuntu
    18.04.3 LTS guest (running the "custom" 5.4.0 kernel we built back in our companion
    book *Linux Kernel Programmin*g, *Chapter 3*, *Building the 5.0 Linux kernel from
    Source, Part 2*!):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d01e778c-ea1a-4934-8283-30d35557238d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Screenshot revealing the content of the debugfs filesystem on an
    x86_64 Linux VM
  prefs: []
  type: TYPE_NORMAL
- en: As with procfs and sysfs, due to debugfs being a kernel feature (it's a virtual
    filesystem, after all!), the precise content within it is highly dependent on
    the kernel version and CPU architecture. As we mentioned previously, by looking
    at this screenshot, it should now be obvious that there are plenty of real-world
    "users" of debugfs.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for the presence of debugfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First off, in order to make use of the powerful *debugfs* interface, it must
    be enabled within the kernel config. The relevant Kconfig macro is `CONFIG_DEBUG_FS`.
    Let''s check whether it''s enabled on our 5.4 custom kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are assuming you have the `CONFIG_IKCONFIG` and `CONFIG_IKCONFIG_PROC`
    options set to `y`, thus allowing us to use the `/proc/config.gz` pseudo file
    to access the current kernel's configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Indeed it is; it's typically enabled by default in distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the default mount point of debugfs is `/sys/kernel/debug`. Thus, we can
    see that it is internally dependent on the sysfs kernel feature being present
    and mounted, which it is by default. Let''s check where debugfs is mounted on
    our Ubuntu 18.04 x86_64 VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It is available and mounted at the expected location; that is, `/sys/kernel/debug`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, it''s always a best practice to never assume that this will always
    be the location where it''s mounted; in your script or user mode C program, take
    the trouble to check and verify it. In fact, allow me to rephrase this: *it''s
    always a good practice to never assume anything; making assumptions is a really
    good source of bugs*.'
  prefs: []
  type: TYPE_NORMAL
- en: By the way, an interesting Linux feature is that filesystems can be mounted
    in different, even multiple, locations; also, some folks prefer to create a symbolic
    link to `/sys/kernel/debug` as `/debug`; it's up to you, really.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, our intention here is to create our (pseudo) files under the debugfs
    umbrella, and then register and make use of the read/write callbacks from them,
    for the purpose of interfacing our driver with the user space. To do so, we need
    to understand the basic usage of the debugfs API. We will point you to the documentation
    for this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Looking up the debugfs API documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The kernel supplies succinct and superb documentation on using the debugfs
    API (courtesy of Jonathan Corbet, LWN) here: [https://www.kernel.org/doc/Documentation/filesystems/debugfs.txt](https://www.kernel.org/doc/Documentation/filesystems/debugfs.txt)
    (of course, you can also look it up directly within the kernel codebase).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I urge you to refer to this document to learn how to use the debugfs APIs,
    since it''s easy to read and understand; this way, you can avoid unnecessarily
    repeating the same information here. In addition to the aforementioned document,
    the modern kernel documentation system (the "Sphinx"-based one) also provides
    quite detailed debugfs API pages: [https://www.kernel.org/doc/html/latest/filesystems/api-summary.html?highlight=debugfs#the-debugfs-filesystem](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html?highlight=debugfs#the-debugfs-filesystem).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that all debugfs APIs are exported as GPL-only to kernel modules (thus
    necessitating the module being released under the "GPL" license (this can be dual
    licensed, but one must be "GPL")).
  prefs: []
  type: TYPE_NORMAL
- en: An interfacing example with debugfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugfs, being deliberately designed with a "no particular rules" mindset, makes
    it the ideal interface to use *for debug purposes*. Why? It allows you to construct
    any arbitrary byte stream and send it off to the user space, including a binary
    "blob" with the `debugfs_create_blob()` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our previous example kernel modules with procfs and sysfs constructed and used
    three to four (pseudo) files. For a quick demo with debugfs, we shall just stick
    to two "files":'
  prefs: []
  type: TYPE_NORMAL
- en: '`llkd_dbgfs_show_drvctx`: As you''ll have no doubt guessed, when read, it will
    cause the current content of our (by now familiar) "driver context" data structure
    to be dumped to the console; we shall ensure the pseudo file''s mode is read-only
    (by root).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`llkd_dbgfs_debug_level`: This file''s mode shall be read-write (by root only);
    when read, it will display the current value of `debug_level`; when an integer
    is written to it, we shall update the value of `debug_level` within the kernel
    module to the value passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, in the init code of our kernel module, we will first create a directory
    under `debugfs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a starting point – a directory – let's move on and create the
    debugfs (pseudo) files under it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using the first debugfs file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For readability and to save space, we won't show the error handling code sections
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in the example with procfs, we must allocate and initialize an instance
    of our "driver context" data structure (we haven't shown the code here as it's
    repetitive, so please refer to the GitHub source).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, via the generic `debugfs_create_file()` API, we must create a `debugfs` file,
    associating it with a `file_operations` structure. This, in effects, gets just
    a read callback registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: From 5.8 Linux onward (recall that we're working with the 5.4 LTS kernel), the
    return value of several of the debugfs creation APIs have been removed (they will
    return `void`); Greg Kroah-Hartman's patch mentions that this was done as no one
    was using them. This is quite typical of Linux – unneeded features are stripped
    off, and kernel evolution continues...
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, the "read" callback is our `dbgfs_show_drvctx()` function. As a reminder,
    this function gets auto-invoked by the debugfs layer whenever the `debugfs` file
    (`llkd_dbgfs_show_drvctx`) is read; here''s the code for our debugfs read callback
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we retrieve the "data" pointer (our driver context structure) by
    dereferencing the debugfs files' inode member, which is called `i_private`.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml),
    *Writing a Simple misc Character Device Driver*, using the `data` pointer to dereference
    the driver context structure from the file's inode is one of a number of similar,
    common techniques employed by driver authors to avoid the use of globals. Here,
    `gdrvctx` *is* a global, so it's a moot point; we are simply using it to demonstrate
    the typical use case.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `snprintf()` API, we can populate a local buffer with the current
    content of our driver's "context" structure, and then, via the `simple_read_from_buffer()`
    API, pass it up to the user space app that issued the read, which typically causes
    it to be displayed on the Terminal/console window. This `simple_read_from_buffer()`
    API is a wrapper over `copy_to_user()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give it a spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the two debugfs files are created as expected; let''s verify
    this (be careful here; you can only look into debugfs as *root*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The pseudo files have been created and have the correct permissions. Now, let''s
    read (as root user) from the `llkd_dbgfs_show_drvctx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'It works; performing the read again a few seconds later. Notice how the value
    of `config3` has changed. Why? Recall that we set it to the `jiffies` value –
    the number of timer "ticks"/interrupts – that have occurred since system boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Having created and used our first debugfs file, let's understand the second
    debugfs file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using the second debugfs file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s move on to the second debugfs file. We will create it using an interesting
    shortcut helper debugfs API named `debugfs_create_u32()`. This API *automatically*
    sets up internal callbacks, allowing you to read/write upon the specified unsigned
    32-bit global variable within the driver. The main advantage of this "helper"
    routine is that you don''t need to explicitly provide a `file_operations` structure
    or even any callback routines. The debugfs layer "understands" and internally
    sets things up so that reading or writing the numeric (global) variable will always
    just work! Take a look at the following code in the *init* codepath, which creates
    and sets up our second debugfs file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s as simple as that! Now, reading this file will produce the current value
    of `debug_level`; writing to it will set it to the value written. Let''s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, but there is a downside to this "shortcut" approach: since this
    is all done internally, there is no way for us to *validate* the value being written.
    Thus, here, we wrote the value `5` to `debug_level`; it worked, but it''s an invalid
    value (at least let''s assume that''s the case)! So, how can this be corrected?
    Simple: do not use this helper method; instead, do it the "usual" way via the
    generic `debugfs_create_file()` API (as we did for the first debugfs file). The
    advantage here is that as we set up explicit callback routines for read and write,
    by specifying them within a fops structure, we have control over the value being
    written (I leave doing this to you, as an exercise). Like life, it''s a trade-off;
    you win some, you lose some.'
  prefs: []
  type: TYPE_NORMAL
- en: Helper debugfs APIs for working on numeric globals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have just learned how to use the `debugfs_create_u32()` helper API to set
    up a debugfs file to read/write an unsigned 32-bit integer global. The fact is,
    the debugfs layer provides a bunch of similar "helper" APIs to implicitly read/write
    on numeric (integer) global variables within your module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The helper routines for creating debugfs entries that can read/write different
    bit size unsigned integer (8-, 16-, 32-, and 64-bit) globals follow. The last
    parameter is the key one – the address of the global integer within the kernel/module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding APIs work with decimal base; to make using *hexadecimal base*
    easy, we have the following helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As an aside, the kernel also provides a helper API for those cases where the
    precise *size* of the variable varies; hence, using the `debugfs_create_size_t()`
    helper creates a debugfs file appropriate for a variable of size `size_t`.
  prefs: []
  type: TYPE_NORMAL
- en: For drivers that merely need to peek at a numeric global, or update it without
    any worry about invalid values, these debugfs helper APIs are very useful and
    are indeed commonly used by several drivers in the mainline kernel (we will look
    at an example within the MMC driver shortly). To evade the "validity check" issue,
    often, we can arrange for the *user space* application (or script) to perform
    validity checking; in fact, this is typically the "right way" to do things.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UNIX paradigm has a saying: *provide mechanism, not policy.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with globals that are of the *boolean* type, debugfs provides
    the following helper API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Reading from the "file" will result in only `Y` or `N` (suffixed with a newline)
    being returned; obviously, `Y` if the current value of the fourth `value` parameter
    is non-zero, and `N` otherwise. When writing, you can write `Y` or `N` or `1`
    or `0`; other values will not be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about it: you can control your "robot" device via your robot device driver
    by writing `1` to a boolean variable called, say, `power` to turn it on, and use `0`
    to turn it off! The possibilities are endless.'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel documentation on debugfs provides a few more miscellaneous APIs;
    I leave it to you to have a look. Now that we've covered how to create and use
    our demo debugfs pseudo files, let's learn how to remove them.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the debugfs pseudo file(s)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a module is removed (via, say, `rmmod(8)`), we must delete our debugfs
    files. The older way to do this was via the `debugfs_remove()` API, where each
    debugfs file had to be individually removed with it (painful, to say the least).
    The modern approach makes this really simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Pass the pointer to the overall "parent" directory (the one we created first),
    and the entire branch is recursively removed; perfect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not deleting your debugfs files at this point, thus leaving them there on the
    filesystem in an orphaned state, is asking for trouble! Just think about this:
    what will happen when someone (attempts to) reads or writes to any of them later?
    **A kernel bug, or an *Oops***, that''s what.'
  prefs: []
  type: TYPE_NORMAL
- en: Seeing a kernel bug – an Oops!
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's make it happen – a kernel bug! Exciting, yes!?
  prefs: []
  type: TYPE_NORMAL
- en: Okay, to create a kernel bug, we must ensure that when we remove (unload) the
    kernel module, the API that cleans up (deletes) all the debugfs files, `debugfs_remove_recursive()`,
    is *not *invoked. Thus, after each module is removed, our debugfs directory and
    files seem to be present! However, if you try and operate on – read/write – any
    of them, they'll be in an *orphaned state* and, hence, upon trying to dereference
    its metadata, the internal debugfs code paths will perform an invalid memory reference,
    resulting in a (kernel-level) bug.
  prefs: []
  type: TYPE_NORMAL
- en: In the kernel space, a bug is a very serious thing indeed; in theory, it should
    never, ever happen! This is called an *Oops;* as part of handling this, an internal
    kernel function is called, which dumps useful diagnostic information via `printk` to
    the in-memory kernel log buffer, as well as to the console device (on production
    systems, it might also be directed elsewhere so that it can be retrieved and investigated
    at a later date; for example, via the kernel's *kdump* mechanism).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce a module parameter that controls whether we (quite deliberately)
    cause an *Oops* to occur or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the cleanup code path of our driver, we check if the `cause_an_oops` variable
    is non-zero and deliberately do *not* (recursively) delete our debugfs file(s),
    hence setting up the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When we "normally" use `insmod(8)`, the scary `cause_an_oops` module parameter
    is `0` by default, thus ensuring that everything works well. But let''s get adventurous!
    We are building the kernel module and when we insert it, we must pass the parameter
    while setting it to `1` (notice that here, we''re running as *root* on our x86_64
    Ubuntu 18.04 LTS guest system on our custom `5.4.0-llkd01` kernel):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s remove the kernel module – internally, the code that''s used to
    clean up (recursively delete) our debugfs file would not have run. Here, we are
    actually triggering the kernel bug, the *Oops,* by attempting to read one of our
    debugfs files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Killed` message on the console is ominous! This is a clue that something
    has gone (dramatically) wrong. Viewing the kernel log confirms that we indeed
    got an *Oops!* The following (partially cropped) screenshot shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b9849ec-98d3-4fa8-a772-87b4d6fa656b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – A partial screenshot of a kernel Oops, a kernel-level bug
  prefs: []
  type: TYPE_NORMAL
- en: 'Since provided kernel debugging details is beyond the scope of this book, we
    will not delve into the details here. Nevertheless, figuring out a little bit
    is quite intuitive. Look carefully at the preceding screenshot: in the `BUG:`
    statement, you can see the **kernel virtual address** (**kva**) whose lookup caused
    the bug, known as the Oops (we covered the kva space in the companion guide, *Linux
    Kernel Programming – Chapter 7, Memory Management Internals Essentials*; this
    is really key information for driver authors):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the CPU (`1`) that the process context (`cat`) was running on, the
    tainted flags, and the kernel version. One of the really key pieces of output
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This tells you that the CPU instruction pointer (the register named RIP on the
    x86_64) was in the `debugfs_u32_get()` function at an offset of `0x5` bytes from
    the start of the machine code of the function (furthermore, the kernel figures
    out that the length of the function is `0x20` bytes)!
  prefs: []
  type: TYPE_NORMAL
- en: Combining this information with powerful tools such as `objdump(1)` and `addr2line(1)`
    can help to literally pinpoint the location of the bug in code!
  prefs: []
  type: TYPE_NORMAL
- en: 'The CPU registers are dumped; even better, the *call trace *or the *call stack*
    – the *content of the kernel mode stack* of the process context (please refer
    to *Linux Kernel Programming*, in *Chapter 6*, *Kernel Internals Essentials, Processes
    and Threads,* for details on the kernel stack) – shows you the code that led up
    to this point; that is, the crash (read the stack trace bottom-up). Another quick
    tip: if a kernel function in the call trace''s output is preceded by a `?` symbol,
    just ignore it (it''s perhaps a previous "blip" that was left behind).'
  prefs: []
  type: TYPE_NORMAL
- en: Realistically, a kernel bug on a production system *must* cause the entire system
    to panic (halt). On non-production systems (like what we're running on), a kernel
    panic may or may not occur; here, it doesn't. Nevertheless, a kernel bug must
    be treated with the highest level of severity, it's indeed a show-stopper and
    must be fixed. The procfs file, `/proc/sys/kernel/panic_on_oops`, is set to `0`
    by most distros, but on production systems, it will typically be set to the value `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The moral here is clear: there is no auto cleanup being performed by debugfs;
    we have to do it. Right, let''s wrap up this discussion on debugfs by looking
    up some actual real-world usage within the kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugfs – actual users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned previously, there are several "real-world" users of the debugfs
    API; can we spot some of them? Well, here''s one way: simply search under the
    kernel source tree''s `drivers/` directory for files named `*debugfs*.c`; you
    might be surprised (I found 114 such files in the 5.4.0 kernel tree!). Let''s
    take a look at a few:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at (some of) them; their code exposes debugfs interfaces. This
    is not always done for mere debug purposes; many of the debugfs files are for
    actual production usage! As an example, the MMC driver contains the following
    line of code, which makes use of the debugfs "helper" API to get an x32 global:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This creates a debugfs file called `state` that, when read, displays the "state"
    of the card.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, this completes our coverage of how to interface with the user space via
    the powerful debugfs framework. Our demo debugfs driver created a debugfs directory
    and two debugfs pseudo files within it; you then learned how to set up and use
    both read and write callback handlers for them. The "shortcut" APIs (such as `debugfs_create_u32()`
    and friends) are powerful too. Not only that, but we even managed to generate
    a kernel bug – an Oops! Now, let's learn how to communicate over a special type
    of socket, known as a netlink socket.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing via netlink sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, you'll learn to interface kernel and user spaces with a familiar and indeed
    ubiquitous network abstraction – sockets! Programmers familiar with network application
    programming swear by its advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Familiarity with network programming in C/C++ with socket APIs helps here. Do
    see the *Further reading* section for a couple of good tutorials on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages using sockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Among others, socket technology provides us with several advantages (over other
    typical user mode IPC mechanisms such as pipes, SysV IPC/POSIX IPC mechanisms
    (message queues, shared memory, semaphores, and so on)), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional simultaneous data transfer (full duplex).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lossless on the internet, with at least with some transport layer protocols,
    such as TCP, and of course, on the localhost, which is the case here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-speed data transfer, especially on localhost!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow control semantics are always in effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous communication; messages can be queued, so the sender does not have
    to wait for the receiver.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Especially with respect to our topic, in other user<->kernel communication paths
    (such as procfs, sysfs, debugfs, and ioctl), the user space app must initiate
    the transfer to the kernel space; with netlink sockets, *the kernel can initiate
    a transfer.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, with all the other mechanisms we have seen so far (procfs, sysfs, and
    debugfs), the various interface files being strewn all over the filesystem(s)
    can cause kernel namespace pollution; with netlink sockets (and, incidentally,
    with ioctl), this isn't the case as there are no files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These advantages can be helpful, depending on the type of product you're working
    on. Now, let's understand what a netlink socket is.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what a netlink socket is
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what is a netlink socket? We shall keep it simple – a *netlink socket* is
    a "special" socket family that exists only on the Linux OS since version 2.2\.
    Using it, you can set up **Inter-Process Communication** (**IPC**) between a user
    mode process (or thread) and a component within the kernel; in our case, a kernel
    module, which is typically a driver.
  prefs: []
  type: TYPE_NORMAL
- en: It is similar to a UNIX domain datagram socket in many ways; it's meant for
    communication on the *localhost* *only* and not across systems. While UNIX domain
    sockets use a pathname as their namespace (a special "socket" file), netlink sockets
    use a PID. Pedantically, this is a port ID and not a process ID, although realistically,
    process IDs are very often used as the namespace. The modern kernel core (besides
    drivers) uses netlink sockets in many cases – as one example, the iproute2 networking
    utilities use it to configure wireless drivers. As another interesting example,
    the udev feature uses netlink sockets to effect communication between the kernel
    udev implementation and the user space daemon process (udevd or systemd-udevd,
    for things such as device discovery, device node provisioning, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will design and implement a simple user<->kernel messaging demonstration
    using netlink sockets. To do so, we shall have to write two programs (at a minimum)
    – one as the user space application that issues socket-based system calls, and
    another for the kernel-space component (here, a kernel module). We shall have
    the user space process send a "message" to the kernel module; the kernel module
    should receive it and print it (into the kernel log buffer). The kernel module
    will then reply to the user space process, which is blocking on this very event.
  prefs: []
  type: TYPE_NORMAL
- en: So, without further ado, let's dive into writing some code using netlink sockets;
    we shall begin with the user space application. Read on!
  prefs: []
  type: TYPE_NORMAL
- en: Writing the user space netlink socket application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps get the *user space* application running:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we must do is get ourselves a *socket*. Traditionally, a socket
    is defined as an endpoint of communication; thus, a pair of sockets forms a connection.
    We will use the `socket(2)` system call to do this. Its signature is
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int socket(int domain, int type, int protocol);`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without going into too much detail, here''s what we do:'
  prefs: []
  type: TYPE_NORMAL
- en: We specify `domain` as part of the special `PF_NETLINK` family, thus requesting
    a netlink socket.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `type` to `SOCK_RAW` using a raw socket (effectively skipping the transport
    layer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protocol` is the protocol to use. Since we''re using a raw socket, the protocol
    is left to be implemented either by us or by the kernel; having the kernel netlink
    code do this is the right approach. Here, we use an unused protocol number; that
    is, `31`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to bind the socket via the usual `bind(2)` system call semantics.
    First, we must initialize a netlink source `socketaddr` structure for this purpose
    (where we specify the family as a netlink and the PID value as the calling process''
    PID (for unicast only)). The following code is for the first two steps mentioned
    here (for clarity, we won''t be displaying the error checking code here):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must initialize a netlink "destination address" structure. Here, we
    set the PID member to `0`, a special value indicating that the destination is
    the kernel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must allocate and initialize a netlink "header" data structure. Among
    other things, it specifies the source PID and, importantly, the data "payload"
    that we shall deliver to our kernel component. Here, we are making use of helper
    macros such as `NLMSG_DATA()` to specify the correct data location within the
    netlink header structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, an `iovec` structure must be initialized to reference the netlink header,
    and a `msghdr` data structure must be initialized to point to the destination
    address and `iovec`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the message is sent (transmitted) via the `sendmsg(2)` system call
    (which takes the socket descriptor and the aforementioned `msghdr` structure as
    a parameter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel component – a kernel module, which we shall discuss shortly – should
    now receive the message via its netlink socket and display the message''s content;
    we arrange for it to then politely reply. To grab the reply, our user space app
    must now perform a blocking read on the socket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We must employ the `recvmsg(2)` system call to do this. When it gets unblocked,
    it states that the message has been received.
  prefs: []
  type: TYPE_NORMAL
- en: Why so much abstraction and wrapping for data structures? Well, it's how things
    often evolve – the `msghdr` structure was created so that the `sendmsg(2)` API
    can use fewer parameters. But that implies the parameters have to go somewhere;
    they go deep inside `msghdr`, which points to the destination address and `iovec`,
    whose `base` member points to the netlink header structure, which contains the
    payload! Whew.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an experiment, what if we build and run the user mode netlink application
    prematurely – *without* the kernel-side code in place? It will fail, of course...
    But how exactly? Well, use the empirical approach. By trying this out via the
    venerable `strace(1)` utility, we can see that the `socket(2)` system call returns
    a failure, the cause being `Protocol not supported`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This is correct; there is no such `protocol # 31` (`31` = `0x1f`, the protocol
    number we''re using) in place *yet* within the kernel! We''re yet to do this.
    So, that''s the user space side of things. Now, let''s complete the puzzle and
    have it actually work! We''ll do this by seeing how the kernel component (module/driver)
    is written.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the kernel-space netlink socket code as a kernel module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The kernel provides the base infrastructure for netlink, including APIs and
    data structures; all the required ones are exported and thus available to you
    as a module author. We use several of them; the steps to program our kernel netlink
    component – our kernel module – are outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with the user space app, the first thing we must do is get ourselves
    a netlink socket. The kernel API is `netlink_kernel_create()`, and its signature
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is a generic network structure; we pass the kernel''s existing
    and valid `init_net` structure here. The second parameter is the *protocol number
    (unit)* to use; we shall specify the same number (`31`) as we did for the user
    space app. The third parameter is a pointer to an (optional) netlink configuration
    structure; here, we only set the input member to a function of ours nullifying
    the rest. This function is called back when a user space process (or thread) provides
    any input (that is, transmits something) to the kernel netlink component. So,
    within our kernel module''s `init` routine, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned previously, when a user space process (or thread) provides
    any input (that is, transmits something) to our kernel (netlink) module or driver,
    the callback function is invoked. It''s important to understand that it runs in
    the process context and not any kind of interrupt context; we use our `convenient.h:PRINT_CTX()`
    macro to verify this (we will cover this in [Chapter 4](cfd1ca5d-cd0b-451d-8a35-31e65a09d2e4.xhtml),
    *Handling Hardware Interrupts*, in the *Fully figuring out the context* section).
    Here, we simply display the received message and then reply by sending a sample
    message to our user space peer process. The data payload that''s transmitted from
    our user space peer process can be retrieved from the socket buffer structure
    that is passed along to our callback function as a parameter, from a netlink header
    structure within it. You can see how the data and sender PID are retrieved here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The *socket buffer* data structure – `struct sk_buff` – is considered the critical
    data structure within the Linux kernel's network protocol stack. It holds all
    metadata concerning the network packet, including dynamic pointers to it. It has
    to be quickly allocated and freed (especially when network code runs in interrupt
    contexts); this is indeed possible because it's on the kernel's slab (SLUB) cache
    (see details on the kernel slab allocator in the companion guide *Linux Kernel
    Programming,* *Chapters 7*, *Memory Management Internals - Essentials*, *Chapter
    8*, *Kernel Memory Allocation for Module Authors – Part 1*, and *Chapter 9*, *Kernel
    Memory Allocation for Module Authors – Part 2*).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to understand that we can retrieve the payload from the network
    packet by first dereferencing the `data` member of the socket buffer (`skb`) structure
    that's passed to our callback routine! Next, this `data` member is actually the
    pointer to the netlink message header structure that's set up by our user space
    peer. We then dereference it to get the actual payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would now like to "reply" to our user space peer process; doing so involves
    performing a few actions. First, we must allocate a new netlink message with the
    `nlmsg_new()` API, which is really a thin wrapper over `alloc_skb()`, add a netlink
    message to the just allocated socket buffer via the `nlmsg_put()` API, and then
    copy in the data (the payload) into the netlink header using an appropriate macro
    (`nlmsg_data()`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We send the reply to our user space peer process via the `nlmsg_unicast()`
    API (even multicasting netlink messages are possible):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'That only leaves the cleanup (which is invoked when the kernel module is removed);
    the `netlink_kernel_release()` API is effectively the inverse of `netlink_kernel_create()` as
    it cleans up the netlink socket, shutting it down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have written both the user space app and the kernel module to interface
    via a netlink socket, let's actually try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Trying out our netlink interfacing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to verify it all works as advertised. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, build and insert the kernel module into kernel memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `lkm` convenience script makes short work of this; this session was carried
    out on our familiar x86_64 guest VM running Ubuntu 18.04 LTS and a custom 5.4.0
    Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, it''s loaded up and ready. Next, we will build and try out our user
    space application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce358d89-c70a-4d5b-8804-df86245ce2b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Screenshot showing user<->kernel communication via our sample netlink
    socket code
  prefs: []
  type: TYPE_NORMAL
- en: It works; the kernel netlink module receives and displays the message that was
    sent to it from the user space process (`PID 7813`). The kernel module then replies
    with its own message to its user space peer, which successfully receives and displays
    it (via a `printf()`). Give it a try yourself. When you're done, don't forget
    to remove the kernel module with `sudo rmmod netlink_simple_intf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An aside: a connector driver exists within the kernel. Its purpose is to ease
    the development of netlink-based communication, making it simpler for both kernel
    and user space developers set up and use a netlink-based communication interface.
    We will not delve into this here; please refer to the documentation within the
    kernel ([https://elixir.bootlin.com/linux/v5.4/source/Documentation/driver-api/connector.rst](https://elixir.bootlin.com/linux/v5.4/source/Documentation/driver-api/connector.rst)).
    Some sample code is also provided within the kernel source tree (at `samples/connector`).'
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have learned how to interface between a user mode app and a kernel
    component via the powerful netlink socket mechanism. As we mentioned earlier,
    it has several actual use cases within the kernel tree. Now, let's move on and
    cover one more user-kernel interfacing method, via the popular `ioctl(2)` system
    call.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing via the ioctl system call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ioctl **is a system call; why the funny name *ioctl*? It''s an abbreviation
    for **input-output control**. While the read and write system calls (among others)
    are used to effectively transfer *data* from and to a device (or file; remember
    the UNIX paradigm *if it''s not a process, it''s a file!*), the *ioctl* system
    call is used to *issue* *commands* to the device (via its driver). For example,
    changing a console device''s terminal characteristics, writing a track to a disk
    when formatting it, sending a control command to a stepper motor, controlling
    a camera or audio device, and so on, are all instances of commands being sent
    to a device.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a fictitious example. We have a device and are developing a (character)
    device driver for it. The device has various *registers*, small – typically 8-,
    16-, or 32-bit pieces of hardware memory on the device – some of which are control
    registers. By appropriately performing I/O (reads and writes) on them, we control
    the device (well, that's really the whole point, isn't it; the actual subject
    matter regarding the details of working with hardware memory including device
    registers will be covered in the next chapter). So, how will you, the driver author,
    communicate or interface with a user space program that wants to perform various
    control operations on this device? We often architect the user space C (or C++)
    program to open the device typically by performing an `open(2)` on its device
    file, and subsequently issue the read and write system calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, as we just mentioned, the `read(2)` and `write(2)` system call APIs are
    appropriate when *transferring* *data* while here, instead, we intend to perform
    **control operations**. So, we need another system call to do so... Do we then
    need to create and encode a new system call (or calls)? No, it''s much simpler
    than that: we *multiplex via the* *ioctl system call,* leveraging it to perform
    any required control operations upon our device! How? Ah, recall from the previous
    chapter the all-important `file_operations` (fops) data structure; we will now
    initialize another member, the `.ioctl` one, to our ioctl method function, thus
    allowing our device driver to hook into this system call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Realistically, we shall have to figure out whether we should use `ioctl` or
    the `unlocked_ioctl` member of the `file_operations` structure, depending on whether
    the module is running on Linux kernel version 2.6.36 or later; more on this follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, adding new system calls to the kernel is not something you should
    do lightly! The kernel chaps are *not *open to arbitrarily adding syscalls – it''s
    a security-sensitive interface, after all. More on this is documented here: [https://www.kernel.org/doc/html/latest/kernel-hacking/hacking.html#ioctls-not-writing-a-new-system-call](https://www.kernel.org/doc/html/latest/kernel-hacking/hacking.html#ioctls-not-writing-a-new-system-call).'
  prefs: []
  type: TYPE_NORMAL
- en: More on using ioctl for interfacing follows.
  prefs: []
  type: TYPE_NORMAL
- en: Using ioctl in the user and kernel space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ioctl(2)` system call''s signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter list is a *varargs – variable arguments –* one. Realistically
    and typically, we pass either two or three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is obvious – the file descriptor of the (in our case) device
    file that was opened.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second parameter, called `request`, is the interesting one: it''s the command
    to be passed to the driver. In reality, it''s an *encoding*, encapsulating a so-called
    ioctl magic number: a number and a type (read/write).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The (optional) third parameter, often called `arg`, is also an `unsigned long`
    quantity; we use it to either pass some data in the usual fashion to the underlying
    driver or, often, to return data to the user space by passing its (virtual) address
    and having the kernel write into it, utilizing C's so-called **value-result**
    or **in-out** parameter style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, using ioctl correctly is not as trivial as it is with many other APIs.
    Think about this for a moment: you can easily have a scenario where several user
    space apps are issuing `ioctl(2)` system calls (with various commands being issued)
    to their underlying device drivers. A problem becomes apparent: how will the kernel
    VFS layer direct the ioctl request to the correct driver? ioctl is typically performed
    on a char device file that has a unique *(major, minor)* number; hence, how can
    another driver receive your ioctl command (unless you intentionally, perhaps maliciously,
    set up the device file(s) in such a manner)?'
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, a protocol exists to achieve safe and correct usage of ioctl; every
    application and driver defines a magic number that will be encoded into all its
    ioctl requests. First, the driver will verify that every ioctl request it receives
    contains *its* magic number; only then will it proceed to process it; otherwise,
    it will simply drop it. This, of course, brings up the need for an *ABI* – we
    need to allocate unique magic numbers (it could be a range) to each "registered"
    driver. Since this creates an ABI, the kernel document will be the same; you can
    find details on who is using which magic number (or code) here: [https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt](https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, an ioctl request to the underlying driver can be one of essentially four
    things: a command to "write" to the device, a command to "read" from (or query)
    the device, a command to do both read/write transfers, or neither. This information
    is (again) *encoded* into a request by defining certain bits to convey the meaning:
    to make this job easier, we have four helper macros that allows us to construct
    ioctl commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_IO(type,nr)`: Encodes an ioctl command with no argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_IO**R**(type,nr,datatype)`: Encodes an ioctl command for reading data from
    the kernel/driver'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_IO**W**(type,nr,datatype)`: Encodes an ioctl command for writing data to
    the kernel/driver'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_IO**WR**(type,nr,datatype)`: Encodes an ioctl command for read/write transfers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These macros are defined within the user space `<sys/ioctl.h>` header and in
    the kernel at `include/uapi/asm-generic/ioctl.h`. The typical (and quite obvious)
    best practice is to create a *common header* file that defines the ioctl commands
    for an app/driver and includes that file in both the user mode app, as well as
    the device driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, as a demonstration, we shall design and implement a user space app and
    a kernel space device driver to drive a fictional device that communicates via
    the `ioctl(2)` system call. Thus, we must define some commands to issue via the
    *ioctl* interface. We will do this in a common header file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We must try and make the names we use in our macros meaningful. Our three commands
    (highlighted in bold) are all prefixed with `IOCTL_LLKD_`, indicating that they
    are all ioctl commands for our fictitious `LLKD` project; next, they are suffixed
    with `IOC{Q|S}`, with `IOC` implying that it's an ioctl command, `Q` implying
    it's a query operation, and `S` implying it's a set operation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how we set things up at the code level from both the user space
    as well as the kernel space (driver).
  prefs: []
  type: TYPE_NORMAL
- en: User space – using the ioctl system call
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *user space* signature of the `ioctl(2)` system call is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that it takes a variable argument list; the arguments to ioctl
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First parameter**: The file descriptor of the file or device (as it will
    be in our case) to perform the ioctl operation on (we get `fd` by performing an
    *open* on the device file).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second parameter**: The request or command being issued to the underlying
    device driver (or filesystem or whatever `fd` represents).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An optional third (or more) parameter(s)**: Often, the third parameter is
    an integer (or a pointer to an integer or data structure); we use this method
    to either pass some additional information to the driver, when issuing a *set *kind
    of command, or to retrieve some information from the driver via the well-understood
    *pass-by-reference* C paradigm, where we pass the pointer and have the driver
    "poke" it, thus treating the parameter as, in effect, a return value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In effect, ioctl is often used as a *generic* system call. The use of ioctl
    to perform command operations on both hardware and software is almost embarrassingly
    large! Please refer to the kernel documentation (`Documentation/ioctl/<...>`)
    to see many actual real-world examples. For example, you will find details on
    who is using which magic number (or code) within ioctl here: [https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt](https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt).'
  prefs: []
  type: TYPE_NORMAL
- en: (Similarly, the `ioctl_list(2)` man page reveals the complete list of ioctl
    calls in the x86 kernel; these documentation files seem to be pretty old, though.
    The docs now seem to be here: [https://github.com/torvalds/linux/tree/master/Documentation/userspace-api/ioctl](https://github.com/torvalds/linux/tree/master/Documentation/userspace-api/ioctl).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some snippets of the user space C application, particularly
    when it comes to issuing the `ioctl(2)` system calls (for brevity and readability,
    we have left out the error checking code; the full code is available in this book''s
    GitHub repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: How does our driver handle these user space-issued ioctls? Let's find out.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel space – using the ioctl system call
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we saw that the kernel driver will have to initialize
    its `file_operations` structure to include the `ioctl` method. There is more to
    this, though: the Linux kernel keeps evolving; in early kernel versions, the developers
    used a very coarse granularity lock that, though it worked, quite severely hurt
    its performance (we will discuss locking in detail in [Chapter 6](f456f2ea-ca5f-4d0f-b9c0-55b9ae92f659.xhtml),
    *Kernel Synchronization - Part 1*, and [Chapter 7](14cf1232-dfd5-428a-9c0b-30bcd84651b9.xhtml),
    *Kernel Synchronization - Part 2*). It was so bad that it was nicknamed the **Big
    Kernel Lock** (**BKL**)! The good news is that by kernel release 2.6.36, the developers
    got rid of this infamous lock. Doing so had some side effects, though: one of
    them was that the number of parameters that get sent to the ioctl method within
    the kernel and thus within our `file_operations` data structure changed from four
    to three with the newer method – christened `unlocked_ioctl`. Thus, for our demo
    driver, we will initialize the *ioctl* method with the following when initializing
    our driver''s `file_operations` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, as it''s defined within the fops driver, ioctl is considered a private
    driver interface (`driver-private`). Also, this same fact regarding the newer
    "unlocked" version has to be taken into account in the function definition within
    the driver code; our driver does so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The key code here is the driver''s ioctl method. Think about it: once basic
    validity checks have been done, all the driver really does is perform a *switch-case *on
    all possible valid ioctl commands issued by the user space app. Let''s take a
    look at the following code (for readability, we will skip the `#if LINUX_VERSION_CODE
    >= ...` macro directive and just show the modern ioctl function signature, as
    well as some validity checks; you can view the full code in this book''s GitHub
    repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_IOC_NR` macro is used to extract the command number from the `cmd` parameter.
    Here, we can see that the driver "reacts" to three valid cases of the `ioctl` issued
    via the user space process:'
  prefs: []
  type: TYPE_NORMAL
- en: On receiving the `IOCTL_LLKD_IOC**RESET**` command, it performs a device reset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On receiving the `IOCTL_LLKD_IOC**Q**POWER` command, it queries (`Q` for query)
    and returns the current power status (by poking its value into the third parameter, `arg`,
    using the *value-result* C programming approach).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On receiving the `IOCTL_LLKD_IOC**S**POWER` command, it sets (`S` for set) the
    power status (to the value passed in the third parameter, `arg`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, since we're working with a purely fictional device, our driver does
    not actually perform any register (or other hardware) work. This driver is simply
    a template that you can make use of.
  prefs: []
  type: TYPE_NORMAL
- en: What if a hacker attempts to issue a command unknown to our driver in a (rather
    clumsy) hack? Well, the initial validity checks will catch it; even if they don't,
    we shall hit the `default` case in our *ioctl* method, resulting in the driver
    returning `-ENOTTY` to the user space. This will, via glibc "glue" code, set the
    user space process (or thread's) `errno` value to `ENOTTY`, informing it that
    the ioctl method cannot be serviced. Our user space `perror(3)` API will display
    the `Inappropriate ioctl for device` error message. In fact, this is precisely
    what occurs if a driver has *no* ioctl method (that is, if the ioctl member within
    the `file_operations` structure is set to `NULL`) and a user space app issues
    an `ioctl` method against it.
  prefs: []
  type: TYPE_NORMAL
- en: I leave it to you to try out this user space/driver project example; for convenience,
    once the driver has been loaded (via insmod), you can use the `ch2/userspace_ioctl/cr8devnode.sh`
    convenience script to generate the device file. Once it's set up, run the user
    space app; you will find that running it in succession has the "power state" of
    our fictional device get repeatedly toggled.
  prefs: []
  type: TYPE_NORMAL
- en: ioctl as a debug interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this chapter, what about using the *ioctl*
    interface for debug purposes? It can be used for this purpose. You can always
    insert a "debug" command into the *switch-case* block; it can be used to provide
    useful information to the user space application on the driver status, the values
    of key variables (health monitoring too), and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only that, but unless it''s explicitly documented to the end user or customer,
    the precise commands that are used via the ioctl interface are unknown; thus,
    you are expected to document the interface while providing sufficient detail for
    other teams or the customer to make good use of them. This leads to an interesting
    point: you might choose to deliberately leave a certain ioctl command undocumented;
    it''s now a "hidden" command that can be used by, say, field engineers to examine
    the device. (I leave doing this as an assignment to you.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel documentation on ioctl includes this file: [https://www.kernel.org/doc/Documentation/ioctl/botching-up-ioctls.txt](https://www.kernel.org/doc/Documentation/ioctl/botching-up-ioctls.txt).
    Though biased toward kernel graphics stack devs, it describes typical design mistakes,
    trade-offs, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Fantastic – you're almost done! You have learned how to interface a kernel module
    or driver with a user mode process or thread (within a user space application)
    via various technologies. We began with procfs, then moved on to using sysfs and
    debugfs. The netlink socket and the ioctl system call completed our look at these
    interfacing methods.
  prefs: []
  type: TYPE_NORMAL
- en: But with all this choice, which one should you actually use on a project? The
    next section will help you make this decision by providing a quick comparison
    between these various interfacing methods.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the interfacing methods – a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we have created a quick comparison table of the various user-kernel
    interfacing methods that were described in this chapter, based on a few parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter /Interfacing method** | **procfs** | **sysfs** | **        debugfs**
    | **netlink socket** | **ioctl** |'
  prefs: []
  type: TYPE_TB
- en: '| **Ease of development** | Easy to learn and use. | (Relatively) easy to learn
    and use. | (Very) easy to learn and use. | Harder; have to write user space C
    + driver code + understand socket APIs. | Fair/harder; have to write user space
    C + driver code. |'
  prefs: []
  type: TYPE_TB
- en: '| **Appropriate for what use** | Core kernel *only* (a few older drivers may
    still use it); best avoided by drivers. | Device driver interfacing. | Driver
    (and other) interfacing for production and debug purposes. | Various interfacing:
    users include device drivers, core networking code, the udev system, and more.
    | Device driver interfacing mostly (includes many). |'
  prefs: []
  type: TYPE_TB
- en: '| **Interface visibility** | Visible to all; use permissions to control access.
    | Visible to all; use permissions to control access. | Visible to all; use permissions
    to control access. | Hidden from the filesystem; doesn''t pollute the kernel namespace.
    | Hidden from the filesystem; doesn''t pollute the kernel namespace. |'
  prefs: []
  type: TYPE_TB
- en: '| **Upstream kernel ABI for driver/module authors*** | Usage in drivers is
    deprecated for mainline. | The "right way"; the formally accepted approach to
    interface drivers with user space. | Well supported and heavily used in mainline
    by drivers and other products. | Well supported (since 2.2). | Well supported.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Useful for (driver) debugging purposes**  | Yes (although not supposed
    to in mainline). | No/not ideal. | Yes, very useful! "No rules" by design. | No/not
    ideal. | Yes; (even) via hidden commands. |'
  prefs: []
  type: TYPE_TB
- en: '* As we mentioned earlier, the kernel community documents that procfs, sysfs,
    and debugfs are all *ABIs; *their stability and lifespan isn''t guaranteed. While
    that is the formal stance adopted by the community, the reality is that plenty
    of actual interfaces that use these filesystems have become de facto ones used
    by products in the real world. Nevertheless, we should follow the kernel community''s
    "rules" and guidelines regarding their usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered an important aspect of device driver authors – how
    exactly you can *interface between user and kernel  (driver) space*. We walked
    you through several interfacing methods; we began with an older one, which is
    interfacing via the venerable proc filesystem (and then mentioned why it's not
    the preferred method for driver authors). We then moved on to interfacing via
    the newer 2.6-based *sysfs.* This turns out to be *the* preferred interface for
    the user space, at least for a device driver. Sysfs has limitations, though (recall
    the one-value-per-sysfs-file rule). Thus, using the completely free-format *debugfs*
    interfacing technique makes writing debug (and other) interfaces very simple and
    powerful indeed. The netlink socket is a powerful interfacing technology and is
    used by the network subsystem, udev, and a few drivers; it does require some knowledge
    on socket programming and the kernel socket buffer, though. To perform generic
    command operations on device drivers, the ioctl system call turns out to be a
    tremendous multiplexer and is often used by device driver authors (and other components)
    to interface with the user space.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this knowledge, you are now in a position to practically integrate
    your driver-level code with user space applications (or scripts); often, a user
    mode **graphical user interface** (**GUI**) will want to display some values that
    have been received from the kernel or device driver. You now know how to pass
    these values from the kernel space device driver!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you will learn about a typical task driver authors must
    perform: working with hardware chip memory! Do ensure you''re clear on this chapter''s
    material, work on the exercises provided, review the *Further reading* resources,
    and then dive into the next chapter. See you there!'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`sysfs_on_misc`: *sysfs assignment #1*: Extend one of the `misc` device drivers
    we wrote in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml), *Writing
    a Simple misc Character Device Driver*; set up two sysfs files and their read/write
    callbacks; test them from user space.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sysfs_addrxlate`: *sysfs assignment #2 (a bit more advanced)*: *Address translation:*
    Exploiting the knowledge gained from this chapter and from the *Linux Kernel Programming* book, *Chapter
    7, Memory Management Internals - Essentials,* the *Direct-mapped RAM and address
    translation* section, write a simple platform driver that provides two sysfs interface
    files called `addrxlate_kva2pa` and `addrxlate_pa2kva`. Writing a kva into the
    sysfs file, `addrxlate_kva2pa`, should have the driver read and translate the
    *kva* into its corresponding **physical address** (**pa**); then, reading from
    the same file should cause the *pa* to be displayed. Do the same with the `addrxlate_pa2kva`
    sysfs file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dbgfs_disp_pgoff`: *debugfs assignment #1*: Write a kernel module that sets
    up a debugfs file here: `<debugfs_mount_point>/dbgfs_disp_pgoff`. When read, it
    should display (to user space) the current value of the `PAGE_OFFSET` kernel macro.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dbgfs_showall_threads`: *debugfs assignment #2* : Write a kernel module that
    sets up a debugfs file here: `<debugfs_mount_point>/dbgfs_showall_threads/dbgfs_showall_threads`.
    When read, it should display some attributes of every thread that''s alive. (This
    is similar to our code from the *Linux Kernel Programming* book here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/ch6/foreach/thrd_showall](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/ch6/foreach/thrd_showall).
    Note that the threads are displayed *only* at insmod time; with a debugfs file,
    you can display information on all the threads at any time you choose to)!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Suggested output is CSV format: *`TGID,PID,current,stack-start,name,#threads`. The
    `[name]` field in square brackets => kernel thread*;'
  prefs: []
  type: TYPE_NORMAL
- en: '* `#threads` field should only display a positive integer*;* no output here
    implies a single-threaded process; for example: `130,130,0xffff9f8b3cd38000,0xffffc13280420000,[watchdogd]`)'
  prefs: []
  type: TYPE_NORMAL
- en: '*ioctl assignment #1*: Using the provided `ch2/ioctl_intf/` code as a template,
    write a user space C application and a kernel space (char) device driver implementing
    the `ioctl` method. Add an ioctl command called `IOCTL_LLKD_IOCQPGOFF` to return
    the value of `PAGE_OFFSET` (within the kernel) to the user space.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ioctl_undoc`: *ioctl assignment #2*: Using the provided `ch2/ioctl_intf/`
    code as a template, write a user space C application and a kernel space (char)
    device driver implementing the `ioctl` method. Add a driver context data structure
    (we used these in several examples), and then allocate and initialize it. Now,
    in addition to the three previous ioctl commands we used, set up a fourth undocumented
    command (you can call it `IOCTL_LLKD_IOCQDRVSTAT`). When queried from the user
    space via `ioctl(2)`, it must return the contents of the driver context data structure
    to the user space; the user space C app must print out the current content of
    every member of that structure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will find some of the questions answered in the book's GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn).
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter. Some more information on using the very common I2C protocol within
    a Linux device driver can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: An article on the I2C protocol basics: *How to use I2C in STM32F103C8T6? STM32
    I2C Tutorial*, March 2020: [https://www.electronicshub.org/how-to-use-i2c-in-stm32f103c8t6/](https://www.electronicshub.org/how-to-use-i2c-in-stm32f103c8t6/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kernel documentation: Implementing I2C device drivers: [https://www.kernel.org/doc/html/latest/i2c/writing-clients.html](https://www.kernel.org/doc/html/latest/i2c/writing-clients.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
