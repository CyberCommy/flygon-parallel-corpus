- en: '6: Kubernetes Services'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters we’ve launched Pods and used Deployments to add self-healing,
    scalability, and rolling updates. However, despite all of this, **we still cannot
    rely on Pod IPs!** In this chapter, we’ll see how Kubernetes *Services* give us
    networking that we **can** rely on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll split the chapter up like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real world example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before diving in, we need to remind ourselves that **Pod IPs are unreliable.**
    When Pods fail, they get replaced with new Pods with new IPs. Scaling-up a Deployment
    introduces new Pods with new IP addresses. Scaling-down a Deployment removes Pods.
    All of this creates a large amount of IP churn, and creates a situation where
    Pod IPs cannot be relied on.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to know 3 fundamental things about Kubernetes Services.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to clear up some terminology. When talking about a *Service*
    in this chapter we’re talking about the Service REST object in the Kubernetes
    API. Just like a *Pod* , *ReplicaSet* , or *Deployment* , a Kubernetes ***Service***
    is an object in the API that we define in a manifest and POST to the API server.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we need to know that every Service gets its own **stable IP address**
    , its own **stable DNS name** , and its own **stable port** .
  prefs: []
  type: TYPE_NORMAL
- en: Third, we need to know that Services use labels to dynamically select the Pods
    in the cluster they will send traffic to.
  prefs: []
  type: TYPE_NORMAL
- en: The last two points are what allow Services to provide stable networking to
    a dynamic set of Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Theory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Figure 6.1 shows a simple Pod-based application deployed via a Kubernetes Deployment.
    It shows a client (which could be another component of the app) that does not
    have a reliable network endpoint for accessing the Pods - remember that Pod IPs
    are unreliable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 shows the same application with a Service added into the mix. The
    Service is associated with the Pods and provides them with a stable IP, DNS and
    port. It also load-balances requests across the Pods.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2
  prefs: []
  type: TYPE_NORMAL
- en: With a Service in front of a set of Pods, the Pods can scale up and down, they
    can fail, and they can be updated… As these things happen, the Service in front
    of them notices the changes and updates its knowledge of the Pods. But it never
    changes the stable IP, DNS and port that it exposes!
  prefs: []
  type: TYPE_NORMAL
- en: Labels and loose coupling
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pods and Services are loosely coupled via *labels* and *label selectors* . This
    is the same technology that links Deployments to Pods. Figure 6.3 shows an example
    where 3 Pods are labelled as `zone=prod` and `version=1` , and the Service has
    a *label selector* that matches.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3](Image00038.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3
  prefs: []
  type: TYPE_NORMAL
- en: In Figure 6.3, the Service is providing stable networking to all three Pods
    - you can send requests to the Service and it will proxy them on to the Pods.
    It also provides simple load-balancing.
  prefs: []
  type: TYPE_NORMAL
- en: For a Service to match a set of Pods, and therefore provide stable networking
    and load-balancing, it only needs to match *some* of the labels on a Pod. However,
    for a Pod to match a Service, it has to have all of the labels the Service is
    looking for. If that sounds confusing, the examples in Figure’s 6.4 and 6.5 should
    help.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 shows an example where the Service does not match any of the Pods.
    This is because the Service is looking for Pods that have two labels, but the
    Pods only possess one of them. The logic behind this is a Boolean `AND` operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4](Image00039.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 shows an example that does work. It works because the Service is
    selecting on two labels, and the Pods in the diagram possess both. It doesn’t
    matter that the Pods have additional labels that the Service isn’t looking for.
    The Service is looking for Pods with two labels, it finds them, and ignores the
    fact that the Pods have additional labels - all that is important is that the
    Pods possess the labels the Service is looking for.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5](Image00040.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5
  prefs: []
  type: TYPE_NORMAL
- en: The following excerpts, from a Service YAML and Deployment YAML, show how *selectors*
    and *labels* are implemented. We’ve added comments to the lines we’re interested
    in.
  prefs: []
  type: TYPE_NORMAL
- en: '**svc.yml**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**deploy.yml**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the example files, the Service has a label selector (`.spec.selector` ) with
    a single value `app=hello-world` . This is the label that the Service is looking
    for when it queries the cluster for matching Pods. The Deployment specifies a
    Pod template with the same `app=hello-world` label (`.spec.template.metadata.labels`
    ). This means that any Pods it deploys will have the `app=hello-world` label.
    It is these two attributes that loosely tie the Service to the Deployments Pods.
  prefs: []
  type: TYPE_NORMAL
- en: When the Deployment and the Service are deployed, the Service will select all
    10 Pod replicas and provide them with a stable networking endpoint and perform
    load-balancing.
  prefs: []
  type: TYPE_NORMAL
- en: Services and Endpoint objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As Pods come-and-go (scaling up and down, failures, rolling updates etc.), the
    Service dynamically updates its list of healthy matching Pods. It does this through
    a combination of the label selector and a construct called an *Endpoint* object.
  prefs: []
  type: TYPE_NORMAL
- en: Each Service that is created, automatically gets an associated *Endpoint* object.
    All this Endpoint object is, is a dynamic list of all of the healthy Pods on the
    cluster that match the Service’s label selector.
  prefs: []
  type: TYPE_NORMAL
- en: It works like this…
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is constantly evaluating the Service’s label selector against the
    current list of healthy Pods in the cluster. Any new Pods that match the selector
    get added to the Endpoint object, and any Pods that disappear get removed. This
    means the Endpoint is always up-to-date. When a Service is sending traffic to
    Pods, it queries its Endpoint for the latest list of healthy matching Pods - this
    ensures the Service is kept up-to-date as Pods come and go.
  prefs: []
  type: TYPE_NORMAL
- en: The Endpoint object has its own API endpoint that Kubernetes-native apps can
    query for the latest list of matching Pods (like the Service object does). Non-native
    Kubernetes apps can just use the Service’s stable IP (VIP).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the fundamentals of how Services work, let’s look at some use-cases.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Services from inside the cluster
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Kubernetes supports several *types* of Service. The default type is **ClusterIP**
    .
  prefs: []
  type: TYPE_NORMAL
- en: A ClusterIP Service does the following. It gets the Service a stable IP address
    (ClusterIP) and port that is only accessible from inside the cluster. It then
    registers them against the name of the Service on the cluster’s DNS service.
  prefs: []
  type: TYPE_NORMAL
- en: All Pods in the cluster know about the cluster’s DNS service, meaning all Pods
    are able to resolve Service names.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Service called “hellcat-svc” will trigger the following. Kubernetes
    will register the name “hellcat-svc”, along with an IP address and port, with
    the cluster’s DNS service. The name, IP and port are guaranteed to be long-lived
    and stable, and all Pods in the cluster will be able to resolve “hellcat-svc”
    to the Service’s ClusterIP.
  prefs: []
  type: TYPE_NORMAL
- en: Net net… as long as a Pod (application microservice) knows the name of a Service,
    it can resolve that to its ClusterIP address and connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: This only works for Pods and other objects on the cluster, as it requires access
    to the cluster’s DNS service. It does not work outside of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing from outside the cluster
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Kubernetes has another type of Service called a **NodePort Service** . This
    builds on top of ClusterIP and enables access from outside of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that the default Service type is ClusterIP, and that this registers
    a DNS name, Virtual IP, and port with the clusters DNS. NodePort Services add
    to this by adding another port that can be used to reach the Service from outside
    the cluster. This additional port is called the NodePort.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example represents a NodePort Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name:** hellcat-svc'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ClusterIP:** 172.12.5.17'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**port:** 8080'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NodePort:** 30050'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This Service can be accessed directly from inside the cluster via any of the
    first three values (Name, ClusterIP, port). It can also be accessed from outside
    of the cluster by hitting any cluster node on port `30050` .
  prefs: []
  type: TYPE_NORMAL
- en: At the lowest level, we have *nodes* in the cluster hosting Pods. Then we create
    a Service and use labels to associate it with Pods. The Service object has a reliable
    NodePort mapped to every node in the cluster – the NodePort is the same on every
    node. This means that traffic from outside of the cluster can hit any node in
    the cluster on the NodePort and get through to the application (Pods).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 shows an NodePort Service where 3 Pods are exposed externally on
    port `30050` on every node in the cluster. In step 1, an external client hits
    **Node2** on port `30050` . In step 2 it is redirected to the Service object (this
    happens even though **Node2** isn’t running a Pod from the Service). Step 3 shows
    that the Service has an associated Endpoint object with an always-up-to-date list
    of Pods matching the label selector. Step 4 shows the client being directed to
    **pod1** on **Node1** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6
  prefs: []
  type: TYPE_NORMAL
- en: The Service could just as easily have directed the client to pod2 or pod3\.
    In fact, future requests may go to other Pods as the Service load-balances traffic
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: There are other types of Services, such as LoadBalancer Services. These integrate
    with load-balancers from your cloud provider such as AWS, Azure, and GCP. They
    build on top of NodePort Services (which in turn build on top of ClusterIP Services)
    and allow clients on the internet to reach your Pods via one of your cloud’s load-balancers.
  prefs: []
  type: TYPE_NORMAL
- en: LoadBalancer Services are extremely easy to setup. However, they only work if
    you’re running your Kubernetes cluster on a supported cloud platform. E.g. you
    cannot leverage an ELB load-balancer on AWS if your Kubernetes cluster is an on-premises
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Kubernetes implements Service discovery in a couple of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: DNS (preferred)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables (definitely not preferred)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS-based Service discovery requires the DNS *cluster-add-on* - this is just
    a fancy name for the native Kubernetes DNS service. If you followed the installation
    methods from the “Installing Kubernetes” chapter, you’ll already have this. It
    implements a Pod-based DNS service in the cluster and configures all kubelets
    (nodes) to use it for DNS.
  prefs: []
  type: TYPE_NORMAL
- en: The DNS add-on constantly watches the API server for new Services and automatically
    registers them in DNS. This means every Service gets a DNS name that is resolvable
    across the entire cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative form of service discovery is through environment variables.
    Every Pod gets a set of environment variables that resolve every Service currently
    on the cluster. However, this is a fall-back in case you’re not using DNS in your
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with environment variables, is that they’re only inserted into Pods
    at creation time. This means that Pods have no way of learning about new Services
    that are added to the cluster after the Pod itself is created - far from ideal!
    This is why DNS is the preferred method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of Service theory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Services are all about providing stable networking for Pods. They also provide
    load-balancing and ways to be accessed from outside of the cluster. They’re dynamically
    associated with Pods using labels and label selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on with Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re about to get hands-on and put the theory to the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll augment a simple single-Pod app with a Kubernetes Service. And we’ll
    show how to do it in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The imperative way (only use in emergencies)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The declarative way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The imperative way
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Warning!** The imperative way is **not** the Kubernetes way! It introduces
    the risk that changes made imperatively never make it into declarative manifests,
    rendering the manifests stale. This introduces the risk that stale manifests are
    used to update the cluster at a later date, unintentionally overwriting important
    changes that were made imperatively.'
  prefs: []
  type: TYPE_NORMAL
- en: Use `kubectl` to declaratively deploy the following Deployment (later steps
    will be done imperatively). The command assumes the Deployment is defined in a
    file called `deploy.yml` and has the following content.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that the Deployment is running, it’s time to imperatively deploy a Service
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Use the following `kubectl` command to create a new Service that will provide
    networking and load-balancing for the Pods deployed in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let’s explain what the command is doing. `kubectl expose` is the imperative
    way to create a new *Service* object. `deployment web-deploy` is telling Kubernetes
    to expose the Deployment called `web-deploy` that was created in a previous step.
    `--name=hello-svc` tells Kubernetes that we want to call this Service “hello-svc”,
    and `--target-port=8080` tells it which port the app is listening on (this is
    **not** the cluster-wide NodePort that we’ll access the Service on). Finally,
    `--type=NodePort` tells Kubernetes we want a cluster-wide port for the Service.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Service is created, you can inspect it with the `kubectl describe svc
    hello-svc` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Some interesting values in the output include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Selector` is the list of labels that Pods must have in order for the Service
    to send traffic to them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IP` is the permanent ClusterIP (VIP) of the Service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Port` is the port that the app and Service listens on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NodePort` is the cluster-wide port that can be used to access it externally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Endpoints` is the dynamic list of healthy Pods that currently match the Service’s
    label selector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know the cluster-wide port that the Service is accessible on, we
    can open a web browser and access the app. In order to do this, you will need
    to know the IP address of at least one of the nodes in your cluster, and you will
    need to be able to reach it from your browser - e.g. a publicly routable IP if
    you’re accessing via the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 shows a web browser accessing a cluster node with an IP address of
    `54.246.255.52` on the cluster-wide NodePort `30175` .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7](Image00042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7
  prefs: []
  type: TYPE_NORMAL
- en: The app we’ve deployed is a simple web app. It’s built to listen on port 8080,
    and we’ve configured a Kubernetes *Service* to map port `30175` on every cluster
    node back to port 8080 on the app. By default, cluster-wide ports (NodePort values)
    are between 30,000 - 32,767.
  prefs: []
  type: TYPE_NORMAL
- en: Coming up next we’re going to see how to do the same thing the proper way -
    the declarative way! To do that, we need to clean up by deleting the Service we
    just created. We can do this with the `kubectl delete svc` command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The declarative way
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Time to do things the proper way… the Kubernetes way!
  prefs: []
  type: TYPE_NORMAL
- en: A Service manifest file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll use the following Service manifest file to deploy the same *Service* that
    we deployed in the previous section. Only this time we’ll specify a value for
    the cluster-wide port.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let’s step through some of the lines.
  prefs: []
  type: TYPE_NORMAL
- en: Services are mature objects and are fully defined in the `v1` API (`.apiVersion`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: The `.kind` field tells Kubernetes to pass the manifest to the Service controller
    for deployment as a Service.
  prefs: []
  type: TYPE_NORMAL
- en: The `.metadata` section defines a name and a label for the Service. The label
    here is a label for the Service itself. It is not the label that the Service uses
    to select Pods.
  prefs: []
  type: TYPE_NORMAL
- en: The `.spec` section is where we actually define the Service. In this example,
    we’re telling Kubernetes to deploy a `NodePort` Service (other types such as `ClusterIP`
    and `LoadBalancer` exist) and to map port `8080` to port `30001` on each node
    in the cluster. Then we’re explicitly telling it to use TCP (default).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `.spec.selector` tells the Service to send traffic to all Pods in the
    cluster that have the `app=hello-world` label. This means it will provide stable
    networking and load-balancing across all Pods with that label.
  prefs: []
  type: TYPE_NORMAL
- en: Common Service types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The three common *ServiceTypes* are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClusterIP.` This is the default option, and gives the *Service* a stable IP
    address internally within the cluster. It will not make the Service available
    outside of the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NodePort.` This builds on top of `ClusterIP` and adds a cluster-wide TCP or
    UDP port. It makes the Service available outside of the cluster on this port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadBalancer.` This builds on top of `NodePort` and integrates with cloud-based
    load-balancers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The manifest needs POSTing to the API server. The simplest way to do this is
    with `kubectl apply` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command tells Kubernetes to deploy a new object from a file called `svc.yml`
    . The `-f` flag lets you tell Kubernetes which manifest file to use. Kubernetes
    knows to deploy a Service object based on the value of the `.kind` field in the
    manifest.
  prefs: []
  type: TYPE_NORMAL
- en: Introspecting Services
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that the Service is deployed, you can inspect it with the usual `kubectl
    get` and `kubectl describe` commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we’ve exposed the Service as a `NodePort` on port `30001`
    across the entire cluster. This means we can point a web browser to that port
    on any node and get to the Service. You will need to use a node IP that you can
    reach, and you will need to make sure that any firewall and security rules allow
    the traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 shows a web browser accessing the app via a cluster node with an
    IP address of `54.246.255.52` on the cluster-wide port `30001` .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8
  prefs: []
  type: TYPE_NORMAL
- en: Endpoint objects
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Earlier in the chapter, we said that every Service gets its own Endpoint object
    with the same name as the Service. This holds a list of all the Pods the Service
    matches and is dynamically updated as Pods come and go. We can see Endpoints with
    the normal `kubectl` commands.
  prefs: []
  type: TYPE_NORMAL
- en: In the following command, we abbreviate Endpoint to `ep` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Summary of deploying Services
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with all Kubernetes objects, the preferred way of deploying and managing
    Services is the declarative way. Leveraging labels allows them to be dynamic.
    This means you can deploy new Services that will work with Pods and Deployments
    that are already running on the cluster and in use. Each Service gets its own
    Endpoint object that maintains an up-to-date list of matching Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Real world example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although everything we’ve learned so far is cool and interesting, the important
    questions are: *How does it bring value?* and *How does it keep businesses running
    and make them more agile and resilient?*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a minute to run through a common real-world example - making updates
    to applications.
  prefs: []
  type: TYPE_NORMAL
- en: We all know that updating applications is a fact of life - bug fixes, new features
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 shows a simple application deployed on a Kubernetes cluster as a
    bunch of Pods managed by a Deployment. As part of it, we’ve got a Service selecting
    on Pods with labels that match `app=biz1` and `zone=prod` (notice how the Pods
    have both of the labels listed in the label selector). The application is up and
    running.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9](Image00044.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume we need to push a new version. But we need to do it without incurring
    downtime.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we can add Pods running the new version of the app as shown in Figure
    6.10.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10](Image00045.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, the updated *Pods* are deployed through their own ReplicaSet
    and are labelled so that they match the existing label selector. The Service is
    now load-balancing requests across **both versions of the app** (`version=4.1`
    and `version=4.2` ).
  prefs: []
  type: TYPE_NORMAL
- en: This happens because the Service’s label selector is being constantly evaluated,
    and its Endpoint object and ClusterIP are constantly being updated with new matching
    Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re happy with the updated version, forcing all traffic to use it is
    as simple as updating the Service’s label selector to include the label `version=4.2`
    . Suddenly the older version no longer matches, and the Service is only forwarding
    traffic to the new version (Figure 6.11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11](Image00046.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11
  prefs: []
  type: TYPE_NORMAL
- en: However, the old version still exists - we’re just not sending traffic to it
    any more. This means that if we experience an issue with the new version, we can
    switch back to the previous version by simply changing the label selector on the
    Service to include `version=4.1` instead of `version=4.2` . See Figure 6.12.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12](Image00047.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12
  prefs: []
  type: TYPE_NORMAL
- en: Now everybody’s getting the old version.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality can be used for all kinds of things - blue-greens, canaries,
    you name it. So simple, yet so powerful!
  prefs: []
  type: TYPE_NORMAL
- en: Clean-up the lab with the following commands. These will delete the Deployment
    and Service used in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Chapter Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned that *Services* bring stable and reliable networking
    to apps deployed on Kubernetes. They also perform load-balancing and allow us
    to expose elements of our application to the outside world (outside of the Kubernetes
    cluster).
  prefs: []
  type: TYPE_NORMAL
- en: Services are first-class objects in the Kubernetes API and can be defined in
    the standard YAML manifest files. They use label selectors to dynamically match
    Pods, and the best way to work with them is declaratively.
  prefs: []
  type: TYPE_NORMAL
