- en: Chapter 5. Customizing the Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a default system, we get certain settings that are preconfigured. As time
    progresses, we often feel the need to modify some of the default settings provided.
    Similar needs arise when we are working in a shell to get things done, for example,
    modifying the environment according to the needs of the application. Some of the
    features are so irresistible that we may need them every time, for example, the
    editor of our choice used by an application. While working on an important task,
    it may happen that we forget a command that we used a few days ago. In such cases,
    we try to recall that command as soon as possible to get work done. If we can't
    remember, we consume time and effort searching on the Internet or in text books
    for the exact command and syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how, by adding or changing the existing environment
    variables, we can modify the environment as per our application needs. We will
    also see how a user can modify the `.bashrc`, `.bash_profile`, and `.bash_logout`
    files to make the setting changes available permanently. We will see how we can
    search and modify the history of previously executed commands. We will also see
    how to run multiple tasks from a single shell and manage them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the default environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the shell environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using bash startup files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing your history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing the default environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up a proper environment is very important for running a process. An
    environment consists of environment variables that may or may not have a default
    value set. The required environment is set by modifying the existing environment
    variables or creating new environment variables. Environment variables are exported
    variables that are available to the current process and also its child processes.
    In [Chapter 1](ch01.html "Chapter 1. The Beginning of the Scripting Journey"),
    *The Beginning of the Scripting Journey*, we learned about some of the builtin
    shell variables that can be used in our application as environment variables to
    set the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing a shell environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To view the current environment in the shell, we can use the `printenv` or `env`
    commands. Environment variables may have no value, a single value, or a multiple
    value set. If multiple values exist, each value is separated by a colon (:).
  prefs: []
  type: TYPE_NORMAL
- en: printenv
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use `printenv` to print the value associated with a given environment
    variable. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ printenv [VARIABLE]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following as examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If no `VARIABLE` is specified, `printenv` prints all environment variables
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: env
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also use the `env` command to view environment variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This displays all environment variables defined for a given shell.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To view value(s) of a specific environment variable, the `echo` command can
    also be used followed by an environment variable name prefixed with a dollar symbol
    (`$`). For example, `echo $SHELL`.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between shell and environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both shell and environment variables are variables that are accessible and
    set for a given shell that may be used by an application or a command running
    in that shell. However, there are a few differences between them, which are set
    out in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Shell variables | Environment variables |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Both local and exported variables are shell variables | Exported shell variables
    are environment variables |'
  prefs: []
  type: TYPE_TB
- en: '| The `set builtin` command is used to see the name and corresponding value
    of a shell variable | The `env` or `printenv` command is used to see the name
    and corresponding value of an environment variable |'
  prefs: []
  type: TYPE_TB
- en: '| Local shell variables are not available for use by their child shells | Child
    shells inherit all environment variables present in the parent shell |'
  prefs: []
  type: TYPE_TB
- en: '| A shell variable is created by specifying a variable name on the left and
    value(s) separated by a colon (:) on the right-hand side of an equal operator
    (=) | An environment variable can be created by prefixing an export shell built
    - in command to the existing shell variable, or while creating a new shell variable
    |'
  prefs: []
  type: TYPE_TB
- en: Modifying a shell environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a new shell is launched, it has the initial environment set that will be
    used by any application or command that gets executed in a given shell. We now
    know that the `env` or `setenv` shell builtin command can be used to view which
    environment variables are set for this shell. The shell also provides the capability
    to modify the current environment. We can also modify the current bash environment
    by creating, modifying, or deleting environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Creating environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a new environment variable in a shell, the `export` shell builtin
    command is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we will create a new environment variable `ENV_VAR1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A new environment variable with the name `ENV_VAR1` is created. To view a new
    environment variable, we can call the `printenv` or `env` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `echo` command to print the value of an environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A local shell variable can also be exported further as an environment variable.
    As an example, we will create the `ENV_VAR2` and `LOCAL_VAR1` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'No environment variable is found with the name `ENV_VAR2`. This is because
    while creating `ENV_VAR2`, it wasn''t exported. Therefore, it will be created
    as a local variable of a shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to make the `ENV_VAR2` shell variable as an environment variable, we can
    use the export command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The variable `LOCAL_VAR1` is not an environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the important features of environment variables is that it is available
    to all of its child shells. We can see this in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the environment variables from a parent shell got inherited
    by a child shell—for example, `ENV_VAR1`, `ENV_VAR2`—while the local variable,
    such as `LOCAL_VAR1`, remains available only to a shell in which the variable
    was created.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shell provides flexibility for modifying any existing environment variable.
    For example, consider the `HOME` environment variable. By default, the `HOME`
    environment variable contains the path of the current logged in user''s home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will modify the `HOME` environment variable value to `/tmp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also append a value to an environment variable. To do this, make sure
    the new value is separated with a colon (`:`). For example, consider the `PATH`
    environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to add a new path to the `PATH` variable—for example, `/home/foo/projects/bin`—so
    that, while looking for a program or command, the shell can search the specified
    path too. To append a path to the `PATH` environment variable, use a colon (:)
    followed with a new path name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the new path has been appended to the existing values of the
    `PATH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We can also append multiple values to an environment variable; for that, each
    value should be separated by a colon (`:`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we will add two more application paths to the `PATH` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The two new paths, `/home/foo/project1/bin` and `/home/foo/project2/bin`, have
    been added to the `PATH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can delete or reset a value of an environment variable using the `unset`
    shell builtin command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we will create an environment variable called `ENV1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The environment variable `ENV1` gets deleted by the `unset` command. Now, to
    reset an environment variable, assign it a blank value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using bash startup files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, to perform a task or set anything for a given shell, we had to execute
    the needed commands in a shell. One of the main limitations to this approach is
    that the same configuration won't be available in a new shell. In a lot of cases,
    a user may want that whenever he or she launches a new shell, whereas instead
    a new customized configuration on top of the default configuration is available
    for use. For customizing bash, three files are available in a user's home directory
    that get executed by default whenever a user launches a new bash. These files
    are `bashrc`, `.bash_profile`, and `.bash_logout`.
  prefs: []
  type: TYPE_NORMAL
- en: .bashrc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a graphical system, mostly a non-login shell is used by a user. To run a
    non-login shell, we don't need the login credentials. Starting a shell in a graphical
    system provides a non-login shell. When a bash is invoked in non-login mode, the
    `~/.bashrc` file is invoked and the configuration available in it is executed
    and applied in any bash shell being launched. Settings that are needed in both
    the login and non-login shell are kept in the `~/.bashrc` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on a Fedora 22 system default, the `~/.bashrc` file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Any addition done in `~/.bashrc` will be reflected only to the current user's
    bash shell. We can see that the `.bashrc` file also checks whether the `etc/bashrc`
    file is available. If available, that gets executed too. The `/etc/bashrc` file
    contains configuration applied to a bash shell for all users—that is, systemwide.
    Sysadmin can modify the `/etc/bashrc` file if any configuration needs to be applied
    to all users' bash shells.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file `/etc/bashrc` also looks into the script files available in `/etc/profile.d`,
    which can be confirmed by the following code snippet taken from the `/etc/bashrc`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows a modified `.bashrc` file. Name this file `custom_bashrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `LD_LIBRARY_PATH` environment variable is used to give the runtime shared
    library loader (`ld.so`) an extra set of directories to look for when searching
    for shared libraries. You can learn more about the shared library at [http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html](http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a backup of your original `~/.bashrc` file before modifying it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, copy the `custom_bashrc` file to `~/.bashrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply modified settings, open a new bash shell. To apply a new `.bashrc`
    in the same bash shell, you can source into a new `~/.bashrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check whether the new settings are available or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `alias` command displays aliases that we added in `.bashrc`—that is, `rm`,
    `cp`, `df`, and `ll`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, call the `current_directory_size()`function that we added in `.bashrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to move back the original `.bashrc` file whose backup we created
    at the beginning of this example, and source into it to get the settings reflected
    in the current shell session. This is required if you don''t want any of the configuration
    changes that we did while playing out the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When bash is invoked as a non-login shell, it loads the configuration available
    in the `~/.bashrc`, `/etc/bashrc`, and `/etc/profile.d/*.sh` files.
  prefs: []
  type: TYPE_NORMAL
- en: .bash_profile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a non-graphical system, after a successful login, the user gets a shell.
    Such a shell is called a login shell. When a bash is invoked as a login shell,
    first the `/etc/profile` file gets executed; this runs the script available in
    `/etc/profile.d/` as well. The following code snippet taken from `/etc/profile`
    also mentions this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'These are global settings applied to any user''s login shell. Furthermore,
    `~/.bash_profile` gets executed for a login shell. On a Fedora 22 system, the
    default content of the `~/.bash_profile` file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: From the contents, we can see that it looks for the `.bashrc` file in a user's
    home directory. If the `.bashrc` file is available in a home directory, it gets
    executed. We also know that the `~/.bashrc` file executes the `/etc/bashrc` file
    as well. Next, we see that `.bash_profile` appends the `PATH` variable with the
    `$HOME/.local/bin` and `$HOME/bin` values. Furthermore, the modified `PATH` variable
    is exported as an environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: A user can modify the `~/.bash_profile` file as per his/her customized configuration
    needs, such as default shell, editor for login shell, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example contains a modified configuration in `.bash_profile`.
    We will use `bash_profile` as its filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Changes are made after the **Added configuration by us** comment. Before we
    apply this new configuration to `~/.bash_profile`, we will first make a backup
    of the original file. This will help us in restoring the original content of the
    `.bash_profile` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A new file `.bash_profile.bak` will be created in the `home` directory. Now,
    we will copy our new configuration to `~/.bash_profile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the reflected changes in a login shell, we can either login as a non-graphical
    interface or just perform `ssh` into the same machine to run a login shell. SSH
    (Secure Shell) is a cryptographic network protocol for initiating text-based shell
    sessions on remote machines in a secure way. In UNIX and Linux-based systems,
    SSH to a local or remote machine can be done using the `ssh` command. The `man`
    page of `ssh` (`man ssh`) shows all the capabilities provided by it. To do a remote
    login on the same machine, we can run `ssh username@localhost`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that all the details added by us are printed in a login shell. Another
    way to quickly test our new `.bash_profile` is by doing source to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To reset changes done in the `~/.bash_profile` file, copy from the `~/.bash_profile.bak`
    file that we created at the beginning of this example and source into it to get
    the changes reflected in the current shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When bash is invoked as a login shell, it loads the configuration available
    in the `/etc/profile`, `/etc/profile.d/*.sh`, `~/.bash_profile`, `.~/.bashrc`,
    and `~/etc/bashrc` files.
  prefs: []
  type: TYPE_NORMAL
- en: .bash_logout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `.bash_logout` file present in a user's home directory gets executed every
    time a login shell exits. This is useful when a user has logged in remotely or
    has a non-graphical interface. A user can add clean-up tasks to be performed before
    he/she logs off from a system. A clean-up task may include removing the temporary
    files created, clearing environment variables, logging off important data, archiving
    or encrypting certain tasks, uploading onto the Web, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing your history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shells provide an interesting feature that allows you to find out the history
    of all commands you have executed previously in a shell. It often happens that
    we forget what command was typed on the previous day to perform a task. We may
    or may not be able to recall the exact syntax, but it is very convenient that
    we can refer to the history saved by the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Shell variables controlling the history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are shell variables that can be altered to change what and how much history
    a user can see. These shell variables are mentioned in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| HISTFILE | Name of file in which by default history will be saved |'
  prefs: []
  type: TYPE_TB
- en: '| HISTFILESIZE | Number of commands to be kept in history file |'
  prefs: []
  type: TYPE_TB
- en: '| HISTSIZE | Number of history to be stored in memory for current session |'
  prefs: []
  type: TYPE_TB
- en: '| HISTCONTROL | A colon-separated list of values controlling how commands are
    saved on the history list |'
  prefs: []
  type: TYPE_TB
- en: 'The value of the `HISTCONTROL` shell variable can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ignorespace | Lines which starts with a blank space, doesn''t save in history
    list |'
  prefs: []
  type: TYPE_TB
- en: '| ignoredups | Don''t save lines which matches in previous saved history list
    |'
  prefs: []
  type: TYPE_TB
- en: '| ignoreboth | Applies both ignorespace and ignoredups |'
  prefs: []
  type: TYPE_TB
- en: '| erasedups | Remove all previous lines from history matching current line
    before saving it in history file |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s see what values these shell variables may contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: From the value obtained, we can see that the default history is saved into the
    `.bash_history` file of a user's `home` directory, with the maximum history command
    lines saved as 1000\. Also, any duplicate history that is already present in the
    previous history line isn't saved.
  prefs: []
  type: TYPE_NORMAL
- en: The history builtin command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shells provide the `history` builtin command so that a user will know the history
    of commands executed up to now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the history without any options, prints all the previously typed commands
    on `stdout`. The sequence of commands are provided oldest to latest as we go from
    top to bottom of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![The history builtin command](img/4335_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table explains the options available with the `history` shell
    built - in command:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| -a | Append the new history lines into history immediately |'
  prefs: []
  type: TYPE_TB
- en: '| -c | Clears history from current list |'
  prefs: []
  type: TYPE_TB
- en: '| -d offset | Deletes history from offset specified |'
  prefs: []
  type: TYPE_TB
- en: '| -r | Append the content of saved history to current list |'
  prefs: []
  type: TYPE_TB
- en: '| -w | Write the current history list to the history file after overwriting
    existing saved history contents |'
  prefs: []
  type: TYPE_TB
- en: 'To see the last five commands executed, we can also perform the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We will find that all the commands executed match a given string from the history
    file. For example, search for commands having the `set` string in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To clear all the history of commands saved and to append the history available
    in the current list, we can do the following (don''t run the following commands
    if you don''t want to loose the saved command history):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the default history behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, shell has some values set for managing the history. In the previous
    section, we saw that a maximum of 1000 lines of history will be stored in the
    history file. If a user spends most of his time working with a shell, he may have
    used 1000 or above commands in one or two days. In such a case, he will not be
    able to look at the history if he has typed a command ten days ago. Depending
    upon the individual use-case, a user can modify the number of lines to be stored
    in the history file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the following command will set the maximum number of lines the history
    file may have to `100000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can change where the history file should be saved. We saw that,
    by default, it is saved in the `.bash_history` file in the `home` directory. We
    can modify the `HISTFILE` shell variable and set it to whatever location we want
    our command history to be saved to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now the executed command history will be saved in the `customized_history_path`
    file in the home directory instead of the `~/.bash_history` file.
  prefs: []
  type: TYPE_NORMAL
- en: To make these changes reflect to all the shells being launched by a user and
    for all sessions, add these modifications to the `~/.bashrc` file.
  prefs: []
  type: TYPE_NORMAL
- en: Handy shortcuts for seeing the history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending upon a user's history size setting, the number of commands available
    in the history may be large. If a user wants to look for a specific command, he
    or she will have to look through the entire history, which can sometimes be troublesome.
    Shells provide some shortcuts to help us find a specific command previously executed.
    Knowledge of these shortcuts can save time in finding previously executed commands
    in the history.
  prefs: []
  type: TYPE_NORMAL
- en: '[Ctrl + r]'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While working in a shell, the [*Ctrl* + *r*] shortcut allows you to search
    for a command in the history. Start typing a command after pressing [*Ctrl* +
    *r*]; the shell shows a complete command that matches the substring of the command
    typed. To move forward to the next match, type [*Ctrl* + *r*] on the keyboard
    again and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We can see that typing `his`, suggested from history `man history` that we previously
    typed.
  prefs: []
  type: TYPE_NORMAL
- en: Up and down arrow key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The up and down arrow keys available on the keyboard can be used to go back
    and forward in the history of commands previously executed by the user. For example,
    to get the previous command, press the up arrow key once. To go back even further,
    press the up arrow key again and so on. Further, to go forward in the history
    use the down arrow key.
  prefs: []
  type: TYPE_NORMAL
- en: '!!'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The shortcut `!!` can be used to reexecute the last command executed in the
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '!(search_string)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This shortcut executes the last command starting with `search_string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '!?(search_string)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This shortcut executes the last command found with the substring `search_string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Task management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an application runs, it is possible that it will run for a long period
    of time or run until the computer shuts down. While running an application in
    a shell, we know that a shell prompt only comes back when running a program in
    the shell completes successfully or terminates due to some error. Unless we get
    a shell prompt back, we can't run another command in the same shell. We can't
    even close that shell because it will close the running process.
  prefs: []
  type: TYPE_NORMAL
- en: Also, to run another application, we will have to open another shell in a new
    terminal and then run it. It can become difficult and tedious to manage if we
    have to run a lot of tasks. Shells provide ways to run a task in the background
    and suspend, kill, or move back in the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: Running tasks in the background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A task can be started as a background in a shell by appending an ampersand (&).
  prefs: []
  type: TYPE_NORMAL
- en: For example, we want to search for a string in the entire filesystem. Depending
    upon the filesystem's size and the number of files, it may take a lot of time.
    We can call the `grep` command to search for a string and save the result in a
    file. A filesystem hierarchy in Linux starts from the root('`/`').
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `grep` searches for a string in the entire filesystem, sends any error
    message to `/dev/null`, and saves the search result into the `out1.txt` file.
    An ampersand (&) at the end sends the entire job to the background, prints PID
    of the started task, and returns back the shell prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can do other work in the same opened shell and perform other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a running task to the background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It often happens that we run a task in a shell normally—that is, as a foreground
    task—but later we want to move it to the background. It is possible to do this
    by first suspending the current task using [*Ctrl* + *z*] and then using `bg`
    to move the task to the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the last text search as an example. We start a search normally as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not see anything happening on the shell and we will just keep waiting
    for a shell prompt to return. Alternatively, we can suspend the running job using
    [Ctrl + z]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to send a suspended task to continue running in the background, use the
    `bg` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Listing background tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find out which tasks are running in the background or suspended in the current
    shell, `jobs` shell built - in is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, index [1] and [2] are job numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The character '`+`' identifies the job that would be used as a default by the
    `fg` or `bg` command, and the character '`-`' identifies the job that would become
    a default if the current default job exits or terminates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another task and suspend it using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To view PID of all background and suspended tasks, we can use the `–p` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'PID of jobs is in sequence. To view only the tasks running in the background,
    the `-r` option is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To view only the suspended tasks, the `-s` option is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To view a particular index job, use an index number with the `jobs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Moving tasks to the foreground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can move a background or suspended task to the foreground using the shell
    built - in command `fg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The character ''`+`'' is mentioned in the job index `3`. This means, running
    the `fg` command will run the third job in the foreground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command suspends the third task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To move a particular job to the foreground, use `fg` with a task index number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Terminating tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also delete a running or suspended task if it''s no longer needed. This
    can be done by using the `disown` shell built - in command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `disown` without any option, deletes a task that has the character ''`+`''
    mentioned with a task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete running tasks, the `-r` option is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove all tasks, the `-a` option is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The output of `jobs` shows nothing because all the suspended and running tasks
    got deleted by the `-a` option.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you now know how to create and modify environment
    variables in a shell. You also know how `.bashrc` and `.bash_profile` help in
    making changes that are available permanently for all sessions of a user. You
    learned how to search the history of commands that we have previously executed
    and also how to run and manage different tasks in a shell by using the `fg` and
    `bg` shell built - in commands.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see what important types of files are available
    on Linux-based systems and what operations can be performed on them to get meaningful
    results.
  prefs: []
  type: TYPE_NORMAL
