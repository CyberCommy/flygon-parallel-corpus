- en: Goroutines - Advanced Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the second chapter of this book that deals with goroutines: the most
    important feature of the Go programming language: as well as channels that greatly
    improve what goroutines can do, and we will continue this from where we stopped
    it in [Chapter 9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)*,* *Goroutines -
    Basic Features*.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, you will learn how to use various types of channels, including buffered
    channels, signal channels, nil channels, and channels of channels! Additionally,
    you will learn how you can utilize shared memory and mutexes with goroutines as
    well as how to time out a program when it is taking too long to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, this chapter will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Buffered channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `select` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nil channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channel of channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timing out a program and avoiding waiting forever for it to end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared memory and goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `sync.Mutex` in order to guard shared data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `sync.RWMutex` in order to protect your shared data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the code of `dWC.go` from [Chapter 9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml),
    *Goroutines - Basic Features*, in order to add support for buffered channels and
    mutexes to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we said that the kernel scheduler is responsible for
    the order your goroutines will be executed in, which is not completely accurate.
    The kernel scheduler is responsible for the execution of the threads your programs
    have. The Go runtime has its own scheduler that is responsible for the execution
    of the goroutines using a technique known as **m:n scheduling**, where *m* goroutines
    are executed using *n* operating system threads using multiplexing. As the Go
    scheduler has to deal with the goroutines of a single program, its operation is
    much cheaper and faster than the operation of the kernel scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: The sync Go package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, we will use functions and data types from the `sync` package in
    this chapter. Particularly, you will learn about the usefulness of the `sync.Mutex`
    and `sync.RWMutex` types and the functions supporting them.
  prefs: []
  type: TYPE_NORMAL
- en: The select keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `select` statement in Go is like a `switch` statement for channels and allows
    a goroutine to wait on multiple communication operations. Therefore, the main
    advantage you get from using the `select` keyword is that the same function can
    deal with multiple channels using a single `select` statement! Additionally, you
    can have nonblocking operations on channels.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the program that will be used for illustrating the `select` keyword
    will be `useSelect.go` and will be presented in five parts. The `useSelect.go`
    program allows you to generate the number of random you want, which is defined
    in the first command-line argument, up to a certain limit, which is the second
    command-line argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `useSelect.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `useSelect.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see how the `select` keyword allows you to listen to and coordinate
    two channels (`randomNumberChannel` and `finishedChannel`) at the same time. The
    `select` statement waits for a channel to unblock and then executes on that.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop of the `createNumber()` function will not end on this own. Therefore,
    `createNumber()` will keep generating random numbers for as long as the `randomNumberChannel`
    branch of the `select` statement is used. The `createNumber()` function will exit
    when it gets the Boolean value `true` in the `finishedChannel` channel.
  prefs: []
  type: TYPE_NORMAL
- en: A better name for the `finishedChannel` channel would have been `done` or even
    `noMoreData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing special here: you just read the command-line arguments before
    starting the desired goroutine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of `useSelect.go` is where you will start the desired goroutine
    and create a `for` loop in order to generate the desired number of random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, you also send a message to `finishedChannel` and check whether the `randomNumberChannel`
    channel is `open` or `closed` after sending the message to `finishedChannel`.
    As you sent `false` to `finishedChannel`, the `finishedChannel` channel will remain
    `open`. Note that a message sent to a `closed` channel panics, whereas a message
    received from a `closed` channel returns the zero value immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Note that once you close a channel, you cannot write to this channel. However,
    you can still read from that channel!
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `useSelect.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, you sent the `true` value to `finishedChannel`, so your channels will
    close and the `createNumber()` goroutine will exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `useSelect.go` will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you will see in the `bufChannels.go` program that explains buffered channels,
    the `select` statement can also save you from overflowing a buffered channel.
  prefs: []
  type: TYPE_NORMAL
- en: Signal channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **signal channel** is a channel that is used just for signaling. Signal channels
    will be illustrated using the `signalChannel.go` program with a rather unusual
    example that will be presented in five parts. The program executes four goroutines:
    when the first one is finished, it sends a signal to a signal channel by closing
    it, which will unblock the second goroutine. When the second goroutine finishes
    its job, it closes another channel that unblocks the remaining two goroutines.
    Note that signal channels are not the same as channels that carry the `os.Signal`
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `A()` function is blocked by the channel defined in the `a` parameter. This
    means that until this channel is closed, the `A()` function cannot continue its
    execution. The last statement of the function closes the channel that is stored
    in the `b` variable, which will be used for unblocking other goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the program is the implementation of the `B()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the `B()` function is blocked by the channel stored in the `b` argument,
    which means that until the `b` channel is closed, the `B()` function will be waiting
    in its first statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `signalChannel.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the `C()` function is blocked by the channel stored in its `a` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Defining a signal channel as an empty `struct` with no fields is a very common
    practice because empty structures take no memory space. In such a case, you could
    have used a `bool` channel instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `signalChannel.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, you start four goroutines. However, until you close the `a` channel, all
    of them will be blocked! Additionally, `A()` will finish first and unblock `B()`
    that will unblock the two `C()` goroutines. So, this technique allows you to define
    the order of execution of your goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you execute `signalChannel.go`, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the goroutines are being executed in the desired order despite
    the `A()` function taking more time to execute than the others due to the `time.Sleep()`
    function call.
  prefs: []
  type: TYPE_NORMAL
- en: Buffered channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Buffered channels** allow the Go scheduler to put jobs in the queue quickly
    in order to be able to serve more requests. Moreover, you can use buffered channels
    as **semaphores** in order to limit throughput. The technique works as follows:
    incoming requests are forwarded to a channel, which processes one request at a
    time. When the channel is done, it sends a message to the original caller saying
    that it is ready to process a new request. So, the capacity of the buffer of the
    channel restricts the number of simultaneous requests it can keep and process:
    this can be easily implemented using a `for` loop with a call to `time.Sleep()`
    at its end.'
  prefs: []
  type: TYPE_NORMAL
- en: Buffered channels will be illustrated in `bufChannels.go`, which will be presented
    in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preamble proves that you do not need any extra packages for supporting buffered
    channels in your Go program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the program has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, you create a new channel named `numbers` with `5` places, which is denoted
    by the last parameter of the `make` statement. This means that you can write five
    integers to that channel without having to read any one of them in order to make
    space for the others. However, you cannot put six integers on a channel with five
    integer places!
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `bufChannels.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, you try to put `10` integers to a buffered channel with `5` places. However,
    the use of the `select` statement allows you to know whether you have enough space
    for storing all the integers or not and act accordingly!
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `bufChannels.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, you also use a `select` statement while trying to read 20 integers from
    a channel. However, as soon as reading from the channel fails, the `for` loop
    exits using a `break` statement. This happens because when there is nothing left
    to read from the `numbers` channel, the `num := <-numbers` statement will block,
    which makes the `case` statement to go to the `default` branch.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the code, there is no goroutine in `bufChannels.go`, which
    means that buffered channels can work on their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `bufChannels.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: About timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you imagine waiting forever for something to perform an action? Neither
    can I! So, in this section you will learn how to implement **timeouts** in Go
    with the help of the `select` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program with the sample code will be named `timeOuts.go` and will be presented
    in four parts; the first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `timeOuts.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `time.Sleep()` statement in the goroutine is used for simulating the time
    it will take for the goroutine to do its real job.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `timeOuts.go` has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This time the use of `time.After()` is required for declaring the time you want
    to wait before timing out. The wonderful thing here is that if the time of `time.After()`
    expires without the `select` statement having received any data from the `c1`
    channel, the case branch of `time.After()` will get executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program will have the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, you see an operation that does not time out because it
    is completed within the desired time, which means that the first branch of the
    `select` block will get executed instead of the second one that signifies the
    timeout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of `timeOuts.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: An alternative way to implement timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technique of this subsection will let you not wait for any stubborn goroutines
    to finish their jobs. Therefore, this subsection will show you how to time out
    goroutines with the help of the `timeoutWait.go` program that will be presented
    in four parts. Despite the code differences between `timeoutWait.go` and `timeOuts.go`,
    the general idea is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `timeoutWait.go` contains the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `timeoutWait.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, you declare a function that does the entire job. The core of the function
    is the `select` block that works the same way as in `timeOuts.go`. The anonymous
    function of `timeout()` will successfully end when the `w.Wait()` statement returns,
    which will happen when the appropriate number of `sync.Done()` calls have been
    executed, which means that all goroutines will be finished. In this case, the
    first case of the `select` statement will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `temp` channel is needed in the `select` block and nowhere else.
    Additionally, the element type of the `temp` channel could have been anything,
    including `bool`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `timeOuts.go` has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The last fragment of the program has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After the anticipated `w.Done()` call has been executed, the `timeout()` function
    will return `true`, which will prevent the timeout from happening.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this subsection, `timeoutWait.go` actually
    prevents your program from having to wait indefinitely for one or more goroutines
    to end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `timeoutWait.go` will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Channels of channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will talk about creating and using a channel of channels.
    Two possible reasons to use such a channel are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For acknowledging that an operation finished its job
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For creating many worker processes that will be controlled by the same channel
    variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the naive program that will be developed in this section is `cOfC.go`
    and will be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `f1()` function returns integer numbers that belong to the `numbers` variable.
    When it is about to end, it also returns the number of integers it has sent back
    to the `caller` function using the `c <- total` statement.
  prefs: []
  type: TYPE_NORMAL
- en: As you cannot use a channel of channels directly, you should first read from
    it (`cc <- c`) and get a channel that you can actually use. The handy thing here
    is that although you can close the `c` channel, the channel of channels (`cc`)
    will be still up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `cOfC.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this Go code, you can see that you can declare a channel of channels using
    the `chan` keyword two consecutive times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `cOfC.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, you limit the number of integers that will be created by closing the `f`
    channel when you have the number of integers you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `cOfC.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A channel of channels is an advanced Go feature that you probably will not need
    to use in your system software. However, it is good to know that it exists.
  prefs: []
  type: TYPE_NORMAL
- en: Nil channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will talk about **nil channels**, which are a special sort of channel
    that will always block. The name of the program will be `nilChannel.go` and will
    be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program contains the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The second portion contains the implementation of the `addIntegers()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `addIntegers()` function stops after the time defined in the `time.NewTimer()`
    function passes and will go to the relevant branch of the `case` statement. There,
    it makes `c` a nil channel, which means that the channel will stop receiving new
    data and that the function will just wait there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `nilChannel.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `sendIntegers()` function keeps generating random numbers and sends
    them to the `c` channel as long as the `c` channel is open. However, here you
    also have a goroutine that is never cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `nilChannel.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Shared memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shared memory is the traditional way that threads use for communicating with
    each other. Go comes with built-in synchronization features that allow a single
    goroutine to own a shared piece of data. This means that other goroutines must
    send messages to this single goroutine that owns the shared data, which prevents
    the corruption of the data! Such a goroutine is called a **monitor goroutine**.
    In Go terminology, this is s*haring by communicating instead of communicating
    by sharing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique will be illustrated in the `sharedMem.go` program, which will
    be presented in five parts. The first part of `sharedMem.go` has the following
    Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `ReadValue()` function is used for reading the shared variable, whereas
    the `SetValue()` function is used for setting the value of the shared variable.
    Also, the two channels used in the program need to be global variables in order
    to avoid passing them as arguments to all the functions of the program. Note that
    these global variables are usually wrapped up in a Go library or a `struct` with
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `sharedMem.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The logic of `sharedMem.go` can be found in the implementation of the `monitor()`
    function. When you have a read request, the `ReadValue()` function attempts to
    read from the `readValue` channel. Then, the `monitor()` function returns the
    current value that is kept in the `value` parameter. Similarly, when you want
    to change the stored value, you call `SetValue()`, which writes to the `writeValue`
    channel that is also handled by the `select` statement. Once again, the `select`
    block plays a key role because it orchestrates the operations of the `monitor()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth portion of the program has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `sharedMem.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If you want to share more values, you can define a new structure that will hold
    the desired variables with the data types you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Using sync.Mutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mutex** is an abbreviation for **mutual exclusion**; the `Mutex` variables
    are mainly used for thread synchronization and for protecting shared data when
    multiple writes can occur at the same time. A mutex works like a buffered channel
    of capacity 1 that allows at most one goroutine to access a shared variable at
    a time. This means that there is no way for two or more goroutines to try to update
    that variable simultaneously. Although this is a perfectly valid technique, the
    general Go community prefers to use the `monitor` goroutine technique presented
    in the previous section.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to use `sync.Mutex`, you will have to declare a `sync.Mutex` variable
    first. You can lock that variable using the `Lock` method and release it using
    the `Unlock` method. The `sync.Lock()` method gives you exclusive access over
    the shared variable for a region of code that finishes when you call the `Unlock()`
    method and is called a **critical section**.
  prefs: []
  type: TYPE_NORMAL
- en: Each critical section of a program cannot be executed without locking it first
    using `sync.Lock()`. However, if a lock has already been taken, everybody should
    wait for its release first. Although multiple functions might wait to get a lock,
    only one of them will get it when it will be released.
  prefs: []
  type: TYPE_NORMAL
- en: You should try to make critical sections as small as possible; in other words,
    do not delay releasing a lock because other goroutines might want to use it. Additionally,
    forgetting to unlock `Mutex` will most likely result in a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the Go program with the code for illustrating the use of `sync.Mutex`
    will be `mutexSimple.go` and will be presented in five chunks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `mutexSimple.go` contains the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that a critical section is not always obvious and you should be very careful
    when specifying it. Also note that a critical section cannot be embedded in another
    critical section when both critical sections use the same `Mutex` variable! Putting
    it simply, avoid, at almost all costs, spreading mutexes across functions because
    that makes really hard to see whether you are embedding or not!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `addDot()` adds a dot character at the end of the `sharedVariable` string.
    However, as the string should be altered simultaneously by multiple goroutines,
    you use a `sync.Mutex` variable to protect it. As the critical section contains
    just one command, the waiting period for getting access to the mutex will be fairly
    small, if not instantaneous. However, in a real-world situation, the waiting period
    might be much longer, especially on software such as database servers where many
    things happen simultaneously by thousands of processes: you can simulate that
    by adding a call to `time.Sleep()` in the critical section.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is the responsibility of the developer to associate a mutex with
    one or more shared variables!
  prefs: []
  type: TYPE_NORMAL
- en: 'The third code segment of `mutexSimple.go` is the implementation of another
    function that uses the mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Although locking the shared variable while reading it is not absolutely necessary,
    this kind of locking prevents the shared variable from changing while you are
    reading it. This might look like a small issue here but imagine reading the balance
    of your bank account instead!
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part is where you define the number of goroutines that you will
    start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The final part of `mutexSimple.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you start the desired number of goroutines. Each goroutine calls the
    `addDot()` function that accesses the shared variable: and you wait for them to
    finish before reading the value of the shared variable using the `read()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output you will get from executing `mutexSimple.go` will be similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Using sync.RWMutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go offers another type of mutex, called `sync.RWMutex`, that allows multiple
    readers to hold the lock but only a single writer - `sync.RWMutex` is an extension
    of `sync.Mutex` that adds two methods named `sync.RLock` and `sync.RUnlock`, which
    are used for locking and unlocking for reading purposes. Locking and unlocking
    a `sync.RWMutex` for exclusive writing should be done with `Lock()` and `Unlock()`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that either one writer can hold the lock or multiple readers: not
    both! You will most likely use such a mutex when most of the goroutines want to
    read a variable and you do not want goroutines to wait in order to get an exclusive
    lock.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to demystify `sync.RWMutex` a little, you should discover that the
    `sync.RWMutex` type is a Go structure currently defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So, there is nothing to be afraid of here! Now, it is time to see a Go program
    that uses `sync.RWMutex`. The program will be named `mutexRW.go` and will be presented
    in five parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `mutexRW.go` contains with the expected preamble as well
    as the definition of a global variable and a new `struct` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `secret` structure embeds `sync.RWMutex` and therefore it can call all the
    methods of `sync.RWMutex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `mutexRW.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This function makes changes to one of its arguments, which means that it requires
    an exclusive lock, hence the use of the `Lock()` and `Unlock()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the sample code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the definition of two functions that use an `sync.RWMutex`
    for reading. This means that multiple instances of them can get the `sync.RWMutex`
    lock.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth portion of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, you start five goroutines in order to make things more interesting and
    random.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `mutexRW.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Although shared memory and the use of a mutex are still a valid approach to
    concurrent programming, using goroutines and channels is a more modern way that
    follows the Go philosophy. Therefore, if you can solve a problem using channels
    and pipelines, you should prefer that way instead of using shared variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `mutexRW.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If the implementation of `Change()` was using a `RLock()` call as well as a
    `RUnlock()` call, which would have been totally wrong, then the output of the
    program would have been the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Put simply, you should be fully aware of the locking mechanism you are using
    and the way it works. In this case, it is the timing that is deciding what `Counts()`
    will return: the timing depends on the `time.Sleep()` call of the `Change()` function
    that emulates the processing that will happen in a real function. The problem
    is that the use of `RLock()` and `RUnlock()` in `Change()` allows multiple goroutines
    to read the shared variable and therefore get the wrong output from the `Counts()`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: The dWC.go utility revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will change the implementation of the `dWC.go` utility developed
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The first version of the program will use a buffered channel whereas the second
    version of the program will use shared memory for keeping the counts for each
    file you process.
  prefs: []
  type: TYPE_NORMAL
- en: Using a buffered channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of this implementation will be `WCbuffered.go` and will be presented
    in five parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `File` structure will keep the counts for each input file. The second chunk
    of `WCbuffered.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `monitor()` function collects all the information and prints it. The `for`
    loop inside `monitor()` makes sure that it will collect the right amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program contains the implementation of the `count()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When the `count()` function is done, it sends the information to the buffered
    channel, so there is nothing special here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth portion of `WCbuffered.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, you create a buffered channel named `values` with as many places as the
    number of files you will process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last portion of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Using shared memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The good thing with shared memory and mutexes is that, in theory, they usually
    take a very small amount of the code, which means that the rest of the code can
    work concurrently without any other delays. However, only after you have implemented
    something can you see what really happens!
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of this implementation will be `WCshared.go` and will be presented
    in five parts: the first part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `values` slice will be the shared variable of the program whereas the name
    of the mutex variable will be `aM`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second chunk of `WCshared.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: So, just before the `count()` function exits, it adds an element to the values
    slice using a critical section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `WCshared.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, you just deal with the command-line arguments of the utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of `WCshared.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here, you just start the desired number of goroutines and wait for them to finish
    their jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last code slice of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'When all goroutines are done, it is time to process the contents of the shared
    variable, calculate totals, and print the desired output. Note that in this case,
    there is no shared variable of any kind and therefore there is no need for a mutex:
    you just wait to gather all results and print them.'
  prefs: []
  type: TYPE_NORMAL
- en: More benchmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will measure the performance of `WCbuffered.go` and `WCshared.go`
    using the handy `time(1)` utility. However, this time, instead of presenting a
    graph, I will give you the actual output of the `time(1)` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, both utilities performed equally well, or equally badly if you
    prefer! However, apart from the speed of a program, what also matters is the clarity
    of its design and how easy it is to make code changes to it! Additionally, the
    presented way also times the compile times of both utilities, which might make
    the results less accurate.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that both programs can easily generate totals is that they both have
    a control point. For the `WCshared.go` utility, the control point is the shared
    variable, whereas for `WCbuffered.go`, the control point is the buffered channel
    that collects the desired information inside the `monitor()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting race conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you use the `-race` flag when running or building a Go program, you will
    turn on the Go **race detector**, which makes the compiler create a modified version
    of the typical executable file. This modified version can record the accesses
    to shared variables as well as all synchronization events that take place, including
    calls to `sync.Mutex`, `sync.WaitGroup`, and so on. After doing some analysis
    of the events, the race detector prints a report that can help you identify potential
    problems so that you can correct them.
  prefs: []
  type: TYPE_NORMAL
- en: In order to showcase the operation of the race detector, we will use the code
    of the `rd.go` program, which will be presented in four parts. For this particular
    program, the **data race** will happen because two or more goroutines access the
    same variable concurrently and at least one of them changes the value of the variable
    in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `main()` program is also a goroutine in Go!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Nothing special here, so if there is a problem with the program, it is not in
    the preamble.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `rd.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Once again, there is no problem in this particular code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third segment of `rd.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This code is very suspicious because you try to print the value of a variable
    that keeps changing all the time because of the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `rd.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special in the last chunk of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling the Go race detector for `rd.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: So, the race detector found two data races. The first one happens when number
    `1` was not printed at all and the second when number `4` was printed two times.
    Additionally, number `0` was not printed despite being the initial value of `i`.
    Last, you should not get number `10` in the output but you did get it because
    the last value of `i` is indeed `10`. Note that the `main.main.func1()` notation
    found in the preceding output means that Go talks about an anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, what the previous two messages tell you is that there is something
    wrong with the `i` variable because it keeps changing while the goroutines of
    the program try to read it. Additionally, you cannot deterministically tell what
    will happen first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the same program without the race detector will generate the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with `rd.go` can be found in the anonymous function. As the anonymous
    function takes no arguments, it uses the current value of `i`, which cannot be
    determined with any certainty as it depends on the operating system and the Go
    scheduler: this is where the race situation happens! So, have in mind that one
    of the easiest places to have a race condition is inside a goroutine spawned from
    an anonymous function! As a result, if you have to solve such as situation, start
    by converting the anonymous function into regular functions with defined arguments!'
  prefs: []
  type: TYPE_NORMAL
- en: Programs that use the race detector are slower and need more RAM than the same
    programs without the race detector. Last, if the race detector has nothing to
    report, it will generate no output.
  prefs: []
  type: TYPE_NORMAL
- en: About GOMAXPROCS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GOMAXPROCS` environment variable (and Go function) allows you to limit
    the number of operating system threads that can execute user-level Go code simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Go version 1.5, the default value of `GOMAXPROCS` should be the
    number of cores available on your Unix system.
  prefs: []
  type: TYPE_NORMAL
- en: Although using a `GOMAXPROCS` value that is smaller than the number of the cores
    a Unix machine has might affect the performance of a program, specifying a `GOMAXPROCS`
    value that is bigger than the number of the available cores will not make your
    program run faster!
  prefs: []
  type: TYPE_NORMAL
- en: The code of `goMaxProcs.go` allows you to determine the value of the `GOMAXPROCS`
    - it will be presented in two parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `goMaxProcs.go` on an Intel i7 machine with hyper threading support
    and the latest Go version gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you execute `goMaxProcs.go` on a Debian Linux machine that runs
    an older Go version and has an older processor, it will generate the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The way to change the value of `GOMAXPROCS` on the fly is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'However, putting a value bigger than `256` will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, have in mind that if you are running a concurrent program such as `dWC.go`
    using a single core, the concurrent version of the program might not be faster
    than the version of the program without goroutines! In some situations, this happens
    because the use of goroutines as well as the various calls to the `sync.Add`,
    `sync.Wait`, and `sync.Done` functions slows down the performance of a program.
    This can be verified by the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read carefully the documentation page of the `sync` package that can be found
    at [https://golang.org/pkg/sync/](https://golang.org/pkg/sync/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to implement `dWC.go` using a different shared memory technique than the
    one used in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a `struct` data type that holds your account balance and make functions
    that read the amount of money you have and make changes to the money. Create an
    implementation that uses `sync.RWMutex` and another one that uses `sync.Mutex`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would happen to `mutexRW.go` if you used `Lock()` and `Unlock()` everywhere
    instead of `RLock()` and `RUnlock()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to implement `traverse.go` from [Chapter 5](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml)*,*
    *Files and Directories* using goroutines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to create an implementation of `improvedFind.go` from [Chapter 5](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml)*,*
    *Files and Directories* using goroutines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter talked about some advanced Go features related to goroutines, channels,
    and concurrent programming. However, the moral of this chapter is that channels
    can do many things and can be used in many situations, which means that the developer
    must be able to choose the appropriate technique to implement a task based on
    their experience.
  prefs: []
  type: TYPE_NORMAL
- en: The subject of the next chapter will be web development in Go and it will contain
    very interesting material, including sending and receiving JSON data, developing
    web servers and web clients, as well as talking to a MongoDB database from your
    Go code.
  prefs: []
  type: TYPE_NORMAL
