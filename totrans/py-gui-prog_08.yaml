- en: Improving the Look with Styles and Themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While programs can be perfectly functional with plain text in shades of black,
    white, and gray, the subtle use of colors, fonts, and images can enhance the visual
    appeal and usability of even the most utilitarian applications. Your data entry
    application is no exception. Your boss and your users have brought several issues
    to your attention, which seem to require the use of Tkinter's styling capabilities.
    Your boss has informed you that corporate HQ requires all in-house software to
    prominently display the company logo, while the data entry staff have mentioned
    a variety of issues with the readability and overall look of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to learn about some features of Tkinter that
    will help us to solve these issues:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn how to add images to our Tkinter GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll learn how to adjust the fonts and colors in our Tkinter widgets, both
    directly and with tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll learn how to adjust the look of Ttk widgets using styles and themes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with images in Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first requirement we're going to handle is adding the company logo. As a
    result of corporate policy, your application is supposed to have the company logo
    embedded in it, and you've been asked to make your application comply if possible.
  prefs: []
  type: TYPE_NORMAL
- en: To add this image to our application, you'll need to learn about Tkinter's `PhotoImage`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter PhotoImage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several Tkinter widgets, including `Label` and `Button`, can take an `image`
    argument, which allows them to display an image. We can't simply put a path to
    an image file in those cases; instead, we have to create a `PhotoImage` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making a `PhotoImage` object is fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`PhotoImage` is typically called with the keyword argument `file`, which is
    pointed to a file path. Alternatively, you can use the `data` argument to point
    to a `bytes` object containing image data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `PhotoImage` can be used wherever an `image` argument is accepted, such as
    a `Label`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It's critical to note that your application must retain a reference to the `PhotoImage`
    object that will stay in scope for as long as the image is shown; otherwise, the
    image will not appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you run this example, you'll notice that no image gets displayed. That's
    because the `smile` variable is destroyed as soon as `__init__()` exits; with
    no reference to the `PhotoImage` object, the image vanishes, even though we've
    packed it into the layout. To fix this, you would need to store the `image` object
    in an instance variable such as `self.smile`, which will continue to exist after
    the method returns.
  prefs: []
  type: TYPE_NORMAL
- en: Image support in Tkinter is limited to GIF, PGM, PPM, and (as of version 8.6)
    PNG files. To use other file formats, such as JPEG or BMP, you'll need to use
    an image manipulation library such as Pillow to convert them into a format that
    Tkinter understands.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Python 3 for macOS ships with Tkinter 8.5\. To use PNG
    on macOS, you'll need to upgrade to Tkinter 8.6 or later, or use Pillow. Please
    see [https://www.python.org/download/mac/tcltk/](https://www.python.org/download/mac/tcltk/)
    for more information about Tcl/Tk and macOS. Pillow is not in the Python standard
    library. To install it, follow the instructions at [http://python-pillow.org](http://python-pillow.org).
  prefs: []
  type: TYPE_NORMAL
- en: Adding the company logo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our knowledge of `PhotoImage`, adding the company logo to our program should
    be simple; however, we have to solve the problem of how to determine the image
    file's path. The path can be either absolute or relative to the working directory,
    but we don't know what those will be on another system. Fortunately, there's a
    way to figure it out.
  prefs: []
  type: TYPE_NORMAL
- en: Under the `abq_data_entry` directory, create a new directory called `images`,
    and within it place an appropriately-sized PNG file that we can use in our application
    (the image has an 8x5 aspect ratio, so in this case, we're using `32x20`). To
    get an absolute path to the image, we're going to rely on a built-in variable
    in Python called `__file__`. In any Python script, the `__file__` variable will
    contain the absolute path to the current script file, which we can use to locate
    our image files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, from our `application.py` file, we could find our image using
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first find the directory that contains the `application.py`
    file by calling `path.dirname(__file__)`. This gives us an absolute path to `abq_data_entry`,
    from which we know the relative path to the image. We can join these two paths
    and have an absolute path to the image, no matter where the program is installed
    on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: This approach works fine, but consider that we may want to access images from
    a variety of modules in our application, and having to import `path` and repeat
    this logic in multiple files is less than optimal. A cleaner approach is to treat
    our `images` folder like a Python package and create constants in it that point
    to image paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating an `__init__.py` file inside the `images` folder and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `application.py` module can simply do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Application.__init__()` can then create a `PhotoImage` object using the path
    in  `ABQ_LOGO_32`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After creating the `PhotoImage` object, we display it using a `Label`. If you
    run the application, you should see the logo show up at the top.
  prefs: []
  type: TYPE_NORMAL
- en: Setting our Window icon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also add the logo as our Window icon, which makes more sense than leaving
    the default Tkinter logo. This way, the logo will show up in both the window decorations
    and in the operating system's taskbar.
  prefs: []
  type: TYPE_NORMAL
- en: As a subclass of Tk, our `Application` object has a method called `iconbitmap`
    which should, given a path to an icon file, set the icon appropriately. Unfortunately,
    this method is fairly finicky about the type of file it's given and does not work
    well across platforms. We can work around this using `PhotoImage` and the special
    Tk `call()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `call` method allows us to directly call Tcl/Tk commands, and can be useful
    to access Tk capabilities that Tkinter wraps poorly or not at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates another `PhotoImage` object, referencing a larger version
    of the logo. Next, we execute `self.call()`, passing in the individual tokens
    of the Tcl/Tk command. In this case, we're calling the `wm iconphoto` command.
    `self._w` returns the Tcl/Tk name for our `Application` object; and, last of all,
    we pass in the `PhotoImage` object we created.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you won't need to use `call` often, but if you do, you can find documentation
    about Tcl/Tk commands at: [https://www.tcl.tk/doc/](https://www.tcl.tk/doc/) .
  prefs: []
  type: TYPE_NORMAL
- en: Run your application and notice how the icon has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Styling Tkinter widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tkinter has essentially two styling systems: the old Tkinter widgets system,
    and the newer Ttk system. Since we still need to work with both Tkinter and Ttk
    widgets, we''ll have to look at both systems. Let''s take a look first at the
    older Tkinter system and apply some styling to the Tkinter widgets in our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Widget color properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic Tkinter widgets allow you to change two colors: **foreground**, meaning
    mainly the text and borders, and **background**, meaning the rest of the widget.
    These can be set using the `foreground` and `background` arguments, or their aliases
    `fg` and `bg`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example shows the use of colors on a `Label`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The values for the colors can be color name strings or CSS-style RGB hex strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this code produces the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are over 700 named colors recognized by Tkinter, roughly corresponding
    to those recognized by the X11 display server used on Linux and Unix, or the CSS
    named colors used by web designers. For a complete list, see [https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm](https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Using widget properties on our form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One request you received from the data entry staff is to increase the visual
    separation between the sections on the data entry form. Our `LabelFrame` widgets
    are simple Tkinter widgets (not Ttk), so we can accomplish this fairly simply
    by giving the sections colored backgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'After some thought and discussion, you decide to color-code the sections as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Record information will use `khaki`, suggesting the classic manila folders used
    for paper records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment information will use `lightblue`, symbolic of water and air
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plant information will have a `lightgreen` background, symbolic of plants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Notes` are distinctive enough, so it will remain the same'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open up `views.py` and edit the `LabelFrame` calls in `DataRecordForm.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we've added a bit of padding here as well, to make the color more
    visible around the widgets and to also create more separation in the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should add similar padding around the `Notes` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we add the padding to the `grid` call, so that the entire `LabelInput`
    gets shifted over.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result, at least on Debian Linux, looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6133ca48-cf64-43e2-bcb9-19fa095453eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Hardly a visual masterpiece yet, but we have some separation and color coding
    between form sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Foreground and background are sufficient for simple widgets such as buttons,
    but more complex Tkinter widgets like the `Text` widget or the Ttk `Treeview`
    rely on a system of **tags**. A tag in Tkinter is a named region of a widget's
    content to which color and font settings can be applied. To see how this works,
    let's build a crude, but pretty, Python shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating a `Text` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've used the `fg` and `bg` arguments to set up a green-on-black theme,
    popular with programmers. Rather than have only green text, though, let's configure
    different colors for our prompt and our interpreter output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll define some tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `tag_configure` method allows us to create and configure tags on the `Text`
    widget. We've created one called `'prompt'` for our shell prompt, and another
    called `'output'` for the Python output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `insert` text with a given tag applied, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may remember, the `Text.insert` method takes an index and string as
    its first two arguments. Notice the third argument: this is a tuple of the tags
    with which we want to mark the inserted text. This value must be a tuple, even
    if you''re only using one tag.'
  prefs: []
  type: TYPE_NORMAL
- en: If you add `text.mainloop()` to the end of the code and run it, you'll see that
    we have a black text entry window with a magenta prompt, but if you type your
    text, it will show up in green. So far so good; now, let's make it execute some
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function just before the `mainloop()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When retrieving text from a `Text` widget, we're required to supply start and
    end indices for the text we want to retrieve. Notice that we've used our tag name
    in the index. `prompt.last` tells Tkinter to fetch the text starting after the
    end of the region tagged `prompt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s execute `cmd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If our `cmd` actually contains anything, we'll try to execute it with `eval`,
    then store a string of the response value as `output`. If it throws an exception,
    we'll get our exception as a string and set that as the `output`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll just show our `output`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We insert our `output` text, prepended with a newline and tagged as `output`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll finish off the function by giving the user back a `prompt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We also return the string `break` here to tell Tkinter to ignore the original
    event that triggered the callback. Since we're going to trigger this from a `Return`/`Enter`
    keystroke, we want to ignore that keystroke after we're finished. If we don't,
    the keystroke will be executed after our function returns and the user will be
    on the line under the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to bind our function to the `Return` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that the event for the `Enter`/`Return` key is always `<Return>`, even
    on non-Apple hardware (where the key is more commonly labeled `Enter`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Your application should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/db7df434-b620-4c9e-b45c-b34a34475830.png)'
  prefs: []
  type: TYPE_IMG
- en: While this shell won't be supplanting IDLE any time soon, it does look rather
    nice, don't you think?
  prefs: []
  type: TYPE_NORMAL
- en: Styling our record list with tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although `Treeview` is a Ttk widget, it uses tags to control the styling of
    individual rows. We can use this to answer another of the requests you''ve gotten
    from the data entry staff: they''d like the record list to highlight records updated
    and inserted during the current session.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we'll need to do is have our `Application` object keep track
    of which rows have been updated or inserted during the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Application.__init__()`, we''ll create the following instance variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When a record is saved, we'll need to update one or the other of these lists
    with its row number. We'll do this in `Application.on_save()`, after the record
    is saved, but before we repopulate the record list.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll check for an updated record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Updates have `rownum` which do not have a `None` value, so if this is the case,
    we'll append it to the list. If a record is continually updated, there will be
    duplicates in our list, but that's not really of any consequence in the scale
    at which we're operating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to deal with inserts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Inserted records are a little more troublesome in that we don't have a row number
    readily available to record. We do know that inserts are always appended to the
    end of the file, though, so it should be one less than the number of rows in the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Our inserted and updated records will be kept until the end of the program session
    (when the user exits the program), but we need to manually delete them in the
    case where a user selects a new file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can handle that by clearing the lists in `on_file_select()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, our controller knows about inserted and updated records. Our record list
    does not, however; we need to fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the `RecordList` call in `Application.__init__()` and add the variables
    to its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, we'll need to go back into `views.py` and tell the `RecordList` what to
    do with this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by updating its argument list and saving the lists to instance
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll need to configure tags with appropriate colors. Our data entry staff
    feels that `lightgreen` would be a sensible color for inserted records, and `lightblue`
    for updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code in `__init__()` after the `self.treeview` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did with the `Text` widget earlier, we call `tag_configure` to connect
    background color settings with our tag names. Note that you aren't restricted
    to just one configuration setting here; we could conceivably add `foreground`,
    `font`, or other configuration settings to the same call.
  prefs: []
  type: TYPE_NORMAL
- en: To add the tags to our `TreeView` rows, we'll need to update the `populate`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `for` loop, just before inserting the row, we''ll add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We want `tag` to equal `'inserted'` if the `inserted` list exists and our `rownum`
    is in it; we want it to be `'updated'` if the `updated` list exists and our `rownum`
    is in it. Otherwise, we leave it blank.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our `treeview.insert` call just needs to be amended with this `tag` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Run the application and try inserting and updating some records.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b8fb6912-02db-4fc5-a202-10d600d31c28.png)'
  prefs: []
  type: TYPE_IMG
- en: Tkinter fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three ways of specifying a widget's font in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way is to just use a string format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The string takes the format `Font-family` `size` `styles`, where `styles` can
    be any valid combination of text style keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those words include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bold` for boldface text, or `normal` for normal weight'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`italic` for italized text, or `roman` for regular slant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`underline` for underlined text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`overstrike` for struck-out text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything but the font family is optional, though you need to specify a `size`
    if you want to specify any of the styling keywords. The ordering of style keywords
    doesn't matter, but the weight and slant keywords are mutually exclusive (that
    is, you can't have `bold` `normal` or `italic roman`).
  prefs: []
  type: TYPE_NORMAL
- en: One shortcoming of the string approach is that it cannot handle fonts with spaces
    in the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle these, you can use the tuple format for fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This format is exactly like the string format except that the different components
    are written as items in a tuple. The `size` component can be an integer or a string
    containing digits, which provides some flexibility depending on where the value
    comes from.
  prefs: []
  type: TYPE_NORMAL
- en: This approach works fine for setting up a handful of font changes at launch
    time, but for situations that need to dynamically manipulate font settings, Tkinter
    has a feature called **named fonts.** This approach uses a `Font` class that can
    be assigned to widgets and then dynamically changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Font`, it must be imported from the `tkinter.font` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a custom `Font` object and assign it to widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Font` constructor arguments correlate the keywords used
    in string and tuple font specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this font is assigned, we can dynamically alter aspects of it at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're providing a `Button` that will toggle the `overstrike`
    attribute on and off.
  prefs: []
  type: TYPE_NORMAL
- en: Tk comes with several named fonts already configured; we can create Python `Font`
    objects from them using the `nametofont` function from the `tkinter.font` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'This table shows some of the named fonts included in Tkinter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Font name** | **Defaults to** | **Used for** |'
  prefs: []
  type: TYPE_TB
- en: '| `TkCaptionFont` | System title font | Window and dialog caption bars |'
  prefs: []
  type: TYPE_TB
- en: '| `TkDefaultFont` | System default font | Items not otherwise specified |'
  prefs: []
  type: TYPE_TB
- en: '| `TkFixedFont` | System fixed-width font | Nothing |'
  prefs: []
  type: TYPE_TB
- en: '| `TkHeadingFont` | System heading font | Column headings in lists and tables
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TkIconFont` | System icon font | Icon captions |'
  prefs: []
  type: TYPE_TB
- en: '| `TkMenuFont` | System menu font | Menu labels |'
  prefs: []
  type: TYPE_TB
- en: '| `TkSmallCaptionFont` | System title | Subwindows, tool dialogs |'
  prefs: []
  type: TYPE_TB
- en: '| `TkTextFont` | System input font | Input widgets: Entry, Spinbox, and so
    on |'
  prefs: []
  type: TYPE_TB
- en: '| `TkTooltipFont` | System tooltip font | Tooltips |'
  prefs: []
  type: TYPE_TB
- en: If you're curious as to what fonts Tkinter is using on your operating system,
    you can use the `tkinter.font.names()` function to retrieve a list of them.
  prefs: []
  type: TYPE_NORMAL
- en: To change the overall look of the application, we can override these named fonts
    and the changes will get applied across all widgets that don't otherwise have
    a font set.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `nametofont` function to retrieve an object for
    `TkDefaultFont`, the default named font class for Tkinter applications. After
    retrieving it, we can set its font `family` and `size`, changing those values
    for all widgets using `TkDefaultFont`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Label` then shows the result of this adjustment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/12b670be-7fa5-4774-acb0-5cae16efab46.png)'
  prefs: []
  type: TYPE_IMG
- en: Giving users font options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of our data entry users have complained that the font of the application
    is just a little too small to read easily, but others dislike the idea of you
    increasing it because it makes the application too big for the screen. To accommodate
    all the users, we can add a configuration option that allows them to set a preferred
    font size.
  prefs: []
  type: TYPE_NORMAL
- en: We need to begin by adding a `'font size'` option to our settings model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `models.py` and append the `SettingsModel.variables` dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll add a set of radio buttons to our options menu so that the user
    can set the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `views.py` and let''s start creating a menu just before the options menu
    gets added to the main menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This should look familiar, since we created a nearly identical font size menu
    when learning about the Tkinter `Menu` widget. We're allowing fonts from `6` to
    `16`, which should provide plenty of range for our users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Application` class, let''s create a method that will apply the font
    setting to our application''s fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We include `*args` because `set_font` will be called as a `trace` callback,
    so we need to capture any arguments being sent in, even though we won't use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll get the current `''font size''` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There are several named fonts we're going to need to change, not just `TkDefaultFont`.
    For our application, `TkDefaultFont`, `TkTextFont`, and `TkMenuFont` should be
    sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll just loop through these, retrieving the classes and setting the size
    on each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we need to do is to make sure this callback gets called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after the `load_settings()` call in `Application.__init__()`, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We call `set_font()` once to activate any saved `font size` settings and then
    set a `trace` to run it whenever the value is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and try out the font menu. It should look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8fb2114c-d0ab-4d97-96b0-4523e44ddb24.png)'
  prefs: []
  type: TYPE_IMG
- en: Styling Ttk widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ttk widgets represent a major improvement over standard Tkinter widgets in
    terms of the power and flexibility with which they can be styled. This flexibility
    is what gives Ttk widgets the ability to mimic native UI controls across platforms,
    but it comes at a cost: Ttk styling is confusing, poorly documented, and occasionally
    inconsistent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand Ttk styling, let''s start with some vocabulary, from the most
    basic elements to the most complex:'
  prefs: []
  type: TYPE_NORMAL
- en: Ttk starts with **elements**. An element is one piece of a widget, such as a
    border, an arrow, or a field where text can be typed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements are composed using **layouts** into a complete widget (a `Combobox`
    or `Treeview`, for example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Styles** are collections of properties that define color and font settings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each style has a name, usually T, plus the name of the widget, such as `TButton`
    or `TEntry`. There are some exceptions to this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each element in a layout references one or more style properties to define its
    appearance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Widgets have a number of **states**, which are flags that can be turned on
    or off:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styles can be configured with a **map** that connects property values to states
    or combinations of states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A collection of styles is called a **theme**. Tkinter ships with different
    themes on different platforms.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A theme might define not only different styles, but different layouts as well.
    For example, a `ttk.Button` on the default macOS theme may contain a different
    set of elements, applying style settings differently compared to a `ttk.Button`
    using the default theme in Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're confused at this point, that's okay. Let's take a deep dive into the
    anatomy of a `ttk.Combobox` to get a better feel for these ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Ttk widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get a better picture of how a Ttk widget is built, open a shell in IDLE
    and import `tkinter`, `ttk`, and `pprint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a root window, `Combobox`, and `Style` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `Style` object is, perhaps, slightly misnamed; it doesn't point to a single
    style, but rather gives us a handle to examine and alter the styles, layouts,
    and maps for the current theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to examine our `Combobox`, we''ll first get its `stylename` using
    the `winfo_class()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then inspect the layout of the `Combobox` using the `Style.layout()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: By passing the style name (in this case, `TCombobox`) to the `style.layout()`
    method, we get back a layout specification that shows the hierarchy of elements
    used to construct this widget.
  prefs: []
  type: TYPE_NORMAL
- en: The elements, in this case, are `"Combobox.field"`, `"Combobox.downarrow"`,
    `"Combobox.padding"`, and `"Combobox.textarea"`. As you can see, each element
    has associated positioning properties similar to what you'd pass into `pack()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `layout` method can also be used to replace a style's layout by passing
    in a new layout specification. Unfortunately, this requires replacing the entire
    layout specification—you can't just adjust or replace a single element in place.
  prefs: []
  type: TYPE_NORMAL
- en: To see how the style connects to the elements, we can use the `style.element_options()`
    method. This method takes an element name and returns a list of options that can
    be used to alter it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that the `downarrow` element of the `Combobox` uses these style
    properties to determine its appearance. To change these properties, we'll have
    to use the `style.configure()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the color of the arrow to `red`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You should see that the `arrowcolor` has changed to `red`. This is all we need
    to know to configure widgets for static changes, but what about dynamic changes?
  prefs: []
  type: TYPE_NORMAL
- en: To make dynamic changes, we'll need to understand our widget's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can inspect or alter the state of our `Combobox` using the `state` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`Combobox.state()` with no arguments will return a tuple with the currently
    set state flags; when used with an argument (which must be a sequence of strings),
    it will set the corresponding state flags.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn off a state flag, prepend a `!` to the flag name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When you call `state()` with an argument to change the value, the return value
    is a tuple containing a set of states that would, if applied, undo the state change
    you just set. This might be useful in a situation where you want to temporarily
    set a widget's state, then return it to its previous (unknown) state.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can''t just use any strings for `state()`; they must be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`active`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`focus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pressed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selected`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`background`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alternate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exactly how different widgets use each of these states depends on the widget;
    not every `state()` is configured to have an effect by default.
  prefs: []
  type: TYPE_NORMAL
- en: Widget states interact with the widget style through the use of a map. We use
    the `style.map()` method to inspect or set the map for each style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the default map for `TCombobox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `TCombobox` has a style map for the `arrowcolor` and `fieldbackground`
    properties by default. Each style map is a list of tuples, and each tuple is one
    or more state flags followed by a value for the setting. When all of the state
    flags match the current state of the widget, the value takes effect.
  prefs: []
  type: TYPE_NORMAL
- en: The default map turns the arrow color to a light gray color when the `disabled`
    flag is set, and turns the field background to a different light gray color when
    either the `disabled` or `readonly` flags are set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set our own style mapping using the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've configured the `arrowcolor` property to be `blue` when the `invalid`
    flag is not set, and `red` when both the `invalid` and `focus` flags are set.
    Notice that while our call to `map` completely overwrote the `arrowcolor` style
    map, the `fieldbackground` map was unaffected. This means you can replace style
    mappings individually, but you can't simply append to the existing map for a given
    property.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've been operating on the `TCombobox` style, which is the default
    style for all `Combobox` widgets. Any changes we made would impact every `Combobox`
    in the application. We can also create custom styles derived from the existing
    style by prepending a name and a dot to an existing style name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`Blue.TCombobox` inherits all of the properties of `TCombobox` (including the
    `blue` `downarrow` we previously configured), but can add or override them with
    settings of its own that don''t affect `TCombobox`. This allows you to create
    custom styles for some widgets without affecting other widgets of the same type.'
  prefs: []
  type: TYPE_NORMAL
- en: We can alter the look of all the Ttk widgets at once by changing the theme.
    Remember that a theme is a collection of styles, so by changing the theme, we'll
    be replacing all the built-in styles and layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different themes are shipped on different platforms; to see the themes available
    on your platform, use the `theme_names()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: (These are the themes available on Debian Linux; yours may differ.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To query the current theme, or to set a new theme, use the `theme_use()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the previous styling is gone when you change the theme. If you switch
    back to the default, however, you'll see that your changes were retained.
  prefs: []
  type: TYPE_NORMAL
- en: Styling our form labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we can tackle with our knowledge of styling is our form widgets.
    Our colorization of the form is rather ugly and incomplete due to the `LabelInput`
    widgets retaining their default, drab color. We'll need to style each of those
    widgets to match the color of its `LabelInput`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `views.py` file, add this near the start of the `DataRecordForm.__init__()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We're creating our `Style` object so that we can start working with our Ttk
    styles. What styles do we need?
  prefs: []
  type: TYPE_NORMAL
- en: We need a style for Ttk `Label` widgets for each section, since we'll need different
    colors for the widgets in `RecordInfo`, `EnvironmentInfo`, and `Plant Info`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need to style our Ttk `Checkbutton`, since it uses its own built-in label
    rather than a separate label widget. Since there's only one right now, we only
    need one style for it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create those styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're creating a custom style based on `TLabel`, but this is
    prefixed for each individual section. For each style, we're just setting the `background`
    color appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the tedious task of adding this style to each widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In each `LabelInput` call, you'll need to add a `label_args` argument that sets
    the `style` to the appropriate `TLabel` style for the section. Go through and
    do this for all the widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `Checkbutton`, you''ll need to do it differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've set `input_args`, since the style applies to the `Checkbutton` rather
    than the label (leave `label_args`; we'll need that in a minute).
  prefs: []
  type: TYPE_NORMAL
- en: If you run the program at this point, you'll see a marked improvement, but it's
    not quite there yet; the error labels are still the old, default color.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we just need to edit our `LabelInput` widget to use the `label_args`
    for the error label as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `widgets.py` and fix the `self.error_label` assignment in `LabelInput.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, your application should have consistent colors and look a lot more attractive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eabe2216-6517-4675-b812-375b762689ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Styling input widgets on error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our data entry staff has complained that the error-styling in our fields is
    not terribly noticeable. Currently, we're just setting the `foreground` color
    to `red`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has a couple of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: For empty fields, there's nothing to actually color `red`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our color blind user has trouble distinguishing the `red` from the normal text
    color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use our styling knowledge to improve the error styling and make invalid
    fields more noticeable.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can do that, though, you may have to fix a minor issue with one of
    our widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Making our Spinbox a Ttk widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're using Python 3.6 or earlier, the `Spinbox` widget is only available
    in `tkinter`, and not `ttk`.  We'll need to fix this so that our error-styling
    can be consistent.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, the author has submitted a patch to Python
    3.7 to include the Ttk `Spinbox`. If you're using Python 3.7 or later, you can
    just use `ttk::spinbox` and skip this section.
  prefs: []
  type: TYPE_NORMAL
- en: Since `Spinbox` is already in the Tcl/Tk Ttk library, creating a Python class
    for it is surprisingly easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code near the top of `widgets.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This is all that's needed to create a Ttk `Spinbox` for this application. We're
    simply subclassing `ttk.Entry`, but changing the Ttk widget being used in the
    `__init__` statement. If we needed any `Spinbox` methods that `Entry` lacks, we'd
    need to provide those; for this application, we don't need anything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we only need to update our `ValidatedSpinbox` class to inherit `TtkSpinbox`
    rather than `tk.Spinbox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Updating ValidatedMixin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we're working with all Ttk widgets, we can update our `ValidatedMixin`
    class with some dynamic styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin in the `__init__()` method by creating a `Style` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a mixin class, we don't know the original style name of the widget
    we're mixing with, so we'll have to fetch that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we can do this with `winfo_class()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: After getting the widget class, we're creating a derivative style by prepending
    `ValidatedInput` to it. In order to toggle our input appearance between error
    and non-error appearances, we'll create a style map that switches with the state
    of the `invalid` state flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this with a call to `style.map()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We're still using red, since it's an established "error color", but this time
    we're inverting the field from dark-on-light to light-on-dark. This should help
    our colorblind user to distinguish errors, even though they are red.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to update our call to `self.config` to include setting the
    widget''s style to our new validated style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Ttk widgets automatically set their `invalid` flags as part of the built-in
    validation system. Currently, we have a method called `_toggle_error()`, which
    is called whenever validation begins or fails and sets the error state on and
    off. We can remove that method completely, and all references to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try the application now, you''ll see that fields with errors now turn
    a dark red color with white text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aa35c553-7642-47b8-b442-8d30c3a69249.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally speaking, the default Ttk theme on any given platform is probably
    the best one to use on that platform, but looks are subjective and sometimes we
    might feel that Tkinter gets it wrong. Having a way to adjust the theme might
    help to smooth out some rough edges and make some users feel more comfortable
    with the look of the application.
  prefs: []
  type: TYPE_NORMAL
- en: As we've already seen, querying available themes and setting a new theme is
    fairly simple. Let's create a configuration option to change the theme of our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Building a theme selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Themes aren't something users are going to need to change often, and as we've
    seen, changing the theme can undo style changes we've made to our widgets. In
    light of this, we'll play it safe by designing our theme changer in such a way
    that it requires a restart of the program to make the actual change.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding a theme option to our `SettingsModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Every platform has a `theme` aliased to `default`, so this is a safe and sensible
    default value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, our `Application.__init__()` method will need to check this value and
    set the `theme` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code just after the call to `load_settings()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We create a `Style` object, query our settings for the theme name, then (assuming
    the saved `theme` is in the available themes) set the `theme` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: What remains now is to create the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `views.py` file, we''ll create a new submenu for the `options_menu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply loop through the available themes and add a `Radiobutton` for
    each theme, tying it to our `settings['theme']` variable.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be obvious to users that changing the theme requires a restart, so
    let's make sure to let them know.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add a `trace` to the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `on_theme_change` method will just display a warning dialog informing the
    user that a restart will be needed to realize the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add it to the end of the `MainMenu` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can run the application and try changing the `theme`. Which theme looks
    best on your platform?
  prefs: []
  type: TYPE_NORMAL
- en: You might find that some themes on your platform break the widget styling in
    the form. Remember that themes don't just change default colors and fonts, they
    change the layout and contents of the widget elements themselves. Sometimes, a
    style setting doesn't carry across different themes due to this change of property
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we overhauled the look and feel of our application for both
    aesthetic and usability improvements. You learned how to work with color and font
    settings for Tkinter widget, and the intricate world of Ttk styles.
  prefs: []
  type: TYPE_NORMAL
