- en: The App Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our last chapter was about adding home screen installation and push notifications--both
    meant to improve the user's experience by adding functionality--but, as we described
    in our user stories at the beginning of the book, one of the most important features
    of this app was its inclusiveness; it was a chat app for everyone, anyone, anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a web app perspective, we can better rephrase that as "any connection,
    any speed." The biggest blocker of web application performance is network requests:
    how long it takes to load data over a poor connection.'
  prefs: []
  type: TYPE_NORMAL
- en: Developers can fail to give performance its due attention, simply because we
    usually test our sites on speedy connections inside air-conditioned buildings
    in urban hubs. However, for a global app such as Chatastrophe, we must think about
    the users in less developed countries, the users in rural areas, and the users
    who only have a tenth of the network speed we do. How can we make the app work
    for them?
  prefs: []
  type: TYPE_NORMAL
- en: This section is all about performance; specifically, it's about optimizing our
    app so that it performs well even in the worst conditions. If we do it well, we'll
    have a robust user experience, suited for any speed (or lack thereof).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover these things:'
  prefs: []
  type: TYPE_NORMAL
- en: What progressive enhancement is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RAIL model of performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Chrome DevTools to measure performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving our app shell out of React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is progressive enhancement?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Progressive enhancement** is a simple idea with big consequences. It comes
    from a desire to provide an awesome user experience, married with the need for
    performance. If all our users had perfect, ultrafast connections, we could build
    an incredible application. However, if all our users have slow connections, we
    have to settle for a more bare-bones experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Progressive enhancement says porque no los dos? Why not both?
  prefs: []
  type: TYPE_NORMAL
- en: Our audience includes both fast connections and slow connections. We should
    serve both, and serve each appropriately, which means providing the best experience
    for the best connections and a more stripped-down (but still great) experience
    for poor connections, and everything in between.
  prefs: []
  type: TYPE_NORMAL
- en: In a sentence, progressive enhancement means our application gets progressively
    better as our user’s connection improves, but it is always useful and useable.
    Our application is thus an application adaptive to the connection*.*
  prefs: []
  type: TYPE_NORMAL
- en: You can actually imagine that this as exactly how a modern web page loads. First,
    we load the HTML--the basic, ugly skeleton of our content. Then, we add the CSS
    to make it pretty. Lastly, we load the JavaScript, which contains all the good
    stuff to make it pop. In other words, our application gets progressively better
    as the site loads.
  prefs: []
  type: TYPE_NORMAL
- en: The progressive enhancement paradigms urge us to reorganize our site's content
    so that the importance stuff loads as quickly as possible, and then the bells
    and whistles come in. So, if you’re on a super fast connection, you get everything,
    now; otherwise, you get just what you need to get using the application and the
    rest of the stuff comes later.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this chapter, we'll optimize our application to boot up as quickly as
    possible. We’ll also cover many tools you can use to keep an eye on performance,
    and continually enhance it, but how do we measure performance? What metrics can
    we use to ensure that we're delivering a fast app? Enter the RAIL model.
  prefs: []
  type: TYPE_NORMAL
- en: The RAIL model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RAIL is what Google calls a "user-centric performance model". It's a set of
    guidelines for measuring our app's performance. We should try to avoid straying
    outside of these suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: We will use RAIL's principles to speed up our application and ensure that it
    performs well enough for all users. You can read Google's full docs on RAIL at
    [https://developers.google.com/web/fundamentals/performance/rail](https://developers.google.com/web/fundamentals/performance/rail).
  prefs: []
  type: TYPE_NORMAL
- en: 'RAIL outlines four specific periods in an application''s life cycle. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Idle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personally, I think it's easier to think about them in reverse order (since
    it's more true to their actual order), but that would have spelled LIAR, so we
    can see why Google shied away from that. Either way, that's how we'll cover them
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Load
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, your application loads (let there be light!).
  prefs: []
  type: TYPE_NORMAL
- en: RAIL says that the optimal load time is one second (or less). That doesn't mean
    your entire application loads in one second; it means the user sees content within
    one second. They get some sense that the current task (loading the page) is progressing
    in a meaningful way, rather than staring at a blank white screen. As we'll see,
    this is easier said than done!
  prefs: []
  type: TYPE_NORMAL
- en: Idle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once your application is done loading, it is idle (and also will be idle between
    actions) until a user performs an action.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than letting your app just sit there (being lazy!), RAIL argues that
    we should use this time to continue loading in parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see this more in the next chapter, but if our initial load is just the
    bare bones version of our app, we load the rest (progressive enhancement!) during
    idle time.
  prefs: []
  type: TYPE_NORMAL
- en: Animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation will be less relevant to our purpose, but we'll cover it briefly here.
    Essentially, users will note a lag in animations if they are not performed at
    60 fps. This will negatively affect the perceived performance (how the user feels
    about your app's speed).
  prefs: []
  type: TYPE_NORMAL
- en: Note that RAIL also defines scrolling and touch gestures as animations, so even
    if you have no animations, if your scroll is laggy, you have a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eventually (hopefully very quickly!), the user performs an action. Usually,
    that will mean clicking on a button or typing or using a gesture. Once they do
    so, you have 100 ms to provide a response that acknowledges their action; otherwise,
    users will notice and get frustrated, and maybe retry the action, causing more
    problems down the line (we've all experienced this--the mad double- and triple-clicking).
  prefs: []
  type: TYPE_NORMAL
- en: Note that some actions will take longer to complete, if you need to do some
    calculation or network requests. You don’t need to complete the action in 100
    ms, but you do have to provide some response; otherwise, as *Meggin Kearney* puts
    it, "the connection between action and reaction is broken. Users will notice."
  prefs: []
  type: TYPE_NORMAL
- en: Timeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the preceding model illustrates, there are certain time limitations, within
    which our application has to live. Here''s a handy reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '>16ms: Time per frame of any animation/scrolling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '>100ms: Response to user action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '>1000ms: Display content on the web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1000ms+: User loses focus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '10,000ms+: User will likely abandon the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application performs according to these specifications, you're in good
    standing (and these are not easy to do, as we shall see).
  prefs: []
  type: TYPE_NORMAL
- en: Measuring using the timeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at how to profile our application's performance
    using the Chrome DevTools, the first of a few tools we'll use to track how our
    application loads and responds.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an idea of how it performs, we can improve it according to RAIL
    principles.
  prefs: []
  type: TYPE_NORMAL
- en: The DevTools are, of course, always under development, so their appearance may
    differ from the given screenshots. The core functionality should remain the same,
    however, and so, it's important to pay close attention to the principles at work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to your deployed Firebase application in Chrome and open up DevTools to
    the Performance tab (I recommend undocking the tools into a separate window via
    the dropdown menu in the top right, since there’s a lot of content to see); then,
    refresh the page. After the page finishes loading, you should see something similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's a lot going on here, so let's break it down. We'll start with the Summary
    tab, the circle graph at the bottom there.
  prefs: []
  type: TYPE_NORMAL
- en: The Summary tab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The number in the middle is how long it took for our application to fully complete
    loading. Your number should be similar to mine, with some variation based on your
    internet speed.
  prefs: []
  type: TYPE_NORMAL
- en: By far the biggest number here is scripting, at almost 1000 ms on its own. Since
    our application is JavaScript-heavy, this makes sense. Right away, we can see
    where most of our optimization should be focused--on booting up our scripting
    as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The other significant number is the amount of idle time (almost as much as scripting
    time). We’ll see why there's so much in a moment, but keep in mind that the RAIL
    model recommends using that time to start preloading bits of the application that
    haven't loaded yet. As of now, we load everything at the start, boot it all up,
    and then sit around for a bit. It will make far more sense to load only what we
    need (thus reducing scripting time) and then load the rest in the background (thus
    reducing idle time).
  prefs: []
  type: TYPE_NORMAL
- en: Network requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will jump up to network requests now, since it'll help explain a lot of the
    rest of the performance profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see what data was exactly loaded in at what time. At the beginning,
    we see a lot of the setup files: the Firebase app and `messaging` libraries, our
    `bundle.js`, and the actual document for the page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Later on, the two significant calls are for the user: to log in and load the
    user details. The last thing we load is the manifest.'
  prefs: []
  type: TYPE_NORMAL
- en: This ordering makes sense. We need to load the Firebase libraries and our JavaScript
    in order to boot up our application. Once we do so, we start the login process.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing that happens, once our user logs in, is that we receive the messages,
    data from Firebase. As you’ll note, this does not show up on the chart, because
    it's done over WebSockets, in real time, so it's not a network request as such.
    However, it will figure into the rest of the performance profile, so keep it in
    mind.
  prefs: []
  type: TYPE_NORMAL
- en: Waterfall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have a detailed breakdown of what Chrome is actually doing at any time
    during the rendering process.
  prefs: []
  type: TYPE_NORMAL
- en: The Waterfall tool is detailed and complex, so we'll have to be content with
    a surface glimpse here. There are two insights we can draw just from looking at
    it, however. First, we can see all the idle time visualized. Most of it is at
    the start, which is somewhat unavoidable as we first load the document, but there's
    that great gap in the middle that we can try to fill.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you can see when the application receives the messages from Firebase,
    in the rightmost waterfall section. If you hover over each block, you can actually
    trace Firebase receiving the message down to our `App.js`, setting its state to
    the messages array.
  prefs: []
  type: TYPE_NORMAL
- en: So, while we can't see the messages loading in the network request, we can see
    the response in the JavaScript execution.
  prefs: []
  type: TYPE_NORMAL
- en: Screenshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is my favorite section of the Performance Tools, because it vividly illustrates
    how your application loads.
  prefs: []
  type: TYPE_NORMAL
- en: As we established earlier, users should see content within 1,000 ms of loading
    your application. Here, we can see that content first appears on our application
    at about 400 ms, so we’re looking good, but as our application grows (and our
    scripting burden increases) that may change, so now’s the time to optimize as
    much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: PageSpeed Insights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Performance Tools are great in that they let us dive deep into the nitty
    gritty of our application's loading. We will use them to keep track of our app's
    performance as we try to improve it, but, if we want more specific, detailed suggestions,
    we can turn to **PageSpeed Insights**, a tool provided by Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to PageSpeed Insights ([https://developers.google.com/speed/pagespeed/insights/](https://developers.google.com/speed/pagespeed/insights/))
    and plug in the URL of your deployed application. After a few seconds, you''ll
    get recommendations about what can we improve about Chatastrophe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our mobile performance is in dire need of aid. Most of the insights
    focus on our render-blocking JavaScript and CSS. I encourage you to read through
    their descriptions of these problems and try fixing them on your own. In the next
    section, we'll work on improving our app to Google's specifications, using another
    Progressive Web App secret weapon--the app shell pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The app shell pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The essence of our application is the message list and chat box, where users
    read and write messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'This core functionality relies on JavaScript to work. We cannot get around
    the fact that we are unable to display the messages until the user has been authenticated
    through Firebase and the messages array has loaded, but everything surrounding
    those two pieces is mostly static content. It''s the same in every view and it
    does not rely on JavaScript to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can refer to this as the application shell--the frame around the functional,
    JavaScript driven core.
  prefs: []
  type: TYPE_NORMAL
- en: Since this frame does not rely on JavaScript to function, there's actually no
    need for us to wait for React to load and boot up all our JavaScript before displaying
    it—which is what is currently happening.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, our shell is a part of our React code, so, all our JavaScript has
    to be loaded before we call `ReactDOM.render` and display it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: However, with our app, and with many apps, there’s a significant section of
    the UI that is essentially just HTML and CSS. Also, if our goal is to decrease
    perceived load time (how long the user thinks it takes to load our app) and get
    content on the screen as soon as possible, we're better off keeping our shell
    just as HTML and CSS, that is, separating it from our JavaScript so that we don’t
    have to wait for React.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our Performance Tools, you can see that the first thing loaded
    is the document, or our `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we can move our shell in that `index.html`, it'll appear a heck of a lot
    faster than it currently is, because it won't have to wait for the bundle to load.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, however, let's take a benchmark to see where we are and how
    much of an improvement this will make.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using your deployed app, open up our Performance Tools and refresh the application
    (use the Empty Cache & Hard Reload option available when DevTools is open to ensure
    that there’s no accidental caching going on—hold and press the reload button to
    access it). Then, take a look at that image strip and see when content first appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Run the test three times, to be sure, and then take the average. For me, it
    took an average of 600 ms. That's our benchmark to beat.
  prefs: []
  type: TYPE_NORMAL
- en: Moving shell HTML out of React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by defining what we want to move into our `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following image, everything outside the messages and chat box line is
    our app shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: That's what we want to move out of React and convert to plain HTML, but let's
    clarify something before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal here is to create a fast-loading version of the parts of our app that
    don't need JavaScript immediately but, ultimately, some of our shell will need
    JavaScript. We need our logout button in the header and that will need JavaScript
    to function (though only once the user is authenticated).
  prefs: []
  type: TYPE_NORMAL
- en: So, while we talk of moving this content out of React, what we'll actually do
    is have a pure HTML and CSS version of the shell and then, when React initializes,
    we will replace it with with the React version.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach gives us the best of both worlds: a fast-loading version of the
    basics, which we''ll swap out once the JS is ready. If this sounds familiar, you
    can also call it progressively enhancing our app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can we manage this swap-out? Well, let''s start by opening our `index.html`
    and taking a look at how our application initializes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The key is our `div#root`. As we see in our `index.js`, that''s where we inject
    our React content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Right now, we''re embedding our React content into an empty `div`, but let''s
    try out something; add an `<h1>` in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, reload your app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `<h1>` appears until our React is ready, in which case it is replaced, so
    we can add content inside `div#root` and it’ll simply be overwritten when React
    is ready; that's our key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s progressively move content over, starting from our `App.js` and working
    our way downward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The only bit of HTML (or JSX, currently) we need here is the container. Let''s
    copy that into `div#root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside `ChatContainer` (or `LoginContainer`, or `UserContainer`), we
    see we have a `div.inner-container`, which also can be moved over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note the change from `className` (for JSX) to `class` (for HTML).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we move the `Header` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload your app and you''ll see a very ugly version of our HTML appear before
    the React loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What’s going on here? Well, our CSS is loaded inside our `App.js`, in our import
    statements, so it's not ready until our React is. The next step will be to move
    the relevant CSS inside our `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Moving CSS out of React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, our app doesn't have that much CSS, so we can, in theory, just `<link>`
    our entire style sheet inside `index.html`, instead of importing it in `App.js`,
    but as our application and our CSS grow in size, that will be less than optimal.
  prefs: []
  type: TYPE_NORMAL
- en: Our best option is to inline the relevant CSS. We start by adding a `<style>`
    tag to our `<head>`, right below our `<title>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Then, open up `src/app.css`, and cut (not copy) the CSS within the `/* Start
    initial styles */` and `/* End Initial styles */` comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put that inside the style tags and reload the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The application looks exactly the same! That''s the good news; at this stage,
    there probably isn''t a perceptible difference in load time. However, let''s deploy
    and then run our Performance tools again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the shell (with the blank inner) appears well before the loading
    indicator appears (a sign that the React app has booted it up). This is time the
    user will usually spend staring at a blank screen.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the loading indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take it one small step forward, and also add the loading indicator into
    our app shell, to give the user a sense of what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the JSX from `ChatContainer` and add it to our `index.html`. Then, reload
    the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, the user gets a clear sense that the application is loading, and will be
    much more forgiving of our app's load time (though we will still do our best to
    decrease it).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the essential principle to take from this chapter: Progressive Web
    Apps demand that we do as much as we can to improve our user''s experience. Sometimes,
    we can''t do anything about load times (at the end of the day, our JavaScript
    will always take some time to boot up--and once it does, it provides a great user
    experience) but we can at least give our user a sense of progress.'
  prefs: []
  type: TYPE_NORMAL
- en: Good web design is about empathy. Progressive Web Apps are about being empathetic
    toward everyone, no matter what conditions they're accessing your app from.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the essentials of performance tooling and concepts,
    from RAIL to DevTools, to PageSpeed Insights. We also made a significant performance
    improvement using the app shell pattern. We'll continue to hone our app's performance
    in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Our next chapter will tackle the biggest performance hurdle--our behemoth JavaScript
    file. We'll learn how to split it into smaller chunks using the magic of React
    Router and how to load those chunks during the idle time of our app. Let's get
    to it!
  prefs: []
  type: TYPE_NORMAL
