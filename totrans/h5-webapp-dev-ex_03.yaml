- en: Chapter 3. The Devil is in the Details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Men who wish to know about the world must learn about it in its particular
    details."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*—Heraclitus*'
  prefs: []
  type: TYPE_NORMAL
- en: '*This chapter is all about the new HTML5 input types and how to interact with
    them using JavaScript. In [Chapter 1](ch01.html "Chapter 1. The Task at Hand"),
    *The Task at Hand*, we created a task list application and in [Chapter 2](ch02.html
    "Chapter 2. Let''s Get Stylish"), *Let''s Get Stylish*, we styled it using new
    CSS3 styles. In this chapter we continue to improve it by adding a task details
    section using the new HTML5 input types. Then we will use custom data attributes
    to automatically bind values in the view to the data model in our application.
    We will also add some jQuery animations to make UI transitions smoother.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The new HTML5 input types and what benefits they provide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom data attributes and their uses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to bind a data model to input elements using custom data attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using jQuery animation methods to hide and show elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using timers to queue up saves to localStorage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 input types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML5 comes with a whole host of new input types. These new types are designed
    to provide formatting, validation, and in some cases, selectors. For touch devices
    some of them provide a different set of keys for the keyboard. Not all of the
    new input types are supported by all browsers yet. Fortunately for us, if a browser
    doesn't support a type it will just display it as a normal text field. Unfortunately
    for us, you can't depend on the browser to provide the correct formatted data
    if the unsupported types are only shown as text fields. So make sure you have
    a backup plan if you are going to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few of the more useful new input types with images of the ones that
    are supported by Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See examples in `Chapter 3/input-types/input-types.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `color` input type is used to choose a color. When clicked it usually displays
    a color picker. The value is a hex color specifier (for example, #FF0000). This
    control isn''t widely supported for now, so use with caution.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Color](img/5947OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `date` input type is used to select a date. When clicked it usually displays
    a date picker. The value is a date string in the format yyyy-mm-dd (for example,
    2013-01-23). You may also specify the `min` and `max` attributes in the same date
    format to limit the date span:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Date](img/5947OT_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Email
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `email` input type is used to enter an e-mail address. It looks and behaves
    like a standard text field. On touch devices the keyboard usually changes to provide
    e-mail symbols such as the *@* sign and *.com*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `number` input type is used to enter a number. It is usually displayed
    with up and down buttons (a spinner control) that change the value by the `step`
    amount when clicked. On touch devices the keyboard may change to a number pad.
    There are a few attributes you can use to restrict the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min`: This specifies the minimum value allowed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max`: This specifies the maximum value allowed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step`: This specifies the amount by which value changes when you click on
    the up or down spinner buttons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Number](img/5947OT_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `range` input type is used to choose a value from a range of values. This
    is nearly identical to the `number` input type, except that it is usually displayed
    as a slider control. It has the same attributes as the `number` input type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Range](img/5947OT_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `time` input type is used to select a time. When clicked it may display
    a time picker or you can set the time using the spinners. The value is a 24-hour
    format time string in the format hh:mm:ss (for example, 13:35:15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Time](img/5947OT_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `url` input type is used to enter a URL. Like the `email` type, touch devices
    usually display a keyboard optimized for entering a URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Datalist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to these new input types, a new `<datalist>` form element has been
    added in HTML5\. It is used to add a drop-down list of hints to a text field.
    When the user starts typing in the text field, all of the list options that match
    the letters being typed will be shown in a dropdown under the field. The user
    can select one of the options to automatically fill in the field.
  prefs: []
  type: TYPE_NORMAL
- en: You associate a `<datalist>` element with a text field by setting an ID on the
    `<datalist>` element, and referencing it with the `list` attribute of an `<input>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Datalist](img/5947OT_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because implementation of the new input types is spotty at this times, be cautious
    when using them. Using a `number` field isn't going to cause many problems if
    it's not supported; the user can still enter a number in the text field. But something
    like the `color` field, if not supported, shows as a text field. Will your user
    be willing to enter a color in hex code in that case?
  prefs: []
  type: TYPE_NORMAL
- en: Autofocus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's one more useful addition to HTML5 input elements. A new `autofocus`
    attribute was added to set the focus on a particular `<input>` element when the
    page is first loaded. Previously we did this in our application by calling the
    jQuery `focus()` method for the `<input id="new-task-name">` element. We can do
    the same thing in HTML5 by just adding the `autofocus` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Task details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's put some of these new input types to good use in our task list application.
    At the moment all we have is a task name input field. There's not much we can
    do with that. So let's add some fields to each task to allow the user to define
    more details about them. You can find the source code for this section in `Chapter
    3\example3.1`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding task details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will give each task the following new fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start date**: The date the task should start. The input type is `date`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Due date**: The date the task should be done by. The input type is `date`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status**: Drop-down list `<select>` with options for **None**, **Not Started**,
    **Started**, and **Completed**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority**: Drop-down list `<select>` with options for **None**, **Low**,
    **Normal**, and **High**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**% Complete**: The input type is `number`, with a valid range from **0** to
    **100**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define these fields in the task template markup in `taskAtHand.html`.
    The details for each task will be displayed in a section under the task name.
    Our template now looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First we added a new `<div class="details">` element to contain the new detail
    fields. This allows us to separate the details from the task name to style it
    differently. Then we added the labels and fields to it. Note that for **% Complete**
    we set the `min` and `max` attributes of the `number` field to limit the number
    between 0 and 100.
  prefs: []
  type: TYPE_NORMAL
- en: Next we need to style the details section. We will give it a gray background
    and rounded corners. We make all the labels of same width and align them to right
    so that all the input fields line up. We then set the `<select>` element of **Status**
    and **Priority** to a fixed width so they line up as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We added a task details section to our tasks using some of the new HTML5 input
    types. The following screenshot shows what the task item looks like now with a
    details section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/5947OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – hiding task details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This looks good, but it's also taking up a lot of room. If each task in the
    list is this long it will soon scroll off the page and we won't be able to see
    an overview of the task list very well. Since the task details are optional fields
    anyway, we can make our list more compact by not showing the details until the
    user wants to see them. We'll do that by hiding the details section and adding
    a toggle button next to the task name to show or hide the details when clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s add the toggle details button next to the task name in our task
    template and give it a class named `toggle-details`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s implement the toggle button in our JavaScript code. First we add
    a click event handler for the toggle button in the `addTaskElement()` method that
    calls the `toggleDetails()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we implement the `toggleDetails()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `toggleDetails()` method uses a couple of new jQuery methods that we haven't
    seen yet. It toggles the visibility of the task details using `slideToggle()`
    and toggles the `expanded` class on the button using `toggleClass()`. The `toggleClass()`
    method adds a class to an element if the element doesn't already have it, and
    removes it if it does.
  prefs: []
  type: TYPE_NORMAL
- en: The `slideToggle()` method is an animation function that toggles the visibility
    of an element. It makes an element visible using a sliding down motion pushing
    the elements below it down. To hide the element it slides it back up, shrinking
    it until it's hidden. There is also a method to fade elements in and out called
    `fadeToggle()`. But a slide provides a smoother transition when an element moves
    other elements out of the way when it becomes visible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general a slide looks better when the element pushes the elements below it
    down when it's made visible. It is also good for menu-like behavior. A fade usually
    looks best when you are making an element visible that displays over the top of
    other elements.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's add some styling to the button. Of course we want some nice icons
    like our other task buttons, so let's add them to our sprite sheet file, `icons.png`.
    We need an image to show when the task properties are collapsed and one to show
    when they are expanded. Let's create a second row of images for these two icons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – hiding task details](img/5947OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing we need to do back in our stylesheet is set `display` to `none`
    for the details so that they are hidden by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add styles for the `toggle-details` button. As we are using the same
    sprite sheet as the task tools buttons, we''ll use the same style for our new
    button by adding it to the CSS selector. Then we''ll add selectors to get the
    images into the button using background position offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The vertical offset for our `toggle-details` images is `-16px` because they
    are on the second row in the sprite sheet. Notice that the second image matches
    to the `expanded` class. We are adding the `expanded` class to the button when
    details are visible.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added a toggle button to each task that hides or shows the task details when
    clicked. Open it in the browser and see what we have now. You can open and close
    task details and they smoothly slide open and closed. Pretty cool.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/5947OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Custom data attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another new feature of HTML5 is custom data attributes. Custom data attributes
    allow you to store custom data private to your application as an attribute on
    any element in the DOM. All you have to do is prefix the attribute name with `data-`.
    The name should be all lower case letters. You can assign any string value to
    the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we had a list of products and we wanted to store information
    about the products, such as product ID and category. All we have to do is add
    `data-product-id` and `data-category` attributes to the associated elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So now that we have custom attributes, we can extract the custom data from the
    elements using JavaScript and use it in our applications. jQuery happens to have
    a `data()` method designed just for this purpose. You give it the name of the
    custom attribute, minus the `data-`, and it returns the value associated with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the previous example, let''s say we want to allow the user
    to click on a product in the list and then do some processing on it. The following
    `setSelectedProduct()` method uses the `data()` method to extract the product
    ID and category from the element that was clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Data binding with custom attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great use for custom data attributes is to implement data binding. Data binding
    allows us to map user controls in the DOM to fields in the data model so that
    they are automatically updated when the user changes them. Using this technique
    we can eliminate a lot of boring repetitive code that does nothing more than handle
    events and map fields in the view to fields in the model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few excellent data binding libraries available for JavaScript, including
    `Backbone.js` and `Knockout`. We will implement our own simple data binding here
    to learn how to use custom attributes. If you find yourself building an application
    with a lot of data you might consider using one of these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – building a data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can begin implementing data binding, we need a data model to bind
    to. If you recall, we are only saving the task names to `localStorage`. Our data
    model is simply an array of strings. Now that each task has multiple details fields
    we will need something a little more substantial to hold all of that data. You
    can find the source code for this section in `Chapter 3\example3.2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining a task object for our data model. We will create a
    new file, `taskList.js` to put it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Starting from the top, our constructor takes one parameter-the task name. It
    uses that to set the name field in the object. Each task has a unique task ID,
    which gets incremented every time a task is created. The rest of the members are
    set to default values.
  prefs: []
  type: TYPE_NORMAL
- en: We are attaching a `Task.nextTaskId` field to the `Task` object constructor
    to keep track of what the next unique task ID should be. Doing this allows us
    to define what we would call static or class variables in languages that have
    classes, such as Java or C# (where they are defined using static variables). The
    `nextTaskId` field will get saved to `localStorage` whenever it changes so that
    we know where we left off when the user returns to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `priority` and `status` are using enumerations. We implement those
    as static objects (because JavaScript doesn't have enumerations) attached to the
    `Task` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need is a list to store the `Task` objects in. To make it
    easier to manage the code for this, we will create a `TaskList` object that is
    basically a wrapper over an array. It provides methods to add, remove, and get
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The constructor takes one optional parameter that is an array of the `Task`
    objects. The first line of the constructor checks to see if an array was passed
    in. If not, it creates a new empty array using empty square brackets (`[]`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript the logical OR operator (`||`) can act as a null-coalescing operator.
    It returns the left-hand operand if the operand is "truthy"; otherwise it returns
    the right operand. In this case, truthy means that a `tasks` parameter was passed
    in and is not `null` or `undefined`. This is very useful paradigm for defining
    default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we add a public `getTasks()` method that simply returns the array. We will
    need access to it later to save the tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we add a public `addTask()` method that takes a `Task` object and appends
    it to the end of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The public `removeTask()` method takes a task ID as a parameter and removes
    the associated task from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It gets the index of the task by calling `getTaskIndex()`, then uses the `array.splice()`
    method to remove it from the `tasks` array. The `getTaskIndex()` method is a private
    method that takes a task ID as a parameter and searches through the array to find
    the task with that ID. If it finds the task it returns it. Otherwise it returns
    `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Next up is the public `getTask()` method. It takes a task ID as a parameter
    and also uses the `getTaskIndex()` method to find it. It returns the associated
    `Task` object, or `null` if it doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The last public method we are going to add is called `each()`. It takes a reference
    to a `callback` function as a parameter. It loops over the array of tasks and
    executes the `callback` function for each task in the array. This method can be
    used to iterate over all tasks in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – implementing the bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s head back over to the task template in our HTML file and add some custom
    data attributes. We''ll add custom attributes to all of the task details `<input>`
    and `<select>` elements. The data attribute name will be `data-field`, and the
    attribute value will be the name of the field the element matches to in the `Task`
    object. We will use those attributes later in our JavaScript to hook the DOM elements
    and data model together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a data model, we need to go into the `TaskAtHandApp` object
    in `taskAtHand.js` and update it to use that model. First we''ll add a `taskList`
    variable and initialize it to an instance of a `TaskList` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll go into the `addTask()` method and add code to create a new `Task`
    object, and add it to the task list. This is also where we save the `nextTaskId`
    value into `localStorage` after it''s been incremented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we also changed the parameter of the `addTaskElement()` method
    to pass in the `Task` object. So let''s update the `addTaskElement()` method to
    take a `Task` object as the parameter instead of a task name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After creating a new task element in the DOM we set the task ID on it using
    a custom data attribute named `task-id`. This is done with the jQuery `data()`
    method that takes the data attribute name and value as parameters. Next we set
    the task name into the `<span>` attribute from the `task.name` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will implement the first part of the data binding. This next block of
    code uses the data attributes we previously added to the markup to set the values
    from the `Task` object into the associated `<input>` and `<select>` elements in
    the details section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: First it finds all `<input>` and `<select>` elements inside the task element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then it calls the jQuery `each()` method, which is used to iterate over the
    set of selected elements, passing in a `callback` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `callback` function `this` points to the current element. So first
    we wrap the element in a jQuery object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we use the `data()` method to get the value of the `data-field` custom
    attribute, which is the name of the field in the `Task` object associated with
    the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally we set the value of the user control to the value of the field in the
    `Task` object. We get the value from the `Task` object using square brackets.
    Remember that in JavaScript `object["field"]` is the .same as `object.field`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can think of using square brackets to access object fields as similar to
    using reflection in C# or Java to dynamically access values in objects at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add code to go the other way. Whenever the user changes the
    value of a form control we want to automatically save it back to the data model.
    So let''s add a change event handler for each of the details form controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This calls the `onChangeTaskDetails()` method, passing in the task ID and the
    form control element that changed wrapped in a jQuery object. Let''s implement
    that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break it down to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: First it gets the `Task` object from the task list with the specified ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After making sure we got an object back (you never know, so always check) we
    get the `Task` object field name from the element's `data-field` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we set the value of the field on the `Task` object to the value of the
    form control element, again using square brackets to access it dynamically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally we call `saveTaskList()` to commit the change to `localStorage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That reminds me, we need to rewrite the `saveTaskList()` method to save our
    new `TaskList` object. That''s easy enough. We just call the `getTasks()` method
    of the task list to get the array of `Task` objects. Then we save the array to
    `localStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have old task list data from the previous examples you will need to delete
    it before using the new data model. In Chrome developer tools you can click on
    the item and press the *Delete* key to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First we created a data model to hold all of the task data. Then we added data
    binding to our application using custom data attributes to automatically update
    the data model when a field on the page changes. Then we saved the task list to
    local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – loading the task list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve saved the new data model to `localStorage` we need to update
    the `loadTaskList()` method to load the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'First we get the task array from `localStorage` and pass that as a parameter
    into the `TaskList` object''s constructor. Then we call a new method, `rebuildTaskList()`
    to create the task elements in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: First we remove any old elements from the task list element using the jQuery
    `empty()` method. Then we use the `each()` method that we implemented in the `TaskList`
    object to iterate over the tasks and call `addTaskElement()` for each one to build
    the task elements.
  prefs: []
  type: TYPE_NORMAL
- en: Queuing up changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we've bound the user controls to the data model and automatically save it
    every time a change is made. There's one problem with this though. Input controls
    like the `number` or `time` types that have spinners associated with them cause
    a `change` event every time a spinner button is clicked. If the user holds a spinner
    button down it will fire `change` events at an alarming rate. This will in turn
    save the task list to `localStorage` repeatedly in a very short period of time.
    That doesn't seem like a very efficient thing to do, especially if you have a
    lot of data.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – delaying the saves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See the code in `Chapter 3\example3.3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can alleviate this problem by delaying the save to `localStorage` for a
    period of time to wait until all of the user interaction has finished. This is
    pretty easy to implement using JavaScript''s `setTimeout()` function. We will
    make this change in the `saveTaskList()` method, but first we need a global variable
    in the `TaskAtHandApp` object to keep track of the timeout ID returned by `setTimeout()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When changes are pending a save, we want to display a message in the status
    element at the bottom of the page so the user knows that their changes will be
    saved. When the actual save has taken place we will update the message and fade
    it out so the user knows the save is complete. To do that we need to rewrite the
    `setStatus()` method as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We add an optional `noFade` parameter. When set to `true` the message will
    not fade out. Otherwise we use the jQuery `fadeOut()` method to gradually fade
    out the message over 1000 milliseconds, or one second. Now let''s update the `saveTaskList()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is check to see if there is already a save pending by
    checking if the `timeoutId` variable has a value. If it does, we will cancel the
    timeout using JavaScript's `clearTimeout()` function. This has the effect of resetting
    the timer if the user makes another change while a save is pending. All changes
    will effectively be queued up and saved at one time.
  prefs: []
  type: TYPE_NORMAL
- en: Next we set a new timeout using `setTimeout()`. The `setTimeout()` function
    takes a function to execute and the number of milliseconds to wait until it executes
    the function. It returns a timeout ID that we store in our `timeoutId` variable
    in case we need to cancel the timeout later.
  prefs: []
  type: TYPE_NORMAL
- en: After 2000 milliseconds, or two seconds of inactivity the task list will be
    saved. Then we reset the `timeoutId` variable because our timeout is finished.
    Finally we call `setStatus()` to tell the user the changes have been saved.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used the JavaScript `setTimeout()` function to effectively queue up changes
    so we aren't constantly saving the task list when values are changing rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That's it; our task list application is complete, as far as this book goes anyway.
    Now go and add your own features to make it even better. For example, add more
    task fields such as a text area to enter notes. Maybe add an option to the toolbar
    to hide completed tasks. Try adding a sorting option to sort the list by name,
    status, or date.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. What happens if a browser doesn't support one of the new HTML5 input types?
  prefs: []
  type: TYPE_NORMAL
- en: The input field is not displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The field is displayed as a text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The field is set to read only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser shows an error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. What kind of element can custom data attributes be used on?
  prefs: []
  type: TYPE_NORMAL
- en: Only form input elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only block level elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only inline elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we looked at some of the more useful HTML5 input types. We used
    those input types to create a collapsible task details section for each task.
    Then we used custom data attributes to implement a simple data binding to map
    the input fields in the view to the data model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered the following concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How and when to use the new HTML5 input types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use custom data attributes to store private data in the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement data binding using custom data attributes to bind a data model
    to form controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use jQuery animation methods to hide and show elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a timer to delay saves to `localStorage` to make applications more
    responsive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter we will head off in a completely new direction. We'll take
    a look at the HTML5 canvas element and API and write a brand new application that
    uses it.
  prefs: []
  type: TYPE_NORMAL
