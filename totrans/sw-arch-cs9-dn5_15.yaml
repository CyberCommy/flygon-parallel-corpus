- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Presenting ASP.NET Core MVC
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ASP.NET Core MVC
- en: In this chapter, you will learn how to implement an application presentation
    layer. More specifically, you will learn how to implement a web application based
    on ASP.NET Core MVC.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何实现应用程序的表示层。具体来说，你将学习如何基于ASP.NET Core MVC实现Web应用程序。
- en: 'ASP.NET Core is a .NET framework for implementing web applications. ASP.NET
    Core has been partially described in previous chapters, so this chapter will focus
    mainly on ASP.NET Core MVC. More specifically, this chapter will cover the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core是一个实现Web应用程序的.NET框架。ASP.NET Core在之前的章节中已经部分描述过，因此本章主要将重点放在ASP.NET
    Core MVC上。具体来说，本章将涵盖以下主题：
- en: Understanding the presentation layers of web applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Web应用程序的表示层
- en: Understanding the ASP.NET Core MVC structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ASP.NET Core MVC结构
- en: What is new in the latest versions of ASP.NET Core?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core的最新版本有哪些新特性？
- en: Understanding the connection between ASP.NET Core MVC and design principles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ASP.NET Core MVC与设计原则之间的联系
- en: Use case – implementing a web app in ASP.NET Core MVC
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例 - 在ASP.NET Core MVC中实现Web应用程序
- en: We will review and give further details on the structure of the ASP.NET Core
    framework, which, in part, was discussed in *Chapter 14*, *Applying Service-Oriented
    Architectures with .NET Core*, and *Chapter 4*, *Deciding the Best Cloud-Based
    Solution*. Here, the main focus is on how to implement web-based presentation
    layers based on the so-called **Model View Controller** (**MVC**) architectural
    pattern.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾并详细介绍ASP.NET Core框架的结构，部分内容在*第14章*，*使用.NET Core应用服务导向架构*，和*第4章*，*决定最佳基于云的解决方案*中已经讨论过。这里的重点是如何基于所谓的**模型视图控制器**（**MVC**）架构模式实现基于Web的表示层。
- en: We will also analyze all of the new features available in the last ASP.NET Core
    5.0 version, as well as the architectural patterns included in the ASP.NET Core
    MVC framework and/or used in typical ASP.NET Core MVC projects. Some of these
    patterns were discussed in *Chapter 11*, *Design Patterns and .NET 5 Implementation*,
    and *Chapter 12*, *Understanding the Different Domains in Software Solutions*,
    whereas some others, such as the MVC pattern itself, are new.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将分析ASP.NET Core 5.0版本中所有新功能，以及在ASP.NET Core MVC框架中包含的或在典型的ASP.NET Core MVC项目中使用的架构模式。其中一些模式在*第11章*，*设计模式和.NET
    5实现*，和*第12章*，*理解软件解决方案中的不同领域*中已经讨论过，而另一些，如MVC模式本身，是新的。
- en: You will learn how to implement an ASP.NET Core MVC application, as well as
    how to organize the whole Visual Studio solution, by going through a practical
    example at the end of this chapter. This example describes a complete ASP.NET
    Core MVC application for editing the packages of the WWTravelClub book use case.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章末尾的实际示例将教你如何实现一个ASP.NET Core MVC应用程序，以及如何组织整个Visual Studio解决方案。该示例描述了一个完整的ASP.NET
    Core MVC应用程序，用于编辑WWTravelClub书籍用例的包。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the free Visual Studio 2019 Community edition or better
    with all database tools installed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要免费的Visual Studio 2019社区版或更高版本，并安装了所有数据库工具。
- en: All the concepts in this chapter will be clarified with practical examples based
    on the WWTravelClub book use case. The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有概念都将以基于WWTravelClub书籍用例的实际示例进行澄清。本章的代码可在[https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5)上找到。
- en: Understanding the presentation layers of web applications
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Web应用程序的表示层
- en: 'This chapter discusses an architecture for implementing the presentation layers
    of web-based applications based on the ASP.NET Core framework. The presentation
    layers of web applications are based on three techniques:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了基于ASP.NET Core框架的Web应用程序的表示层的架构。Web应用程序的表示层基于三种技术：
- en: '**Mobile or desktop native applications that exchange data with servers through
    REST or SOAP services**: We have not discussed them since they are strictly tied
    to the client device and its operating system. Therefore, analyzing them, which
    would require a dedicated book, is completely beyond the scope of this book.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过REST或SOAP服务与服务器交换数据的移动或桌面本地应用程序**：我们没有讨论它们，因为它们严格绑定到客户端设备及其操作系统。因此，分析它们完全超出了本书的范围，这需要一本专门的书。'
- en: '**Single-Page Applications** (**SPAs**): These are HTML-based applications
    whose dynamic HTML is created on the client either in JavaScript or with the help
    of WebAssembly (a kind of cross-browser assembly that can be used as a high-performance
    alternative to JavaScript). Like native applications, SPAs exchange data with
    the server through REST or SOAP services, but they have the advantage of being
    independent of the device and its operating system since they run in a browser.
    *Chapter 16*, *Blazor WebAssembly*, describes the Blazor SPA framework, which
    is based on WebAssembly, since it is based itself on a .NET runtime compiled in
    WebAssembly.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单页应用程序**（**SPA**）：这些是基于HTML的应用程序，其动态HTML是在客户端使用JavaScript或WebAssembly（一种可以作为JavaScript的高性能替代品的跨浏览器汇编）创建的。与本地应用程序一样，SPA通过REST或SOAP服务与服务器交换数据，但它们的优势在于独立于设备及其操作系统，因为它们在浏览器中运行。*第16章*，*Blazor
    WebAssembly*，描述了基于WebAssembly的Blazor SPA框架，因为它本身是基于WebAssembly编译的.NET运行时。'
- en: '**HTML pages created by the server whose content depends on the data to be
    shown to the user**: The ASP.NET Core MVC framework, which will be discussed in
    this chapter, is a framework for creating such dynamic HTML pages.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由服务器创建的HTML页面，其内容取决于要向用户显示的数据**：本章将讨论的ASP.NET Core MVC框架是用于创建这种动态HTML页面的框架。'
- en: The remainder of this chapter focuses on how to create HTML pages on the server
    side and, more specifically, on ASP.NET Core MVC, which will be introduced in
    the next section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分侧重于如何在服务器端创建HTML页面，更具体地说，侧重于ASP.NET Core MVC，该内容将在下一节中介绍。
- en: Understanding the ASP.NET Core MVC structure
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解ASP.NET Core MVC结构
- en: ASP.NET Core is based on the concept of the Generic Host, as explained in the
    *Using generic hosts* subsection of *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*. The basic architecture of ASP.NET Core was outlined
    in the *A short introduction to ASP.NET Core* subsection of *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core基于通用主机的概念，如*第5章*的*将微服务架构应用于企业应用程序*的*使用通用主机*子部分中所解释的。ASP.NET Core的基本架构在*第14章*的*应用.NET
    Core实现面向服务的架构*的*简短介绍ASP.NET Core*子部分中概述了。
- en: It is worth reminding you that the host configuration is delegated to the `Startup`
    class defined in the `Startup.cs` file by calling the `.UseStartup<Startup>()`
    method of the `IWebHostBuilder` interface. `ConfigureServices(IServiceCollection
    services)` of the `Startup` class defines all services that can be injected into
    object constructors through **Dependency Injection** (**DI**). DI was described
    in detail in the *Using generic hosts* subsection of *Chapter 5*, *Applying a
    Microservice Architecture to Your Enterprise Application*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 值得提醒您的是，主机配置是通过在`Startup.cs`文件中定义的`Startup`类来委托的，方法是调用`IWebHostBuilder`接口的`.UseStartup<Startup>()`方法。`Startup`类的`ConfigureServices(IServiceCollection
    services)`定义了可以通过**依赖注入**（**DI**）注入到对象构造函数中的所有服务。DI在*第5章*的*将微服务架构应用于企业应用程序*的*使用通用主机*子部分中有详细描述。
- en: On the other hand, the `Configure(IApplicationBuilder app, IWebHostEnvironment
    env)` startup method defines the so-called ASP.NET Core pipeline, which was briefly
    described in the *A short introduction to ASP.NET Core* subsection of *Chapter
    14*, *Applying Service-Oriented Architectures with .NET Core*, and which will
    be described in more detail in the next subsection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Configure(IApplicationBuilder app, IWebHostEnvironment env)`启动方法定义了所谓的ASP.NET
    Core管道，它在*第14章*的*应用.NET Core实现面向服务的架构*的*简短介绍ASP.NET Core*子部分中简要描述，并将在下一子部分中进行更详细的描述。
- en: How the ASP.NET Core pipeline works
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core管道的工作原理
- en: ASP.NET Core furnishes a set of configurable modules you can assemble according
    to your needs. Each module takes care of a functionality that you may or may not
    need. Examples of such functionalities are authorization, authentication, static
    file processing, protocol negotiation, CORS handling, and so on. Since most of
    the modules apply transformations to the incoming request and the final response,
    these modules are usually referred to as **middleware**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了一组可配置的模块，您可以根据需要组装。每个模块负责您可能需要也可能不需要的功能。此类功能的示例包括授权、身份验证、静态文件处理、协议协商、CORS处理等。由于大多数模块对传入请求和最终响应进行转换，因此通常将这些模块称为**中间件**。
- en: You can put together all of the modules you need by inserting them into a common
    processing framework called the **ASP.NET Core pipeline**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将它们插入到称为**ASP.NET Core管道**的通用处理框架中，组合所有需要的模块。
- en: 'More specifically, ASP.NET Core requests are processed by pushing a context
    object through a pipeline of ASP.NET Core modules, as shown in the following diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，ASP.NET Core请求通过将上下文对象推送通过ASP.NET Core模块的管道来处理，如下图所示：
- en: '![](img/B16756_15_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_15_01.png)'
- en: 'Figure 15.1: ASP.NET Core pipeline'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：ASP.NET Core管道
- en: The object that is inserted into the pipeline is an `HttpContext` instance that
    contains the data of the incoming request. More specifically, the `Request` property
    of `HttpContext` contains an `HttpRequest` object whose properties represent the
    incoming request in a structured way. There are properties for headers, cookies,
    request path, parameters, form fields, and the request body.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 插入到管道中的对象是包含传入请求数据的`HttpContext`实例。更具体地说，`HttpContext`的`Request`属性包含一个`HttpRequest`对象，其属性以结构化方式表示传入请求。有关标头、cookie、请求路径、参数、表单字段和请求正文的属性。
- en: The various modules can contribute to the construction of the final response
    if we write them in an `HttpResponse` object contained in the `Response` property
    of the `HttpContext` instance. The `HttpResponse` class is similar to the `HttpRequest`
    class, but its properties refer to the response being built.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将它们写入`HttpContext`实例的`Response`属性中包含的`HttpResponse`对象中，各种模块可以为最终响应的构建做出贡献。`HttpResponse`类类似于`HttpRequest`类，但其属性指的是正在构建的响应。
- en: Some modules can build an intermediate data structure that is then used by other
    modules in the pipeline. In general, such intermediary data can be stored in custom
    entries of `IDictionary<object, object>`, which is contained in the `Items` property
    of the `HttpContext` object. However, there is a predefined property, `User`,
    that contains information about the currently logged-in user. The logged-in user
    is not computed automatically, so they must be computed by an authentication module.
    The *ASP.NET Core service authorization* subsection of *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*, explained how to add the standard
    module that performs JWT token-based authentication to the ASP.NET Core pipeline.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模块可以构建一个中间数据结构，然后由管道中的其他模块使用。一般来说，这样的中间数据可以存储在`HttpContext`对象的`Items`属性中包含的`IDictionary<object,
    object>`的自定义条目中。但是，有一个预定义的属性`User`，其中包含有关当前登录用户的信息。已登录用户不会自动计算，因此它们必须由身份验证模块计算。*第14章*的*应用.NET
    Core实现面向服务的架构*的*ASP.NET Core服务授权*子部分解释了如何向ASP.NET Core管道添加执行基于JWT令牌的身份验证的标准模块。
- en: '`HttpContext` also has a `Connection` property that contains information on
    the underlying connection established with the client, as well as a `WebSockets`
    property that contains information on possible WebSocket-based connections established
    with the clients.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpContext`还有一个`Connection`属性，其中包含与客户端建立的基础连接的信息，以及一个`WebSockets`属性，其中包含与客户端建立的可能的基于WebSocket的连接的信息。'
- en: '`HttpContext` also has a `Features` property that contains `IDictionary<Type,
    object>`, which specifies the features supported by the web server that hosts
    the web application and the modules of the pipeline. Features can be set with
    the `.Set<TFeature>(TFeature o)` method and can be retrieved with the `.Get<TFeature>()`
    method.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpContext`还有一个`Features`属性，其中包含`IDictionary<Type, object>`，指定了托管Web应用程序和管道模块的Web服务器支持的功能。功能可以使用`.Set<TFeature>(TFeature
    o)`方法进行设置，并可以使用`.Get<TFeature>()`方法进行检索。'
- en: Web server features are automatically added by the framework, while all other
    features are added by pipeline modules when they process `HttpContext`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器功能是由框架自动添加的，而所有其他功能是在处理`HttpContext`时由管道模块添加的。
- en: '`HttpContext` also gives us access to the dependency injection engine through
    its `RequestServices` property. You can get an instance of a type managed by the
    dependency engine by calling the `.RequestService.GetService(Type t)` method or,
    even better, the `.GetRequiredService<TService>()` extension method that is built
    on top of it. However, as we will see in the remainder of this chapter, all types
    managed by the dependency injection engine are usually automatically injected
    into constructors, so these methods are only used when we''re building custom
    **middleware** or other customizations of the ASP.NET Core engine.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpContext`还通过其`RequestServices`属性为我们提供了对依赖注入引擎的访问。您可以通过调用`.RequestService.GetService(Type
    t)`方法或者更好的是建立在其之上的`.GetRequiredService<TService>()`扩展方法来获取由依赖引擎管理的类型的实例。然而，正如我们将在本章的其余部分中看到的那样，所有由依赖注入引擎管理的类型通常都会自动注入到构造函数中，因此这些方法仅在构建自定义**中间件**或其他自定义ASP.NET
    Core引擎时使用。'
- en: The `HttpContext` instance that is created for processing a web request is not
    only available to modules, but also to the application code through DI. It is
    enough to insert an `IHttpContextAccessor` parameter into the constructor of a
    class that is automatically dependency injected, such as a service passed to a
    controller (see later on in this section), and then access its `HttpContext` property.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问`HttpContext`属性，不仅模块可以访问`HttpContext`实例，应用程序代码也可以通过DI访问。只需将`IHttpContextAccessor`参数插入到自动依赖注入的类的构造函数中，例如传递给控制器的服务（稍后在本节中），然后访问其`HttpContext`属性。
- en: 'A module is any class with the following structure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是具有以下结构的任何类：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In general, each module processes the `HttpContext` instance that was passed
    by the previous module in the pipeline, then calls `await _next.Invoke(context)`
    to invoke the modules in the remainder of the pipeline. When the other modules
    have finished their processing and the response for the client has been prepared,
    each module can perform further post-processing of the response in the code that
    follows the `_next.Invoke(context)` call.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个模块处理由管道中前一个模块传递的`HttpContext`实例，然后调用`await _next.Invoke(context)`来调用管道中其余模块。当其他模块完成其处理并为客户端准备好响应时，每个模块可以在`_next.Invoke(context)`调用后的代码中执行进一步的响应后处理。
- en: 'Modules are registered in the ASP.NET Core pipeline by calling the `UseMiddleware<T>`
    method in the `Startup.cs` file''s `Configure` method, as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`Startup.cs`文件的`Configure`方法中调用`UseMiddleware<T>`方法，可以在ASP.NET Core管道中注册模块，如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Modules are inserted into the pipeline in the same order when `UseMiddleware`
    is called. Since each functionality that''s added to an application might require
    several modules and might require operations other than adding modules, you usually
    define an `IApplicationBuilder` extension such as `UseMyFunctionality`, as shown
    in the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`UseMiddleware`时，模块以相同的顺序插入到管道中。由于添加到应用程序的每个功能可能需要多个模块，并且可能需要除添加模块之外的其他操作，通常会定义一个`IApplicationBuilder`扩展，例如`UseMyFunctionality`，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After that, the whole functionality can be added to the application by calling
    `app.UseMyFunctionality(...)`. For instance, the ASP.NET Core MVC functionality
    can be added to the ASP.NET Core pipeline by calling `app.UseEndpoints(....)`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以通过调用`app.UseMyFunctionality(...)`将整个功能添加到应用程序中。例如，可以通过调用`app.UseEndpoints(....)`将ASP.NET
    Core MVC功能添加到ASP.NET Core管道中。
- en: 'Often, functionalities that are added with each `app.Use...` require that some
    .NET types are added to the application DI engine. In these cases, we also define
    an `IServiceCollection` extension named `AddMyFunctionality`, which must be called
    in the `Startup.cs` file''s `ConfigureServices(IServiceCollection services)` method.
    For instance, ASP.NET Core MVC requires a call like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用每个`app.Use...`添加的功能需要将一些.NET类型添加到应用程序DI引擎中。在这些情况下，我们还定义了一个名为`AddMyFunctionality`的`IServiceCollection`扩展，必须在`Startup.cs`文件的`ConfigureServices(IServiceCollection
    services)`方法中调用。例如，ASP.NET Core MVC需要像下面这样的调用：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you don't need to change the default MVC options, you can simply call `services.AddControllersWithViews()`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要更改默认的MVC选项，可以简单地调用`services.AddControllersWithViews()`。
- en: The next subsection describes another important feature of the ASP.NET Core
    framework; namely, how to handle application configuration data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节描述了ASP.NET Core框架的另一个重要功能，即如何处理应用程序配置数据。
- en: Loading configuration data and using it with the options framework
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载配置数据并使用选项框架
- en: 'When an ASP.NET Core application starts, it reads configuration information
    (such as a database connection string) from the `appsettings.json` and `appsettings.[EnvironmentName].json`
    files, where `EnvironmentName` is a string value that depends on where the application
    is deployed. Typical values for `EnvironmentName` are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当ASP.NET Core应用程序启动时，它会从`appsettings.json`和`appsettings.[EnvironmentName].json`文件中读取配置信息（例如数据库连接字符串），其中`EnvironmentName`是取决于应用程序部署位置的字符串值。`EnvironmentName`的典型值如下：
- en: '`Production` is used for production deployment'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Production` 用于生产部署'
- en: '`Development` is used during development'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Development` 用于开发时'
- en: '`Staging` is used when the application is tested in staging'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Staging` 用于在测试阶段测试应用程序'
- en: The two JSON trees that were extracted from the `appsettings.json` and `appsettings.[EnvironmentName].json`
    files are merged into a unique tree, where the values contained in `[EnvironmentName].json`
    override the values contained in the corresponding paths of `appsettings.json`.
    This way, the application can be run with different configurations in different
    deployment environments. In particular, you may use a different database connection
    string, and hence, a different database instance in each different environment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从`appsettings.json`和`appsettings.[EnvironmentName].json`文件中提取的两个JSON树合并为一个唯一的树，其中`[EnvironmentName].json`中包含的值会覆盖`appsettings.json`相应路径中包含的值。这样，应用程序可以在不同的部署环境中以不同的配置运行。特别是，您可以在每个不同的环境中使用不同的数据库连接字符串，因此在每个不同的环境中使用不同的数据库实例。
- en: 'The `[EnvironmentName]` string is taken from the `ASPNETCORE_ENVIRONMENT` operating
    system environment variable. In turn, `ASPNETCORE_ENVIRONMENT` can be automatically
    set during the application''s deployment with Visual Studio in two ways:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`[EnvironmentName]`字符串取自`ASPNETCORE_ENVIRONMENT`操作系统环境变量。反过来，`ASPNETCORE_ENVIRONMENT`可以在应用程序部署期间通过Visual
    Studio的两种方式自动设置：'
- en: During Visual Studio deployment, Visual Studio's **Publish** wizard creates
    an XML publish profile. If the **Publish** wizard allows you to choose `ASPNETCORE_ENVIRONMENT`
    from its drop-down list, you are done:![](img/B16756_15_02.png)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio部署期间，Visual Studio的**发布**向导会创建一个XML发布配置文件。如果**发布**向导允许您从下拉列表中选择`ASPNETCORE_ENVIRONMENT`，那么您就完成了！[](img/B16756_15_02.png)
- en: 'Figure 15.2: Visual Studio deployment settings'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：Visual Studio部署设置
- en: 'Otherwise, you may proceed as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以按照以下步骤进行：
- en: Once you've filled in the information in the wizard, save the publish profile
    without publishing it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向导中填写信息后，保存发布配置文件而不进行发布。
- en: Then, edit the profile with a text editor and add an XML property such as `<EnvironmentName>Staging</EnvironmentName>`.
    Since all the already defined publish profiles can be selected during the application's
    publication, you may define a different publish profile for each of your environments,
    and then you may select the one you need during each publication.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用文本编辑器编辑配置文件并添加XML属性，例如`<EnvironmentName>Staging</EnvironmentName>`。由于应用程序发布期间可以选择所有已定义的发布配置文件，因此您可以为每个环境定义不同的发布配置文件，然后在每次发布时选择所需的配置文件。
- en: 'The value you must set `ASPNETCORE_ENVIRONMENT` to during deployment can also
    be specified in the Visual Studio ASP.NET Core project file (`.csproj`) of your
    application by adding the following code:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序的Visual Studio ASP.NET Core项目文件（`.csproj`）中添加以下代码，可以指定部署期间必须将`ASPNETCORE_ENVIRONMENT`设置为的值：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'During development in Visual Studio, the value to give to `ASPNETCORE_ENVIRONMENT`
    when the application is run can be specified in the `Properties\launchSettings.json`
    file of the ASP.NET Core project. The `launchSettings.json` file contains several
    named groups of settings. These settings configure how to launch the web application
    when it is run from Visual Studio. You may choose to apply all the settings of
    a group by selecting the group name with the drop-down list next to Visual Studio''s
    run button:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中进行开发时，可以在ASP.NET Core项目的`Properties\launchSettings.json`文件中指定应用程序运行时要给`ASPNETCORE_ENVIRONMENT`的值。`launchSettings.json`文件包含几个命名的设置组。这些设置配置了在从Visual
    Studio运行Web应用程序时如何启动。您可以通过选择运行按钮旁边的下拉列表中的组名来应用组的所有设置：
- en: '![](img/B16756_15_03.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_15_03.png)'
- en: 'Figure 15.3: Choice of launch settings group'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：启动设置组的选择
- en: Your selection from this drop-down list will be shown in the run button, with
    the default selection being **IIS Express**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您从下拉列表中的选择将显示在运行按钮上，默认选择为**IIS Express**。
- en: 'The following code shows a typical `launchSettings.json` file in which you
    can either add a new group of settings or change the settings of the existing
    default groups:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了一个典型的`launchSettings.json`文件，您可以在其中添加新的设置组或更改现有默认组的设置：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The named groups of settings are under the `profiles` properties. There, you
    may choose where to host the application (`IISExpress`), where to launch the browser,
    and the values of some environment variables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 命名的设置组位于`profiles`属性下。在那里，您可以选择在哪里托管应用程序（`IISExpress`），在哪里启动浏览器以及一些环境变量的值。
- en: The current environment that's been loaded from the `ASPNETCORE_ENVIRONMENT`
    operating system environment variable can be tested through the `IWebHostEnvironment`
    interface during the ASP.NET Core pipeline definition. This is because an `IWebHostEnvironment`
    instance is passed as a parameter to the `Startup.cs` file's `Configure` method.
    `IWebHostEnvironment` is also available to the remainder of the user code through
    DI.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`IWebHostEnvironment`接口可以在ASP.NET Core管道定义期间测试从`ASPNETCORE_ENVIRONMENT`操作系统环境变量中加载的当前环境。这是因为`IWebHostEnvironment`实例作为参数传递给`Startup.cs`文件的`Configure`方法。`IWebHostEnvironment`也通过DI对用户代码的其余部分可用。
- en: '`IWebHostEnvironment.IsEnvironment(string environmentName)` checks whether
    the current value of `ASPNETCORE_ENVIRONMENT` is `environmentName`. There are
    also specific shortcuts for testing development (`.IsDevelopment()`), production
    (`.IsProduction()`), and staging (`.IsStaging()`). `IWebHostEnvironment` also
    contains the current root directory of the ASP.NET Core application (`.WebRootPath`)
    and the directory reserved for the static files (`.ContentRootPath`) that are
    served as-is by the web server (CSS, JavaScript, images, and so on).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`IWebHostEnvironment.IsEnvironment(string environmentName)`检查`ASPNETCORE_ENVIRONMENT`的当前值是否为`environmentName`。还有特定的快捷方式用于测试开发（`.IsDevelopment()`）、生产（`.IsProduction()`）和暂存（`.IsStaging()`）。`IWebHostEnvironment`还包含ASP.NET
    Core应用程序的当前根目录（`.WebRootPath`）和用于静态文件的目录（`.ContentRootPath`），这些文件由Web服务器原样提供（CSS、JavaScript、图像等）。'
- en: 'Both `launchSettings.json` and all publish profiles can be accessed as children
    of the **Properties** node in Visual Studio Explorer, as shown in the following
    screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio资源管理器中，`launchSettings.json`和所有发布配置文件都可以作为**Properties**节点的子节点访问，如下截图所示：
- en: '![](img/B16756_15_04.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_15_04.png)'
- en: 'Figure 15.4: Launch settings file'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：启动设置文件
- en: 'Once `appsettings.json` and `appsettings.[EnvironmentName].json` have been
    loaded, the configuration tree resulting from their merge can be mapped to the
    properties of .NET objects. For example, let''s suppose we have an `Email` section
    of the `appsettings` file that contains all of the information needed to connect
    to an email server, as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`appsettings.json`和`appsettings.[EnvironmentName].json`被加载，它们合并后的配置树可以映射到.NET对象的属性上。例如，假设我们在`appsettings`文件中有一个`Email`部分，其中包含连接到电子邮件服务器所需的所有信息，如下所示：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, the whole `Email` section can be mapped to an instance of the following
    class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，整个`Email`部分可以映射到以下类的实例：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code that performs the mapping must be inserted into the `ConfigureServices`
    method in the `Startup.cs` file since the `EmailConfig` instance will be available
    through DI. The code we need is shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 执行映射的代码必须插入到`Startup.cs`文件的`ConfigureServices`方法中，因为`EmailConfig`实例将通过DI可用。我们需要的代码如下所示：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once we've configured the preceding settings, classes that need `EmailConfig`
    data must declare an `IOptions<EmailConfig> options` parameter that will be provided
    by the DI engine. An `EmailConfig` instance is contained in `options.Value`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置了上述设置，需要`EmailConfig`数据的类必须声明一个由DI引擎提供的`IOptions<EmailConfig> options`参数。`EmailConfig`实例包含在`options.Value`中。
- en: It is worth mentioning that the option classes' properties can be applied to
    the same validation attributes we will use for ViewModels (see the *Server-side
    and client-side validation* subsection).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，选项类的属性可以应用于我们将用于ViewModels的相同验证属性（参见*服务器端和客户端验证*小节）。
- en: The next subsection describes the basic ASP.NET Core pipeline modules needed
    by an ASP.NET Core MVC application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节描述了ASP.NET Core MVC应用程序所需的基本ASP.NET Core管道模块。
- en: Defining the ASP.NET Core MVC pipeline
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义ASP.NET Core MVC管道
- en: If you create a new ASP.NET Core MVC project in Visual Studio, a standard pipeline
    is created in the `Startup.cs` file's `Configure` method. There, if needed, you
    may add further modules or change the configuration of the existing modules.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Visual Studio中创建一个新的ASP.NET Core MVC项目，在`Startup.cs`文件的`Configure`方法中会创建一个标准管道。在那里，如果需要，可以添加更多模块或更改现有模块的配置。
- en: 'The initial code of the `Configure` method handles errors and performs basic
    HTTPS configuration:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Configure`方法的初始代码处理错误并执行基本的HTTPS配置：'
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If there are errors, if the application is in a development environment, the
    module installed by `UseDeveloperExceptionPage` adds a detailed error report to
    the response. This module is a valuable debugging tool.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有错误，如果应用程序处于开发环境中，`UseDeveloperExceptionPage`安装的模块会向响应中添加详细的错误报告。这个模块是一个有价值的调试工具。
- en: If an error occurs when the application is not in development mode, `UseExceptionHandler`
    restores the request processing from the path it receives as an argument; that
    is, from `/Home/Error`. In other words, it simulates a new request with the `/Home/Error`
    path. This request is pushed into the standard MVC processing until it reaches
    the endpoint associated with the `/Home/Error` path, where the developer is expected
    to place the custom code that handles the error.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序在非开发模式下发生错误，`UseExceptionHandler`将从接收到的路径恢复请求处理；也就是说，从`/Home/Error`开始。换句话说，它模拟了一个带有`/Home/Error`路径的新请求。此请求被推送到标准MVC处理，直到达到与`/Home/Error`路径相关联的端点，开发人员应该在那里放置处理错误的自定义代码。
- en: 'When the application is not in development, `UseHsts` adds the `Strict-Transport-Security`
    header to the response, which informs the browser that the application must only
    be accessed with HTTPS. After this declaration, compliant browsers should automatically
    convert any HTTP request of the application into an HTTPS request for the time
    specified in the `Strict-Transport-Security` header. By default, `UseHsts` specifies
    30 days as the time in the header, but you may specify a different time and other
    header parameters by adding an `options` object to the `ConfigureServices` method
    of `Startup.cs`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序不处于开发模式时，`UseHsts`会向响应中添加`Strict-Transport-Security`头，通知浏览器只能使用HTTPS访问应用程序。声明后，符合规范的浏览器应自动将应用程序的任何HTTP请求转换为`Strict-Transport-Security`头中指定的时间内的HTTPS请求。默认情况下，`UseHsts`在头中指定30天的时间，但您可以通过向`Startup.cs`的`ConfigureServices`方法添加一个`options`对象来指定不同的时间和其他头参数。
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`UseHttpsRedirection` causes an automatic redirection to an HTTPS URL when
    an HTTP URL is received, in a way that forces a secure connection. Once the first
    HTTPS secure connection is established, the `Strict-Transport-Security` header
    prevents future redirections that might be used to perform man-in-the-middle attacks.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseHttpsRedirection`在接收到HTTP URL时会自动重定向到HTTPS URL，以强制进行安全连接。一旦建立了第一个HTTPS安全连接，`Strict-Transport-Security`头将阻止未来可能用于执行中间人攻击的重定向。'
- en: 'The following code shows the remainder of the default pipeline:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了默认管道的其余部分：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`UseStaticFiles` makes all files contained in the `wwwroot` folder of the project
    (typically CSS, JavaScript, images, and font files) accessible from the web through
    their actual path.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseStaticFiles` 使项目中 `wwwroot` 文件夹中包含的所有文件（通常是 CSS、JavaScript、图像和字体文件）通过其实际路径从
    web 访问。'
- en: '`UseCookiePolicy` has been removed in the .NET 5 template, but you can still
    add it manually. It ensures that cookies are processed by the ASP.NET Core pipeline,
    but only if the user has given consent for cookie usage. Consent to cookie usage
    is given through a consent cookie; that is, cookie processing is enabled only
    if this consent cookie is found among the request cookies. This cookie must be
    created by JavaScript when the user clicks a consent button. The whole string
    that contains both the consent cookie''s name and its contents can be retrieved
    from `HttpContext.Features`, as shown in the following snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseCookiePolicy` 在 .NET 5 模板中已被移除，但您仍然可以手动添加。它确保 ASP.NET Core 管道处理 cookie，但仅在用户已经同意使用
    cookie 的情况下。对 cookie 使用的同意是通过同意 cookie 给出的；也就是说，只有在请求 cookie 中找到此同意 cookie 时才启用
    cookie 处理。当用户单击同意按钮时，此 cookie 必须由 JavaScript 创建。包含同意 cookie 名称及其内容的整个字符串可以从 `HttpContext.Features`
    中检索，如下面的代码片段所示：'
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`CanTrack` is `true` only if consent is required and has not been given yet.
    When the consent cookie is detected, `CanTrack` is set to `false`. This way, `showBanner`
    is `true` only if consent is required and it has not been given yet. Therefore,
    it tells us whether to ask the user for consent or not.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在需要同意且尚未给出同意时，`CanTrack` 才为 `true`。检测到同意 cookie 时，`CanTrack` 被设置为 `false`。这样，只有在需要同意且尚未给出同意时，`showBanner`
    才为 `true`。因此，它告诉我们是否要向用户请求同意。
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`UseAuthentication` enables authentication schemes and only appears if you
    select an authentication scheme when the project is created.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseAuthentication` 启用身份验证方案，仅在创建项目时选择身份验证方案时才会出现。'
- en: 'Specific authentication schemes can be enabled by configuring the options objects
    in the `ConfigureServices` method, as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 `ConfigureServices` 方法中配置选项对象来启用特定的身份验证方案，如下所示：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code specifies a custom authentication cookie name and adds JWT-based
    authentication for the REST service contained in the application. Both `AddCookie`
    and `AddJwtBearer` have overloads that accept the name of the authentication scheme
    before the action, which is where you can define the authentication scheme options.
    Since the authentication scheme name is necessary for referring to a specific
    authentication scheme, when it is not specified, a default name is used:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码指定了自定义身份验证 cookie 名称，并为应用程序中包含的 REST 服务添加了基于 JWT 的身份验证。`AddCookie` 和 `AddJwtBearer`
    都有重载，可以在操作之前接受身份验证方案的名称，这是您可以定义身份验证方案选项的地方。由于身份验证方案名称是指定特定身份验证方案的必要条件，因此在未指定时会使用默认名称：
- en: The standard name contained in `CookieAuthenticationDefaults.AuthenticationScheme`
    for cookie authentication.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CookieAuthenticationDefaults.AuthenticationScheme` 中包含的 cookie 身份验证的标准名称。'
- en: The standard name contained in `JwtBearerDefaults.AuthenticationScheme` for
    JWT authentication.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JwtBearerDefaults.AuthenticationScheme` 中包含的 JWT 身份验证的标准名称。'
- en: The name that's passed into `o.DefaultScheme` selects the authentication scheme
    used for filling the `User` property of `HttpContext`. Together with `DefaultScheme`,
    there are other properties that allow more advanced customizations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `o.DefaultScheme` 的名称选择用于填充 `HttpContext` 的 `User` 属性的身份验证方案。除了 `DefaultScheme`，还有其他属性允许进行更高级的自定义。
- en: For more information about JWT authentication, please refer to the *ASP.NET
    Core service authorization* subsection of *Chapter 14*, *Applying Service-Oriented
    Architectures with .NET Core*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 JWT 身份验证的更多信息，请参阅 *第 14 章* *使用 .NET Core 应用服务导向架构* 的 *ASP.NET Core 服务授权*
    子章节。
- en: If you just specify `services.AddAuthentication()`, a cookie-based authentication
    with default parameters is assumed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只指定 `services.AddAuthentication()`，则假定使用具有默认参数的基于 cookie 的身份验证。
- en: '`UseAuthorization` enables authorization based on the `Authorize` attribute.
    Options can be configured by placing the `AddAuthorization` method in the `ConfigureServices`
    method. These options allow you to define the policies for claims-based authorization.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseAuthorization` 启用基于 `Authorize` 属性的授权。可以通过在 `ConfigureServices` 方法中放置 `AddAuthorization`
    方法来配置选项。这些选项允许您定义基于声明的授权策略。'
- en: For more information on authorization, please refer to the *ASP.NET Core service
    authorization* subsection of *Chapter 14*, *Applying Service-Oriented Architectures
    with .NET Core*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有关授权的更多信息，请参阅 *第 14 章* *使用 .NET Core 应用服务导向架构* 的 *ASP.NET Core 服务授权* 子章节。
- en: '`UseRouting` and `UseEndpoints` handle the so-called ASP.NET Core endpoints.
    An endpoint is an abstraction of a handler that serves specific classes of URLs.
    These URLs are transformed into an `Endpoint` instance with patterns. When a pattern
    matches a URL, an `Endpoint` instance is created and filled with both the pattern''s
    name and the data that was extracted from the URL. This is a consequence of matching
    URL parts with named parts of the pattern. This can be seen in the following code
    snippet:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseRouting` 和 `UseEndpoints` 处理所谓的 ASP.NET Core 端点。端点是服务特定类的 URL 的处理程序的抽象。这些
    URL 被转换为具有模式的 `Endpoint` 实例。当模式与 URL 匹配时，将创建 `Endpoint` 实例，并填充模式的名称和从 URL 提取的数据。这是将
    URL 部分与模式的命名部分进行匹配的结果。这可以在以下代码片段中看到：'
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`UseRouting` adds a module that processes the request path to get the request
    `Endpoint` instance and adds it to the `HttpContext.Features` dictionary under
    the `IEndpointFeature` type. The actual `Endpoint` instance is contained in the
    `Endpoint` property of `IEndpointFeature`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseRouting` 添加一个模块，用于处理请求路径以获取请求的 `Endpoint` 实例，并将其添加到 `HttpContext.Features`
    字典中的 `IEndpointFeature` 类型下。实际的 `Endpoint` 实例包含在 `IEndpointFeature` 的 `Endpoint`
    属性中。'
- en: Each pattern also contains the handler that should process all the requests
    that match the pattern. This handler is passed to `Endpoint` when it is created.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模式还包含应处理与模式匹配的所有请求的处理程序。创建`Endpoint`时，将此处理程序传递给`Endpoint`。
- en: On the other hand, `UseEndpoints` adds the middleware that executes the route
    determined by the `UseRouting` logic. It is placed at the end of the pipeline
    since its middleware produces the final response. Splitting the routing logic
    into two separate middleware modules enables authorization middleware to sit in-between
    them and, based on the matched endpoint, to decide whether to pass the request
    to the `UseEndpoints` middleware for its normal execution, or whether to return
    a 401 (Unauthorized)/403 (Forbidden) response immediately.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`UseEndpoints`添加了执行由`UseRouting`逻辑确定的路由的中间件。它放置在管道的末尾，因为其中间件生成最终响应。将路由逻辑拆分为两个单独的中间件模块使得授权中间件可以坐在它们之间，并根据匹配的端点决定是否将请求传递给`UseEndpoints`中间件进行正常执行，还是立即返回401（未经授权）/403（禁止）响应。
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`MapControllerRoute` defines the patterns associated with the MVC engine, which
    will be described in the next subsection. There are other methods that define
    other types of patterns. A call such as `.MapHub<MyHub>("/chat")` maps paths to
    hubs that handle **SignalR**, an abstraction built on top of `WebSocket`, whereas
    `.MapHealthChecks("/health")` maps paths to ASP.NET Core components that return
    application health data. You can also directly map a pattern to a custom handler
    with `.MapGet`, which intercepts GET requests, and `.MapPost`, which intercepts
    POST requests. This is called **route to code**. The following is an example of
    `MapGet`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapControllerRoute`定义了与MVC引擎相关的模式，这将在下一小节中描述。还有其他定义其他类型模式的方法。例如，像`.MapHub<MyHub>("/chat")`这样的调用将路径映射到处理**SignalR**的hub，这是建立在`WebSocket`之上的抽象，而`.MapHealthChecks("/health")`将路径映射到返回应用程序健康数据的ASP.NET
    Core组件。您还可以直接将模式映射到自定义处理程序，例如`.MapGet`拦截GET请求，`.MapPost`拦截POST请求。这称为**路由到代码**。以下是`MapGet`的示例：'
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Patterns are processed in the order in which they are defined until a matching
    pattern is found. Since the authentication/authorization middleware is placed
    after the routing middleware, it can process the `Endpoint` request to verify
    whether the current user has the required authorizations to execute the `Endpoint`
    handler. Otherwise, a 401 (Unauthorized) or 403 (Forbidden) response is immediately
    returned. Only requests that survive authentication and authorization have their
    handlers executed by the `UseEndpoints` middleware.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 模式按照定义的顺序进行处理，直到找到匹配的模式为止。由于身份验证/授权中间件放置在路由中间件之后，它可以处理`Endpoint`请求，以验证当前用户是否具有执行`Endpoint`处理程序所需的授权。否则，将立即返回401（未经授权）或403（禁止）响应。只有通过身份验证和授权的请求才会由`UseEndpoints`中间件执行其处理程序。
- en: 'With the ASP.NET Core RESTful API described in *Chapter 14*, *Applying Service-Oriented
    Architectures with .NET Core*, ASP.NET Core MVC also uses attributes placed on
    controllers or controller methods to specify authorization rules. However, an
    instance of `AuthorizeAttribute` can be also added to a pattern to apply its authorization
    constraints to all the URLs matching that pattern, as shown in the following example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第14章*中描述的ASP.NET Core RESTful API中，ASP.NET Core MVC还使用放置在控制器或控制器方法上的属性来指定授权规则。但是，也可以将`AuthorizeAttribute`的实例添加到模式中，以将其授权约束应用于匹配该模式的所有URL，如下例所示：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code makes the health check path available only to administrative
    users.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使健康检查路径仅对管理员用户可用。
- en: Having described the basic structure of the ASP.NET Core framework, we can now
    move toward more MVC-specific features. The next subsection describes controllers
    and explains how they interact with the UI components known as Views through ViewModels.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述了ASP.NET Core框架的基本结构之后，我们现在可以转向更多MVC特定的功能。下一小节描述了控制器，并解释了它们如何通过ViewModel与称为Views的UI组件进行交互。
- en: Defining controllers and ViewModels
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义控制器和ViewModels
- en: The various `.MapControllerRoute` calls in `UseEndpoints` associate URL patterns
    with controllers and with the methods of these controllers, where controllers
    are classes that inherit from the `Microsoft.AspNetCore.Mvc.Controller` class.
    Controllers are discovered by inspecting all of the application's `.dll` files
    and are added to the DI engine. This job is performed by the call to `AddControllersWithViews`
    in the `ConfigureServices` method of the `startup.cs` file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseEndpoints`中的各种`.MapControllerRoute`调用将URL模式与控制器及这些控制器的方法关联起来，其中控制器是从`Microsoft.AspNetCore.Mvc.Controller`类继承的类。控制器是通过检查应用程序的所有`.dll`文件并将其添加到DI引擎来发现的。这项工作是由`startup.cs`文件的`ConfigureServices`方法中对`AddControllersWithViews`的调用执行的。'
- en: The pipeline module that's added by `UseEndpoints` takes the controller name
    from the `controller` pattern variable, and the name of the controller method
    to invoke from the `action` pattern variable. Since, by convention, all controller
    names are expected to end with the `Controller` suffix, the actual controller
    type name is obtained from the name found in the `controller` variable by adding
    this suffix. Hence, for instance, if the name found in `controller` is `"Home"`,
    then the `UseEndpoints` module tries to get an instance of the `HomeController`
    type from the DI engine. All of the controller public methods can be selected
    by the routing rules. Use of a controller public method can be prevented by decorating
    it with the `[NonAction]` attribute. All controller methods available to the routing
    rules are called action methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseEndpoints`添加的管道模块从`controller`模式变量中获取控制器名称，并从`action`模式变量中获取要调用的控制器方法的名称。由于按照惯例，所有控制器名称都应以`Controller`后缀结尾，因此实际的控制器类型名称是通过在`controller`变量中找到的名称后添加此后缀来获得的。因此，例如，如果在`controller`中找到的名称是`"Home"`，那么`UseEndpoints`模块会尝试从DI引擎中获取`HomeController`类型的实例。路由规则可以选择所有控制器的公共方法。通过使用`[NonAction]`属性装饰，可以防止使用控制器的公共方法。路由规则可用的所有控制器方法都称为操作方法。'
- en: MVC controllers work like the API controllers that we described in the *Implementing
    REST services with ASP.NET Core* subsection of *Chapter 14*, *Applying Service-Oriented
    Architectures with .NET Core*. The only difference is that API controllers are
    expected to produce JSON or XML, while MVC controllers are expected to produce
    HTML. For this reason, while API controllers inherit from the `ControllerBase`
    class, MVC controllers inherit from the `Controller` class, which, in turn, inherits
    from the `ControllerBase` class and adds its methods that are useful for HTML
    generation, such as invoking views, which are described in the next subsection,
    and creating a redirect response.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: MVC控制器的工作方式类似于我们在*第14章*的*使用.NET Core实现REST服务*中描述的API控制器。唯一的区别是API控制器预期生成JSON或XML，而MVC控制器预期生成HTML。因此，虽然API控制器继承自`ControllerBase`类，但MVC控制器继承自`Controller`类，后者又继承自`ControllerBase`类，并添加了对HTML生成有用的方法，例如调用视图，在下一小节中描述，并创建重定向响应。
- en: MVC controllers may also use a routing technique similar to one of the API controllers;
    that is, routing based on controllers and controller method attributes. This behavior
    is enabled by calling the `MapControllerRoute()` method in `UseEndpoints`. If
    this call is placed before all other `MapControllerRoute` calls, then the controller
    routes have priority on `MapControllerRoute` patterns; otherwise, the opposite
    is true.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: MVC控制器也可以使用类似于API控制器之一的路由技术；即基于控制器和控制器方法属性的路由。通过在`UseEndpoints`中调用`MapControllerRoute()`方法来启用此行为。如果此调用放置在所有其他`MapControllerRoute`调用之前，则控制器路由优先于`MapControllerRoute`模式；否则，情况相反。
- en: All the attributes we have seen for API controllers can be also used with MVC
    controllers and action methods (`HttpGet`, `HttpPost`, `...Authorize`, and so
    on). Developers can write their own custom attributes by inheriting from the `ActionFilter`
    class or other derived classes. I will not give details on this right now, but
    these details can be found in the official documentation, which is referred to
    in the *Further reading* section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在API控制器中看到的所有属性也可以用于MVC控制器和动作方法（`HttpGet`，`HttpPost`，`...Authorize`等）。开发人员可以通过继承`ActionFilter`类或其他派生类来编写自定义属性。我现在不会详细介绍这些内容，但这些细节可以在官方文档中找到，官方文档在*进一步阅读*部分中有提到。
- en: When the `UseEndpoints` module invokes a controller, all of its constructor
    parameters are filled by the DI engine since the controller instance itself is
    returned by the DI engine, and since DI automatically fills constructor parameters
    with DI in a recursive fashion.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当`UseEndpoints`模块调用控制器时，由于控制器实例本身是由DI引擎返回的，因此所有构造函数参数都由DI引擎填充，并且由于DI会以递归方式自动填充构造函数参数。
- en: 'Action method parameters, on the other hand, are taken from the following sources:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，动作方法参数来自以下来源：
- en: Request headers
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求标头
- en: Variables in the pattern matched by the current request
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前请求匹配的模式中的变量
- en: Query string parameters
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询字符串参数
- en: Form parameters (in the case of POST requests)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单参数（在POST请求的情况下）
- en: Dependency injection (DI)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入（DI）
- en: While the parameters filled with DI are matched by type, all other parameters
    are matched by *name* while ignoring the letter casing. That is, the action method
    parameter name must match the header, query string, form, or pattern variable.
    When the parameter is a complex type, a match is searched for in each property,
    using the property name for the match. In the case of nested complex types, a
    match is searched for each nested property's path, and the name associated with
    the path is obtained by chaining all the property names in the path and separating
    them with dots. For instance, `Property1.Property2.Property3...Propertyn` is the
    name associated with a path composed by the nested properties `Property1`, `Property2`,
    ...., `Propertyn`. The name that's obtained this way must match a header name,
    pattern variable name, query string parameter name, and so on. For instance, an
    `OfficeAddress` property containing a complex `Address` object would generate
    names like `OfficeAddress.Country`, `OfficeAddress.Town`, and so on.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DI填充的参数按类型匹配，而所有其他参数按*名称*匹配，忽略字母大小写。也就是说，动作方法参数名称必须与标头、查询字符串、表单或模式变量匹配。当参数是复杂类型时，将在每个属性中搜索匹配，使用属性名称进行匹配。在嵌套复杂类型的情况下，将在每个嵌套属性的路径中搜索匹配，并且与路径相关联的名称是通过将路径中的所有属性名称链接在一起并用点分隔来获得的。例如，`Property1.Property2.Property3...Propertyn`是由嵌套属性`Property1`、`Property2`、....、`Propertyn`组成的路径相关联的名称。以这种方式获得的名称必须与标头名称、模式变量名称、查询字符串参数名称等匹配。例如，包含复杂`Address`对象的`OfficeAddress`属性将生成名称如`OfficeAddress.Country`、`OfficeAddress.Town`等。
- en: 'By default, simple type parameters are matched with pattern variables and query
    string variables, while complex types parameters are matched with form parameters.
    However, the preceding defaults can be changed by prefixing the parameters with
    attributes, as detailed here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，简单类型参数与模式变量和查询字符串变量匹配，而复杂类型参数与表单参数匹配。然而，可以通过在参数前加上属性来更改前述默认值，如下所述：
- en: '`[FromForm]` forces a match with form parameters'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromForm]` 强制与表单参数匹配'
- en: '`[FromHeader]` forces a match with a request header'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromHeader]` 强制与请求标头匹配'
- en: '`[FromRoute]` forces a match with pattern variables'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromRoute]` 强制与模式变量匹配'
- en: '`[FromQuery]` forces a match with a query string variable'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromQuery]` 强制与查询字符串变量匹配'
- en: '`[FromServices]` forces the use of DI'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromServices]` 强制使用DI'
- en: 'During the match, the string that was extracted from the selected source is
    converted into the type of the action method parameter using the current thread
    culture. If either a conversion fails or no match is found for an obligatory action
    method parameter, then the whole action method invocation process fails, and a
    404 response is automatically returned. For instance, in the following example,
    the `id` parameter is matched with query string parameters or pattern variables
    since it is a simple type, while `myclass` properties and nested properties are
    matched with form parameters since `MyClass` is a complex type. Finally, `myservice`
    is taken from DI since it is prefixed with the `[FromServices]` attribute:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配期间，从所选源中提取的字符串将使用当前线程文化转换为操作方法参数的类型。如果转换失败或者对于必需的操作方法参数找不到匹配项，则整个操作方法调用过程将失败，并且将自动返回404响应。例如，在以下示例中，`id`参数将与查询字符串参数或模式变量匹配，因为它是一个简单类型，而`myclass`属性和嵌套属性将与表单参数匹配，因为`MyClass`是一个复杂类型。最后，`myservice`将从DI中获取，因为它带有`[FromServices]`属性前缀：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If no match is found for the `id` parameter and if the `id` parameter is declared
    as obligatory in the `UseEndpoints` pattern, a 404 response is automatically returned
    since pattern matching fails. It is common to declare parameters as not optional
    when they must match not nullable single types. If, instead, no `MyService` instance
    is found in the DI container, an exception is thrown because in this case, the
    failure doesn't depend on a wrong request but a design error.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`UseEndpoints`模式中找不到`id`参数的匹配项，并且`id`参数在`UseEndpoints`模式中被声明为必需的，由于模式匹配失败，将自动返回404响应。当参数必须匹配非空单一类型时，通常将参数声明为非可选。如果在DI容器中找不到`MyService`实例，则会抛出异常，因为在这种情况下，失败不是由于错误的请求，而是由于设计错误。
- en: MVC controllers return an `IActionResult` interface or a `Task<IActionResult>`
    result if they are declared as `async`. `IActionResult` defines the unique method
    with the `ExecuteResultAsync(ActionContext)` signature, which, when invoked by
    the framework, produces the actual response.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: MVC控制器返回`IActionResult`接口或`Task<IActionResult>`结果，如果它们被声明为`async`。`IActionResult`定义了具有`ExecuteResultAsync(ActionContext)`签名的唯一方法，当由框架调用时，会产生实际的响应。
- en: 'For each different `IActionResult`, MVC controllers have methods that return
    them. The most commonly used `IActionResult` is `ViewResult`, which is returned
    by a `View` method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个不同的`IActionResult`，MVC控制器都有返回它们的方法。最常用的`IActionResult`是`ViewResult`，它是由`View`方法返回的：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`ViewResult` is a very common way for a controller to create an HTML response.
    More specifically, the controller interacts with business/data layers to produce
    an abstraction of the data that will be shown in the HTML page. This abstraction
    is an object called a **ViewModel**. The ViewModel is passed as a second argument
    to the `View` method, while the first argument is the name of an HTML template,
    called View, that is instantiated with the data contained in the ViewModel.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewResult`是控制器创建HTML响应的一种非常常见的方式。更具体地说，控制器与业务/数据层交互，以产生将显示在HTML页面中的数据的抽象。这种抽象是一个称为**ViewModel**的对象。ViewModel作为第二个参数传递给`View`方法，而第一个参数是一个名为View的HTML模板的名称，该模板包含ViewModel中的数据。'
- en: 'Summing this up, the MVC controllers'' processing sequence is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，MVC控制器的处理顺序如下：
- en: The controllers perform some processing to create the ViewModel, which is an
    abstraction of the data to show on the HTML page.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器执行一些处理以创建ViewModel，这是要显示在HTML页面上的数据的抽象。
- en: Then, the controllers create `ViewResult` by passing a View name and ViewModel
    to the `View` method.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，控制器通过将视图名称和ViewModel传递给`View`方法来创建`ViewResult`。
- en: The MVC framework invokes `ViewResult` and causes the template contained in
    the View to be instantiated with the data contained in the ViewModel.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC框架调用`ViewResult`并导致包含在View中的模板与ViewModel中包含的数据实例化。
- en: The result of the template's instantiation is written in the response with adequate
    headers.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板实例化的结果将以适当的标头写入响应。
- en: This way, the controller performs the conceptual job of HTML generation by building
    a ViewModel, while the View – that is, the template – takes care of all the graphical
    details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，控制器通过构建ViewModel执行HTML生成的概念性工作，而视图 - 也就是模板 - 则负责所有的图形细节。
- en: Views will be described in greater detail in the next subsection, while the
    Model (ViewModel) View Controller pattern will be discussed in more detail in
    the *Understanding the connection between ASP.NET Core MVC and design principles*
    section of this chapter. Finally, a practical example will be provided in the
    *Use **case – implementing* *a web app in ASP.NET Core MVC* section of this chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 视图将在下一小节中详细描述，而模型（ViewModel）视图控制器模式将在本章的*理解ASP.NET Core MVC和设计原则之间的联系*部分中更详细地讨论。最后，在本章的*用例
    - 在ASP.NET Core MVC中实现Web应用程序*部分将提供一个实际的例子。
- en: Another common `IActionResult` is `RedirectResult`, which creates a redirect
    response, hence forcing the browser to move to a specific URL. Redirects are often
    used once the user has successfully submitted a form that completes a previous
    operation. In this case, it is common to redirect the user to a page where they
    can select another operation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的`IActionResult`是`RedirectResult`，它创建一个重定向响应，因此强制浏览器转到特定的URL。一旦用户成功提交完成先前操作的表单，通常会使用重定向。在这种情况下，通常会将用户重定向到可以选择另一个操作的页面。
- en: The simplest way to return `RedirectResult` is by passing a URL to the `Redirect`
    method. This is the advised way to perform a redirect to a URL that is outside
    the web application. On the other hand, when the URL is within the web application,
    it is advisable to use the `RedirectToAction` method, which accepts the controller
    name, the action method name, and the desired parameters for the target action
    method. The framework uses this data to compute a URL that causes the desired
    action method to be invoked with the provided parameters. This way, if the routing
    rules are changed during the application's development or maintenance, the new
    URL is automatically updated by the framework with no need to modify all occurrences
    of the old URL in the code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`RedirectResult`最简单的方法是通过将URL传递给`Redirect`方法。这是执行重定向到Web应用程序之外的URL的建议方式。另一方面，当URL在Web应用程序内部时，建议使用`RedirectToAction`方法，该方法接受控制器名称、操作方法名称和目标操作方法的所需参数。框架使用这些数据来计算一个URL，以导致所需的操作方法被调用并提供参数。这样，如果在应用程序的开发或维护过程中更改了路由规则，框架会自动更新新的URL，无需修改代码中旧URL的所有出现。
- en: 'The following code shows how to call `RedirectToAction`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何调用`RedirectToAction`：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another useful `IActionResult` is `ContentResult`, which can be created by
    calling the `Content` method. `ContentResult` allows you to write any string to
    the response and specify its MIME type, as shown in the following example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的`IActionResult`是`ContentResult`，可以通过调用`Content`方法创建。`ContentResult`允许您将任何字符串写入响应并指定其MIME类型，如下例所示：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, the `File` method returns `FileResult`, which writes binary data in
    the response. There are several overloads of this method that allow the specification
    of a byte array, a stream, or the path of a file, plus the MIME type of the binary
    data.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`File`方法返回`FileResult`，它在响应中写入二进制数据。该方法有几个重载，允许指定字节数组、流或文件的路径，以及二进制数据的MIME类型。
- en: Now, let's move on to describing how actual HTML is generated in Views.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续描述在Views中生成实际HTML的方法。
- en: Understanding Razor Views
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Razor视图
- en: 'ASP.NET Core MVC uses a language called Razor to define the HTML templates
    contained in the Views. Razor views are files that are compiled into .NET classes
    when they''re first used, when the application has been built, or when the application
    has been published. By default, both pre-compilation on each build and on publish
    are enabled, but you can also enable runtime compilation so that the Views can
    be modified once they have been deployed. This option can be enabled by checking
    the **Enable Razor runtime compilation** checkbox when the project is created
    in Visual Studio. You can also disable compilation on each build and on publish
    by adding the following code to the web application project file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC使用一种称为Razor的语言来定义Views中包含的HTML模板。Razor视图是文件，当它们首次使用时，当应用程序构建时，或者当应用程序发布时，它们会被编译为.NET类。默认情况下，每次构建和发布都启用了预编译，但您还可以启用运行时编译，以便在部署后可以修改Views。在Visual
    Studio中创建项目时，可以通过选中**启用Razor运行时编译**复选框来启用此选项。您还可以通过向Web应用程序项目文件添加以下代码来禁用每次构建和发布的编译：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Views can also be precompiled into views libraries if you choose a Razor view
    library project in the window that appears once you have chosen an ASP.NET Core
    project.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了Razor视图库项目，则视图也可以预编译为视图库。
- en: Also, after the compilation, views remain associated with their paths, which
    become their full names. Each controller has an associated folder under the **Views**
    folder with the same name as the controller, which is expected to contain all
    the views used by that controller.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在编译后，视图仍然与其路径相关联，这些路径成为它们的完整名称。每个控制器在**Views**文件夹下有一个与控制器同名的关联文件夹，该文件夹预计包含该控制器使用的所有视图。
- en: 'The following screenshot shows the folder associated with `HomeController`
    and its Views:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了与`HomeController`及其Views相关联的文件夹：
- en: '![](img/B16756_15_05.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_15_05.png)'
- en: 'Figure 15.5: View folders associated with controllers and the shared folder'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：与控制器相关联的视图文件夹和共享文件夹
- en: The preceding screenshot also shows the **Shared** folder, which is expected
    to contain all the views or partial views used by several controllers. The controller
    refers to views in the `View` method through their paths without the `.cshtml`
    extension. If the path starts with `/`, the path is interpreted as relative to
    the application root. Otherwise, as a first attempt, the path is interpreted as
    relative to the folder associated with the controller. If no view is found there,
    the view is searched for in the **Shared** folder.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图还显示了**Shared**文件夹，该文件夹预计包含多个控制器使用的所有视图或部分视图。控制器通过其路径引用`View`方法中的视图，而不包括`.cshtml`扩展名。如果路径以`/`开头，则将路径解释为相对于应用程序根的路径。否则，首先尝试将路径解释为相对于与控制器关联的文件夹。如果在那里找不到视图，则会在**Shared**文件夹中搜索视图。
- en: Hence, for instance, the `Privacy.cshtml` View file in the preceding screenshot
    can be referred to from within `HomeController` as `View("Privacy", MyViewModel)`.
    If the name of the View is the same as the name of the action method, we can simply
    write `View(MyViewModel)`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，在前面的屏幕截图中的`Privacy.cshtml`视图文件可以在`HomeController`中从`View("Privacy", MyViewModel)`中引用。如果View的名称与操作方法的名称相同，我们可以简单地写`View(MyViewModel)`。
- en: 'Razor views are a mix of HTML code with C# code, plus some Razor-specific statements.
    They all begin with a header that contains the type of ViewModel that the View
    is expected to receive:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Razor视图是HTML代码与C#代码的混合，加上一些特定于Razor的语句。它们都以包含View应该接收的ViewModel类型的标题开头：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each view may also contain some `using` statements whose effect is the same
    as the `using` statements of standard code files:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图还可以包含一些`using`语句，其效果与标准代码文件的`using`语句相同：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`@using` statements declared in the special `_ViewImports.cshtml` file – that
    is, in the root of the `Views` folder – are automatically applied to all views.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在特殊的`_ViewImports.cshtml`文件中声明的`@using`语句（即在`Views`文件夹的根目录）会自动应用于所有视图。
- en: 'Each view can also require instances of types from the DI engine in its header
    with the syntax shown here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图还可以在其头部使用以下语法要求DI引擎中的类型的实例：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code requires an instance of the `IViewLocalizer` interface and
    places it in the `Localizer` variable. The remainder of the View is a mix of C#
    code, HTML, and Razor control flow statements. Each area of a view can be either
    in HTML mode or C# mode. The code in a View area that is in HTML mode is interpreted
    as HTML, while the code in a View area that is in C# mode is interpreted as C#.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码需要`IViewLocalizer`接口的一个实例，并将其放在`Localizer`变量中。视图的其余部分是C#代码、HTML和Razor流程控制语句的混合。视图的每个区域可以是HTML模式或C#模式。在HTML模式的视图区域中的代码被解释为HTML，而在C#模式的视图区域中的代码被解释为C#。
- en: The topic that follows explains the Razor flow of control statements.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的主题将解释Razor流程控制语句。
- en: Learning the Razor flow of control statements
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习Razor流程控制语句
- en: 'If you want to write some C# code in an HTML area, you can create a C# area
    with the `@{..}` Razor flow of control statement, as shown here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在HTML区域中编写一些C#代码，可以使用`@{..}` Razor流程控制语句创建一个C#区域，如下所示：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding example shows that it is enough to write an HTML tag to create
    an HTML area inside of the C# area and so on recursively. As soon as the HTML
    tag closes, you are in C# mode again.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明，只需编写HTML标签即可在C#区域内创建HTML区域，依此类推。一旦HTML标签关闭，您又处于C#模式。
- en: 'C# code produces no HTML, while HTML code is added to the response in the same
    order it appears. You can add text computed with C# code while in HTML mode by
    prefixing any C# expression with `@`. If the expression is complex in that it
    is composed of a chain of properties and method calls, it must be enclosed by
    parentheses. The following code shows some examples:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: C#代码不会产生HTML，而HTML代码按照出现的顺序添加到响应中。您可以通过在HTML模式下使用`@`前缀来添加使用C#代码计算的文本。如果表达式复杂，由一系列属性和方法调用组成，必须用括号括起来。以下代码显示了一些示例：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Types are converted into strings using the current culture settings (see the
    *Understanding the connection between ASP.NET Core MVC and design principles*
    section for details on how to set the culture of each request). Moreover, strings
    are automatically HTML encoded to avoid the `<` and `>` symbols, which might interfere
    with the view HTML. HTML encoding can be prevented with the `@HTML.Raw` function,
    as shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 类型使用当前的区域设置转换为字符串（有关如何设置每个请求的区域设置的详细信息，请参见*了解ASP.NET Core MVC和设计原则之间的关系*部分）。此外，字符串会自动进行HTML编码，以避免`<`和`>`符号干扰视图HTML。可以使用`@HTML.Raw`函数来防止HTML编码，如下所示：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In an HTML area, alternative HTML can be selected with the `@if` Razor statement:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML区域中，可以使用`@if` Razor语句选择替代HTML：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As shown in the preceding code, the beginning of each block of a Razor control
    flow statement is in C# mode and remains in C# mode until the first HTML open
    tag is encountered, and then HTML mode starts. C# mode is resumed after the corresponding
    HTML close tag.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，Razor流程控制语句的每个块的开始都是在C#模式下，并且直到遇到第一个HTML开放标签之前都保持在C#模式下，然后开始HTML模式。在相应的HTML关闭标签之后，会恢复C#模式。
- en: 'An HTML template can be instantiated several times with the `for`, `foreach`,
    `while`, and `do` Razor statements, as shown in the following examples:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`for`、`foreach`、`while`和`do` Razor语句多次实例化HTML模板，如下例所示：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Razor views can contain comments that do not generate any code. Any text included
    within `@*...*@` is considered a comment and is removed when the page is compiled.
    The next topic describes properties that are available in all Views.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Razor视图可以包含不生成任何代码的注释。在`@*...*@`中包含的任何文本都被视为注释，并在页面编译时被移除。下一个主题描述了所有视图中可用的属性。
- en: Understanding Razor View properties
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解Razor视图属性
- en: Some standard variables are predefined in each view. The most important variable
    is `Model`, which contains the ViewModel that was passed to the view. For instance,
    if we pass a `Person` model to a view, then `<span>@Model.Name</span>` displays
    the name of the `Person` model that was passed to the view.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图中都预定义了一些标准变量。最重要的变量是`Model`，它包含传递给视图的ViewModel。例如，如果我们将一个`Person`模型传递给一个视图，那么`<span>@Model.Name</span>`会显示传递给视图的`Person`模型的名称。
- en: The `ViewData` variable contains `IDictionary<string, object>`, which is shared
    with the controller that invoked the view. That is, all controllers also have
    a `ViewData` property containing `IDictionary<string, object>`, and every entry
    that is set in the controller is also available in the `ViewData` variable of
    the invoked view. `ViewData` is an alternative to the ViewModel for a controller
    for passing information to its invoked view. It is worth mentioning that the `ViewState`
    dictionary can also be accessed as a dynamic object through the `ViewBag` property.
    This means that dynamic `ViewBag` properties are mapped to `ViewData` string indices
    and that their values are mapped to the `ViewState` entries corresponding to those
    indices.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewData`变量包含`IDictionary<string, object>`，与调用视图的控制器共享。也就是说，所有控制器都有一个包含`IDictionary<string,
    object>`的`ViewData`属性，并且在控制器中设置的每个条目也可以在调用视图的`ViewData`变量中使用。`ViewData`是控制器传递信息给调用视图的替代方法。值得一提的是，`ViewState`字典也可以通过`ViewBag`属性作为动态对象进行访问。这意味着动态的`ViewBag`属性被映射到`ViewData`字符串索引，它们的值被映射到与这些索引对应的`ViewState`条目。'
- en: The `User` variable contains the currently logged user; that is, the same instance
    contained in the current request's `Http.Context.User` property. The `Url` variable
    contains an instance of the `IUrlHelper` interface whose methods are utilities
    for computing the URLs of application pages. For instance, `Url.Action("action",
    "controller", new {par1=valueOfPar1,...})` computes the URL that causes the action
    method, *action*, of the *controller* to be invoked with all the parameters specified
    in the anonymous object passed as its parameters.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`变量包含当前登录的用户；也就是说，包含在当前请求的`Http.Context.User`属性中的相同实例。`Url`变量包含一个`IUrlHelper`接口的实例，其方法是用于计算应用程序页面的URL的实用程序。例如，`Url.Action("action",
    "controller", new {par1=valueOfPar1,...})`计算出导致调用*controller*的*action*方法的URL，并使用作为参数传递的匿名对象中指定的所有参数。'
- en: The `Context` variable contains the whole request's `HttpContext`. The `ViewContext`
    variable contains data about the context of the view invocation, including metadata
    about the action method that invoked the view.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`变量包含整个请求的`HttpContext`。`ViewContext`变量包含有关视图调用上下文的数据，包括有关调用视图的操作方法的元数据。'
- en: The next topic describes how Razor enhances HTML tag syntax.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题将描述Razor如何增强HTML标记语法。
- en: Using Razor tag helpers
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Razor标记助手
- en: In ASP.NET Core MVC, the developer can define so-called tag helpers, which either
    enhance existing HTML tags with new tag attributes or define new tags. While Razor
    views are compiled, any tag is matched against existing tag helpers. When a match
    is found, the source tag is replaced with HTML created by the tag helpers. Several
    tag helpers may be defined for the same tag. They are all executed in an order
    that can be configured with a priority attribute associated with each tag helper.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core MVC中，开发人员可以定义所谓的标记助手，这些标记助手可以增强现有的HTML标记，添加新的标记属性，或者定义新的标记。在Razor视图编译时，任何标记都会与现有的标记助手进行匹配。当找到匹配项时，源标记将被标记助手创建的HTML替换。可以为同一个标记定义多个标记助手。它们都按照可以通过与每个标记助手关联的优先级属性进行配置的顺序执行。
- en: All tag helpers defined for the same tag may cooperate while each tag instance
    is being processed. This is because they are passed a shared data structure where
    each of them may apply a contribution. Usually, the final tag helper that is invoked
    processes this shared data structure to produce the output HTML.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为同一个标记定义的所有标记助手在处理每个标记实例时可以进行合作。这是因为它们被传递了一个共享的数据结构，其中每个标记助手都可以应用一个贡献。通常，被调用的最终标记助手会处理这个共享的数据结构，以生成输出的HTML。
- en: Tag helpers are classes that inherit from the `TagHelper` class. This topic
    doesn't discuss how to create new tag helpers but introduces the main predefined
    tag helpers that come with ASP.NET Core MVC. A complete guide on how to define
    tag helpers is available in the official documentation, which is referenced in
    the *Further reading* section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 标记助手是继承自`TagHelper`类的类。本主题不讨论如何创建新的标记助手，而是介绍了随ASP.NET Core MVC一起提供的主要预定义标记助手。如何定义标记助手的完整指南可在官方文档中找到，该文档在*进一步阅读*部分中有引用。
- en: 'To use a tag helper, you must declare the `.dll` file containing it with a
    declaration like the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用标记助手，必须声明包含它的`.dll`文件，声明如下：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you would like to use just one of the tag helpers defined in the `.dll` file,
    you must replace `*` with the tag name.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想使用`.dll`文件中定义的标记助手中的一个，必须用标记名称替换`*`。
- en: 'The preceding declaration can be placed either in each view that uses the tag
    helpers defined in the library or, once and for all, in the `_ViewImports.cshtml`
    file in the root of the `Views` folder. By default, `_ViewImports.cshtml` adds
    all predefined ASP.NET Core MVC tag helpers with the following declaration:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的声明可以放置在使用库中定义的标记助手的每个视图中，也可以一次性放置在`Views`文件夹的根目录中的`_ViewImports.cshtml`文件中。默认情况下，`_ViewImports.cshtml`添加了所有预定义的ASP.NET
    Core MVC标记助手，声明如下：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The anchor tag is enhanced with attributes that automatically compute the URL
    and that invoke a specific action method with given parameters, as shown here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 锚标记使用属性进行增强，这些属性可以自动计算URL，并调用具有给定参数的特定操作方法，如下所示：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A similar syntax is added to the `form` tags:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的语法也适用于`form`标记：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `script` tag is enhanced with attributes that allow us to fall back to
    a different source if the download fails. Typical usage is to download scripts
    from some cloud service to optimize the browser cache and to fall back to a local
    copy of the script in case of failure. The following code uses the fallback technique
    to download the `bootstrap` JavaScript file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`script`标记使用属性进行增强，允许我们在下载失败时回退到不同的源。典型用法是从某个云服务下载脚本以优化浏览器缓存，并在失败时回退到脚本的本地副本。以下代码使用回退技术下载`bootstrap`
    JavaScript文件：'
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`asp-fallback-test` contains a JavaScript test that verifies whether the download
    succeeded. In the preceding example, the test verifies whether a JavaScript object
    has been created.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`asp-fallback-test`包含一个JavaScript测试，用于验证下载是否成功。在前面的示例中，测试验证是否已创建JavaScript对象。'
- en: 'The `environment` tag can be used to select different HTML for different environments
    (development, staging, and production). Its typical usage is selecting the debug
    versions of JavaScript files during development, as shown in this example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`environment`标记可用于选择不同环境（开发、暂存和生产）的不同HTML。其典型用法是在开发过程中选择JavaScript文件的调试版本，如下例所示：'
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There is also a `cache` tag, which caches its content in memory to optimize
    rendering speed:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`cache`标记，它将其内容缓存在内存中以优化渲染速度：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By default, content is cached for 20 minutes, but the tag has attributes that
    must be defined when the cache expires, such as `expires-on="{datetime}"`, `expires-after="{timespan}"`,
    and `expires-sliding="{timespan}"`. Here, the difference between `expires-sliding`
    and `expires-after` is that, in the second attribute, the expiration time count
    is reset each time the content is requested. The `vary-by` attribute causes the
    creation of a different cache entry for each different value passed to `vary-by`.
    There are also attributes such as `vary-by-header`, which creates a different
    entry for each different value assumed by the request header specified in the
    attribute; `vary-by-cookie`; and so on.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，内容被缓存20分钟，但标记具有在缓存过期时必须定义的属性，例如`expires-on="{datetime}"`，`expires-after="{timespan}"`和`expires-sliding="{timespan}"`。在这里，`expires-sliding`和`expires-after`之间的区别在于，在第二个属性中，每次请求内容时，到期时间计数都会被重置。`vary-by`属性导致为传递给`vary-by`的每个不同值创建不同的缓存条目。还有一些属性，例如`vary-by-header`，它为指定属性中指定的请求标头的每个不同值创建一个不同的条目；`vary-by-cookie`；等等。
- en: 'All `input` tags – that is, `textarea`, `input`, and `select` – have an `asp-for`
    attribute that accepts a properties path rooted in the view''s ViewModel as their
    value. For instance, if the view has a `Person` ViewModel, we may have something
    like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`input`标记 - 也就是`textarea`，`input`和`select` - 都有一个`asp-for`属性，其值接受以视图的ViewModel为根的属性路径。例如，如果视图有一个`Person`
    ViewModel，我们可能会有这样的东西：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first thing the preceding code does is assign the value of the `Town` nested
    property to the `value` attribute of the `input` tag. In general, if the value
    is not a string, it is converted into a string using the current request culture.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码的第一件事是将`Town`嵌套属性的值分配给`input`标记的`value`属性。通常情况下，如果值不是字符串，它会根据当前请求的区域设置转换为字符串。
- en: However, it also sets the name of the input field to `Address.Town` and the
    ID of the input field to `Address_Town`. This is because dots are not allowed
    in tag IDs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它还将输入字段的名称设置为`Address.Town`，将输入字段的ID设置为`Address_Town`。这是因为标记ID中不允许出现点。
- en: A prefix can be added to these standard names by specifying it in `ViewData.TemplateInfo.HtmlFieldPrefix`.
    For instance, if the previous property is set to `MyPerson`, the name becomes
    `MyPerson.Address.Town`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`ViewData.TemplateInfo.HtmlFieldPrefix`中指定前缀来添加到这些标准名称。例如，如果前一个属性设置为`MyPerson`，则名称变为`MyPerson.Address.Town`。
- en: If the form is submitted to an action method that has the same `Person` class
    as one of its parameters, the name of `Address.Town` that's given to the `input`
    field will cause the `Town` property of this parameter to be filled with the `input`
    field. In general, the string contained in the `input` field is converted into
    the type of property it has been matched with using the current request culture.
    Summing this up, names of `input` fields are created in such a way that a complete
    `Person` model can be recovered in the action method when the HTML page is posted.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单提交到一个具有与其参数之一相同的`Person`类的操作方法，则给`input`字段的`Address.Town`名称将导致该参数的`Town`属性被填充到`input`字段中。通常情况下，`input`字段中包含的字符串会根据当前请求的区域设置转换为其匹配的属性类型。总结一下，`input`字段的名称是以这样的方式创建的，以便在HTML页面被提交时，操作方法中可以恢复完整的`Person`模型。
- en: The same `asp-for` attribute can be used in a `label` tag to cause the label
    to refer to the input field with the same `asp-for` value.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的`asp-for`属性可以在`label`标记中使用，以使标签引用具有相同`asp-for`值的输入字段。
- en: 'The following code is an example of an `input`/`label` pair:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`input`/`label`对的示例：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When no text is inserted into the label, the text shown in the label is taken
    from a `Display` attribute that decorates the property (`Town`, in this example),
    if any; otherwise, the name of the property is used.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当标签中没有插入文本时，标签中显示的文本将从装饰属性（在本例中为`Town`）中获取；否则，将使用属性的名称。
- en: If `span` or `div` contains an `asp-validation-for ="Address.Town"` error attribute,
    then validation messages concerning the `Address.Town` input will be inserted
    automatically inside that tag. The validation framework will be described in the
    *Understanding the connection between ASP.NET Core MVC and design principles*
    section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`span`或`div`包含`asp-validation-for ="Address.Town"`错误属性，则与`Address.Town`输入相关的验证消息将自动插入到该标记内。验证框架将在*了解ASP.NET
    Core MVC与设计原则之间的关系*部分中进行描述。
- en: 'It is also possible to automatically create a validation error summary by adding
    the attribute that follows a `div` or a `span`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过在`div`或`span`后添加属性来自动创建验证错误摘要：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If the attribute is set to `ValidationSummary.ModelOnly`, only messages that
    are not associated with specific `input` fields will be shown in the summary,
    while if the value is `ValidationSummary.All`, all error messages will be shown.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性设置为`ValidationSummary.ModelOnly`，则仅会在摘要中显示与特定`input`字段不相关的消息，而如果值为`ValidationSummary.All`，则会显示所有错误消息。
- en: The `asp-items` attribute can be applied to any `select` tag in order to automatically
    generate all `select` options. It must be passed an `IEnumerable<SelectListItem>`,
    where each `SelectListItem` contains both the text and value of an option. `SelectListItem`
    also contains an optional `Group` property you can use to organize the options
    shown in `select` into groups.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`asp-items`属性可以应用于任何`select`标记，以便自动生成所有`select`选项。必须传递一个`IEnumerable<SelectListItem>`，其中每个`SelectListItem`包含选项的文本和值。`SelectListItem`还包含一个可选的`Group`属性，您可以使用它来将在`select`中显示的选项组织成组。'
- en: The next topic shows how to reuse view code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题将展示如何重用视图代码。
- en: Reusing view code
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重用视图代码
- en: ASP.NET Core MVC includes several techniques for reusing view code. The most
    important is the layout page.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC包括几种重用视图代码的技术。最重要的是布局页面。
- en: In each web application, several pages share the same structure; for instance,
    the same main menu or the same left or right bar. In ASP.NET Core, this common
    structure is factored out in views called layout pages/views.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个Web应用程序中，几个页面共享相同的结构；例如，相同的主菜单或相同的左侧或右侧栏。在ASP.NET Core中，这种常见结构被分解为称为布局页面/视图的视图中。
- en: 'Each view can specify the view to be used as its layout page with the following
    code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图都可以使用以下代码指定要用作其布局页面的视图：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If no layout page is specified, a default layout page, defined in the `_ViewStart.cshtml`
    file located in the `Views` folder, is used. The default content of `_ViewStart.cshtml`
    is as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定布局页面，则将使用位于“Views”文件夹中的“_ViewStart.cshtml”文件中定义的默认布局页面。_ViewStart.cshtml的默认内容如下：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Therefore, the default layout page in the files scaffolded by Visual Studio
    is `_Layout.cshtml`, which is contained in the `Shared` folder.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Visual Studio生成的文件中的默认布局页面是`_Layout.cshtml`，它包含在`Shared`文件夹中。
- en: 'The layout page contains the HTML that''s shared with all of its children pages,
    the HTML page headers, and the page references to CSS and JavaScript files. The
    HTML produced by each view is placed inside of its layout place, where the layout
    page calls the `@RenderBody()` method, as shown in the following example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 布局页面包含与其所有子页面共享的HTML、HTML页面头和对CSS和JavaScript文件的页面引用。每个视图生成的HTML都放在其布局位置中，布局页面调用`@RenderBody()`方法，如下例所示：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`ViewState` of each `View` is copied into `ViewState` of its layout page, so
    `ViewState` can be used to pass information to the view layout page. Typically,
    it is used to pass the view title to the layout page, which then uses it to compose
    the page''s title header, as shown here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图的`ViewState`都会被复制到其布局页面的`ViewState`中，因此`ViewState`可用于将信息传递给视图布局页面。通常用于将视图标题传递给布局页面，然后布局页面用它来组成页面的标题头，如下所示：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: While the main content produced by each view is placed in a single area of its
    layout page, each layout page can also define several sections placed in different
    areas where each view can place further secondary content.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个视图生成的主要内容都放在其布局页面的一个区域中，但每个布局页面还可以定义放置在不同区域的几个部分，每个视图可以在其中放置更多的次要内容。
- en: 'For instance, suppose a layout page defines a `Scripts` section, as shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设布局页面定义了一个`Scripts`部分，如下所示：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, the view can use the previously defined section to pass some view-specific
    JavaScript references, as shown here:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，视图可以使用先前定义的部分来传递一些特定于视图的JavaScript引用，如下所示：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If an action method is expected to return HTML to an AJAX call, it must produce
    an HTML fragment instead of a whole HTML page. Therefore, in this case, no layout
    page must be used. This is achieved by calling the `PartialView` method instead
    of the `View` method in the controller action method. `PartialView` and `View`
    have exactly the same overloads and parameters.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作方法预期向AJAX调用返回HTML，则必须生成HTML片段而不是整个HTML页面。因此，在这种情况下，不必使用布局页面。这可以通过在控制器操作方法中调用`PartialView`方法而不是`View`方法来实现。`PartialView`和`View`具有完全相同的重载和参数。
- en: 'Another way to reuse view code is to factor out a view fragment that''s common
    to several views into another view that is called by all previous views. A view
    can call another view with the `partial` tag, as shown here:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 重用视图代码的另一种方法是将几个视图共有的视图片段分解到另一个由所有先前视图调用的视图中。视图可以使用`partial`标签调用另一个视图，如下所示：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding code invokes `_viewname` and passes it the object contained in
    `Model.ModelProperty.NestedProperty` as its `ViewModel`. When a view is invoked
    by the `partial` tag, no layout page is used since the called view is expected
    to return an HTML fragment.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码调用`_viewname`并将`Model.ModelProperty.NestedProperty`中包含的对象作为其`ViewModel`传递。当使用`partial`标签调用视图时，不使用布局页面，因为被调用视图预期返回HTML片段。
- en: The `ViewData.TemplateInfo.HtmlFieldPrefix` property of the called view is set
    to the `"ModelProperty.NestedProperty"` string. This way, possible input fields
    rendered in `_viewname.cshtml` will have the same name as if they had been rendered
    directly by the calling view.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用视图的`ViewData.TemplateInfo.HtmlFieldPrefix`属性设置为`"ModelProperty.NestedProperty"`字符串。这样，在`_viewname.cshtml`中呈现的可能输入字段将具有与直接由调用视图呈现时相同的名称。
- en: 'Instead of specifying the ViewModel of `_viewname` through a property of the
    caller view (ViewModel), you can also directly pass an object that is contained
    in a variable or returned by a C# expression by replacing `for` with `model`,
    as shown in this example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将`for`替换为`model`，直接传递包含在变量中或由C#表达式返回的对象，而不是通过调用视图（ViewModel）的属性来指定`_viewname`的ViewModel，如本例所示：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this case, the `ViewData.TemplateInfo.HtmlFieldPrefix` property of the called
    view keeps its default value; that is, the empty string.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，被调用视图的`ViewData.TemplateInfo.HtmlFieldPrefix`属性保持其默认值；即空字符串。
- en: 'A view can also call something more complex than another view; that is, another
    controller method that, in turn, renders a view. Controllers that are designed
    to be invoked by views are called **view components**. The following code is an
    example of component invocation:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 视图还可以调用比另一个视图更复杂的内容；也就是说，另一个控制器方法，反过来呈现一个视图。设计为由视图调用的控制器称为**视图组件**。以下代码是组件调用的示例：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Parameter names must match the ones used in the view component method. However,
    both the component's name and parameter names must be translated into kebab case;
    that is, all the characters must be transformed into lowercase if all the characters
    that were in the original name were in uppercase, though the first one word must
    be preceded by a `-`. For instance, `MyParam` must be transformed into `my-param`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名称必须与视图组件方法中使用的名称匹配。但是，组件的名称和参数名称都必须转换为kebab case；也就是说，如果原始名称中的所有字符都是大写字母，那么所有字符都必须转换为小写字母，尽管第一个单词必须在前面加上“-”。例如，`MyParam`必须转换为`my-param`。
- en: Actually, view components are classes that derive from the `ViewComponent` class.
    When a component is invoked, the framework looks for either an `Invoke` method
    or an `InvokeAsync` method and passes it all the parameters that were defined
    in the component's invocation. `InvokeAsync` must be used if the method is defined
    as `async`; otherwise, we must use `Invoke`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，视图组件是从`ViewComponent`类派生的类。当调用组件时，框架会查找`Invoke`方法或`InvokeAsync`方法，并将组件调用中定义的所有参数传递给它。如果方法被定义为`async`，则必须使用`InvokeAsync`；否则，必须使用`Invoke`。
- en: 'The following code is an example of a view component definition:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是视图组件定义的示例：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The previously defined component must be invoked with a call such as the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 先前定义的组件必须通过以下方式调用：
- en: '[PRE54]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If the component is invoked by a view of a controller called `MyController`,
    `ViewName` is searched for in the following paths:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件由名为`MyController`的控制器的视图调用，则在以下路径中搜索`ViewName`：
- en: '`/Views/MyController/Components/MyTest/ViewName`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Views/MyController/Components/MyTest/ViewName`'
- en: '`/Views/Shared/Components/MyTest/ViewName`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Views/Shared/Components/MyTest/ViewName`'
- en: Now, let's look at the more recent relevant features of ASP.NET Core.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下ASP.NET Core的更近期的相关功能。
- en: What is new in the latest versions of ASP.NET Core?
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core的最新版本有什么新功能？
- en: 'The main change for ASP.NET Core took place in version 3.0: the routing engine
    was factored out of the MVC engine and is now also available for other handlers.
    In previous versions, routes and routing were a part of the MVC handler and were
    added with `app.UseMvc(....)`; this has now been replaced with `app.UseRouting()`
    and `UseEndpoints(...)`, which can route requests not only to controllers but
    also to other handlers.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core的主要变化发生在3.0版本：路由引擎已从MVC引擎中分离出来，现在也可用于其他处理程序。在以前的版本中，路由和路由是MVC处理程序的一部分，并且通过`app.UseMvc(....)`添加；现在已经被`app.UseRouting()`和`UseEndpoints(...)`取代，它们不仅可以将请求路由到控制器，还可以将请求路由到其他处理程序。
- en: 'Endpoints and their associated handlers are now defined in `UseEndpoints`,
    as shown here:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，端点及其关联的处理程序是在`UseEndpoints`中定义的，如下所示：
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`MapControllerRoute` associates patterns with controllers, but we may also
    use something such as `endpoints.MapHub<ChatHub>("/chat")`, which associates a
    pattern with a hub that handles WebSocket connections. In the previous section,
    we saw that patterns can also be associated with custom handlers using `MapPost`
    and `MapGet`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapControllerRoute`将模式与控制器关联起来，但我们也可以使用诸如`endpoints.MapHub<ChatHub>("/chat")`之类的东西，将模式与处理WebSocket连接的hub关联起来。在前一节中，我们看到模式也可以使用`MapPost`和`MapGet`与自定义处理程序关联。'
- en: 'An independent router also allows us to add authorizations not only to controllers
    but also to any handler, as shown here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的路由器还允许我们不仅向控制器添加授权，还可以向任何处理程序添加授权，如下所示：
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Moreover, ASP.NET Core now has an independent JSON formatter and doesn''t depend
    on the third-party Newtonsoft JSON serializer anymore. However, if you have compatibility
    issues, you still have the option to replace the minimal ASP.NET Core JSON formatter
    with the Newtonsoft JSON serializer by installing the `Microsoft.AspNetCore.Mvc.NewtonsoftJson`
    NuGet package and configuring the controllers, as shown here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ASP.NET Core现在有一个独立的JSON格式化程序，不再依赖于第三方Newtonsoft JSON序列化器。但是，如果您有兼容性问题，仍然可以选择通过安装`Microsoft.AspNetCore.Mvc.NewtonsoftJson`
    NuGet包并配置控制器来将最小的ASP.NET Core JSON格式化程序替换为Newtonsoft JSON序列化器，如下所示：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, `AddNewtonsoftJson` also has an overload that accepts the configuration
    options for the Newtonsoft JSON serializer:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`AddNewtonsoftJson`还有一个重载，接受Newtonsoft JSON序列化器的配置选项：
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Microsoft's JSON serializer was introduced in version 3, but at the beginning,
    its implementation was minimal. Now, in .NET 5, it offers options that are comparable
    to the ones of the Newtonsoft JSON serializer.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的JSON序列化器是在版本3中引入的，但一开始它的实现是最小的。现在，在.NET 5中，它提供了与Newtonsoft JSON序列化器相当的选项。
- en: In versions previous to 3.0, you were forced to add both controllers and views
    to the DI engine. Now, you can still inject both controllers and views with `services.AddControllersWithViews`,
    but you can also add controllers with `AddControllers` if you are going to implement
    REST endpoints only.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在3.0之前的版本中，您被迫将控制器和视图都添加到DI引擎中。现在，您仍然可以使用`services.AddControllersWithViews`注入控制器和视图，但如果您只打算实现REST端点，也可以使用`AddControllers`添加控制器。
- en: Version 5 brought significant performance improvements due to improvements in
    .NET performance, improvements in the JIT compiler, which now generate shorter
    and more optimized code, and due to improvements in the HTTP/2 protocol implementation.
    Basically, you can rely on a doubled computation speed, along with more efficient
    memory and garbage collection handling.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于.NET性能的改进、JIT编译器的改进（现在生成更短更优化的代码）以及HTTP/2协议实现的改进，版本5带来了显著的性能改进。基本上，您可以依赖于加倍的计算速度，以及更高效的内存和垃圾收集处理。
- en: Understanding the connection between ASP.NET Core MVC and design principles
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解ASP.NET Core MVC与设计原则之间的连接
- en: The whole ASP.NET Core framework is built on top of the design principles and
    patterns that we analyzed in *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*, *Chapter 8*, *Interacting with Data in C# – Entity
    Framework Core*, *Chapter 11*, *Design Patterns and .NET 5 Implementation*, *Chapter
    12*, *Understanding the Different Domains in Software Solutions*, and *Chapter
    13*, *Implementing Code Reusability in C# 9*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 整个ASP.NET Core框架是建立在我们在*第5章*、*将微服务架构应用于企业应用程序*、*第8章*、*在C#中与数据交互-Entity Framework
    Core*、*第11章*、*设计模式和.NET 5实现*、*第12章*、*理解软件解决方案中的不同领域*和*第13章*、*在C# 9中实现代码重用性*中分析的设计原则和模式之上构建的。
- en: Moreover, all framework functionalities are provided through DI so that each
    of them can be replaced by a customized counterpart without it affecting the remainder
    of the code. However, these providers are not added individually to the DI engine;
    instead, they are grouped into option objects (see the *Loading configuration
    data and using it with the options framework* subsection) in order to conform
    to the SOLID Single Responsibility Principle. This is the case, for instance,
    for all model binders, validation providers, and data annotation providers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, configuration data, instead of being available from a unique dictionary
    created from a configuration file, is organized into option objects thanks to
    the options framework we described in the first section of this chapter. This
    is also an application of the SOLID Interface Segregation Principle.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'However, ASP.NET Core also applies other patterns that are specific instances
    of the general Separation of Concerns principle, which is a generalization of
    the Single Responsibility Principle. They are as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The middleware modules architecture (ASP.NET Core pipeline)
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factoring out validation and globalization from the application code
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MVC pattern itself
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will analyze each of these in the various subsections that follow.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the ASP.NET Core pipeline
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ASP.NET Core pipeline architecture has two important advantages:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: All the different operations that are performed on the initial request are factored
    out into different modules, according to the Single Responsibility Principle.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules that perform these different operations don't need to call each
    other because each module is invoked once and for all by the ASP.NET Core framework.
    This way, the code for each module is not required to perform any action that
    is connected to responsibilities that have been assigned to other modules.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ensures maximum independence of functionalities and simpler code. For instance,
    once authorization and authentication modules are on, no other module needs to
    worry about authorization anymore. Each controller code can focus on application-specific
    business stuff.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Server-side and client-side validation
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Validation logic has been completely factored out from the application code
    and has been confined to the definition of validation attributes. The developer
    just needs to specify the validation rule to apply to each model property by decorating
    the property with an adequate validation attribute.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Validation rules are checked automatically when action method parameters are
    instantiated. Both errors and paths in the model (where they occurred) are then
    recorded in a dictionary that is contained in the `ModelState` controller property.
    The developer has the responsibility of verifying whether there are errors by
    checking `ModelState.IsValid`, in which case the developer must return the same
    ViewModel to the same view so that the user can correct all errors.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Error messages are automatically shown in the view with no action required
    from the developer. The developer is only required to do the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Add `span` or `div` with an `asp-validation-for` attribute next to each input
    field, which will be automatically filled with the possible error.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `div` with an `asp-validation-summary` attribute that will be automatically
    filled with the validation error summary. See the *Using Razor tag helpers* section
    for more details.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is enough to add some JavaScript references by invoking the `_ValidationScriptsPartial.cshtml`
    view with the `partial` tag to enable the same validation rules on the client
    side, so that errors are shown to the user before the form is posted to the server.
    Some predefined validation attributes are contained in the `System.ComponentModel.DataAnnotations`
    and `Microsoft.AspNetCore.Mvc` namespaces and include the following attributes:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The `Required` attribute requires the user to specify a value for the property
    that it decorates. An implicit `Required` attribute is automatically applied to
    all non-nullable properties, such as all floats, integers, and decimals, since
    they can't have a `null` value.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Required”属性要求用户为其装饰的属性指定一个值。隐式的“Required”属性会自动应用于所有非空属性，例如所有浮点数、整数和小数，因为它们不能有“null”值。
- en: The `Range` attribute constrains numeric quantities within a range.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Range”属性限制数字数量在一个范围内。
- en: They also include attributes that constrain string lengths.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们还包括限制字符串长度的属性。
- en: Custom error messages can be inserted directly into the attributes, or attributes
    can refer to the property of resource types containing them.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义错误消息可以直接插入到属性中，或者属性可以引用包含它们的资源类型的属性。
- en: The developer can define their custom attributes by providing the validation
    code both in C# and in JavaScript for client-side validation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以通过在C#和JavaScript中提供验证代码来定义其自定义属性，用于客户端验证。
- en: 'Attribute-based validation can be replaced by other validation providers, such
    as fluent validation that defines validation rules for each type using a fluent
    interface. It is enough to change a provider in a collection contained in the
    MVC options object. This can be configured through an action passed to the `services.AddControllersWithViews`
    method. MVC options can be configured as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的验证可以被其他验证提供程序替换，例如使用流畅接口为每种类型定义验证规则的流畅验证。只需在MVC选项对象中包含的集合中更改提供程序即可。这可以通过传递给“services.AddControllersWithViews”方法的操作来配置。MVC选项可以配置如下：
- en: '[PRE59]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The validation framework automatically checks whether numeric and date inputs
    are well-formatted according to the selected culture.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 验证框架会自动检查数字和日期输入是否根据所选文化格式良好。
- en: ASP.NET Core globalization
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core全球化
- en: In multicultural applications, pages must be served according to the language
    and culture preferences of each user. Typically, multicultural applications can
    serve their content in a few languages, and they can handle dates and numeric
    formats in several more languages. In fact, while the content in all supported
    languages must be produced manually, .NET Core has the native capability of formatting
    and parsing dates and numbers in all cultures.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在多元文化应用程序中，页面必须根据每个用户的语言和文化偏好提供服务。通常，多元文化应用程序可以用几种语言提供其内容，并且可以处理更多语言的日期和数字格式。事实上，虽然所有支持的语言中的内容必须手动制作，但.NET
    Core具有在所有文化中格式化和解析日期和数字的本机能力。
- en: For instance, a web application might not support unique content for all English-based
    cultures (en), but might support all known English-based cultures for numbers
    and dates formats (en-US, en-GB, en-CA, and so on).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Web应用程序可能不支持所有基于英语的文化（en）的唯一内容，但可能支持所有已知的基于英语的文化的数字和日期格式（en-US、en-GB、en-CA等）。
- en: The culture used for numbers and dates in a .NET thread is contained in the
    `Thread.CurrentThread.CurrentCulture` property. Hence, by setting this property
    to `new CultureInfo("en-CA")`, numbers and dates will be formatted/parsed according
    to the Canadian culture. `Thread.CurrentThread.CurrentUICulture`, instead, decides
    on the culture of the resource files; that is, it selects a culture-specific version
    of each resource file or view. Accordingly, a multicultural application is required
    to set the two cultures associated with the request thread and organize multilingual
    content into language-dependent resource files and/or views.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET线程中用于数字和日期的文化包含在“Thread.CurrentThread.CurrentCulture”属性中。因此，通过将此属性设置为“new
    CultureInfo("en-CA")”，数字和日期将根据加拿大文化进行格式化/解析。“Thread.CurrentThread.CurrentUICulture”则决定资源文件的文化；也就是说，它选择每个资源文件或视图的特定于文化的版本。因此，多元文化应用程序需要设置与请求线程关联的两种文化，并将多语言内容组织到依赖于语言的资源文件和/或视图中。
- en: 'According to the Separation of Concerns principle, the whole logic used to
    set the request culture according to the user''s preferences is factored out into
    a specific module of the ASP.NET Core pipeline. To configure this module, as a
    first step, we set the supported date/numbers cultures, as in the following example:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 根据关注点分离原则，根据用户的偏好设置请求文化的整个逻辑被分解到ASP.NET Core管道的特定模块中。要配置此模块，首先我们设置支持的日期/数字文化，如下例所示：
- en: '[PRE60]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, we set the languages supported for the content. Usually, a version of
    the language that is not specific for any country is selected to keep the number
    of translations small enough, as shown here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置了内容支持的语言。通常，选择一个不特定于任何国家的语言版本，以保持翻译数量足够小，如下所示：
- en: '[PRE61]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we add the culture middleware to the pipeline, as shown here:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将culture中间件添加到管道中，如下所示：
- en: '[PRE62]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If the culture requested by the user is explicitly found among the ones listed
    in `supportedCultures` or `supportedUICultures`, it is used without modifications.
    Otherwise, since `FallBackToParentCultures` and `FallBackToParentUICultures` are
    `true`, the parent culture is tried; that is, for instance, if the required `fr-FR`
    culture is not found among those listed, then the framework searches for its generic
    version, `fr`. If this attempt also fails, the framework uses the cultures specified
    in `DefaultRequestCulture`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户请求的文化在“supportedCultures”或“supportedUICultures”中列出的文化中明确找到，则使用它而不进行修改。否则，由于“FallBackToParentCultures”和“FallBackToParentUICultures”为“true”，将尝试父文化；例如，如果所需的“fr-FR”文化在列出的文化中找不到，那么框架将搜索其通用版本“fr”。如果此尝试也失败，则框架将使用“DefaultRequestCulture”中指定的文化。
- en: 'By default, the `culture` middleware searches the culture selected for the
    current user with three providers that are tried in the order shown here:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，“culture”中间件使用三个提供程序搜索当前用户选择的文化，按照以下顺序尝试：
- en: The middleware looks for the `culture` and `ui-culture` query string parameters.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间件查找“culture”和“ui-culture”查询字符串参数。
- en: 'If the previous step fails, the middleware looks for a cookie named `.AspNetCore.Culture`,
    the value of which is expected to be as in this example: `c=en-US|uic=en`.'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前面的步骤失败，中间件将查找名为`.AspNetCore.Culture`的cookie，其值预期如本例所示：`c=en-US|uic=en`。
- en: If both previous steps fail, the middleware looks for the `Accept-Language`
    request header sent by the browser, which can be changed in the browser settings,
    and which is initially set to the operating system culture.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前两个步骤都失败，中间件将查找浏览器发送的`Accept-Language`请求头，该请求头可以在浏览器设置中更改，并且最初设置为操作系统的区域设置。
- en: With the preceding strategy, the first time a user requests an application page,
    the browser culture is taken (the provider listed in *step 3*). Then, if the user
    clicks a language-change link with the right query string parameters, a new culture
    is selected by provider 1\. Usually, once a language link has been clicked, the
    server also generates a language cookie to remember the user's choice through
    provider 2.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述策略，用户第一次请求应用程序页面时，会采用浏览器的区域设置（*步骤3*中列出的提供程序）。然后，如果用户点击带有正确查询字符串参数的语言更改链接，提供程序1会选择新的区域设置。通常，一旦点击了语言链接，服务器还会通过提供程序2生成一个语言cookie来记住用户的选择。
- en: The simplest way to provide content localization is to provide a different view
    for each language. Hence, if we would like to localize the `Home.cshtml` view
    for different languages, we must provide views named `Home.en.cshtml`, `Home.es.cshtml`,
    and so on. If no view specific to the `ui-culture` thread is found, the not localized
    `Home.cshtml` version of the view is chosen.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 提供内容本地化的最简单方法是为每种语言提供不同的视图。因此，如果我们想要为不同的语言本地化`Home.cshtml`视图，我们必须提供名为`Home.en.cshtml`、`Home.es.cshtml`等的视图。如果没有找到特定于`ui-culture`线程的视图，则选择未本地化的`Home.cshtml`版本的视图。
- en: 'View localization must be enabled by calling the `AddViewLocalization` method,
    as shown here:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 视图本地化必须通过调用`AddViewLocalization`方法来启用，如下所示：
- en: '[PRE63]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Another option is to store simple strings or HTML fragments in resource files
    specific for all supported languages. The usage of resource files must be enabled
    by calling the `AddLocalization` method in the configure services section, as
    shown here:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将简单的字符串或HTML片段存储在针对所有支持的语言的特定资源文件中。必须通过在配置服务部分调用`AddLocalization`方法来启用资源文件的使用，如下所示：
- en: '[PRE64]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`ResourcesPath` is the root folder where all resource files will be placed.
    If it is not specified, an empty string is assumed, and the resource files will
    be placed in the web application root. Resource files for a specific view, say,
    the `/Views/Home/Index.cshtml` view, must have a path like this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourcesPath`是将放置所有资源文件的根文件夹。如果未指定，将假定为空字符串，并且资源文件将放置在Web应用程序根目录中。例如，特定视图（例如`/Views/Home/Index.cshtml`视图）的资源文件必须具有以下路径：'
- en: '[PRE65]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Hence, if `ResourcesPath` is empty, resources must have the `/Views/Home/Index.<culture
    name>.resx` path; that is, they must be placed in the same folder as the view.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果`ResourcesPath`为空，则资源必须具有`/Views/Home/Index.<culture name>.resx`路径；也就是说，它们必须放在与视图相同的文件夹中。
- en: 'Once the key-value pairs for all the resource files associated with a view
    have been added, localized HTML fragments can be added to the view, as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为与视图关联的所有资源文件添加了键值对，就可以向视图添加本地化的HTML片段，如下所示：
- en: Inject `IViewLocalizer` into the view with `@inject IViewLocalizer Localizer`.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@inject IViewLocalizer Localizer`将`IViewLocalizer`注入视图。
- en: Where needed, replace the text in the View with accesses to the `Localizer`
    dictionary, such as `Localizer["myKey"]`, where `"myKey"` is a key used in the
    resource files.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要的地方，将视图中的文本替换为对`Localizer`字典的访问，例如`Localizer["myKey"]`，其中`"myKey"`是资源文件中使用的键。
- en: 'The following code shows an example of the `IViewLocalizer` dictionary:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`IViewLocalizer`字典的示例：
- en: '[PRE66]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If localization fails because the key is not found in the resource file, the
    key itself is returned. Strings used in data annotation, such as validation attributes,
    are used as keys in resource files if data annotation localization is enabled,
    as shown here:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本地化失败，因为在资源文件中找不到键，则返回键本身。如果启用了数据注释本地化，数据注释中使用的字符串（例如验证属性）将作为资源文件中的键使用，如下所示：
- en: '[PRE67]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Resource files for data annotations applied to a class whose full name is,
    say, `MyWebApplication.ViewModels.Account.RegisterViewModel`, must have the following
    path:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于名称为`MyWebApplication.ViewModels.Account.RegisterViewModel`的类的数据注释的资源文件必须具有以下路径：
- en: '[PRE68]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It is worth pointing out that the first segment of the namespace that corresponds
    to the `.dll` application name is replaced with `ResourcesPath`. If `ResourcesPath`
    is empty and if you use the default namespaces created by Visual Studio, then
    the resource files must be placed in the same folder that contains the classes
    they are associated with.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，与`.dll`应用程序名称对应的命名空间的第一个段将替换为`ResourcesPath`。如果`ResourcesPath`为空，并且您使用Visual
    Studio创建的默认命名空间，则资源文件必须放在包含与其关联的类的相同文件夹中。
- en: It is possible to localize strings and HTML fragments in controllers, or wherever
    dependencies can be injected, by associating each group of resource files with
    a type, such as `MyType`, and then injecting either `IHtmlLocalizer<MyType>` for
    HTML fragments or `IStringLocalizer<MyType>` for strings that need to be HTML
    encoded.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将每组资源文件与类型（例如`MyType`）关联，然后注入`IHtmlLocalizer<MyType>`用于HTML片段或`IStringLocalizer<MyType>`用于需要进行HTML编码的字符串，来在控制器或其他地方本地化字符串和HTML片段。
- en: Their usage is identical to the usage of `IViewLocalizer`. The path of the resource
    files associated with `MyType` is computed as in the case of data annotations.
    If you would like to use a unique group of resource files for the whole application,
    a common choice is to use the `Startup` class as the reference type (`IStringLocalizer<Startup
    >` and `IHtmlLocalizer<Startup >`). Another common choice is to create various
    empty classes to use as reference types for various groups of resource files.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的使用与`IViewLocalizer`的使用相同。与数据注释的情况一样，与`MyType`相关的资源文件的路径是计算的。如果您想要为整个应用程序使用一组唯一的资源文件，一个常见选择是使用`Startup`类作为参考类型（`IStringLocalizer<Startup>`和`IHtmlLocalizer<Startup>`）。另一个常见选择是创建各种空类，以用作各种资源文件组的参考类型。
- en: 'Now that we''ve learned how to manage globalization in your ASP.NET Core projects,
    in the next subsection, we will describe the more important pattern used by ASP.NET
    Core MVC to enforce *Separation of Concerns*: the MVC pattern itself.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在ASP.NET Core项目中管理全球化，在下一小节中，我们将描述ASP.NET Core MVC使用的更重要的模式，以强制*关注点分离*：MVC模式本身。
- en: The MVC pattern
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC模式
- en: MVC is a pattern used to implement the presentation layers of a web application.
    The basic idea is to apply a *Separation of Concerns* between the logic of the
    presentation layer and its graphics. Logic is taken care of by controllers, while
    graphics are factored out into views. Controllers and views communicate through
    the model, which is often called the ViewModel to distinguish it from the models
    of the business and data layers.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是用于实现Web应用程序的演示层的模式。基本思想是在演示层的逻辑和图形之间应用*关注点分离*。逻辑由控制器处理，而图形被分解为视图。控制器和视图通过模型进行通信，通常称为ViewModel，以区别于业务和数据层的模型。
- en: However, what is the logic of a presentation layer? In *Chapter 1*, *Understanding
    the Importance of Software Architecture*, we saw that software requirements can
    be documented with use cases that describe the interaction between the user and
    the system.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，演示层的逻辑是什么？在*第1章*，*理解软件架构的重要性*中，我们看到软件需求可以用用例来记录，描述用户和系统之间的交互。
- en: Roughly speaking, the logic of the presentation layer consists of the management
    of use cases; hence, roughly, use cases are mapped to controllers and every single
    operation of a use case is mapped to an action method of those controllers. Hence,
    controllers take care of managing the protocol of interaction with the user and
    rely on the business layer for any business processing involved during each operation.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，演示层的逻辑包括管理用例；因此，粗略地说，用例被映射到控制器，每个用例的单个操作被映射到这些控制器的操作方法。因此，控制器负责管理与用户的交互协议，并依赖业务层在每个操作期间涉及的任何业务处理。
- en: Each action method receives data from the user, performs some business processing,
    and, depending on the results of this processing, decides what to show to the
    user and encodes it in the ViewModel. Views receive ViewModels that describe what
    to show to the user and decide the graphics to use; that is, the HTML to use.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作方法从用户那里接收数据，执行一些业务处理，并根据此处理的结果决定向用户显示什么，并将其编码为ViewModel。视图接收描述向用户显示什么以及决定要使用的图形的ViewModel，并决定要使用的HTML。
- en: 'What are the advantages of separating logic and graphics into two different
    components? The main advantages are listed here:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 将逻辑和图形分离成两个不同的组件有什么优势？主要优势列在这里：
- en: Changes in graphics do not affect the remainder of the code, so you can experiment
    with various graphic options to optimize the interaction with the user without
    putting the reliability of the remainder of the code at risk.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形的更改不会影响其余的代码，因此您可以尝试各种图形选项，以优化与用户的交互，而不会危及其余代码的可靠性。
- en: The application can be tested by instantiating controllers and passing the parameters,
    with no need to use testing tools that operate on the browser pages. In this way,
    tests are easier to implement. Moreover, they do not depend on the way graphics
    are implemented, so they do not need to be updated each time the graphics change.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以通过实例化控制器并传递参数来进行测试，而无需使用在浏览器页面上操作的测试工具。这样，测试更容易实现。此外，它们不依赖于图形的实现方式，因此不需要在图形更改时更新。
- en: It is easier to split the job between developers that implement controllers
    and graphic designers that implement views. Often, graphic designers have difficulties
    with Razor, so they might just furnish an example HTML page that developers transform
    into Razor views that operate on the actual data.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将工作分配给实现控制器的开发人员和实现视图的图形设计师更容易。通常，图形设计师在Razor方面有困难，因此他们可能只提供一个示例HTML页面，由开发人员将其转换为操作实际数据的Razor视图。
- en: Now, let's look at how to create a web app in ASP.NET Core MVC.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在ASP.NET Core MVC中创建Web应用程序。
- en: Use case – implementing a web app in ASP.NET Core MVC
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 在ASP.NET Core MVC中实现Web应用程序
- en: In this section, as an example of the ASP.NET Core application, we will implement
    the administrative panel for managing the destinations and packages of the `WWTravelClub`
    book use case. The application will be implemented with the **Domain-Driven Design**
    (**DDD**) approach described in *Chapter 12*, *Understanding the Different Domains
    in Software Solutions*. So, having a good understanding of that chapter is a fundamental
    prerequisite to reading this section. The subsections that follow describe the
    overall application specifications and organization, and then the various application
    parts.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，作为ASP.NET Core应用程序的示例，我们将实现用于管理`WWTravelClub`书中目的地和套餐的管理面板。该应用程序将使用*第12章*中描述的**领域驱动设计**（**DDD**）方法进行实现，因此对该章的充分理解是阅读本节的基本先决条件。接下来的小节描述了整体应用程序规范和组织，以及各种应用程序部分。
- en: Defining application specifications
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义应用程序规范
- en: 'The destinations and packages were described in *Chapter 8*, *Interacting with
    Data in C# – Entity Framework Core*. Here, we will use exactly the same data model,
    with the necessary modifications to adapt it to the DDD approach. The administrative
    panel must allow packages, a destinations listing, and CRUD operations on it.
    To simplify the application, the two listings will be quite simple: the application
    will show all destinations sorted according to their names, while all packages
    will be sorted starting from the ones with a higher-end validity date.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地和套餐在*第8章*中描述，*在C#中与数据交互 - Entity Framework Core*。在这里，我们将使用完全相同的数据模型，对其进行必要的修改以适应DDD方法。管理面板必须允许套餐、目的地列表，并对其进行CRUD操作。为了简化应用程序，这两个列表将非常简单：应用程序将显示所有按名称排序的目的地，而所有套餐将按照其有效日期开始排序。
- en: 'Moreover, we suppose the following things:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们假设以下事项：
- en: The application that shows destinations and packages to the user shares the
    same database used by the administrative panel. Since only the administrative
    panel application needs to modify data, there will be just one write copy of the
    database with several read-only replicas.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向编辑窗口添加：
- en: Price modifications and package deletions are immediately used to update the
    user's shopping carts. For this reason, the administrative application must send
    asynchronous communications about price changes and package removals. We will
    not implement the whole communication logic here, but we will just add all such
    events to an event table, which should be used as input to a parallel thread that's
    in charge of sending these events to all relevant microservices.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格修改和套餐删除立即用于更新用户的购物车。因此，管理应用程序必须发送关于价格变化和套餐删除的异步通信。我们不会在这里实现整个通信逻辑，但我们将所有这类事件添加到事件表中，该表应作为输入发送给负责将这些事件发送到所有相关微服务的并行线程。
- en: Here, we will give the full code for just package management; most of the code
    for destination management is left as an exercise for you. The full code is available
    in the `ch15` folder of the GitHub repository associated with this book. In the
    remainder of this section, we will describe the application's overall organization
    and discuss some relevant samples of code.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将为套餐管理提供完整的代码；目的地管理的大部分代码留作练习。完整的代码可在与本书相关的GitHub存储库的`ch15`文件夹中找到。在本节的其余部分，我们将描述应用程序的整体组织并讨论一些相关的代码示例。
- en: Defining the application architecture
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义应用程序架构
- en: 'The application is organized based on the guidelines described in *Chapter
    12*, *Understanding the Different Domains in Software Solution*, while considering
    the DDD approach and using SOLID principles to map your domain sections. That
    is, the application is organized into three layers, each implemented as a different
    project:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序根据*第12章*中描述的指南进行组织，*理解软件解决方案中的不同领域*，同时考虑DDD方法并使用SOLID原则来映射您的领域部分。也就是说，应用程序分为三个层，每个层都作为不同的项目实现：
- en: 'There''s a data layer that contains the repository''s implementation and the
    classes describing database entities. It is a .NET Core library project. However,
    since it needs some interfaces like `IServiceCollection`, which are defined in
    `Microsoft.NET.Sdk.web`, we must add a reference not only to the .NET Core SDK
    but also to the ASP.NET Core SDK. This can be done as follows:'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个数据层，其中包含存储库的实现和描述数据库实体的类。这是一个.NET Core库项目。但是，由于它需要一些接口，如`IServiceCollection`，这些接口在`Microsoft.NET.Sdk.web`中定义，因此我们必须添加对.NET
    Core SDK和ASP.NET Core SDK的引用。可以按照以下步骤完成：
- en: Right-click on the project icon in the solution explorer and select **Edit project
    file**.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击项目图标，然后选择**编辑项目文件**。
- en: 'In the edit window add:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示目的地和套餐给用户的应用程序与管理面板使用相同的数据库。由于只有管理面板应用程序需要修改数据，因此将只有一个写入数据库副本和多个只读副本。
- en: '[PRE69]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: There's also a domain layer that contains repository specifications; that is,
    interfaces that describe repository implementations and DDD aggregates. In our
    implementation, we decided to implement aggregates by hiding the forbidden operations/properties
    of root data entities behind interfaces. Hence, for instance, the `Package` data
    layer class, which is an aggregate root, has a corresponding `IPackage` interface
    in the domain layer that hides all the property setters of the `Package` entity.
    The domain layer also contains the definitions of all the domain events, while
    the corresponding event handlers are defined in the application layer.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一个域层，其中包含存储库规范；即描述存储库实现和DDD聚合的接口。在我们的实现中，我们决定通过在接口后隐藏根数据实体的禁止操作/属性来实现聚合。因此，例如，`Package`数据层类，它是一个聚合根，在域层中有一个相应的`IPackage`接口，它隐藏了`Package`实体的所有属性设置器。域层还包含所有领域事件的定义，而相应的事件处理程序在应用程序层中定义。
- en: Finally, there's the application layer – that is, the ASP.NET Core MVC application
    – where we define DDD queries, commands, command handlers, and event handlers.
    Controllers fill query objects and execute them to get ViewModels they can pass
    to views. They update storage by filling command objects and executing their associated
    command handlers. In turn, command handlers use `IRepository` interfaces and `IUnitOfWork`
    coming from the domain layer to manage and coordinate transactions.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，还有应用程序层 - 即ASP.NET Core MVC应用程序 - 在这里我们定义DDD查询、命令、命令处理程序和事件处理程序。控制器填充查询对象并执行它们以获取它们可以传递给视图的ViewModels。它们通过填充命令对象并执行其关联的命令处理程序来更新存储。反过来，命令处理程序使用来自域层的`IRepository`接口和`IUnitOfWork`来管理和协调事务。
- en: The application uses the Query Command Segregation pattern; therefore, it uses
    command objects to modify the storage and the query object to query it.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用查询命令分离模式；因此，它使用命令对象来修改存储和查询对象来查询它。
- en: 'The query is simple to use and implement: controllers fill their parameters
    and then call their execution methods. In turn, query objects have direct LINQ
    implementations that project results directly onto the ViewModels used by the
    controller Views with `Select` LINQ methods. You may also decide to hide the LINQ
    implementation behind the same repository classes used for the storage update
    operations, but this would turn the definition and modification of simple queries
    into very time-consuming tasks.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: In any case, it is good practice to hide query objects behind interfaces so
    that their implementations can be replaced by fake implementations when you test
    controllers.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: However, the chain of objects and calls involved in the execution of commands
    is more complex. This is because it requires the construction and modification
    of aggregates, as well as a definition of the interaction between several aggregates
    and between aggregates and other applications through domain events to be provided.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a sketch of how storage update operations are performed.
    The circles are data being exchanged between the various layers, while rectangles
    are the procedures that process them. Moreover, dotted arrows connect interfaces
    with types that implement them:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_15_06.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: Diagram of command execution'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the flow of action through *Figure 15.6* as a list of steps:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: A controller's action method receives one or more ViewModels and performs validation.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One or more ViewModels containing changes to apply are hidden behind interfaces
    (`IMyUpdate`) defined in the domain layer. They are used to fill the properties
    of a command object. These interfaces must be defined in the domain layer since
    they will be used as arguments of the repository methods defined there.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A command handler matching the previous command is retrieved via DI in the controller
    action method (through the`[FromServices]` parameter attribute we described in
    the *Defining Controllers and ViewModels* subsection). Then, the handler is executed.
    During its execution, the handler interacts with various repository interface
    methods and with the aggregates they return.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When creating the command handler discussed in *step 3*, the ASP.NET Core DI
    engine automatically injects all parameters declared in its constructor. In particular,
    it injects all `IRepository` implementations needed to perform all command handler
    transactions. The command handler performs its job by calling the methods of these
    `IRepository` implementations received in its constructor to build aggregates
    and modify the built aggregates. Aggregates either represent already-existing
    entities or newly created ones. Handlers use the `IUnitOfWork` interface contained
    in each `IRepository`, as well as the concurrency exceptions returned by the data
    layer, to organize their operations as transactions. It is worth pointing out
    that each aggregate has its own `IRepository`, and that the whole logic for updating
    each aggregate is defined in the aggregate itself, not in its associated `IRepository`,
    to keep the code more modular.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Behind the scenes, in the data layer, `IRepository` implementations use Entity
    Framework to perform their job. Aggregates are implemented by root data entities
    hidden behind interfaces defined in the domain layer, while `IUnitOfWork` methods,
    which handle transactions and pass changes to the database, are implemented with
    `DbContext` methods. In other words, `IUnitOfWork` is implemented with the application's
    `DbContext`.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Domain events are generated during each aggregate process and are added to the
    aggregates themselves by us calling their `AddDomainEvent` methods. However, they
    are not triggered immediately. Usually, they are triggered at the end of all the
    aggregates' processing and before changes are passed to the database; however,
    this is not a general rule.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application handles errors by throwing exceptions. A more efficient approach
    would be to define a request-scoped object in the dependency engine, where each
    application subpart may add its errors as domain events. However, while this approach
    is more efficient, it increases the complexity of the code and the application
    development time.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Visual Studio solution is composed of three projects:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: There's a project containing the domain layer called `PackagesManagementDomain`,
    which is a .NET Standard 2.0 library.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a project containing the whole data layer called `PackagesManagementDB`,
    which is a .NET 5.0 library.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there's an ASP.NET Core MVC 5.0 project called `PackagesManagement`
    that contains both application and presentation layers. When you define this project,
    select **no authentication**; otherwise, the user database will be added directly
    to the ASP.NET Core MVC project instead of to the database layer. We will add
    the user database manually in the data layer.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by creating the `PackagesManagement` ASP.NET Core MVC project so
    that the whole solution has the same name as the ASP.NET Core MVC project. Then,
    we'll add the other two library projects to the same solution.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let the ASP.NET Core MVC project reference both projects, while `PackagesManagementDB`
    references `PackagesManagementDomain`. We suggest you define your own projects
    and then copy the code of this book's GitHub repository into them as you read
    this section.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes the code of the `PackagesManagementDomain` data
    layer project.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Defining the domain layer
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the `PackagesManagementDomain` standard 2.0 library project has been added
    to the solution, we'll add a `Tools` folder to the project root. Then, we'll place
    all the `DomainLayer` tools contained in the code associated with `chapter 12`.
    Since the code contained in this folder uses data annotations and defines DI extension
    methods, we must also add references to the `System.ComponentModel.Annotations`
    and `Microsoft.Extensions.DependencyInjection` NuGet packages.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need an `Aggregates` folder containing all the aggregate definitions
    (remember, we implemented aggregates as interfaces); namely, `IDestination`, `IPackage`,
    and `IPackageEvent`. Here, `IPackageEvent` is the aggregate associated with the
    table where we will place events to be propagated to other applications.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s analyze `IPackage`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'It contains the same properties of the `Package` entity, which we saw in *Chapter
    8*, *Interacting with Data in C# – Entity Framework Core*. The only differences
    are the following:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: It inherits from `IEntity<int>`, which furnishes all basic functionalities of
    aggregates.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has no `Id` property since it is inherited from `IEntity<int>`.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All properties are read-only, and it has a `FullUpdate` method since all aggregates
    can only be modified through update operations defined in the user domain (in
    our case, the `FullUpdate` method).
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's also add a `DTOs` folder. Here, we place all interfaces used to pass
    updates to the aggregates. Such interfaces are implemented by the application
    layer ViewModels used to define such updates. In our case, it contains `IPackageFullEditDTO`,
    which we can use to update existing packages. If you would like to add the logic
    to manage destinations, you must define an analogous interface for the `IDestination`
    aggregate.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'An `IRepository` folder contains all repository specifications; namely, `IDestinationRepository`,
    `IPackageRepository`, and `IPackageEventRepository`. Here, `IPackageEventRepository`
    is the repository associated with the `IPackageEvent` aggregate. As an example,
    let''s have a look at the `IPackageRepository` repository:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Repositories always contain just a few methods since all business logic should
    be represented as aggregate methods – in our case, just the methods to create
    a new package, to retrieve an existing package, and to delete an existing package.
    The logic to modify an existing package is included in the `FullUpdate` method
    of `IPackage`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, as with all domain layer projects, `PackagesManagementDomain` contains
    an event folder containing all domain event definitions. In our case, the folder
    is named `Events` and contains the package-deleted event and the price-changed
    event:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When an aggregate sends all its changes to another application, it must have
    a version property. The application that receives the changes uses this version
    property to apply all changes in the right order. An explicit version number is
    necessary because changes are sent asynchronously, so the order they are received
    in may differ from the order they were sent in. For this purpose, events that
    are used to publish changes outside of the application have both `OldVersion`
    (the version before the change) and `NewVersion` (the version after the change)
    properties. Events associated with delete events have no `NewVersion` since after
    being deleted, an entity can't store any versions.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection explains how all interfaces defined in the domain layer
    are implemented in the data layer.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data layer
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data layer project contains references to the `Microsoft.AspNetCore.Identity.EntityFrameworkCore`
    and `Microsoft.EntityFrameworkCore.SqlServer` NuGet packages, since we use Entity
    Framework Core with SQL server. It references `Microsoft.EntityFrameworkCore.Tools`
    and `Microsoft.EntityFrameworkCore.Design`, which are needed to generate database
    migrations, as explained in the *Entity Framework Core migrations* section of
    *Chapter 8*, *Interacting with Data in C# – Entity Framework Core*.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a `Models` folder that contains all database entities. They are similar
    to the ones in *Chapter 8*, *Interacting with Data in C# – Entity Framework Core*.
    The only differences are as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: They inherit from `Entity<T>`, which contains all basic features of aggregates.
    Please notice that inheriting from `Entity<T>` is only needed for aggregate roots;
    all other entities must be defined as explained in *Chapter 8*, *Interacting with
    Data in C# – Entity Framework Core*. In our example, all entities are aggregate
    roots.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have no `Id` since it is inherited from `Entity<T>`.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of them have an `EntityVersion` property that is decorated with the `[ConcurrencyCheck]`
    attribute. It contains the entity version that is needed for sending a property
    all entity changes to other applications. The `ConcurrencyCheck` attribute is
    needed to prevent concurrency errors while updating the entity version. This prevents
    suffering the performance penalty implied by a transaction.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More specifically, when saving entity changes, if the value of a field marked
    with the `ConcurrencyCheck` attribute is different from the one that was read
    when the entity was loaded in memory, a concurrency exception is thrown to inform
    the calling method that someone else modified this value after the entity was
    read, but before we attempted to save its changes. This way, the calling method
    can repeat the whole operation with the hope that, this time, no one will write
    the same entity in the database during its execution.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth analyzing the `Package` entity:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `FullUpdate` method is the only way to update the `IPackage` aggregate when
    the price changes add `PackagePriceChangedEvent` to the entity list of events.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MainDBContext.cs` file contains the data layer database context definition.
    It doesn''t inherit from `DBContext` but from the following predefined context
    class:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This context defines the user's tables needed for the authentication. In our
    case, we opted for the `IdentityUser<T>` standard and `IdentityRole<S>` for users
    and roles, respectively, and used integers for both the `T` and `S` Entity keys.
    However, we may also use classes that inherit from `IdentityUser` and `IdentityRole`
    and then add further properties.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: In the `OnModelCreating` method, we must call `base.OnModelCreating(builder)`
    in order to apply the configuration defined in `IdentityDbContext`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '`MainDBContext` implements `IUnitOfWork`. The following code shows the implementation
    of all methods that start, roll back, and commit a transaction:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: However, they are rarely used by command classes in a distributed environment.
    This is because retrying the same operation until no concurrency exception is
    returned usually ensures better performance than transactions.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth analyzing the implementation of the method that passes all changes
    applied to `DbContext` to the database:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The preceding implementation just calls the `SaveChangesAsync DbContext` context
    method, which saves all changes to the database, but then it intercepts all concurrency
    exceptions and detaches all the entities involved in the concurrency error from
    the context. This way, next time a command retries the whole failed operation,
    their updated versions will be reloaded from the database.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Repositories` folder contains all repository implementations. It is worth
    analyzing the implementation of the `IPackageRepository.Delete` method:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: It reads the entity from the database and formally removes it from the `Packages`
    dataset. This will force the entity to be deleted in the database when changes
    are saved to the database. Moreover, it adds `PackageDeleteEvent` to the aggregate
    list of events.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: The `Extensions` folder contains the `DBExtensions` static class, which, in
    turn, defines two extension methods to be added to the application DI engine and
    the ASP.NET Core pipeline, respectively. Once added to the pipeline, these two
    methods will connect the database layer to the application layer.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IServiceCollection` extension of `AddDbLayer` accepts (as its input parameters)
    the database connection string and the name of the `.dll` file that contains all
    migrations. Then, it does the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: That is, it adds the database context to the DI engine and defines its options;
    namely, that it uses SQL Server, the database connection string, and the name
    of the `.dll` file that contains all migrations.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it does the following:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: That is, it adds and configures all the types needed to handle database-based
    authentication. In particular, it adds the `UserManager` and `RoleManager` types,
    which the application layer can use to manage users and roles. `AddDefaultTokenProviders`
    adds the provider that creates the authentication tokens using data contained
    in the database when users log in.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it discovers and adds to the DI engine all repository implementations
    by calling the `AddAllRepositories` method, which is defined in the DDD tools
    we added to the domain layer project.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: The `UseDBLayer` extension method ensures migrations are applied to the database
    by calling `context.Database.Migrate()` and then populates the database with some
    initial objects. In our case, it uses `RoleManager` and `UserManager` to create
    an administrative role and an initial administrator, respectively. Then, it creates
    some sample destinations and packages.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '`context.Database.Migrate()`is useful to quickly set up and update staging
    and test environments. When deploying in production, instead, an SQL script should
    be produced from the migrations using the migration tools. Then, this script should
    be examined before being applied by the person in charge of maintaining the database.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'To create migrations, we must add the aforementioned extension methods to the
    ASP.NET Core MVC `Startup.cs` file, as shown here:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Please be sure that both the authorization and authentication modules have been
    added to the ASP.NET Core pipeline; otherwise, the authentication/authorization
    engine will not work.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must add the connection string to the `appsettings.json` file, as
    shown here:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Finally, let's add `Microsoft.EntityFrameworkCore.Design` to the ASP.NET Core
    project.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, let''s open Visual Studio Package Manager Console, select `PackageManagementDB`
    as the default project, and then launch the following command:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The preceding command will scaffold the first migration. We may apply it to
    the database with the `Update-Database` command. Please note that if you copy
    the project from GitHub, you don't need to scaffold migrations since they have
    already been created, but you still need to update the database.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes the application layer.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Defining the application layer
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a first step, for simplicity, let''s freeze the application culture to `en-US`
    by adding the code that follows to the ASP.NET Core pipeline:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, let''s create a `Tools` folder and place the `ApplicationLayer` code
    there, which you may find in the `ch12` code of the GitHub repository associated
    with this book. With these tools in place, we can add the code that automatically
    discovers and adds all queries, command handlers, and event handlers to the DI
    engine, as shown here:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Then, we must add a `Queries` folder to place all queries and their associated
    interfaces. As an example, let''s have a look at the query that lists all packages:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The query object is automatically injected into the application DB context.
    The `GetAllPackages` method uses LINQ to project all of the required information
    into `PackageInfosViewModel` and sorts all results in descending order on the
    `EndValidityDate` property.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '`PackageInfosViewModel` is placed in the `Models` folder together with all
    other ViewModels. It is good practice to organize ViewModels into folders by defining
    a different folder for each controller. It is worth analyzing the ViewModel used
    for editing packages:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: It has a constructor that accepts an `IPackage` aggregate. This way, package
    data is copied into the ViewModel that is used to populate the edit view. It implements
    the `IPackageFullEditDTO` DTO interface defined in the domain layer. This way,
    it can be directly used to send `IPackage` updates to the domain layer.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'All properties contain validation attributes that are automatically used by
    client-side and server-side validation engines. Each property contains a `Display`
    attribute that defines the label to give to the input field that will be used
    to edit the property. It is better to place the field labels in the ViewModels
    than placing them directly into the views since, this way, the same names are
    automatically used in all views that use the same ViewModel. The following code
    block lists all its properties:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `Commands` folder contains all commands. As an example, let''s have a look
    at the command used to modify packages:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Its constructor must be invoked with an implementation of the `IPackageFullEditDTO`
    DTO interface, which, in our case, is the edit ViewModel we described previously.
    Command handlers are placed in the `Handlers` folder. It is worth analyzing the
    command that updates packages:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Its constructor has automatically injected the `IPackageRepository` repository
    and an `IEventMediator` instance needed to trigger event handlers. The following
    code also shows the implementation of the standard `HandleAsync` command handler
    method:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Command operations are repeated until no concurrency exception is returned.
    `HandleAsync` uses the repository to get an instance of the entity to modify.
    If the entity is not found (it has been deleted), the commands stop its execution.
    Otherwise, all changes are passed to the retrieved aggregate. Immediately after
    the update, all events contained in the aggregate are triggered. In particular,
    if the price has changed, the event handler associated with the price change is
    executed. The concurrency check declared with the `[ConcurrencyCheck`] attribute
    on the `EntityVersion` property of the `Package` entity ensures that the package
    version is updated properly (by incrementing its previous version number by 1),
    as well as that the price changed event is passed the right version numbers.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, event handlers are placed in the `Handlers` folder. As an example, let''s
    have a look at the price changed event handler:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The constructor has automatically injected the `IPackageEventRepository` repository
    that handles the database table and all the events to send to other applications.
    The `HandleAsync` implementation simply calls the repository method that adds
    a new record to this table.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: All records in the table are handled by `IPackageEventRepository`, which can
    be retrieved and sent to all interested microservices by a parallel task defined
    in the DI engine with a call such as `services.AddHostedService<MyHostedService>();`,
    as detailed in the *Using generic hosts* subsection of *Chapter 5*, *Applying
    Microservice Architecture to Your Enterprise Application*. However, this parallel
    task is not implemented in the GitHub code associated with this chapter.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes how controllers and views are designed.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Controllers and views
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to add two more controllers to the one automatically scaffolded by Visual
    Studio; namely, `AccountController`, which takes care of user login/logout and
    registration, and `ManagePackageController`, which handles all package-related
    operations. It is enough to right-click on the `Controllers` folder and then select
    **Add** | **Controller**. Then, choose the controller name and select the empty
    MVC controller to avoid the possibility of Visual Studio scaffolding code you
    don't need.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, `AccountController` just has login and logout methods, so you
    can log in just with the initial administrator user. However, you can add further
    action methods that use the `UserManager` class to define, update, and delete
    users. The `UserManager` class can be provided through DI, as shown here:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`SignInManager` takes care of login/logout operations. The `Logout` action
    method is quite simple and is shown here:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: It just calls the `signInManager.SignOutAsync` method and then redirects the
    browser to the home page. To avoid it being called by clicking a link, it is decorated
    with `HttpPost`, so it can only be invoked via a form submit.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'Login, on the other hand, requires two action methods. The first one is invoked
    via `Get` and shows the login form, where the user must place their username and
    password. It is shown here:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'It receives `returnUrl` as its parameter when the browser is automatically
    redirected to the login page by the authorization module. This happens when an
    unlogged user tries to access a protected page. `returnUrl` is stored in the `ViewState`
    dictionary that is passed to the login view. The form in the login view passes
    it back, together with the username and password, to the controller when it is
    submitted, as shown in this code:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The form post is intercepted by an action method with the same `Login` name
    but decorated with the `[HttpPost]` attribute, as shown here:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The preceding method receives the `Login` model used by the login view, together
    with the `returnUrl` query string parameter. The `ValidateAntiForgeryToken` attribute
    verifies a token (called an anti-forgery token) that MVC forms automatically.
    This is then added to a hidden field to prevent cross-site attacks.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, the action method logs the user out if they are already logged
    in:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Otherwise, it verifies whether there are validation errors, in which case it
    shows the same view filled with the data of the ViewModel to let the user correct
    their errors:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If the model is valid, `_signInManager` is used to log the user in:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If the result returned by the operation is successful, the action method redirects
    the browser to `returnUrl` if it''s not null; otherwise, it redirects the browser
    to the home page:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: If the login fails, it adds an error to `ModelState` and shows the same form
    to let the user try again.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '`ManagePackagesController` contains an `Index` method that shows all packages
    in table format:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The query object is injected into the action method by DI. Then, the action
    method invokes it and inserts the resulting `IEnumerable` into the `Items` property
    of a `PackagesListViewModel` instance. It is a good practice to include `IEnumerables`
    in ViewModels instead of passing them directly to the views so that, if necessary,
    other properties can be added without the need to modify the existing view code.
    Results are shown in a Bootstrap 4 table since Bootstrap 4 CSS is automatically
    scaffolded by Visual Studio.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is shown here:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_15_07.png)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: Application packages handling page'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: 'The **New package** link (it is shaped like a **Bootstrap 4** button, but it
    is a link) invokes a controller `Create` action method, while the **delete** and
    **edit** links in each row invoke a `Delete` and `Edit` action method, respectively,
    and pass them the ID of the package shown in the row. Here is the implementation
    of the two-row links:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'It is worth describing the code of the `HttpGet` and `HttpPost` `Edit` action
    methods:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The `Edit` method of `HttpGet` uses `IPackageRepository` to retrieve the existing
    package. If the package is not found, that means it has been deleted by some other
    user, and the browser is redirected again to the list page to show the updated
    list of packages. Otherwise, the aggregate is passed to the `PackageFullEditViewModel`
    ViewModel, which is rendered by the `Edit` view.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: 'The view used to render the package must render `select` with all possible
    package destinations, so it needs an instance of the `IDestinationListQuery` query
    that was implemented to assist with the destination selection HTML logic. This
    query is injected directly into the view since it is the view''s responsibility
    to decide how to enable the user to select a destination. The code that injects
    the query and uses it is shown here:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The action method that processes the post of the view form is given here:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: If `ModelState` is valid, `UpdatePackageCommand` is created and its associated
    handler is invoked; otherwise, the View is displayed again to the user to enable
    them to correct all the errors.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'The new links to the package list page and login page must be added to the
    main menu, which is in the `_Layout` view, as shown here:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '`logoutForm` is an empty form whose only purpose is to send a post to the `Logout`
    action method. It has been added to the end of the body, as shown here:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Now, the application is ready! You can run it, log in, and start to manage packages.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed the ASP.NET Core pipeline and various modules that
    comprise an ASP.NET Core MVC application in detail, such as authentication/authorization,
    the options framework, and routing. Then, we described how controllers and Views
    map requests to response HTML. We also analyzed all the improvements introduced
    in the latest versions.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we analyzed all the design patterns implemented in the ASP.NET Core
    MVC framework and, in particular, the importance of the Separation of Concerns
    principle and how ASP.NET Core MVC implements it in the ASP.NET Core pipeline,
    as well as in its validation and globalization modules. We focused in more detail
    on the importance of Separation of Concerns between the presentation layer logic
    and graphics, as well as how the MVC pattern ensures it.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter explains how to implement a presentation layer as a **Single-Page
    Application** (**SPA**) with the new Blazor WebAssembly framework.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you list all the middleware modules scaffolded by Visual Studio in an ASP.NET
    Core project?
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the ASP.NET Core pipeline module need to inherit from a base class or implement
    some interface?
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that a tag must have just one tag helper defined for it, otherwise
    an exception is thrown?
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you remember how to test if validation errors have occurred in a controller?
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the instruction in a layout view for including the output of the main
    view that's called?
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are secondary sections of the main view invoked in a layout view?
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a controller invoke a view?
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, how many providers are installed in the globalization module?
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are ViewModels the only way for controllers to communicate with their invoked
    views?
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More details on the ASP.NET MVC framework are available in its official documentation
    at [https://docs.microsoft.com/en-US/aspnet/core/](https://docs.microsoft.com/en-US/aspnet/core/)
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details on the Razor syntax can be found at [https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?tabs=visual-studio).
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the creation custom tag helpers that were not discussed in
    this chapter can be found at [https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring](https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring).
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the creation of custom controller attributes can be found at
    [https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters](https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters).
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The definition of custom validation attributes is discussed in this article:
    [https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/](https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/).'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
