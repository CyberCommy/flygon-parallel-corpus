- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Presenting ASP.NET Core MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to implement an application presentation
    layer. More specifically, you will learn how to implement a web application based
    on ASP.NET Core MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core is a .NET framework for implementing web applications. ASP.NET
    Core has been partially described in previous chapters, so this chapter will focus
    mainly on ASP.NET Core MVC. More specifically, this chapter will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the presentation layers of web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the ASP.NET Core MVC structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is new in the latest versions of ASP.NET Core?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the connection between ASP.NET Core MVC and design principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case â€“ implementing a web app in ASP.NET Core MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will review and give further details on the structure of the ASP.NET Core
    framework, which, in part, was discussed in *Chapter 14*, *Applying Service-Oriented
    Architectures with .NET Core*, and *Chapter 4*, *Deciding the Best Cloud-Based
    Solution*. Here, the main focus is on how to implement web-based presentation
    layers based on the so-called **Model View Controller** (**MVC**) architectural
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We will also analyze all of the new features available in the last ASP.NET Core
    5.0 version, as well as the architectural patterns included in the ASP.NET Core
    MVC framework and/or used in typical ASP.NET Core MVC projects. Some of these
    patterns were discussed in *Chapter 11*, *Design Patterns and .NET 5 Implementation*,
    and *Chapter 12*, *Understanding the Different Domains in Software Solutions*,
    whereas some others, such as the MVC pattern itself, are new.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to implement an ASP.NET Core MVC application, as well as
    how to organize the whole Visual Studio solution, by going through a practical
    example at the end of this chapter. This example describes a complete ASP.NET
    Core MVC application for editing the packages of the WWTravelClub book use case.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the free Visual Studio 2019 Community edition or better
    with all database tools installed.
  prefs: []
  type: TYPE_NORMAL
- en: All the concepts in this chapter will be clarified with practical examples based
    on the WWTravelClub book use case. The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the presentation layers of web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter discusses an architecture for implementing the presentation layers
    of web-based applications based on the ASP.NET Core framework. The presentation
    layers of web applications are based on three techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mobile or desktop native applications that exchange data with servers through
    REST or SOAP services**: We have not discussed them since they are strictly tied
    to the client device and its operating system. Therefore, analyzing them, which
    would require a dedicated book, is completely beyond the scope of this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single-Page Applications** (**SPAs**): These are HTML-based applications
    whose dynamic HTML is created on the client either in JavaScript or with the help
    of WebAssembly (a kind of cross-browser assembly that can be used as a high-performance
    alternative to JavaScript). Like native applications, SPAs exchange data with
    the server through REST or SOAP services, but they have the advantage of being
    independent of the device and its operating system since they run in a browser.
    *Chapter 16*, *Blazor WebAssembly*, describes the Blazor SPA framework, which
    is based on WebAssembly, since it is based itself on a .NET runtime compiled in
    WebAssembly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTML pages created by the server whose content depends on the data to be
    shown to the user**: The ASP.NET Core MVC framework, which will be discussed in
    this chapter, is a framework for creating such dynamic HTML pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remainder of this chapter focuses on how to create HTML pages on the server
    side and, more specifically, on ASP.NET Core MVC, which will be introduced in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ASP.NET Core MVC structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core is based on the concept of the Generic Host, as explained in the
    *Using generic hosts* subsection of *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*. The basic architecture of ASP.NET Core was outlined
    in the *A short introduction to ASP.NET Core* subsection of *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth reminding you that the host configuration is delegated to the `Startup`
    class defined in the `Startup.cs` file by calling the `.UseStartup<Startup>()`
    method of the `IWebHostBuilder` interface. `ConfigureServices(IServiceCollection
    services)` of the `Startup` class defines all services that can be injected into
    object constructors through **Dependency Injection** (**DI**). DI was described
    in detail in the *Using generic hosts* subsection of *Chapter 5*, *Applying a
    Microservice Architecture to Your Enterprise Application*.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `Configure(IApplicationBuilder app, IWebHostEnvironment
    env)` startup method defines the so-called ASP.NET Core pipeline, which was briefly
    described in the *A short introduction to ASP.NET Core* subsection of *Chapter
    14*, *Applying Service-Oriented Architectures with .NET Core*, and which will
    be described in more detail in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: How the ASP.NET Core pipeline works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core furnishes a set of configurable modules you can assemble according
    to your needs. Each module takes care of a functionality that you may or may not
    need. Examples of such functionalities are authorization, authentication, static
    file processing, protocol negotiation, CORS handling, and so on. Since most of
    the modules apply transformations to the incoming request and the final response,
    these modules are usually referred to as **middleware**.
  prefs: []
  type: TYPE_NORMAL
- en: You can put together all of the modules you need by inserting them into a common
    processing framework called the **ASP.NET Core pipeline**.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, ASP.NET Core requests are processed by pushing a context
    object through a pipeline of ASP.NET Core modules, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_15_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: ASP.NET Core pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: The object that is inserted into the pipeline is an `HttpContext` instance that
    contains the data of the incoming request. More specifically, the `Request` property
    of `HttpContext` contains an `HttpRequest` object whose properties represent the
    incoming request in a structured way. There are properties for headers, cookies,
    request path, parameters, form fields, and the request body.
  prefs: []
  type: TYPE_NORMAL
- en: The various modules can contribute to the construction of the final response
    if we write them in an `HttpResponse` object contained in the `Response` property
    of the `HttpContext` instance. The `HttpResponse` class is similar to the `HttpRequest`
    class, but its properties refer to the response being built.
  prefs: []
  type: TYPE_NORMAL
- en: Some modules can build an intermediate data structure that is then used by other
    modules in the pipeline. In general, such intermediary data can be stored in custom
    entries of `IDictionary<object, object>`, which is contained in the `Items` property
    of the `HttpContext` object. However, there is a predefined property, `User`,
    that contains information about the currently logged-in user. The logged-in user
    is not computed automatically, so they must be computed by an authentication module.
    The *ASP.NET Core service authorization* subsection of *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*, explained how to add the standard
    module that performs JWT token-based authentication to the ASP.NET Core pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpContext` also has a `Connection` property that contains information on
    the underlying connection established with the client, as well as a `WebSockets`
    property that contains information on possible WebSocket-based connections established
    with the clients.'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpContext` also has a `Features` property that contains `IDictionary<Type,
    object>`, which specifies the features supported by the web server that hosts
    the web application and the modules of the pipeline. Features can be set with
    the `.Set<TFeature>(TFeature o)` method and can be retrieved with the `.Get<TFeature>()`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: Web server features are automatically added by the framework, while all other
    features are added by pipeline modules when they process `HttpContext`.
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpContext` also gives us access to the dependency injection engine through
    its `RequestServices` property. You can get an instance of a type managed by the
    dependency engine by calling the `.RequestService.GetService(Type t)` method or,
    even better, the `.GetRequiredService<TService>()` extension method that is built
    on top of it. However, as we will see in the remainder of this chapter, all types
    managed by the dependency injection engine are usually automatically injected
    into constructors, so these methods are only used when we''re building custom
    **middleware** or other customizations of the ASP.NET Core engine.'
  prefs: []
  type: TYPE_NORMAL
- en: The `HttpContext` instance that is created for processing a web request is not
    only available to modules, but also to the application code through DI. It is
    enough to insert an `IHttpContextAccessor` parameter into the constructor of a
    class that is automatically dependency injected, such as a service passed to a
    controller (see later on in this section), and then access its `HttpContext` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'A module is any class with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In general, each module processes the `HttpContext` instance that was passed
    by the previous module in the pipeline, then calls `await _next.Invoke(context)`
    to invoke the modules in the remainder of the pipeline. When the other modules
    have finished their processing and the response for the client has been prepared,
    each module can perform further post-processing of the response in the code that
    follows the `_next.Invoke(context)` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules are registered in the ASP.NET Core pipeline by calling the `UseMiddleware<T>`
    method in the `Startup.cs` file''s `Configure` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Modules are inserted into the pipeline in the same order when `UseMiddleware`
    is called. Since each functionality that''s added to an application might require
    several modules and might require operations other than adding modules, you usually
    define an `IApplicationBuilder` extension such as `UseMyFunctionality`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After that, the whole functionality can be added to the application by calling
    `app.UseMyFunctionality(...)`. For instance, the ASP.NET Core MVC functionality
    can be added to the ASP.NET Core pipeline by calling `app.UseEndpoints(....)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, functionalities that are added with each `app.Use...` require that some
    .NET types are added to the application DI engine. In these cases, we also define
    an `IServiceCollection` extension named `AddMyFunctionality`, which must be called
    in the `Startup.cs` file''s `ConfigureServices(IServiceCollection services)` method.
    For instance, ASP.NET Core MVC requires a call like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you don't need to change the default MVC options, you can simply call `services.AddControllersWithViews()`.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes another important feature of the ASP.NET Core
    framework; namely, how to handle application configuration data.
  prefs: []
  type: TYPE_NORMAL
- en: Loading configuration data and using it with the options framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an ASP.NET Core application starts, it reads configuration information
    (such as a database connection string) from the `appsettings.json` and `appsettings.[EnvironmentName].json`
    files, where `EnvironmentName` is a string value that depends on where the application
    is deployed. Typical values for `EnvironmentName` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Production` is used for production deployment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Development` is used during development'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Staging` is used when the application is tested in staging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two JSON trees that were extracted from the `appsettings.json` and `appsettings.[EnvironmentName].json`
    files are merged into a unique tree, where the values contained in `[EnvironmentName].json`
    override the values contained in the corresponding paths of `appsettings.json`.
    This way, the application can be run with different configurations in different
    deployment environments. In particular, you may use a different database connection
    string, and hence, a different database instance in each different environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `[EnvironmentName]` string is taken from the `ASPNETCORE_ENVIRONMENT` operating
    system environment variable. In turn, `ASPNETCORE_ENVIRONMENT` can be automatically
    set during the application''s deployment with Visual Studio in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: During Visual Studio deployment, Visual Studio's **Publish** wizard creates
    an XML publish profile. If the **Publish** wizard allows you to choose `ASPNETCORE_ENVIRONMENT`
    from its drop-down list, you are done:![](img/B16756_15_02.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 15.2: Visual Studio deployment settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, you may proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you've filled in the information in the wizard, save the publish profile
    without publishing it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, edit the profile with a text editor and add an XML property such as `<EnvironmentName>Staging</EnvironmentName>`.
    Since all the already defined publish profiles can be selected during the application's
    publication, you may define a different publish profile for each of your environments,
    and then you may select the one you need during each publication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The value you must set `ASPNETCORE_ENVIRONMENT` to during deployment can also
    be specified in the Visual Studio ASP.NET Core project file (`.csproj`) of your
    application by adding the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'During development in Visual Studio, the value to give to `ASPNETCORE_ENVIRONMENT`
    when the application is run can be specified in the `Properties\launchSettings.json`
    file of the ASP.NET Core project. The `launchSettings.json` file contains several
    named groups of settings. These settings configure how to launch the web application
    when it is run from Visual Studio. You may choose to apply all the settings of
    a group by selecting the group name with the drop-down list next to Visual Studio''s
    run button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_15_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: Choice of launch settings group'
  prefs: []
  type: TYPE_NORMAL
- en: Your selection from this drop-down list will be shown in the run button, with
    the default selection being **IIS Express**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows a typical `launchSettings.json` file in which you
    can either add a new group of settings or change the settings of the existing
    default groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The named groups of settings are under the `profiles` properties. There, you
    may choose where to host the application (`IISExpress`), where to launch the browser,
    and the values of some environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: The current environment that's been loaded from the `ASPNETCORE_ENVIRONMENT`
    operating system environment variable can be tested through the `IWebHostEnvironment`
    interface during the ASP.NET Core pipeline definition. This is because an `IWebHostEnvironment`
    instance is passed as a parameter to the `Startup.cs` file's `Configure` method.
    `IWebHostEnvironment` is also available to the remainder of the user code through
    DI.
  prefs: []
  type: TYPE_NORMAL
- en: '`IWebHostEnvironment.IsEnvironment(string environmentName)` checks whether
    the current value of `ASPNETCORE_ENVIRONMENT` is `environmentName`. There are
    also specific shortcuts for testing development (`.IsDevelopment()`), production
    (`.IsProduction()`), and staging (`.IsStaging()`). `IWebHostEnvironment` also
    contains the current root directory of the ASP.NET Core application (`.WebRootPath`)
    and the directory reserved for the static files (`.ContentRootPath`) that are
    served as-is by the web server (CSS, JavaScript, images, and so on).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `launchSettings.json` and all publish profiles can be accessed as children
    of the **Properties** node in Visual Studio Explorer, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_15_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: Launch settings file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `appsettings.json` and `appsettings.[EnvironmentName].json` have been
    loaded, the configuration tree resulting from their merge can be mapped to the
    properties of .NET objects. For example, let''s suppose we have an `Email` section
    of the `appsettings` file that contains all of the information needed to connect
    to an email server, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the whole `Email` section can be mapped to an instance of the following
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that performs the mapping must be inserted into the `ConfigureServices`
    method in the `Startup.cs` file since the `EmailConfig` instance will be available
    through DI. The code we need is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once we've configured the preceding settings, classes that need `EmailConfig`
    data must declare an `IOptions<EmailConfig> options` parameter that will be provided
    by the DI engine. An `EmailConfig` instance is contained in `options.Value`.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that the option classes' properties can be applied to
    the same validation attributes we will use for ViewModels (see the *Server-side
    and client-side validation* subsection).
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes the basic ASP.NET Core pipeline modules needed
    by an ASP.NET Core MVC application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the ASP.NET Core MVC pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you create a new ASP.NET Core MVC project in Visual Studio, a standard pipeline
    is created in the `Startup.cs` file's `Configure` method. There, if needed, you
    may add further modules or change the configuration of the existing modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial code of the `Configure` method handles errors and performs basic
    HTTPS configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If there are errors, if the application is in a development environment, the
    module installed by `UseDeveloperExceptionPage` adds a detailed error report to
    the response. This module is a valuable debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: If an error occurs when the application is not in development mode, `UseExceptionHandler`
    restores the request processing from the path it receives as an argument; that
    is, from `/Home/Error`. In other words, it simulates a new request with the `/Home/Error`
    path. This request is pushed into the standard MVC processing until it reaches
    the endpoint associated with the `/Home/Error` path, where the developer is expected
    to place the custom code that handles the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application is not in development, `UseHsts` adds the `Strict-Transport-Security`
    header to the response, which informs the browser that the application must only
    be accessed with HTTPS. After this declaration, compliant browsers should automatically
    convert any HTTP request of the application into an HTTPS request for the time
    specified in the `Strict-Transport-Security` header. By default, `UseHsts` specifies
    30 days as the time in the header, but you may specify a different time and other
    header parameters by adding an `options` object to the `ConfigureServices` method
    of `Startup.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`UseHttpsRedirection` causes an automatic redirection to an HTTPS URL when
    an HTTP URL is received, in a way that forces a secure connection. Once the first
    HTTPS secure connection is established, the `Strict-Transport-Security` header
    prevents future redirections that might be used to perform man-in-the-middle attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the remainder of the default pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`UseStaticFiles` makes all files contained in the `wwwroot` folder of the project
    (typically CSS, JavaScript, images, and font files) accessible from the web through
    their actual path.'
  prefs: []
  type: TYPE_NORMAL
- en: '`UseCookiePolicy` has been removed in the .NET 5 template, but you can still
    add it manually. It ensures that cookies are processed by the ASP.NET Core pipeline,
    but only if the user has given consent for cookie usage. Consent to cookie usage
    is given through a consent cookie; that is, cookie processing is enabled only
    if this consent cookie is found among the request cookies. This cookie must be
    created by JavaScript when the user clicks a consent button. The whole string
    that contains both the consent cookie''s name and its contents can be retrieved
    from `HttpContext.Features`, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`CanTrack` is `true` only if consent is required and has not been given yet.
    When the consent cookie is detected, `CanTrack` is set to `false`. This way, `showBanner`
    is `true` only if consent is required and it has not been given yet. Therefore,
    it tells us whether to ask the user for consent or not.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`UseAuthentication` enables authentication schemes and only appears if you
    select an authentication scheme when the project is created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specific authentication schemes can be enabled by configuring the options objects
    in the `ConfigureServices` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code specifies a custom authentication cookie name and adds JWT-based
    authentication for the REST service contained in the application. Both `AddCookie`
    and `AddJwtBearer` have overloads that accept the name of the authentication scheme
    before the action, which is where you can define the authentication scheme options.
    Since the authentication scheme name is necessary for referring to a specific
    authentication scheme, when it is not specified, a default name is used:'
  prefs: []
  type: TYPE_NORMAL
- en: The standard name contained in `CookieAuthenticationDefaults.AuthenticationScheme`
    for cookie authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard name contained in `JwtBearerDefaults.AuthenticationScheme` for
    JWT authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name that's passed into `o.DefaultScheme` selects the authentication scheme
    used for filling the `User` property of `HttpContext`. Together with `DefaultScheme`,
    there are other properties that allow more advanced customizations.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about JWT authentication, please refer to the *ASP.NET
    Core service authorization* subsection of *Chapter 14*, *Applying Service-Oriented
    Architectures with .NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: If you just specify `services.AddAuthentication()`, a cookie-based authentication
    with default parameters is assumed.
  prefs: []
  type: TYPE_NORMAL
- en: '`UseAuthorization` enables authorization based on the `Authorize` attribute.
    Options can be configured by placing the `AddAuthorization` method in the `ConfigureServices`
    method. These options allow you to define the policies for claims-based authorization.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on authorization, please refer to the *ASP.NET Core service
    authorization* subsection of *Chapter 14*, *Applying Service-Oriented Architectures
    with .NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: '`UseRouting` and `UseEndpoints` handle the so-called ASP.NET Core endpoints.
    An endpoint is an abstraction of a handler that serves specific classes of URLs.
    These URLs are transformed into an `Endpoint` instance with patterns. When a pattern
    matches a URL, an `Endpoint` instance is created and filled with both the pattern''s
    name and the data that was extracted from the URL. This is a consequence of matching
    URL parts with named parts of the pattern. This can be seen in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`UseRouting` adds a module that processes the request path to get the request
    `Endpoint` instance and adds it to the `HttpContext.Features` dictionary under
    the `IEndpointFeature` type. The actual `Endpoint` instance is contained in the
    `Endpoint` property of `IEndpointFeature`.'
  prefs: []
  type: TYPE_NORMAL
- en: Each pattern also contains the handler that should process all the requests
    that match the pattern. This handler is passed to `Endpoint` when it is created.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `UseEndpoints` adds the middleware that executes the route
    determined by the `UseRouting` logic. It is placed at the end of the pipeline
    since its middleware produces the final response. Splitting the routing logic
    into two separate middleware modules enables authorization middleware to sit in-between
    them and, based on the matched endpoint, to decide whether to pass the request
    to the `UseEndpoints` middleware for its normal execution, or whether to return
    a 401 (Unauthorized)/403 (Forbidden) response immediately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`MapControllerRoute` defines the patterns associated with the MVC engine, which
    will be described in the next subsection. There are other methods that define
    other types of patterns. A call such as `.MapHub<MyHub>("/chat")` maps paths to
    hubs that handle **SignalR**, an abstraction built on top of `WebSocket`, whereas
    `.MapHealthChecks("/health")` maps paths to ASP.NET Core components that return
    application health data. You can also directly map a pattern to a custom handler
    with `.MapGet`, which intercepts GET requests, and `.MapPost`, which intercepts
    POST requests. This is called **route to code**. The following is an example of
    `MapGet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Patterns are processed in the order in which they are defined until a matching
    pattern is found. Since the authentication/authorization middleware is placed
    after the routing middleware, it can process the `Endpoint` request to verify
    whether the current user has the required authorizations to execute the `Endpoint`
    handler. Otherwise, a 401 (Unauthorized) or 403 (Forbidden) response is immediately
    returned. Only requests that survive authentication and authorization have their
    handlers executed by the `UseEndpoints` middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the ASP.NET Core RESTful API described in *Chapter 14*, *Applying Service-Oriented
    Architectures with .NET Core*, ASP.NET Core MVC also uses attributes placed on
    controllers or controller methods to specify authorization rules. However, an
    instance of `AuthorizeAttribute` can be also added to a pattern to apply its authorization
    constraints to all the URLs matching that pattern, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code makes the health check path available only to administrative
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Having described the basic structure of the ASP.NET Core framework, we can now
    move toward more MVC-specific features. The next subsection describes controllers
    and explains how they interact with the UI components known as Views through ViewModels.
  prefs: []
  type: TYPE_NORMAL
- en: Defining controllers and ViewModels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The various `.MapControllerRoute` calls in `UseEndpoints` associate URL patterns
    with controllers and with the methods of these controllers, where controllers
    are classes that inherit from the `Microsoft.AspNetCore.Mvc.Controller` class.
    Controllers are discovered by inspecting all of the application's `.dll` files
    and are added to the DI engine. This job is performed by the call to `AddControllersWithViews`
    in the `ConfigureServices` method of the `startup.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline module that's added by `UseEndpoints` takes the controller name
    from the `controller` pattern variable, and the name of the controller method
    to invoke from the `action` pattern variable. Since, by convention, all controller
    names are expected to end with the `Controller` suffix, the actual controller
    type name is obtained from the name found in the `controller` variable by adding
    this suffix. Hence, for instance, if the name found in `controller` is `"Home"`,
    then the `UseEndpoints` module tries to get an instance of the `HomeController`
    type from the DI engine. All of the controller public methods can be selected
    by the routing rules. Use of a controller public method can be prevented by decorating
    it with the `[NonAction]` attribute. All controller methods available to the routing
    rules are called action methods.
  prefs: []
  type: TYPE_NORMAL
- en: MVC controllers work like the API controllers that we described in the *Implementing
    REST services with ASP.NET Core* subsection of *Chapter 14*, *Applying Service-Oriented
    Architectures with .NET Core*. The only difference is that API controllers are
    expected to produce JSON or XML, while MVC controllers are expected to produce
    HTML. For this reason, while API controllers inherit from the `ControllerBase`
    class, MVC controllers inherit from the `Controller` class, which, in turn, inherits
    from the `ControllerBase` class and adds its methods that are useful for HTML
    generation, such as invoking views, which are described in the next subsection,
    and creating a redirect response.
  prefs: []
  type: TYPE_NORMAL
- en: MVC controllers may also use a routing technique similar to one of the API controllers;
    that is, routing based on controllers and controller method attributes. This behavior
    is enabled by calling the `MapControllerRoute()` method in `UseEndpoints`. If
    this call is placed before all other `MapControllerRoute` calls, then the controller
    routes have priority on `MapControllerRoute` patterns; otherwise, the opposite
    is true.
  prefs: []
  type: TYPE_NORMAL
- en: All the attributes we have seen for API controllers can be also used with MVC
    controllers and action methods (`HttpGet`, `HttpPost`, `...Authorize`, and so
    on). Developers can write their own custom attributes by inheriting from the `ActionFilter`
    class or other derived classes. I will not give details on this right now, but
    these details can be found in the official documentation, which is referred to
    in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: When the `UseEndpoints` module invokes a controller, all of its constructor
    parameters are filled by the DI engine since the controller instance itself is
    returned by the DI engine, and since DI automatically fills constructor parameters
    with DI in a recursive fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Action method parameters, on the other hand, are taken from the following sources:'
  prefs: []
  type: TYPE_NORMAL
- en: Request headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables in the pattern matched by the current request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query string parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form parameters (in the case of POST requests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection (DI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the parameters filled with DI are matched by type, all other parameters
    are matched by *name* while ignoring the letter casing. That is, the action method
    parameter name must match the header, query string, form, or pattern variable.
    When the parameter is a complex type, a match is searched for in each property,
    using the property name for the match. In the case of nested complex types, a
    match is searched for each nested property's path, and the name associated with
    the path is obtained by chaining all the property names in the path and separating
    them with dots. For instance, `Property1.Property2.Property3...Propertyn` is the
    name associated with a path composed by the nested properties `Property1`, `Property2`,
    ...., `Propertyn`. The name that's obtained this way must match a header name,
    pattern variable name, query string parameter name, and so on. For instance, an
    `OfficeAddress` property containing a complex `Address` object would generate
    names like `OfficeAddress.Country`, `OfficeAddress.Town`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, simple type parameters are matched with pattern variables and query
    string variables, while complex types parameters are matched with form parameters.
    However, the preceding defaults can be changed by prefixing the parameters with
    attributes, as detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[FromForm]` forces a match with form parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromHeader]` forces a match with a request header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromRoute]` forces a match with pattern variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromQuery]` forces a match with a query string variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromServices]` forces the use of DI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'During the match, the string that was extracted from the selected source is
    converted into the type of the action method parameter using the current thread
    culture. If either a conversion fails or no match is found for an obligatory action
    method parameter, then the whole action method invocation process fails, and a
    404 response is automatically returned. For instance, in the following example,
    the `id` parameter is matched with query string parameters or pattern variables
    since it is a simple type, while `myclass` properties and nested properties are
    matched with form parameters since `MyClass` is a complex type. Finally, `myservice`
    is taken from DI since it is prefixed with the `[FromServices]` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If no match is found for the `id` parameter and if the `id` parameter is declared
    as obligatory in the `UseEndpoints` pattern, a 404 response is automatically returned
    since pattern matching fails. It is common to declare parameters as not optional
    when they must match not nullable single types. If, instead, no `MyService` instance
    is found in the DI container, an exception is thrown because in this case, the
    failure doesn't depend on a wrong request but a design error.
  prefs: []
  type: TYPE_NORMAL
- en: MVC controllers return an `IActionResult` interface or a `Task<IActionResult>`
    result if they are declared as `async`. `IActionResult` defines the unique method
    with the `ExecuteResultAsync(ActionContext)` signature, which, when invoked by
    the framework, produces the actual response.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each different `IActionResult`, MVC controllers have methods that return
    them. The most commonly used `IActionResult` is `ViewResult`, which is returned
    by a `View` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`ViewResult` is a very common way for a controller to create an HTML response.
    More specifically, the controller interacts with business/data layers to produce
    an abstraction of the data that will be shown in the HTML page. This abstraction
    is an object called a **ViewModel**. The ViewModel is passed as a second argument
    to the `View` method, while the first argument is the name of an HTML template,
    called View, that is instantiated with the data contained in the ViewModel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing this up, the MVC controllers'' processing sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The controllers perform some processing to create the ViewModel, which is an
    abstraction of the data to show on the HTML page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the controllers create `ViewResult` by passing a View name and ViewModel
    to the `View` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MVC framework invokes `ViewResult` and causes the template contained in
    the View to be instantiated with the data contained in the ViewModel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of the template's instantiation is written in the response with adequate
    headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This way, the controller performs the conceptual job of HTML generation by building
    a ViewModel, while the View â€“ that is, the template â€“ takes care of all the graphical
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Views will be described in greater detail in the next subsection, while the
    Model (ViewModel) View Controller pattern will be discussed in more detail in
    the *Understanding the connection between ASP.NET Core MVC and design principles*
    sectionÂ of this chapter. Finally, a practical example will be provided in the
    *UseÂ **case â€“ implementing* *a web app in ASP.NET Core MVC* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Another common `IActionResult` is `RedirectResult`, which creates a redirect
    response, hence forcing the browser to move to a specific URL. Redirects are often
    used once the user has successfully submitted a form that completes a previous
    operation. In this case, it is common to redirect the user to a page where they
    can select another operation.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to return `RedirectResult` is by passing a URL to the `Redirect`
    method. This is the advised way to perform a redirect to a URL that is outside
    the web application. On the other hand, when the URL is within the web application,
    it is advisable to use the `RedirectToAction` method, which accepts the controller
    name, the action method name, and the desired parameters for the target action
    method. The framework uses this data to compute a URL that causes the desired
    action method to be invoked with the provided parameters. This way, if the routing
    rules are changed during the application's development or maintenance, the new
    URL is automatically updated by the framework with no need to modify all occurrences
    of the old URL in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to call `RedirectToAction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful `IActionResult` is `ContentResult`, which can be created by
    calling the `Content` method. `ContentResult` allows you to write any string to
    the response and specify its MIME type, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `File` method returns `FileResult`, which writes binary data in
    the response. There are several overloads of this method that allow the specification
    of a byte array, a stream, or the path of a file, plus the MIME type of the binary
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to describing how actual HTML is generated in Views.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Razor Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core MVC uses a language called Razor to define the HTML templates
    contained in the Views. Razor views are files that are compiled into .NET classes
    when they''re first used, when the application has been built, or when the application
    has been published. By default, both pre-compilation on each build and on publish
    are enabled, but you can also enable runtime compilation so that the Views can
    be modified once they have been deployed. This option can be enabled by checking
    the **Enable Razor runtime compilation** checkbox when the project is created
    in Visual Studio. You can also disable compilation on each build and on publish
    by adding the following code to the web application project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Views can also be precompiled into views libraries if you choose a Razor view
    library project in the window that appears once you have chosen an ASP.NET Core
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Also, after the compilation, views remain associated with their paths, which
    become their full names. Each controller has an associated folder under the **Views**
    folder with the same name as the controller, which is expected to contain all
    the views used by that controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the folder associated with `HomeController`
    and its Views:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_15_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: View folders associated with controllers and the shared folder'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot also shows the **Shared** folder, which is expected
    to contain all the views or partial views used by several controllers. The controller
    refers to views in the `View` method through their paths without the `.cshtml`
    extension. If the path starts with `/`, the path is interpreted as relative to
    the application root. Otherwise, as a first attempt, the path is interpreted as
    relative to the folder associated with the controller. If no view is found there,
    the view is searched for in the **Shared** folder.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, for instance, the `Privacy.cshtml` View file in the preceding screenshot
    can be referred to from within `HomeController` as `View("Privacy", MyViewModel)`.
    If the name of the View is the same as the name of the action method, we can simply
    write `View(MyViewModel)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Razor views are a mix of HTML code with C# code, plus some Razor-specific statements.
    They all begin with a header that contains the type of ViewModel that the View
    is expected to receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Each view may also contain some `using` statements whose effect is the same
    as the `using` statements of standard code files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`@using` statements declared in the special `_ViewImports.cshtml` file â€“ that
    is, in the root of the `Views` folder â€“ are automatically applied to all views.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each view can also require instances of types from the DI engine in its header
    with the syntax shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code requires an instance of the `IViewLocalizer` interface and
    places it in the `Localizer` variable. The remainder of the View is a mix of C#
    code, HTML, and Razor control flow statements. Each area of a view can be either
    in HTML mode or C# mode. The code in a View area that is in HTML mode is interpreted
    as HTML, while the code in a View area that is in C# mode is interpreted as C#.
  prefs: []
  type: TYPE_NORMAL
- en: The topic that follows explains the Razor flow of control statements.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the Razor flow of control statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to write some C# code in an HTML area, you can create a C# area
    with the `@{..}` Razor flow of control statement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows that it is enough to write an HTML tag to create
    an HTML area inside of the C# area and so on recursively. As soon as the HTML
    tag closes, you are in C# mode again.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# code produces no HTML, while HTML code is added to the response in the same
    order it appears. You can add text computed with C# code while in HTML mode by
    prefixing any C# expression with `@`. If the expression is complex in that it
    is composed of a chain of properties and method calls, it must be enclosed by
    parentheses. The following code shows some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Types are converted into strings using the current culture settings (see the
    *Understanding the connection between ASP.NET Core MVC and design principles*
    section for details on how to set the culture of each request). Moreover, strings
    are automatically HTML encoded to avoid the `<` and `>` symbols, which might interfere
    with the view HTML. HTML encoding can be prevented with the `@HTML.Raw` function,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In an HTML area, alternative HTML can be selected with the `@if` Razor statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the beginning of each block of a Razor control
    flow statement is in C# mode and remains in C# mode until the first HTML open
    tag is encountered, and then HTML mode starts. C# mode is resumed after the corresponding
    HTML close tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTML template can be instantiated several times with the `for`, `foreach`,
    `while`, and `do` Razor statements, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Razor views can contain comments that do not generate any code. Any text included
    within `@*...*@` is considered a comment and is removed when the page is compiled.
    The next topic describes properties that are available in all Views.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Razor View properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some standard variables are predefined in each view. The most important variable
    is `Model`, which contains the ViewModel that was passed to the view. For instance,
    if we pass a `Person` model to a view, then `<span>@Model.Name</span>` displays
    the name of the `Person` model that was passed to the view.
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewData` variable contains `IDictionary<string, object>`, which is shared
    with the controller that invoked the view. That is, all controllers also have
    a `ViewData` property containing `IDictionary<string, object>`, and every entry
    that is set in the controller is also available in the `ViewData` variable of
    the invoked view. `ViewData` is an alternative to the ViewModel for a controller
    for passing information to its invoked view. It is worth mentioning that the `ViewState`
    dictionary can also be accessed as a dynamic object through the `ViewBag` property.
    This means that dynamic `ViewBag` properties are mapped to `ViewData` string indices
    and that their values are mapped to the `ViewState` entries corresponding to those
    indices.
  prefs: []
  type: TYPE_NORMAL
- en: The `User` variable contains the currently logged user; that is, the same instance
    contained in the current request's `Http.Context.User` property. The `Url` variable
    contains an instance of the `IUrlHelper` interface whose methods are utilities
    for computing the URLs of application pages. For instance, `Url.Action("action",
    "controller", new {par1=valueOfPar1,...})` computes the URL that causes the action
    method, *action*, of the *controller* to be invoked with all the parameters specified
    in the anonymous object passed as its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The `Context` variable contains the whole request's `HttpContext`. The `ViewContext`
    variable contains data about the context of the view invocation, including metadata
    about the action method that invoked the view.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic describes how Razor enhances HTML tag syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Using Razor tag helpers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In ASP.NET Core MVC, the developer can define so-called tag helpers, which either
    enhance existing HTML tags with new tag attributes or define new tags. While Razor
    views are compiled, any tag is matched against existing tag helpers. When a match
    is found, the source tag is replaced with HTML created by the tag helpers. Several
    tag helpers may be defined for the same tag. They are all executed in an order
    that can be configured with a priority attribute associated with each tag helper.
  prefs: []
  type: TYPE_NORMAL
- en: All tag helpers defined for the same tag may cooperate while each tag instance
    is being processed. This is because they are passed a shared data structure where
    each of them may apply a contribution. Usually, the final tag helper that is invoked
    processes this shared data structure to produce the output HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Tag helpers are classes that inherit from the `TagHelper` class. This topic
    doesn't discuss how to create new tag helpers but introduces the main predefined
    tag helpers that come with ASP.NET Core MVC. A complete guide on how to define
    tag helpers is available in the official documentation, which is referenced in
    the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a tag helper, you must declare the `.dll` file containing it with a
    declaration like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you would like to use just one of the tag helpers defined in the `.dll` file,
    you must replace `*` with the tag name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding declaration can be placed either in each view that uses the tag
    helpers defined in the library or, once and for all, in the `_ViewImports.cshtml`
    file in the root of the `Views` folder. By default, `_ViewImports.cshtml` adds
    all predefined ASP.NET Core MVC tag helpers with the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The anchor tag is enhanced with attributes that automatically compute the URL
    and that invoke a specific action method with given parameters, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar syntax is added to the `form` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `script` tag is enhanced with attributes that allow us to fall back to
    a different source if the download fails. Typical usage is to download scripts
    from some cloud service to optimize the browser cache and to fall back to a local
    copy of the script in case of failure. The following code uses the fallback technique
    to download the `bootstrap` JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`asp-fallback-test` contains a JavaScript test that verifies whether the download
    succeeded. In the preceding example, the test verifies whether a JavaScript object
    has been created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `environment` tag can be used to select different HTML for different environments
    (development, staging, and production). Its typical usage is selecting the debug
    versions of JavaScript files during development, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a `cache` tag, which caches its content in memory to optimize
    rendering speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: By default, content is cached for 20 minutes, but the tag has attributes that
    must be defined when the cache expires, such as `expires-on="{datetime}"`, `expires-after="{timespan}"`,
    and `expires-sliding="{timespan}"`. Here, the difference between `expires-sliding`
    and `expires-after` is that, in the second attribute, the expiration time count
    is reset each time the content is requested. The `vary-by` attribute causes the
    creation of a different cache entry for each different value passed to `vary-by`.
    There are also attributes such as `vary-by-header`, which creates a different
    entry for each different value assumed by the request header specified in the
    attribute; `vary-by-cookie`; and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'All `input` tags â€“ that is, `textarea`, `input`, and `select` â€“ have an `asp-for`
    attribute that accepts a properties path rooted in the view''s ViewModel as their
    value. For instance, if the view has a `Person` ViewModel, we may have something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the preceding code does is assign the value of the `Town` nested
    property to the `value` attribute of the `input` tag. In general, if the value
    is not a string, it is converted into a string using the current request culture.
  prefs: []
  type: TYPE_NORMAL
- en: However, it also sets the name of the input field to `Address.Town` and the
    ID of the input field to `Address_Town`. This is because dots are not allowed
    in tag IDs.
  prefs: []
  type: TYPE_NORMAL
- en: A prefix can be added to these standard names by specifying it in `ViewData.TemplateInfo.HtmlFieldPrefix`.
    For instance, if the previous property is set to `MyPerson`, the name becomes
    `MyPerson.Address.Town`.
  prefs: []
  type: TYPE_NORMAL
- en: If the form is submitted to an action method that has the same `Person` class
    as one of its parameters, the name of `Address.Town` that's given to the `input`
    field will cause the `Town` property of this parameter to be filled with the `input`
    field. In general, the string contained in the `input` field is converted into
    the type of property it has been matched with using the current request culture.
    Summing this up, names of `input` fields are created in such a way that a complete
    `Person` model can be recovered in the action method when the HTML page is posted.
  prefs: []
  type: TYPE_NORMAL
- en: The same `asp-for` attribute can be used in a `label` tag to cause the label
    to refer to the input field with the same `asp-for` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of an `input`/`label` pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When no text is inserted into the label, the text shown in the label is taken
    from a `Display` attribute that decorates the property (`Town`, in this example),
    if any; otherwise, the name of the property is used.
  prefs: []
  type: TYPE_NORMAL
- en: If `span` or `div` contains an `asp-validation-for ="Address.Town"` error attribute,
    then validation messages concerning the `Address.Town` input will be inserted
    automatically inside that tag. The validation framework will be described in the
    *Understanding the connection between ASP.NET Core MVC and design principles*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to automatically create a validation error summary by adding
    the attribute that follows a `div` or a `span`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If the attribute is set to `ValidationSummary.ModelOnly`, only messages that
    are not associated with specific `input` fields will be shown in the summary,
    while if the value is `ValidationSummary.All`, all error messages will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: The `asp-items` attribute can be applied to any `select` tag in order to automatically
    generate all `select` options. It must be passed an `IEnumerable<SelectListItem>`,
    where each `SelectListItem` contains both the text and value of an option. `SelectListItem`
    also contains an optional `Group` property you can use to organize the options
    shown in `select` into groups.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic shows how to reuse view code.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing view code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core MVC includes several techniques for reusing view code. The most
    important is the layout page.
  prefs: []
  type: TYPE_NORMAL
- en: In each web application, several pages share the same structure; for instance,
    the same main menu or the same left or right bar. In ASP.NET Core, this common
    structure is factored out in views called layout pages/views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each view can specify the view to be used as its layout page with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If no layout page is specified, a default layout page, defined in the `_ViewStart.cshtml`
    file located in the `Views` folder, is used. The default content of `_ViewStart.cshtml`
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, the default layout page in the files scaffolded by Visual Studio
    is `_Layout.cshtml`, which is contained in the `Shared` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout page contains the HTML that''s shared with all of its children pages,
    the HTML page headers, and the page references to CSS and JavaScript files. The
    HTML produced by each view is placed inside of its layout place, where the layout
    page calls the `@RenderBody()` method, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`ViewState` of each `View` is copied into `ViewState` of its layout page, so
    `ViewState` can be used to pass information to the view layout page. Typically,
    it is used to pass the view title to the layout page, which then uses it to compose
    the page''s title header, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: While the main content produced by each view is placed in a single area of its
    layout page, each layout page can also define several sections placed in different
    areas where each view can place further secondary content.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, suppose a layout page defines a `Scripts` section, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the view can use the previously defined section to pass some view-specific
    JavaScript references, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If an action method is expected to return HTML to an AJAX call, it must produce
    an HTML fragment instead of a whole HTML page. Therefore, in this case, no layout
    page must be used. This is achieved by calling the `PartialView` method instead
    of the `View` method in the controller action method. `PartialView` and `View`
    have exactly the same overloads and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to reuse view code is to factor out a view fragment that''s common
    to several views into another view that is called by all previous views. A view
    can call another view with the `partial` tag, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code invokes `_viewname` and passes it the object contained in
    `Model.ModelProperty.NestedProperty` as its `ViewModel`. When a view is invoked
    by the `partial` tag, no layout page is used since the called view is expected
    to return an HTML fragment.
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewData.TemplateInfo.HtmlFieldPrefix` property of the called view is set
    to the `"ModelProperty.NestedProperty"` string. This way, possible input fields
    rendered in `_viewname.cshtml` will have the same name as if they had been rendered
    directly by the calling view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of specifying the ViewModel of `_viewname` through a property of the
    caller view (ViewModel), you can also directly pass an object that is contained
    in a variable or returned by a C# expression by replacing `for` with `model`,
    as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `ViewData.TemplateInfo.HtmlFieldPrefix` property of the called
    view keeps its default value; that is, the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'A view can also call something more complex than another view; that is, another
    controller method that, in turn, renders a view. Controllers that are designed
    to be invoked by views are called **view components**. The following code is an
    example of component invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Parameter names must match the ones used in the view component method. However,
    both the component's name and parameter names must be translated into kebab case;
    that is, all the characters must be transformed into lowercase if all the characters
    that were in the original name were in uppercase, though the first one word must
    be preceded by a `-`. For instance, `MyParam` must be transformed into `my-param`.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, view components are classes that derive from the `ViewComponent` class.
    When a component is invoked, the framework looks for either an `Invoke` method
    or an `InvokeAsync` method and passes it all the parameters that were defined
    in the component's invocation. `InvokeAsync` must be used if the method is defined
    as `async`; otherwise, we must use `Invoke`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a view component definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The previously defined component must be invoked with a call such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If the component is invoked by a view of a controller called `MyController`,
    `ViewName` is searched for in the following paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/Views/MyController/Components/MyTest/ViewName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/Views/Shared/Components/MyTest/ViewName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's look at the more recent relevant features of ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: What is new in the latest versions of ASP.NET Core?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main change for ASP.NET Core took place in version 3.0: the routing engine
    was factored out of the MVC engine and is now also available for other handlers.
    In previous versions, routes and routing were a part of the MVC handler and were
    added with `app.UseMvc(....)`; this has now been replaced with `app.UseRouting()`
    and `UseEndpoints(...)`, which can route requests not only to controllers but
    also to other handlers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Endpoints and their associated handlers are now defined in `UseEndpoints`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`MapControllerRoute` associates patterns with controllers, but we may also
    use something such as `endpoints.MapHub<ChatHub>("/chat")`, which associates a
    pattern with a hub that handles WebSocket connections. In the previous section,
    we saw that patterns can also be associated with custom handlers using `MapPost`
    and `MapGet`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An independent router also allows us to add authorizations not only to controllers
    but also to any handler, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, ASP.NET Core now has an independent JSON formatter and doesn''t depend
    on the third-party Newtonsoft JSON serializer anymore. However, if you have compatibility
    issues, you still have the option to replace the minimal ASP.NET Core JSON formatter
    with the Newtonsoft JSON serializer by installing the `Microsoft.AspNetCore.Mvc.NewtonsoftJson`
    NuGet package and configuring the controllers, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `AddNewtonsoftJson` also has an overload that accepts the configuration
    options for the Newtonsoft JSON serializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Microsoft's JSON serializer was introduced in version 3, but at the beginning,
    its implementation was minimal. Now, in .NET 5, it offers options that are comparable
    to the ones of the Newtonsoft JSON serializer.
  prefs: []
  type: TYPE_NORMAL
- en: In versions previous to 3.0, you were forced to add both controllers and views
    to the DI engine. Now, you can still inject both controllers and views with `services.AddControllersWithViews`,
    but you can also add controllers with `AddControllers` if you are going to implement
    REST endpoints only.
  prefs: []
  type: TYPE_NORMAL
- en: Version 5 brought significant performance improvements due to improvements in
    .NET performance, improvements in the JIT compiler, which now generate shorter
    and more optimized code, and due to improvements in the HTTP/2 protocol implementation.
    Basically, you can rely on a doubled computation speed, along with more efficient
    memory and garbage collection handling.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the connection between ASP.NET Core MVC and design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole ASP.NET Core framework is built on top of the design principles and
    patterns that we analyzed in *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*, *Chapter 8*, *Interacting with Data in C# â€“ Entity
    Framework Core*, *Chapter 11*, *Design Patterns and .NET 5 Implementation*, *Chapter
    12*, *Understanding the Different Domains in Software Solutions*, and *Chapter
    13*, *Implementing Code Reusability in C# 9*.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, all framework functionalities are provided through DI so that each
    of them can be replaced by a customized counterpart without it affecting the remainder
    of the code. However, these providers are not added individually to the DI engine;
    instead, they are grouped into option objects (see the *Loading configuration
    data and using it with the options framework* subsection) in order to conform
    to the SOLID Single Responsibility Principle. This is the case, for instance,
    for all model binders, validation providers, and data annotation providers.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, configuration data, instead of being available from a unique dictionary
    created from a configuration file, is organized into option objects thanks to
    the options framework we described in the first section of this chapter. This
    is also an application of the SOLID Interface Segregation Principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, ASP.NET Core also applies other patterns that are specific instances
    of the general Separation of Concerns principle, which is a generalization of
    the Single Responsibility Principle. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The middleware modules architecture (ASP.NET Core pipeline)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factoring out validation and globalization from the application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MVC pattern itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will analyze each of these in the various subsections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the ASP.NET Core pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ASP.NET Core pipeline architecture has two important advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: All the different operations that are performed on the initial request are factored
    out into different modules, according to the Single Responsibility Principle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules that perform these different operations don't need to call each
    other because each module is invoked once and for all by the ASP.NET Core framework.
    This way, the code for each module is not required to perform any action that
    is connected to responsibilities that have been assigned to other modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ensures maximum independence of functionalities and simpler code. For instance,
    once authorization and authentication modules are on, no other module needs to
    worry about authorization anymore. Each controller code can focus on application-specific
    business stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side and client-side validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Validation logic has been completely factored out from the application code
    and has been confined to the definition of validation attributes. The developer
    just needs to specify the validation rule to apply to each model property by decorating
    the property with an adequate validation attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Validation rules are checked automatically when action method parameters are
    instantiated. Both errors and paths in the model (where they occurred) are then
    recorded in a dictionary that is contained in the `ModelState` controller property.
    The developer has the responsibility of verifying whether there are errors by
    checking `ModelState.IsValid`, in which case the developer must return the same
    ViewModel to the same view so that the user can correct all errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error messages are automatically shown in the view with no action required
    from the developer. The developer is only required to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `span` or `div` with an `asp-validation-for` attribute next to each input
    field, which will be automatically filled with the possible error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `div` with an `asp-validation-summary` attribute that will be automatically
    filled with the validation error summary. See the *Using Razor tag helpers* section
    for more details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is enough to add some JavaScript references by invoking the `_ValidationScriptsPartial.cshtml`
    view with the `partial` tag to enable the same validation rules on the client
    side, so that errors are shown to the user before the form is posted to the server.
    Some predefined validation attributes are contained in the `System.ComponentModel.DataAnnotations`
    and `Microsoft.AspNetCore.Mvc` namespaces and include the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Required` attribute requires the user to specify a value for the property
    that it decorates. An implicit `Required` attribute is automatically applied to
    all non-nullable properties, such as all floats, integers, and decimals, since
    they can't have a `null` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Range` attribute constrains numeric quantities within a range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They also include attributes that constrain string lengths.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom error messages can be inserted directly into the attributes, or attributes
    can refer to the property of resource types containing them.
  prefs: []
  type: TYPE_NORMAL
- en: The developer can define their custom attributes by providing the validation
    code both in C# and in JavaScript for client-side validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attribute-based validation can be replaced by other validation providers, such
    as fluent validation that defines validation rules for each type using a fluent
    interface. It is enough to change a provider in a collection contained in the
    MVC options object. This can be configured through an action passed to the `services.AddControllersWithViews`
    method. MVC options can be configured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The validation framework automatically checks whether numeric and date inputs
    are well-formatted according to the selected culture.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core globalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In multicultural applications, pages must be served according to the language
    and culture preferences of each user. Typically, multicultural applications can
    serve their content in a few languages, and they can handle dates and numeric
    formats in several more languages. In fact, while the content in all supported
    languages must be produced manually, .NET Core has the native capability of formatting
    and parsing dates and numbers in all cultures.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a web application might not support unique content for all English-based
    cultures (en), but might support all known English-based cultures for numbers
    and dates formats (en-US, en-GB, en-CA, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The culture used for numbers and dates in a .NET thread is contained in the
    `Thread.CurrentThread.CurrentCulture` property. Hence, by setting this property
    to `new CultureInfo("en-CA")`, numbers and dates will be formatted/parsed according
    to the Canadian culture. `Thread.CurrentThread.CurrentUICulture`, instead, decides
    on the culture of the resource files; that is, it selects a culture-specific version
    of each resource file or view. Accordingly, a multicultural application is required
    to set the two cultures associated with the request thread and organize multilingual
    content into language-dependent resource files and/or views.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Separation of Concerns principle, the whole logic used to
    set the request culture according to the user''s preferences is factored out into
    a specific module of the ASP.NET Core pipeline. To configure this module, as a
    first step, we set the supported date/numbers cultures, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we set the languages supported for the content. Usually, a version of
    the language that is not specific for any country is selected to keep the number
    of translations small enough, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the culture middleware to the pipeline, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If the culture requested by the user is explicitly found among the ones listed
    in `supportedCultures` or `supportedUICultures`, it is used without modifications.
    Otherwise, since `FallBackToParentCultures` and `FallBackToParentUICultures` are
    `true`, the parent culture is tried; that is, for instance, if the required `fr-FR`
    culture is not found among those listed, then the framework searches for its generic
    version, `fr`. If this attempt also fails, the framework uses the cultures specified
    in `DefaultRequestCulture`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `culture` middleware searches the culture selected for the
    current user with three providers that are tried in the order shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: The middleware looks for the `culture` and `ui-culture` query string parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the previous step fails, the middleware looks for a cookie named `.AspNetCore.Culture`,
    the value of which is expected to be as in this example: `c=en-US|uic=en`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If both previous steps fail, the middleware looks for the `Accept-Language`
    request header sent by the browser, which can be changed in the browser settings,
    and which is initially set to the operating system culture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the preceding strategy, the first time a user requests an application page,
    the browser culture is taken (the provider listed in *step 3*). Then, if the user
    clicks a language-change link with the right query string parameters, a new culture
    is selected by provider 1\. Usually, once a language link has been clicked, the
    server also generates a language cookie to remember the user's choice through
    provider 2.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to provide content localization is to provide a different view
    for each language. Hence, if we would like to localize the `Home.cshtml` view
    for different languages, we must provide views named `Home.en.cshtml`, `Home.es.cshtml`,
    and so on. If no view specific to the `ui-culture` thread is found, the not localized
    `Home.cshtml` version of the view is chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'View localization must be enabled by calling the `AddViewLocalization` method,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to store simple strings or HTML fragments in resource files
    specific for all supported languages. The usage of resource files must be enabled
    by calling the `AddLocalization` method in the configure services section, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`ResourcesPath` is the root folder where all resource files will be placed.
    If it is not specified, an empty string is assumed, and the resource files will
    be placed in the web application root. Resource files for a specific view, say,
    the `/Views/Home/Index.cshtml` view, must have a path like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Hence, if `ResourcesPath` is empty, resources must have the `/Views/Home/Index.<culture
    name>.resx` path; that is, they must be placed in the same folder as the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the key-value pairs for all the resource files associated with a view
    have been added, localized HTML fragments can be added to the view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Inject `IViewLocalizer` into the view with `@inject IViewLocalizer Localizer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where needed, replace the text in the View with accesses to the `Localizer`
    dictionary, such as `Localizer["myKey"]`, where `"myKey"` is a key used in the
    resource files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows an example of the `IViewLocalizer` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If localization fails because the key is not found in the resource file, the
    key itself is returned. Strings used in data annotation, such as validation attributes,
    are used as keys in resource files if data annotation localization is enabled,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Resource files for data annotations applied to a class whose full name is,
    say, `MyWebApplication.ViewModels.Account.RegisterViewModel`, must have the following
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that the first segment of the namespace that corresponds
    to the `.dll` application name is replaced with `ResourcesPath`. If `ResourcesPath`
    is empty and if you use the default namespaces created by Visual Studio, then
    the resource files must be placed in the same folder that contains the classes
    they are associated with.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to localize strings and HTML fragments in controllers, or wherever
    dependencies can be injected, by associating each group of resource files with
    a type, such as `MyType`, and then injecting either `IHtmlLocalizer<MyType>` for
    HTML fragments or `IStringLocalizer<MyType>` for strings that need to be HTML
    encoded.
  prefs: []
  type: TYPE_NORMAL
- en: Their usage is identical to the usage of `IViewLocalizer`. The path of the resource
    files associated with `MyType` is computed as in the case of data annotations.
    If you would like to use a unique group of resource files for the whole application,
    a common choice is to use the `Startup` class as the reference type (`IStringLocalizer<Startup
    >` and `IHtmlLocalizer<Startup >`). Another common choice is to create various
    empty classes to use as reference types for various groups of resource files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve learned how to manage globalization in your ASP.NET Core projects,
    in the next subsection, we will describe the more important pattern used by ASP.NET
    Core MVC to enforce *Separation of Concerns*: the MVC pattern itself.'
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVC is a pattern used to implement the presentation layers of a web application.
    The basic idea is to apply a *Separation of Concerns* between the logic of the
    presentation layer and its graphics. Logic is taken care of by controllers, while
    graphics are factored out into views. Controllers and views communicate through
    the model, which is often called the ViewModel to distinguish it from the models
    of the business and data layers.
  prefs: []
  type: TYPE_NORMAL
- en: However, what is the logic of a presentation layer? In *Chapter 1*, *Understanding
    the Importance of Software Architecture*, we saw that software requirements can
    be documented with use cases that describe the interaction between the user and
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: Roughly speaking, the logic of the presentation layer consists of the management
    of use cases; hence, roughly, use cases are mapped to controllers and every single
    operation of a use case is mapped to an action method of those controllers. Hence,
    controllers take care of managing the protocol of interaction with the user and
    rely on the business layer for any business processing involved during each operation.
  prefs: []
  type: TYPE_NORMAL
- en: Each action method receives data from the user, performs some business processing,
    and, depending on the results of this processing, decides what to show to the
    user and encodes it in the ViewModel. Views receive ViewModels that describe what
    to show to the user and decide the graphics to use; that is, the HTML to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are the advantages of separating logic and graphics into two different
    components? The main advantages are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Changes in graphics do not affect the remainder of the code, so you can experiment
    with various graphic options to optimize the interaction with the user without
    putting the reliability of the remainder of the code at risk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application can be tested by instantiating controllers and passing the parameters,
    with no need to use testing tools that operate on the browser pages. In this way,
    tests are easier to implement. Moreover, they do not depend on the way graphics
    are implemented, so they do not need to be updated each time the graphics change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to split the job between developers that implement controllers
    and graphic designers that implement views. Often, graphic designers have difficulties
    with Razor, so they might just furnish an example HTML page that developers transform
    into Razor views that operate on the actual data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's look at how to create a web app in ASP.NET Core MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Use case â€“ implementing a web app in ASP.NET Core MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, as an example of the ASP.NET Core application, we will implement
    the administrative panel for managing the destinations and packages of the `WWTravelClub`
    book use case. The application will be implemented with the **Domain-Driven Design**
    (**DDD**) approach described in *Chapter 12*, *Understanding the Different Domains
    in Software Solutions*. So, having a good understanding of that chapter is a fundamental
    prerequisite to reading this section. The subsections that follow describe the
    overall application specifications and organization, and then the various application
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: Defining application specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The destinations and packages were described in *Chapter 8*, *Interacting with
    Data in C# â€“ Entity Framework Core*. Here, we will use exactly the same data model,
    with the necessary modifications to adapt it to the DDD approach. The administrative
    panel must allow packages, a destinations listing, and CRUD operations on it.
    To simplify the application, the two listings will be quite simple: the application
    will show all destinations sorted according to their names, while all packages
    will be sorted starting from the ones with a higher-end validity date.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, we suppose the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The application that shows destinations and packages to the user shares the
    same database used by the administrative panel. Since only the administrative
    panel application needs to modify data, there will be just one write copy of the
    database with several read-only replicas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Price modifications and package deletions are immediately used to update the
    user's shopping carts. For this reason, the administrative application must send
    asynchronous communications about price changes and package removals. We will
    not implement the whole communication logic here, but we will just add all such
    events to an event table, which should be used as input to a parallel thread that's
    in charge of sending these events to all relevant microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we will give the full code for just package management; most of the code
    for destination management is left as an exercise for you. The full code is available
    in the `ch15` folder of the GitHub repository associated with this book. In the
    remainder of this section, we will describe the application's overall organization
    and discuss some relevant samples of code.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the application architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application is organized based on the guidelines described in *Chapter
    12*, *Understanding the Different Domains in Software Solution*, while considering
    the DDD approach and using SOLID principles to map your domain sections. That
    is, the application is organized into three layers, each implemented as a different
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a data layer that contains the repository''s implementation and the
    classes describing database entities. It is a .NET Core library project. However,
    since it needs some interfaces like `IServiceCollection`, which are defined in
    `Microsoft.NET.Sdk.web`, we must add a reference not only to the .NET Core SDK
    but also to the ASP.NET Core SDK. This can be done as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right-click on the project icon in the solution explorer and select **Edit project
    file**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the edit window add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: There's also a domain layer that contains repository specifications; that is,
    interfaces that describe repository implementations and DDD aggregates. In our
    implementation, we decided to implement aggregates by hiding the forbidden operations/properties
    of root data entities behind interfaces. Hence, for instance, the `Package` data
    layer class, which is an aggregate root, has a corresponding `IPackage` interface
    in the domain layer that hides all the property setters of the `Package` entity.
    The domain layer also contains the definitions of all the domain events, while
    the corresponding event handlers are defined in the application layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there's the application layer â€“ that is, the ASP.NET Core MVC application
    â€“ where we define DDD queries, commands, command handlers, and event handlers.
    Controllers fill query objects and execute them to get ViewModels they can pass
    to views. They update storage by filling command objects and executing their associated
    command handlers. In turn, command handlers use `IRepository` interfaces and `IUnitOfWork`
    coming from the domain layer to manage and coordinate transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application uses the Query Command Segregation pattern; therefore, it uses
    command objects to modify the storage and the query object to query it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The query is simple to use and implement: controllers fill their parameters
    and then call their execution methods. In turn, query objects have direct LINQ
    implementations that project results directly onto the ViewModels used by the
    controller Views with `Select` LINQ methods. You may also decide to hide the LINQ
    implementation behind the same repository classes used for the storage update
    operations, but this would turn the definition and modification of simple queries
    into very time-consuming tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: In any case, it is good practice to hide query objects behind interfaces so
    that their implementations can be replaced by fake implementations when you test
    controllers.
  prefs: []
  type: TYPE_NORMAL
- en: However, the chain of objects and calls involved in the execution of commands
    is more complex. This is because it requires the construction and modification
    of aggregates, as well as a definition of the interaction between several aggregates
    and between aggregates and other applications through domain events to be provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a sketch of how storage update operations are performed.
    The circles are data being exchanged between the various layers, while rectangles
    are the procedures that process them. Moreover, dotted arrows connect interfaces
    with types that implement them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_15_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: Diagram of command execution'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the flow of action through *Figure 15.6* as a list of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A controller's action method receives one or more ViewModels and performs validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One or more ViewModels containing changes to apply are hidden behind interfaces
    (`IMyUpdate`) defined in the domain layer. They are used to fill the properties
    of a command object. These interfaces must be defined in the domain layer since
    they will be used as arguments of the repository methods defined there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A command handler matching the previous command is retrieved via DI in the controller
    action method (through the`[FromServices]` parameter attribute we described in
    the *Defining Controllers and ViewModels* subsection). Then, the handler is executed.
    During its execution, the handler interacts with various repository interface
    methods and with the aggregates they return.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When creating the command handler discussed in *step 3*, the ASP.NET Core DI
    engine automatically injects all parameters declared in its constructor. In particular,
    it injects all `IRepository` implementations needed to perform all command handler
    transactions. The command handler performs its job by calling the methods of these
    `IRepository` implementations received in its constructor to build aggregates
    and modify the built aggregates. Aggregates either represent already-existing
    entities or newly created ones. Handlers use the `IUnitOfWork` interface contained
    in each `IRepository`, as well as the concurrency exceptions returned by the data
    layer, to organize their operations as transactions. It is worth pointing out
    that each aggregate has its own `IRepository`, and that the whole logic for updating
    each aggregate is defined in the aggregate itself, not in its associated `IRepository`,
    to keep the code more modular.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Behind the scenes, in the data layer, `IRepository` implementations use Entity
    Framework to perform their job. Aggregates are implemented by root data entities
    hidden behind interfaces defined in the domain layer, while `IUnitOfWork` methods,
    which handle transactions and pass changes to the database, are implemented with
    `DbContext` methods. In other words, `IUnitOfWork` is implemented with the application's
    `DbContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Domain events are generated during each aggregate process and are added to the
    aggregates themselves by us calling their `AddDomainEvent` methods. However, they
    are not triggered immediately. Usually, they are triggered at the end of all the
    aggregates' processing and before changes are passed to the database; however,
    this is not a general rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application handles errors by throwing exceptions. A more efficient approach
    would be to define a request-scoped object in the dependency engine, where each
    application subpart may add its errors as domain events. However, while this approach
    is more efficient, it increases the complexity of the code and the application
    development time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Visual Studio solution is composed of three projects:'
  prefs: []
  type: TYPE_NORMAL
- en: There's a project containing the domain layer called `PackagesManagementDomain`,
    which is a .NET Standard 2.0 library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a project containing the whole data layer called `PackagesManagementDB`,
    which is a .NET 5.0 library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there's an ASP.NET Core MVC 5.0 project called `PackagesManagement`
    that contains both application and presentation layers. When you define this project,
    select **no authentication**; otherwise, the user database will be added directly
    to the ASP.NET Core MVC project instead of to the database layer. We will add
    the user database manually in the data layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by creating the `PackagesManagement` ASP.NET Core MVC project so
    that the whole solution has the same name as the ASP.NET Core MVC project. Then,
    we'll add the other two library projects to the same solution.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let the ASP.NET Core MVC project reference both projects, while `PackagesManagementDB`
    references `PackagesManagementDomain`. We suggest you define your own projects
    and then copy the code of this book's GitHub repository into them as you read
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes the code of the `PackagesManagementDomain` data
    layer project.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the domain layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the `PackagesManagementDomain` standard 2.0 library project has been added
    to the solution, we'll add a `Tools` folder to the project root. Then, we'll place
    all the `DomainLayer` tools contained in the code associated with `chapter 12`.
    Since the code contained in this folder uses data annotations and defines DI extension
    methods, we must also add references to the `System.ComponentModel.Annotations`
    and `Microsoft.Extensions.DependencyInjection` NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need an `Aggregates` folder containing all the aggregate definitions
    (remember, we implemented aggregates as interfaces); namely, `IDestination`, `IPackage`,
    and `IPackageEvent`. Here, `IPackageEvent` is the aggregate associated with the
    table where we will place events to be propagated to other applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s analyze `IPackage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'It contains the same properties of the `Package` entity, which we saw in *Chapter
    8*, *Interacting with Data in C# â€“ Entity Framework Core*. The only differences
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It inherits from `IEntity<int>`, which furnishes all basic functionalities of
    aggregates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has no `Id` property since it is inherited from `IEntity<int>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All properties are read-only, and it has a `FullUpdate` method since all aggregates
    can only be modified through update operations defined in the user domain (in
    our case, the `FullUpdate` method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's also add a `DTOs` folder. Here, we place all interfaces used to pass
    updates to the aggregates. Such interfaces are implemented by the application
    layer ViewModels used to define such updates. In our case, it contains `IPackageFullEditDTO`,
    which we can use to update existing packages. If you would like to add the logic
    to manage destinations, you must define an analogous interface for the `IDestination`
    aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `IRepository` folder contains all repository specifications; namely, `IDestinationRepository`,
    `IPackageRepository`, and `IPackageEventRepository`. Here, `IPackageEventRepository`
    is the repository associated with the `IPackageEvent` aggregate. As an example,
    let''s have a look at the `IPackageRepository` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Repositories always contain just a few methods since all business logic should
    be represented as aggregate methods â€“ in our case, just the methods to create
    a new package, to retrieve an existing package, and to delete an existing package.
    The logic to modify an existing package is included in the `FullUpdate` method
    of `IPackage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, as with all domain layer projects, `PackagesManagementDomain` contains
    an event folder containing all domain event definitions. In our case, the folder
    is named `Events` and contains the package-deleted event and the price-changed
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: When an aggregate sends all its changes to another application, it must have
    a version property. The application that receives the changes uses this version
    property to apply all changes in the right order. An explicit version number is
    necessary because changes are sent asynchronously, so the order they are received
    in may differ from the order they were sent in. For this purpose, events that
    are used to publish changes outside of the application have both `OldVersion`
    (the version before the change) and `NewVersion` (the version after the change)
    properties. Events associated with delete events have no `NewVersion` since after
    being deleted, an entity can't store any versions.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection explains how all interfaces defined in the domain layer
    are implemented in the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data layer project contains references to the `Microsoft.AspNetCore.Identity.EntityFrameworkCore`
    and `Microsoft.EntityFrameworkCore.SqlServer` NuGet packages, since we use Entity
    Framework Core with SQL server. It references `Microsoft.EntityFrameworkCore.Tools`
    and `Microsoft.EntityFrameworkCore.Design`, which are needed to generate database
    migrations, as explained in the *Entity Framework Core migrations* section of
    *Chapter 8*, *Interacting with Data in C# â€“ Entity Framework Core*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a `Models` folder that contains all database entities. They are similar
    to the ones in *Chapter 8*, *Interacting with Data in C# â€“ Entity Framework Core*.
    The only differences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They inherit from `Entity<T>`, which contains all basic features of aggregates.
    Please notice that inheriting from `Entity<T>` is only needed for aggregate roots;
    all other entities must be defined as explained in *Chapter 8*, *Interacting with
    Data in C# â€“ Entity Framework Core*. In our example, all entities are aggregate
    roots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have no `Id` since it is inherited from `Entity<T>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of them have an `EntityVersion` property that is decorated with the `[ConcurrencyCheck]`
    attribute. It contains the entity version that is needed for sending a property
    all entity changes to other applications. The `ConcurrencyCheck` attribute is
    needed to prevent concurrency errors while updating the entity version. This prevents
    suffering the performance penalty implied by a transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More specifically, when saving entity changes, if the value of a field marked
    with the `ConcurrencyCheck` attribute is different from the one that was read
    when the entity was loaded in memory, a concurrency exception is thrown to inform
    the calling method that someone else modified this value after the entity was
    read, but before we attempted to save its changes. This way, the calling method
    can repeat the whole operation with the hope that, this time, no one will write
    the same entity in the database during its execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth analyzing the `Package` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `FullUpdate` method is the only way to update the `IPackage` aggregate when
    the price changes add `PackagePriceChangedEvent` to the entity list of events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MainDBContext.cs` file contains the data layer database context definition.
    It doesn''t inherit from `DBContext` but from the following predefined context
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This context defines the user's tables needed for the authentication. In our
    case, we opted for the `IdentityUser<T>` standard and `IdentityRole<S>` for users
    and roles, respectively, and used integers for both the `T` and `S` Entity keys.
    However, we may also use classes that inherit from `IdentityUser` and `IdentityRole`
    and then add further properties.
  prefs: []
  type: TYPE_NORMAL
- en: In the `OnModelCreating` method, we must call `base.OnModelCreating(builder)`
    in order to apply the configuration defined in `IdentityDbContext`.
  prefs: []
  type: TYPE_NORMAL
- en: '`MainDBContext` implements `IUnitOfWork`. The following code shows the implementation
    of all methods that start, roll back, and commit a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: However, they are rarely used by command classes in a distributed environment.
    This is because retrying the same operation until no concurrency exception is
    returned usually ensures better performance than transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth analyzing the implementation of the method that passes all changes
    applied to `DbContext` to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation just calls the `SaveChangesAsync DbContext` context
    method, which saves all changes to the database, but then it intercepts all concurrency
    exceptions and detaches all the entities involved in the concurrency error from
    the context. This way, next time a command retries the whole failed operation,
    their updated versions will be reloaded from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Repositories` folder contains all repository implementations. It is worth
    analyzing the implementation of the `IPackageRepository.Delete` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: It reads the entity from the database and formally removes it from the `Packages`
    dataset. This will force the entity to be deleted in the database when changes
    are saved to the database. Moreover, it adds `PackageDeleteEvent` to the aggregate
    list of events.
  prefs: []
  type: TYPE_NORMAL
- en: The `Extensions` folder contains the `DBExtensions` static class, which, in
    turn, defines two extension methods to be added to the application DI engine and
    the ASP.NET Core pipeline, respectively. Once added to the pipeline, these two
    methods will connect the database layer to the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IServiceCollection` extension of `AddDbLayer` accepts (as its input parameters)
    the database connection string and the name of the `.dll` file that contains all
    migrations. Then, it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: That is, it adds the database context to the DI engine and defines its options;
    namely, that it uses SQL Server, the database connection string, and the name
    of the `.dll` file that contains all migrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: That is, it adds and configures all the types needed to handle database-based
    authentication. In particular, it adds the `UserManager` and `RoleManager` types,
    which the application layer can use to manage users and roles. `AddDefaultTokenProviders`
    adds the provider that creates the authentication tokens using data contained
    in the database when users log in.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it discovers and adds to the DI engine all repository implementations
    by calling the `AddAllRepositories` method, which is defined in the DDD tools
    we added to the domain layer project.
  prefs: []
  type: TYPE_NORMAL
- en: The `UseDBLayer` extension method ensures migrations are applied to the database
    by calling `context.Database.Migrate()` and then populates the database with some
    initial objects. In our case, it uses `RoleManager` and `UserManager` to create
    an administrative role and an initial administrator, respectively. Then, it creates
    some sample destinations and packages.
  prefs: []
  type: TYPE_NORMAL
- en: '`context.Database.Migrate()`is useful to quickly set up and update staging
    and test environments. When deploying in production, instead, an SQL script should
    be produced from the migrations using the migration tools. Then, this script should
    be examined before being applied by the person in charge of maintaining the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create migrations, we must add the aforementioned extension methods to the
    ASP.NET Core MVC `Startup.cs` file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Please be sure that both the authorization and authentication modules have been
    added to the ASP.NET Core pipeline; otherwise, the authentication/authorization
    engine will not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must add the connection string to the `appsettings.json` file, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's add `Microsoft.EntityFrameworkCore.Design` to the ASP.NET Core
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, let''s open Visual Studio Package Manager Console, select `PackageManagementDB`
    as the default project, and then launch the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will scaffold the first migration. We may apply it to
    the database with the `Update-Database` command. Please note that if you copy
    the project from GitHub, you don't need to scaffold migrations since they have
    already been created, but you still need to update the database.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the application layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a first step, for simplicity, let''s freeze the application culture to `en-US`
    by adding the code that follows to the ASP.NET Core pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s create a `Tools` folder and place the `ApplicationLayer` code
    there, which you may find in the `ch12` code of the GitHub repository associated
    with this book. With these tools in place, we can add the code that automatically
    discovers and adds all queries, command handlers, and event handlers to the DI
    engine, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must add a `Queries` folder to place all queries and their associated
    interfaces. As an example, let''s have a look at the query that lists all packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The query object is automatically injected into the application DB context.
    The `GetAllPackages` method uses LINQ to project all of the required information
    into `PackageInfosViewModel` and sorts all results in descending order on the
    `EndValidityDate` property.
  prefs: []
  type: TYPE_NORMAL
- en: '`PackageInfosViewModel` is placed in the `Models` folder together with all
    other ViewModels. It is good practice to organize ViewModels into folders by defining
    a different folder for each controller. It is worth analyzing the ViewModel used
    for editing packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: It has a constructor that accepts an `IPackage` aggregate. This way, package
    data is copied into the ViewModel that is used to populate the edit view. It implements
    the `IPackageFullEditDTO` DTO interface defined in the domain layer. This way,
    it can be directly used to send `IPackage` updates to the domain layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'All properties contain validation attributes that are automatically used by
    client-side and server-side validation engines. Each property contains a `Display`
    attribute that defines the label to give to the input field that will be used
    to edit the property. It is better to place the field labels in the ViewModels
    than placing them directly into the views since, this way, the same names are
    automatically used in all views that use the same ViewModel. The following code
    block lists all its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Commands` folder contains all commands. As an example, let''s have a look
    at the command used to modify packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Its constructor must be invoked with an implementation of the `IPackageFullEditDTO`
    DTO interface, which, in our case, is the edit ViewModel we described previously.
    Command handlers are placed in the `Handlers` folder. It is worth analyzing the
    command that updates packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Its constructor has automatically injected the `IPackageRepository` repository
    and an `IEventMediator` instance needed to trigger event handlers. The following
    code also shows the implementation of the standard `HandleAsync` command handler
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Command operations are repeated until no concurrency exception is returned.
    `HandleAsync` uses the repository to get an instance of the entity to modify.
    If the entity is not found (it has been deleted), the commands stop its execution.
    Otherwise, all changes are passed to the retrieved aggregate. Immediately after
    the update, all events contained in the aggregate are triggered. In particular,
    if the price has changed, the event handler associated with the price change is
    executed. The concurrency check declared with the `[ConcurrencyCheck`] attribute
    on the `EntityVersion` property of the `Package` entity ensures that the package
    version is updated properly (by incrementing its previous version number by 1),
    as well as that the price changed event is passed the right version numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, event handlers are placed in the `Handlers` folder. As an example, let''s
    have a look at the price changed event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The constructor has automatically injected the `IPackageEventRepository` repository
    that handles the database table and all the events to send to other applications.
    The `HandleAsync` implementation simply calls the repository method that adds
    a new record to this table.
  prefs: []
  type: TYPE_NORMAL
- en: All records in the table are handled by `IPackageEventRepository`, which can
    be retrieved and sent to all interested microservices by a parallel task defined
    in the DI engine with a call such as `services.AddHostedService<MyHostedService>();`,
    as detailed in the *Using generic hosts* subsection of *Chapter 5*, *Applying
    Microservice Architecture to Your Enterprise Application*. However, this parallel
    task is not implemented in the GitHub code associated with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes how controllers and views are designed.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers and views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to add two more controllers to the one automatically scaffolded by Visual
    Studio; namely, `AccountController`, which takes care of user login/logout and
    registration, and `ManagePackageController`, which handles all package-related
    operations. It is enough to right-click on the `Controllers` folder and then select
    **Add** | **Controller**. Then, choose the controller name and select the empty
    MVC controller to avoid the possibility of Visual Studio scaffolding code you
    don't need.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, `AccountController` just has login and logout methods, so you
    can log in just with the initial administrator user. However, you can add further
    action methods that use the `UserManager` class to define, update, and delete
    users. The `UserManager` class can be provided through DI, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '`SignInManager` takes care of login/logout operations. The `Logout` action
    method is quite simple and is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: It just calls the `signInManager.SignOutAsync` method and then redirects the
    browser to the home page. To avoid it being called by clicking a link, it is decorated
    with `HttpPost`, so it can only be invoked via a form submit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Login, on the other hand, requires two action methods. The first one is invoked
    via `Get` and shows the login form, where the user must place their username and
    password. It is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'It receives `returnUrl` as its parameter when the browser is automatically
    redirected to the login page by the authorization module. This happens when an
    unlogged user tries to access a protected page. `returnUrl` is stored in the `ViewState`
    dictionary that is passed to the login view. The form in the login view passes
    it back, together with the username and password, to the controller when it is
    submitted, as shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The form post is intercepted by an action method with the same `Login` name
    but decorated with the `[HttpPost]` attribute, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method receives the `Login` model used by the login view, together
    with the `returnUrl` query string parameter. The `ValidateAntiForgeryToken` attribute
    verifies a token (called an anti-forgery token) that MVC forms automatically.
    This is then added to a hidden field to prevent cross-site attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, the action method logs the user out if they are already logged
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, it verifies whether there are validation errors, in which case it
    shows the same view filled with the data of the ViewModel to let the user correct
    their errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'If the model is valid, `_signInManager` is used to log the user in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'If the result returned by the operation is successful, the action method redirects
    the browser to `returnUrl` if it''s not null; otherwise, it redirects the browser
    to the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: If the login fails, it adds an error to `ModelState` and shows the same form
    to let the user try again.
  prefs: []
  type: TYPE_NORMAL
- en: '`ManagePackagesController` contains an `Index` method that shows all packages
    in table format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The query object is injected into the action method by DI. Then, the action
    method invokes it and inserts the resulting `IEnumerable` into the `Items` property
    of a `PackagesListViewModel` instance. It is a good practice to include `IEnumerables`
    in ViewModels instead of passing them directly to the views so that, if necessary,
    other properties can be added without the need to modify the existing view code.
    Results are shown in a Bootstrap 4 table since Bootstrap 4 CSS is automatically
    scaffolded by Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_15_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: Application packages handling page'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **New package** link (it is shaped like a **Bootstrap 4** button, but it
    is a link) invokes a controller `Create` action method, while the **delete** and
    **edit** links in each row invoke a `Delete` and `Edit` action method, respectively,
    and pass them the ID of the package shown in the row. Here is the implementation
    of the two-row links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth describing the code of the `HttpGet` and `HttpPost` `Edit` action
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The `Edit` method of `HttpGet` uses `IPackageRepository` to retrieve the existing
    package. If the package is not found, that means it has been deleted by some other
    user, and the browser is redirected again to the list page to show the updated
    list of packages. Otherwise, the aggregate is passed to the `PackageFullEditViewModel`
    ViewModel, which is rendered by the `Edit` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view used to render the package must render `select` with all possible
    package destinations, so it needs an instance of the `IDestinationListQuery` query
    that was implemented to assist with the destination selection HTML logic. This
    query is injected directly into the view since it is the view''s responsibility
    to decide how to enable the user to select a destination. The code that injects
    the query and uses it is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The action method that processes the post of the view form is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: If `ModelState` is valid, `UpdatePackageCommand` is created and its associated
    handler is invoked; otherwise, the View is displayed again to the user to enable
    them to correct all the errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new links to the package list page and login page must be added to the
    main menu, which is in the `_Layout` view, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '`logoutForm` is an empty form whose only purpose is to send a post to the `Logout`
    action method. It has been added to the end of the body, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Now, the application is ready! You can run it, log in, and start to manage packages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed the ASP.NET Core pipeline and various modules that
    comprise an ASP.NET Core MVC application in detail, such as authentication/authorization,
    the options framework, and routing. Then, we described how controllers and Views
    map requests to response HTML. We also analyzed all the improvements introduced
    in the latest versions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we analyzed all the design patterns implemented in the ASP.NET Core
    MVC framework and, in particular, the importance of the Separation of Concerns
    principle and how ASP.NET Core MVC implements it in the ASP.NET Core pipeline,
    as well as in its validation and globalization modules. We focused in more detail
    on the importance of Separation of Concerns between the presentation layer logic
    and graphics, as well as how the MVC pattern ensures it.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter explains how to implement a presentation layer as a **Single-Page
    Application** (**SPA**) with the new Blazor WebAssembly framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you list all the middleware modules scaffolded by Visual Studio in an ASP.NET
    Core project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the ASP.NET Core pipeline module need to inherit from a base class or implement
    some interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that a tag must have just one tag helper defined for it, otherwise
    an exception is thrown?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you remember how to test if validation errors have occurred in a controller?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the instruction in a layout view for including the output of the main
    view that's called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are secondary sections of the main view invoked in a layout view?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a controller invoke a view?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, how many providers are installed in the globalization module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are ViewModels the only way for controllers to communicate with their invoked
    views?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More details on the ASP.NET MVC framework are available in its official documentation
    at [https://docs.microsoft.com/en-US/aspnet/core/](https://docs.microsoft.com/en-US/aspnet/core/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details on the Razor syntax can be found at [https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?tabs=visual-studio).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the creation custom tag helpers that were not discussed in
    this chapter can be found at [https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring](https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the creation of custom controller attributes can be found at
    [https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters](https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The definition of custom validation attributes is discussed in this article:
    [https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/](https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
