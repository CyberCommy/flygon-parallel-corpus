- en: Chapter 11. Using MongoDB with Our Waiter Caller Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our web application now has nearly all of its functionality. If we plan to monetize
    this application, now would be the time where we'd demo it to potential customers.
    Even though their data (such as their account name and virtual table data) would
    be lost every time we had to restart our server, this data is trivial enough to
    make a full demo of the application feasible.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will add a proper database for use in production. We'll
    use MongoDB—a slightly controversial NoSQL database management system that has
    become extremely popular, arguably largely because of its simplicity. We'll take
    a look at how to install in on our VPS, configure it correctly, and access it
    using a Python driver. Then, we'll implement the full `DBHelper` class to replace
    `MockDBHelper`, which we use for testing. To end off, we'll look at adding indices
    to MongoDB and a favicon to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the MongoDB shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing PyMongo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding some finishing touches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is a NoSQL database. This means that unlike the MySQL database we used
    for our Crime Map project, it is not organized into tables, rows, and columns;
    instead, it is organized into collections, documents, and fields. While it can
    be useful to think of these new terms as a sort of translation from those we use
    for relational databases, the concepts do not perfectly translate. If you have
    a background in relational databases, a useful and more complete reference to
    these translations can be found on the official MongoDB website at [https://docs.mongodb.org/manual/reference/sql-comparison/](https://docs.mongodb.org/manual/reference/sql-comparison/).
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB's structure is much more flexible than that of a SQL database—not all
    of our data has to confirm to a specific schema, and this can save development
    time. For our Crime Map project, we had to spend time up front looking at our
    data and deciding how to represent it in a database. We then had to set up a bunch
    of fields, specifying the data type, length, and other constraints. MongoDB, by
    contrast, requires none of this. It's more flexible than an RDBMS, and it uses
    documents to represent the data. Documents are essentially bits of JSON data similar
    to the data we pulled from the APIs we used. This means that we can easily add
    or remove fields as necessary, and we do not need to specify data types for our
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this is that by not being forced to be structured and consistent,
    it's easy for us to get lazy and fall into bad practices of mixing different data
    types in a single field and allowing invalid data to pollute our database. In
    short, MongoDB gives us more freedom, but in doing so, it shifts some of the responsibility
    for being clean and consistent onto our shoulders.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB can be found in the Ubuntu software repositories, but as updates are
    frequent and the repository versions tend to lag behind, it's highly recommended
    to install it from the official Mongo package directly.
  prefs: []
  type: TYPE_NORMAL
- en: We'll go through how to do this step by step here, but as the installation procedures
    may change, it's advisable to get an updated version of the required URLs and
    steps from the official installation guide available at [https://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/](https://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is import MongoDB''s public key so that the installation
    can be authenticated. On your VPS only (as before, we will not install a database
    server on our development machine), run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the key, we can use the following command to add a link to
    the MongoDB package to our software sources. Note that this command is specific
    to Ubuntu 14.04 "Trusty", which, at the time of writing, is the latest long-term
    support Ubuntu version. If your VPS runs a different version of Ubuntu, make sure
    you get the correct command from the MongoDB documentation link provided earlier.
    To discover which version of Ubuntu you have, run `lsb_release -a` in your terminal
    and examine the output for a version number and name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we simply need to update our source lists by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, do the actual installation by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will install MongoDB with some sensible defaults and start
    the server. It'll also configure it in such a way that the server will start up
    automatically if you reboot your VPS.
  prefs: []
  type: TYPE_NORMAL
- en: Using the MongoDB shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similarly to what we discussed with MySQL, MongoDB comes with a simple shell.
    This is ideal to run quick, one-off commands and get used to the syntax. Let's
    run through the basic CRUD operations to get familiar with how MongoDB works.
  prefs: []
  type: TYPE_NORMAL
- en: As in our previous project, once we introduce MongoDB, we'll move to using it
    only through Python code; however, to start out, we'll write commands directly
    in the shell. This means there will be some slight differences in syntax, but
    as nearly everything is JSON based, these differences shouldn't be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the MongoDB shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start the MongoDB shell, run the following command on your VPS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will start the interactive MongoDB shell as in the following image, which
    you can exit at any time by pressing *Ctrl + C* or by typing `exit` into the shell
    and pressing *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting the MongoDB shell](img/B04312_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running commands in the MongoDB shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with MySQL, the top-level concept in MongoDB is a database. By default,
    this will connect to a database named `test`. We can change databases using the
    `use` command. Run the following command in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You should see the output "**Switched to db sandbox**". This is where we can
    note the first big difference between MySQL and MongoDB. With MySQL, we would
    first have had to create the database. This is a common pattern we'll see with
    MongoDB; if you reference a database, collection, or field that doesn't exist,
    it'll be automatically created for you.
  prefs: []
  type: TYPE_NORMAL
- en: Creating data with MongoDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s create a collection (similar to a table in our MySQL database from
    the Crime Map project) and add a document (as with a row from a table in our MySQL
    database) to it. Run the following in the MongoDB shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, `db` refers to the current database. Directly after,
    `people` refers to the collection called of this name. As it doesn't exist, it'll
    get created as we attempt to use it. Following this is `insert`, which means we
    want to add something to the database. We will pass as an argument (inside round
    the brackets), which is a JSON structure. In our case, we represented a person
    with a JSON object containing the person's name and age. Note that everything
    is in quotation marks except for the value of the `age` field; again, unlike MySQL,
    we don't have to specify the types for this data. MongoDB will store the name
    as a string and the age as an integer, but it applies no restrictions to these
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another person to the database to make the next operations that we will
    try out more meaningful. Run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Reading data with MongoDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of the SQL concept of a `SELECT` statement, MongoDB uses a `find()`
    command. Similarly to SQL, we can specify the criteria to search for in data and
    also choose which fields we want the database to return. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is the most basic version of the `find` operation. It'll simply *find*
    or *retrieve* all the data and all its fields from the `people` collection. You
    should see MongoDB output all the information about both the people we just added.
    You'll note that each person also has an `ObjectId` field added; MongoDB adds
    unique identifier fields to each of our documents automatically, and these `ID`
    fields are also automatically indexed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `find` with a single argument. The argument specifies criteria,
    and MongoDB only returns documents that match. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return all the fields from all the records if the name matches `John
    Smith`, so you should see a single result returned and printed to the shell, as
    in the screenshot that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading data with MongoDB](img/B04312_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, if we don''t want all the fields returned, we can run the `find` command
    and pass in a second argument to specify which fields we want. Run the following
    command, and you should see results as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Reading data with MongoDB](img/B04312_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first argument says we're only interested in people who are called "John
    Smith". The second argument says we're only interested in their age. Here, `1`
    is a flag that says we want this field. We could instead use `0` to say that we're
    not interested in a field, in which case, all the fields will be returned except
    this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that even though we said we were only interested in the `age` field, the
    preceding command returned the `_id` field as well. The `_id` field is always
    returned unless explicitly excluded. For example, we could run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will return only John's age and nothing else. Also, note that the key for
    the `_id` field is `_id` and not `id`; this is to prevent a conflict with the
    `id` keyword in many programming languages, including Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of our examples used very basic JSON objects with only a single value,
    but we can specify multiple values for each argument. Consider the difference
    between the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first command uses `find` with a single argument that returns all records
    for all the people with the name John Smith and aged 1\. The second command uses
    `find` with two arguments and returns the `age` field (and `_id` field) of all
    the people with the name John Smith.
  prefs: []
  type: TYPE_NORMAL
- en: A final difference to note from MySQL is that there is no need to commit new
    data. Once we run the `insert` statement, the data will be in the database until
    we remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Updating data with MongoDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Updating existing records is slightly more complicated. MongoDB provides an
    `update` method, which can be called in the same way as `insert` and `find`. It
    also takes two arguments—the first specifying the criteria to find the document
    we want to update, and the second providing a new document to replace it with.
    Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This finds the person with the name John Smith, and replaces him with a new
    person, also with the name `John Smith` and aged 43\. If there are a lot of fields
    and we only want to change a single one, it is tedious and wasteful to recreate
    all the old fields. Therefore, we can use MongoDB''s `$set` keyword instead, which
    will only replace the specified fields inside a document instead of replacing
    the whole document. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This updates John's age back to 35 again, which is probably a relief to him.
    Instead of having to overwrite the whole document, here we only changed the `age`
    field. We did this using the `$set` keyword in the second argument. Note that
    the `update` function still takes two arguments and the second one now has a nested
    JSON structure—the out JSON object has `$set` as the key and another JSON object
    as a value. The inner JSON object specifies the updates that we want to make.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data with MongoDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Deleting data is as easy as finding it. We will simply use the `remove` function
    instead of `find` and then specify the matching criteria in a single argument,
    just as we would with `find`. Run the following command to delete John from our
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a confirmation that one record was deleted, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting data with MongoDB](img/B04312_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also check that John is deleted by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, only Mary will be returned, as in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting data with MongoDB](img/B04312_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To remove all the documents from a collection, we can pass in an empty argument.
    Run the following command to remove all the remaining people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `{}` specifies an empty criteria condition and therefore matches all
    the documents. Check that our `people` collection is empty by running the `find`
    command again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see no output, as shown in the following screenshot (with the earlier
    examples included for context), because our `people` collection is now empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting data with MongoDB](img/B04312_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we looked at the basics of MongoDB, let's take a look at how to run
    similar commands using Python instead of operating through the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing PyMongo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PyMongo is a library that implements drivers for MongoDB and will allow us
    to execute commands on our database from our application code. As usual, install
    it through pip using the following command (note that, similarly to MongoDB, you
    only need to install this library on the server):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can import this library into our application and build our real `DBHelper`
    class, implementing all the methods we used in our `MockDBHelper` class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the DBHelper class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last class that we need is the `DBHelper` class, which will contain all
    the functions that are required for our application code to talk to our database.
    This class will use the `pymongo` library we just installed in order to run MongoDB
    commands. Create a file named `dbhelper.py` in the `waiter` directory and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This code imports the `pymongo` library, and in the constructor, it creates
    a client—a Python object that will let us run the CRUD operations we tried out
    earlier on our database. We defined the name of our database as a global one,
    and in the second line of our constructor, we connected to the specified database
    using `client`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the user methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For user management, we need the same two functions we had in our mock class.
    The first is to get a user out of the database (in order to log this user in)
    and the second is to add new users to the database (in order to register new users).
    Add the following two methods to the `DBHelper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For the first method, we used PyMongo's `find_one()` function. This is similar
    to the `find()` method we used in the MongoDB shell but returns only a single
    match instead of all the matching results. As we only allow one registration per
    e-mail address, there will always be either one or zero matches. Using `find()`
    instead of `find_one()` here would also work, but we would get back a Python generator
    that produces a single or zero element. Using `find_one()`, we will get back either
    a single user result or none, which is exactly what our login code needs.
  prefs: []
  type: TYPE_NORMAL
- en: For the `add_user()` method, we used `insert()` exactly as we discussed when
    playing with the MongoDB shell and inserted a new document containing the e-mail
    address, salt, and salted hash of the password.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the table methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need methods to handle the following cases for the virtual tables that our
    users will create:'
  prefs: []
  type: TYPE_NORMAL
- en: One to add new tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One to update tables (so that we can add the shortened bitly URL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One to get all the tables (so that we can display them in the **Account** page)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One to get a single table (so that we can add the local table number to our
    requests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One to delete a table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a nice set of methods as it demonstrates all four of the CRUD database
    operations. Add the following code to the `DBHelper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For the `add_table()` method, MongoDB will assign a unique identifier every
    time we insert a table. This gives us true multiuser support. Our mock code used
    the user-chosen table number as a unique identifier and would break with multiple
    users when two or more users chose the same table number. In the `add_table()`
    method, we returned this unique identifier to the application code, which can
    then be used to build the URL that's needed to make new requests for this specific
    table.
  prefs: []
  type: TYPE_NORMAL
- en: The `update_table()` method uses the `insert()` function that we discussed earlier.
    As in our previous example, we used the `$set` keyword to keep our original data
    intact, and only edited a specific field (instead of overwriting the entire document).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that unlike in the MongoDB shell example, we now need quotation marks around
    `$set`; this makes it syntactically legal Python code (all the keys of a dictionary
    have to be strings), and PyMongo takes care of the magic in the background to
    convert our Python dictionaries into MongoDB commands and objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_tables()` function used the `find()` function instead of the `find_one()`
    function that we used for the user code. This caused PyMongo to return a Python
    generator that can produce all the data that matched the *find* criteria. As we
    assumed that we'll always be able to load all the tables into memory, we converted
    this generator to a list, which we then passed to our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_table()` function is used in cases when we only have access to the
    table ID and need to get other information about the table. This is exactly the
    scenario when we processed requests; the URL of the request contained the table''s
    unique ID but wanted to add the table number to the **Dashboard** page. The unique
    identifiers that MongoDB generated are actually objects rather than simple strings,
    but we had just the string from our URL. Therefore, we created `ObjectId` and
    passed in the string before using this ID to query the database. `ObjectId` can
    be imported from the `bson` library, which was installed automatically. This means
    we also need to add another import statement. Add the following line to the top
    of the `dbhelper.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `delete_table()` method used the `remove()` function exactly as
    we did before. Here, we removed a table by its unique identifier, so again, we
    created an `ObjectId` object from the string we had before passing it to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the request methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have to add the last three methods to the `DBHelper` class to deal with
    the attention requests. We need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a request when a patron visits the provided URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all the requests for a specific user to display on the **Dashboard** page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete requests from the database when the user hits the **Resolve** button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following methods to the `dbhelper.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Changing the application code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a real `DBHelper` class, we need to conditionally import it
    based on which environment we''re in. Change the import for the `MockDBHelper`
    class in the `waitercaller.py` file to read, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that the preceding four lines are added beneath the `config` import.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, our `DBHelper` class deals mainly with many instances of `ObjectId`,
    while our `MockDBHelper` class uses strings. We therefore need a small change
    to our `account_createtable()` function to cast `ObjectId` to a string. Take a
    look at the line in `waitercaller.py` that reads the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, change this to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that `tableid` is always a string before we concatenate it
    to our URL.
  prefs: []
  type: TYPE_NORMAL
- en: The last code changes we need for our production is a different `config` file
    to specify the correct `base_url` for our VPS and to indicate that the `MockDBHelper`
    class should not be used. As we don't check our `config` file into our `git` repository,
    we'll need to create this directly on the VPS.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our application in production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application should now be fully functional once we add the preceding code!
    As with the database section of our Crime Map application, this bit is the most
    delicate as we haven't been able to test the `DBHelper` code locally, and we'll
    have to debug it directly on the VPS. However, we're confident, from our `MockDBHelper`
    class, that all our application logic is working, and if the new database code
    holds up, everything else should go as expected. Let's push our code to the server
    and test it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locally, run the following commands in your `waitercaller` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'On your VPS, change to the `WaiterCaller` directory, pull the new code, and
    restart Apache, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the production `config` file using nano by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Type the following into the new `config.py` file, substituting the IP address
    in `base_url` with the IP address of your VPS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Then, save and quit the file by hitting *Ctrl* + *X* and entering *Y* when prompted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command to reload Apache with the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Visit the IP address of your VPS in your local browser and do a run-through
    of all the functionality to make sure everything works as expected. This includes
    attempting to sign up with invalid data, signing up, attempting to log in with
    invalid data, logging in, creating a table, creating a request, viewing the dashboard,
    waiting for the dashboard to refresh, resolving a request, and more. For a full
    test, all the actions should be completed several times in varying combinations.
  prefs: []
  type: TYPE_NORMAL
- en: You'll probably understand how tedious this gets even for our relatively simple
    application. For more complicated applications, it is well worth the effort to
    create automatic tests—code that imitates what a user would do on the site but
    also has built-in expectations of what should happen at each step. Tools such
    as Selenium ([www.seleniumhq.org](http://www.seleniumhq.org)) come in very useful
    to build such tests.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As always, if anything goes wrong or you get the dreaded "500: Internal Server
    Error", check the Apache error file at `/etc/log/apache2/error.log` for hints.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding some finishing touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To end off, we'll add a couple of indices to our database to improve efficiency
    and prevent multiple requests from being open for a single table. After this,
    we'll add a favicon to personalize our web application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding indices to MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Database indices are used to increase efficiency. Normally, to find a subset
    of documents in our database that match certain criteria (that is, whenever we
    use the MongoDB `find()` method), the database engine has to examine each record
    and add the ones that match the returned result. If we add an index to a specific
    field, the database will store more metadata, which can be thought about as storing
    a sorted copy of this field. To find out whether `john@example.com` appears in
    a sorted list is much more efficient than checking whether it appears in an unsorted
    list. However, the indices do take up additional storage space, so choosing where
    to add indices is a classic *space-time tradeoff* that's seen everywhere in computer
    science. MongoDB can also use indices to place some constraints on a field. In
    our case, we'll use a *unique* index, which prevents a new document from being
    added to the database if the value for the indexed field already appears in another
    document in this collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add two indices to MongoDB. We''ll add an index on the `email` field
    of our `users` collection as we will use this field to find users on login, and
    we want the lookups to be as fast as possible. We also want to ensure at a database
    level that each e-mail address is unique. We already have two checks for this:
    the HTML5 field does a frontend check, and our application code does a backend
    check. Even though a database check may seem unnecessary, it takes little effort
    to set up and follows the good principles of baked-in security (in which checks
    aren''t just tacked on as an afterthought, but all data is validated as often
    as possible instead), and the principle that each *layer* of an application (the
    frontend, application layer, and database layer in our case) shouldn''t blindly
    trust the data that is passed from a higher layer.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll also add a unique index on the `table_id` field for a requests collection.
    This will prevent a single impatient table from spamming the dashboard with multiple
    requests by refreshing the page that creates a new request. It's also useful because
    our requests are created using GET requests, which can easily be duplicated (by
    a browser preloading a page or a social network scraping the links a user visits
    to find out more about them). By ensuring that each request's `table_id` is unique,
    we can prevent both of these issues.
  prefs: []
  type: TYPE_NORMAL
- en: Where do we add indices?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we built our MySQL database, we had a setup script that ran independently
    of our Crime Map web application. This setup script built the skeleton of the
    database, and we wrote it in Python so that we could easily run it again if we
    ever needed to migrate to a new server or to reinstall our database.
  prefs: []
  type: TYPE_NORMAL
- en: As MongoDB is so much more flexible, we didn't need a setup script. We can start
    our application off on a new server, and—as long as we install MongoDB—the database
    will recreate itself from scratch as new data is added or the old data is restored
    from a backup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lack of a setup script does mean that we don''t really have a good place
    to add indices to our database. If we add the indices through the MongoDB shell,
    it means that someone has to remember to add them again if the application needs
    to migrate to a new server. Therefore, we''ll create an independent Python script
    just to make the indices. On your local machine, create a Python file in the `waitercaller`
    directory and call it `create_mongo_indices.py`. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The connection code is the same that we used before, and the code used to create
    indices is simple enough. We called the `create_index()` method on the collection
    we want to create an index on and then passed in the field name to use to create
    the index. In our case, we also passed in the `unique=True` flag to specify that
    the indices should also have a unique constraint added to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to make a small change to our application so that it can deal
    with the case of a new request being made when an identical request is already
    open. In the `dbhelper.py` file, update the `add_request()` method to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to insert a request into our database with a duplicate `table_id`
    field, `DuplicateKeyError` will be thrown. In the updated code, we will catch
    this error and return `False` to indicate that the request wasn''t successfully
    created. We will also now return `True` when the request is successful. To take
    advantage of this information in the application code, we also need to update
    the `new_request()` method. Edit the method so that it looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will check whether the new request was successfully created or whether
    an existing one blocked it. In the latter case, we will return a different message,
    requesting patience from the patron.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the new functionality, add the new and modified files to Git (`waitercaller.py`,
    `dbhelper.py`, `create_mongo_indices.py`), commit, and then push them. On your
    VPS, pull in the new changes, restart Apache, and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the indices we discussed before, run some tests again in your browser
    to make sure nothing broke and to verify that you get the new message displayed
    when you visit the same attention request URL repeatedly without resolving the
    request, as in the screenshot that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Where do we add indices?](img/B04312_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You may find that, due to your browser pre-fetching pages, attention requests
    get made automatically when you first create tables through the account page.
    If you see the message as displayed in the above image when you don't expect to,
    resolve any open requests on the dashboard page, and visit the newrequest URL
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a favicon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing we'll add to our application is a favicon. *Favicons* are the
    small images that most browsers display in the tab bar when a page is open and
    on the bookmarks bar if a user bookmarks a site. They add a friendly touch to
    the site and help a user identify a site more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tricky part about favicons is that they have to be really small. It''s
    customary to use a 16x16 pixel image as a favicon—which doesn''t leave that much
    room for creativity. There are some nice websites to help you create the perfect
    favicon for your website. One such site is [favicon.cc](http://favicon.cc), which
    allows you to create a favicon from scratch (giving you 16x16 blank pixels to
    start), or it can import an image. Using the import functionality, you can use
    a bigger image that [favicon.cc](http://favicon.cc) attempts to reduce to 16x16
    pixels—this has mixed results and generally works better with simpler images.
    An example favicon is included in the code bundle in the static directory, and
    an enlarged version of it is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a favicon](img/B04312_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have an icon (you can use the one provided in the code bundle), it''s
    easy to tell Flask to serve it along with the rest of the page. Make sure your
    icon is called `favicon.ico` (the standard extension for icon files is `.ico`)
    and put it in the `waitercaller/static` directory. Then, add the following line
    to the `<head>` section of the `base.html` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a link to the `favicon.ico` file using Jinja''s `url_for` function
    to generate the full URL needed to be directed to the static directory, which
    is simply converted to the plain HTML (which you can see by hitting **View source**
    in your browser). Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you reload the page again, you will see the favicon in the tab heading,
    and if you bookmark the page, you''ll view the icon in the bookmarks toolbar of
    your browser as well, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a favicon](img/B04312_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's it for our last project. Of course, no web application is ever truly
    complete, and there are countless improvements to make and features to add. By
    this stage in the book, you will have more than enough knowledge to start adding
    your own changes and bringing your original ideas into creation, either as extensions
    to the projects we walked through in this book or from scratch, as brand-new web
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed our Waiter Caller web application. We installed
    MongoDB on our server, learned how to use it through the shell, and then installed
    PyMongo. Using PyMongo, we created a new database helper class to allow our application
    code to run operations on the new database.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we added a favicon to make our web application friendlier and more
    aesthetically pleasing to users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we'll take a look at what could still be added
    to our application to improve usability and security and end with some pointers
    on where to look next to continue learning about Flask and web development through
    Python.
  prefs: []
  type: TYPE_NORMAL
