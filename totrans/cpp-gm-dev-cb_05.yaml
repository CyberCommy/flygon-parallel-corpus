- en: Chapter 5. Event-Driven Programming – Making Your First 2D Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting to make a Windows game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Windows classes and handles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding keyboard and mouse controls with text output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Windows resources with GDI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dialogs and controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using animated sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows programming is the start of creating proper applications. We need to
    know how to package our game into one executable file so that all our resources,
    such as images, models, and sounds, are encrypted properly and packaged into one
    file. By doing this, we make sure that the files are safe and cannot be illegally
    copied on distribution. The application, however, still makes use of these files
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Windows programming also marks the start of understanding the Windows Message
    Pump. This system is very important to understand, as all major programming paradigms
    depend on this principle, especially when we are doing event-driven programming.
  prefs: []
  type: TYPE_NORMAL
- en: The main principle of event driven programming is that, based on events, we
    should process something. The concept to be understood here is how often we check
    for events and how often we should process them.
  prefs: []
  type: TYPE_NORMAL
- en: Starting to make a Windows game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to understand before we start making a Windows game is how a
    window or a message box is drawn. We need to be aware of the numerous inbuilt
    functions that Windows provides us with and the different callback functions that
    we can use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows. You also
    need to have a working copy of Visual Studio installed on your Windows machine.
    There are no other prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to create a message box in Windows.
    There are different types of message box we can create, and it is only a matter
    of a few lines of code. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 Windows application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Source.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`WINMAIN()` is the entry point of a Windows program. In this example, we have
    used the inbuilt function to create a message box. `windows.h` contains all the
    necessary files that we need to call the inbuilt functions present in the Windows
    API. A message box is typically used to display something. We can also associate
    message boxes with default Windows sounds. The display of the message box can
    also be controlled to a great extent. We need to use the right type of parameter
    to achieve this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other types of message box that we can use as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MB_OK**: One button, with the **OK** message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MB_OKCANCEL**: Two buttons, with the **OK**, **Cancel** message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MB_RETRYCANCEL**: Two buttons, with the **Retry**, **Cancel** message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MB_YESNO**: Two buttons, with the **Yes**, **No** message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MB_YESNOCANCEL**: Three buttons, with the **Yes**, **No**, **Cancel** message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MB_ABORTRETRYIGNORE**: Three buttons, with the **Abort**, **Retry**, **Ignore**
    message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MB_ICONEXCLAIMATION**: An exclamation point icon appears'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MB_ICONINFORMATION**: An information icon appears'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MB_ICONQUESTION**: A question mark icon appears'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MB_ICONSTOP**: A stop sign icon appears'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like all good Win32 or Win64 API functions, `MessageBox` returns a value to
    let us know what happened.
  prefs: []
  type: TYPE_NORMAL
- en: Using Windows classes and handles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To write games, we do not need to know a lot about Windows programming. What
    we need to know is how to open a window, how to process messages, and how to call
    the main game loop. The first task of a Windows application is to create a window.
    After the windows is created, we can do various other things, such as processing
    events and handling callbacks. These events are finally used by the game framework
    to display sprites on the screen and make them movable and interactive so that
    we can play a game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will find out how easy it is to use Windows classes and handles.
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 Windows application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The entire `typedef` struct `_WNDCLASSEX` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Windows API provides us with multiple API callbacks. We need to decide which
    message to intercept and what information to process in that message pump. For
    example, `WM_CREATE` is a Windows create function. We should perform most of our
    initializations here. Similarly, `WM_DESTROY` is where we need to destroy our
    created objects. We need to use GDI objects to paint boxes and other things on
    the window. We can also display our own cursors and icons on the window.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a window is the first step in Windows programming. All our sprites
    and other objects will be drawn on top of this window. There is a standard way
    of drawing a window. So this part of the code will be repeated in all programs
    that use Windows programming to draw something.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to create a window:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 Windows application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have used the standard Windows API callback. We query on
    the message parameter that is passed and, based on that, we intercept and perform
    suitable actions. We have used the `WM_PAINT` message to paint the window for
    us and the `WM_DESTROY` message to destroy the current window. To paint the window,
    we need a handle to the device context and then we can use `BeginPaint` and `EndPaint`
    appropriately. In the main structure, we need to fill up the Windows structures
    and specify the current cursor and icons that need to be loaded. Here, we can
    specify what color brush we are going to use to paint the window. Finally, the
    size of the window is specified and registered. After that, we need to continuously
    peek messages, translate them, and finally dispatch them to the Windows procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Adding keyboard and mouse controls with text output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important things that we require in a video game is a human
    interface to interact with. The most common interface devices are the keyboard
    and the mouse. Therefore, it is very important to understand how they work and
    how we can detect key presses and movements. It is equally important to know how
    to display specific text on the screen; this can be really useful for debugging
    and for HUD implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to detect keyboard and mouse
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 Windows application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main window is created and registered. In the callback function, we use
    a function called `GetAsyncKeyState(VK_KEYNAME)` to detect which key was pressed.
    After that, we perform a bitwise `AND` operation to check whether the last key
    press was also the same key and whether it has actually been pressed. We then
    have different Boolean parameters to detect the state of the key press and store
    them. The code could be structured in a better way, but this is the easiest way
    to understand how to detect key presses. To detect the mouse movement coordinates,
    we use a function called `GetCursorPos` inside `WM_MOUSEMOVE` and accordingly
    get the *x* and *y* coordinates on screen. Finally, we need to display all this
    information on the screen. To do this, we create a rectangle on screen. In that
    rectangle, we need to use a function called `TextOut` to display that information.
    The `TextOut` function uses the handle to the device context, the *x* and *y*
    coordinates, and the message to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Using Windows resources with GDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Graphics** **Device Interface** (**GDI**) allows us to do interesting things
    using bitmaps, icons cursors, and so on. GDI is used as a rendering alternative
    if we are not implementing any other rendering alternatives such as OpenGL or
    DirectX.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to load resources using the
    Windows GDI:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 Windows application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **Resource files** and add a new cursor from the **Add Resource**
    subsection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `resource.h` file will automatically be created for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a source file called `Source.cpp` and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Loading up the new cursor is the easiest task to achieve. We need to modify
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we specify null here, the default windows cursor will be loaded. Instead,
    we can load the cursor that we just created. Make sure the reference name of the
    cursor in `resource.h` is specified as `IDC_CURSOR2`. We can name it anything
    we want, but we need to call the appropriate reference from the `LoadCursor` function.
    `MAKEINTRESOURCE` enables us to relate to the resource file from the source code.
    Similarly, we can load multiple cursors and switch them at runtime if we so desire.
    The same process is used for loading other resources, such as icons and other
    bitmaps. When we modify a resource file, the corresponding `resource.h` file must
    be closed or it will not allow us to edit it. Similarly, if we want to manually
    edit the `source.h` file, we need to close the corresponding `.rc` or resource
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Using dialogs and controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dialogs are one of the mandatory features of Windows programming. If we are
    creating a complete application, there will be a stage when we will require dialogs
    in some form. Dialogs could be in the form of edit boxes, radio buttons, check
    boxes, and so on. Dialogs come in two forms: modal and modeless. Modal dialog
    boxes require an immediate response, whereas modeless dialog boxes are more like
    floating boxes and do not require an immediate response.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows. You also
    need to have a working copy of Visual Studio installed on your Windows machine.
    No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will find out how easy it is to create dialog boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 windows application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select dialog as the type of resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the box in whatever way you desire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A corresponding `resource.h` file will be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to `Source.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the `resource.h` file is automatically created for us, we can manually
    edit it to name the dialog appropriately. After the main window is created, we
    need to get a handle to the window and then call the dialog box function like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Very much like the main window callback, the dialog box has its own callback.
    We need to intercept the messages accordingly and perform our actions. `BOOL CALLBACK
    AboutDlgProc` is the callback that we have at our disposal. We have a similar
    initialize message. For our dialog boxes, most of the intercepts will take place
    in `WM_COMMAND`. Based on the `wparam` parameter, we need to switch, so that know
    whether we have clicked the **OK** button or the **CANCEL** button and can take
    the appropriate steps.
  prefs: []
  type: TYPE_NORMAL
- en: Using sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To develop any 2D game, we need sprites. Sprites are elements of computer graphics
    that can stay on screen, be manipulated, and be animated. GDI allows us to use
    sprites to create our game. Probably all the assets in the game will be sprites,
    from the UI to the main characters, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how to use sprites in our game:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new resource type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Sprite** option as the new resource type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following source files: `backbuffer.h/cpp`, `Clock.h/cpp`, `Game.h/.cpp`,
    `sprite.h/cpp`, and `Utilities.h`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `backbuffer.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `backbuffer.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `Clock.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `Clock.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `Game.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `Game.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `sprite.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `sprite.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `Utilities.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, the backbuffer is used to draw the image first and then we swap
    the buffer to present it to the screen. This process is also called *presenting*.
    We create a generic `backbuffer` class that helps us to swap the buffer. The `sprite`
    class is used to load the sprites and push them on to the back buffer, where they
    can be processed and finally drawn on the screen. The sprite class is also provided
    with some basic utility functions that help us to get the width and height of
    the sprite. Most of the functions are just a wrapper on top of Windows' own API
    functions and callbacks. We have also created a `clock` class, which helps us
    to keep track of time, as each time point should be implemented as a function
    of delta time. If we do not do this, then the game might run with fluctuating
    behavior, based on the machine that is executing it. The `game` class is used
    to put all of it together. It has an instance of `backbuffer`, which is a singleton
    class and handles the context of the window and other resources.
  prefs: []
  type: TYPE_NORMAL
- en: Using animated sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using animated sprites is an important part of games programming. Unless some
    kind of animation is applied to the sprites, it will not appear realistic enough
    and the whole mood of immersion in the game will be lost. Although animations
    can be achieved in a variety of ways, we will only look at sprite strip animation,
    as it is the most commonly used form of animation for 2D games.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows. You also
    need to have a working copy of Visual Studio installed on your Windows machine.
    No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will find out how easy it is to create dialog boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 Windows application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `AnimatedSprite.cpp` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Source.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the animation to work, we need to load in a sequence of images as sprite
    strips. The higher the number of images, the smoother the animation will be. For
    the equivalent number of sprites, we need to load in their masks as well, so that
    they can be blitted together. We need to store all the images in a vector list.
    For the animation to work properly, all the images must be equally spaced out.
    After we have stored them correctly, we can run the animations as rapidly or slowly
    as we want, by controlling how many frames/sprites we want to draw in a certain
    amount of time. The remaining process of drawing the sprite on the screen remains
    the same.
  prefs: []
  type: TYPE_NORMAL
