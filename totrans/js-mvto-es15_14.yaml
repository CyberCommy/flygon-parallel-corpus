- en: Chapter 2. Organizing Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we'll look at how to organize JavaScript code into reusable,
    understandable chunks. The language itself doesn't lend itself well to this sort
    of modularization but a number of methods of organizing JavaScript code have emerged
    over the years. This chapter will argue for the need to break down code and then
    work through the methods of creating JavaScript modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Global scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 2015 classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chunks of code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing anybody learns to program is the ubiquitous Hello World application.
    This simple application prints some variation of "hello world" to the screen.
    Depending on who you ask, the phrase hello world dates back to the early 1970s
    where it was used to demonstrate the B programming language or even to 1967 where
    it appears in a BCL programming guide. In such a simple application there is no
    need to worry about the structure of code. Indeed, in many programming languages,
    hello world needs no structure at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Ruby, it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For JavaScript (via Node.js), it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Programming modern computers was originally done using brutally simplistic techniques.
    Many of the first computers had problems they were attempting to solve hard-wired
    into them. They were not general purpose computing machines like the ones we have
    today. Instead they were built to solve just one problem such as decoding encrypted
    texts. Stored program computers were first developed in the late 1940s.
  prefs: []
  type: TYPE_NORMAL
- en: The languages used to program these computers were complicated at first, usually
    very closely tied to the binary. Eventually higher and higher-level abstractions
    were created to make programming more accessible. As these languages started to
    take shape through the 50s and 60s it quickly became apparent that there needed
    to be some way to divide up large blocks of code.
  prefs: []
  type: TYPE_NORMAL
- en: In part this was simply to maintain the sanity of programmers who could not
    keep an entire, large program in their heads at any one time. However, creating
    reusable modules also allowed for code to be shared within an application and
    even between applications. The initial solution was to make use of statements,
    which jumped the flow control of the program from one place to another. For a
    number of years these GOTO statements were heavily relied upon. To a modern programmer
    who has been fed a continual stream of warnings about the use of GOTO statements
    this seems like insanity. However it was not until some years after the first
    programming languages emerged that structured programming grew to replace the
    GOTO syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Structured programming is based on the Böhm-Jacopini theorem, which states
    that there is a rather large class of problems, the answer to which can be computed
    using three very simple constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: Sequential execution of sub-programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional execution of two sub-programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeated execution of a sub-program until a condition is true
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Astute readers will recognize these constructs as being the normal flow of execution,
    a branch or `if` statement, and a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Fortran was one of the earliest languages and was initially built without support
    for structured programming. However structured programming was soon adopted as
    it helped to avoid spaghetti code.
  prefs: []
  type: TYPE_NORMAL
- en: Code in Fortran was organized into modules. Modules were loosely coupled collections
    of procedures. For those coming from a modern object oriented language, the closest
    concept might be that a module was like a class that contains only static methods.
  prefs: []
  type: TYPE_NORMAL
- en: Modules were useful for dividing code into logical groupings. However, it didn't
    provide for any sort of structure for the actual applications. The structure for
    object-oriented languages, that is classes and subclasses, can be traced to a
    1967 paper written by Ole-Johan Dahl and Kristen Nygaard. This paper would go
    on to form the basis of Simula-67, the first language with support for object
    oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: While Simula-67 was the first language to have classes, the language most talked
    about in relation to early object oriented programming is Smalltalk. This language
    was developed behind closed doors at the famous Xerox **Palo Alto Research Center**
    (**PARC**) during the 1970s. it was released to the public in 1980 as Smalltalk-80
    (it seems like all historically relevant programming languages where prefixed
    with the year of release as a version number). What Smalltalk brought was that
    everything in the language was an object, even literal numbers like 3 could have
    operations performed on them.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every modern programming language has some concept of classes to organize
    code. Often these classes will fall into a higher-level structure commonly called
    a namespace or module. Through the use of these structures, even very large programs
    can be divided into manageable and understandable chunks.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the rich history and obvious utility of classes and modules, JavaScript
    did not support them as first class constructs until just recently. To understand
    why, one has to simply look back at the history of JavaScript from [Chapter 1](part0081_split_000.html#2D7TI2-015e68c68a464f18a9559f448be84435
    "Chapter 1. Designing for Fun and Profit"), *Designing For Fun and Profit*, and
    realize that for its original purpose having such constructs would have been overkill.
    Classes were a part of the ill-fated ECMAScript 4 standard and they finally became
    part of the language with the release of the ECMAScript 2015 standard.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we'll explore some of the ways to recreate the well worn class
    structure of other modern programming languages in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: What's the matter with global scope anyway?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In browser based JavaScript every object you create is assigned to the global
    scope. For the browser, this object is simply known as **window**. It is simple
    to see this behavior in action by opening up the development console in your favorite
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Opening the Development Console**'
  prefs: []
  type: TYPE_NORMAL
- en: Modern browsers have, built into them, some very advanced debugging and auditing
    tools. To access them there is a menu item, which is located under **Tools** |
    **Developer Tools in Chrome** | **Tools** | **Web Developer in Firefox**, and
    directly under the menu as **F12 Developer Tools** in Internet Explorer. Keyboard
    shortcuts also exist for accessing the tools. On Windows and Linux, *F12* is standard
    and, on OSX, `Option` + `Command` + `I` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Within the developer tools is a console window that provides direct access to
    the current page's JavaScript. This is a very handy place to test out small snippets
    of code or to access the page's JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the console open, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this will be `hello world` printed to the console. By declaring
    words globally it is automatically attached to the top level container: window.'
  prefs: []
  type: TYPE_NORMAL
- en: In Node.js the situation is somewhat different. Assigning a variable in this
    fashion will actually attach it to the current module. Not including the `var`
    object will attach the variable to the `global` object.
  prefs: []
  type: TYPE_NORMAL
- en: For years you've likely heard that making use of global variables is a bad thing.
    This is because globals are very easily polluted by other code.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a very commonly named variable such as `index`. It is likely that in
    any application of appreciable size that this variable name would be used in several
    places. When either piece of code makes use of the variable it will cause unexpected
    results in the other piece of code. It is certainly possible to reuse variables,
    and it can even be useful in systems with very limited memory such as embedded
    systems, but in most applications reusing variables to mean different things within
    a single scope is difficult to understand and a source of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Applications that make use global scoped variables also open themselves up to
    being attacked on purpose by other code. It is trivial to alter the state of global
    variables from other code, which could expose secrets like login information to
    attackers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally global variables add a great deal of complexity to applications. Reducing
    the scope of variables to a small section of code allows developers to more easily
    understand the ways in which the variable is used. When the scope is global then
    changes to that variable may have an effect far outside of the one section of
    code. A simple change to a variable can cascade into the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule global variables should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Objects in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is an object oriented language but most people don''t make use of
    the object oriented features of it except in passing. JavaScript uses a mixed
    object model in that it has some primitives as well as objects. JavaScript has
    five primitive types:'
  prefs: []
  type: TYPE_NORMAL
- en: undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of these five, only two are what we would expect to be an object anyway. The
    other three, boolean, string, and number all have wrapped versions, which are
    objects: Boolean, String, and Number. They are distinguished by starting with
    uppercase. This is the same sort of model used by Java, a hybrid of objects and
    primitives.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript will also box and unbox the primitives as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code you can see the boxed and unboxed versions of JavaScript primitives
    at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating objects in JavaScript is trivial. This can be seen in this code for
    creating an object in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Because JavaScript is a dynamic language, adding properties to objects is also
    quite easy. This can be done even after the object has been created. This code
    creates the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Objects contain both data and functionality. We''ve only seen the data part
    so far. Fortunately in JavaScript, functions are first class objects. Functions
    can be passed around and functions can be assigned to variables. Let''s try adding
    some functions to the object we''re creating in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is a bit painful, building up objects an assignment at a time.
    Let''s see if we can improve upon the syntax for creating objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax seems, at least to me, to be a much cleaner, more traditional way
    of building objects. Of course it is possible to mix data and functionality in
    an object in this fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of things to note in this piece of code. The first is that
    the different items in the object are separated using a comma and not a semi-colon.
    Those coming from other languages such as C# or Java are likely to make this mistake.The
    next item of interest is that we need to make use of the `this` qualifier to address
    the `greeting` variable from within the `doThings` function. This would also be
    true if we had a number of functions within the object as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `this` keyword behaves differently in JavaScript than you might expect coming
    from other C-syntax languages. `this` is bound to the owner of the function in
    which it is found. However, the owner of the function is sometimes not what you
    expect. In the preceding example `this` is bound to the `functionObject` object,
    however if the function were declared outside of an object this would refer to
    the global object. In certain circumstances, typically event handlers, this is
    rebound to the object firing the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`this` takes on the value of target. Getting used to the value of `this` is,
    perhaps, one of the trickiest things in JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ECMAScript-2015 introduces the `let` keyword which can replace the `var` keyword
    for declaring variables. `let` uses block level scoping which is the scoping you''re
    likely to use from most languages. Let''s see an example of how they differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With the var scoped version you can see that the variable lives on outside of
    the block. This is because behind the scenes the declaration of `varScoped` is
    hoisted to the beginning of the code block. With the `let` scoped version of the
    code `letScoped` is scoped just within the `for` loop so, once we leave the loop,
    `letScoped` is undefined. When given the option of using `let` or `var` we would
    tend to err on the side of always using `let`. There are some cases when you actually
    would want to use var scoping but they are few and far between.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have built up a pretty complete model of how to build objects within JavaScript.
    However, objects are not the same thing as classes. Objects are instances of classes.
    If we want to create multiple instances of our `functionObject` object we''re
    out of luck. Attempting to do so will result in an error. In the case of Node.js
    the error will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The stack trace here shows an error in a module called `repl`. This is the read-execute-print
    loop that is loaded by default when starting Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time that a new instance is required, the object must be reconstructed.
    To get around this we can define the object using a function as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax allows for a constructor to be defined and for new objects to be
    created from this function. Constructors without return values are functions that
    are called as an object is created. In JavaScript the constructor actually returns
    the object created. You can even assign internal properties using the constructor
    by making them part of the initial function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Build me a prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously mentioned, there was, until recently, no support for creating
    true classes in JavaScript. While ECMAScript-2015 brings some syntactic sugar
    to classes, the underlying object system is still as it has been in the past,
    so it remains instructive to see how we would have created objects without this
    sugar. Objects created using the structure in the previous section have a fairly
    major drawback: creating multiple objects is not only time consuming but also
    memory intensive. Each object is completely distinct from other objects created
    in the same fashion. This means that the memory used to hold the function definitions
    is not shared between all instances. What is even more fun is that you can redefine
    individual instances of a class without changing all of the instances. This is
    demonstrated in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Altering the functionality of a single instance or really of any already defined
    object in this fashion is known as **monkey** **patching**. There is some division
    over whether or not this is a good practice. It can certainly be useful when dealing
    with library code but it adds great confusion. It is generally considered better
    practice to extend the existing class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without a proper class system JavaScript, of course, has no concept of inheritance.
    However, it does have a prototype. At the most basic level an object in JavaScript
    is an associative array of keys and values. Each property or function on an object
    is simply defined as part of this array. You can even see this in action by accessing
    members of an object using array syntax as is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accessing members of an object using array syntax can be a very handy way to
    avoid using the eval function. For instance, if I had the name of the function
    I wanted to call in a string called `funcName` and I wanted to call it on an object,
    `obj1`, then I could do so by doing `obj1[funcName]()` instead of using a potentially
    dangerous call to eval. Eval allows for arbitrary code to be executed. Allowing
    this on a page means that an attacker may be able to enter malicious scripts on
    other people's browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an object is created, its definition is inherited from a prototype. Weirdly
    each prototype is also an object so even prototypes have prototypes. Well, except
    for the object which is the top-level prototype. The advantage to attaching functions
    to the prototype is that only a single copy of the function is created; saving
    on memory. There are some complexities to prototypes but you can certainly survive
    without knowing about them. To make use of a prototype you need to simply assign
    functions to it as is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note is that only the functions are assigned to the prototype.
    Instance variables such as `name` are still assigned to the instance. As these
    are unique to each instance there is no real impact on the memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: In many ways a prototypical language is more powerful than a class-based inheritance
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you make a change to the prototype of an object at a later date then all
    the objects which share that prototype are updated with the new function. This
    removes some of the concerns expressed about monkey typing. An example of this
    behavior is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When building up objects you should be sure to take advantage of the prototype
    object whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know about prototypes there is an alternative approach to building objects
    in JavaScript and that is to use the `Object.create` function. This is a new syntax
    introduced in ECMAScript 5\. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The create syntax will build a new object based on the given prototype. You
    can also pass in a `propertiesObject` object that describes additional fields
    on the created object. These descriptors consist of a number of optional fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`writable`: This dictates whether the field should be writable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configurable`: This dictates whether the files should be removable from the
    object or support further configuration after creation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enumerable`: This dictates whether the property can be listed during an enumeration
    of the object''s properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: This dictates the default value of the field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to assign a `get` and `set` functions within the descriptor
    that act as getters and setters for some other internal property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `object.create` for our castle we can build an instance using `Object.create`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that we explicitly define the `name` field. `Object.create`
    bypasses the constructor so the initial assignment we described in the preceding
    code won''t be called. You might also notice that writeable is set to `false`.
    The result of this is that the reassignment of `name` to `Highgarden` has no effect.
    The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the niceties of objects is that they can be built upon to create increasingly
    complex objects. This is a common pattern, which is used for any number of things.
    There is no inheritance in JavaScript because of its prototypical nature. However,
    you can combine functions from one prototype into another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have a base class called `Castle` and we want to customize
    it into a more specific class called `Winterfell`. We can do so by first copying
    all of the properties from the `Castle` prototype onto the `Winterfell` prototype.
    This can be done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course this is a very painful way to build objects. You''re forced to know
    exactly which functions the base class has to copy them. It can be abstracted
    in a rather naïve fashion like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are into object diagrams this shows how **Winterfell** extends **Castle**
    in this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inheritance](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This can be used quite simply as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We say that this is naïve because it fails to take into account a number of
    potential failure conditions. A fully-fledged implementation is quite extensive.
    The jQuery library provides a function called `extend` which implements prototype
    inheritance in a robust fashion. It is about 50 lines long and deals with deep
    copies and null values. The function is used extensively, internally in jQuery
    but it can be a very useful function in your own code. We mentioned that prototype
    inheritance is more powerful than the traditional methods of inheritance. This
    is because it is possible to mix and match bits from many base classes to create
    a new class. Most modern languages only support single inheritance: a class can
    have only one direct parent. There are some languages with multiple inheritance
    however, it is a practice that adds a great deal of complexity when attempting
    to decide which version of a method to call at runtime. Prototype inheritance
    avoids many of these issues by forcing selection of a method at assembly time.'
  prefs: []
  type: TYPE_NORMAL
- en: Composing objects in this fashion permits taking properties from two or more
    different bases. There are many times when this can be useful. For example a class
    representing a wolf might take some of its properties from a class describing
    a dog and some from another class describing a quadruped.
  prefs: []
  type: TYPE_NORMAL
- en: By using classes built in this way we can meet pretty much all of the requirements
    for constructing a system of classes including inheritance. However inheritance
    is a very strong form of coupling. In almost all cases it is better to avoid inheritance
    in favor of a looser form of coupling. This will allow for classes to be replaced
    or altered with a minimum impact on the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a complete class system it would be good to address the global
    namespace discussed earlier. Again there is no first class support for namespaces
    but we can easily isolate functionality to the equivalent of a namespace. There
    are a number of different approaches to creating modules in JavaScript. We'll
    start with the simplest and add some functionality as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start we simply need to attach an object to the global namespace. This object
    will contain our root namespace. We''ll name our namespace `Westeros`; the code
    simply looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This object is, by default, attached to the top level object so we need not
    do anything more than that. A typical usage is to first check if the object already
    exists and use that version instead of reassigning the variable. This allows you
    to spread your definitions over a number of files. In theory you could define
    a single class in each file and then bring them all together as part of the build
    process before delivering them to the client or using them in an application.
    The short form of this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the object, it is simply a question of assigning our classes as
    properties of that object. If we continue to use the `Castle` object then it would
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to build a hierarchy of namespaces that is more than a single level
    deep, that too is easily accomplished, as seen in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This class can be instantiated and used in a similar way to previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course with JavaScript there is more than one way to build the same code
    structure. An easy way to structure the preceding code is to make use of the ability
    to create and immediately execute a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This code seems to be a bit longer than the previous code sample but I find
    it easier to follow due to its hierarchical nature. We can create a new castle
    using them in the same structure as shown in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Inheritance using this structure is also relatively easily done. If we were
    to define a `BaseStructure` class which was to be in the ancestor of all structures,
    then making use of it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll note that the base structure is passed into the `Castle` object when
    the closure is evaluated. The highlighted line of code makes use of a helper method
    called `__extends`. This method is responsible for copying the functions over
    from the base prototype to the derived class. This particular piece of code was
    generated from a TypeScript compiler which also, helpfully, generated an `extends`
    method which looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can continue the rather nifty closure syntax we''ve adopted for a class
    to implement an entire module. This is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this structure you can see the same code for creating modules that we
    explored earlier. It is also relatively easy to define multiple classes inside
    a single module. This can be seen in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code creates a second class inside of the module. It is also
    perfectly permissible to define one class in each file. Because the code checks
    to get the current value of `Westeros` before blindly reassigning it, we can safely
    split the module definition across multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of the highlighted section shows exposing the class outside of
    the closure. If we want to make private classes that are only available within
    the module then we only need to exclude that line. This is actually known as the
    revealing module pattern. We only reveal the classes that need to be globally
    available. It is a good practice to keep as much functionality out of the global
    namespace as possible.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 2015 classes and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen so far that it is perfectly possible to build classes and even
    modules in pre ECMAScript -2015 JavaScript. The syntax is, obviously, a bit more
    involved than in a language such as C# or Java. Fortunately ECMAScript-2015, brings
    support for some syntactic sugar for making classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'ECMAScript-2015 also brings a well thought out module system for JavaScript.
    There''s also syntactic sugar for creating modules which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As modules can contain functions they can, of course, contain classes. ECMAScript-2015
    also defines a module import syntax and support for retrieving modules from remote
    locations. Importing a module looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Some of this syntactic sugar is available in any environment which has full
    ECMAScript-2015 support. At the time of writing, all major browser vendors have
    very good support for the class portion of ECMAScript-2015 so there is almost
    no reason not to use it if you don't have to support ancient browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices and troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an ideal world everybody would get to work on greenfield projects where they
    can put in standards right from the get go. However that isn't the case. Frequently
    you may find yourself in a situation where you have a bunch of non-modular JavaScript
    code as part of a legacy system.
  prefs: []
  type: TYPE_NORMAL
- en: In these situations it may be advantageous to simply ignore the non-modular
    code until there is an actual need to upgrade it. Despite the popularity of JavaScript,
    much of the tooling for JavaScript is still immature making it difficult to rely
    on a compiler to find errors introduced by JavaScript refactoring. Automatic refactoring
    tools are also complicated by the dynamic nature of JavaScript. However, for new
    code, proper use of modular JavaScript can be very helpful to avoid namespace
    conflicts and improve testability.
  prefs: []
  type: TYPE_NORMAL
- en: How to arrange JavaScript is an interesting question. From a web perspective
    I have taken the approach of arranging my JavaScript in line with the web pages.
    So each page has an associated JavaScript file, which is responsible for the functionality
    of that page. In addition, components which are common between pages, say a grid
    control, are placed into a separate file. At compile time all the files are combined
    into a single JavaScript file. This helps strike a balance between having a small
    code file with which to work and reducing the number of requests to the server
    from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It has been said that there are only two really hard things in computing science.
    What those issues are varies depending on who is speaking. Frequently it is some
    variation of cache invalidation and naming. How to organize your code is a large
    part of that naming problem.
  prefs: []
  type: TYPE_NORMAL
- en: As a group we seem to have settled quite firmly on the idea of namespaces and
    classes. As we've seen, there is no direct support for either of these two concepts
    in JavaScript. However there are myriad ways to work around the problem, some
    of which actually provide more power than one would get through a traditional
    namespace/class system.
  prefs: []
  type: TYPE_NORMAL
- en: The primary concern with JavaScript is to avoid polluting the global namespace
    with a large number of similarly named, unconnected objects. Encapsulating JavaScript
    into modules is a key step on the road toward writing maintainable and reusable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: As we move forward we'll see that many of the patterns which are quite complex
    arrangements of interfaces become far simpler in the land of JavaScript. Prototype-based
    inheritance, which seems difficult at the outset, is a tremendous tool for aiding
    in the simplification of design patterns.
  prefs: []
  type: TYPE_NORMAL
