- en: Chapter 5. Foreign Exchange Derivatives with C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now move to the world of currency or foreign exchange derivatives and how
    to price them using C++. We consider two examples: the pricing of a European Call
    option (basic example) and the pricing of an up-and-out barrier call option (advanced
    example). We provide the full-working C++ implementation for both. We follow the
    model for the evolution of foreign exchange currencies as found in "Foreign Currency
    Option Values". A simpler C implementation (without the OO features) can be found
    in the code bundle of this chapter. If you are new to OOP, it is recommended that
    you first study the implementation in C followed by the implementation in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic example – European FX Call (FX1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we demonstrate the pricing of a plain vanilla European Call
    option on foreign exchange. Our aim here is to calculate the premium of this financial
    derivative.
  prefs: []
  type: TYPE_NORMAL
- en: The full details of the contract, including the choice of mathematical model
    and its numerical method, are shown in the following Bento Box template for European
    Call FX option (FX1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic example – European FX Call (FX1)](img/00193.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Bento Box template for European Call FX option (FX1)
  prefs: []
  type: TYPE_NORMAL
- en: 'We proceed by completing the contents of the Bento Box in clockwise sense,
    starting from the top-left corner. The following are the steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Derivative contract**: We first fill all the data of the contract, in particular
    the payoff function, which in our case is as follows:![Basic example – European
    FX Call (FX1)](img/00194.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Equation 1
  prefs: []
  type: TYPE_NORMAL
- en: '**Math model**: We ought to select the mathematical model for the underlying,
    which in the case of currencies is the Garman-Kohlhagen model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Numerical method**: We select the numerical method to be used and in this
    case, we choose the finite difference method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Algorithm**: We construct the algorithm that will put together these calculations
    as a series of calculation steps, which will serve us as blueprint for implementing
    it in C++.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that a finite difference algorithm, in contrast to a Monte Carlo simulation,
    does not require a random number generator to operate. All computations are deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important feature of finite difference methods is that they require the
    definition of a mesh. This mesh is essentially the collection of coordinates in
    which the **Partial Differential Equation** (**PDE**) will be approximated. In
    the case of equities, the Black-Scholes PDE, for example, is defined in terms
    of two independent variables: the stock price *S* and time *t*. In the case of
    currencies, the Garman-Kohlhagen PDE is defined in terms of two variables: the
    exchange rate *X* and time *t*. The solution domain is therefore the area defined
    by all the possible values that the pairs *X* and *t* can take in the *X* and
    *t* plane. For example, if we are considering a European Call currency option
    with strike 1.0 EUR/GBP, spot price 1.0 EUR/GBP and a maturity of one year, our
    solution domain gamma could be defined as the range of values for *X* between
    0.5 and 1.5, and the range of values for *t* between 0 and 1\. In mathematical
    terms, this can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic example – European FX Call (FX1)](img/00195.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Equation 2
  prefs: []
  type: TYPE_NORMAL
- en: This rectangular domain then needs to be divided or discretized. This means
    that we have to transform it from a continuous into a discrete domain. Usually
    in finite differences, what we do is divide it into a number *N* of equidistant
    steps in the *X* axis and into a number *M* of equidistant steps in the *t* axis.
    The result is a grid that resembles a mesh and thus the origin of the name.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we present the implementation of the explicit finite difference method,
    as described in [Chapter 3](part0024_split_000.html#MSDG2-f9cfc61bea324a5db85ec5ea1673cdfd
    "Chapter 3. Numerical Methods"), *Numerical Methods*, using a transformation of
    variables. This is done to transform the original PDE into an equivalent but simplified
    dimensionless PDE, which describes the diffusion of heat. This dimensionless version
    of the PDE is easier to solve using FDM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this transformation, the solution domain is not changed into two
    new variables *x* and ![Basic example – European FX Call (FX1)](img/00196.jpeg).
    And so the PDE is solved in the domain defined by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic example – European FX Call (FX1)](img/00197.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Equation 3
  prefs: []
  type: TYPE_NORMAL
- en: We consider an example of a European Call option on currency with strike 0.75
    EUR/USD with a spot price of 0.75 EUR/USD. The option has six months to maturity.
    We divide the *x* axis in *N=5* steps and the tau axis in *M=6* steps. The premium
    under these conditions is 4.36 EUR/USD.
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming code snippets implement the algorithm from the Bento Box template.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code 9 – FX1_main.cpp (finite difference FX European Call)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Code 10 – FX1_source.cpp (finite difference FX European Call)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the basic example (FX1), you need to compile and run code snippets
    9,10,11,12, and 13 (which include a matrix and printing utility); afterwards,
    you should obtain the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic example – European FX Call (FX1)](img/00198.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Basic example (FX1): FX European Call screenshot with results'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced example – FX barrier option (FX2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this second example, we consider the pricing of an exotic option: an up-and-out
    barrier with a call payoff. The details of the approach are shown in the following
    Bento Box template for FX Barrier Up and Out option (FX2):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced example – FX barrier option (FX2)](img/00199.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Bento Box template for FX Barrier Up and Out option (FX2)
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is a great advantage of using **Finite Difference Methodology**
    (**FDM**) with respect to **Monte Carlo** (**MC**) in pricing a continuously monitored
    barrier option. This is because MC is rather complex to incorporate the continuously
    monitored features, leaving us with little choice but to increase the number of
    fixing/observation points in the MC program. However, this will significantly
    increase the computation time in MC. We do not need to do this in FDM, making
    it more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Our target is to compute the option premium as we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: An up-and-out barrier is just like a standard European Call option but with
    one crucial difference—if the underlying crosses the limiting upper barrier, the
    option has a value of zero. The pricing algorithm and its implementation are thus
    almost identical, but with the difference that the upper boundary condition will
    now set the value to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Barrier options are useful in finance because their premium is smaller than
    those of standard European options. They are cheaper to the investor, because
    he/she is taking the risk of not exercising it if the level of the underlying
    is too high (up-and-out barriers) or too low (down-and-out barriers).
  prefs: []
  type: TYPE_NORMAL
- en: We consider the same example as we did earlier, but with a barrier *B = 1.5*
    EUR/USD. The premium for this option under these conditions is 4.11 EUR/USD with
    an execution time of 2.22 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming code snippets implement the algorithm from the Bento Box template.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code 14 – FX2_main.cpp (FDM FX barrier option)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Code 15 – FX2_source.cpp (FDM FX barrier option)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the advanced example (FX2), you need to compile and run code snippets
    14 and 15 plus the previous 11, 12, and 13; afterwards, you should obtain the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced example – FX barrier option (FX2)](img/00200.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Advanced example (FX2): FX up-and-out barrier call screenshot with results'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have solved two pricing problems in forex derivatives. We
    have seen a basic example and a more complex one (plain vanilla) and an advanced
    example (exotic) including a barrier option. For each, we have provided the complete
    C++ implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We will now proceed to the next asset class and interest rate derivatives.
  prefs: []
  type: TYPE_NORMAL
