- en: Chapter 6. Replace new with Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we have removed all `global` calls in our classes, they are likely
    to retain other hidden dependencies. In particular, we are probably creating new
    object instances in inappropriate locations, tightly coupling the classes together.
    These things make it much harder to write tests and to see what the internal dependencies
    are.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After converting the `global` calls in a hypothetical *ItemsGateway* class,
    we might have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two dependency injection issues here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the class probably got converted from a function that used `global $db_host`,
    `$db_user`, `$db_pass` and then constructed a `Db` object internally. Our initial
    pass at removing `global` calls got rid of the globals, but it left this `Db`
    dependency in place. This is what we will call a one-time creation dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, the `selectAll()` method creates new `Item` objects, and as such is
    dependent on the `Item` class. We cannot see this dependency from the outside
    of the class. This is what we will call a repeated creation dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As far as I know, the terms one-time creation dependency and repeated creation
    dependency are not industry-standard terms. They are for the purposes of this
    book only. Please inform the author if you are aware of similar concepts that
    have industry-standard terms.
  prefs: []
  type: TYPE_NORMAL
- en: The point of dependency injection is to push the dependencies in from the outside,
    thereby revealing the dependencies in our classes. Using a `new` keyword inside
    a class is in opposition to that idea, so we need to work through the codebase
    to remove that keyword from our non-`Factory` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What is a Factory Object?**'
  prefs: []
  type: TYPE_NORMAL
- en: One of the keys to dependency injection is that an object may either create
    other objects, *or* it may operate on other objects, *but not both*. Any time
    we need to create an object inside another object, we let that work be done by
    something called a *Factory* with a `newInstance()` method and inject that *Factory*
    into the object that needs to do creation. The `new` keyword is restricted to
    being used inside *Factory* objects. This allows us to switch out *Factory* objects
    any time we need to create different kinds of objects.
  prefs: []
  type: TYPE_NORMAL
- en: The replacement process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step, then, is to remove all use of `new` keyword from our non-*Factory*
    classes, and inject the necessary dependencies instead. We will also use *Factory*
    objects as needed to deal with repeated creation dependencies. This is the general
    process we will follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Find a class with the `new` keyword in it. If the class is already a `Factory`,
    we can ignore it and move on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each one-time creation in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract each instantiation to a constructor parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the constructor parameter to a property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove any constructor parameters and class properties that are used only for
    the `new` call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each repeated creation in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract each block of creation code to a new `Factory` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a constructor parameter for each `Factory` and assign it to a property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the previous creation logic in the class to use the *Factory*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change all instantiation calls for the modified class throughout the project
    so that the necessary dependency objects are passed to the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spot check, commit, push, and notify QA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat with the next `new` call that is not inside a *Factory* object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find a new keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in other steps, we begin this one by using our project-wide search facility
    to look for the `new` keyword in our class files using the following regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two kinds of creation to look for: one-time and repeated. How can we
    tell the difference? In general:'
  prefs: []
  type: TYPE_NORMAL
- en: If the instantiation is assigned to a property, and is never changed, it is
    most likely a one-time creation. Generally, we see this in constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the instantiation occurs in a non-constructor method, it is most likely a
    repeated creation, because it occurs each time the method is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract One-Time creation to dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we find the *ItemsGateway* class listed above when we search for
    the `new` keyword, and encounter the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On examining the class, we find that `$this->db` is assigned once as a property.
    This appears to be a one-time creation. In addition, it appears that at least
    some of the existing constructor parameters are used only for the `Db` instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We proceed to remove the instantiation call entirely, along with the properties
    used only for the instantiation call, and replace the constructor parameters with
    a single Db parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Extract repeated creation to factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we find a repeated creation instead of a one-time creation, we have a different
    task to accomplish. Let's return to the *ItemsGateway* class, but this time we'll
    look at the `selectAll()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can see here that the `new` keyword occurs in a loop inside a method. This
    is clearly a case of repeated creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we extract the creation code to its own new class. Because the code
    creates an `Item` object, we will call the class *ItemFactory*. In it, we will
    create a method for returning new instances of `Item` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The only purpose of a *Factory* is to create new objects. It should not have
    any other functionality. It will be tempting to place other behavior in a `Factory`
    in a bid to centralize common logic. Resist this temptation!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have extracted the creation code to a separate class, we will modify
    the *ItemsGateway* to take an *ItemFactory* parameter, retain it in a property,
    and use the *ItemFactory* to create *Item* objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Change instantiation calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we have changed the constructor signature, all the existing instantiations
    of *ItemsGateway* are now broken. We need to find all the places in the code where
    the *ItemsGateway* class is instantiated, and change the instantiations to pass
    a properly-constructed `Db` object and an *ItemFactory*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we use our project-wide search facility to search using a regular
    expression for our changed class name:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Doing so will give us a list of all instantiations in the project. We need to
    review each result and change it by hand to instantiate the dependencies and pass
    them to the *ItemsGateway*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a page script from the search results looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to change it to something more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Do this for each instantiation of the changed class.
  prefs: []
  type: TYPE_NORMAL
- en: Spot Check, Commit, Push, Notify QA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have changed the class and the instantiations of the class throughout
    the codebase, we need to make sure our legacy application works. Again, we have
    no formal testing process in place, so we need to run or otherwise invoke the
    parts of the application that use the changed class and look for errors.
  prefs: []
  type: TYPE_NORMAL
- en: Once we feel sure that the application still operates properly, we commit the
    code, push it to our central repository, and notify QA that we are ready for them
    to test our new additions.
  prefs: []
  type: TYPE_NORMAL
- en: Do ... While
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Search for the next `new` keyword in a class, and start the process all over
    again. When we find that `new` keywords exist only in *Factory* classes, our job
    is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Common Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What About Exceptions and SPL Classes?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we concentrate on removing all use of the `new` keyword, except
    inside *Factory* objects. I believe there are two reasonable exceptions to this
    rule: *Exception* classes themselves, and certain built-in PHP classes, such as
    the SPL classes.'
  prefs: []
  type: TYPE_NORMAL
- en: It would be perfectly consistent with the process described in this chapter
    to create an `ExceptionFactory` class, inject it into objects that throw exceptions,
    and then use the `ExceptionFactory` to create the `Exception` objects to be thrown.
    This strikes even me as going a bit too far. I think that `Exception` objects
    are a reasonable exception to the rule of no `new` outside `Factory` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, I think built-in PHP classes are also frequently an exception to
    the rule. While it would be nice to have, say, an *ArrayObjectFactory* or an *ArrayIteratorFactory*
    to create *ArrayObject* and *ArrayIterator* classes that are provided by SPL itself,
    it may be a little too much. Creating these kinds of objects directly inside the
    objects that use them is usually all right.
  prefs: []
  type: TYPE_NORMAL
- en: However, we need to be careful. Creating a complex or otherwise powerful object
    like a `PDO` connection directly inside the class that needs it is probably overstepping
    our bounds. It's tough to describe a good rule of thumb here; when in doubt, err
    on the side of dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: What about Intermediary Dependencies?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometime we will discover classes that have dependencies, and the dependencies
    themselves have dependencies. These intermediary dependencies are passed to the
    outside class, which carries them along only so that the internal objects can
    be instantiated with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we have a `Service` class that needs an *ItemsGateway*, which
    itself needs a `Db` connection. Before removing `global` variables, the `Service`
    class might have looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After removing `global` variables, we are left with a `new` keyword, but we
    still need the `Db` object as a dependency for *ItemsGateway*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How do we successfully remove the `new` keyword here? The *ItemsGateway* needs
    a `Db` connection. The `Db` connection is never used by the `Service` directly;
    it is used only for building the *ItemsGateway*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution in cases like this is to inject a fully-constructed *ItemsGateway*.
    First, we modify the `Service` class to receive its real dependency, the *ItemsGateway*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Second, throughout the entire legacy application, we change all instantiations
    of the *Service* to pass an *ItemsGateway*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a page script might have done this when using `global` variables
    everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we changed it to inject the intermediary dependency after removing
    globals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'But we should finally change it to inject the real dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Isn't this a lot of code?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I sometimes hear the complaint that using dependency injection means a lot of
    extra code to do the same thing as before.
  prefs: []
  type: TYPE_NORMAL
- en: It's true. Having a call like this, where the class manages its own dependencies
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is obviously less code than using dependency injection by creating the
    dependencies and using `Factory` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'With dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The real issue here, though, is not more code. The issues are more testable,more
    clear, and more decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: In looking at the first example, how can we tell what *ItemsGateway* needs to
    operate? What other parts of the system will it affect? It's very difficult to
    tell without examining the entire class and looking for `global` and `new` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: In looking at the second example, it is very easy to tell what the class needs
    to operate, what we can expect it to create, and what parts of the system it interacts
    with. These things additionally make it easier to test the class later.
  prefs: []
  type: TYPE_NORMAL
- en: Should a factory create collections?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the examples above, our `Factory` class only creates a single `newInstance()`
    of an object. If we regularly create collections of objects, it may be reasonable
    to add a `newCollection()` method to our `Factory`. For example, given our *ItemFactory*
    above, we may do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We may go so far as to create an `ItemCollection` class for the collection instead
    of using an array. If so, it would be reasonable to use a `new` keyword inside
    our `ItemFactory` to create the `ItemCollection` instance. (The `ItemCollection`
    class is omitted here).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, we may wish to have a separate *ItemCollectionFactory*, using an injected
    *ItemFactory* to create Item objects, with its own `newInstance()` method to return
    a new *ItemCollection*.
  prefs: []
  type: TYPE_NORMAL
- en: There are many variations on the proper use of `Factory` objects. The key is
    to keep object creation (and related operations) separate from object manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Can we automate all these Injections?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the dependency injection we have been doing so far has been manual injection,
    where we create the dependencies ourselves and then inject them as we create the
    objects we need. This can be a tedious process. Who wants to create a `Db` object
    over and over again just so it can be injected into a variety of `Gateway` classes?
    Isn't there some way to automate that?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, there is. It is called a `Container`. A `Container` may go by various synonyms
    indicating how it is to be used. A Dependency Injection `Container` is intended
    to be used always-and-only outside the non-`Factory` classes, whereas an identical
    `Container` implementation going by the name `Service Locator` is intended to
    be used `inside` non-`Factory` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a `Container` brings distinct advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create shared services that are instantiated only when they are called.
    For example, the `Container` can house a `Db` instance that only gets created
    when we ask the `Container` for a database connection; the connection is created
    once and then reused over and over again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can put complex object creation inside the `Container`, where objects that
    need multiple services for their constructor parameters can retrieve those services
    from the `Container` inside their own creation logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But using a `Container` has disadvantages as well:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to drastically change how we think about our object creation, and where
    those objects live in the application. In the end this is a good thing, but it
    can be trouble in the interim.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Container` used as a Service Locator replaces our `global` variables with
    a fancy new toy that has many of the same problems as `global`. The `Container`
    hides dependencies because it is called only from inside the class that needs
    dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this stage of modernizing our legacy application it can be very tempting
    to start using a `Container` to automate dependency injection for use. I suggest
    that we do not add one just now, because so much of our legacy application remains
    to be modernized. We will add one eventually, but it will be as the very last
    step of our modernization process.
  prefs: []
  type: TYPE_NORMAL
- en: Review and next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now made great strides in modernizing our application. Removing `global`
    and `new` keywords in favor of dependency injections has already improved the
    quality of the codebase and made tracking down bugs a lot easier, if only because
    modifying a variable over here no longer causes a variable over there to be affected
    at a distance. Our page scripts might be somewhat longer, because we have to create
    the dependencies, but we can now see exactly what parts of the system we are interacting
    with much more clearly.
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to examine our newly refactored classes and start writing tests
    for them. That way, when we start making changes to the classes, we will know
    if we broke any previously existing behavior.
  prefs: []
  type: TYPE_NORMAL
