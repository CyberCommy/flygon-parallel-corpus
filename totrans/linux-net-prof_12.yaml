- en: '*Chapter 9*: RADIUS Services for Linux'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll cover **Remote Authentication Dial-In User Service**
    (**RADIUS**), one of the main methods of authenticating services over a network.
    We'll implement FreeRADIUS on our server, link it to a backend **Lightweight Directory
    Access Protocol** (**LDAP**)/**Secure LDAP** (**LDAPS**) directory, and use it
    to authenticate access to various services on the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: RADIUS basics—what is RADIUS and how does it work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing RADIUS with local Linux authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RADIUS with LDAP/LDAPS backend authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlang—the unlanguage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RADIUS use-case scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Google Authenticator for **multi-factor authentication** (**MFA**) with
    RADIUS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples in this section, we'll use our existing Ubuntu host or
    **virtual machine** (**VM**). We'll be touching on some wireless topics in this
    chapter, so if you don't have a wireless card in your host or VM, you'll want
    a Wi-Fi adapter to work through those examples.
  prefs: []
  type: TYPE_NORMAL
- en: As we work through the various examples, we'll be editing several configuration
    files. If not specifically referenced, the configuration files for `freeradius`
    are all held within the `/etc/freeradius/3.0/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: For the packages we're installing that aren't included by default in Ubuntu,
    be sure that you have a working internet connection so that you can use the `apt`
    commands for installation.
  prefs: []
  type: TYPE_NORMAL
- en: RADIUS basics – what is RADIUS and how does it work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, let's review a key concept—AAA. **AAA** is a common industry
    term that stands for **authentication**, **authorization**, and **accounting**—three
    key concepts for controlling access to resources.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is whatever is required to prove your identity. In many cases,
    this involves just a user **identifier** (**ID**) and a password, but we will
    explore more complex methods using MFA in this chapter as well.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization generally happens after authentication. Once you have proven your
    identity, various systems will use that identity information to work out what
    you have access to. This may mean which subnets, hosts, and services you have
    access to, or might involve which files or directories you can access. In regular
    language, authentication and authorization are often used interchangeably, but
    when discussing RADIUS and system access, they are quite different.
  prefs: []
  type: TYPE_NORMAL
- en: Accounting is a bit of a throwback to dial-up days. When people were using dial-up
    modems to access corporate systems or the internet, they took up valuable resources
    during their session (namely, the receiving modem and circuit), so RADIUS was
    used to track their session times and durations for their monthly invoice. In
    more modern times, RADIUS accounting is still used to track session times and
    durations, but this information is now more for troubleshooting, or sometimes
    for forensics purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The primary use of RADIUS these days is for authentication, with accounting
    usually also being configured. Authorization is often done by other backend systems,
    though RADIUS can be used to assign a network-based **access-control list** (**ACL**)
    to each authentication session, which is one form of authorization.
  prefs: []
  type: TYPE_NORMAL
- en: With that background covered, let's discuss RADIUS in more detail. The **RADIUS**
    authentication protocol is extremely simple, which makes it attractive for many
    different use cases, and so is supported by almost all devices and services that
    might require authentication. Let's go through a configuration as well as a typical
    authentication exchange (at a high level).
  prefs: []
  type: TYPE_NORMAL
- en: First, let's discuss a device that needs authentication, called a **network
    access server** (**NAS**) in this context. A NAS can be a **virtual private network**
    (**VPN**) device, a wireless controller or access point, or a switch—really, any
    device a user might access that requires authentication. A NAS is defined in the
    RADIUS server, usually by an **Internet Protocol** (**IP**) address, with an associated
    "shared secret" to allow for authentication of the device.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the device is configured to use RADIUS for authentication. If this is
    for administrative access, local authentication will often be left in place as
    a fallback method—so, if RADIUS isn't available, local authentication will still
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it for the device (NAS) configuration. When a client attempts to connect
    to the NAS, the NAS collects the login information and forwards it to the RADIUS
    server for verification (see *Figure 9.1* for a typical RADIUS request packet
    as captured in Wireshark). Things to notice in the packet include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The port used for RADIUS requests is `1812/udp`. The matching port for RADIUS
    accounting is `1813/udp`—accounting tracks connection times and so on, and is
    historically used for billing. There is an older style set of ports (`1645` and
    `1646/udp`) that is still fully supported on many RADIUS servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Code` field is used to identify the packet type—in this example, we''ll
    cover `Access-Request` (code `1`), `Accept` (code `2`), and `Reject` (code `3`).
    The full list of RADIUS codes includes the following ones:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Table 9.1 – RADIUS codes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_09_Table_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.1 – RADIUS codes
  prefs: []
  type: TYPE_NORMAL
- en: The `Packet ID` field is what is used to tie together the request and the response
    packet. Since RADIUS is a **User Datagram Protocol** (**UDP**) protocol, there's
    no concept of a session at the protocol level—this has to be in the payload of
    the packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Authenticator` field is unique to each packet and is supposed to be randomly
    generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remainder of the packet consists of `AVP` in the packet. This makes the
    protocol extensible; both the NAS and the RADIUS server can add AV pairs as circumstances
    dictate. There are several AV pairs commonly supported in all implementations,
    as well as several vendor-specific AV pairs that are usually tied to the NAS vendor
    and specific situations—for instance, to differentiate between administrative
    access to a device and user access to a VPN or wireless **service set ID** (**SSID**).
    We'll cover this in more depth as we explore some use cases later in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following simple example, our two attributes are the `User-Name` AV
    pair, which is in clear text, and the `User-Password` AV pair, which is labeled
    as `Encrypted` but is, in fact, an MD5 hashed value (where `Request Authenticator`
    value. The **Request for Comments** (**RFC**) (*RFC 2865*—see the *Further reading*
    section) has a full explanation of how this is computed if you are interested
    in further details on this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Simple RADIUS request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_09_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Simple RADIUS request
  prefs: []
  type: TYPE_NORMAL
- en: 'The response is usually much simpler, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: It's normally either a code 2 `Accept` (*Figure 9.2*) or a code 3 `Reject` (*Figure
    9.3*) response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The packet ID is the same as in the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The response authenticator is computed from the response packet code (2 in
    this case), the length of the response (20 bytes in this case), the packet ID
    (2), the Request Authenticator, and the shared secret. Other AV pairs in the reply
    will also be used in computing this value. The key thing for this field is that
    the NAS will use it to authenticate that the response is coming from the RADIUS
    server it is expecting it from. This first packet example shows an `Access-Accept`
    response, where the access request is granted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Simple RADIUS response (Access-Accept)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_09_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Simple RADIUS response (Access-Accept)
  prefs: []
  type: TYPE_NORMAL
- en: 'This second response packet example shows an `Access-Reject` packet. All fields
    remain the same, except that the access request has been rejected. If there are
    no configuration errors, this result is usually seen when either the username
    or password values are incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Simple RADIUS response (Access-Reject)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_09_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Simple RADIUS response (Access-Reject)
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how a simple RADIUS request works, let's start building our RADIUS
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing RADIUS with local Linux authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example shows the simplest RADIUS configuration, where the `UserID` and
    `Password` values are all locally defined in a configuration file. This is not
    recommended for any production environment for several reasons, detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The passwords are stored as clear-text strings, so in the event of a compromise,
    all RADIUS passwords can be collected by a malicious actor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The passwords are entered by the administrator rather than the user. This means
    that the key security concept of "non-repudiation" is lost—if an event is tied
    to such an account, the affected user can always say "the administrator also knows
    my password—it must have been them."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also related to the administrator-entered password—the user cannot change their
    password, which also means that in most cases, this RADIUS password will be different
    from other passwords that the user uses, making it more difficult to remember.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is, however, a handy way to test an initial RADIUS configuration before we
    complicate it with backend authentication stores and more complex RADIUS exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll install `freeradius`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's edit the `client` configuration, which defines our various NAS devices
    that people will be making authentication requests to. To do this, use `sudo`
    to edit the `/etc/freeradius/3.0/clients.conf` file. As you'd expect, you'll see
    that the RADIUS configuration files cannot be edited or even viewed with normal
    rights, so `sudo` must be used for all access to these.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of this file, we'll add a stanza for each RADIUS client device,
    with its name, IP address, and the shared secret for that device. Note that it's
    a best practice to use a long, random string for this, unique to each device.
    It's easy to write a quick script to generate this for you—see [https://isc.sans.edu/forums/diary/How+do+you+spell+PSK/16643](https://isc.sans.edu/forums/diary/How+do+you+spell+PSK/16643)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we''ve added three switches (each having a name
    that starts with `sw`) and a wireless controller (`VWLC01`, a virtual wireless
    controller). A key concept here is to consistently name devices. It''s a common
    thing that you might need different rules or policies for different device types;
    giving them consistent names by device type is a handy concept that can simplify
    this. Also, something as simple as sorting a list becomes simpler if the device
    name standard is known and consistent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in some situations, you may have to configure entire subnets—in that
    case, the client line might read something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This normally isn't recommended as it opens the RADIUS server to attack from
    anything on that subnet. If at all possible, use fixed IP addresses. In some cases,
    however, you might be forced to use subnets—for instance, if you've got **wireless
    access points** (**WAPs**) authenticating for wireless clients directly to RADIUS,
    with IPs assigned dynamically using **Dynamic Host Configuration Protocol** (**DHCP**).
  prefs: []
  type: TYPE_NORMAL
- en: Note also the `nastype` line—this ties the device to a `dictionary` file that
    contains definitions for common AV pairs for that vendor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create a test user—use `sudo` to edit the `/etc/freeradius/3.0/users`
    file and add a test account, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, restart your service with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, some troubleshooting—to test the syntax of your configuration file, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the authentication operation, verify that your RADIUS server information
    is defined as a RADIUS client (it is by default), then use the `radclient` command
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this testing done, it's recommended that you delete your locally defined
    user—this isn't something you should forget as it could leave this available for
    an attacker later. Let's now expand our configuration to a more typical enterprise
    configuration—we'll add a backend directory based on LDAP.
  prefs: []
  type: TYPE_NORMAL
- en: RADIUS with LDAP/LDAPS backend authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using a backend authentication store such as **LDAP** is useful for many reasons.
    Since this is usually using the same authentication store as regular logins, this
    gives us several advantages, detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Group membership in LDAP can be used to control access to critical accesses
    (such as administrative access).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords are the same for RADIUS access as for standard logins, making them
    easier to remember.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords and password changes are under the user's control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credentials maintenance is in one central location in the event of a user changing
    groups. In particular, if a user leaves the organization, their account is disabled
    in RADIUS as soon as it is disabled in LDAP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The downside of this method is simple: users are horrible at picking good passwords.
    This is why, especially for any interfaces that face the public internet, it''s
    recommended to use MFA (we''ll cover this later in this chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking advantage of this, if access is controlled only by a simple user/password
    exchange, an attacker has a few great options to gain access, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using credential stuffing**: With this method, the attacker collects passwords
    from other compromises (these are freely available), as well as passwords that
    you might expect to see locally or within the company (local sports teams or company
    product names, for instance), or words that might be significant to the target
    account (children''s or spouse''s names, car model, street name, or phone number
    information, for instance). They then try all of these against their targets,
    which they normally collect from either the corporate website or social media
    sites (LinkedIn is a favorite for this). This is amazingly successful because
    people tend to have predictable passwords or use the same password across multiple
    sites, or both. In an organization of any size, the attacker is usually successful
    in this attack, with times typically ranging from a few minutes to a day. This
    is successful enough that it is automated in several malware strains, most notably
    starting with *Mirai* in 2017 (which attacked administrative access to common
    **Internet of Things** (**IoT**) devices), then expanded to include any number
    of derivative strains that use common word lists for password guessing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Brute forcing of credentials**: The same as credential stuffing, but using
    an entire password list against all accounts, as well as trying all combinations
    of characters after those words are exhausted. Really, this is the same as credential
    stuffing, but just "keeps going" after the initial attack. This shows the imbalance
    between the attacker and defender—continuing an attack is essentially free for
    the attacker (or as cheap as the compute time and bandwidth are), so why wouldn''t
    they just keep trying?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring RADIUS for an LDAP authentication store is easy. While we'll cover
    a standard LDAP configuration, it's important to keep in mind that this protocol
    is clear-text, so is a great target for attackers—**LDAPS** (**LDAP over Transport
    Layer Security (TLS)**) is always preferred. Normally, a standard LDAP configuration
    should only be used for testing, before layering on the encryption aspect with
    LDAPS.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's configure our backend directory in RADIUS, using LDAP as the transport
    protocol. In this example, our LDAP directory is Microsoft's **Active Directory**
    (**AD**), but in a Linux-only environment, it's typical to have a Linux LDAP directory
    (using OpenLDAP, for instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the `freeradius-ldap` package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we proceed with implementing LDAPS, you''ll need the public certificate
    of the CA server that is used by your LDAPS server. Collect this file in `/usr/share/ca-certificates/extra`
    directory (you''ll need to create this directory), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy or move the certificates into the new directory, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Tell Ubuntu to add this directory to the `certs listgroups`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You will be prompted to add any new certificates, so be sure to select the one
    you just added. If there are any certificates in the list that you do not expect
    to see, cancel this operation and verify that these are not malicious before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll edit the `/etc/freeradius/3.0/mods-enabled/ldap` file. This file
    won't be here—you can reference the `/etc/freeradius/3.0/mods-available/ldap`
    file as an example if needed, or link to that file directly.
  prefs: []
  type: TYPE_NORMAL
- en: The `server` line in the configuration shown next implies that your RADIUS server
    must be able to resolve that server name using the **Domain Name System** (**DNS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be configuring LDAPS using these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you are forced to configure LDAP rather than LDAPS, the port changes to `389`,
    and of course there is no certificate, so the `tls` section in the `ldap` configuration
    file can be removed or commented out.
  prefs: []
  type: TYPE_NORMAL
- en: The `ldapuser` example user that we used typically doesn't need any exceptional
    access. However, be sure to use a lengthy (>16 characters) random password for
    this account as in most environments, this password is not likely to change frequently
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we direct `authenticate / pap` section of the `/etc/freeradius/3.0/sites-enabled/default`
    file (note that this is a link to the main file in `/etc/freeradius/3.0/sites-available`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, be sure to uncomment the `ldap` line in that same section, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run `freeradius` in the foreground. This will allow us to see message
    processing as it occurs—in particular, any errors that display. This means we
    won''t have to hunt down error logs during this initial set of tests. Here''s
    the code you''ll need for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to debug further, you can run the `freeradius` server as a foreground
    application to display default logging in real time with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when everything is working, restart your RADIUS server to collect
    the configuration changes by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And again, to test a user login from your local machine, execute the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll want to enable LDAP-enabled group support—we''ll see in a later
    section (*RADIUS use-case scenarios*) that we''ll want to use group membership
    in various policies. To do this, we''ll revisit the `ldap` file and add a `group`
    section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this done, one thing we should realize is that LDAP isn't meant so much
    for authentication as for authorization—it's a great method to check group membership,
    for instance. In fact, if you noticed as we were building, this was specifically
    called out in the configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Let's fix this situation, and use **NT LAN Manager** (**NTLM**), one of the
    underlying AD protocols for authentication, instead.
  prefs: []
  type: TYPE_NORMAL
- en: NTLM authentication (AD) – introducing CHAP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linking RADIUS back to AD for account information and group membership is by
    far the most common configuration that we see in most organizations. While Microsoft
    **Network Policy Server** (**NPS**) is free and easily installed on a domain-member
    Windows server, it does not have an easy configuration to link it to a **two-factor
    authentication** (**2FA**) service such as Google Authenticator. This makes a
    Linux-based RADIUS server with AD integration an attractive option for organizations
    requiring MFA that also takes advantage of AD group membership when establishing
    access rights.
  prefs: []
  type: TYPE_NORMAL
- en: 'What does the authentication look like for this method? Let''s look at the
    standard **Challenge-Handshake Authentication Protocol** (**CHAP**), **Microsoft
    CHAP** (**MS-CHAP**) or MS-CHAPv2, which adds password-change capabilities to
    the RADIUS exchange. A basic CHAP exchange looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Basic CHAP exchange'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_09_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Basic CHAP exchange
  prefs: []
  type: TYPE_NORMAL
- en: 'Going through the preceding exchange in sequence, we can note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the client sends the initial **Hello**, which includes the **USERID**
    (but not the password).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **CHAP Challenge** is sent from the NAS. This is the result of a random
    number and the RADIUS secret key, which is then hashed using MD5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client (**Supplicant**) uses that value to hash the password, then sends
    that value in the response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NAS sends that random number and the response value to the RADIUS server,
    which performs its own calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the two values match, then the session gets a **RADIUS Access-Accept** response;
    if not, then it gets a **RADIUS Access-Reject** response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Protected Extensible Authentication Protocol** (**PEAP**) adds one more
    wrinkle to this exchange – there is a TLS exchange between the client and the
    RADIUS server, which allows the client to verify the identity of the server, as
    well as encrypt the exchange of data using standard TLS. For this, the RADIUS
    server needs a certificate, and the clients need the issuing CA in their store
    of trusted CAs.
  prefs: []
  type: TYPE_NORMAL
- en: To configure AD integration (using PEAP MS-CHAPv2) for FreeRADIUS, we'll configure
    `ntlm_auth` for authentication, and move LDAP as-is to the `authorize` section
    of the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start things rolling with `ntlm_auth`, we''ll need to install `samba` (a
    play on **SMB**, which stands for **Server Message Block**). First, make sure
    that it isn''t already installed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From this listing, we see that it''s not installed in our VM, so let''s add
    it to our configuration with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `/etc/samba/smb.conf`, and update the lines shown in the following code
    snippet for your domain (our test domain is shown). Be sure to use `sudo` when
    you edit—you''ll need root rights to modify this file (note that the `[homes]`
    line is likely commented out by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll edit the `krb5.conf` file. The example file is in `/usr/share/samba/setup`—copy
    that file to `/etc` and edit that copy. Note that the `EXAMPLE.COM` entries are
    there by default, and in most installations, these should be removed (`example.com`
    is a reserved domain for examples and documentation). The code is illustrated
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `/etc/nsswitch.conf` file and add the `winbind` keyword, as shown
    in the following code snippet. Note that the `automount` line isn''t there by
    default in Ubuntu 20, so you may wish to add that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Things should be partially configured for you now—restart your Linux host,
    then verify that the following two services are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '`smbd` provides the file- and printer-sharing services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmbd` provides the NetBIOS-to-IP-address name service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, you can join your Linux host to the AD domain (you''ll be prompted
    for the password), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the `smbd` and `windbind` daemons, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the status with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, for more detail, you could run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to list users and groups in the Windows domain, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If this doesn''t work, the first place to look for the answer is likely the
    DNS. Remember the age-old proverb, phrased here as a haiku:'
  prefs: []
  type: TYPE_NORMAL
- en: '*It''s not DNS*'
  prefs: []
  type: TYPE_NORMAL
- en: '*There is no way it''s DNS*'
  prefs: []
  type: TYPE_NORMAL
- en: '*It was DNS*'
  prefs: []
  type: TYPE_NORMAL
- en: This is so funny because it's true. If the DNS configuration isn't perfect,
    then all kinds of other things don't work as expected. In order to get this to
    all work, your Linux station will need to resolve records on the Windows DNS server.
    The easiest way to make that happen is to have your station's DNS server setting
    point to that IP (refer to [*Chapter 2*](B16336_02_Final_NM_ePub.xhtml#_idTextAnchor035),
    *Basic Linux Network Configuration and Operations – Working with Local Interfaces*,
    if you need a refresh on the `nmcli` command). Alternatively, you could set up
    a conditional forwarder on your Linux DNS server, or add a secondary zone of the
    AD DNS on your Linux host—there are several alternatives available, depending
    on which service you need to be "primary" in your situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test DNS resolution, try to ping your domain controller by name. If that
    works, try to look up some **service** (**SRV**) records (which are part of the
    underpinnings of AD)—for instance, you could look at this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, verify that you can authenticate to AD using `wbinfo`, then again using
    the `ntlm_auth` command (which RADIUS uses), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that plain text passwords failed for the `wbinfo` login attempt—this (of
    course) is the desired situation.
  prefs: []
  type: TYPE_NORMAL
- en: With our connection to the domain working, we're now set to get to work on the
    RADIUS configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is to update the `/etc/freeradius/3.0/mods-available/mschap`
    file, to configure a setting to fix an issue in the challenge/response handshake.
    Your `mschap` file needs to contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if you scroll down in the file, you''ll see a line starting with `ntlm_auth
    ="`. You''ll want that line to read like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are doing machine authentication, you might need to change the `username`
    parameter to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to enable PEAP, we go to the `mods-available/eap` file and update the
    `default_eap_type` line, and change that method from `md5` to `peap`. Then, in
    the `tls-config tls-common` section, update the `random_file` line from the default
    value of `${certdir}/random` to now display as `random_file = /dev/urandom`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When completed, you want the changes to the `eap` file to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This finishes the typical server-side configuration for PEAP authentication.
  prefs: []
  type: TYPE_NORMAL
- en: On the client (supplicant) side, we simply enable CHAP or PEAP authentication.
    In this configuration, the station sends the user ID or machine name as the authenticating
    account, along with a hashed version of the user's or workstation's password.
    On the server side, this hash is compared to its own set of calculations. The
    password never gets transmitted in the clear; however, the "challenge" that the
    server sends is sent as an extra step.
  prefs: []
  type: TYPE_NORMAL
- en: On the NAS device (for instance, a VPN gateway or wireless system), we enable
    `MS-CHAP` authentication, or `MS-CHAPv2` (which adds the capability for password
    changes over RADIUS).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll see things get a bit more complex; what if you want to use RADIUS
    for multiple things—for instance, to control VPN access and admin access to that
    VPN server at the same time, using the same RADIUS servers? Let's explore how
    we can set up rules using the *U**nlang* language to do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: Unlang – the unlanguage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FreeRADIUS supports a simple processing language called **Unlang** (short for
    **unlanguage**). This allows us to make rules that add additional controls to
    the RADIUS authentication flow and final decision.
  prefs: []
  type: TYPE_NORMAL
- en: Unlang syntax is generally found in the virtual server files—in our case, that
    would be `/etc/freeradius/3.0/sites-enabled/default`, and can be in the sections
    titled `authorize`, `authenticate`, `post-auth`, `preacct`, `accounting`, `pre-proxy`,
    `post-proxy`, and `session`.
  prefs: []
  type: TYPE_NORMAL
- en: In most common deploys, we might look for an incoming RADIUS variable or AV
    pair—for instance, `Service-Type`, which might be `Administrative` or `Authenticate-Only`,
    and in the Unlang code, match that up with a check against group membership—for
    instance, network admins, VPN users, or wireless users.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the simple case of the two firewall login requirements (`VPN-Only` or `Administrative`
    access), you might have a rule like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can add further to this example, knowing that if a user is VPNing in, `Called-Station-ID`
    will be the external IP address of the firewall, whereas an administrative login
    request will be to the inside IP or management IP (depending on your configuration).
  prefs: []
  type: TYPE_NORMAL
- en: If a large number of devices are in play, a `switch/case` construct can come
    in handy to simplify a never-ending list of `if/else-if` statements. You can also
    use `all switches` with (for instance) `NAS-Identifier =~ /SW*/`.
  prefs: []
  type: TYPE_NORMAL
- en: If authenticating for wireless access, the `NAS-Port-Type` setting will be `Wireless-802.11`,
    and for an 802.1x wired access request, the `NAS-Port-Type` setting will be `Ethernet`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also include different authentication criteria per wireless SSID, as
    the SSID is typically in the `Called-Station-SSID` variable, in the format `<Mac
    Address of the AP>:SSIDNAME`, with `-` characters to delimit the `58-97-bd-bc-3e-c0:WLCORP`.
    So, to just return the MAC address, you would match on the last six characters—so,
    something such as `.\.WLCORP$`.
  prefs: []
  type: TYPE_NORMAL
- en: In a typical corporate environment, we might have two to three SSIDs for various
    access levels, administrative users to different network device types, users with
    VPN access or access to a specific SSID—you can see how this coding exercise can
    become very complex very quickly. It's recommended that changes to your `unlang`
    syntax be first tested in a small test environment (perhaps with virtual network
    devices), then deployed and given production testing during scheduled outage/test
    maintenance windows.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the bits and pieces built, let's configure some real-world
    devices for various authentication requirements.
  prefs: []
  type: TYPE_NORMAL
- en: RADIUS use-case scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at several device types and the various authentication
    options and requirements those devices might have, and explore how we can address
    them all using RADIUS. Let's start with a VPN gateway, using standard user ID
    and password authentication (don't worry—we won't leave it like that).
  prefs: []
  type: TYPE_NORMAL
- en: VPN authentication using user ID and password
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authentication to VPN services (or, before that, dial-up services) is what most
    organizations put RADIUS in for in the first place. As time has marched on, however,
    a single-factor user ID and password login is no longer a safe option for any
    public-facing service. We'll discuss this in this section, but we'll update it
    to a more modern approach when we get to our section on MFA.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add your VPN gateway (usually your firewall) as a client for RADIUS—add
    it to your `/etc/freeradius/3.0/clients.conf` file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, configure your firewall to point to RADIUS for VPN user authentication.
    For a Cisco **Adaptive Security Appliance** (**ASA**) firewall, for instance,
    you would make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update the tunnel-group to use the `RADIUS` server group for authentication,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now that this is working, let's add `RADIUS` as the authentication method for
    administrative access to this same box.
  prefs: []
  type: TYPE_NORMAL
- en: Administrative access to network devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next thing we'll want to layer in is administrative access to that same
    firewall. How do we do this for administrators, but somehow prevent regular VPN
    users from accessing administrative functions? Easy—we'll take advantage of some
    additional AV pairs (remember we discussed those earlier in the chapter?).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding a new network policy with the following credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: For VPN users, we'll add an AV pair for `Service-Type`, with a value of `Authenticate
    Only`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For administrative users, we'll add an AV pair for `Service-Type`, with a value
    of `Administrative`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the RADIUS side, the policy will require group membership for each policy,
    so we'll create groups called `VPN Users` and `Network Administrators` in the
    backend authentication store and populate them appropriately. Note that when this
    is all put together, admins will have VPN access and admin access, but people
    with regular VPN accounts will only have VPN access.
  prefs: []
  type: TYPE_NORMAL
- en: To get the actual rule syntax for this, we'll go back to the previous section
    on Unlang and use that example, which does exactly what we need. If you are requesting
    administrative access, you need to be in the `Network Admins` group, and if you
    need VPN access, you need to be in the `VPN Users` group. If the access and group
    membership don't align, then you are denied access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that RADIUS is set up, let''s direct administrative access to the **graphical
    user interface** (**GUI**) and **Secure Shell** (**SSH**) interfaces to RADIUS
    for authentication. On the firewall, add the following changes to the ASA firewall
    configuration we discussed in the VPN illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is an "authentication list" for each login method. We're using
    RADIUS first, but if that fails (for instance, if the RADIUS server is down or
    not reachable), authentication to local accounts will fail. Also, note that we
    have RADIUS in the list for `enable` mode. This means that we no longer need to
    have a single, shared enable password that all administrators must use. Finally,
    the `aaa authentication log-history` command means that when you enter `enable`
    mode, the firewall will inject your username into the RADIUS request, so you'll
    only need to type your password when entering `enable` mode.
  prefs: []
  type: TYPE_NORMAL
- en: If we did not have the `unlang` rule in place, just the preceding configuration
    would allow regular access VPN users to request and obtain administrative access.
    Once you have RADIUS controlling multiple accesses on one device, it's imperative
    that you have rules written to keep them straight.
  prefs: []
  type: TYPE_NORMAL
- en: With our firewall configured, let's take a look at administrative access to
    our routers and switches.
  prefs: []
  type: TYPE_NORMAL
- en: Administrative access to routers and switches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll start with a Cisco router or switch configuration. This configuration
    will vary slightly between platforms or **Internetwork Operating System** (**IOS**)
    versions, but should look very similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A **Hewlett-Packard** (**HP**) ProCurve equivalent configuration would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that when entering `enable` mode, the HP switch will want a full authentication
    (user ID and password) a second time, not just the password, as you might expect.,
  prefs: []
  type: TYPE_NORMAL
- en: 'At the RADIUS server, administrative access requests from the Cisco and HP
    switches will include the same AV pair we saw for administrative access to the
    firewall: `Service-type: Administrative`. You will likely pair this with a requirement
    for group membership in RADIUS, as we did for the firewall.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have RADIUS controlling admin access to our switches, let's expand
    our RADIUS control to include more secure methods of authentication. Let's start
    this by exploring EAP-TLS (where **EAP** stands for **Extensible Authentication
    Protocol**), which uses certificates for mutual authentication exchange between
    the client and the RADIUS server.
  prefs: []
  type: TYPE_NORMAL
- en: RADIUS configuration for EAP-TLS authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start this section, let's discuss what EAP-TLS really is. **EAP** is a method
    of extending RADIUS past its traditional user ID/password exchange. We're familiar
    with TLS from [*Chapter 8*](B16336_08_Final_NM_ePub.xhtml#_idTextAnchor133), *Certificate
    Services on Linux*. So, stated simply, EAP-TLS is the use of certificates to prove
    identity and provide authentication services within RADIUS.
  prefs: []
  type: TYPE_NORMAL
- en: In most "regular company" use cases, EAP-TLS is paired with a second protocol
    called 802.1x, which is used to control access to the network—for instance, access
    to a wireless SSID or wired Ethernet port. We'll be a while getting there, but
    let's start looking at the nuts and bolts of EAP-TLS, then add in network access.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does this look from a protocol perspective? If you review the *Using
    a certificate – web server* example that we discussed in [*Chapter 8*](B16336_08_Final_NM_ePub.xhtml#_idTextAnchor133),
    *Certificate Services on Linux*, it looks exactly like that, but in both directions.
    Drawing it out (in *Figure 9.5*), we see the same information exchange as we saw
    in the web-server example, but in both directions, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client (or supplicant) sends their identity information to RADIUS, using
    their user or device certificate instead of the user ID and password—this information
    is used by the RADIUS server to verify the identity of the supplicant, and either
    permit or deny access based on that information (and associated rules within RADIUS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meanwhile, the supplicant verifies the identity of the RADIUS server in the
    same way—verifying that the server name matches the **Common Name** (**CN**) in
    the certificate and that the certificate is trusted. This guards against malicious
    RADIUS servers being deployed (for instance, in an "evil twin" wireless attack).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once this mutual authentication is completed, the network connection is completed
    between the supplicant and the network device (NAS)—usually, that device is a
    switch or a WAP (or a wireless controller).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see an illustration of this in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Authentication flow for 802.1x/EAP-TLS session'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_09_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Authentication flow for 802.1x/EAP-TLS session
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: All of this stipulates that all the required certificates are distributed in
    advance. This means that the RADIUS server needs its certificate installed, and
    the supplicants need their device certificate and/or user certificate installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of this, the CA has to be trusted by the devices, the users, and the
    RADIUS server. While all of this can be done using a public CA, it's normally
    done by a private CA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During the authentication process, neither the supplicant nor the RADIUS server
    (of course) communicates with the CA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand how EAP-TLS works conceptually, what does an EAP-TLS
    configuration look like on a wireless controller?
  prefs: []
  type: TYPE_NORMAL
- en: Wireless network authentication using 802.1x/EAP-TLS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EAP-TLS for 802.1x authentication is introduced into many companies as their
    wireless client authentication mechanism, mostly because every other authentication
    method for wireless is subject to one or more simple attacks. EAP-TLS is literally
    the only secure method to authenticate to wireless.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, the configuration on the NAS (the wireless controller, in this
    case) is very simple—the heavy lifting for preparation and configuration is all
    on the RADIUS server and the client station. For a Cisco wireless controller,
    the configuration is normally done primarily through the GUI, though of course,
    a command line is there as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the GUI, EAP-TLS authentication is very simple—we''re just setting up a
    pass-through for the client to authenticate directly to the RADIUS server (and
    vice versa). The steps are outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, define a RADIUS server for authentication. There's an almost identical
    configuration for the same server for RADIUS accounting, using port `1813`. You
    can see a sample configuration in the following screenshot:![Figure 9.6 – Wireless
    controller configuration for RADIUS server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16336_09_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Wireless controller configuration for RADIUS server
  prefs: []
  type: TYPE_NORMAL
- en: Next, under **SSID Definition**, we'll set up the authentication as 802.1x,
    as illustrated in the following screenshot:![Figure 9.7 – Configuring SSID to
    use 802.1x authentication
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16336_09_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – Configuring SSID to use 802.1x authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, under **AAA Servers**, we link the RADIUS server to the **SSID**,
    as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Assigning RADIUS server for 802.1x authentication and accounting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_09_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – Assigning RADIUS server for 802.1x authentication and accounting
  prefs: []
  type: TYPE_NORMAL
- en: To make this all work, both the clients and the RADIUS server need appropriate
    certificates and need to be configured for EAP-TLS authentication. Distributing
    the certificates well in advance is recommended—especially if you are issuing
    certificates using automation, you want to give your client stations enough lead
    time so that they will all have connected up and triggered their certificate issuance
    and installation.
  prefs: []
  type: TYPE_NORMAL
- en: With the wireless network authentication now secured with EAP-TLS, what does
    the analogous configuration look like on a typical workstation switch?
  prefs: []
  type: TYPE_NORMAL
- en: Wired network authentication using 802.1x/EAP-TLS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we'll show the switch-side configuration (Cisco) for 802.1x
    authentication of network devices. In this configuration, the workstations authenticate
    using EAP-TLS, and we tell the switch to "trust" the phones. While this is a common
    configuration, it's easy to circumvent—an attacker can just tell their laptop
    to "tag" its packets (using the `nmcli` command, for instance) as **virtual local-area
    network** (**VLAN**) 105 (the voice VLAN). As long as the switch trusts the device
    to set its own VLAN, this attack is not so hard, though getting all the parameters
    "just perfect" to continue an attack from there can take some effort. For this
    reason, it's by far preferred to have both PCs and phones authenticate, but this
    requires an additional setup—the phones need device certificates to complete this
    recommended configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get on with our example switch configuration. First, we define the RADIUS
    servers and group (this should look familiar from the section on administrative
    access).
  prefs: []
  type: TYPE_NORMAL
- en: 'The switch configuration to allow 802.1x includes several global commands,
    setting up the RADIUS servers and the RADIUS group, and linking 802.1x authentication
    back to the RADIUS configuration. These commands are illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Next, we configure the switch ports. A typical switch port, with 802.1x authentication
    for the workstation on VLAN 101, using workstation and/or user certificates (previously
    issued) and no authentication for **Voice over IP** (**VOIP**) phones (on VLAN
    105). Note that as we discussed, the authentication is mutual—the workstations
    authenticate the RADIUS server as valid in the same exchange that the RADIUS server
    authenticates the workstation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.2 – Interface configuration for switch 802.1x/EAP-TLS configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_09_Table_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.2 – Interface configuration for switch 802.1x/EAP-TLS configuration
  prefs: []
  type: TYPE_NORMAL
- en: To force the VOIP phones to also authenticate using 802.1x and certificates,
    remove the `trust device cisco-phone` line. There is some political risk in this
    change—if a person's PC can't authenticate and they can't call the Helpdesk because
    their phone is out, that immediately raises the "temperature" of the entire troubleshooting
    and solution process, even if they can call the Helpdesk using their cellphone.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's backtrack a bit and add MFA, in the form of Google Authenticator.
    This is normally used when a user ID and password might be the legacy solution.
    For instance, this is a great solution for protecting VPN authentication from
    things such as password-stuffing attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Using Google Authenticator for MFA with RADIUS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed, a 2FA authentication scheme is the best option for accessing public-facing
    services, especially any services facing the public internet, whereas in days
    gone by, you might have configured a simple user ID and password for authentication.
    With the ongoing **Short Message Service** (**SMS**) compromises, we see it illustrated
    in the press why SMS messages are a poor choice for 2FA—it's lucky that tools
    such as Google Authenticator can be configured for this use case at no cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll install a new package that allows authentication to Google Authenticator,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `users` file, we''ll change user authentication to use **pluggable authentication
    modules** (**PAMs**), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Uncomment the `pam` line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to edit the `/etc/pam.d/radiusd` file. Comment out the default
    `include` files, as shown in the following code snippet, and add the lines for
    Google Authenticator. Note that `freeraduser` is a local Linux user ID that will
    be the process owner for this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If your Google Authenticator service is working, then the RADIUS link to it
    should be working now too!
  prefs: []
  type: TYPE_NORMAL
- en: Next, generate the Google Authenticator secret key and supply the **Quick Response**
    (**QR**) code, account recovery information, and other account information to
    the client (this is likely a self-serve implementation in most environments).
  prefs: []
  type: TYPE_NORMAL
- en: Now, when users authenticate to RADIUS (for a VPN, administrative access, or
    whatever, really), they use their regular password and their Google key. In most
    cases, you don't want this overhead for wireless authentication. Certificates
    tend to work best for that—to the point that if your wireless isn't using EAP-TLS
    for authentication, it's susceptible to one or more common attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This concludes our journey into using RADIUS for authentication of various servers.
    As with many of the Linux services we've explored in this book, this chapter just
    scratches the surface of common configurations, use cases, and combinations that
    RADIUS can be used to address.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have the expertise to understand how RADIUS works
    and be able to configure secure RADIUS authentication for VPN services and administrative
    access, as well as wireless and wired network access. You should have the basics
    to understand the PAP, CHAP, LDAP, EAP-TLS, and 802.1x authentication protocols.
    The EAP-TLS use cases, in particular, should illustrate why having an internal
    CA can really help in securing your network infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we touched on integrating Google Authenticator with RADIUS for MFA.
    We didn't cover the detailed configuration of the Google Authenticator service,
    though—this seems to be changing so frequently of late that the Google documentation
    for that service is the best reference.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss using Linux as a load balancer. Load balancers
    have been with us for many years, but in recent years, they are being deployed
    both more frequently and quite differently in both physical and virtual data centers—stay
    tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: For a firewall that you intend to authenticate administrative access and VPN
    access to, how can you allow a regular user VPN access but not administrative
    access?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is EAP-TLS such a good authentication mechanism for wireless networks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IF EAP-TLS is so great, why is MFA preferred over EAP-TLS with certificates
    for VPN access authentication?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic RFCs that were referenced in this chapter are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 2865*: *RADIUS* ([https://tools.ietf.org/html/rfc2865](https://tools.ietf.org/html/rfc2865))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 3579*: *RADIUS Support for EAP* ([https://tools.ietf.org/html/rfc3579](https://tools.ietf.org/html/rfc3579))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 3580*: *IEEE 802.1X RADIUS Usage Guidelines* ([https://tools.ietf.org/html/rfc3580](https://tools.ietf.org/html/rfc3580))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the full list of RFCs for the DNS is sizable. The following list shows
    current RFCs only—obsoleted and experimental RFCs have been removed. These can
    all, of course, be found at [https://tools.ietf.org](https://tools.ietf.org) as
    well as at [https://www.rfc-editor.org:](https://www.rfc-editor.org:)
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 2548*: *Microsoft Vendor-specific RADIUS Attributes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 2607*: *Proxy Chaining and Policy Implementation in Roaming*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 2809*: *Implementation of L2TP Compulsory Tunneling via RADIUS*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 2865*: *Remote Authentication Dial-In User Service (RADIUS)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 2866*: *RADIUS Accounting*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 2867*: *RADIUS Accounting Modifications for Tunnel Protocol Support*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 2868*: *RADIUS Attributes for Tunnel Protocol Support*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 2869*: *RADIUS Extensions*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 2882*: *Network Access Servers Requirements: Extended RADIUS Practices*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 3162*: *RADIUS and IPv6*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 3575*: *IANA Considerations for RADIUS*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 3579*: *RADIUS Support for EAP*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 3580*: *IEEE 802.1X RADIUS Usage Guidelines*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4014*: *RADIUS Attributes Suboption for the DHCP Relay Agent Information
    Option*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4372*: *Chargeable User Identity*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4668*: *RADIUS Authentication Client MIB for IPv6*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4669*: *RADIUS Authentication Server MIB for IPv6*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4670*: *RADIUS Accounting Client MIB for IPv6*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4671*: *RADIUS Accounting Server MIB for IPv6*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4675*: *RADIUS Attributes for Virtual LAN and Priority Support*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4679*: *DSL Forum Vendor-Specific RADIUS Attributes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4818*: *RADIUS Delegated-IPv6-Prefix Attribute*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4849*: *RADIUS Filter Rule Attribute*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 5080*: *Common RADIUS Implementation Issues and Suggested Fixes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 5090*: *RADIUS Extension for Digest Authentication*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 5176*: *Dynamic Authorization Extensions to RADIUS*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 5607*: *RADIUS Authorization for NAS Management*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 5997*: *Use of Status-Server Packets in the RADIUS Protocol*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 6158*: *RADIUS Design Guidelines*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 6218*: *Cisco Vendor-Specific RADIUS Attributes for the Delivery of Keying
    Material*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 6421*: *Crypto-Agility Requirements for Remote Authentication Dial-In
    User Service (RADIUS)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 6911*: *RADIUS Attributes for IPv6 Access Networks*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 6929*: *Remote Authentication Dial-In User Service (RADIUS) Protocol Extensions*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 8044*: *Data Types in RADIUS*'
  prefs: []
  type: TYPE_NORMAL
- en: 'AD/SMB integration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://wiki.freeradius.org/guide/freeradius-active-directory-integration-howto](https://wiki.freeradius.org/guide/freeradius-active-directory-integration-howto)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://web.mit.edu/rhel-doc/5/RHEL-5-manual/Deployment_Guide-en-US/s1-samba-security-modes.html](https://web.mit.edu/rhel-doc/5/RHEL-5-manual/Deployment_Guide-en-US/s1-samba-security-modes.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.samba.org/index.php/Setting_up_Samba_as_a_Domain_Member](https://wiki.samba.org/index.php/Setting_up_Samba_as_a_Domain_Member)'
  prefs: []
  type: TYPE_NORMAL
- en: '802.1x: [https://isc.sans.edu/diary/The+Other+Side+of+Critical +Control+1%3A+802.1x+Wired+Network+Access+Controls/25146](https://isc.sans.edu/diary/The+Other+Side+of+Critical+Control+1%3A+802.1x+Wired+Network+Access+Controls/25146)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unlang references:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://networkradius.com/doc/3.0.10/unlang/home.html](https://networkradius.com/doc/3.0.10/unlang/home.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://freeradius.org/radiusd/man/unlang.txt](https://freeradius.org/radiusd/man/unlang.txt)'
  prefs: []
  type: TYPE_NORMAL
