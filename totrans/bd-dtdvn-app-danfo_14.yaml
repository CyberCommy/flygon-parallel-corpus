- en: '*Chapter 11*: Building a Recommendation System with Danfo.js and TensorFlow.js'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, we introduced you to TensorFlow.js and showed you
    how to create a simple regression model to predict sales prices. In this chapter,
    we'll take this a step further by creating a recommendation system that can recommend
    movies for different users while taking into account a user preference. By the
    end of this chapter, you will understand how recommendation systems work, as well
    as how to build one with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a recommendation system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The neural network approach to creating a recommendation system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a movie recommendation system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern browser such as Chrome, Safari, Opera, or Firefox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js**, **Danfo.js**, TensorFlow.js, and (optionally) **Dnotebook** installed
    on your system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stable internet connection for downloading a dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter is available and can be cloned from GitHub at [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The installation instructions for Danfo.js, TensorFlow.js, and Dnotebook can
    be found in [*Chapter 3*](B17076_03_ePub_RK.xhtml#_idTextAnchor066)*, Getting
    Started with Danfo.js*, [*Chapter 10*](B17076_10_ePub_RK.xhtml#_idTextAnchor180)*,
    Introduction to TensorFlow.js*, and [*Chapter 2*](B17076_02_ePub_RK.xhtml#_idTextAnchor045)*,
    Dnotebook – An Interactive Computing Environment for JavaScript*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: What is a recommendation system?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **recommendation system** is any system that can predict a preference or a
    usefulness score given to an item by a user. Using this preference score, it can
    recommend items to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Items here can be digital products such as movies, music, books, and even clothes.
    The goal of every recommendation system is to be able to recommend items that
    the user will like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recommendation systems are very popular and can be found almost everywhere;
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Movie streaming platforms such as *Netflix*, *Amazon Prime*, *Hulu*, and *Disney+*
    use recommendation systems for recommending movies to you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social media websites such as *Facebook*, *Twitter*, and *Instagram* use recommendation
    systems for recommending friends to connect with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E-commerce websites such as *Amazon* and *AliExpress* use recommendation systems
    for recommending products such as clothes, books, and electronics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendation systems are mostly built using data from user-item interaction.
    Hence, there are three major approaches that are followed when building recommendation
    systems. These are **collaborative filtering**, **content-based filtering**, and
    the **hybrid approach**. We'll briefly explain these approaches in the following
    sub-sections.
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative filtering approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the collaborative filtering approach, the recommendation system is modeled
    based on users'' past behavior or history. That is, this approach leverages existing
    user interactions such as ratings, likes, or reviews for items to model the user''s
    preference, thereby understanding what the user likes. The following diagram shows
    how the collaborative filtering approach helps with building a recommendation
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Collaborative filtering approach to building a recommendation
    system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Collaborative filtering approach to building a recommendation
    system
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, you can see that two users who have seen the same
    movie, and probably rated the same way, are grouped as similar users, since the
    movie that's been seen by the person on the left has been recommended to the person
    on the right. In the content-based filtering approach, the recommendation system
    is modeled based on **item characteristics**. That is, items may be pre-tagged
    with certain characteristics such as category, price, genre, size, and ratings
    received, and using these characteristics, the recommendation system can recommend
    similar items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how the content-based filtering approach to building
    a recommendation system works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Content-based filtering approach to building a recommendation
    system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_11_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Content-based filtering approach to building a recommendation
    system
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, you can observe that movies similar to each other
    get recommended to a user.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid filtering approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hybrid approach, as its name suggests, is a combination of the collaborative
    and content-based filtering approaches. That is, it combines the best of both
    approaches to create an even better recommendation system. The majority of real-world
    recommendation systems today use this approach to mitigate the shortcomings of
    individual approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows one way of combining the content-based filtering
    approach with the collaborative filtering approach to create a hybrid recommendation
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The hybrid approach to building a recommendation system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_11_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – The hybrid approach to building a recommendation system
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, you can see that we have two inputs feeding the hybrid
    system. These inputs go into the collaborative (**CF**) and content-based systems,
    and then the output from these systems gets combined. This combination can be
    customized and can even serve as input to other advanced systems such as neural
    networks. The overall goal here is to create a powerful hybrid system by combining
    multiple recommendation systems.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that any approach that's used in creating a recommendation
    system will need one form of data or the other. For example, in the collaborative
    filtering approach, you will need the *user-item interaction* history, while for
    the content-based approach, you'll need *item metadata*.
  prefs: []
  type: TYPE_NORMAL
- en: If you have enough data to train a recommendation system, you can leverage numerous
    machine and non-machine learning techniques to model the data before making recommendations.
    Some popular algorithms you can use are **K-nearest neighbor** ([https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm)),
    **clustering algorithms** ([https://en.wikipedia.org/wiki/Cluster_analysis](https://en.wikipedia.org/wiki/Cluster_analysis)),
    **decision trees** ([https://en.wikipedia.org/wiki/Decision_trees](https://en.wikipedia.org/wiki/Decision_trees)),
    **Bayesian** **classifiers** ([https://en.wikipedia.org/wiki/Naive_Bayes_classifier](https://en.wikipedia.org/wiki/Naive_Bayes_classifier)),
    and even **artificial neural networks** ([https://en.wikipedia.org/wiki/Artificial_neural_networks](https://en.wikipedia.org/wiki/Artificial_neural_networks)).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll use the **neural network** approach to build a recommendation
    system. We'll explain this in detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The neural network approach to creating a recommendation system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, neural networks have been the Swiss army knife when it comes
    to solving many problems in the field of **machine learning** (**ML**). This is
    evident in areas of ML breakthroughs such as **image classification**/**segmentation**
    and **natural language processing**. With the availability of data, neural networks
    have been successfully used to build large-scale recommendation systems such as
    the ones used at *Netflix* ([https://research.netflix.com/research-area/machine-learning](https://research.netflix.com/research-area/machine-learning))
    and *YouTube* ([https://research.google/pubs/pub45530/](https://research.google/pubs/pub45530/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there are different approaches to building a recommendation system
    with neural networks, they all rely on one major fact: they need an efficient
    way to learn similarities between items or users. In this chapter, we''ll leverage
    a concept called **embeddings** to efficiently learn these similarities so that
    we can easily power our recommendation system.'
  prefs: []
  type: TYPE_NORMAL
- en: But first, what are embeddings and why are we using them? In the next sub-section,
    we'll briefly answer these questions.
  prefs: []
  type: TYPE_NORMAL
- en: What is an embedding?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An embedding is a mapping of discrete variables to continuous or real-valued
    variables. That is, given a set of variables such as `[good, bad]`, an embedding
    can map each discrete item to a continuous vector of *n* dimensions – for example,
    good can be represented as `[0.1, 0.6, 0.1, 0.8]` and bad can be represented as
    `[0.8, 0.2, 0.6, 0.1]`, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Representing discrete categories with real-valued variables'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_11_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Representing discrete categories with real-valued variables
  prefs: []
  type: TYPE_NORMAL
- en: If you're familiar with encoding schemes such as **one-hot encoding** ([https://en.wikipedia.org/wiki/One-hot](https://en.wikipedia.org/wiki/One-hot))
    or **label encoding** ([https://machinelearningmastery.com/one-hot-encoding-for-categorical-data/](https://machinelearningmastery.com/one-hot-encoding-for-categorical-data/)),
    then you might be wondering how embedding is different from them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, there are two major differences and, technically, advantages of embedding:'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding representations can be small or large, depending on the specified
    dimension. This is different from encoding schemes such as one-hot encoding, where
    the dimensionality of the representation increases with the number of discrete
    classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following figure shows how the dimension that''s used by the
    one-hot encoding representation increases with the number of unique countries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Size comparison between embeddings and one-hot encoding'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_11_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – Size comparison between embeddings and one-hot encoding
  prefs: []
  type: TYPE_NORMAL
- en: 'Embeddings can be learned alongside weights in neural networks. This is the
    major advantage over other encoding schemes because, with this property, learned
    embeddings become a similarity cluster of discrete classes, which means that you
    can easily find similar items or users. For example, looking at the following
    proofed, you can see that we have two groups of learned word embeddings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Embedding words and showing similarity in an embedding space
    (Redrawn from: https://medium.com/@hari4om/word-embedding-d816f643140)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_11_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.6 – Embedding words and showing similarity in an embedding space
    (Redrawn from: https://medium.com/@hari4om/word-embedding-d816f643140)'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, you can see that the group depicting **man**, **woman**,
    **king**, and **queen** is being passed through an embedding and that the resulting
    output is an embedding space, where words that are closer in meaning are grouped.
    This is made possible by the learned word *embedding*.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we leverage embeddings to create a recommendation system? Well, as
    we mentioned previously, embeddings can efficiently represent data, which means
    we can use them to learn or represent user-item interaction. As such, we can easily
    use learned embeddings to find similar items to recommend. We can even take this
    further by combining an embedding with a supervised machine learning task.
  prefs: []
  type: TYPE_NORMAL
- en: This approach of combining a learned embedding representation with a supervised
    ML task is what we'll do in the next section to create our movie recommendation
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Building a movie recommendation system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build a movie recommendation system, we need some kind of user-movie interaction
    dataset. Fortunately, we can use the `MovieLens 100k` dataset ([https://grouplens.org/datasets/movielens/100k/](https://grouplens.org/datasets/movielens/100k/))
    provided by **Grouplens** ([https://grouplens.org/](https://grouplens.org/)).
    This data contains 100,000 movie ratings given by 1,000 users on 1,700 movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the first few rows of the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – The first few rows of the MovieLens dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_11_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.7 – The first few rows of the MovieLens dataset
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding screenshot, you can see that we have `user_id`, `item_id`
    (movies), and the rating the user gave to the item (movie). With just this interaction
    and the use of embeddings, we can efficiently model the behavior of users and,
    as such, learn what kind of movies they like.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how we''ll build and learn this interaction with embeddings and
    a neural network, please refer to the following architecture diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – High-level architecture of our recommendation system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_11_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.8 – High-level architecture of our recommendation system
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding diagram, you can see that we have two embedding layers, one
    for the users and the other for the items (movies). These two embedding layers
    are then combined before being passed to a dense layer.
  prefs: []
  type: TYPE_NORMAL
- en: So, in essence, we are combining embeddings with a supervised learning task,
    where the output from the embeddings gets passed to a dense layer to predict ratings
    a user will give an item (movie).
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering, if we are learning to predict ratings a user will give
    a product, how does this help us make recommendations? Well, the trick is that
    if we can efficiently predict the rating a user will give a movie, then, using
    the learned similarity embedding, we can predict the rating the user will give
    to all movies. Then, with this information, we can recommend the movies with the
    highest predicted ratings to the user.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we build this seemingly complicated recommendation system in JavaScript?
    Well, in the next sub-section, we'll show you how you can easily use TensorFlow.js,
    combined with Danfo.js, to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your project directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code and the dataset you need to successfully follow this chapter are provided
    in the code repository for this chapter ([https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11)).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the entire project to your computer to easily follow along.
    If you have downloaded the project code, then navigate to your root directory,
    where the `src` folder is visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `src` folder, you have the following folders/scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`book_recommendation_model`: This is the folder where the trained model is
    saved to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: This folder contains our training data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data_proc.js`: This script contains all our data processing code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model.js`: This script defines and compiles the recommendation model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recommend.js`: This script contains code for making recommendations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`train.js`: This script contains code for training the recommendation model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To quickly test the pre-trained recommendation model, first, install all the
    necessary packages using `yarn` (recommended) or `NPM`, and then run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will recommend `10`, `5`, and `20` movies for users with user IDs of `196`,
    `880`, and `13`. If successful, you should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Recommended movies provided by the trained recommendation system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_11_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.9 – Recommended movies provided by the trained recommendation system
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also retrain the model by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command, by default, will retrain the model with a batch size
    of `128`, an epoch size of `5`, and, when done, will save the trained model to
    the `book_recommender_model` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have set up the project locally, we'll work through each section
    and explain how to build the recommendation system from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving and processing the training dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dataset we're using was retrieved from the Grouplens website. By default,
    the movies data (`https://files.grouplens.org/datasets/movielens/ml-100k.zip`)
    is a ZIP file containing tab-separated files. For the sake of simplicity, I have
    downloaded and converted the two files you'll need for this project into `CSV`
    format. You can get these files from the `data` folder in this project's code
    repository ([https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11/src/data](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11/src/data)).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`movieinfo.csv`: This file contains metadata about each movie, such as its
    title, description, and links.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`movielens.csv`: This is the user ratings dataset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use the `movielens` dataset, we must read the dataset with Danfo.js, process
    it, and then convert it into a tensor that we can pass to our neural network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your project''s code, open the `data_proc.js` script. This script exports
    one main function called `processData` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what are we doing in the preceding code? Well, thankfully, we do not need
    much data pre-processing because the `user_id`, `item_id`, and `ratings` columns
    are already in numeric form. So, we are simply doing two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the maximum IDs from the item and user columns. This number, called
    the **vocabulary size**, will be passed to the embedding layer when creating our
    model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving and returning the underlying tensors of the user, item, and rating
    columns. The user and item tensors will serve as our training input, while the
    rating tensors will become our supervised learning target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know how to process the data, let's start building the neural network
    using TensorFlow.js.
  prefs: []
  type: TYPE_NORMAL
- en: Building the recommendation model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete code for our recommendation model can be found in the `model.js`
    file. This model uses a hybrid approach, as we saw in the high-level architecture
    diagram (see *Figure 11.8*).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are using the Model API we introduced in [*Chapter 10*](B17076_10_ePub_RK.xhtml#_idTextAnchor180)*,
    Introduction to TensorFlow.js*, to create the network. This is because we are
    creating a complex architecture and we need more control in terms of inputs and
    outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following steps, we will explain the model and show the corresponding
    code for creating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user` and the other from the items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the input has a shape parameter set to `1`. This is because our
    input tensors are vectors with a dimension of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '`InputDim`: This is the vocabulary size of the embedding vector. The maximum
    integer index is `+ 1`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b) `OutputDim`: This is a user-specified output dimension. That is, it is used
    to configure the size of the embedding vector.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll merge these embedding layers.
  prefs: []
  type: TYPE_NORMAL
- en: '`dot` product, flattening the output, and passing the output to a dense layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding output, we can now define our model using the Models API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will define and compile the model, as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the Models API to define the inputs and output, and
    then calls the compile method, which accepts a training optimizer (Adam optimizer)
    and a loss function (mean squared error). You can view the full model code in
    the `model.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: With the model architecture defined, we can start training the model.
  prefs: []
  type: TYPE_NORMAL
- en: Training and saving the recommendation model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The training code for the model can be found in the `train.js` file. This code
    has two main sections. We'll look at both here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first section, shown in the following code block, trains the model using
    a batch size of `128`, an epoch size of `5`, and a validation split of `0.1`-`10`%
    for the training data, which is reserved for model validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding training code, we printed the loss after each training epoch.
    This helps us track training progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block saves the trained model to the file path provided.
    In our case, we are saving it to the `movie_recommendation_model` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Take note of this folder's name as we'll be using it when we make recommendations
    in the next sub-section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To train the model, you can run the following command in the `src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can directly run `train.js` with `node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start model training for the specified number of epochs and, once
    done, save the model to the specified folder. Once the training is complete, you
    should have an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Training logs of the recommendation model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_11_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.10 – Training logs of the recommendation model
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a trained and saved model, you can start making movie recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Making movie recommendations with the saved model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `recommend.js` file contains the code for making recommendations. We have
    also included a utility function called `getMovieDetails`. This function maps
    a movie ID to the movie metadata so that we can display useful information, such
    as the name of a movie.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we make recommendations? Well, since we have trained our model to
    predict the ratings a user will give a set of movies, we can simply pass a user
    ID and all the movies to the model to make ratings predictions.
  prefs: []
  type: TYPE_NORMAL
- en: With the ratings predictions for all movies, we can simply sort them in descending
    order and then return the top movies as recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must get all the unique movie IDs to predict for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must construct a user tensor that''s the same length as the movie
    ID tensor. The tensor will have the same user ID across all entries because for
    each movie, we are predicting the rating the same user will give:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must load the model and call the `predict` function by passing the
    movie and user tensors as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will return a tensor of predicted ratings the user will give to each movie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must construct a DataFrame with two columns called `movie_id` (unique
    movie IDs) and `ratings` (predicted ratings given by the user to each movie):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Storing the predicted ratings and the corresponding movie ID in a DataFrame
    helps us easily sort the ratings, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must pass the array of sorted movie IDs to the `getMovieDetails`
    utility function. This function will map each movie ID to the corresponding metadata
    and return a DataFrame with two columns (movie title and movie release date),
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `recommend.js` script in the `src` folder contains the full code for making
    recommendations, including the utility function for mapping a movie ID to its
    metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test a recommendation, you need to call the `recommend` function and pass
    a movie ID and the number of recommendations you want, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives us the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! You have successfully created a recommendation system using neural
    network embeddings, which can efficiently recommend movies to different users.
    Using the concepts you've learned about in this chapter, you can easily create
    different recommendation systems that can recommend different products, such as
    music, books, and videos.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we successfully built a recommendation system that can recommend
    movies to users based on their preferences. First, we defined what a recommendation
    model is before briefly talking about the three approaches to designing a recommendation
    system. Then, we talked about neural network embeddings and why we decided to
    use them to create our recommendation model. Finally, we put together all the
    concepts we've learned about by building a movie recommendation model that can
    recommend the specified number of movies to a user.
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge you've gained in this chapter, you can easily create a recommendation
    system that can be embedded in your JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, you'll build another hands-on application using
    Danfo.js and the **Twitter API**.
  prefs: []
  type: TYPE_NORMAL
