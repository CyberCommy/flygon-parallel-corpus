- en: End-to-End System Testing
  prefs: []
  type: TYPE_NORMAL
- en: '**End-to-end** (**E2E**) system testing is the automated testing of a system
    in its entirety. As a programmer, the unit tests for your piece of code are just
    a small factor in the bigger picture of the whole system. So in this chapter,
    we will be looking at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing E2E testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding and testing factories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding and testing dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing modularization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have gained the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: Be able to define E2E testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to perform E2E testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to explain what factories are and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to understand what dependency injection is and how to use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to understand what modularization is and how to utilize it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E2E testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you've finished your project and all the unit tests pass. However, your
    project is a part of a larger system. This larger system will need to be tested
    to make sure that your code, and the other code it interfaces with, both work
    together as expected. Code tested in isolation can break when integrated into
    larger systems, and existing systems can break with the addition of new code,
    so it is important to perform E2E testing, also known as **integration testing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integration testing is responsible for testing the complete program flow from
    beginning to end. Integration testing usually starts at the *requirements gathering
    stage*. You start by gathering and documenting the various requirements of the
    system. You then design all the components and devise tests for each subsystem,
    and then the E2E tests for the whole system. Then, you write your code according
    to the requirements and implement your own unit tests. Once your code is complete
    and the tests all pass, then the code is integrated into the overall system within
    the test environment and the E2E tests are executed. Often, E2E tests are carried
    out manually, although where possible, they can be automated as well. The following
    diagram shows a system that comprises two subsystems with modules and a database.
    In E2E testing, all these modules will be tested either manually, using automation,
    or by both methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/226c6b2d-d997-46de-af9f-aeee7cfe2acb.png)'
  prefs: []
  type: TYPE_IMG
- en: The input to and output from each system are the main focus of the tests. You
    have to ask yourself, *is the correct information passed in and passed out of
    each system?*
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, there are three things to consider when building your E2E tests:'
  prefs: []
  type: TYPE_NORMAL
- en: What *user functions* will there be, and what steps will each function perform?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What *conditions* will there be for each function and each of its steps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the *different scenarios* that we will have to build test cases for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each subsystem will have one or more features that it will provide, and each
    feature will have a number of actions that will be executed in a particular order.
    Those actions will receive inputs and provide outputs. There will also be relationships
    between features and functions that you must identify, after which you will need
    to determine whether the function is *reusable* or *independent*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the scenario of an online testing product. Teachers and students will
    log in to the system. If the teacher logs in, they will be taken to an admin console,
    and if a student logs in, they will be taken to the test menu to carry out one
    or more tests. In this scenario, we effectively have three subsystems:'
  prefs: []
  type: TYPE_NORMAL
- en: The login system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The admin system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two flows of execution in the aforementioned system. We have the admin
    flow and the test flow. Conditions and test cases will have to be established
    for each flow. We will use this very simple assessment system login scenario for
    our E2E example. In the real world, E2E will be more involved than in this chapter.
    The main aim of this chapter is to get you thinking about E2E testing and how
    you can best implement it, so we will keep things as simple as we can so that
    complexity does not get in the way of what we are trying to accomplish, which
    is to manually test three modules that must interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of this section is to build three console applications that make up
    the complete system: the login module, the admin module, and the test module.
    Then once they are built, we will go through testing them manually. The diagram
    that follows displays the interaction between systems. We will start with the
    login module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e8a30cd-7ce6-4185-a12d-fb8567a02fa6.png)'
  prefs: []
  type: TYPE_IMG
- en: The login module (subsystem)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first part of our system requires both teachers and students to log in
    to the system using a username and password. The task list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the username.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Cancel (this resets username and password).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the username is invalid, then display an error message on the login page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the user is valid, then do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user is a teacher, load the admin console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user is a student, load the test console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by creating a console application. Call it `CH07_Logon`. In the
    `Program.cs` class, replace the existing code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DoLogin()` method will take the passed-in string and use it for the title.
    Since we will not have logged in yet, the title will be set to `"Welcome to the
    test platform"`. We need to add the `DoLogin()` method. The code for this method
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The previous code accepts a message. The message is used as the title in the
    console window. The user is then prompted to enter their username and password.
    The `ReadPassword()` method reads all inputs and replaces filtered letters with
    an *asterisk* to hide the user's input. The username and password are then validated
    by calling the `ValidateUser()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we must do is add the `ReadPassword()` method as in the code
    that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is really simple. It calls an overloaded method of the same name
    and passes in the password mask character. Let''s implement the overloaded `ReadPassword()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The overloaded `ReadPassword()` method accepts a password mask. This method
    adds each character to the stack. Unless the key being pressed is the *Enter*key,
    the key being pressed is checked to see if the user is performing a *Delete* keypress. If
    the user is performing a *Delete* keypress, then the last character entered is
    removed from the stack. If the character entered is not in the filtered list,
    then it is pushed onto the stack. The password mask is then written to the screen.
    As soon as the *Enter* key is pressed, a blank line is written to the console
    window, and the contents of the stack are reversed, returning it as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final method we need to write for this subsystem is the `ValidateUser()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `ValidateUser()` method checks the username and password. If they validate
    as an admin, then the admin page is loaded. If they validate as a student, then
    the student page is loaded. Otherwise, the console is cleared, the user is informed
    the credentials are wrong, and they are prompted to reenter their credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Upon a successful login operation being performed, the relevant subsystem is
    loaded and the login subsystem then terminates. Now that we have written our login
    module, we will write our admin module.
  prefs: []
  type: TYPE_NORMAL
- en: The admin module (subsystem)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The admin subsystem is where all the system administration is carried out.
    This includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing students
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting students
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding students
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting students
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing students' profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning tests to students
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the administrator password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backing up data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restoring data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erasing all data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this exercise, we will not be implementing any of these features. I will
    leave you to do that as a fun exercise. All we are interested in is that the admin
    module loads on a successful login. If the admin module is loaded without logging
    in, then an error message is displayed. Then when the user presses a key, they
    are taken to the login module. Successful login is accomplished when a user successfully
    logs in as an administrator, and the admin executable is called with the *admin
    argument*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a console application in Visual Studio and call it `CH07_Admin`. Update
    the `Main()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Main()` method checks that the argument count is greater than `0` and
    that the first argument in the array is admin. If it is, then the main screen
    is displayed by calling the `DisplayMainScreen()` method. Otherwise, the `DisplayMainScreenError()`
    method is called that warns the user that they must log in to access the system.
    It''s time to write the `DisplayMainScreen()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `DisplayMainScreen()` method is really simple. It displays
    a title with a message to press any key to exit, then waits for a keypress. Upon
    keypress, the program shells out to the login module and exits. Now, for the `DisplayMainScreenError()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: From this method, you can see that the module was started without logging in.
    This is not permitted. So when the user presses any key, the user is redirected
    to the login module, where they can log in to use the admin module. Our final
    module is the test module. Let's get to work and write it.
  prefs: []
  type: TYPE_NORMAL
- en: The test module (subsystem)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The test system consists of a menu. This menu displays a list of tests the
    student must perform, and also provides the option to exit the test system. The
    functions of this system include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Display a menu of tests to be completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the menu, select an item to start a test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On test completion, save results and return to the menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a test has been completed, remove it from the menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user exits the test module, they are returned to the login module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with the previous module, I will let you have a play and add the aforementioned
    functionality. The main thing we are interested in here is to make sure the test
    module can only be run when the user has logged in. When the module is exited,
    the login module is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test module is more or less a rehash of the admin module, so we will rush
    through this section to get to where we need to be. Update the `Main()` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the `DisplayMainScreen()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, write the `DisplayMainScreenError()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have written all three modules, we will test them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our three-module system using E2E
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to perform a manual E2E test of our three-module
    system. We will test the login module to ensure that it only allows valid logins
    access to either the admin module or the test module. When a valid admin logs
    into the system, they should see the admin module, and the login module should
    be unloaded. When a valid student logs into the system, then they should see the
    test module, and the login module should be unloaded.
  prefs: []
  type: TYPE_NORMAL
- en: If we then try and load the admin module without first logging in, we should
    be warned that we must log in. Pressing any key should unload the admin module
    and load the login module. Trying to use the test module without logging in should
    behave in the same way as the admin module. We should be warned that we can't
    use the test module unless we log in, and pressing any key should load the login
    module and unload the test module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now go through the manual testing process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that all the projects are built, then run the login module. You should
    see the screen that follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bf130dba-087c-448d-a344-89766b0b5d6c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter an incorrect username and/or password, then press *Enter*, and you will
    see the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d7bf0b1f-2f9f-47df-a707-07267376dbb6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, enter `admin` as the username and `letmein` as the password, and then
    press *Enter*. You should see the admin module screen for a successful login:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b6f29856-e562-4997-a448-7302aca8bab3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Press any key to exit, and you should see the login module again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c9cff545-17b8-4ba7-922a-14ce7fb1556e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter `student` as your username and `letmein` as your password. Press *Enter*
    and you should be shown the student module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/537c6f76-cbdb-43e1-b825-baa350993755.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now load the admin module without logging in, and you should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ee22f7c7-a511-4283-973e-984b4a12af8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Pressing any key will take you back to the login module. Now load the test
    module without logging in, and you should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a98b384d-c361-4a1f-8126-c6b10e50f900.png)'
  prefs: []
  type: TYPE_IMG
- en: We have now successfully manually carried out E2E testing of our system that
    consists of three modules. This is by far the best way to run through a system
    when E2E testing. Your unit tests will be very useful in making this stage fairly
    straightforward. By the time you get to this stage, your bugs should have been
    caught and dealt with. But as always, there is always the possibility of problems
    being encountered, which is why it is good to manually run through the system
    as a whole manually. That way, you can visually see through your interactions
    that the system behaves as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Larger systems employ factories and dependency injection. In the following sections
    of this chapter, we will look at them both, starting with factories.
  prefs: []
  type: TYPE_NORMAL
- en: Factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Factories are implemented using the **factory method pattern**. The intent of
    this pattern is to allow the creation of objects without specifying their classes.
    This is accomplished by invoking a factory method. The main goal of a factory
    method is to create an instance of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You use the factory method pattern for the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When the class is unable to anticipate the type of object that must be instantiated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the subclass must specify the type of object to instantiate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the class controls the instantiation of its objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0657bd23-9126-4d8e-8644-5c6b8442814a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the preceding diagram, you have the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Factory`, which provides the interface for the `FactoryMethod()` that returns
    a type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteFactory`, which overrides or implements the `FactoryMethod()` to return
    a concrete type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteObject`, which inherits or implements the base class or interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now is a good time for a demonstration. Imagine that you have three different
    customers. Each customer requires using a different relational database as the
    backend data source. The databases used by your customers will be Oracle Database,
    SQL Server, and MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: As a part of your E2E testing, you will need to test against each of these data
    sources. But how can you write the program once and have it work against any of
    those databases? This is where the `Factory` method pattern comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Either during the installation process or via the initial configuration of your
    application, you can have the user specify the database that they wish to use
    as the data source. This information can be stored in a configuration file as
    an encrypted database connection string. When your application starts up, it will
    read the database connection string and decrypt it. The database connection string
    will then be passed into the factory method. Lastly, an appropriate database connection
    object will be selected, instantiated, and returned for use by your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have some background, let''s create a .NET Framework Console Application
    in Visual Studio and call it `CH07_Factories`. Replace the code in the `App.cong`
    file with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding code has added the `connectionStrings` element
    to the configuration file. Within that element, we clear any existing connection
    strings and then add the three database connection strings we will be using for
    the application. To simplify the contents of this section, we have unencrypted
    connection strings, but in the production environment, make sure that your connection
    strings are encrypted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, we will not be using the `Main()` method in the `Program`
    class. We will start the `Factory` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is our abstract factory with a single abstract `FactoryMethod()`
    that returns a type of `IDatabaseConnection`. Since it does not exist, we''ll
    add that next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this interface, we have a read-only connection string, a method called `OpenConnection()`
    to open a database connection, and a method called `CloseConnection()` to close
    an open database connection. So far, we have our abstract `Factory` and our `IDatababaseConnection`
    interface. Next, we will create our concrete database connection classes. Let''s
    start with the SQL Server database connection class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `SqlServerDbConnection` class fully implements the `IDatabaseConnection`
    interface. The constructor takes `connectionString` as a single parameter. The
    read-only `ConnectionString` property is then assigned to `connectionString`.
    The `OpenConnection()` method only prints to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a real implementation, however, the connection string would be used to connect
    to the valid data source specified in the string. Once a database connection is
    open, it must be *closed*. The closing of the database connection would be carried
    out by the `CloseConnection()` method. Next, we repeat the preceding process for
    the Oracle database connection and the MySQL database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the `OracleDbConnection` class in place. So, the last class we
    need to implement is the `MySqlDbConnection` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we have added our concrete classes. The only thing left to do is
    to create our `ConcreteFactory` class that inherits the abstract `Factory` class.
    You will need to reference the `System.Configuration.ConfigurationManager` NuGet
    packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the class uses the `System.Configuration` namespace. The `ConnectionStringSettings` values
    are stored in the `_connectionStringSettings` member variable. This is set in
    the constructor that takes `connectionStringName`. The name is passed into the
    `GetDbConnectionSettings()` method. The quick among you will see an obvious mistake
    in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The method is getting called but the member variable is not being set. However,
    we will pick up this oversight and fix it when we come to run the tests that we
    have yet to write. The `GetDbConnectionSettings()` methods uses `ConfigurationManager`
    to read the required connection string from the `ConnectionStrings[]` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to complete our `ConcreteClass` by adding `FactoryMethod()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our `FactoryMethod()` returns a concrete class of type `IDatabaseConnection`.
    At the start of the class, the member variable is read and the values are stored
    locally for `providerName` and `connectionString`. A switch is then used to determine
    what type of database connection to build and pass back.
  prefs: []
  type: TYPE_NORMAL
- en: We are now in a position to test our factory to see whether it works with the
    different types of databases used by our customers. This test can be done manually,
    but for the purpose of this exercise, we are going to write automation tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new NUnit test project. Add a reference to the `CH07_Factories` project.
    Then, add the `System.Configuration.ConfigurationManager` NuGet package. Rename
    the class to `UnitTests.cs`. Now, add the first test, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This test is for a SQL Server database connection. It creates a new `ConcreteFactory()` instance
    and passes in the `connectionStringName` value of `"SqlServer"`. The factory then
    instantiates and returns the correct database connection object via `FactoryMethod()`.
    Finally, the connection object is asserted to test that it is indeed an instance
    of type `SqlServerDbConnection`. We need to write the previous test twice more
    for the other database connections, so let''s now add the Oracle database connection
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The test passes in the `connectionStringName` value of `"Oracle"`. An assertion
    is made to test whether the connection object returned is of type `OracleDbConnection`.
    Last of all, we have our MySQL database connection test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The test passes in the `connectionStringName` value of `"MySQL"`. An assertion
    is made to test whether the connection object returned is of type `MySqlDbConnection`.
    If we run our tests now, they will all fail because the `_connectionStringSettings`
    variable is not getting set, so let''s fix this. Modify your `ConcreteFactory`
    constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run all your tests now, they should work. If your connection string
    is not getting picked up by NUnit, then it will be looking in a different `App.config` file
    to what you are expecting. Add the following line before the line that reads the
    connection string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will inform you where NUnit is looking for your connection string settings.
    If the file does not exist, you can create it manually and duplicate the contents
    from your main `App.config` file. But the problem with this is that the file will
    more than likely get deleted upon the next build. So to make the change permanent,
    you can add a post-build event command line to your test project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, right-click on your test project and select Properties. Then on
    the Properties tab, select Build Events. In the post-build event command line,
    add the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the Build Events page of the Project Properties
    dialog with the Post-build event command line in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aaf54bb6-5e8e-4508-97e7-7e2535671d6c.png)'
  prefs: []
  type: TYPE_IMG
- en: This will create the missing file in the test project output folder. The file
    on your system may be named `testhost.x86.dll.config`, since it is on my system.
    Now, your builds should be working.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you change the return type of one of the cases in `FactoryMethod()`, you
    will see that your test fails, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/566d7135-2c34-4582-be80-52b4020ca9c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Change the code back to the correct type so that your code now passes.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to manually E2E test a system, along with how to employ software
    factories, and how we can automatically test whether our factories function as
    expected. Now we will look at dependency injection and how this can be E2E tested.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dependency Injection** (**DI**) helps you to produce code that is loosely
    coupled by separating the code''s behavior from its dependencies, which leads
    to more readable code that is easy to test, extend, and maintain. Code is more
    readable because you follow the single responsibility principle. This also leads
    to much smaller code. Smaller code is easier to maintain and test, and because
    we rely upon abstractions instead of on implementations, we can extend the code
    more easily according to our needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the types of DI that you can implement:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property/setter injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Poor man''s DI* is composed without a container. However, the recommended
    and best practice is to use a DI container. In simple terms, a DI container is
    a registration framework that instantiates dependencies and injects them when
    requested.'
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to write our own dependency container, interface, services,
    and client for our DI example. Then we will write our tests for the dependency
    project. Bear in mind that even though tests should be written first, in most
    business situations I have encountered, they are written once the software has
    been written! So in this scenario, we will write our tests after the software
    we want has been coded. This can often happen when you employ multiple teams where
    some utilize TDD and some don't, or you use third-party code for which no tests
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned earlier that E2E is best done manually and that automation is hard,
    but you can automate tests of the system, as well as performing manual testing.
    This is particularly useful if you target multiple data sources.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to have in place is a dependency container. The dependency
    container keeps a register of types and instances. You register types before you
    use them. When it is time to use an instance of an object, you resolve it into
    a variable and inject (pass it) into the constructor, method, or property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class library and call it `CH07_DependencyInjection`. Add a new
    class called `DependencyContainer`, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have two dictionaries that house the types and the instances.
    We also have two methods. One is used to register our types, and the second is
    used to register our instances. Now that we have the code to register and store
    our types and instances, we need a way to resolve them at runtime. Add the following
    code to the `DependencyContainer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is passed in a type. It calls the method to resolve the type and
    returns an instance of that type. So, let''s add that method now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `Resolve()` method checks to see whether the `Instances` dictionary contains
    an instance whose key matches the contract. If it does, then that instance is
    returned. Otherwise, a new instance is created and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need an interface that our services to be injected will implement.
    We''ll call it `IService`. It will have a single method that will return a string,
    and the method will be called `WhoAreYou()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Our services to be injected will implement the aforementioned interface. Our
    first class will be named `ServiceOne`, and the method will return the string
    `"CH07_DependencyInjection.ServiceOne()"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The second service is the same except it is called `ServiceTwo`, and the method
    returns the string `"CH07_DependencyInjection.ServiceTwo()"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependency container, interface, and service classes are now in place.
    Finally, we are going to add the client that will be used as the demonstration
    object that will consume our services via DI. Our class will demonstrate constructor
    injection, property injection, and method injection. Add the following code to
    the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_service` member variable will be used to store our injected service.
    We have a default constructor so that we can test our property and method injection.
    Add the constructor that accepts and sets the `IService` member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add our property to test property injection and constructor injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll add a method that calls `WhoAreYou()` on the injected object. The
    `Service` property allows the `_service` member variable to be set and retrieved.
    Finally, we will add our `GetServiceName()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `GetServiceName()` method is called on the injected instance of the `IService`
    class. This method returns the fully qualified name of the service passed in.
    Now we will write the unit tests to test the functionality. Add a test project
    and reference the dependency project. Call the test project `CH07_DependencyInjection.Tests`
    and rename `UnitTest1` to `UnitTests`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write tests to check that our registration and resolving of instances
    works, and that the correct classes are injected by constructor injection, setter
    injection, and method injection. Our tests will test the injection of `ServiceOne`
    and `ServiceTwo`. Let''s start by writing our `Setup()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `Setup()` method, we register both our implementations of the `IService`
    class, these being `ServiceOne()` and `ServiceTwo()`. Now we will write our two
    test methods to test the dependency container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Both these methods call the `Resolve()` method. The method checks for an instance
    of a type. If an instance exists, it returns it. Otherwise, one is instantiated
    and returned. It''s time to write the constructor injection tests for `serviceOne`
    and `serviceTwo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In both of these constructor test methods, we resolve the relevant service
    from the container registry. Then we pass the service into the constructor. Finally,
    using the get `Service` property, we assert that the service passed in via the
    constructor is an instance of the expected service. Let''s write the test to show
    that the property setter injection works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To test that the setter injection resolves the class we are after, create a
    client using the default constructor, then assign the resolved instance to the
    `Service` property. Next, we assert whether the service is an instance of the
    expected type or not. Finally, for our tests, we just need to test our method
    injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we again resolve our instance. Create a new client using the default constructor
    and assert passing in the resolved instance and that calling the `GetServiceName()`
    method returns the correct identity of the passed-in instance.
  prefs: []
  type: TYPE_NORMAL
- en: Modularization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A system consists of one or more modules. When a system con two or more modules,
    you need to test the interaction between them to make sure they work together
    as expected. Let''s consider the system for an API shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f98ec51-7941-48ce-9cb1-1fe5936d445d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the previous diagram, we have a client that accesses a data
    store in the cloud via an API. The client sends a request to the HTTP server.
    The request is authenticated. Once it has been authenticated, the request is then
    authorized to access the API. The data sent by the client is deserialized and
    then passed on to the business layer. The business layer then performs either
    a read, insert, update, or delete operation on the data store. The data is then
    passed back to the client from the database via the business layer, followed by
    the serialization layer, and then back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have a number of modules that interact with each other.
    We have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Security (Authentication and Authorization) interacting with serialization (Serialization
    and Deserialization)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization interacting with the business layer that contains all the business
    logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Business Logic layer interacting with the data store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we look at these three preceding points, we can see that a number of tests
    can be written to automate the E2E testing process. Many tests are essentially
    unit tests that become incorporated into our suite of integration tests. Let''s
    consider some now. We are able to test the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Correct login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorized access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unauthorized access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deserialization of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database insert
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database delete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see from these tests, they are unit tests over integration tests.
    So, what integration tests could we write? Well, we could write the following
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Send a read request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send an insert request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send an edit request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send a delete request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those four tests could be written using the correct username and password and
    well-formed data requests, and they could also be written for invalid usernames
    or passwords and malformed data requests.
  prefs: []
  type: TYPE_NORMAL
- en: So, you can perform integration testing by using unit tests to test the code
    in each module, then using tests that only test the interaction between two modules
    at a time. You can also write tests that perform a full E2E operation.
  prefs: []
  type: TYPE_NORMAL
- en: But despite being able to test all this with code, the one thing you *must*
    do is run through the system manually to verify that everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: With all these tests completed successfully, you can have the confidence to
    release your code to the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered E2E testing (also known as **integration testing**),
    let's take some time to summarize what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at what E2E testing is. We saw that we can write
    automated tests, but we've also come to understand the importance of manually
    testing the complete application from an end user perspective.
  prefs: []
  type: TYPE_NORMAL
- en: When we looked at factories, we saw an example of their use when it comes to
    database connectivity. We considered a scenario where our app will enable users
    to use a database of their choice. We load in a connection string, and then based
    on that connection string, the relevant database connection object is instantiated
    and returned for use. We saw how we could test our factories for each use case
    for each different database. Factories can be used in a number of different scenarios,
    and now you know what they are, how to use them, and most importantly, you know
    how to test them.
  prefs: []
  type: TYPE_NORMAL
- en: DI enables a single class to work with multiple different implementations of
    an interface. We saw this in action when we wrote our own dependency container.
    The interface we created was implemented by two classes, added to the dependency
    register, and resolved when called upon by the dependency container. We implemented
    unit tests to test the different implementations for constructor injection, property
    injection, and method injection.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at modules. A simple application may consist of a single module,
    but the more an application grows in complexity, the more modules will make up
    that application. As the number of modules grows, so does the opportunity for
    something to go wrong. Therefore, it is very important to test the interaction
    between modules. The modules themselves can be tested using unit tests. The interaction
    between modules can be tested with more involved tests that run through a complete
    scenario from start to finish.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at best practices when working with
    threading and concurrency. But first, let's test your knowledge on the contents
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is E2E testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is another term for E2E testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What methods should we employ during E2E testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are factories, and why do we use them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is DI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we use a dependency container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The book *Dependency Injection in .NET* by Manning will introduce you to .NET
    DI before guiding you through the various DI frameworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
