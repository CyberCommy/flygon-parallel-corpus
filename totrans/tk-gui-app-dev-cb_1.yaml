- en: Getting Started with Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Structuring a Tkinter application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating text entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing text changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating a text entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting numerical values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating selections with radio buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing switches with checkboxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a list of items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling mouse and keyboard events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the main window's icon, title, and size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to its clear syntax and the wide ecosystem of libraries and tools, Python
    has become a popular and general-purpose programming language. From web development
    to **Natural Language Processing** (**NLP**), you can easily find an open source
    library that fits the need of your application domain, and in the last instance,
    you can always use any of the modules included in the Python standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library follows the "batteries-included" philosophy, which means
    that it contains a large collection of utilities: regular expressions, mathematical
    functions, networking, and so on. The standard **Graphical User Interface** (**GUI**)
    package of this library is **Tkinter**, a thin object-oriented layer on top of
    Tcl/Tk.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting from Python 3, the `Tkinter` module was renamed to `tkinter` (with
    a lowercase **t**). It also affects to the `tkinter.ttk` and `tkinter.tix` extensions.
    We will dive into the `tkinter.ttk` module in the last chapter of this book, since
    the `tkinter.tix` module is officially deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore several patterns for some basic classes of
    the `tkinter` module and some methods that are common to all widget subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring a Tkinter application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main advantages of making applications with Tkinter is that it is
    very easy to set up a basic GUI with a script of a few lines. As the programs
    get more complex, it becomes more difficult to separate logically each part, so
    an organized structure will help us to keep our code clean.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will take the following program as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It creates a main window with a button that prints `Hello, Tkinter!` in the
    console each time it is clicked. The button is placed with a padding of 120px
    in the horizontal axis and 30px in the vertical axis. The last statement starts
    the main loop, which processes user events and updates the GUI until the main
    window is destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/0b2f562d-e318-40c4-9a0c-2190012897ce.png)'
  prefs: []
  type: TYPE_IMG
- en: You can execute the program and verify that it is working as expected. However,
    all our variables are defined in the global namespace, and the more widgets you
    add, the more difficult it becomes to reason about the parts where they are used.
  prefs: []
  type: TYPE_NORMAL
- en: Wildcard imports (`from ... import *`) are strongly discouraged in production
    code because they pollute your global namespace—we only used them here to illustrate
    an anti-pattern that can be commonly seen in online examples.
  prefs: []
  type: TYPE_NORMAL
- en: These maintainability issues can be addressed with basic OOP techniques, which
    are considered good practice in all types of Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To improve the modularity of our simple program, we will define a class that
    wraps our global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, each variable is enclosed in a specific scope, including the `command`
    function, which is moved as a separate method.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we replaced the wildcard import with the `import ... as` syntax to have
    better control over our global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we defined our `App` class as a `Tk` subclass, which now is referenced
    via the `tk` namespace. To properly initialize the base class, we will call the
    `__init__` method of the `Tk` class with the built-in `super()` function. This
    corresponds to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a reference to the `App` instance with the `self` variable, so
    we will add all the Button widget as an attribute of our class.
  prefs: []
  type: TYPE_NORMAL
- en: Although it may look overkill for such a simple program, this refactoring will
    help us to reason about each part, the button instantiation is separated from
    the callback that gets executed when it is clicked, and the application bootstrapping
    is moved to the `if __name__ == "__main__"` block, which is a common practice
    in executable Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: We will follow this convention through all the code samples, so you can take
    this template as the starting point of any larger application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We subclassed the `Tk` class in our example, but it is also common to subclass
    other widget classes. We did this to reproduce the same statements that we had
    before we refactored the code.
  prefs: []
  type: TYPE_NORMAL
- en: However, it may be more convenient to subclass `Frame` or `Toplevel` in larger
    programs, such as those with multiple windows. This is because a Tkinter application
    should have only one `Tk` instance, and the system creates one automatically if
    you instantiate a widget before you create the `Tk` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this decision does not affect the structure of our `App` class
    since all widget classes have a `mainloop` method that internally starts the `Tk`
    main loop.
  prefs: []
  type: TYPE_NORMAL
- en: Working with buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Button widgets represent a clickable item of your GUI applications. They typically
    use a text or an image indicating the action that will be performed when clicked.
    Tkinter allows you to easily configure this functionality with some standard options
    of the `Button` widget class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following contains a button with an image that gets disabled when clicked
    and a list of buttons with the different types of available reliefs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this program is to show several configuration options that can
    be used when creating a Button widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the preceding code, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/972eaa5e-75fd-46c8-88be-f6fc9b648bb5.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic way of instantiation of `Button` is using the `text` option to
    set the button label and the command option that references the function to be
    invoked when the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In out example, we also added `PhotoImage` via the `image` option, which takes
    precedence over the *text* string. The `compound` option serves to combine image
    and text in the same button, determining the position where the image is placed.
    It accepts the following constants as valid values: `CENTER`, `BOTTOM`, `LEFT`,
    `RIGHT`, and `TOP`.'
  prefs: []
  type: TYPE_NORMAL
- en: The second row of buttons is created with a list comprehension, using the list
    of `RELIEF` values. The label of each button corresponds to the name of the constant,
    so you can note the difference in the appearance of each button.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used an attribute to keep a reference to our `PhotoImage` instance, even
    though we are not using it outside our `__init__` method. The reason is that images
    are cleared when they are garbage collected, which will happen if we declare it
    as a local variable and the method exists.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, always remember to keep a reference to each `PhotoImage` object
    as long as the window where it is shown is still alive.
  prefs: []
  type: TYPE_NORMAL
- en: Creating text entries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Entry widget represents a text input displayed in a single line. Along with
    the `Label` and `Button` classes, it is one of the most commonly used Tkinter
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example shows how to create a login form with two entry instances for
    the `username` and `password` fields. Each character of `password` is displayed
    as an asterisk to avoid showing it in clear text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Log in` button prints the values in the console, whereas the `Clear` button
    removes the content of both entries and returns the focus to the entry for `username`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/21860bf1-fad4-4dc9-9f33-8b60bc599fbe.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Entry widgets are instantiated using the parent window or frame as the first
    argument and a set of optional keyword arguments to configure additional options.
    We did not specify any options for the entry corresponding to the `username` field.
    To keep the password secret, we specify the `show` argument with the string `"*"`,
    which will display each typed character as an asterisk.
  prefs: []
  type: TYPE_NORMAL
- en: With the `get()` method, we will retrieve the current text as a string. This
    is used in the `print_login` method to show the entries' content in the standard
    output.
  prefs: []
  type: TYPE_NORMAL
- en: The `delete()` method takes two arguments that indicate the range of the characters
    that should be deleted. Keep in mind that the indices start at the position 0,
    and they do not include the character at the end of the range. If only one argument
    is passed, it deletes the character at that position.
  prefs: []
  type: TYPE_NORMAL
- en: In the `clear_form()` method, we delete from index 0 to the constant `END`,
    which means that the whole content is removed. Finally, we set the focus to the
    `username` entry.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The content of an Entry widget can be modified programmatically with the `insert()`
    method, which takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index`: The position to insert the text; note that entry positions are 0-indexed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`: The text to insert'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A common pattern to reset the content of an entry with a default value can
    be achieved with a combination of `delete()` and `insert()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Another pattern is to append the text in the current position of the text cursor.
    Here, you can use the `INSERT` constant instead of having to calculate the numerical
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Like the `Button` class, the `Entry` class also accepts the `relief` and `state`
    options to modify its border style and state. Keep in mind that calls to `delete()`
    and `insert()` are ignored when the state is `"disabled"` or `"readonly"`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Tracing text changes* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Validating a text entry* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing text changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Tk` variables allow your applications to get notified when an input changes
    its value. There are four variable classes in `Tkinter`: `BooleanVar`, `DoubleVar`,
    `IntVar`, and `StringVar`. Each one wraps the value of the corresponding Python
    type, which should match the type of the input widget attached to the variable.'
  prefs: []
  type: TYPE_NORMAL
- en: This feature is particularly useful if you want to automatically update certain
    parts of your application based on the current state of some input widgets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, we will associate a `StringVar` instance to our entry
    with the `textvariable` option; this variable traces write operations with the
    `show_message()` method as callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you type something into the Entry widget, the label updates its text with
    a message composed with the `Tk` variable value. For instance, if you type the
    word `Phara`, the label will show `Hello, Phara!`. If the entry is empty, the
    label will not show any text. To show you how to modify the variable''s content
    programmatically, we added a button that clears the entry when you click on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/93325b8b-dbe1-4415-a4a2-855233a38797.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first lines of our application constructor instantiate `StringVar` and
    attach a callback to the write mode. The valid mode values are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"w"`: Called when the variable is written'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"r"`: Called when the variable is read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"u"` (for *unset*): Called when the variable is deleted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When invoked, the callback function receives three arguments: the internal
    variable name, an empty string (it is used in other types of `Tk` variables),
    and the mode that triggered the operation. By declaring the method with `*args`,
    we make these arguments optional, because we are not using any of these values
    within the callback.'
  prefs: []
  type: TYPE_NORMAL
- en: The `get()` method of `Tk` wrappers returns the current value of the variable,
    and the `set()` method updates its value. They also notify the corresponding observers,
    so both modifying the entry's content through the GUI or clicking on the Clear button will
    trigger the call to the `show_message()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tk variables are optional for `Entry` widgets, but they are necessary for other
    widget classes to work correctly, such as the `Checkbutton` and `Radiobutton`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating selections with radio buttons* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing switches with checkboxes* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating a text entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, text inputs represent fields that follow certain validation rules,
    such as having a maximum length or matching a specific format. Some applications
    allow typing any kind of content into these fields and trigger the validation
    when the whole form is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Under some circumstances, we want to prevent users from typing invalid content
    into a text field. We will take a look at how to implement this behavior using
    the validation options of the Entry widget.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following application shows how to validate an entry using regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you run this script and type a non-alphanumeric character in the Entry widget,
    it will keep the same content and print the error message. This will also happen
    when you try to type more than 10 valid characters since the regular expression
    also limits the content's length.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `validate` option set to `"key"`, we will activate the entry validation
    that gets triggered on any content modification. The value is `"none"` by default,
    which means that there is no validation.
  prefs: []
  type: TYPE_NORMAL
- en: Other possible values are `"focusin"` and `"focusout"`, which validate when
    the widget gets or loses the focus, respectively, or simply `"focus"` to validate
    in both cases. Alternatively, we can use the `"all"` value to validate in all
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: The `validatecommand` function is called each time the validation is triggered,
    and it should return `true` if the new content is valid, and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we need more information to determine whether the content is valid or
    not, we create a Tcl wrapper around our Python function using the `register` method
    of the `Widget` class. Then, you can add the percent substitution for each parameter
    that will be passed to the Python function. Finally, we will group these values
    as a Python tuple. This corresponds to the following line from our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, you can use any of the following substitutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%d`: Type of action; 1 for insertion, 0 for deletion, and -1 otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%i`: Index of the string being inserted or deleted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%P`: Value of the entry if the modification is allowed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%s`: Value of the entry before the modification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%S`: String content that is being inserted or deleted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%v`: The type of validation currently set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%V`: Type of validation that triggered the action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%W`: The name of the Entry widget'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `invalidcommand` option takes a function that is invoked when `validatecommand`
    returns `false`. The same percent substitutions can be applied to this option,
    but in our example, we directly passed the `print_error()` method of our class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Tcl/Tk documentation suggests not mixing the `validatecommand` and the `textvariable`
    options since setting an invalid value to the `Tk` variable will turn off validation.
    The same occurs if the `validatecommand` function do not return a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: In case you are not familiar with the `re` module, you can check out the detailed
    introduction to regular expressions in the official Python documentation at[ https://docs.python.org/3.6/howto/regex.html](https://docs.python.org/3.6/howto/regex.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating text entries* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting numerical values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previous recipes cover how to work with text inputs; we may want to enforce
    some inputs to contain only numerical values. This is the use case for the `Spinbox`
    and `Scale` classes—both widgets allow users to select a numerical value from
    a range or a list of valid options, but there are several differences in the way
    they are displayed and configured.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This program has `Spinbox` and `Scale` for selecting an integer value from
    `0` to `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, for debugging purposes, we added a button that prints
    the value of each widget when you click on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/61eb247c-f98a-4874-a756-96f2985bb7f6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both classes accept the `from_` and `to` options to indicate the range of valid
    values—the trailing underscore is necessary because the `from` option was originally
    defined in Tcl/Tk, but it is a reserved keyword in Python.
  prefs: []
  type: TYPE_NORMAL
- en: A handy functionality of the `Scale` class is the `resolution` option, which
    sets the precision of the rounding. For instance, a resolution of 0.2 will allow
    the user to select the values 0.0, 0.2, 0.4, and so on. The value of this option
    is 1 by default, so the widget rounds all values to the nearest integer.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the value of each widget can be retrieved with the `get()` method.
    An important difference is that `Spinbox` returns the number as a string, whereas
    `Scale` returns an integer value or a float value if the rounding accepts decimal
    values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Spinbox` class has a similar configuration to the Entry widget, such as
    the `textvariable` and `validate` options. You can apply all these patterns to
    spinboxes with the main difference that it restricts to numerical values.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Tracing text changes* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating selections with radio buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the Radiobutton widget, you can let the user select among several options.
    This pattern works well for a relatively small number of mutually exclusive choices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can connect multiple `Radiobutton` instances using a Tkinter variable so
    that when you click on a non-selected option, it will deselect whatever other
    option was previously selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following program, we created three radio buttons for the `Red`, `Green`,
    and `Blue` options. Each time you click on a radio button, it prints the lowercase
    name of the corresponding color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, it will display the application with the Red radio
    button already selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/69c23add-531e-4e7c-ab29-ee12aa28deff.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To avoid repeating the code of the `Radiobutton` initialization, we defined
    a utility method that is called from a list comprehension. We unpacked the values
    of each tuple of the `COLORS` list and then passed these local variables as options
    to `Radiobutton`. Remember to try to not repeat yourself whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Since `StringVar` is shared among all the `Radiobutton` instances, they are
    automatically connected, and we force the user to select only one choice.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We set a default value of `"red"` in our program; however, what would happen
    if we omit this line, and the value of `StringVar` does not match any of the radio
    button values? It will match the default value of the `tristatevalue` option,
    which is the empty string. This causes the widget to display in a special "tri-state"
    or indeterminate mode. Although this option can be modified with the `config()`
    method, a better practice is to set a sensible default value so the variable is
    initialized in a valid state.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing switches with checkboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choices between two alternatives are typically implemented with checkboxes and
    lists of options where each choice is independent from the rest. As we will see
    in the next example, these concepts can be implemented using the Checkbutton widget.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following application shows how to create Checkbutton, which must be connected
    to an `IntVar` variable to be able to inspect the button state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we simply printed the value of the widget each time
    it is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/a667f326-09f7-49c0-bd84-aa4b43f73390.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like the Button widget, the Checkbutton also accepts the `command` and `text`
    options.
  prefs: []
  type: TYPE_NORMAL
- en: With the `onvalue` and `offvalue` options, we can specify the values used when
    the button is on and off. We use an integer variable because these values are
    **1** and **0** by default, respectively; however, you can also set them to any
    other integer values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Checkbuttons, it is also possible to use other variable types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The only restriction is to match `onvalue` and `offvalue` with the type of the
    Tkinter variable; in this case, since `"ON"` and `"OFF"` are strings, the variable
    should be a `StringVar`. Otherwise, the Tcl interpreter will raise an error when
    trying to set the corresponding value of a different type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Tracing text changes* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating selections with radio buttons* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a list of items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Listbox widget contains text items that can be selected by the user with
    the mouse or keyboard. This selection can be individual or multiple, depending
    on the widget configuration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following program creates a list selection with the days of the week. There
    is a button to print the actual selection and a list of buttons to change the
    selection mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can try out changing the mode of selection and printing the selected items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/f8530d3e-efbd-4789-b518-48e43e5de8b5.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We create an empty Listbox object and add all the text items with the `insert()`
    method. The 0 index indicates that the items should be added at the beginning
    of the list. In the following code snippet, we unpacked the `DAYS` list, but individual
    items can be appended at the end with the `END` constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The current selection is retrieved using the `curselection()` method. It returns
    the indices of the selected items to transform them to the corresponding text
    items we called the `get()` method for each index in a comprehension list. Finally,
    the list is printed in the standard output for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the `selectmode` option can be changed programmatically to
    explore the different behaviors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SINGLE`: Single choice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BROWSE`: Single choice that can be moved with the up and down keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MULTIPLE`: Multiple choice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXTENDED`: Multiple choice with ranges that can be selected with the *Shift*
    and *Ctrl* keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the number of text items is large enough, it may be necessary to add a vertical
    scroll bar. You can easily connect it using the `yscrollcommand` option. In our
    example, we can wrap both widgets in a frame to keep the same layout. Remember
    to specify the `fill` option when packing the scroll so that it fills the available
    space in the *y* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, there is a `xscrollcommand` option for the horizontal axis.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating selections with radio buttons* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling mouse and keyboard events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to react to events is one of the most basic but important topics
    in GUI application development since it determines how users can interact with
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing keys of the keyboard and clicking on items with the mouse are some
    common types of events, which are automatically handled in some Tkinter classes.
    For instance, this behavior is already implemented on the `command` option of
    the `Button` widget class, which invokes the specified callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Some events can get triggered without user interaction, such as changing the
    input focus programmatically from one widget to another.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can attach an event binding to a widget using the `bind` method. The following
    example binds some mouse events to a `Frame` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: All events are handled by the `print_event()` method of our class, which prints
    the type of event and the position of the mouse in the console. You can try it
    out by clicking on the green frame with the mouse, and moving it around while
    it starts printing the event messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example contains an Entry widget with a couple of bindings; one
    for the event that gets triggered when the entry gets the focus, and another for
    all the key press events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first message this program will output is the `FocusIn` event when you set
    the focus on the Entry widget. If you try it out, you will see that it will also
    show the events of keys that do not correspond to non-printable characters, such
    as arrow keys or the return key.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `bind` method is defined in the `widget` class and takes three arguments,
    an event `sequence`, a `callback` function, and an optional `add` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `sequence` string uses the `<modifier-type-detail>` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'In first place, modifiers are optional and allow you to specify additional
    combinations to the general type of the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Shift`: When the user presses the *Shift* key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Alt`: When the user presses the *Alt* key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Control`: When the user presses the *Ctrl* key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Lock`: When the user presses the *Shift* lock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Double`: When the event happens twice in quick succession'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Triple`: When the event happens thrice in quick succession'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Event types determine the general type of event:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ButtonPress` or `Button`: Event generated when a mouse button is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ButtonRelease`: Event generated when a mouse button is released'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enter`: Event generated when you move the mouse over a widget'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Leave`: Event generated when the mouse pointer leaves a widget'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FocusIn`: Event generated when the widget gets the input focus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FocusOut`: Event generated when the widget loses the input focus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KeyPress` or `Key`: Event generated when a key is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KeyRelease`: Event generated when a key is released'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Motion`: Event generated when the mouse is moved'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The detail is also optional and serves to indicate the mouse button or key:'
  prefs: []
  type: TYPE_NORMAL
- en: For mouse events, 1 is the left button, 2 is the middle button, and 3 is the
    right button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For keyboard events, it is the key character. Special keys use the key symbol;
    some common examples are return, *Tab*, *Esc*, up, down, right, left, *Backspace*,
    and function keys (from *F1* to *F12*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `callback` function takes an event parameter. For mouse events, it has
    the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x` and `y`: Current mouse position in pixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x_root` and `y_root`: Same as `x` and `y`, but relative to the left-upper
    corner of the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num`: Mouse button number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For keyboard events, it contains these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`char`: Pressed character code as a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keysym`: Pressed key symbol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keycode`: Pressed key code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both cases, the event has the `widget` attribute, referencing the instance
    that generated the event, and `type`, which specifies the event type.
  prefs: []
  type: TYPE_NORMAL
- en: We strongly recommend that you define methods for the `callback` functions since
    you will also have the reference to the class instance, and therefore you can
    easily access each of the `widget` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `add` parameter can be `''`, to replace the `callback` function
    if there was a previous binding, or `'+'` to add the callback and preserve the
    old ones.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the event types described here, there are also other types that may
    be useful in some scenarios, such as the `<Destroy>` event that is generated when
    a widget is destroyed or the `<Configure>` event that is sent when the size or
    position of the widget changes.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the Tcl/Tk documentation for a complete list of event types
    at [https://www.tcl.tk/man/tcl/TkCmd/bind.htm#M7](https://www.tcl.tk/man/tcl/TkCmd/bind.htm#M7).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Structuring a Tkinter application* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the main window's icon, title, and size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Tk` instance differs from normal widgets in the way that it is configured,
    so we will explore some basic methods that allow us to customize how it is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This snippet creates a main window with a custom title and icon. It has 400px
    of width by 200px of height, with a separation of 10px in each axis to the upper-left
    corner of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This program assumes that you have a valid ICO file called `python.ico` in the
    same directory where the script is placed and executed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The methods `title()` and `iconbitmap()` of the `Tk` class are very self-descriptive—the
    first one sets the window title, whereas the second one takes the path to the
    icon that is associated to the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `geometry()` method configures the size of the window with a string that
    follows the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '*{width}x{height}+{offset_x}+{offset_y}*'
  prefs: []
  type: TYPE_NORMAL
- en: In case you add more secondary windows to your application, these methods are
    also available in the `Toplevel` class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to make the application fullscreen, replace the call to the `geometry()`
    method with `self.state("zoomed")`.
  prefs: []
  type: TYPE_NORMAL
