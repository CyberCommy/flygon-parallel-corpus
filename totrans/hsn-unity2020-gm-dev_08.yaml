- en: '*Chapter 8*: Lighting Using the Universal Render Pipeline'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lighting** is a complex topic and there are several possible ways to handle
    it, with each one having its pros and cons. In order to get the best possible
    quality at the best performance, you need to know exactly how your renderer handles
    it, and that is exactly what we are going to do in this chapter. We will discuss
    how lighting is handled in Unity''s **Universal Render Pipeline** (**URP**), as
    well as how to properly configure it to adapt our scene''s mood with proper lighting
    effects.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine the following lighting concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Applying lighting
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying shadows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing lighting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying lighting
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When discussing ways to process lighting in a game, there are two main ways
    we can do so, known as **Forward Rendering** and **Deferred Rendering**. Both
    handle lighting in a different order, with different techniques, requirements,
    pros, and cons. Forward Rendering is usually recommended for performance, while
    Deferred Rendering is usually recommended for quality. The latter is used by the
    **High Definition Render Pipeline** of Unity, the renderer used for high-quality
    graphics in high-end devices. At the time of writing this book, Unity is developing
    a performant version for URP. Also, in Unity, Forward Renderer comes in two flavors:
    **Multi-Pass Forward**, which is used in the built-in renderer (the old Unity
    renderer), and **Single Pass Forward,** which is used in URP. Again, each has
    its pros and cons.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Actually, there are other options available, both official and third-party,
    such as **Vertex Lit**, but for now, we will focus on the three main ones – the
    ones you use 95% of the time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between one or another depends on the kind of game you are creating
    and the target platform you need to run the game on. Your chosen option will change
    a lot due to the way you apply lighting to your scene, so it's crucial you understand
    which system you are dealing with.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will discuss the following Realtime lighting concepts:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Discussing lighting methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring ambient lighting with skyboxes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring lighting in URP
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by comparing the previously mentioned lighting methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Discussing lighting methods
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To recap, we mentioned three main ways of processing lighting:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Forward Rendering (Single Pass)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward Rendering (Multi-Pass)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deferred Rendering
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we look at the differences between each, let''s talk about the things
    they have in common. Those three renderers start drawing the scene by determining
    which objects can be seen by the camera; that is, the ones that fall inside the
    camera''s frustum, and provide a giant pyramid that can be seen when you select
    the camera:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The camera''s frustum showing only the objects that can be seen
    by it'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.01_B14199.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – The camera's frustum showing only the objects that can be seen
    by it
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: After that, Unity will order them from the nearest to the camera to the farthest
    (transparent objects are handled a little bit differently, but let's ignore that
    for now). It's done like this because it's more probable that objects nearer to
    the camera will cover most of the camera, so they will occlude others, preventing
    us from wasting resources calculating pixels for the occluded ones.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, Unity will try to render the objects in that order. This is where
    differences start to arise between lighting methods, so let''s start comparing
    the two Forward Rendering variants. For each object, Single Pass Forward Rendering
    will calculate the object´s appearance, including all the lights that are affecting
    the object, in one shot, or what we call a **Draw Call**. A Draw Call is the exact
    moment when Unity asks the video card to actually render the specified object.
    All the previous work was just preparation for this moment. In the case of the
    Multi-Pass Forward Renderer, by simplifying a little bit of the actual logic,
    Unity will render the object once per light that affects the object. So, if the
    object is being lit by three lights, Unity will render the object three times,
    meaning that three Draw Calls will be issued, and three calls to the GPU will
    be made to execute the rendering process:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Left image, first draw call of a sphere affected by two lights
    in Multi-Pass; middle image, second draw call of the sphere; right image, the
    combination of both Draw Calls'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.02_B14199(Merged).jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Left image, first draw call of a sphere affected by two lights
    in Multi-Pass; middle image, second draw call of the sphere; right image, the
    combination of both Draw Calls
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Now is when you are probably thinking, *"Why should I use Multi-Pass? Single-Pass
    is more performant!"* And yes, you are right! Single-Pass is way more performant
    than Multi-Pass, and here comes the great bit. A Draw Call in a GPU has a limited
    amount of operations that can be executed, so you have a limit to the complexity
    of the Draw Call. Calculating the appearance of an object and all the lights that
    affect it is very complex, and in order to make it fit in just one Draw Call,
    Single Pass executes simplified versions of lighting calculations, meaning less
    lighting quality and features. They also have a limit on how many lights can be
    handled in one shot, which, at the time of writing this book, is eight per object
    (four for low-end devices). This sounds like a small number, but it's usually
    just enough.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other side, Multi-Pass can apply any number of lights you want and can
    execute different logic for each light. Let''s say our object has four lights
    that are affecting it, but there are two lights that are affecting it drastically
    because they are nearer or have higher intensity, while the remaining ones affecting
    the object are just enough to be noticeable. In this scenario, we can render the
    first two lights with higher quality and the remaining ones with cheap calculations
    – no one will be able to tell the difference. In this case, Multi-Pass can calculate
    the first two lights using **Pixel Lighting** and the remaining ones using **Vertex
    Lighting**. The difference is in their names; Pixel calculates light per object''s
    pixel, while Vertex calculates light per object vertex and fills the pixels between
    these vertexes, thereby interpolating information between vertexes. You can clearly
    see the difference in the following images:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Left image, a sphere being rendered with Vertex Lighting; right
    image, a sphere being rendered with Pixel Lighting)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.03_B14199(Merged).jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Left image, a sphere being rendered with Vertex Lighting; right
    image, a sphere being rendered with Pixel Lighting)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: In Single Pass, calculating everything in a single draw call forces you to use
    Vertex Lighting or Pixel Lighting; you cannot combine them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: So, to summarize the differences between Single and Multi-Pass, in Single Pass,
    you have better performance because each object is just drawn once, but you are
    limited to the number of lights that can be applied, while in Multi-Pass, you
    need to render the object several times, but with no limits on the number of lights,
    and you can specify the exact quality you want for each light. There are other
    things to consider, such as the actual cost of a Draw Call (one Draw Call can
    be more expensive than two simple ones), and special lighting effects such as
    toon shading, but let's keep things simple.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s briefly discuss Deferred. Even though we are not going to use
    it, it''s interesting to know why we are not doing that. After determining which
    objects fall inside the frustum and ordering them, Deferred will render the objects
    without any lighting, generating what is called a **G-Buffer**. A G-Buffer is
    a set of several images that contain different information about the objects of
    the scene, such as the colors of its pixels (without lighting), the direction
    of each pixel (known as **Normals**), and how far from the camera the pixels are.
    You can see a typical example of a G-Buffer in the following figure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Left image, plain colors of the object; middle image,'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: depths of each pixel; right image, normals of the pixels
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.04_B14199(Merged).jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Left image, plain colors of the object; middle image, depths of
    each pixel; right image, normals of the pixels
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Normals are directions, and the (X,Y,Z) components of the directions are encoded
    in the RGB components of the colors.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'After rendering all the objects in the scene, Unity will iterate over all lights
    that can be seen in the camera, thus applying a layer of lighting over the G-Buffer,
    taking information from it to calculate that specific light. After all the lights
    have been processed, you will get the following result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Combination of the three lights that were applied to the G-Buffer
    shown in the previous image'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.05_B14199.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Combination of the three lights that were applied to the G-Buffer
    shown in the previous image
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Deferred part of this method comes from the idea of calculating
    lighting as the last stage of the rendering process. This is better because you
    won't waste resources calculating lighting from objects that could potentially
    be occluded. If the floor of the image is being rendered first in Forward, the
    pixels that the rest of the objects are going to occlude were calculated in vain.
    Also, there's the detail that Deferred just calculates lighting in the exact pixels
    that the light can reach. As an example, if you are using a flashlight, Unity
    will calculate lighting only in the pixels that fall inside the cone of the flashlight.
    The con here is that Deferred is not supported by some relatively old video cards
    and that you can't calculate lighting with Vertex Lighting quality, so you will
    need to pay the price of Pixel Lighting, which is not recommended on low-end devices
    (or even necessary in simple graphics games).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: So, why are we using URP with Single Pass Forward? Because it offers the best
    balance between performance, quality, and simplicity. In this game, we won't be
    using too many lights, so we won't worry about the light number limitations of
    Single Pass, and we won't take advantage of the Deferred benefits too much, so
    it makes no sense to use more hardware to run the game.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a very basic notion of how URP handles lighting, let's start
    using it!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ambient lighting with skyboxes
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different light sources that can affect the scene, such as the sun,
    torches, light bulbs, and more. Those are known as **Direct Lights**; that is,
    objects that emit light rays. Then, we have **Indirect Light**, light that usually
    represents bounces of Direct Lights. However calculating all the bounces of all
    the rays emitted by all the lights is impossible if you want to get a game running
    at least 30 FPS (or simply running). The problem is that not having Indirect Light
    will generate unrealistic results since our current scene lighting, where you
    can observe places where the sunlight doesn''t reach, is completely dark because
    no light is bouncing from other places where light hits:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的光源可以影响场景，如太阳、火炬、灯泡等。这些被称为**直接光**；也就是说，发射光线的物体。然后，我们有**间接光**，通常代表直接光的反射。然而，如果要让游戏以至少30
    FPS（或者只是运行）运行，计算所有光线发射的所有光线的所有反射是不可能的。问题在于没有间接光会产生不真实的结果，因为我们当前的场景照明中，你可以观察到阳光无法到达的地方完全黑暗，因为没有光从其他阳光照射的地方反射过来：
- en: '![Figure 8.6 – Shadows projected on a mountain without ambient lighting'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 – 没有环境光的山上投影的阴影'
- en: '](img/Figure_8.06_B14199.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.06_B14199.jpg)'
- en: Figure 8.6 – Shadows projected on a mountain without ambient lighting
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 没有环境光的山上投影的阴影
- en: To solve this problem, we can use approximations of those bounces. These are
    what we call **ambient light**. This represents a base layer of lighting that
    usually applies a little bit of light based on the color of the sky, but you can
    choose whatever color you want. As an example, on a clear night, we can pick a
    dark blue color to represent the tint from the moonlight.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用这些反弹的近似值。这就是我们所说的**环境光**。这代表了通常根据天空的颜色施加一点点光的基础光照层，但你可以选择任何你想要的颜色。例如，在晴朗的夜晚，我们可以选择深蓝色来代表月光的色调。
- en: 'By default, Unity won''t calculate ambient light from the sky, so we need to
    manually do that doing the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Unity不会从天空计算环境光，因此我们需要手动进行以下操作：
- en: Select the Terrain in the Hierarchy and uncheck Static at the top right part
    of the Inspector. Later we will explain why we did this:![Figure 8.7 – Terrain
    in Hierarchy
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择地形，并在检查器的右上角取消选择“静态”。稍后我们会解释为什么要这样做：![图8.7 – 层次结构中的地形
- en: '](img/Figure_8.07_B14199.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.07_B14199.jpg)'
- en: Figure 8.7 – Terrain in Hierarchy
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 层次结构中的地形
- en: Click on **Window** | **Rendering** | **Lighting Settings**. This will open
    the **Scene Lighting Settings** window:![Figure 8.8 – Lighting Settings location
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**窗口** | **渲染** | **灯光设置**。这将打开**场景灯光设置**窗口：![图8.8 – 灯光设置位置
- en: '](img/Figure_8.08_B14199.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.08_B14199.jpg)'
- en: Figure 8.8 – Lighting Settings location
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 灯光设置位置
- en: Click the **Generate Lighting** button at the bottom of the window. If you haven't
    saved the scene so far, a prompt will ask you to save it, which is necessary:![Figure
    8.9 – Generate Lighting button
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口底部的**生成灯光**按钮。如果到目前为止你还没有保存场景，会提示你保存，这是必要的：![图8.9 – 生成灯光按钮
- en: '](img/Figure_8.09_B14199.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.09_B14199.jpg)'
- en: Figure 8.9 – Generate Lighting button
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 生成灯光按钮
- en: See the bottom-right part of the Unity window to check the progress calculation
    bar to check when the process has finished:![Figure 8.10 – Lighting generation
    progress bar
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看Unity窗口右下角的进度计算栏，以检查进程何时完成：![图8.10 – 灯光生成进度条
- en: '](img/Figure_8.010_B14199.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.010_B14199.jpg)'
- en: Figure 8.10 – Lighting generation progress bar
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 灯光生成进度条
- en: 'You can now see how completely dark areas now have a little effect shown on
    them from the light being emitted by the sky:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以看到完全黑暗的区域现在有了一点光的效果：
- en: '![Figure 8.11 – Shadows with ambient lighting'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11 – 带环境光的阴影'
- en: '](img/Figure_8.011_B14199.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.011_B14199.jpg)'
- en: Figure 8.11 – Shadows with ambient lighting
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 带环境光的阴影
- en: 'Now, by doing this, we have better lighting, but it still looks like a sunny
    day. Remember, we want to have rainy weather. In order to do that, we need to
    change the default sky so that it''s cloudy. You can do that by downloading a
    **skybox**. The current sky you can see around the scene is just a big cube containing
    textures on each side, and those have a special projection to prevent us from
    detecting the edges of the cube. We can download six images for each side of the
    cube and apply them to have whatever sky we want, so let''s do that:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过这样做，我们有了更好的照明，但它看起来仍然像是一个晴天。记住，我们想要有雨天的天气。为了做到这一点，我们需要改变默认的天空，使其多云。你可以通过下载一个**天空盒**来实现。你可以在场景周围看到的当前天空只是一个包含每一面纹理的大立方体，这些纹理具有特殊的投影，以防止我们检测到立方体的边缘。我们可以为立方体的每一面下载六张图像并应用它们，以获得任何我们想要的天空，所以让我们这样做：
- en: You can download skybox textures from wherever you want, but here, I will choose
    the Asset Store. Open it by going to **Window** | **Asset Store** and going to
    the Asset Store website.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以从任何你想要的地方下载天空盒纹理，但在这里，我会选择资产商店。通过**窗口** | **资产商店** 打开它，并转到资产商店网站。
- en: Look for **2D** | **Textures & Materials** | **Sky** in the category list on
    the right. Remember that you need to make that window wider if you can't see the
    category list:![Figure 8.12 – Skybox category
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的类别列表中查找**2D** | **纹理和材质** | **天空**。请记住，如果看不到类别列表，需要扩大窗口宽度：![图8.12 – 天空盒类别
- en: '](img/Figure_8.012_B14199.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.012_B14199.jpg)'
- en: Figure 8.12 – Skybox category
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 天空盒类别
- en: Remember to check the **Free Assets** checkbox in the **Pricing** section:![Figure
    8.13 – Free Assets filtering
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得在**定价**部分勾选**免费资产**复选框：![图8.13 – 免费资产过滤
- en: '](img/Figure_8.013_B14199.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.013_B14199.jpg)'
- en: Figure 8.13 – Free Assets filtering
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 免费资产过滤
- en: Pick any skybox you like for a rainy day. Take into account that there are different
    formats for skyboxes. We are using the six-image format, so check that before
    downloading one. In my case, I have chosen the skybox pack shown in the following
    figure. Download and import it, as we did in [*Chapter 5*](B14199_05_Final_SK_ePub.xhtml#_idTextAnchor085)*,
    Importing and Integrating Assets*:![Figure 8.14 –Selected skybox set for this
    book
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.014_B14199.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 –Selected skybox set for this book
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Create a new material by using the **+** icon in the **Project** window and
    selecting **Material**.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Shader** option of that material to **Skybox/6 sided**. Remember that
    the skybox is just a cube, so we can apply a material to change how it looks.
    The skybox shader is prepared to apply the six textures.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the six textures to the **Front**, **Back**, **Left**, **Right**, **Up**,
    and **Down** properties of the material. The six downloaded textures will have
    descriptive names so that you know which textures go where:![Figure 8.15 – Skybox
    material settings
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.015_B14199.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – Skybox material settings
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Drag the material directly into the sky in the Scene View. Be sure you don't
    drag the material into an object because the material will be applied to it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat *steps 1* to *4* of the ambient light calculation (**Lighting Settings**
    | **Generate Lighting**) to recalculate it based on the new skybox. In the following
    figure, you can see the result of my project so far:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Applied skybox'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.016_B14199.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Applied skybox
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good base layer of lighting, we can start adding light objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Configuring lighting in URP
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have three main types of Direct Lights we can add to our scene:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '**Directional Light**: This is a light that represents the sun. This object
    emits light rays in the direction it is facing, regardless of its position; the
    sun moving 100 meters to the right won''t make a big difference. As an example,
    if you slowly rotate this object, you can generate a day/night cycle:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Directional Light results'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.017_B14199(Merged).jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – Directional Light results
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '**Point Light**: This light represents a light bulb, which emits rays in an
    omnidirectional way. The difference it has on the sun is that its position matters
    because it''s closer. Also, because it''s a weaker light, the intensity of this
    light varies according to the distance, so its effect has a range – the further
    the object from the light, the weaker the received intensity:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Point Light results'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.018_B14199(Merged).jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Point Light results
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Spotlight**: This kind of light represents a light cone, such as the one
    emitted by a flashlight. It behaves similarly to point lights in that its position
    and direction matters, and the light intensity decays over a certain distance:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Spotlight results'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.019_B14199(Merged).jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Spotlight results
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have a nice, rainy, ambient lighting, but the only Direct Light
    we have in the scene, the Directional Light, won''t look like this, so let''s
    change that:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Directional Light** object in the **Hierarchy** window and then
    look at the **Inspector** window.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Colour** property to open the Color Picker.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a dark gray color to achieve sun rays partially occluded by clouds.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set **Shadow Type** to **No Shadows**. Now that we have a cloudy day, the sun
    does not project clear shadows, but we will talk more about shadows in a moment:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Soft directional light with no shadows'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.020_B14199.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – Soft directional light with no shadows
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the scene is darker, we can add some lights to light up the scene,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Create a Spotlight by going to **GameObject** | **Light** | **Spotlight**:![Figure
    8.21 – Creating a Spotlight
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.021_B14199.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Creating a Spotlight
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 创建聚光灯
- en: Select it. Then, in the `90` and `120`, which will increase the angle of the
    cone.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它。然后，在`90`和`120`中，这将增加锥体的角度。
- en: Set `50`, meaning that the light can reach up to 50 meters, decaying along the
    way.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置为`50`，表示光可以达到50米，沿途衰减。
- en: Set `1000`:![Figure 8.22 – Spotlight settings
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置为`1000`：![图8.22 – 聚光灯设置
- en: '](img/Figure_8.022_B14199.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.022_B14199.jpg)'
- en: Figure 8.22 – Spotlight settings
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 聚光灯设置
- en: Position the light at one corner of the base, pointing it at the center:![Figure
    8.23 – Spotlight placement
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光源放在基座的一个角落，指向中心：![图8.23 – 聚光灯放置
- en: '](img/Figure_8.023_B14199.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.023_B14199.jpg)'
- en: Figure 8.23 – Spotlight placement
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – 聚光灯放置
- en: Duplicate that light by selecting it and pressing *Ctrl + D* (*command + D*
    on Mac).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择光源并按下*Ctrl + D*（Mac上为*command + D*）来复制该光源。
- en: 'Put it in the opposite corner of the base:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其放在基座的对角线上：
- en: '![Figure 8.24 –Two Spotlight results](img/Figure_8.024_B14199.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图8.24 – 两个聚光灯的效果](img/Figure_8.024_B14199.jpg)'
- en: Figure 8.24 –Two Spotlight results
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 – 两个聚光灯的效果
- en: You can keep adding lights to the scene but take care that you don't go too
    far – remember the light limits. Also, you can download some light posts to put
    in where the lights are located to visually justify the origin of the light. Now
    that we have achieved proper lighting, we can talk about shadows.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续向场景中添加光源，但要注意不要走得太远——记住光源的限制。此外，你可以下载一些灯柱放在光源位置，以视觉上证明光的来源。现在我们已经实现了适当的照明，我们可以谈论阴影了。
- en: Applying shadows
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用阴影
- en: 'Maybe you are thinking that we already have shadows in the scene, but actually,
    we don''t. The darker areas of the object, the ones that are not facing the lights,
    don''t have shadows – they are not being lit, and that''s quite different from
    a shadow. In this case, we are referring to the shadows that are projected from
    one object to another; for example, the shadow of the player being projected on
    the floor, or from the mountains to other objects. Shadows can increase the quality
    of our scene, but they also cost a lot to calculate, so we have two options: not
    using shadows (recommended for low-end devices such as mobiles) or finding a balance
    between performance and quality according to our game and the target device. In
    the first case, you can skip this whole section, but if you want to achieve performant
    shadows (as much as possible), keep reading.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会认为我们的场景中已经有阴影了，但实际上并没有。物体的较暗区域，也就是不面向光源的区域，没有阴影——它们没有被照亮，这与阴影是完全不同的。在这种情况下，我们指的是从一个物体投射到另一个物体的阴影；例如，玩家在地板上投射的阴影，或者从山上到其他物体的阴影。阴影可以提高我们场景的质量，但计算成本也很高，因此我们有两个选择：不使用阴影（建议用于移动设备等低端设备）或根据我们的游戏和目标设备在性能和质量之间找到平衡。在第一种情况下，你可以跳过整个部分，但如果你想要实现高性能的阴影，尽可能地继续阅读。
- en: 'In this section, we are going to discuss the following topics about shadows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论有关阴影的以下主题：
- en: Understanding shadow calculations
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解阴影计算
- en: Configuring performant shadows
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置高性能阴影
- en: Let's start by discussing how Unity calculates shadows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论Unity如何计算阴影。
- en: Understanding shadow calculations
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解阴影计算
- en: In game development, it is well-known that shadows are costly in terms of performance,
    but why? An object has a shadow when a light ray hits another object before reaching
    it. In that case, no lighting is applied to that pixel from that light. The problem
    here is the same problem we have with the light that ambient lighting simulates
    – it would be too costly to calculate all possible rays and its collisions. So,
    again, we need an approximation, and here is where Shadow Maps kick in.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，众所周知，阴影在性能方面是昂贵的，但为什么呢？当光线射到另一个物体后再到达物体时，物体会产生阴影。在这种情况下，该像素不会受到来自该光源的照明。问题在于，这与环境光模拟的光照存在相同的问题——计算所有可能的光线及其碰撞将成本过高。因此，我们需要一个近似值，这就是阴影贴图发挥作用的地方。
- en: 'A Shadow Map is an image that''s rendered from the point of view of the light,
    but instead of drawing the full scene with all the color and lighting calculations,
    it will render all the objects in grayscale, where black means that the pixel
    is very far from the camera and whiter means that the pixel is nearer to the camera.
    If you think about it, each pixel contains information about where a **ray** of
    the light hits. By knowing the position and orientation of the light, you can
    calculate the position where each "ray" hit using the **Shadow Map**. In the following
    figure, you can see the Shadow Map of our Directional Light:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影贴图是从光的视角渲染的图像，但不是绘制带有所有颜色和光照计算的完整场景，而是以灰度渲染所有物体，其中黑色表示像素距离摄像机很远，白色表示像素距离摄像机较近。如果你仔细想一想，每个像素都包含了光线的碰撞信息。通过了解光的位置和方向，你可以使用阴影贴图计算出每个“光线”碰撞的位置。在下图中，你可以看到我们定向光的阴影贴图：
- en: '![Figure 8.25 – Shadow Map generated by the Directional Light of our scene'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25 – 我们场景中定向光生成的阴影贴图'
- en: '](img/Figure_8.025_B14199.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.025_B14199.jpg)'
- en: Figure 8.25 – Shadow Map generated by the Directional Light of our scene
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 – 我们场景中定向光生成的阴影贴图
- en: Each type of light calculates Shadow Maps slightly differently, especially the
    Point Light. Since it's omnidirectional, it needs to render the scene several
    times in all its directions (front, back, up, down, right, and left) in order
    to gather information about all the rays it emits. We won't talk about this in
    detail here, though, as we could talk about it all day.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的光都会稍微不同地计算阴影贴图，尤其是点光源。由于它是全向的，它需要在所有方向（前、后、上、下、左、右）渲染场景多次，以收集关于它发射的所有光线的信息。不过，我们不会在这里详细讨论这个问题，因为我们可能会谈论一整天。
- en: 'Now, something important to highlight here is that Shadow Maps are textures,
    and hence they have a resolution. The higher the resolution, the more "rays" our
    Shadow Map calculates. You are probably wondering what a low-resolution shadow
    map looks like when it has only a few rays in it. Take a look at the following
    figure to see one:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.26 – Hard Shadow rendered with a low-resolution Shadow Map'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.026_B14199.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.26 – Hard Shadow rendered with a low-resolution Shadow Map
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem here is that having fewer rays generates bigger shadow pixels,
    resulting in a pixelated shadow. Here, we have our first configuration to consider:
    what is the ideal resolution for our shadows? You will be tempted to just increase
    it until the shadows look smooth, but of course, that will increase how long it
    will take to calculate it, so it will impact the performance considerably unless
    your target platform can handle it (mobiles definitely can''t). Here, we can use
    the **Soft Shadows** trick, where we can apply a blurring effect over the shadows
    to hide the pixelated edges, as shown in the following figure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27 – Soft Shadows rendered with a low-resolution Shadow Map](img/Figure_8.027_B14199.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: Figure 8.27 – Soft Shadows rendered with a low-resolution Shadow Map
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the blurry effect is not free, but combining it with low-resolution
    shadow maps, if you accept its blurry result, can generate a nice balance between
    quality and performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, low-resolution Shadow Maps have another problem, which is called **Shadow
    Acne**. This is the lighting error you can see in the following figure:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.28 – Shadow Acne from a low-resolution Shadow Map'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.028_B14199.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.28 – Shadow Acne from a low-resolution Shadow Map
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'A low-resolution shadow map generates false positives because it has fewer
    "rays" calculated. The pixels to be shaded between the rays need to interpolate
    information from the nearest ones. The lower the Shadow Map''s resolution, the
    larger the gap between the rays, which means less precision and more false positives.
    One solution would be to increase the resolution, but again, there will be performance
    issues (as always). We have some clever solutions to this, such as using **depth
    bias**. An example of this can be seen in the following figure:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.29 – A false positive between two far “rays.” The highlighted area
    thinks the ray hit an object before reaching it.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.029_B14199.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.29 – A false positive between two far "rays." The highlighted area
    thinks the ray hit an object before reaching it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of **depth bias** is simple – so simple that it seems like a big
    cheat, and actually, it is, but game development is full of them! To prevent false
    positives, we "push" the rays a little bit further, just enough to make the interpolated
    rays reach the hitting surface:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.30 – Rays with a depth bias to eliminate false positives'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.030_B14199.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.30 – Rays with a depth bias to eliminate false positives
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, as you are probably expecting, they don''t solve this problem easily
    without having a caveat. Pushing depth generates false negatives in other areas,
    as shown in the following figure. It looks like the cube is floating, but actually,
    it is touching the ground – the false negatives generate the illusion that it
    is floating:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.31 – False negatives due to a high depth bias'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.031_B14199.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.31 – False negatives due to a high depth bias
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we have a counter trick to this situation known as **normal bias**.
    It still pushes objects, but along the direction they are facing. This one is
    a little bit tricky, so we won''t go into too much detail here, but the idea is
    that combining a little bit of depth bias and another bit of normal bias will
    reduce the false positives, but not completely eliminate them. Therefore, we need
    to learn how to live with that and hide it by cleverly positioning objects:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们有一个对这种情况的反对技巧，称为**法线偏差**。它仍然推动物体，但沿着它们面对的方向。这有点棘手，所以我们不会在这里详细介绍，但是想法是结合一点深度偏差和另一点法线偏差将减少错误的阳性，但不会完全消除它们。因此，我们需要学会如何与之共存，并通过巧妙地定位物体来隐藏它：
- en: '![Figure 8.32 – Reduced false negatives, which is the result of combining depth
    and normal bias'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.32-减少假阴性，这是深度和法线偏差相结合的结果'
- en: '](img/Figure_8.032_B14199.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.032_B14199.jpg)'
- en: Figure 8.32 – Reduced false negatives, which is the result of combining depth
    and normal bias
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.32-减少假阴性，这是深度和法线偏差相结合的结果
- en: There are several other aspects that affect how Shadow Map works, with one of
    them being the light range. The smaller the light range, the less area the shadows
    will cover. The same Shadow Map resolution can add more detail to that area, so
    try to reduce the light ranges as much as you can.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几个影响阴影图工作方式的方面，其中之一是光范围。光范围越小，阴影覆盖的区域就越小。相同的阴影图分辨率可以为该区域添加更多细节，因此尽量减少光范围。
- en: I can imagine your face right now, and yes, lighting is complicated, and we've
    only just scratched the surface! But keep your spirits up! After a little trial
    and error fiddling with the settings, you will understand it better. We'll do
    that in the next section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以想象你现在的表情，是的，照明很复杂，我们只是刚刚触及到表面！但保持你的精神！在稍微调整设置后，你会更好地理解它。我们将在下一节中做到这一点。
- en: Important information
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: If you are really interested in learning more about the internals of the shadow
    system, I recommend that you look at the concept of **Shadow Cascades**, an advanced
    topic about Directional Lights and Shadow Map generation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的对学习阴影系统的内部更多信息感兴趣，我建议您查看**阴影级联**的概念，这是有关定向光和阴影图生成的高级主题。
- en: Configuring performant shadows
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置高性能阴影
- en: 'Because we are targeting mid-end devices, we will try to achieve a good balance
    of quality and performance here, so let''s start enabling shadows just for the
    spotlights. The Directional Light shadow won''t be that noticeable, and actually,
    a rainy sky doesn''t generate clear shadows, so we will use that as an excuse
    to not calculate those shadows. In order to do this, do the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的目标是中端设备，所以我们将尝试在这里实现质量和性能的良好平衡，因此让我们开始仅为聚光灯启用阴影。定向光的阴影不会那么明显，实际上，雨天的天空不会产生清晰的阴影，因此我们将借此借口不计算那些阴影。为了做到这一点，请执行以下操作：
- en: Select both Point Lights by clicking them in the Hierarchy while pressing *Ctrl*
    (*Command* on Mac). This will ensure that any changes made in the **Inspector**
    window will be applied to both:![Figure 8.33 – Selecting multiple objects
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在层次结构中单击它们并同时按下*Ctrl*（Mac上的*Command*）来选择两个点光源。这将确保**检查器**窗口中所做的任何更改都将应用于两者：![图8.33-选择多个对象
- en: '](img/Figure_8.033_B14199.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.033_B14199.jpg)'
- en: Figure 8.33 – Selecting multiple objects
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.33-选择多个对象
- en: In the **Inspector** window, set **Shadow Type** to **Soft Shadows**. We will
    be using low-resolution shadow maps here:![Figure 8.34 – Soft Shadows setting](img/Figure_8.034_B14199.jpg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，将**阴影类型**设置为**软阴影**。我们将在这里使用低分辨率阴影图：![图8.34-软阴影设置](img/Figure_8.034_B14199.jpg)
- en: Figure 8.34 – Soft Shadows setting
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.34-软阴影设置
- en: Select **Directional light** and set **Shadow Type** to **No Shadows** to prevent
    it from casting shadows:![Figure 8.35 – No Shadows setting](img/Figure_8.035_B14199.jpg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**定向光**并将**阴影类型**设置为**无阴影**以防止其投射阴影：![图8.35-无阴影设置](img/Figure_8.035_B14199.jpg)
- en: Figure 8.35 – No Shadows setting
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.35-无阴影设置
- en: Create a cube (**GameObject** | **3D Object** | **Cube**) and place it near
    one of the lights, just to have an object that we can cast shadows on for testing
    purposes.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个立方体（**GameObject** | **3D Object** | **Cube**）并将其放在灯光附近，以便我们可以在其上投射阴影进行测试。
- en: 'Now that we have a base test scenario, let''s fiddle with the Shadow Maps resolution
    settings, preventing Shadow Acne in the process:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个基本的测试场景，让我们调整阴影图分辨率设置，同时防止阴影痤疮：
- en: Go to **Edit** | **Project Settings**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**编辑** | **项目设置**。
- en: In the left-hand side list, look for **Graphics** and click it:![Figure 8.36
    – Graphics settings
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列表中，查找**图形**并单击它：![图8.36-图形设置
- en: '](img/Figure_8.036_B14199.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.036_B14199.jpg)'
- en: Figure 8.36 – Graphics settings
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.36-图形设置
- en: 'In the properties that appear after selecting this option, click in the box
    below **Scriptable Render Pipeline Settings** – the one that contains a name.
    In my case, this is **LWRP-HighQuality**, but yours may be different due to you
    having a different version of Unity:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择此选项后出现的属性中，单击下面的**可编写渲染管线设置**框中的一个名称。在我的情况下，这是**LWRP-HighQuality**，但由于您使用的Unity版本不同，您的情况可能不同：
- en: '![Figure 8.37 – Current Render Pipeline setting](img/Figure_8.037_B14199.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图8.37-当前渲染管线设置](img/Figure_8.037_B14199.jpg)'
- en: Figure 8.37 – Current Render Pipeline setting
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.37-当前渲染管线设置
- en: Doing that will highlight an asset in the Project window, so be sure that window
    is visible before selecting it. Select the highlighted asset:![Figure 8.38 – Current
    pipeline highlighted
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做将在项目窗口中突出显示一个资产，因此在选择之前，请确保该窗口可见。选择突出显示的资产：![图8.38-突出显示当前管道
- en: '](img/Figure_8.038_B14199.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.038_B14199.jpg)'
- en: Figure 8.38 – Current pipeline highlighted
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.38-突出显示当前管道
- en: This asset has several graphics settings related to how URP will handle its
    rendering, including lighting and shadows. Expand the **Lighting** section to
    reveal its settings:![Figure 8.39 – Pipeline lighting settings
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.039_B14199.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.39 – Pipeline lighting settings
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The `Main Light`). Set it to **1024** if it's not already at that value.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the `0.25` in order to reduce them as much as we can before we remove
    the Shadow Acne:![Figure 8.40 – Light shadows settings
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.040_B14199.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.40 – Light shadows settings
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: This isn't entirely related to shadows, but here, you can change the **Per Object
    Light** limit to increase or reduce the number of lights that can affect the object
    (no more than eight).
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In case you followed the shadow cascades tip presented earlier, you can play
    with the **Cascades** value a little bit to enable shadows for Directional Light
    to notice the effect. Remember that those shadow settings only work for Directional
    Light.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set both lights so that they have a 40-meter range. See how the shadows improve
    in quality before and after the change:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.41 – Bias settings'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.041_B14199.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.41 – Bias settings
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Remember that those values only work in my case, so try to fiddle with the values
    a little bit to see how that changes the result – you may find a better setup
    for your PC. Also, remember that not having shadows is always an option, so always
    consider that in case your game is running low on FPS (and there isn't another
    performance problem lurking).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: You probably think that that is all we can do about performance in terms of
    lighting, but luckily, that's not the case! We have another resource we can use
    to improve it further known as static lighting.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing lighting
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned previously that not calculating lighting is good for performance,
    but what about not calculating lights, but still having them? Yes, its sounds
    too good to be true, but it is actually possible (and, of course, tricky). We
    can use a technique called static lighting or baking, which allows us to calculate
    lighting once and use the cached result.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following concepts related to Static Lighting:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Understanding static lighting
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Baking lightmaps
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying static lighting to dynamic objects
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding static lighting
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea is pretty simple: just do the lighting calculations once, save the
    results, and then use those instead of calculating lighting all the time. You
    may be wondering why this isn''t the default technique to use. This is because
    it has some limitations, with the big one being dynamic objects. **Precalculating
    shadows** means that they can''t change once they''ve been calculated, but if
    an object that is casting a shadow is moved, the shadow will still be there, so
    the main thing to take into account here is that you can''t use this technique
    with moving objects. Instead, you will need to mix **static** or **baked lighting**
    for static objects and **Realtime lighting** for dynamic (moving) objects. Also,
    consider that aside from this technique being only valid for static objects, it
    is also only valid for static lights. Again, if a light moves, the precalculated
    data becomes invalid.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Another limitation you need to take into account is that that precalculated
    data can have a huge impact on memory. That data occupies space in RAM, maybe
    hundreds of MBs, so you need to consider whether your target platform has enough
    space. Of course, you can reduce the precalculated lighting quality to reduce
    the size of that data, but you need to consider whether the loss of quality deteriorates
    the look and feel of your game too much. As with all options regarding optimization,
    you need to balance two factors: performance and quality.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'We have several kinds of precalculated data in our process, but the most important
    one is what we call **lightmaps**. A lightmap is a texture that contains all the
    shadows and lighting for all the objects in the scene, so when Unity applies the
    precalculated or baked data, it will look at this texture to know which parts
    of the static objects are lit and which aren''t. You can see an example of a lightmap
    in the following figure:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.42 – Left, a scene with no lighting; middle, a lightmap holding
    precalculated data from that scene; right, the lightmap being applied to the scene'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.042_B14199.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.42 – Left, a scene with no lighting; middle, a lightmap holding precalculated
    data from that scene; right, the lightmap being applied to the scene
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, having lightmaps has its own benefits. The baking process is executed
    in Unity, before the game is shipped to users, so you can spend plenty of time
    calculating stuff that you can't do at runtime, such as improved accuracy, light
    bounces, light occlusion in corners, and light from emissive objects. However,
    that can also be a problem. Remember, dynamic objects still need to rely on Realtime
    lighting, and that lighting will look very different compared to the static lighting,
    so we need to tweak them a lot for the user to not notice the difference.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic notion of what static lighting is, let's dive into
    how to use it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Baking lightmaps
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use lightmaps, we need to make some preparations regarding the 3D models.
    Remember that meshes have **UVs**, which contain information about which part
    of the texture needs to be applied to each part of the model. Sometimes, to save
    texture memory you can apply the same piece of texture to different parts. For
    example, in a car's texture, you wouldn't have four wheels, you'd just have one,
    and you can apply that same piece of texture to all the wheels. The problem here
    is that static lighting uses textures the same way, but here, it will apply the
    lightmaps to light the object. In the wheel scenario, the problem would be that
    if one wheel receives shadows, all of them will have them, because all the wheels
    are sharing the same texture space. The usual solution is to have a second set
    of UVs in the model with no texture space being shared, just to use for lightmapping.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, downloaded models are already prepared for lightmapping, and sometimes
    they aren''t, but luckily, Unity has us covered in those scenarios. To be sure
    a model will calculate lightmapping properly, let''s make Unity automatically
    generate the **Lightmapping UV** set by doing the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Select the mesh asset (FBX) in the **Project** window.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Model** tab, look for the **Generate Lightmap** checkbox at the bottom
    and check it.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Apply** button at the bottom:![Figure 8.43 – Generate Lightmap setting
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.043_B14199.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.43 – Generate Lightmap setting
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this process for every model. Technically, you can only do this in the
    models where you get artifacts and weird results after baking lightmaps, but for
    now, let's do this in all the models just in case.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After preparing the models for being lightmapped, the next step is to tell
    Unity which objects are not going to move. To do so, do the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Select the object that won't move.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Static** checkbox in the topright of the **Inspector** window:![Figure
    8.44 – Static checkbox
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.044_B14199.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.44 – Static checkbox
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this for every static object (this isn't necessary for lights; we will
    deal with those later).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider that you may not want every object, even if it''s static, to be lightmapped,
    because the more objects you lightmap, the more texture size you will require.
    As an example, the terrain is too large and will consume most of the lightmapping''s
    size. Usually, this is necessary, but in our case, the Spotlights are barely touching
    the terrain. Here, we have two options: leave the terrain as dynamic, or better,
    directly tell the Spotlights to not affect the terrain since one is only lit by
    ambient lighting and the Directional Light (which is not casting shadows). Remember
    that this is something we can do because of our type of scene; however, you may
    need to use other settings in other scenarios. You can exclude an object from
    both Realtime and Static lighting calculations by doing the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Select the object to exclude.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, click the **Layer** dropdown and click on **Add
    Layer**:![Figure 8.45 – Layer creation button
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.045_B14199.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.45 – Layer creation button
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can create a layer, which is a group of objects that's used to identify
    which objects are not going to be affected by lighting. In the **Layers** list,
    look for an empty space and type in any name for those kinds of objects. In my
    case, I will only exclude the terrain, so I have just named it **Terrain**:![Figure
    8.46 – Layers list
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.046_B14199.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.46 – Layers list
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Once again, select the terrain, go to the **Layer** dropdown, and select the
    layer you created in the previous step. This way, you can specify that this object
    belongs to that group of objects:![Figure 8.47 – Changing a GameObject's layer
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.047_B14199.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.47 – Changing a GameObject's layer
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Select all the Spotlights lights, look for the **Culling Mask** in the **Inspector**
    window, click it, and uncheck the layer you created previously. This way, you
    can specify that those lights won't affect that group of objects:![Figure 8.48
    – Light Culling Mask
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.048_B14199.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.48 – Light Culling Mask
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can see how those selected lights are not illuminating or applying
    shadows to the terrain.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, it''s time for the lights since the **Static** checkbox won''t work for
    them. For them, we have the following three modes:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '**Realtime**: A light in Realtime mode will affect all objects, both static
    and dynamic, using Realtime lighting, meaning there''s no precalculation. This
    is useful for lights that are not static, such as the player''s flashlight, a
    lamp that is moving due to the wind, and so on.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Baked**: The opposite of Realtime, this kind of light will only affect static
    objects with lightmaps. This means that if the player (dynamic) moves under a
    baked light on the street (static), the street will look lit, but the player will
    still be dark and won''t cast any shadows on the street. The idea is to use this
    on lights that won''t affect any dynamic object, or on lights that are barely
    noticeable on them, so that we can increase performance by not calculating them.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixed**: This is the preferred mode if you are not sure which one to use.
    This kind of light will calculate lightmaps for static objects, but will also
    affect dynamic objects, combining its Realtime lighting with the baked one (like
    Realtime lights also do).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, our Directional Light will only affect the terrain, and because
    we don''t have shadows, applying lighting to it is relatively cheap in URP, so
    we can leave the Directional Light in Realtime so that it won''t take up any lightmap
    texture area. Our spotlights are affecting the base, but actually, they are only
    applying lighting to it – we have no shadows because our base is empty. In this
    case, it is preferable to not calculate lightmapping whatsoever, but for learning
    purposes, I will add a few objects as obstacles to the base to cast some shadows
    and justify the use of lightmapping, as shown in the following figure:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.49 – Adding objects to project light'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.049_B14199.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.49 – Adding objects to project light
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see how the original design of our level changes constantly during
    the development of the game, and that''s something you can''t avoid – bigger parts
    of the game will change in time. Now, we are ready to set up the Light Modes and
    execute the baking process, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Select **Directional Light**.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `Inspector` window to **Realtime** (if it's not already in that mode).
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select both Spotlights.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set their **Render Mode** to **Mixed**:![Figure 8.50 – Mixed lighting setting
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.050_B14199.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.50 – Mixed lighting setting
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lighting Settings** window (**Window** | **Rendering** | **Lighting
    Settings**).
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Generate Lighting**, which is the same button we used previously to
    generate ambient lighting.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the process to complete. You can do this by checking the progress bar
    at the bottom-right of the Unity Editor. Note that this process could take hours
    in large scenes, so be patient:![Figure 8.51 – Baking progress bar
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.051_B14199.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.51 – Baking progress bar
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: We want to change some of the settings of the baking process. In order to enable
    the controls for this, click the **New Lighting Settings** button. This will create
    an asset with lightmapping settings that can be applied to several scenes in case
    we want to share the same settings multiple times:![Figure 8.52 – Creating lighting
    settings
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.052_B14199.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.52 – Creating lighting settings
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Reduce the quality of lightmapping, just to make the process go faster. Just
    to iterate, the lighting can easily be reduced by using settings such as **Lightmap
    Resolution**, **Direct**, **Indirect,** and **Environment Samples**. In my case,
    I have those settings applied, as shown in the following figure. Note that even
    reducing those will take time; we have too many objects in the scene due to the
    modular level design:![Figure 8.53 – Scene lighting settings
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.053_B14199.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.53 – Scene lighting settings
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: After the process has completed, you can check the bottom part of the **Lighting
    Settings** window, where you can see how many lightmaps need to be generated.
    We have a maximum lightmap resolution, so we probably need several of them to
    cover the entire scene. Also, it informs us of their size so that we can consider
    their impact in terms of RAM. Finally, you can check out the **Baked Lightmaps**
    section to see them:![Figure 8.54 – Generated lightmaps
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.054_B14199.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.54 – Generated lightmaps
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, based on the results, you can move objects, modify light intensities,
    or make whatever correction you would need in order to make the scene look the
    way you want and recalculate the lighting every time you need to. In my case,
    those settings gave me good enough results, which you can see in the following
    figure:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.55 – Lightmap result'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.055_B14199.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.55 – Lightmap result
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: We still have plenty of small settings to touch on, but I will leave you to
    discover those through trial and error or by reading the Unity documentation about
    lightmapping at this link. Reading the Unity manual is a good source of knowledge
    and I recommend that you start using it – any good developer, no matter how experienced,
    should read the manual.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Applying static lighting to static objects
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When marking objects as static in your scene, you''ve probably figured out
    that all the objects in the scene won''t move, so you probably checked the static
    checkbox for every one. That''s OK, but you should always put a dynamic object
    into the scene to really be sure that everything works OK – no games have totally
    static scenes. Try adding a capsule and moving it around to simulate our player,
    as shown in the following figure. If you pay attention to it, you will notice
    something odd – the shadows being generated by the lightmapping process are not
    being applied to our dynamic object:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.56 – Dynamic object under a lightmap''s precalculated shadow'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.056_B14199.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.56 – Dynamic object under a lightmap's precalculated shadow
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: You may be thinking that Mixed Light Mode was supposed to affect both dynamic
    and static objects, and that is exactly what it's doing. The problem here is that
    everything related to static objects is precalculated into those lightmap textures,
    including the shadows they cast, and because our capsule is dynamic, it wasn't
    there when the precalculation process was executed. So, in this case, because
    the object that cast the shadow was static, its shadow won't affect any dynamic
    object.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have several solutions. The first would be to change the Static and
    Realtime mixing algorithm to make everything near the camera use Realtime lighting
    and prevent this problem (at least near the focus of attention of the player),
    which would have a big impact on performance. The alternative is to use **Light
    Probes**. When we baked information, we only did that on lightmaps, meaning that
    we have information on lighting just over surfaces, not in empty spaces. Because
    our player is traversing the empty spaces between those surfaces, we don''t know
    exactly how the lighting would look in those spaces, such as the middle of a corridor.
    Light Probes are a set of points in those empty spaces where Unity also pre-calculates
    information, so when some dynamic object passes through it, it will sample information
    from it. In the following figure, you can see some Light Probes that have been
    applied to our scene. You will notice that the ones that are inside shadows are
    going to be dark, while the ones exposed to light will have a greater intensity.
    This effect will be applied to our dynamic objects:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.57 – Spheres representing Light Probes'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.057_B14199.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.57 – Spheres representing Light Probes
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'If you move your object through the scene now, it will react to the shadows,
    as shown in the following two images, where you can see a dynamic object being
    lit outside a baked shadow and being dark inside:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.58 – Dynamic object receiving baked lighting from Light Probes'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.058_B14199(Merged).jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.58 – Dynamic object receiving baked lighting from Light Probes
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create Light Probes, do the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Create a group of **Light** Probes by going to **GameObject** | **Light** |
    **Light Probe Group**:![Figure 8.59 – Creating a Light Probe Group
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.059_B14199.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.59 – Creating a Light Probe Group
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we have some guidelines on how to locate them. It is recommended
    to place them where the lighting changes, such as inside and outside shadow borders.
    However, that is pretty complicated. The simplest and recommended approach is
    to just drop a grid of Light Probes all over your playable area. To do that, you
    can simply copy and paste the Light Grid Group several times to cover the entire
    base:![Figure 8.60 – Light Probe grid
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.060_B14199.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.60 – Light Probe grid
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Another approach would be to select one group and click the **Edit Light Probes**
    button to enter Light Probe edit mode:![Figure 8.61 – Light Probe Group edit button
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.061_B14199.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.61 – Light Probe Group edit button
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Select All** button and then **Duplicate Selected** to duplicate
    all the previously existing probes.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the translate gizmo, move them next to the previous ones, extending the
    grid in the process. Consider that the nearer the probes are, you will need more
    to cover the terrain, which will generate more data. However, Light Probes data
    is relatively cheap, so you can have lots of them.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 4* to *5* until you've covered the entire area.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regenerate lighting with the **Generate Lighting** button in **Lighting Settings**.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, you have precalculated lighting on the Light Probes affecting our
    dynamic objects, combining both worlds to get cohesive lighting.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed several lighting topics, such as how Unity calculates
    lights, shadows, how to deal with different light sources such as direct and indirect
    lighting, how to configure shadows, how to bake lighting to optimize performance,
    and how to combine dynamic and static lighting so that the lights aren't disconnected
    from the world they affect. This was a long chapter, but lighting deserves that.
    It is a complex subject that can improve the look and feel of your scene drastically,
    as well as reducing your performance dramatically. It requires a lot of practice
    and, here, we tried to summarize all the important knowledge you will need to
    start experimenting with it. Be patient with this topic; it is easy to get incorrect
    results, but you are probably just one checkbox away from solving it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have improved all we can in the scene settings, in the next chapter,
    we will apply a final layer of graphic effects using the Unity Postprocessing
    Stack, which will apply full-screen image effects – ones that will give us that
    cinematic look and feel all games have nowadays.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
