- en: Chapter 4. Structural Patterns - Proxy, Facade, Decorator, and Flyweight Design
    Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, we will finish with the Structural patterns. We have left
    some of the most complex ones till the end so that you get more used to the mechanics
    of design patterns, and the features of Go language.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will work at writing a cache to access a database, a library
    to gather weather data, a server with runtime middleware, and discuss a way to
    save memory by saving shareable states between the types values.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start the final chapter on structural patterns with the Proxy pattern.
    It's a simple pattern that provides interesting features and possibilities with
    very little effort.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Proxy pattern usually wraps an object to hide some of its characteristics.
    These characteristics could be the fact that it is a remote object (remote proxy),
    a very heavy object such as a very big image or the dump of a terabyte database
    (virtual proxy), or a restricted access object (protection proxy).
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The possibilities of the Proxy pattern are many, but in general, they all try
    to provide the same following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Hide an object behind the proxy so the features can be hidden, restricted, and
    so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a new abstraction layer that is easy to work with, and can be changed
    easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our example, we are going to create a remote proxy, which is going to be
    a cache of objects before accessing a database. Let's imagine that we have a database
    with many users, but instead of accessing the database each time we want information
    about a user, we will have a **First In First Out** (**FIFO**) stack of users
    in a Proxy pattern (FIFO is a way of saying that when the cache needs to be emptied,
    it will delete the first object that entered first).
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will wrap an imaginary database, represented by a slice, with our Proxy
    pattern. Then, the pattern will have to stick to the following acceptance criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: All accesse to the database of users will be done through the Proxy type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A stack of `n` number of recent users will be kept in the Proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a user already exists in the stack, it won't query the database, and will
    return the stored one
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the queried user doesn't exist in the stack, it will query the database,
    remove the oldest user in the stack if it's full, store the new one, and return
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since version 1.7 of Go, we can embed tests within tests by using closures so
    we can group them in a more human-readable way, and reduce the number of `Test_`
    functions. Refer to [Chapter 1](ch01.html "Chapter 1. Ready... Steady... Go!")
    , *Ready... Steady... Go!* to learn how to install the new version of Go if your
    current version is older than version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: 'The types for this pattern will be the proxy user and user list structs as
    well as a `UserFinder` interface that the database and the Proxy will implement.
    This is key because the Proxy must implement the same interfaces as the features
    of the type it tries to wrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserFinder` is the interface that the database and the Proxy implement.
    The `User` is a type with a member called `ID`, which is `int32` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `UserList` is a type of a slice of users. Consider the following
    syntax for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you are asking why we aren't using a slice of users directly, the answer
    is that by declaring a sequence of users this way, we can implement the `UserFinder`
    interface but with a slice, we can't.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Proxy type, called `UserListProxy` will be composed of a `UserList`
    slice, which will be our database representation. The `StackCache` members which
    will also be of `UserList` type for simplicity, `StackCapacity` to give our stack
    the size we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cheat a bit for the purpose of this tutorial and declare a Boolean
    state on a field called `DidDidLastSearchUsedCache` that will hold if the last
    performed search has used the cache, or has accessed the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `UserListProxy` type will cache a maximum of `StackCapacity` users, and
    rotate the cache if it reaches this limit. The `StackCache` members will be populated
    from objects from `SomeDatabase` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test is called `TestUserListProxy`, and is listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test creates a user list of 1 million users with random names.
    To do so, we feed the random number generator by calling the `Seed()` function
    with some constant seed so our randomized results are also constant; and the user
    IDs are generated from it. It might have some duplicates, but it serves our purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a proxy with a reference to `someDatabase`, which we have just
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have a `proxy` object composed of a mock database with 1 million
    users, and a cache implemented as a FIFO stack with a size of 2\. Now we will
    get three random IDs from `someDatabase` to use in our stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We took the fourth, fifth, and sixth IDs from the slice (remember that arrays
    and slices start with 0, so the index 3 is actually the fourth position in the
    slice).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is going to be our starting point before launching the embedded tests.
    To create an embedded test, we have to call the `Run` method of the `testing.T`
    pointer, with a description and a closure with the `func(t *testing.T)` signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, in the preceding code snippet, we give the description `FindUser
    - Empty cache`. Then we define our closure. First it tries to find a user with
    a known ID, and checks for errors. As the description implies, the cache is empty
    at this point, and the user will have to be retrieved from the `someDatabase` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we check whether the returned user has the same ID as that of the expected
    user at index 0 of the `knownIDs` slice, and that the proxy cache now has a size
    of 1\. The state of the member `DidLastSearchUsedCache` proxy must not be `true`,
    or we will not pass the test. Remember, this member tells us whether the last
    search has been retrieved from the slice that represents a database, or from the
    cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second embedded test for the Proxy pattern is to ask for the same user
    as before, which must now be returned from the cache. It''s very similar to the
    previous test, but now we have to check if the user is returned from the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, again we ask for the first known ID. The proxy cache must maintain a size
    of 1 after this search, and the `DidLastSearchUsedCache` member must be true this
    time, or the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last test will overflow the `StackCache` array on the `proxy` type. We
    will search for two new users that our `proxy` type will have to retrieve from
    the database. Our stack has a size of 2, so it will have to remove the first user
    to allocate space for the second and third users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have retrieved the first three users. We aren't checking for errors because
    that was the purpose of the previous tests. This is important to recall that there
    is no need to over-test your code. If there is any error here, it will arise in
    the previous tests. Also, we have checked that the `user2` and `user3` queries
    do not use the cache; they shouldn't be stored there yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to look for the `user1` query in the Proxy. It shouldn''t
    exist, as the stack has a size of 2, and `user1` was the first to enter, hence,
    the first to go out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't matter if we ask for a thousand users; our cache can't be bigger
    than our configured size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are going to again range over the users stored in the cache, and
    compare them with the last two we queried. This way, we will check that just those
    users are stored in the cache. Both must be found on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the tests now should give some errors, as usual. Let''s run them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, let's implement the `FindUser` method to act as our Proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our Proxy, the `FindUser` method will search for a specified ID in the cache
    list. If it finds it, it will return the ID. If not, it will search in the database.
    Finally, if it's not in the database list, it will return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, our Proxy pattern is composed of two `UserList` types (one
    of them a pointer), which are actually slices of `User` type. We will implement
    a `FindUser` method in `User` type too, which, by the way, has the same signature
    as the `UserFinder` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `FindUser` method in the `UserList` slice will iterate over the list to
    try and find a user with the same ID as the `id` argument, or return an error
    if it can't find it.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why the pointer `t` is between parentheses. This is to
    dereference the underlying array before accessing its indexes. Without it, you'll
    have a compilation error, because the compiler tries to search the index before
    dereferencing the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first part of the proxy `FindUser` method can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We use the preceding method to search for a user in the `StackCache` member.
    The error will be nil if it can find it, so we check this to print a message to
    the console, change the state of `DidLastSearchUsedCache` to `true` so that the
    test can check whether the user was retrieved from cache, and finally, return
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if the error was not nil, it means that it couldn''t find the user in the
    stack. So, the next step is to search in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can reuse the `FindUser` method we wrote for `UserList` database in this
    case, because both have the same type for the purpose of this example. Again,
    it searches the user in the database represented  by the `UserList` slice, but
    in this case, if the user isn't found, it returns the error generated in `UserList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user is found (`err` is nil), we have to add the user to the stack.
    For this purpose, we write a dedicated private method that receives a pointer
    of type `UserListProxy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addUserToStack` method takes the user argument, and adds it to the stack
    in place. If the stack is full, it removes the first element in it before adding.
    We have also written an `addUser` method to `UserList` to help us in this. So,
    now in `FindUser` method, we just have to add one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This adds the new user to the stack, removing the last if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we just have to return the new user of the stack, and set the appropriate
    value on `DidLastSearchUsedCache` variable. We also write a message to the console
    to help in the testing process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have enough to pass our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding messages that our Proxy has worked flawlessly.
    It has returned the first search from the database. Then, when we search for the
    same user again, it uses the cache. Finally, we made a new test that calls three
    different users and we can observe, by looking at the console output, that just
    the first was returned from the cache and that the other two were fetched from
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Proxying around actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wrap proxies around types that need some intermediate action, like giving authorization
    to the user or providing access to a database, like in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Our example is a good way to separate application needs from database needs.
    If our application accesses the database too much, a solution for this is not
    in your database. Remember that the Proxy uses the same interface as the type
    it wraps, and, for the user, there shouldn't be any difference between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll continue this chapter with the big brother of the Proxy pattern, and maybe,
    one of the most powerful design patterns of all. The **Decorator** pattern is
    pretty simple, but, for instance, it provides a lot of benefits when working with
    legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Decorator design pattern allows you to decorate an already existing type
    with more functional features without actually touching it. How is it possible?
    Well, it uses an approach similar to *matryoshka dolls*, where you have a small
    doll that you can put inside a doll of the same shape but bigger, and so on and
    so forth.
  prefs: []
  type: TYPE_NORMAL
- en: The Decorator type implements the same interface of the type it decorates, and
    stores an instance of that type in its members. This way, you can stack as many
    decorators (dolls) as you want by simply storing the old decorator in a field
    of the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you think about extending legacy code without the risk of breaking something,
    you should think of the Decorator pattern first. It's a really powerful approach
    to deal with this particular problem.
  prefs: []
  type: TYPE_NORMAL
- en: A different field where the Decorator is very powerful may not be so obvious
    though it reveals itself when creating types with lots of features based on user
    inputs, preferences, or similar inputs. Like in a Swiss knife, you have a base
    type (the frame of the knife), and from there you unfold its functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, precisely when are we going to use the Decorator pattern? Answer to this
    question:'
  prefs: []
  type: TYPE_NORMAL
- en: When you need to add functionality to some code that you don't have access to,
    or you don't want to modify to avoid a negative effect on the code, and follow
    the open/close principle (like legacy code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want the functionality of an object to be created or altered dynamically,
    and the number of features is unknown and could grow fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, we will prepare a `Pizza` type, where the core is the pizza
    and the ingredients are the decorating types. We will have a couple of ingredients
    for our pizza-onion and meat.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The acceptance criteria for a Decorator pattern is to have a common interface
    and a core type, the one that all layers will be built over:'
  prefs: []
  type: TYPE_NORMAL
- en: We must have the main interface that all decorators will implement. This interface
    will be called `IngredientAdd`, and it will have the `AddIngredient() string`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must have a core `PizzaDecorator` type (the decorator) that we will add ingredients
    to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must have an ingredient "onion"  implementing the same `IngredientAdd` interface
    that will add the string `onion` to the returned pizza.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must have a ingredient "meat" implementing the `IngredientAdd` interface
    that will add the string `meat` to the returned pizza.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When calling `AddIngredient` method on the top object, it must return a fully
    decorated `pizza` with the text `Pizza with the following ingredients: meat, onion`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To launch our unit tests, we must first create the basic structures described
    in accordance with the acceptance criteria. To begin with, the interface that
    all decorating types must implement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code defines the `PizzaDecorator` type, which must have `IngredientAdd`
    inside, and which implements `IngredientAdd` too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the `Meat` type will be very similar to that of the  `PizzaDecorator` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define the `Onion` struct in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is enough to implement the first unit test, and to allow the compiler
    to run them without any compiling errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it must compile without problems, so we can check that the test fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first test is done, and we can see that the `PizzaDecorator` struct isn''t
    returning anything yet, that''s why it fails. We can now move on to the `Onion`
    type. The test of the `Onion` type is quite similar to that of the `Pizza` decorator,
    but we must also make sure that we actually add the ingredient to the `IngredientAdd` method
    and not to a nil pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first half of the preceding test examines the returning error when no `IngredientAdd` method
    is passed to the `Onion` struct initializer. As no pizza is available to add the
    ingredient, an error must be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The second part of the `Onion` type test actually passes `PizzaDecorator` structure
    to the initializer. Then, we check whether no error is being returned, and also
    whether the returning string contains the word `onion` in it. This way, we can
    ensure that onion has been added to the pizza.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally for the `Onion` type, the console output of this test with our current
    implementation will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `meat` ingredient is exactly the same, but we change the type to meat instead
    of onion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the result of the tests will be similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must check the full stack test. Creating a pizza with onion and
    meat must return the text `Pizza with the following ingredients: meat, onion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test creates a variable called `pizza` which, like the m*atryoshka dolls*,
    embeds types of the `IngredientAdd` method in several levels. Calling the `AddIngredient`
    method executes the method at the "onion" level, which executes the "meat" one,
    which, finally, executes that of the `PizzaDecorator` struct. After checking that
    no error had been returned, we check whether the returned text follows the needs
    of the *acceptance criteria 5*. The tests are run with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that the tests now return an empty string
    for our decorated type. This is, of course, because no implementation has been
    done yet. This was the last test to check the fully decorated implementation.
    Let's look closely at the implementation then.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to start implementing the `PizzaDecorator` type. Its role is to
    provide the initial text of the full pizza:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A single line change on the return of the `AddIngredient` method was enough
    to pass the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on to the `Onion` struct implementation, we must take the beginning
    of our `IngredientAdd` returned string, and add the word `onion` at the end of
    it in order to get a composed pizza in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking that we actually have a pointer to `IngredientAdd` first, we use the
    contents of the inner `IngredientAdd`, and check it for errors. If no errors occur,
    we receive a new string composed of this content, a space, and the word `onion`
    (and no errors). Looks good enough to run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementation of the `Meat` struct is very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And here goes their test execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay. So, now all the pieces are to be tested separately. If everything is
    okay, the test of the *full stacked* solution must be passing smoothly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! With the Decorator pattern, we could keep stacking `IngredientAdds`
    which call their inner pointer to add functionality to `PizzaDecorator`. We aren't
    touching the core type either, nor modifying or implementing new things. All the
    new features are implemented by an external type.
  prefs: []
  type: TYPE_NORMAL
- en: A real-life example - server middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you should have understood how the Decorator pattern works. Now we can
    try a more advanced example using the small HTTP server that we designed in the
    Adapter pattern section. You learned that an HTTP server can be created by using
    the `http` package, and implementing the `http.Handler` interface. This interface
    has only one method called `ServeHTTP(http.ResponseWriter, http.Request)`. Can
    we use the Decorator pattern to add more functionality to a server? Of course!
  prefs: []
  type: TYPE_NORMAL
- en: We will add a couple of pieces to this server. First, we are going to log every
    connection made to it to the `io.Writer` interface (for the sake of simplicity,
    we'll use the `io.Writer` implementation of the `os.Stdout` interface so that
    it outputs to the console). The second piece will add basic HTTP authentication
    to every request made to the server. If the authentication passes, a `Hello Decorator!` message
    will appear. Finally, the user will be able to select the number of decoration
    items that he/she wants in the server, and the server will be structured and created
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the common interface, http.Handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already have the common interface that we will decorate using nested types.
    We first need to create our core type, which is going to be the `Handler` that
    returns the sentence `Hello Decorator!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This handler can be attributed to the `http.Handle` method to define our first
    endpoint. Let''s check this now by creating the package''s `main` function, and
    sending a `GET` request to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the server using the Terminal to execute the  `**go run main.go**`
    command. Then, open a new Terminal to make the `GET` request. We''ll use the `curl`
    command to make our requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We have crossed the first milestone of our decorated server. The next step
    is to decorate it with logging capabilities. To do so, we must implement the `http.Handler`
    interface, in a new type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We call this type `LoggerServer`. As you can see, it stores not only a `Handler`,
    but also `io.Writer` to write the output of the log. Our implementation of the
    `ServeHTTP` method prints the request URI, the host, the content length, and the
    used method `io.Writer`. Once printing is finished, it calls the `ServeHTTP` function
    of its inner `Handler` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can decorate `MyServer` with this `LoggerMiddleware`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the `**curl **`  command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Our **curl** command returns the same message, but if you look at the Terminal
    where you have run the Go application, you can see the logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We have decorated `MyServer` with logging capabilities without actually modifying
    it. Can we do the same with authentication? Of course! After logging the request,
    we will authenticate it by using **HTTP Basic Authentication** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The **BasicAuthMiddleware** middleware stores three fields--a handler to decorate
    like in the previous middlewares, a user, and a password, which will be the only
    authorization to access the contents on the server. The implementation of the
    `decorating` method will proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding implementation, we use the `BasicAuth` method from `http.Request`
    to automatically retrieve the user and password from the request, plus an `ok/ko`
    from the parsing action. Then we check whether the parsing is correct (returning
    a message to the requester if incorrect, and finishing the request). If no problems
    have been detected during parsing, we check whether the username and the password
    match with the ones stored in `BasicAuthMiddleware`. If the credentials are valid,
    we shall call the decorated type (our server), but if the credentials aren't valid,
    we receive the `User or password incorrect` message in return, and the request
    is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to provide the user with a way to choose among different types
    of servers. We will retrieve user input data in the main function. We''ll have
    three options to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server with logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server with logging and authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have to use the `Fscanf` function to retrieve input from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `Fscanf` function needs an `io.Reader`  implementor as the first argument
    (which is going to be the input in the console), and it takes the server selected
    by the user from it. We'll pass `os.Stdin` as the `io.Reader` interface to retrieve
    user input. Then, we'll write the type of data it is going to parse. The `%d` specifier
    refers to an integer number. Finally, we'll write memory direction to store the
    parsed input, in this case, the memory position of the `selection` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user selects an option, we can take the basic server and decorate
    it at runtime, switching over to the selected option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The first option will be handled by the default `switch` option--a plain `MyServer`.
    In the case of the second option, we decorate a plain server with logging. The
    third Option is a bit more developed--we ask the user for a username and a password
    using `Fscanf` again. Note that you can scan more than one input, as we are doing
    to retrieve the user and the password. Then, we take the basic server, decorate
    it with authentication, and finally, with logging.
  prefs: []
  type: TYPE_NORMAL
- en: If you follow the indentation of the nested types of option three, the request
    passes through the logger, then the authentication middleware, and finally, the `MyServer`
    argument if everything is okay. The requests will follow the same route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end of the main function takes the decorated handler, and launches the
    server on the `8080` port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s launch the server with the third option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We will first test the plain server by choosing the first option. Run the server
    with the command **go run server_decorator.go**, and select the first option.
    Then, in a different Terminal, run the basic request with curl, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Uh, oh! It doesn''t give us access. We haven''t passed any user and password,
    so it tells us that we cannot continue. Let''s try with some random user and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'No access! We can also check in the Terminal where we launched the server and
    where every request is being logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, enter the correct username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here we are! Our request has also been logged, and the server has granted access
    to us. Now we can improve our server as much as we want by writing more middlewares
    to decorate the server's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: A few words about Go's structural typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go has a feature that most people dislike at the beginning--structural typing.
    This is when your structure defines your type without explicitly writing it. For
    example, when you implement an interface, you don't have to write explicitly that
    you are actually implementing it, contrary to languages such as Java where you
    have to write the keyword `implements`. If your method follows the signature of
    the interface, you are actually implementing the interface. This can also lead
    to accidental implementations of interface, something that could provoke an impossible-to-track
    mistake, but that is very unlikely.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, structural typing also allows you to define an interface after defining
    their implementers. Imagine a `MyPrinter` struct as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine we have been working with the `MyPrinter` type for few months now,
    but it didn''t implement any interface, so it can''t be a possible candidate for
    a Decorator pattern, or maybe it can? What if we wrote an interface that matches
    its `Print` method after a few months? Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: It actually implements the `Printer` interface, and we can use it to create
    a Decorator solution.
  prefs: []
  type: TYPE_NORMAL
- en: Structural typing allows a lot of flexibility when writing programs. If you
    don't know whether a type should be a part of an interface or not, you can leave
    it and add the interface later, when you are completely sure about it. This way,
    you can decorate types very easily and with little modification in your source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing the Decorator design pattern - Proxy versus Decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be wondering, what's the difference between the Decorator pattern
    and the Proxy pattern? In the Decorator pattern, we decorate a type dynamically.
    This means that the decoration may or may not be there, or it may be composed
    of one or many types. If you remember, the Proxy pattern wraps a type in a similar
    fashion, but it does so at compile time and it's more like a way to access some
    type.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, a decorator might implement the entire interface that the
    type it decorates also implements **or not**. So you can have an interface with
    10 methods and a decorator that just implements one of them and it will still
    be valid. A call on a method not implemented by the decorator will be passed to
    the decorated type. This is a very powerful feature but also very prone to undesired
    behaviors at runtime if you forget to implement any interface method.
  prefs: []
  type: TYPE_NORMAL
- en: In this aspect, you may think that the Proxy pattern is less flexible, and it
    is. But the Decorator pattern is weaker, as you could have errors at runtime,
    which you can avoid at compile time by using the Proxy pattern. Just keep in mind
    that the Decorator is commonly used when you want to add functionality to an object
    at runtime, like in our web server. It's a compromise between what you need and
    what you want to sacrifice to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: Facade design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next pattern we'll see in this chapter is the Facade pattern. When we discussed
    the Proxy pattern, you got to know that it was a way to wrap an type to hide some
    of its features of complexity from the user. Imagine that we group many proxies
    in a single point such as a file or a library. This could be a Facade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A facade, in architectural terms, is the front wall that hides the rooms and
    corridors of a building. It protects its inhabitants from cold and rain, and provides
    them privacy. It orders and divides the dwellings.
  prefs: []
  type: TYPE_NORMAL
- en: The Facade design pattern does the same, but in our code. It shields the code
    from unwanted access, orders some calls, and hides the complexity scope from the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use Facade when you want to hide the complexity of some tasks, especially
    when most of them share utilities (such as authentication in an API). A library
    is a form of facade, where someone has to provide some methods for a developer
    to do certain things in a friendly way. This way, if a developer needs to use
    your library, he doesn't need to know all the inner tasks to retrieve the result
    he/she wants.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you use the Facade design pattern in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When you want to decrease the complexity of some parts of our code. You hide
    that complexity behind the facade by providing a more easy-to-use method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to group actions that are cross-related in a single place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to build a library so that others can use your products without
    worrying about how it all works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an example, we are going to take the first steps toward writing our own library
    that accesses `OpenWeatherMaps` service. In case you are not familiar with `OpenWeatherMap`
    service, it is an HTTP service that provides you with live information about weather,
    as well as historical data on it. The **HTTP REST** API is very easy to use, and
    will be a good example on how to create a Facade pattern for hiding the complexity
    of the network connections behind the REST service.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OpenWeatherMap` API gives lots of information, so we are going to focus
    on getting live weather data in one city in some geo-located place by using its
    latitude and longitude values. The following are the requirements and acceptance
    criteria for this design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a single type to access the data. All information retrieved from `OpenWeatherMap` service
    will pass through it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a way to get the weather data for some city of some country.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a way to get the weather data for some latitude and longitude position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only second and thrird point must be visible outside of the package; everything
    else must be hidden (including all connection-related data).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with our API Facade, we will need an interface with the methods asked
    in *acceptance criteria 2* and *acceptance criteria 3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We will call *acceptance criteria 2* `GetByCityAndCountryCode`; we will also
    need a city name and a country code in the string format. A country code is a
    two-character code, which represents the **International Organization for Standardization**
    (**ISO**) name of world countries. It returns a `Weather` value, which we will
    define later, and an error if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '*Acceptance criteria 3* will be called `GetByGeoCoordinates`, and will need
    latitude and longitude values in the `float32` format. It will also return a `Weather`
    value and an error. The `Weather` value is going to be defined according to the
    returned JSON that the `OpenWeatherMap` API works with. You can find the description
    of this JSON at the webpage [http://openweathermap.org/current#current_JSON](http://openweathermap.org/current#current_JSON).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the JSON definition, it has the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s quite a long struct, but we have everything that a response could include.
    The struct is called `Weather`, as it is composed of an ID, a name and a Code
    (`Cod`), and a few anonymous structs, which are: `Coord`, `Weather`, `Base`, `Main`,
    `Wind`, `Clouds`, `Rain`, `Dt`, and `Sys`. We could write these anonymous structs
    outside of the `Weather` struct by giving them a name, but it would only be useful
    if we have to work with them separately.'
  prefs: []
  type: TYPE_NORMAL
- en: After every member and struct within our `Weather` struct, you can find a ``json:"something"``
    line. This comes in handy when differentiating between the JSON key name and your
    member name. If the JSON key is `something`, we aren't forced to call our member
    `something`. For example, our ID member will be called `id` in the JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why don''t we give the name of the JSON keys to our types? Well, if your fields
    in your type are lowercase, the `encoding/json` package won''t parse them correctly.
    Also, that last annotation provides us a certain flexibility, not only in terms
    of changing the members'' names, but also of omitting some key if we don''t need
    it, with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: With `omitempty` at the end, the parse won't fail if this key is not present
    in the bytes representation of the JSON key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, our acceptance criteria 1 ask for a single point of access to the API.
    This is going to be called `CurrentWeatherData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `CurrentWeatherData` type has an API key as public member to work. This
    is because you have to be a registered user in `OpenWeatherMap` to enjoy their
    services. Refer to the `OpenWeatherMap` API's webpage for documentation on how
    to get an API key. We won't need it in our example, because we aren't going to
    do integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need mock data so that we can write a `mock` function to retrieve the data.
    When sending an HTTP request, the response is contained in a member called body
    in the form of an `io.Reader`. We have already worked with types that implement
    the `io.Reader` interface, so this should look familiar to you. Our `mock` function
    appears like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This preceding mocked data was produced by making a request to `OpenWeatherMap`
    using an API key. The `response` variable is a string containing a JSON response.
    Take a close look at the grave accent ([PRE65]
  prefs: []
  type: TYPE_NORMAL
- en: func TestOpenWeatherMap_responseParser(t *testing.T) {
  prefs: []
  type: TYPE_NORMAL
- en: r := getMockData()
  prefs: []
  type: TYPE_NORMAL
- en: 'openWeatherMap := CurrentWeatherData{APIkey: ""}'
  prefs: []
  type: TYPE_NORMAL
- en: weather, err := openWeatherMap.responseParser(r)
  prefs: []
  type: TYPE_NORMAL
- en: if err != nil {
  prefs: []
  type: TYPE_NORMAL
- en: t.Fatal(err)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if weather.ID != 3117735 {
  prefs: []
  type: TYPE_NORMAL
- en: t.Errorf("Madrid id is 3117735, not %d\n", weather.ID)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: func (p *CurrentWeatherData) responseParser(body io.Reader) (*Weather, error)
    {
  prefs: []
  type: TYPE_NORMAL
- en: return nil, fmt.Errorf("Not implemented yet")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: go test -v -run=responseParser .
  prefs: []
  type: TYPE_NORMAL
- en: === RUN   TestOpenWeatherMap_responseParser
  prefs: []
  type: TYPE_NORMAL
- en: '--- FAIL: TestOpenWeatherMap_responseParser (0.00s)'
  prefs: []
  type: TYPE_NORMAL
- en: 'facade_test.go:72: Not implemented yet'
  prefs: []
  type: TYPE_NORMAL
- en: FAIL
  prefs: []
  type: TYPE_NORMAL
- en: exit status 1
  prefs: []
  type: TYPE_NORMAL
- en: FAIL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: func (p *CurrentWeatherData) responseParser(body io.Reader) (*Weather, error)
    {
  prefs: []
  type: TYPE_NORMAL
- en: w := new(Weather)
  prefs: []
  type: TYPE_NORMAL
- en: err := json.NewDecoder(body).Decode(w)
  prefs: []
  type: TYPE_NORMAL
- en: if err != nil {
  prefs: []
  type: TYPE_NORMAL
- en: return nil, err
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return w, nil
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: go test -v -run=responseParser .
  prefs: []
  type: TYPE_NORMAL
- en: === RUN   TestOpenWeatherMap_responseParser
  prefs: []
  type: TYPE_NORMAL
- en: '--- PASS: TestOpenWeatherMap_responseParser (0.00s)'
  prefs: []
  type: TYPE_NORMAL
- en: PASS
  prefs: []
  type: TYPE_NORMAL
- en: ok
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: func (c *CurrentWeatherData) GetByGeoCoordinates(lat, lon float32) (weather
    *Weather, err error) {
  prefs: []
  type: TYPE_NORMAL
- en: return c.doRequest(
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Sprintf("http://api.openweathermap.org/data/2.5/weather q=%s,%s&APPID=%s",
    lat, lon, c.APIkey))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func (c *CurrentWeatherData) GetByCityAndCountryCode(city, countryCode string)
    (weather *Weather, err error) {
  prefs: []
  type: TYPE_NORMAL
- en: return c.doRequest(
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Sprintf("http://api.openweathermap.org/data/2.5/weather?lat=%f&lon=%f&APPID=%s",
    city, countryCode, c.APIkey) )
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: fmt.Sprintf("http://api.openweathermap.org/data/2.5/weather?lat=%f&lon=%f&APPID=%s",
    city, countryCode, c.APIkey)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: func (o *CurrentWeatherData) doRequest(uri string) (weather *Weather, err error)
    {
  prefs: []
  type: TYPE_NORMAL
- en: client := &http.Client{}
  prefs: []
  type: TYPE_NORMAL
- en: req, err := http.NewRequest("GET", uri, nil)
  prefs: []
  type: TYPE_NORMAL
- en: if err != nil {
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: req.Header.Set("Content-Type", "application/json")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: resp, err := client.Do(req)
  prefs: []
  type: TYPE_NORMAL
- en: if err != nil {
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if resp.StatusCode != 200 {
  prefs: []
  type: TYPE_NORMAL
- en: byt, errMsg := ioutil.ReadAll(resp.Body)
  prefs: []
  type: TYPE_NORMAL
- en: if errMsg == nil {
  prefs: []
  type: TYPE_NORMAL
- en: errMsg = fmt.Errorf("%s", string(byt))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: err = fmt.Errorf("Status code was %d, aborting. Error message was:\n%s\n",resp.StatusCode,
    errMsg)
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: weather, err = o.responseParser(resp.Body)
  prefs: []
  type: TYPE_NORMAL
- en: resp.Body.Close()
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: weatherMap := CurrentWeatherData{*apiKey}
  prefs: []
  type: TYPE_NORMAL
- en: weather, err := weatherMap.GetByCityAndCountryCode("Madrid", "ES")
  prefs: []
  type: TYPE_NORMAL
- en: if err != nil {
  prefs: []
  type: TYPE_NORMAL
- en: t.Fatal(err)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("Temperature in Madrid is %f celsius\n", weather.Main.Temp-273.15)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: $ Temperature in Madrid is 30.600006 celsius
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: type Team struct {
  prefs: []
  type: TYPE_NORMAL
- en: ID             uint64
  prefs: []
  type: TYPE_NORMAL
- en: Name           string
  prefs: []
  type: TYPE_NORMAL
- en: Shield         []byte
  prefs: []
  type: TYPE_NORMAL
- en: Players        []Player
  prefs: []
  type: TYPE_NORMAL
- en: HistoricalData []HistoricalData
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: const (
  prefs: []
  type: TYPE_NORMAL
- en: TEAM_A = iota
  prefs: []
  type: TYPE_NORMAL
- en: TEAM_B
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: type Player struct {
  prefs: []
  type: TYPE_NORMAL
- en: Name    string
  prefs: []
  type: TYPE_NORMAL
- en: Surname string
  prefs: []
  type: TYPE_NORMAL
- en: PreviousTeam uint64
  prefs: []
  type: TYPE_NORMAL
- en: Photo   []byte
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: type HistoricalData struct {
  prefs: []
  type: TYPE_NORMAL
- en: Year          uint8
  prefs: []
  type: TYPE_NORMAL
- en: LeagueResults []Match
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: type Match struct {
  prefs: []
  type: TYPE_NORMAL
- en: Date          time.Time
  prefs: []
  type: TYPE_NORMAL
- en: VisitorID     uint64
  prefs: []
  type: TYPE_NORMAL
- en: LocalID       uint64
  prefs: []
  type: TYPE_NORMAL
- en: LocalScore    byte
  prefs: []
  type: TYPE_NORMAL
- en: VisitorScore  byte
  prefs: []
  type: TYPE_NORMAL
- en: LocalShoots   uint16
  prefs: []
  type: TYPE_NORMAL
- en: VisitorShoots uint16
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: type teamFlyweightFactory struct {
  prefs: []
  type: TYPE_NORMAL
- en: createdTeams map[string]*Team
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func (t *teamFlyweightFactory) GetTeam(name string) *Team {
  prefs: []
  type: TYPE_NORMAL
- en: return nil
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func (t *teamFlyweightFactory) GetNumberOfObjects() int {
  prefs: []
  type: TYPE_NORMAL
- en: return 0
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: func TestTeamFlyweightFactory_GetTeam(t *testing.T) {
  prefs: []
  type: TYPE_NORMAL
- en: factory := teamFlyweightFactory{}
  prefs: []
  type: TYPE_NORMAL
- en: teamA1 := factory.GetTeam(TEAM_A)
  prefs: []
  type: TYPE_NORMAL
- en: if teamA1 == nil {
  prefs: []
  type: TYPE_NORMAL
- en: t.Error("The pointer to the TEAM_A was nil")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: teamA2 := factory.GetTeam(TEAM_A)
  prefs: []
  type: TYPE_NORMAL
- en: if teamA2 == nil {
  prefs: []
  type: TYPE_NORMAL
- en: t.Error("The pointer to the TEAM_A was nil")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if teamA1 != teamA2 {
  prefs: []
  type: TYPE_NORMAL
- en: t.Error("TEAM_A pointers weren't the same")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if factory.GetNumberOfObjects() != 1 {
  prefs: []
  type: TYPE_NORMAL
- en: 't.Errorf("The number of objects created was not 1: %d\n", factory.GetNumberOfObjects())'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: $ go test -v -run=GetTeam .
  prefs: []
  type: TYPE_NORMAL
- en: === RUN   TestTeamFlyweightFactory_GetTeam
  prefs: []
  type: TYPE_NORMAL
- en: '--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s)'
  prefs: []
  type: TYPE_NORMAL
- en: 'flyweight_test.go:11: The pointer to the TEAM_A was nil'
  prefs: []
  type: TYPE_NORMAL
- en: 'flyweight_test.go:21: The pointer to the TEAM_A was nil'
  prefs: []
  type: TYPE_NORMAL
- en: 'flyweight_test.go:31: The number of objects created was not 1: 0'
  prefs: []
  type: TYPE_NORMAL
- en: FAIL
  prefs: []
  type: TYPE_NORMAL
- en: exit status 1
  prefs: []
  type: TYPE_NORMAL
- en: FAIL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: func (t *teamFlyweightFactory) GetTeam(teamID int) *Team {
  prefs: []
  type: TYPE_NORMAL
- en: if t.createdTeams[teamID] != nil {
  prefs: []
  type: TYPE_NORMAL
- en: return t.createdTeams[teamID]
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: team := getTeamFactory(teamID)
  prefs: []
  type: TYPE_NORMAL
- en: t.createdTeams[teamID] = &team
  prefs: []
  type: TYPE_NORMAL
- en: return t.createdTeams[teamID]
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: func getTeamFactory(team int) Team {
  prefs: []
  type: TYPE_NORMAL
- en: switch team {
  prefs: []
  type: TYPE_NORMAL
- en: 'case TEAM_B:'
  prefs: []
  type: TYPE_NORMAL
- en: return Team{
  prefs: []
  type: TYPE_NORMAL
- en: 'ID:   2,'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: TEAM_B,'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  prefs: []
  type: TYPE_NORMAL
- en: return Team{
  prefs: []
  type: TYPE_NORMAL
- en: 'ID:   1,'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: TEAM_A,'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: func (t *teamFlyweightFactory) GetNumberOfObjects() int {
  prefs: []
  type: TYPE_NORMAL
- en: return len(t.createdTeams)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: $ go test -v -run=GetTeam .
  prefs: []
  type: TYPE_NORMAL
- en: === RUN   TestTeamFlyweightFactory_GetTeam
  prefs: []
  type: TYPE_NORMAL
- en: '--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s)'
  prefs: []
  type: TYPE_NORMAL
- en: 'panic: assignment to entry in nil map [recovered]'
  prefs: []
  type: TYPE_NORMAL
- en: 'panic: assignment to entry in nil map'
  prefs: []
  type: TYPE_NORMAL
- en: 'goroutine 5 [running]:'
  prefs: []
  type: TYPE_NORMAL
- en: panic(0x530900, 0xc0820025c0)
  prefs: []
  type: TYPE_NORMAL
- en: /home/mcastro/Go/src/runtime/panic.go:481 +0x3f4
  prefs: []
  type: TYPE_NORMAL
- en: testing.tRunner.func1(0xc082068120)
  prefs: []
  type: TYPE_NORMAL
- en: /home/mcastro/Go/src/testing/testing.go:467 +0x199
  prefs: []
  type: TYPE_NORMAL
- en: panic(0x530900, 0xc0820025c0)
  prefs: []
  type: TYPE_NORMAL
- en: /home/mcastro/Go/src/runtime/panic.go:443 +0x4f7
  prefs: []
  type: TYPE_NORMAL
- en: /home/mcastro/go-design-patterns/structural/flyweight.(*teamFlyweightFactory).GetTeam(0xc08202fec0,
    0x0, 0x0)
  prefs: []
  type: TYPE_NORMAL
- en: /home/mcastro/Desktop/go-design-patterns/structural/flyweight/flyweight.go:71
    +0x159
  prefs: []
  type: TYPE_NORMAL
- en: /home/mcastro/go-design-patterns/structural/flyweight.TestTeamFlyweightFactory_GetTeam(0xc082068120)
  prefs: []
  type: TYPE_NORMAL
- en: /home/mcastro/Desktop/go-design-patterns/structural/flyweight/flyweight_test.go:9
    +0x61
  prefs: []
  type: TYPE_NORMAL
- en: testing.tRunner(0xc082068120, 0x666580)
  prefs: []
  type: TYPE_NORMAL
- en: /home/mcastro/Go/src/testing/testing.go:473 +0x9f
  prefs: []
  type: TYPE_NORMAL
- en: created by testing.RunTests
  prefs: []
  type: TYPE_NORMAL
- en: /home/mcastro/Go/src/testing/testing.go:582 +0x899
  prefs: []
  type: TYPE_NORMAL
- en: exit status 2
  prefs: []
  type: TYPE_NORMAL
- en: FAIL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: t.createdTeams[teamName] = &team
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: factory := teamFlyweightFactory{
  prefs: []
  type: TYPE_NORMAL
- en: 'createdTeams: make(map[int]*Team,0),'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: func NewTeamFactory() teamFlyweightFactory {
  prefs: []
  type: TYPE_NORMAL
- en: return teamFlyweightFactory{
  prefs: []
  type: TYPE_NORMAL
- en: 'createdTeams: make(map[int]*Team),'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: func TestTeamFlyweightFactory_GetTeam(t *testing.T) {
  prefs: []
  type: TYPE_NORMAL
- en: factory := NewTeamFactory()
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: $ go test -v -run=GetTeam .
  prefs: []
  type: TYPE_NORMAL
- en: === RUN   TestTeamFlyweightFactory_GetTeam
  prefs: []
  type: TYPE_NORMAL
- en: '--- PASS: TestTeamFlyweightFactory_GetTeam (0.00s)'
  prefs: []
  type: TYPE_NORMAL
- en: PASS
  prefs: []
  type: TYPE_NORMAL
- en: ok
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: func Test_HighVolume(t *testing.T) {
  prefs: []
  type: TYPE_NORMAL
- en: factory := NewTeamFactory()
  prefs: []
  type: TYPE_NORMAL
- en: teams := make([]*Team, 500000*2)
  prefs: []
  type: TYPE_NORMAL
- en: for i := 0; i < 500000; i++ {
  prefs: []
  type: TYPE_NORMAL
- en: teams[i] = factory.GetTeam(TEAM_A)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: for i := 500000; i < 2*500000; i++ {
  prefs: []
  type: TYPE_NORMAL
- en: teams[i] = factory.GetTeam(TEAM_B)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if factory.GetNumberOfObjects() != 2 {
  prefs: []
  type: TYPE_NORMAL
- en: 't.Errorf("The number of objects created was not 2: %d\n",factory.GetNumberOfObjects())'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: $ go test -v -run=Volume .
  prefs: []
  type: TYPE_NORMAL
- en: === RUN   Test_HighVolume
  prefs: []
  type: TYPE_NORMAL
- en: '--- PASS: Test_HighVolume (0.04s)'
  prefs: []
  type: TYPE_NORMAL
- en: PASS
  prefs: []
  type: TYPE_NORMAL
- en: ok
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: for i:=0; i<3; i++ {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("Pointer %d points to %p and is located in %p\n", i, teams[i], &teams[i])
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Pointer 0 points to 0xc082846000 and is located in 0xc082076000
  prefs: []
  type: TYPE_NORMAL
- en: Pointer 1 points to 0xc082846000 and is located in 0xc082076008
  prefs: []
  type: TYPE_NORMAL
- en: Pointer 2 points to 0xc082846000 and is located in 0xc082076010
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: What it tells us is that the first three positions in the map point to the same
    location, but that we actually have three different pointers, which are, effectively,
    much lighter than our team object.
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference between Singleton and Flyweight then?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, the difference is subtle but it's just there. With the Singleton pattern,
    we ensure that the same type is created only once. Also, the Singleton pattern
    is a Creational pattern. With Flyweight, which is a Structural pattern, we aren't
    worried about how the objects are created, but about how to structure a type to
    contain heavy information in a light way. The structure we are talking about is
    the `map[int]*Team` structure in our example. Here, we really didn't care about
    how we created the object; we have simply written an uncomplicated the `getTeamFactory` method
    for it. We gave major importance to having a light structure to hold a shareable
    object (or objects), in this case, the map.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen several patterns to organize code structures. Structural patterns
    are concerned about how to create objects, or how they do their business (we'll
    see this in the behavioral patterns).
  prefs: []
  type: TYPE_NORMAL
- en: Don't feel confused about mixing several patterns. You could end up mixing six
    or seven quite easily if you strictly follow the objectives of each one. Just
    keep in mind that over-engineering is as bad as no engineering at all. I remember
    prototyping a load balancer one evening, and after two hours of crazy over-engineered
    code, I had such a mess in my head that I preferred to start all over again.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll see behavioral patterns. They are a bit more complex,
    and they often use Structural and Creational patterns for their objectives, but
    I'm sure that the reader will find them quite challenging and interesting.
  prefs: []
  type: TYPE_NORMAL
