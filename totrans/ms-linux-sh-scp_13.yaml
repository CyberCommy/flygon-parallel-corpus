- en: Chapter 13. Using Perl as a Bash Scripting Alternative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scripting with bash can help you with the automation of tasks and you can achieve
    a great deal by mastering bash scripting. However, your journey should not end
    with bash. While we have seen the power available in your bash scripts, we are
    limited by the commands we can run and the options they have. Bash scripts allow
    us to access commands; whereas, if we use Perl scripts, we have access to the
    programming interfaces or the APIs of the system. In this way, we can often achieve
    more with fewer resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce Perl scripting and some other basic scripts
    that we can use to learn Perl; we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Perl?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays in Perl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional tests in Perl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Perl?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perl is a scripting language that was developed in the 1980's by Larry Wall
    to extend the functionality of `sed` and `awk`. It is an acronym for **Practical
    Extraction and Reporting Language** but has grown far bigger than its original
    purpose and today it is available on Unix, Linux, OS X, and Windows operating
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although, it is a scripting language, it is not shell scripting; as such there
    is no Perl shell. This means that the code has to be executed via Perl scripts
    and not directly from the command line. The exception to this is the `-e` option
    to the `perl` command that can allow you to execute a `perl` statement. For example,
    we can use the following command line to print the ubiquitous `Hello World`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find that Perl is installed by default on most Linux and Unix systems
    as many programs will make use of Perl in their code. To check the version of
    Perl that you have installed on your system you can use the `perl` command, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command is shown in the following screenshot from my Raspberry
    Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is Perl?](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, Perl in uppercase will refer to the language and `perl` in
    lowercase will refer to the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create a Perl script, just like bash it will be an interpreted language
    and the first line will be the shebang, so that the system knows which command
    is to be used to read the script. The /`usr/bin/perl` command can be used to locate
    `perl` often. To verify this, you may use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Unlike bash, when the `perl` command reads the script it will optimize the script
    at runtime; one simple feature that this will enable is that we can define the
    functions at the end of the script, rather than before they are used. We will
    see this as we look at the Perl script in more detail, as we work through this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a simple Perl script, we can use the text editor of choice. For short
    scripts `vi` or `vim` works well, as does `gedit` if you want to work in GUI.
    For larger projects an IDE may help. Often, the IDE will allow you to change the
    object name easily throughout the script and provide expansion of object names.
    In this chapter, we will make use of very simple scripts so we will continue to
    use `vi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a `$HOME/bin/hello.pl` file to produce the output we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The file still needs to be in a directory within our `PATH` variable; hence,
    we create `$HOME/bin`. If it is not in the `PATH` variable then we will need to
    specify the full or relative path of the file, as with bash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file will need to be set with the execute permission. We can do this with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the script with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the code that we have added is the same as the one we ran the
    earlier `perl -e` command with. The only difference is the shebang. This is also
    quite similar to bash. We now use the print function rather than using the `echo`
    command. Bash scripts run a series of commands, whereas Perl scripts run functions.
    The print function does not automatically add a new line so we add it ourselves
    using the `\n` character. We can also see that the Perl uses the semi-colon to
    terminate a line of code. The shebang is not a line of code, whereas the print
    line is terminated with a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are using Perl version 5.10 or later, on the Pi we have seen that it
    is 5.14 and we can also make use of a function `say`. Similar to the `print` command,
    this is used to display output but it also includes the newline. We have to enable
    this feature, which is managed by the `use` keyword. Either of the following scripts
    will print `Hello World` using the `say` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `say` function also simplifies the printing of files and lists.
  prefs: []
  type: TYPE_NORMAL
- en: Perl arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something that we can make use of in Perl is an array. These arrays are variables
    that are created from lists; put simply, they are basically multi-valued variables.
    If we were to use a container analogy to describe a variable, it will be either
    a cup or a placeholder for one value. An array will be analogous to a crate. We
    can describe the crate with a single name but we have to include additional naming
    elements to access each slot within the crate. A crate can hold more than a single
    item, just like an array.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that by using bash scripting we can pass command line arguments in the
    script. The arguments were using their own variable name, `$1`, `$2`, and so on.
    This also clashed with the name of the program, to a degree, because of the fact
    that it was `$0`. Even though they may appear similar, there is no logical relationship
    between `$0` and `$1`. The `$0` variable is the name of the script and `$1` is
    the first argument. When we look at this in Perl, we can start to see some of
    the major differences.
  prefs: []
  type: TYPE_NORMAL
- en: Program name?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The program name in Perl can still be accessed with the `$0` variable. We can
    see this in the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, even though we think of `$0` as quite simple to use, as we have accessed
    it in bash before, if we approach this with fresh eyes it is not so obvious. Perl
    has a module called `English` where we have some more friendly names defined for
    many other variables used in Perl. If we take a look at the following script we
    can see this in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The line `use` `English`; will import the module that redefines `$0` so that
    it can be referenced as `$PROGRAM_NAME`. Although, this requires more typing it
    also acts as a better name documenting its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Argument arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than using `$1`, `$2,` and so on for the arguments; Perl now uses a list
    of arguments stored in a single array variable. The array name is `@ARGV` and
    we can access each argument supplied by this in the index number or slot number.
    The computers start counting at `0`, so the first argument will be `$ARGV[0]`,
    the second will be `$ARGV[1]`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An index array is named using the `@` symbol. Each element of the array is still
    a single or scalar variable and just like in bash, they are read with the `$`
    symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at the following script, `$HOME/bin/args.pl`, we can see how to
    make the Hello script more portable by accepting arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this in action by running the script, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Argument arrays](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Counting elements in an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can see that the command-line arguments are stored in the `@ARGV` array.
    We can count the number of arguments or, in fact, the elements in any array using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So instead of using the `$#` to count the supplied arguments, we will use the
    code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add this to our script, it will be seen, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also take a note from the previous code block that we can concatenate
    the output of a command with a test using the period character.
  prefs: []
  type: TYPE_NORMAL
- en: Looping through an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In bash, we have a simple mechanism with `$*` to refer the list of arguments
    supplied to a script. In Perl, this is just a little different from having to
    loop through the list. However, the `foreach` keyword is built for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the code is defined within the loop and is contained using the
    brace brackets. If you recall, bash did not specifically have a `foreach` keyword
    and it made use of `do` and `done` to constrain the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we implement this code in the `$HOME/bin/forargs.pl` file, we can execute
    it as a code similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looping through an array](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have relied on the `@ARGV` system array and this has proved to be
    a great way to learn how to access and array. We now need to see how to create
    arrays of our own design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays are lists of values that can store mixed data types; so, there is no
    reason why we cannot have an array that stores both strings and numbers. The order
    in which the items are supplied to the array will set their index position. In
    other words, the first item in the list will be the first index or index `0` in
    the array. Consider the following code: `$HOME/bin/array.pl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we should notice is that when we are setting a variable of any
    type, including an array, we will use the designator for the variable type. We
    see here that the use of `@user = …`, will make use of the `@` symbol as previously
    mentioned to denote that the variable is an array variable. If we were setting
    a scalar variable similar to the ones we use in bash, we will set `$user`. In
    bash, we do not use the designator when setting a variable and we cannot have
    spaces surrounding the assignment operator, `=`. Perl will allow the spaces and
    aids in the readability with an extra whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we should notice that the list contains strings and an integer. This is
    perfectly acceptable and the array can hold different data types. A single name
    of the array makes sense, as we can now store related data into one object.
  prefs: []
  type: TYPE_NORMAL
- en: The final point to take note of in the supplied code is that we can easily concatenate
    the string values with integer values using Perl. There is no need to provide
    any form of data translation. Within the single string, we print the first name,
    last name, and age of the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'On script execution, we should receive an output, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating arrays](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Conditional statements in Perl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the rest of the Perl language, we will have similarities with bash
    scripting and some completely new ways of implementing conditions. This will often
    work in our favor; thus, making the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing command line lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we do not have the command line list logic, which we use in bash and
    we do not make use of the `&&` and `||`. Instead of these rather weird looking
    symbols, the conditional logic for single statements in Perl is written in the
    following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first example, we exit with an error code of `2`, if we have supplied
    less than one command-line argument. The bash equivalent to this will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second example, we will only print the `hello` statement if we have
    supplied arguments. This will be written in bash, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Personally, I like Perl; the way as it at least uses words, so we may understand
    what is happening even if we have not come across the symbols before.
  prefs: []
  type: TYPE_NORMAL
- en: If and unless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within Perl, as we have already seen in the previous examples, we can make use
    of negative logic using `unless`. We both have the traditional `if` keyword and
    now `unless` is an addition. We can use these in our short code, as we have seen
    or in complete blocks of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can edit the existing `args.pl` to create a new file: `$HOME/bin/ifargs.pl`.
    The file should read similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code now has an additional argument, which we have declared and set with
    the line that reads `my $count = scalar @ARGV;`. We used this value as a condition
    for the `if` statement. The block of code constrained in the brace brackets will
    execute only if the condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'We demonstrate the running of this program with and without arguments in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![If and unless](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can write a similar code using `unless`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code in the brackets now runs only if the condition is false. In this case,
    if we have not supplied arguments, the code will not run.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions within Perl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with all languages, the ability to encapsulate a code within functions can
    make the code more readable and ultimately results in easier to manage codes,
    with less number of lines. Unlike bash, the functions in Perl can be defined after
    they are referenced in the code and we often choose to define the functions at
    the end of the script.
  prefs: []
  type: TYPE_NORMAL
- en: Prompt for user input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen the use of command-line arguments in Perl; now, let''s take a
    look at prompting for user input. This becomes a great way to encapsulate the
    code to execute and store the prompt within a function. First of all, we will
    look at a simple script that prompts for the username and then we will modify
    it to include the function. We will create the `$HOME/bin/prompt.pl` file to read,
    as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In line 2, we have declared the variable using `my`. The keyword `my` defines
    the variable with a local scope. In other words, it is local to the block of code
    that it is created within. As this has been created in the main body of the script,
    the variable is available to the entire script. The line declares the variable
    but we do not set the value at this time. Perl does not force you to declare the
    variables, but it is a good idea and a great practice. In fact, we can tell Perl
    to enforce this with the use of the `use strict;` line. We can implement this,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we are forced to declare the variables and the code will
    fail if they are not. The idea behind this is to help troubleshooting by identifying
    misspelled variables later in the code. Try deleting the line starting with `my`
    and re-executing the code; it will fail. Similarly, we can make use of the `use
    warnings;` line, to warn us if we have used a variable only once.
  prefs: []
  type: TYPE_NORMAL
- en: We prompt for the user name and do not use a newline here. We want the prompt
    to be on the same line with the one the user will enter the data into. The function
    `chomp` is great isn't it? This function will remove or chomp the newline from
    the input that we submit. We will need to use the *Enter* key to submit the data
    and `chomp` removes the newline for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are currently only prompting for a user name, so we need just one prompt
    but we could easily ask for a first name and last name. Rather than writing the
    code for the prompt each time, we can create a function. These are defined using
    the keyword `sub`, as we can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `prompt_user` function takes a single argument, which will become the message
    to display with the prompt. For the reference to the argument, we use the system
    array `@_` and index `0`. This is written as `$_[0]`. If we remember, arrays are
    multi-valued and each entry in the array is a scalar variable. Within the function,
    we use the function return to send the value that the user has set back to the
    calling code. We can see that the main code block is simpler now with the code
    for the prompt being abstracted into a function. When we look at this, we may
    think that it took a lot of work, but when we look at adding it in a prompt for
    a first name and last name, it is now much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions are good things to use and hopefully the following code will help
    you see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So this concludes our whirlwind tour and the introduction to Perl. We have seen
    the similarities with bash, as well as, the new features and differences. The
    main points to take from this are that once you become proficient in one language
    it becomes easier to learn other coding languages.
  prefs: []
  type: TYPE_NORMAL
- en: To keep us in the mood of learning new languages, we will now take a quick tour
    of Python in the next chapter.
  prefs: []
  type: TYPE_NORMAL
