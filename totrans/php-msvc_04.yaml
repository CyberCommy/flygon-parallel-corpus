- en: Chapter 4.  Testing and Quality Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at the different testing methodologies that you
    can use before, during, and after the development process. As you will know, testing
    your application avoids future issues and gives you a better project overview.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of using tests in your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very important to use testing in our application because these steps can
    avoid (or at least reduce) future problems or errors that can appear as we are
    humans and can make mistakes during the development process or because the structure
    of the project is not correct or even the understanding of the developer does
    not match the requirements of the customer.
  prefs: []
  type: TYPE_NORMAL
- en: The testing process will help improve the code quality and understanding of
    the functionalities, do regression testing in order to avoid the inclusion of
    old issues in continuous integration and reduce the time taken to finish the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing is used to reduce the fails or errors in our application. Development
    teams spend a lot of time doing bug fixing and, depending on the moment of the
    discovery of the bugs, the impact can be bigger or smaller. The following image
    shows the relative cost of bug fixing related to the stage of the development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The importance of using tests in your application](graphics/B06142_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reason for using testing methodologies in development is that we can find
    errors in our code in the early steps of the development so that we will spend
    less time doing bug fixing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The challenge of testing an application based on microservices is not in the
    testing of every single microservice, but on the integration and data consistency.
    An application based on microservices will need a better understanding of the
    architecture of microservices and their workflow by the developers to be able
    to use testing on it. This is because it is necessary to check the information
    and also the functionality of every microservice at all the points of communication
    between the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing to use on microservices are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: In all the applications based on microservices or even in
    a monolithic one, it is necessary to use unit testing. Using it, we will check
    the necessary functionality of the methods or code modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: Unit testing only checks the isolated components,
    so we also need to check the behavior between methods. We will check the behavior
    between methods of the same microservice using integration testing, so the calls
    between microservices will need to be mocked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API tests**:The microservices architecture depends on the communication between
    them. For each microservice, it is necessary to establish an API; this is like
    a *contract* to use that microservice. With this kind of test, we will check that
    the contract is working for each microservice and all the microservices are working
    with each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end tests**:These guarantee the application quality without any mockup method
    or call. A test will be run to assess the functionality between all the required
    microservices. There are some rules to avoid problems during these tests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end tests are difficult to maintain, so only test the most important
    functionalities; the rest of them use unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user functionalities can be tested by simulating calls to the microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is necessary to keep a clean environment to test it because the tests are
    very dependent on the data, so a previous test can manipulate the data and then,
    the next test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we know how to proceed with testing our application based on microservices,
    we will look at some strategies to do so during development.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Test-driven development** (**TDD**) is part of agile philosophy, and it appears
    to solve the common developer''s problem that shows when an application is evolving
    and growing and the code is getting sick. The developers fix the problems to make
    it run but every single line that we add can be a new bug and it can even break
    other functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TDD is a learning technique that helps the developer to learn about the domain
    problem of the application they will build, doing it in an iterative, incremental,
    and constructivist way:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterative** because the technique always repeats the same process to get
    a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incremental** because for each iteration, we have more unit tests to be used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructivist** because it is possible to test everything we are developing
    during the process straightaway so that we can get immediate feedback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, when we finish developing each unit test or iteration, we can forget it
    because it will be kept throughout the entire development process, helping us
    to remember the domain problem through the unit test. This is a good approach
    for forgetful developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very important to understand that TDD includes four things: analysis,
    design, development, and testing. In other words, doing TDD is understanding the
    domain problem and correctly analyzing the problem, designing the application
    well, developing well, and testing it. It needs to be clear; TDD is not just about
    implementing unit tests, but the whole process of the software development.'
  prefs: []
  type: TYPE_NORMAL
- en: TDD perfectly matches projects based on microservices, because using microservices
    in a large project is dividing it into little microservices, our functionalities are like
    an aggrupation of little projects connected by a communication channel. The project
    size is independent of using TDD because, in this technique, you divide each functionality
    into little examples and, to do this, it does not matter whether the project is
    big or small, and even less when our project is divided by microservices. Also,
    microservices are still better than a monolithic project because the functionalities
    for the unit tests are organized in microservices and it will help the developers
    to know where they can begin to use TDD.
  prefs: []
  type: TYPE_NORMAL
- en: How to do TDD?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Doing TDD is not difficult, we just need to follow some steps and repeat them
    by improving our code and checking that we did not break anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write the unit test**: It needs to be the simplest and clearest test possible,
    and once it is done it has to fail; this is mandatory, if it does not fail, it
    means that there is something we are not doing properly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Run the tests**: If it has errors (it fails), this is the moment to develop
    the minimum code to pass the test; just do what is necessary, do not code additional
    things. Once you develop the minimum code to pass the test, run the test again;
    if it passes go to the next step, if not fix it and run the test again.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Improve the test**: If you think it is possible to improve the code you wrote,
    do it and run the tests again. If you think it is perfect, write a new unit test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following image illustrates the mantra of TDD--**RED**, **GREEN**, **REFACTOR**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do TDD?](graphics/B06142_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To do TDD, it is necessary to write the tests before implementing the function;
    if the implementation is started and then the tests are written, it is not TDD,
    it is just testing.
  prefs: []
  type: TYPE_NORMAL
- en: If we create the unit tests after we start developing our application, we are
    doing the classic testing and we are not taking advantage of the TDD benefits.
    Having your unit tests in place will help you ensure that your abstract idea of
    the domain problem is correct throughout the developing process.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, doing testing is always better than not doing it, but doing TDD is
    still better than doing just classic testing.
  prefs: []
  type: TYPE_NORMAL
- en: Why should I use TDD?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TDD is the answer to questions such as "where shall I begin?", "how can I do
    it?", "how can I write code that can be modified without breaking anything?", and
    "how can I know what I have to implement?".
  prefs: []
  type: TYPE_NORMAL
- en: The goal is not to write many unit tests without sense, but to design TDD properly
    following the requirements. In TDD, we do not to think about implementing functions,
    but about good examples of the functions related to the domain problem in order
    to remove the ambiguity created by the domain problem.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we should reproduce a specific function or case of use in X
    examples by doing TDD until we get the necessary examples to describe the function
    or task without ambiguity or misinterpretations.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TDD can be the best way to document your application.
  prefs: []
  type: TYPE_NORMAL
- en: Using other methodologies of software development, we start thinking about how
    the architecture will be, what pattern will be used, how the communication between
    microservices will be, but what happens if once we have planned all this, we realize
    that it is not necessary? How much time will pass until we realize that? How much
    effort and money will we spend?
  prefs: []
  type: TYPE_NORMAL
- en: TDD defines the architecture of our application by creating little examples
    in many iterations until we realize what is the architecture. The examples will
    slowly show us the steps to follow in order to define what the best structure,
    pattern, or tools to use are, so that we avoid spending resources during the first
    stages of our application.
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean that we are working without an architecture. Obviously, we
    have to know whether our application will be a website or a mobile app and use
    a proper framework (you can research which framework fits your needs in [Chapter
    2](ch02.html "Chapter 2. Development Environment"), *Development Environment*),
    and also know what the interoperability in the application will be; in our case,
    it will be an application based on microservices. So, it will give us support
    to start creating the first unit tests. TDD will be our guideline to develop an
    application and it will produce an architecture without ambiguity from the unit
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'TDD is not cure-all; in other words, it does not give the same results to a
    senior and junior developer, but it is useful for the whole team. Let''s look
    at some advantages of using TDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code reuse**: This creates every functionality with only the necessary code
    to pass the tests in the second stage (Green). It allows you to see whether there
    are more functions using the same code structure or parts of a specific function;
    so, it helps you to reuse the code you wrote earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Teamwork is easier**: It allows you to be confident with your team colleagues.
    Some architects or senior developers do not trust developers with poor experience,
    and they need to check their code before committing the changes, creating a bottleneck at
    that point, so TDD helps us to trust the developers with less experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increases the communication**: It increases the communication between team
    colleagues. The communication is more fluent, so the team share their knowledge
    about the project reflected on the unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid overdesign**: Do not overdesign the application in the first stages.
    As we said before, doing TDD allows you to have an overview of the application
    little by little, avoiding creating useless structures or patterns in your project
    that you will maybe trash in the future stages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit tests are the best documentation**: The best way to give a good point
    of view of a specific functionality is by reading its unit test, which helps us
    understand how it works instead of human words.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allows to discover more use cases** in the design stage: In every test you
    have to create, you will understand how the functionality should work better and
    all the possible stages that a functionality can have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increases the feeling of a job well done**: In every commit of your code,
    you will have the feeling that it was done properly because the rest of the unit
    tests pass without errors, so you will not be worried about breaking other functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increases the software quality**: During the refactoring step, we spend our
    efforts in making the code more efficient and maintainable, verifying that the
    whole project still works properly after the changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The technical concepts and steps to follow the TDD algorithm are easy and clear,
    and the proper way to make it happen improves by practicing it. As we saw before,
    there are only three steps: red, green, and refactor.'
  prefs: []
  type: TYPE_NORMAL
- en: Red - writing the unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to write a test even when the code is not written, you just need
    to think about whether it is possible to write a specification before implementing
    it. So, in the first step, you should consider that the unit test you start writing
    is not like a unit test but like an example or specification of the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In TDD, this example or specification is not fixed; in other words, the unit
    test can be modified in the future. Before beginning to write the first unit test,
    it is necessary to think about how the **software under test** (**SUT**) will
    be, and just a little about how it will work. We need to think about how it will
    be the SUT code and how we will check that it works the way we want it to.
  prefs: []
  type: TYPE_NORMAL
- en: The way that TDD works drives us to firstly design what is more comfortable
    and clear if it fits the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Green - make the code work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the example is written, we have to code the minimum to make it pass the
    test; in other words, set the unit test to green. It does not matter if the code
    is ugly and not optimized, it will be our task in the next steps and iterations.
  prefs: []
  type: TYPE_NORMAL
- en: In this step, the important thing is only to write the necessary code for the
    requirements, without unnecessary things. It does not mean writing without thinking
    about the functionality, but thinking about it to be efficient. It looks easy,
    but you will realize that you will write extra code the first time.
  prefs: []
  type: TYPE_NORMAL
- en: If you concentrate on this step, you will think of new questions about the SUT
    behavior with different entries. However, you should be strong and avoid writing
    extra code about other functionalities related to the current one. As a rule of
    thumb, instead of coding the new features, take notes so you can convert them
    into functionalities in future iterations.
  prefs: []
  type: TYPE_NORMAL
- en: Refactor - eliminate redundancy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refactoring is not the same as rewriting code. You should be able to change
    the design without changing the behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In this step, you should remove the duplicity in your code and check whether
    the code matches the principles of the good practices, thinking about the efficiency,
    clarity, and the future maintainability of the code. This part depends on the
    experience of each developer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key to good refactoring is doing it in small steps.
  prefs: []
  type: TYPE_NORMAL
- en: To refactor a functionality, the best way to do it is to change a little part
    and execute all the available tests, and if they pass, continue with another little
    part until you are happy with the obtained result.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Behavior-driven development** (**BDD**) is a process that broadens the TDD
    technique and mixes it with other design ideas and business analysis provided
    to the developers in order to improve the software development.'
  prefs: []
  type: TYPE_NORMAL
- en: In BDD, we test the scenarios and the class's behavior in order to meet the
    scenarios that can be composed by many classes.
  prefs: []
  type: TYPE_NORMAL
- en: It is very useful to use a DSL in order to have a common language to be used
    by the customer, project owner, business analyst, or developers. The goal is to
    have a ubiquitous language as we saw in [Chapter 3](ch03.html "Chapter 3. Application
    Design"), *Application Design*, in the domain-driven design section.
  prefs: []
  type: TYPE_NORMAL
- en: What is BDD?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said before, BDD is an agile technique based on TDD and ATDD, promoting
    the collaboration between the entire team of a project.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of BDD is that the entire team understands what the customer wants,
    and the customer knows what the rest of the team understood from their specifications.
    Most of the times, when a project starts, developers don't have the same point
    of view as the customer, and during the development process the customer realizes
    that maybe they did not explain it or maybe the developer did not understand it
    properly, so it adds more time to change the code to meet the customer's needs.
  prefs: []
  type: TYPE_NORMAL
- en: So, BDD is writing test cases in human language using rules or a ubiquitous
    language so that the customer and developers can understand it. It also defines
    a DSL for the tests.
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is necessary to define the features as user stories (we will explain what
    this is in the ATDD section of this chapter) and examine their acceptance criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user story is defined, we have to focus on the possible scenarios that
    describe the project behavior for a concrete user or situation using DSL. The
    steps are: given (context), when (event occurs), and then (outcome).'
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, the defined scenario for a user story gives the acceptance criteria
    to check whether the feature is done.
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber as DSL for BDD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cucumber is a DSL tool that executes examples made in plain text as automatic
    tests, taking advantage of the benefits of BDD and bringing together the business
    layer and the technology in a project in order to know what are the functionalities
    most valued by the user and develop them at the same time that we are defining
    the case tests and documenting the project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most important thing for Cucumber is having the same point of understanding
    between developers and customers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Gherkin** is the language that Cucumber uses, and it allows you to translate
    the specifications of the project into a near human language so that the customer
    or other people without technical skills can understand it. This tool and language
    can be used for BDD and ATDD. Let''s look at a piece of sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to define the software behavior without saying how it is implemented.
    Also, it allows us to document the functionalities at the same time we write the
    case automatic tests. The advantages of using Cucumber are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to parse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to discuss
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DSL has three steps in the code that the tool understands and processes; they
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Given**: This is the necessary step to set the system in the proper status
    to check the tests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**When**: This is the necessary step to be carried out by the user to action
    the functionality.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Then**: This refers to the things that change in the system. Here, we are
    able to see if it does what we want.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, there are two more available optional steps: **And** and **But**, and
    they can be used in **Given** or **Then** when you need more than a sentence to
    match the requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to use a tool, called Selenium, to do BDD.
    It is another DSL tool but is oriented to web development instead of plain text.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance test-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maybe the most important methodology in a project is the **Acceptance Test-Driven
    Development** (**ATDD**) or **Story Test-Driven Development** (**STDD**); it is
    TDD but on a different level.
  prefs: []
  type: TYPE_NORMAL
- en: The acceptance (or customer) tests are the written criteria that the project
    meets the business requirements that the customer demands. They are examples (like
    the examples in TDD) written by the project owner. It is the beginning of the
    development for each iteration, the bridge between scrum and agile development.
  prefs: []
  type: TYPE_NORMAL
- en: In ATDD, we start the implementation of our project in a different way to the
    traditional methodologies. The business requirements written in human language
    are replaced by executables agreed by some team members and the customer. It is
    not about replacing the whole documentation, but only part of the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of using ATDD are as mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides real examples and a common language for the team to understand the
    domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows us to identify the domain rules properly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to know if a user story is finished in each iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The workflow works from the first steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development does not start until the tests are defined and accepted by the
    team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User stories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user stories of ATDD are like use cases in terms of name or description,
    but work in a different way. A user story does not define the requirement, avoiding
    the problem of ambiguity of the human language. The goal is to communicate the
    idea without problems for the rest of the team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each user story is a list of clear and concise examples about what the customer
    wants from the application. The name of the story is a sentence of human language
    defining what the function must do. Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Search available secrets around our position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the secrets we already have stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check who is the winner in a battle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have the goals of listening to the customers and helping them define what
    they expect from the application. The user stories should be clear without ambiguity
    and should be written in human language, not in technical language; the customer
    should understand what they say.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined a user story, some questions appear and they should be
    answered by associating acceptance tests for each story. For example, for the
    *Check who is the winner in a battle* story, some possible questions are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if they draw?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the winner win?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the loser lose?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long does a battle take?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the possible acceptance tests are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If they draw, no one will win or lose anything; they will keep their secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The winner will earn 10 points and get a secret from the loser's pocket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loser will give a secret to the winner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A battle takes three throws of a dice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe the questions and answers from a user story will generate new user stories
    to be added to the backlog.
  prefs: []
  type: TYPE_NORMAL
- en: ATDD algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithm of ATDD is like the TDD, but reaches more people than the developers.
    In other words, doing ATDD, the tests of each story are written in a meeting that
    includes the project owners, developers, and QA technicians because the team must
    understand what is necessary to do and why it is necessary so that they can see
    if it is what the code should do. The following image shows the ATDD cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ATDD algorithm](graphics/B06142_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Discuss
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The starting point of the ATDD algorithm is the discussion. In this step, the
    business has a meeting with the customer to clarify how the application should
    work and the analyst should create the user stories from that conversation. Also,
    they should be able to explain the conditions of satisfaction of every user story
    in order to be translated into examples as we explained earlier, in the user stories
    section.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the meeting, the examples should be clear and concise so that
    we can get a list of examples of user stories to cover all the needs that the
    customer reviewed and understood for himself. Also, the team will have a project
    overview in order to understand the business value of the user story, and in case
    the user story was too big, it can be divided into little user stories, getting
    the first one for the first iteration of this process.
  prefs: []
  type: TYPE_NORMAL
- en: Distill
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The high level acceptance tests are written by the customer and the development
    team. In this step, the writing of the test cases that we got from the examples
    in the discussion step begins and the team can take part in the discussion and
    help clarify the information or specify its real needs.
  prefs: []
  type: TYPE_NORMAL
- en: The tests should cover all the examples that were discovered in the discussion
    step, and extra tests could be added during this process; little by little we
    are understanding the functionality better.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this step, we will obtain the necessary tests written in human
    language so that the team (including the customer) can understand what they will
    do in the next step. These tests can be used like documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Develop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the develop step, the acceptance test cases start to be developed by the
    development team and the project owner. The methodology to follow in this step
    is the same as TDD--the developers should create a test and watch it fail (red),
    and then develop the minimum amount of lines to pass (green). Once the acceptance
    tests are green, this should be verified and tested to be ready to be delivered.
  prefs: []
  type: TYPE_NORMAL
- en: During this process, the developers may find new scenarios that need to be added
    into the tests or even, if it needs a large amount of work, it could be pushed
    to the user story.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this step, we will have a software that passes the acceptance
    tests and maybe more comprehensive tests.
  prefs: []
  type: TYPE_NORMAL
- en: Demo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The created functionality is shown by running the acceptance test cases and
    manually exploring the features of the new functionality. After it is demonstrated,
    the team discusses whether the user story was done properly and whether it meets
    the product owner's needs and decide if they can continue with the next story.
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know more about TDD and BDD, it is time to explain a few tools
    that you can use in your development workflow. There are a lot of tools available,
    but we will only explain the most used ones.
  prefs: []
  type: TYPE_NORMAL
- en: Composer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Composer is a PHP tool used to manage software dependencies. You only need to
    declare the libraries required by your project and Composer will manage them,
    installing and updating them when necessary. This tool has only a few requirements--if
    you have PHP 5.3.2+, you are ready to go. In the case of a missing requirement,
    Composer will warn you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install this dependency manager on your development machine, but since
    we are using Docker, we will install it directly on our **PHP-FPM** (**FastCGI
    Process Manager**) containers. The installation of Composer in Docker is very
    easy; you only need to add the following rule to the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: PHPUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another tool we need for our project is PHPUnit, a unit test framework. In our
    case, we will use version 4.0\. The same as before, we will add this tool to our
    PHP-FPM containers to keep our development machine clean. If you are wondering
    why we are not installing anything on our development machine except for Docker,
    the response is clear--having everything in the containers will help you avoid
    any conflict with other projects and give you the flexibility of changing versions
    without being too worried.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick way, you can add the following `RUN` command to your `PHP-FPM` `Dockerfile`
    and you will have the latest PHPUnit version installed and ready to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will install the latest Composer version in your container,
    but the recommended way of installing it is through Composer. Open your `composer.json`
    file and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you update the `composer.json` file, you only need to do a Composer
    update in your container command line and Composer will install PHPUnit for you.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all our requirements as well, it is time to install our PHP
    framework and start doing some TDD stuff. Later, we will continue updating our
    Docker environment with new tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we talked about some PHP frameworks and chose Lumen as
    our example. Feel free to adapt all the examples to your favorite framework. Our
    source code will be living inside our containers but, at this point of the development,
    we do not want immutable containers. We want every change we make to our code
    to be available instantaneously in our containers so that we will use a container
    as a storage volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a container with our source and use it as a storage volume, we only
    need to edit our `docker-compose.yml` file and create a source container for each
    of our microservices, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding piece of code creates a container image named `source_battle`,
    and it stores our battle source (located at `../source/battle` from the `docker-compose.yml` file
    current path). Once we have our source container available, we can edit each of
    our services and assign a volume. For instance, we can add the following line to
    our `microservice_battle_fpm` and `microservice_battle_nginx` container descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our battle source will be available in our source container at the `/var/www/html`
    path and the remaining step to install Lumen is to do a simple Composer execution.
    First, you need to ensure that your infrastructure is up with a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command spins up our containers and outputs the log to the standard
    IO. Now that we are sure that everything is up and running, we need to enter in
    our PHP-FPM containers and install Lumen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need to know the names assigned to each of your containers, you can
    execute `docker ps` on your terminal and copy the container name.As an example,
    we will enter the following command into the battle PHP-FPM container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command opens an interactive shell in your container so that
    you can do anything you want. Let''s install Lumen with a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Repeat the preceding commands for each of your microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have everything ready to start doing unit tests and code your application.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A unit test is a small piece of code that uses other code in a known context
    so that we can check whether the code we are testing is valid. Lumen comes with
    PHPUnit out of the box; therefore, we only need to add all our tests to the tests
    folder. The framework installation comes with a very small sample file by default--`ExampleTest.php`--where
    you can give the unit testing a try. In order to start with unit testing and until
    you become more comfortable creating unit tests, choose one of your microservices
    sources and create the `app/Dummy.php` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest way of starting with unit testing is every time you create a new
    class in your code, you can create a new one for your tests. Working this way,
    you will remember that your new class needs to be covered with unit tests. For
    instance, imagine that you need a `Battle` class; therefore, when you create the
    class, you can also create a new one with a `Test` prefix in your `tests` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an ideal world, all your code is covered by unit tests but we know that
    this is an odd case. Most of the times, you will have 70% or 80% of code coverage
    if you are lucky. We encourage you to keep your code fully covered but if it is
    not possible, cover at least the core functionalities. There are two ways of creating
    unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tests first, code later:** In our opinion, this workflow is better when you
    have enough time to develop your project. First, you create the tests so that
    you are sure that you really know each new functionality. After you have the tests
    in place, you will write the minimum code necessary to pass the tests. Coding
    this way, you will be thinking about what makes your code valid and what can make
    your code fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code first, tests later:** This a very extended workflow when you don''t
    have too much time for unit testing. You create your code as always and, as soon
    as you have finished, you create the unit tests. This approach creates a less
    robust code because you are adapting your unit test to the already created code
    instead of doing it the other way around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that it is important to always have time to test your code; it is a
    long-term investment. Spending time at the beginning will make your code more
    robust and will eliminate future bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You are probably wondering how you can run and check your tests. Don''t worry,
    it is very simple. You only need to enter one of your PHP-FPM containers. For
    example, to enter in the Battle PHP-FPM container, open your terminal and execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the above command you will be inside the container. Now it
    is time to be sure that your current path is the `/var/www/html` folder. After
    you accomplish the previous step, you can execute phpunit inside that folder.
    All this actions can be done with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `phpunit` command will read the `phpunit.xml` file. This XML describes where
    our tests are stored and executes all of them. The execution of this command will
    give us a pretty screen with the results of our passed or failed tests.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An assertion is a statement in a known context that we are expecting to be true
    at some point in our code and that is the core of unit testing. Assertions are
    used inside test cases and a test case can include multiple assertions inside
    the same tests. In PHPUnit, it is very simple to create a test as you only need
    to add the `test` prefix to your method name. Easy, isn't it? To clarify all these
    concepts, let's look at some assertions you can use in your unit tests with some
    examples. Feel free to create more complex tests until you are comfortable with
    PHPUnit.
  prefs: []
  type: TYPE_NORMAL
- en: assertArrayHasKey
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `assertArrayHasKey(mixed $key, array $array[, string $message = ''''])`
    assertion checks whether `$array` has an element with `$key`. Imagine that you
    have a method that generates and returns some kind of configuration data and there
    is a specific element identified by `storage` that you need to be sure is always
    present. Add the following method to our `Dummy` class to simulate the configuration
    generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can test the response of this `getConfigArray` in any way we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding test will check if the array returned by `getConfigArray` has
    an element identified by `foo`, which fails in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this case, this test will ensure that `getConfigArray` returns an element
    identified by `storage`. If, for some reason, you change the implementation of
    the `getConfigArray` method in future, this test will help you ensure that you
    keep receiving at least an array element identified by `storage`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `assertArrayNotHasKey()` as the inverse of `assertArrayHasKey;`
    it uses the same arguments.
  prefs: []
  type: TYPE_NORMAL
- en: assertClassHasAttribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `assertClassHasAttribute(string $attributeName, string $className[, string
    $message = ''''])` assertion checks whether our `$className` has defined the `$attributeName`.
    Modify our `Dummy` class and add a new attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can test the existence of this public attribute with the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will pass the check of the `foo` attribute but will fail
    in checking the `bar` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `assertClassNotHasAttribute()` as the inverse of `assertClassHasAttribute;`
    it uses the same arguments.
  prefs: []
  type: TYPE_NORMAL
- en: assertArraySubset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `assertArraySubset(array $subset, array $array[, bool $strict = '''', string
    $message = ''''])` assertion checks whether a given `$subset` is available in
    our `$array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example test will fail because the `['storage' => 'failed-test']`
    subset does not exist in the response of our `getConfigArray` method.
  prefs: []
  type: TYPE_NORMAL
- en: assertClassHasStaticAttribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `assertClassHasStaticAttribute(string $attributeName, string $className[,
    string $message = ''''])` assertion checks the existence of a static attribute
    in a given `$className`. We can add a static attribute, like the following one,
    to our `Dummy` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Having this static attribute in place, we are free to test the existence of
    `$availableLocales`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In case of needing to assert the inverse, you can use `assertClassNotHasStaticAttribute();`
    it uses the same arguments.
  prefs: []
  type: TYPE_NORMAL
- en: assertContains()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you need to check if a haystack contains specific elements. You can
    do this using the `assertContains()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertContains(mixed $needle, Iterator|array $haystack[, string $message =
    ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNotContains(mixed $needle, Iterator|array $haystack[, string $message
    = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertContainsOnly(string $type, Iterator|array $haystack[, boolean $isNativeType
    = null, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNotContainsOnly(string $type, Iterator|array $haystack[, boolean $isNativeType
    = null, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertContainsOnlyInstancesOf(string $classname, Traversable|array $haystack[,
    string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: assertDirectory() and assertFile()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PHPUnit not only allows you to test the logic of your application, but you
    can even test the existence and permissions of folders and files. All this can
    be achieved with the following assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertDirectoryExists(string $directory[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertDirectoryNotExists(string $directory[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertDirectoryIsReadable(string $directory[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertDirectoryNotIsReadable(string $directory[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertDirectoryIsWritable(string $directory[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertDirectoryNotIsWritable(string $directory[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileEquals(string $expected, string $actual[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileNotEquals(string $expected, string $actual[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileExists(string $filename[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileNotExists(string $filename[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileIsReadable(string $filename[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileNotIsReadable(string $filename[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileIsWritable(string $filename[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileNotIsWritable(string $filename[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringMatchesFormatFile(string $formatFile, string $string[, string
    $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringNotMatchesFormatFile(string $formatFile, string $string[, string
    $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does your application rely on a writable file in order to work? Don't worry,
    PHPUnit has your back. You can add an `assertFileIsWritable()` to your tests so
    that the next time somebody removes the file you have specified in the assertion,
    the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: assertString()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases, you need to check the content of some strings. For instance,
    if your code generates serial codes, you can check whether the codes you generate
    match your specifications. You can use the following assertions with strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertStringStartsWith(string $prefix, string $string[, string $message =
    ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringStartsNotWith(string $prefix, string $string[, string $message
    = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringMatchesFormat(string $format, string $string[, string $message
    = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringNotMatchesFormat(string $format, string $string[, string $message
    = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringEndsWith(string $suffix, string $string[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringEndsNotWith(string $suffix, string $string[, string $message =
    ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: assertRegExp()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `assertRegExp(string $pattern, string $string[, string $message = ''''])`
    assertion will be very useful for you as you have all the regex power in one assertion.
    Let''s add a static function to our Dummy class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This new function returns a static string code. Feel free to complicate the
    generation. To test this generated string code, you can now do something like
    this in your test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using a simple regular expression to check the output
    generated by `getRandomCode`.
  prefs: []
  type: TYPE_NORMAL
- en: assertJson()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Working with microservices, you will probably be working very closely with
    JSON requests and responses. Therefore, it is very important that you have the
    ability to test our JSONs. You can have a JSON as a file or as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertJsonFileEqualsJsonFile()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertJsonStringEqualsJsonFile()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertJsonStringEqualsJsonString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Boolean results or types can be checked with the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertTrue(bool $condition[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFalse(bool $condition[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you need to ensure that an element is an instance of a specific class
    or has a specific internal type. You can use the following assertions in your
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertInstanceOf($expected, $actual[, $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertInternalType($expected, $actual[, $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PHPUnit has a high number of assertions and your tests can''t be completed
    without some of the following assertions applied to results or object states of
    your features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertCount($expectedCount, $haystack[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEmpty(mixed $actual[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEquals(mixed $expected, mixed $actual[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertGreaterThan(mixed $expected, mixed $actual[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertGreaterThanOrEqual(mixed $expected, mixed $actual[, string $message
    = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertInfinite(mixed $variable[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertLessThan(mixed $expected, mixed $actual[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertLessThanOrEqual(mixed $expected, mixed $actual[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNan(mixed $variable[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNull(mixed $variable[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertObjectHasAttribute(string $attributeName, object $object[, string $message
    = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertSame(mixed $expected, mixed $actual[, string $message = ''''])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more information about the assertions you can use on the PHPUnit
    website, that is, [https://phpunit.de/](https://phpunit.de/).
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing from scratch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you probably feel more comfortable with unit testing and you
    want to start coding your app as soon as possible, so let's get started with testing!
  prefs: []
  type: TYPE_NORMAL
- en: Our microservices application uses geolocalization to find secrets and other
    players. This means that your location microservice will need a way to calculate
    the distance between two geospatial points. We will also need, given an origin
    point, to get a list of the closest stored points (they can be the closest users
    or secrets). As this is a core feature, you need to ensure that what we described
    is fully tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app, the localization has its own service. Therefore, open the source
    code of the location microservice with your IDE and create the `app/Http/Controllers/LocationController.php`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code has created our location controller in Lumen and, as we mentioned
    before, as soon as we have this class created, we need to create a similar class
    for our unit tests. In order to do this, you only need to create the `tests/app/Http/Controllers/LocationControllerTest.php`
    file. As you can see, we are even replicating the folder structure; this is the
    best approach to easily know which class we are testing for.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to start creating tests for the distance calculation and for the function that
    allows us to get the closest secrets given a specific geolocation point. One approach
    is to create two different tests. Therefore, fill your `LocationControllerTest.php`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We didn't add anything special to our test class, we only declared two tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `testDistance()`. In this test, we want to ensure that given
    two geospatial points, the calculated distance between them is accurate enough
    for our purposes. In unit testing, you need to start describing the known scenario--as
    points, we have chosen London (latitude: `51.50`, longitude: `-0.13`) and Amsterdam
    (latitude: `52.37`, longitude: `4.90`). The known distance between these two cities
    is around 358.06 km, and this is the result we aim to get from our distance calculator.
    Let''s fill our test with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding piece of code, we defined the known scenario, the location
    of our two points and the distance known between them. Once we had our known scenario
    ready, we created an instance of our `LocationController` and we used the defined
    `getDistance` function to obtain a result we want to test. As soon as we got the
    result, we tested that our `LocationController` had a `conversionRate` static
    attribute that we can use to transform the distance to different units. Our last
    and most important assertion checks the match between the calculated distance
    and the known distance between these two points. We have our basic test ready,
    and it is time to start coding our `getDistance` function.
  prefs: []
  type: TYPE_NORMAL
- en: The distance calculation between two geospatial points can be calculated in
    very different ways. You can use a strategy pattern here, but to keep the example
    simple we will code the different calculation algorithms in different functions
    inside our controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `LocationController` and add some auxiliary code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have defined our conversion rates, a constant we can
    use to round our results, and a simple conversion function. We will use this `convertDistance`
    function later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first approach for distance calculation is to use the Euclidean function
    to get our result. A simple implementation is described in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our algorithm ready, we can add it to our `getDistance` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you have everything in place and you can start the tests. Enter
    the location container and run PHPUnit in `/var/www/html`. This is our first approach;
    the PHPUnit result will be a fail, and the output of this application will tell
    you where the problem is. In our case, the main reason for the fail is that the
    algorithm we used is not accurate enough for our application. We can't deploy
    this version of our application because it has failed tests and we have to change
    our test or the code that implements our tests.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, there are multiple ways of calculating the distance
    between two points and each one can be more or less accurate. The first implementation
    we tried failed because it is used for plains and our world is a sphere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `LocationController` again and create a new distance implementation
    using a haversine calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this distance calculation function is a little more complex
    and considers the spherical form of our world. Change the `getDistance` function
    to use our new algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now run PHPUnit again and everything should be okay; the test will pass and
    our code is ready for production.
  prefs: []
  type: TYPE_NORMAL
- en: 'With unit testing and TDD, the process is always the same:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make your code to pass the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests and if they fail, start again from step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another feature we want to have in our location microservice is to get the
    closest secrets we have near our current position. Open the `LocationControllerTest`
    file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding piece of code, we defined our current location (New York) and
    asked our implementation to give us a list of the closest secrets. Our location
    implementation will have a cache list of secrets, and we know where they are located
    (this will help us to know the correct order).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `LocationController.php` and first add a cache list of secrets. In the
    real world, we don''t have hardcoded values, but it''s good enough for testing
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have our list of secrets ready, we can add our `getClosestSecrets`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we used our cache list of secrets to calculate the distance between
    the origin point and each of our secret points. As soon as we had the distance,
    we sorted the result and returned the closest three.
  prefs: []
  type: TYPE_NORMAL
- en: Running PHPUnit in our location container will show us that all the tests are
    being passed, giving us the confidence to deploy our code to production.
  prefs: []
  type: TYPE_NORMAL
- en: Future commits can make changes to the distance calculation or to the closest
    function, and they can break our tests. Luckily for you, there is a unit testing
    covering them and PHPUnit will throw an alert, so you can start rethinking your
    code implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Let your imagination fly and test everything--from the simple and small case
    to any odd and obscure case you can imagine. The idea is that your application will
    break and break very badly, in the middle of the night or during your holidays.
    There is nothing you can do about this except adding as many tests as you can
    so that you can ensure that the release you have in production is stable enough
    to reduce the risks of breaking.
  prefs: []
  type: TYPE_NORMAL
- en: Behat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Behat is an open source behavior-driven development framework. All the Behat
    tests are written in plain English and wrapped into readable scenarios. This framework
    uses the Gherkin syntax and was inspired by Cucumber, a Ruby tool. The main advantage
    of Behat is that most of the test scenarios can be understood by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Behat can be easily installed using Composer. You only need to edit the `composer.json`
    of each microservice and drop a new line with `"behat/behat" : "3.*"`. Your `require-dev`
    definition will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have updated the `dev` requirements, you need to enter each of your
    PHP-FPM containers and run Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Test execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running Behat is as easy as running PHPUnit. You only need to enter your PHP-FPM
    container, go to the `/var/www/html` folder, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Behat example from scratch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the key features of our microservices application is the ability to
    find secrets. Users should be able to save the secrets and, for this, they need
    a wallet. So, let''s write our user-story in our user microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the test can be understood by anyone in the project--from the
    developers to the stakeholders. Each test scenario always has the same format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can add some modifiers to the preceding basic template (and or but) to empower
    the scenario description. At this point, with your scenario ready, you can save
    it as a `features/wallet.feature` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time you start writing a Behat test on your project, you need to
    initialize the suite with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will create the files needed by Behat to run the scenario
    tests. The main file we will use is `features/bootstrap/FeatureContext.php`; this
    file will be our test environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our `FeatureContext` file in place, it is time to start creating
    our scenario steps. For example, place the following method in your `FeatureContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Behat uses doc-blocks for step definitions, step transformations, and hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding piece of code, we are telling Behat that the `thereIsA()`
    function matches each `Given there is a(n)` step. In our example, that definition
    will match the steps in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Given that there is an amber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a diamond
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to map each of our scenario steps so that our `FeatureContext` will
    end up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Our tests use external classes that we need to define. These classes implement
    our logic and, for example, purposefully create the `features/bootstrap/SecretsCache.php`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to create `features/bootstrap/Wallet.php` with the following
    sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The preceding two classes are the implementation of our tests and, as you can
    see, they have the logic of storing secrets in a wallet. Now, if you run `vendor/bin/behat`
    on your console, the tool will check all our test scenarios and give us confidence
    that our code will behave the way we want it to.
  prefs: []
  type: TYPE_NORMAL
- en: This was a simple example of testing an application with Behat. In our GitHub
    repository, you can find more specific examples. Also, feel free to explore the
    Behat ecosystem; you can find multiple tools and extensions that can help you
    test your application.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Selenium is a suite of tools to automate web browsers across many platforms
    and can be used as a browser extension, or it can be installed on a server to
    run our browser tests. The main advantage of Selenium is that you can easily record
    a full user journey and create a test from the record. This test can be later
    added to your pipeline to be executed on each commit to discover regressions.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium WebDriver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The WebDriver is the API that you can use to run your browser testing from other
    tools. It is a powerful testing environment normally placed in a dedicated server
    where it sits waiting to run browser tests.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium IDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Selenium IDE is a Firefox extension that allows you to record, edit, and
    debug browser tests. This plugin is not only a recording tool, but a full IDE
    with autocomplete functionalities. You can even record and create tests with the
    IDE and later run them with the WebDriver.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, Selenium is used as a complimentary testing tool executed
    from another testing framework. For instance, you can improve your Behat tests
    with Selenium thanks to the Mink project ([http://mink.behat.org/en/latest/](http://mink.behat.org/en/latest/)).
    This project is a wrapper for different browser drivers, so you can use them in
    your BDD workflow.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about the deployment of our application in [Chapter 7](ch07.html
    "Chapter 7. Security"), *Security*. We will learn how to automate all these tests
    and integrate them in our CI/CD workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you studied the importance of using tests on your application,
    tools such as Behat and Selenium, and also about implementing driven development.
    In the next chapter, you will study error handling, dependency management, and
    the microservices framework.
  prefs: []
  type: TYPE_NORMAL
