- en: Chapter 4.  Testing and Quality Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at the different testing methodologies that you
    can use before, during, and after the development process. As you will know, testing
    your application avoids future issues and gives you a better project overview.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The importance of using tests in your application
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very important to use testing in our application because these steps can
    avoid (or at least reduce) future problems or errors that can appear as we are
    humans and can make mistakes during the development process or because the structure
    of the project is not correct or even the understanding of the developer does
    not match the requirements of the customer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The testing process will help improve the code quality and understanding of
    the functionalities, do regression testing in order to avoid the inclusion of
    old issues in continuous integration and reduce the time taken to finish the project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing is used to reduce the fails or errors in our application. Development
    teams spend a lot of time doing bug fixing and, depending on the moment of the
    discovery of the bugs, the impact can be bigger or smaller. The following image
    shows the relative cost of bug fixing related to the stage of the development:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![The importance of using tests in your application](graphics/B06142_04_01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: The reason for using testing methodologies in development is that we can find
    errors in our code in the early steps of the development so that we will spend
    less time doing bug fixing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Testing in microservices
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The challenge of testing an application based on microservices is not in the
    testing of every single microservice, but on the integration and data consistency.
    An application based on microservices will need a better understanding of the
    architecture of microservices and their workflow by the developers to be able
    to use testing on it. This is because it is necessary to check the information
    and also the functionality of every microservice at all the points of communication
    between the microservices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing to use on microservices are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: In all the applications based on microservices or even in
    a monolithic one, it is necessary to use unit testing. Using it, we will check
    the necessary functionality of the methods or code modules.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: Unit testing only checks the isolated components,
    so we also need to check the behavior between methods. We will check the behavior
    between methods of the same microservice using integration testing, so the calls
    between microservices will need to be mocked.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API tests**:The microservices architecture depends on the communication between
    them. For each microservice, it is necessary to establish an API; this is like
    a *contract* to use that microservice. With this kind of test, we will check that
    the contract is working for each microservice and all the microservices are working
    with each other.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end tests**:These guarantee the application quality without any mockup method
    or call. A test will be run to assess the functionality between all the required
    microservices. There are some rules to avoid problems during these tests:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end tests are difficult to maintain, so only test the most important
    functionalities; the rest of them use unit testing
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user functionalities can be tested by simulating calls to the microservices
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is necessary to keep a clean environment to test it because the tests are
    very dependent on the data, so a previous test can manipulate the data and then,
    the next test
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we know how to proceed with testing our application based on microservices,
    we will look at some strategies to do so during development.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Test-driven development** (**TDD**) is part of agile philosophy, and it appears
    to solve the common developer''s problem that shows when an application is evolving
    and growing and the code is getting sick. The developers fix the problems to make
    it run but every single line that we add can be a new bug and it can even break
    other functions.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'TDD is a learning technique that helps the developer to learn about the domain
    problem of the application they will build, doing it in an iterative, incremental,
    and constructivist way:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterative** because the technique always repeats the same process to get
    a value'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incremental** because for each iteration, we have more unit tests to be used'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructivist** because it is possible to test everything we are developing
    during the process straightaway so that we can get immediate feedback'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, when we finish developing each unit test or iteration, we can forget it
    because it will be kept throughout the entire development process, helping us
    to remember the domain problem through the unit test. This is a good approach
    for forgetful developers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very important to understand that TDD includes four things: analysis,
    design, development, and testing. In other words, doing TDD is understanding the
    domain problem and correctly analyzing the problem, designing the application
    well, developing well, and testing it. It needs to be clear; TDD is not just about
    implementing unit tests, but the whole process of the software development.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: TDD perfectly matches projects based on microservices, because using microservices
    in a large project is dividing it into little microservices, our functionalities are like
    an aggrupation of little projects connected by a communication channel. The project
    size is independent of using TDD because, in this technique, you divide each functionality
    into little examples and, to do this, it does not matter whether the project is
    big or small, and even less when our project is divided by microservices. Also,
    microservices are still better than a monolithic project because the functionalities
    for the unit tests are organized in microservices and it will help the developers
    to know where they can begin to use TDD.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: How to do TDD?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Doing TDD is not difficult, we just need to follow some steps and repeat them
    by improving our code and checking that we did not break anything:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**Write the unit test**: It needs to be the simplest and clearest test possible,
    and once it is done it has to fail; this is mandatory, if it does not fail, it
    means that there is something we are not doing properly.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Run the tests**: If it has errors (it fails), this is the moment to develop
    the minimum code to pass the test; just do what is necessary, do not code additional
    things. Once you develop the minimum code to pass the test, run the test again;
    if it passes go to the next step, if not fix it and run the test again.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Improve the test**: If you think it is possible to improve the code you wrote,
    do it and run the tests again. If you think it is perfect, write a new unit test.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following image illustrates the mantra of TDD--**RED**, **GREEN**, **REFACTOR**:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do TDD?](graphics/B06142_04_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: To do TDD, it is necessary to write the tests before implementing the function;
    if the implementation is started and then the tests are written, it is not TDD,
    it is just testing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: If we create the unit tests after we start developing our application, we are
    doing the classic testing and we are not taking advantage of the TDD benefits.
    Having your unit tests in place will help you ensure that your abstract idea of
    the domain problem is correct throughout the developing process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, doing testing is always better than not doing it, but doing TDD is
    still better than doing just classic testing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Why should I use TDD?
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TDD is the answer to questions such as "where shall I begin?", "how can I do
    it?", "how can I write code that can be modified without breaking anything?", and
    "how can I know what I have to implement?".
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The goal is not to write many unit tests without sense, but to design TDD properly
    following the requirements. In TDD, we do not to think about implementing functions,
    but about good examples of the functions related to the domain problem in order
    to remove the ambiguity created by the domain problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we should reproduce a specific function or case of use in X
    examples by doing TDD until we get the necessary examples to describe the function
    or task without ambiguity or misinterpretations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TDD can be the best way to document your application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Using other methodologies of software development, we start thinking about how
    the architecture will be, what pattern will be used, how the communication between
    microservices will be, but what happens if once we have planned all this, we realize
    that it is not necessary? How much time will pass until we realize that? How much
    effort and money will we spend?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: TDD defines the architecture of our application by creating little examples
    in many iterations until we realize what is the architecture. The examples will
    slowly show us the steps to follow in order to define what the best structure,
    pattern, or tools to use are, so that we avoid spending resources during the first
    stages of our application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean that we are working without an architecture. Obviously, we
    have to know whether our application will be a website or a mobile app and use
    a proper framework (you can research which framework fits your needs in [Chapter
    2](ch02.html "Chapter 2. Development Environment"), *Development Environment*),
    and also know what the interoperability in the application will be; in our case,
    it will be an application based on microservices. So, it will give us support
    to start creating the first unit tests. TDD will be our guideline to develop an
    application and it will produce an architecture without ambiguity from the unit
    testing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'TDD is not cure-all; in other words, it does not give the same results to a
    senior and junior developer, but it is useful for the whole team. Let''s look
    at some advantages of using TDD:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**Code reuse**: This creates every functionality with only the necessary code
    to pass the tests in the second stage (Green). It allows you to see whether there
    are more functions using the same code structure or parts of a specific function;
    so, it helps you to reuse the code you wrote earlier.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Teamwork is easier**: It allows you to be confident with your team colleagues.
    Some architects or senior developers do not trust developers with poor experience,
    and they need to check their code before committing the changes, creating a bottleneck at
    that point, so TDD helps us to trust the developers with less experience.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increases the communication**: It increases the communication between team
    colleagues. The communication is more fluent, so the team share their knowledge
    about the project reflected on the unit tests.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid overdesign**: Do not overdesign the application in the first stages.
    As we said before, doing TDD allows you to have an overview of the application
    little by little, avoiding creating useless structures or patterns in your project
    that you will maybe trash in the future stages.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit tests are the best documentation**: The best way to give a good point
    of view of a specific functionality is by reading its unit test, which helps us
    understand how it works instead of human words.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allows to discover more use cases** in the design stage: In every test you
    have to create, you will understand how the functionality should work better and
    all the possible stages that a functionality can have.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increases the feeling of a job well done**: In every commit of your code,
    you will have the feeling that it was done properly because the rest of the unit
    tests pass without errors, so you will not be worried about breaking other functionalities.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increases the software quality**: During the refactoring step, we spend our
    efforts in making the code more efficient and maintainable, verifying that the
    whole project still works properly after the changes.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD algorithm
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The technical concepts and steps to follow the TDD algorithm are easy and clear,
    and the proper way to make it happen improves by practicing it. As we saw before,
    there are only three steps: red, green, and refactor.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Red - writing the unit tests
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to write a test even when the code is not written, you just need
    to think about whether it is possible to write a specification before implementing
    it. So, in the first step, you should consider that the unit test you start writing
    is not like a unit test but like an example or specification of the functionality.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In TDD, this example or specification is not fixed; in other words, the unit
    test can be modified in the future. Before beginning to write the first unit test,
    it is necessary to think about how the **software under test** (**SUT**) will
    be, and just a little about how it will work. We need to think about how it will
    be the SUT code and how we will check that it works the way we want it to.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The way that TDD works drives us to firstly design what is more comfortable
    and clear if it fits the requirements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Green - make the code work
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the example is written, we have to code the minimum to make it pass the
    test; in other words, set the unit test to green. It does not matter if the code
    is ugly and not optimized, it will be our task in the next steps and iterations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: In this step, the important thing is only to write the necessary code for the
    requirements, without unnecessary things. It does not mean writing without thinking
    about the functionality, but thinking about it to be efficient. It looks easy,
    but you will realize that you will write extra code the first time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: If you concentrate on this step, you will think of new questions about the SUT
    behavior with different entries. However, you should be strong and avoid writing
    extra code about other functionalities related to the current one. As a rule of
    thumb, instead of coding the new features, take notes so you can convert them
    into functionalities in future iterations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Refactor - eliminate redundancy
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refactoring is not the same as rewriting code. You should be able to change
    the design without changing the behavior.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In this step, you should remove the duplicity in your code and check whether
    the code matches the principles of the good practices, thinking about the efficiency,
    clarity, and the future maintainability of the code. This part depends on the
    experience of each developer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key to good refactoring is doing it in small steps.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: To refactor a functionality, the best way to do it is to change a little part
    and execute all the available tests, and if they pass, continue with another little
    part until you are happy with the obtained result.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-driven development
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Behavior-driven development** (**BDD**) is a process that broadens the TDD
    technique and mixes it with other design ideas and business analysis provided
    to the developers in order to improve the software development.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: In BDD, we test the scenarios and the class's behavior in order to meet the
    scenarios that can be composed by many classes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: It is very useful to use a DSL in order to have a common language to be used
    by the customer, project owner, business analyst, or developers. The goal is to
    have a ubiquitous language as we saw in [Chapter 3](ch03.html "Chapter 3. Application
    Design"), *Application Design*, in the domain-driven design section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: What is BDD?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said before, BDD is an agile technique based on TDD and ATDD, promoting
    the collaboration between the entire team of a project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，BDD是一种基于TDD和ATDD的敏捷技术，促进了项目整个团队之间的协作。
- en: The goal of BDD is that the entire team understands what the customer wants,
    and the customer knows what the rest of the team understood from their specifications.
    Most of the times, when a project starts, developers don't have the same point
    of view as the customer, and during the development process the customer realizes
    that maybe they did not explain it or maybe the developer did not understand it
    properly, so it adds more time to change the code to meet the customer's needs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: BDD的目标是让整个团队了解客户的需求，让客户知道团队其他成员从他们的规范中理解了什么。大多数情况下，当项目开始时，开发人员和客户的观点并不相同，在开发过程中客户意识到也许他们没有解释清楚，或者开发人员没有正确理解，因此需要更多时间来更改代码以满足客户的需求。
- en: So, BDD is writing test cases in human language using rules or a ubiquitous
    language so that the customer and developers can understand it. It also defines
    a DSL for the tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，BDD是使用规则或通用语言以人类语言编写测试用例，以便客户和开发人员能够理解。它还为测试定义了DSL。
- en: How does it work?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: It is necessary to define the features as user stories (we will explain what
    this is in the ATDD section of this chapter) and examine their acceptance criteria.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将功能定义为用户故事（我们将在本章的ATDD部分解释这是什么），并检查它们的验收标准。
- en: 'Once the user story is defined, we have to focus on the possible scenarios that
    describe the project behavior for a concrete user or situation using DSL. The
    steps are: given (context), when (event occurs), and then (outcome).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户故事被定义，我们必须专注于使用DSL描述项目行为的可能场景。步骤是：给定（上下文），当（事件发生），然后（结果）。
- en: To sum up, the defined scenario for a user story gives the acceptance criteria
    to check whether the feature is done.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，为用户故事定义的场景为验收标准提供了检查功能是否完成的依据。
- en: Cucumber as DSL for BDD
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cucumber作为BDD的DSL
- en: Cucumber is a DSL tool that executes examples made in plain text as automatic
    tests, taking advantage of the benefits of BDD and bringing together the business
    layer and the technology in a project in order to know what are the functionalities
    most valued by the user and develop them at the same time that we are defining
    the case tests and documenting the project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber是一个DSL工具，它执行以纯文本形式制作的示例作为自动测试，利用BDD的好处，将业务层和技术结合在一起，以了解用户最看重的功能，并在定义用例测试和记录项目的同时开发它们。
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The most important thing for Cucumber is having the same point of understanding
    between developers and customers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber最重要的是让开发人员和客户有相同的理解。
- en: '**Gherkin** is the language that Cucumber uses, and it allows you to translate
    the specifications of the project into a near human language so that the customer
    or other people without technical skills can understand it. This tool and language
    can be used for BDD and ATDD. Let''s look at a piece of sample code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gherkin**是Cucumber使用的语言，它允许您将项目的规范翻译成接近人类语言，以便客户或其他没有技术技能的人能够理解。这个工具和语言可以用于BDD和ATDD。让我们看一个样本代码：'
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This allows us to define the software behavior without saying how it is implemented.
    Also, it allows us to document the functionalities at the same time we write the
    case automatic tests. The advantages of using Cucumber are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以让我们定义软件行为，而不用说出它是如何实现的。同时，它也让我们能够在编写自动测试用例的同时记录功能。使用Cucumber的优势如下：
- en: Easy to read
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于阅读
- en: Easy to understand
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于理解
- en: Easy to parse
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于解析
- en: Easy to discuss
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于讨论
- en: 'DSL has three steps in the code that the tool understands and processes; they
    are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: DSL在代码中有三个工具可以理解和处理的步骤；它们如下：
- en: '**Given**: This is the necessary step to set the system in the proper status
    to check the tests.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**给定**：这是将系统设置为适当状态以检查测试的必要步骤。'
- en: '**When**: This is the necessary step to be carried out by the user to action
    the functionality.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当**：这是用户必须执行的必要步骤来激活功能。'
- en: '**Then**: This refers to the things that change in the system. Here, we are
    able to see if it does what we want.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**然后**：这指的是系统中发生变化的事物。在这里，我们能够看到它是否符合我们的期望。'
- en: 'Also, there are two more available optional steps: **And** and **But**, and
    they can be used in **Given** or **Then** when you need more than a sentence to
    match the requirements.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个可选的步骤：**And**和**But**，它们可以在**Given**或**Then**中使用，当您需要超过一句话来满足要求时。
- en: In this chapter, we will see how to use a tool, called Selenium, to do BDD.
    It is another DSL tool but is oriented to web development instead of plain text.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何使用一个名为Selenium的工具来进行BDD。这是另一个DSL工具，但是它是面向Web开发而不是纯文本的。
- en: Acceptance test-driven development
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验收测试驱动开发
- en: Maybe the most important methodology in a project is the **Acceptance Test-Driven
    Development** (**ATDD**) or **Story Test-Driven Development** (**STDD**); it is
    TDD but on a different level.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 也许项目中最重要的方法是**验收测试驱动开发**（**ATDD**）或**故事测试驱动开发**（**STDD**）；它是TDD，但在不同的层面上。
- en: The acceptance (or customer) tests are the written criteria that the project
    meets the business requirements that the customer demands. They are examples (like
    the examples in TDD) written by the project owner. It is the beginning of the
    development for each iteration, the bridge between scrum and agile development.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 验收（或客户）测试是项目满足客户需求的业务要求的书面标准。它们是由项目所有者编写的示例（就像TDD中的示例）。它是每次迭代开发的开始，是Scrum和敏捷开发之间的桥梁。
- en: In ATDD, we start the implementation of our project in a different way to the
    traditional methodologies. The business requirements written in human language
    are replaced by executables agreed by some team members and the customer. It is
    not about replacing the whole documentation, but only part of the requirements.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of using ATDD are as mentioned:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: It provides real examples and a common language for the team to understand the
    domain
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows us to identify the domain rules properly
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to know if a user story is finished in each iteration
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The workflow works from the first steps
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development does not start until the tests are defined and accepted by the
    team
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User stories
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user stories of ATDD are like use cases in terms of name or description,
    but work in a different way. A user story does not define the requirement, avoiding
    the problem of ambiguity of the human language. The goal is to communicate the
    idea without problems for the rest of the team.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Each user story is a list of clear and concise examples about what the customer
    wants from the application. The name of the story is a sentence of human language
    defining what the function must do. Consider the following examples:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Search available secrets around our position
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the secrets we already have stored
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check who is the winner in a battle
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have the goals of listening to the customers and helping them define what
    they expect from the application. The user stories should be clear without ambiguity
    and should be written in human language, not in technical language; the customer
    should understand what they say.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined a user story, some questions appear and they should be
    answered by associating acceptance tests for each story. For example, for the
    *Check who is the winner in a battle* story, some possible questions are as listed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: What happens if they draw?
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the winner win?
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the loser lose?
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long does a battle take?
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the possible acceptance tests are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: If they draw, no one will win or lose anything; they will keep their secrets
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The winner will earn 10 points and get a secret from the loser's pocket
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loser will give a secret to the winner
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A battle takes three throws of a dice
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe the questions and answers from a user story will generate new user stories
    to be added to the backlog.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: ATDD algorithm
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithm of ATDD is like the TDD, but reaches more people than the developers.
    In other words, doing ATDD, the tests of each story are written in a meeting that
    includes the project owners, developers, and QA technicians because the team must
    understand what is necessary to do and why it is necessary so that they can see
    if it is what the code should do. The following image shows the ATDD cycle:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![ATDD algorithm](graphics/B06142_04_03.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Discuss
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The starting point of the ATDD algorithm is the discussion. In this step, the
    business has a meeting with the customer to clarify how the application should
    work and the analyst should create the user stories from that conversation. Also,
    they should be able to explain the conditions of satisfaction of every user story
    in order to be translated into examples as we explained earlier, in the user stories
    section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the meeting, the examples should be clear and concise so that
    we can get a list of examples of user stories to cover all the needs that the
    customer reviewed and understood for himself. Also, the team will have a project
    overview in order to understand the business value of the user story, and in case
    the user story was too big, it can be divided into little user stories, getting
    the first one for the first iteration of this process.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Distill
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The high level acceptance tests are written by the customer and the development
    team. In this step, the writing of the test cases that we got from the examples
    in the discussion step begins and the team can take part in the discussion and
    help clarify the information or specify its real needs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 高级验收测试由客户和开发团队编写。在这一步中，从讨论步骤中得到的测试用例的编写开始，并且团队可以参与讨论并帮助澄清信息或指定其真实需求。
- en: The tests should cover all the examples that were discovered in the discussion
    step, and extra tests could be added during this process; little by little we
    are understanding the functionality better.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该覆盖在讨论步骤中发现的所有示例，并在这个过程中可以添加额外的测试；一点一点地我们正在更好地理解功能。
- en: At the end of this step, we will obtain the necessary tests written in human
    language so that the team (including the customer) can understand what they will
    do in the next step. These tests can be used like documentation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步结束时，我们将获得以人类语言编写的必要测试，以便团队（包括客户）能够理解他们在下一步将要做什么。这些测试可以用作文档。
- en: Develop
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发
- en: In the develop step, the acceptance test cases start to be developed by the
    development team and the project owner. The methodology to follow in this step
    is the same as TDD--the developers should create a test and watch it fail (red),
    and then develop the minimum amount of lines to pass (green). Once the acceptance
    tests are green, this should be verified and tested to be ready to be delivered.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发步骤中，验收测试用例开始由开发团队和项目所有者开发。在这一步骤中要遵循的方法与TDD相同--开发人员应该创建一个测试并观察它失败（红色），然后开发最少的代码行以通过测试（绿色）。一旦验收测试通过，就应该进行验证和测试，准备好交付。
- en: During this process, the developers may find new scenarios that need to be added
    into the tests or even, if it needs a large amount of work, it could be pushed
    to the user story.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，开发人员可能会发现需要添加到测试中的新场景，甚至，如果需要大量工作，它可能会被推到用户故事中。
- en: At the end of this step, we will have a software that passes the acceptance
    tests and maybe more comprehensive tests.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步结束时，我们将拥有一个通过验收测试的软件，甚至可能还有更全面的测试。
- en: Demo
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 演示
- en: The created functionality is shown by running the acceptance test cases and
    manually exploring the features of the new functionality. After it is demonstrated,
    the team discusses whether the user story was done properly and whether it meets
    the product owner's needs and decide if they can continue with the next story.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行验收测试用例并手动探索新功能的特性来展示创建的功能。演示完毕后，团队讨论用户故事是否做得恰当，是否满足产品所有者的需求，并决定是否可以继续下一个故事。
- en: Tools
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: Now that you know more about TDD and BDD, it is time to explain a few tools
    that you can use in your development workflow. There are a lot of tools available,
    but we will only explain the most used ones.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经更多地了解了TDD和BDD，是时候解释一些可以在开发工作流程中使用的工具了。有很多可用的工具，但我们只会解释最常用的工具。
- en: Composer
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Composer
- en: Composer is a PHP tool used to manage software dependencies. You only need to
    declare the libraries required by your project and Composer will manage them,
    installing and updating them when necessary. This tool has only a few requirements--if
    you have PHP 5.3.2+, you are ready to go. In the case of a missing requirement,
    Composer will warn you.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Composer是一个用于管理软件依赖关系的PHP工具。您只需要声明项目所需的库，Composer将管理它们，在必要时安装和更新它们。这个工具只有一些要求--如果您有PHP
    5.3.2+，您就可以开始了。如果缺少某个要求，Composer会提醒您。
- en: 'You can install this dependency manager on your development machine, but since
    we are using Docker, we will install it directly on our **PHP-FPM** (**FastCGI
    Process Manager**) containers. The installation of Composer in Docker is very
    easy; you only need to add the following rule to the Dockerfile:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在开发机器上安装这个依赖管理器，但由于我们使用的是Docker，我们将直接在我们的**PHP-FPM**（**FastCGI进程管理器**）容器中安装它。在Docker中安装Composer非常容易；您只需要向Dockerfile添加以下规则：
- en: '[PRE1]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: PHPUnit
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHPUnit
- en: Another tool we need for our project is PHPUnit, a unit test framework. In our
    case, we will use version 4.0\. The same as before, we will add this tool to our
    PHP-FPM containers to keep our development machine clean. If you are wondering
    why we are not installing anything on our development machine except for Docker,
    the response is clear--having everything in the containers will help you avoid
    any conflict with other projects and give you the flexibility of changing versions
    without being too worried.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目中需要的另一个工具是PHPUnit，一个单元测试框架。在我们的情况下，我们将使用4.0版本。与之前一样，我们将把这个工具添加到我们的PHP-FPM容器中，以保持我们的开发机器干净。如果您想知道为什么除了Docker之外我们不在开发机器上安装任何东西，答案很明确--将所有东西放在容器中将帮助您避免与其他项目的冲突，并且可以灵活地更改版本而不必过于担心。
- en: 'As a quick way, you can add the following `RUN` command to your `PHP-FPM` `Dockerfile`
    and you will have the latest PHPUnit version installed and ready to use:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速的方法，您可以在您的`PHP-FPM` `Dockerfile`中添加以下`RUN`命令，这样您就可以安装并准备使用最新的PHPUnit版本了：
- en: '[PRE2]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command will install the latest Composer version in your container,
    but the recommended way of installing it is through Composer. Open your `composer.json`
    file and add the following line:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在您的容器中安装最新的Composer版本，但推荐的安装方式是通过Composer。打开您的`composer.json`文件并添加以下行：
- en: '[PRE3]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As soon as you update the `composer.json` file, you only need to do a Composer
    update in your container command line and Composer will install PHPUnit for you.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您更新了`composer.json`文件，您只需要在容器命令行中执行Composer更新，Composer就会为您安装PHPUnit。
- en: Now that we have all our requirements as well, it is time to install our PHP
    framework and start doing some TDD stuff. Later, we will continue updating our
    Docker environment with new tools.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的要求都准备好了，现在是时候安装我们的PHP框架并开始做一些TDD的工作了。稍后，我们将继续更新我们的Docker环境，加入新的工具。
- en: In the previous chapters, we talked about some PHP frameworks and chose Lumen as
    our example. Feel free to adapt all the examples to your favorite framework. Our
    source code will be living inside our containers but, at this point of the development,
    we do not want immutable containers. We want every change we make to our code
    to be available instantaneously in our containers so that we will use a container
    as a storage volume.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们谈到了一些PHP框架，并选择了Lumen作为我们的示例。请随意将所有示例调整为您喜欢的框架。我们的源代码将存储在容器中，但在开发的这一阶段，我们不希望容器是不可变的。我们希望我们对代码所做的每一次更改都能立即在我们的容器中使用，因此我们将使用容器作为存储卷。
- en: 'To create a container with our source and use it as a storage volume, we only
    need to edit our `docker-compose.yml` file and create a source container for each
    of our microservices, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含我们的源代码并将其用作存储卷的容器，我们只需要编辑我们的`docker-compose.yml`文件，并为我们的每个微服务创建一个源容器，如下所示：
- en: '[PRE4]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding piece of code creates a container image named `source_battle`,
    and it stores our battle source (located at `../source/battle` from the `docker-compose.yml` file
    current path). Once we have our source container available, we can edit each of
    our services and assign a volume. For instance, we can add the following line to
    our `microservice_battle_fpm` and `microservice_battle_nginx` container descriptions:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段创建了一个名为`source_battle`的容器映像，并存储了我们的battle源代码（位于`docker-compose.yml`文件当前路径的`../source/battle`）。一旦我们有了我们的源代码容器，我们可以编辑每个服务并分配一个卷。例如，我们可以将以下行添加到我们的`microservice_battle_fpm`和`microservice_battle_nginx`容器描述中：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our battle source will be available in our source container at the `/var/www/html`
    path and the remaining step to install Lumen is to do a simple Composer execution.
    First, you need to ensure that your infrastructure is up with a simple command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的battle源代码将在我们的源容器的`/var/www/html`路径中可用，安装Lumen的剩下步骤是执行一个简单的Composer命令。首先，您需要确保您的基础设施已经准备好了：
- en: '[PRE6]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding command spins up our containers and outputs the log to the standard
    IO. Now that we are sure that everything is up and running, we need to enter in
    our PHP-FPM containers and install Lumen.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令启动我们的容器并将日志输出到标准IO。现在我们确信一切都已经准备就绪，我们需要进入我们的PHP-FPM容器并安装Lumen。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you need to know the names assigned to each of your containers, you can
    execute `docker ps` on your terminal and copy the container name.As an example,
    we will enter the following command into the battle PHP-FPM container:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要知道每个容器分配的名称，可以在终端上执行`docker ps`并复制容器名称。例如，我们将输入以下命令进入battle PHP-FPM容器：
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding command opens an interactive shell in your container so that
    you can do anything you want. Let''s install Lumen with a single command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在您的容器中打开一个交互式shell，以便您可以做任何您想做的事情。让我们用一个命令安装Lumen：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Repeat the preceding commands for each of your microservices.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个微服务重复上述命令。
- en: Now you have everything ready to start doing unit tests and code your application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好开始进行单元测试并编写应用程序代码了。
- en: Unit testing
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'A unit test is a small piece of code that uses other code in a known context
    so that we can check whether the code we are testing is valid. Lumen comes with
    PHPUnit out of the box; therefore, we only need to add all our tests to the tests
    folder. The framework installation comes with a very small sample file by default--`ExampleTest.php`--where
    you can give the unit testing a try. In order to start with unit testing and until
    you become more comfortable creating unit tests, choose one of your microservices
    sources and create the `app/Dummy.php` file with the following content:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一小段代码，它在已知的上下文中使用其他代码，以便我们可以检查我们正在测试的代码是否有效。Lumen默认带有PHPUnit；因此，我们只需要将所有测试添加到tests文件夹中。框架安装默认带有一个非常小的示例文件--`ExampleTest.php`--您可以在其中尝试单元测试。为了开始单元测试，直到您更加熟悉创建单元测试，选择一个您的微服务源代码，并创建`app/Dummy.php`文件，内容如下：
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The easiest way of starting with unit testing is every time you create a new
    class in your code, you can create a new one for your tests. Working this way,
    you will remember that your new class needs to be covered with unit tests. For
    instance, imagine that you need a `Battle` class; therefore, when you create the
    class, you can also create a new one with a `Test` prefix in your `tests` folder.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 开始单元测试的最简单方法是每次在代码中创建一个新类时，您都可以为测试创建一个新类。以这种方式工作，您将记住您的新类需要用单元测试进行覆盖。例如，想象一下您需要一个`Battle`类；因此，当您创建该类时，您还可以在`tests`文件夹中创建一个以`Test`为前缀的新类。
- en: 'In an ideal world, all your code is covered by unit tests but we know that
    this is an odd case. Most of the times, you will have 70% or 80% of code coverage
    if you are lucky. We encourage you to keep your code fully covered but if it is
    not possible, cover at least the core functionalities. There are two ways of creating
    unit tests:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的情况下，所有代码都应该由单元测试覆盖，但我们知道这是一个奇怪的情况。大多数情况下，如果幸运的话，您的代码覆盖率将达到70%或80%。我们鼓励您保持代码完全覆盖，但如果不可能，至少覆盖核心功能。有两种创建单元测试的方法：
- en: '**Tests first, code later:** In our opinion, this workflow is better when you
    have enough time to develop your project. First, you create the tests so that
    you are sure that you really know each new functionality. After you have the tests
    in place, you will write the minimum code necessary to pass the tests. Coding
    this way, you will be thinking about what makes your code valid and what can make
    your code fail.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先测试，后编码：**在我们看来，当您有足够的时间开发项目时，这种工作流程更好。首先，创建测试，以确保您真正了解每个新功能。在测试就位后，您将编写必要的最小代码以通过测试。以这种方式编码，您将思考什么使您的代码有效，以及什么可能使您的代码失败。'
- en: '**Code first, tests later:** This a very extended workflow when you don''t
    have too much time for unit testing. You create your code as always and, as soon
    as you have finished, you create the unit tests. This approach creates a less
    robust code because you are adapting your unit test to the already created code
    instead of doing it the other way around.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that it is important to always have time to test your code; it is a
    long-term investment. Spending time at the beginning will make your code more
    robust and will eliminate future bugs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You are probably wondering how you can run and check your tests. Don''t worry,
    it is very simple. You only need to enter one of your PHP-FPM containers. For
    example, to enter in the Battle PHP-FPM container, open your terminal and execute
    the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After executing the above command you will be inside the container. Now it
    is time to be sure that your current path is the `/var/www/html` folder. After
    you accomplish the previous step, you can execute phpunit inside that folder.
    All this actions can be done with the following commands:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `phpunit` command will read the `phpunit.xml` file. This XML describes where
    our tests are stored and executes all of them. The execution of this command will
    give us a pretty screen with the results of our passed or failed tests.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An assertion is a statement in a known context that we are expecting to be true
    at some point in our code and that is the core of unit testing. Assertions are
    used inside test cases and a test case can include multiple assertions inside
    the same tests. In PHPUnit, it is very simple to create a test as you only need
    to add the `test` prefix to your method name. Easy, isn't it? To clarify all these
    concepts, let's look at some assertions you can use in your unit tests with some
    examples. Feel free to create more complex tests until you are comfortable with
    PHPUnit.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: assertArrayHasKey
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `assertArrayHasKey(mixed $key, array $array[, string $message = ''''])`
    assertion checks whether `$array` has an element with `$key`. Imagine that you
    have a method that generates and returns some kind of configuration data and there
    is a specific element identified by `storage` that you need to be sure is always
    present. Add the following method to our `Dummy` class to simulate the configuration
    generation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can test the response of this `getConfigArray` in any way we want:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding test will check if the array returned by `getConfigArray` has
    an element identified by `foo`, which fails in our example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, this test will ensure that `getConfigArray` returns an element
    identified by `storage`. If, for some reason, you change the implementation of
    the `getConfigArray` method in future, this test will help you ensure that you
    keep receiving at least an array element identified by `storage`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: You can use `assertArrayNotHasKey()` as the inverse of `assertArrayHasKey;`
    it uses the same arguments.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: assertClassHasAttribute
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `assertClassHasAttribute(string $attributeName, string $className[, string
    $message = ''''])` assertion checks whether our `$className` has defined the `$attributeName`.
    Modify our `Dummy` class and add a new attribute, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can test the existence of this public attribute with the following tests:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code will pass the check of the `foo` attribute but will fail
    in checking the `bar` attribute.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: You can use `assertClassNotHasAttribute()` as the inverse of `assertClassHasAttribute;`
    it uses the same arguments.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: assertArraySubset
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `assertArraySubset(array $subset, array $array[, bool $strict = '''', string
    $message = ''''])` assertion checks whether a given `$subset` is available in
    our `$array`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding example test will fail because the `['storage' => 'failed-test']`
    subset does not exist in the response of our `getConfigArray` method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: assertClassHasStaticAttribute
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `assertClassHasStaticAttribute(string $attributeName, string $className[,
    string $message = ''''])` assertion checks the existence of a static attribute
    in a given `$className`. We can add a static attribute, like the following one,
    to our `Dummy` class:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Having this static attribute in place, we are free to test the existence of
    `$availableLocales`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In case of needing to assert the inverse, you can use `assertClassNotHasStaticAttribute();`
    it uses the same arguments.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: assertContains()
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you need to check if a haystack contains specific elements. You can
    do this using the `assertContains()` functions:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '`assertContains(mixed $needle, Iterator|array $haystack[, string $message =
    ''''])`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNotContains(mixed $needle, Iterator|array $haystack[, string $message
    = ''''])`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertContainsOnly(string $type, Iterator|array $haystack[, boolean $isNativeType
    = null, string $message = ''''])`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNotContainsOnly(string $type, Iterator|array $haystack[, boolean $isNativeType
    = null, string $message = ''''])`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertContainsOnlyInstancesOf(string $classname, Traversable|array $haystack[,
    string $message = ''''])`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: assertDirectory() and assertFile()
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PHPUnit not only allows you to test the logic of your application, but you
    can even test the existence and permissions of folders and files. All this can
    be achieved with the following assertions:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '`assertDirectoryExists(string $directory[, string $message = ''''])`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertDirectoryNotExists(string $directory[, string $message = ''''])`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertDirectoryIsReadable(string $directory[, string $message = ''''])`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertDirectoryNotIsReadable(string $directory[, string $message = ''''])`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertDirectoryIsWritable(string $directory[, string $message = ''''])`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertDirectoryNotIsWritable(string $directory[, string $message = ''''])`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileEquals(string $expected, string $actual[, string $message = ''''])`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileNotEquals(string $expected, string $actual[, string $message = ''''])`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileExists(string $filename[, string $message = ''''])`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileNotExists(string $filename[, string $message = ''''])`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileIsReadable(string $filename[, string $message = ''''])`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileNotIsReadable(string $filename[, string $message = ''''])`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileIsWritable(string $filename[, string $message = ''''])`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFileNotIsWritable(string $filename[, string $message = ''''])`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringMatchesFormatFile(string $formatFile, string $string[, string
    $message = ''''])`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringNotMatchesFormatFile(string $formatFile, string $string[, string
    $message = ''''])`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does your application rely on a writable file in order to work? Don't worry,
    PHPUnit has your back. You can add an `assertFileIsWritable()` to your tests so
    that the next time somebody removes the file you have specified in the assertion,
    the test will fail.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: assertString()
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases, you need to check the content of some strings. For instance,
    if your code generates serial codes, you can check whether the codes you generate
    match your specifications. You can use the following assertions with strings:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '`assertStringStartsWith(string $prefix, string $string[, string $message =
    ''''])`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringStartsNotWith(string $prefix, string $string[, string $message
    = ''''])`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringMatchesFormat(string $format, string $string[, string $message
    = ''''])`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringNotMatchesFormat(string $format, string $string[, string $message
    = ''''])`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringEndsWith(string $suffix, string $string[, string $message = ''''])`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertStringEndsNotWith(string $suffix, string $string[, string $message =
    ''''])`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: assertRegExp()
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `assertRegExp(string $pattern, string $string[, string $message = ''''])`
    assertion will be very useful for you as you have all the regex power in one assertion.
    Let''s add a static function to our Dummy class:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This new function returns a static string code. Feel free to complicate the
    generation. To test this generated string code, you can now do something like
    this in your test class:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we are using a simple regular expression to check the output
    generated by `getRandomCode`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: assertJson()
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Working with microservices, you will probably be working very closely with
    JSON requests and responses. Therefore, it is very important that you have the
    ability to test our JSONs. You can have a JSON as a file or as a string:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '`assertJsonFileEqualsJsonFile()`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertJsonStringEqualsJsonFile()`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertJsonStringEqualsJsonString()`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean assertions
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Boolean results or types can be checked with the following methods:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '`assertTrue(bool $condition[, string $message = ''''])`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFalse(bool $condition[, string $message = ''''])`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type assertions
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you need to ensure that an element is an instance of a specific class
    or has a specific internal type. You can use the following assertions in your
    tests:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '`assertInstanceOf($expected, $actual[, $message = ''''])`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertInternalType($expected, $actual[, $message = ''''])`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other assertions
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PHPUnit has a high number of assertions and your tests can''t be completed
    without some of the following assertions applied to results or object states of
    your features:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '`assertCount($expectedCount, $haystack[, string $message = ''''])`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEmpty(mixed $actual[, string $message = ''''])`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEquals(mixed $expected, mixed $actual[, string $message = ''''])`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertGreaterThan(mixed $expected, mixed $actual[, string $message = ''''])`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertGreaterThanOrEqual(mixed $expected, mixed $actual[, string $message
    = ''''])`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertInfinite(mixed $variable[, string $message = ''''])`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertLessThan(mixed $expected, mixed $actual[, string $message = ''''])`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertLessThanOrEqual(mixed $expected, mixed $actual[, string $message = ''''])`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNan(mixed $variable[, string $message = ''''])`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNull(mixed $variable[, string $message = ''''])`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertObjectHasAttribute(string $attributeName, object $object[, string $message
    = ''''])`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertSame(mixed $expected, mixed $actual[, string $message = ''''])`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more information about the assertions you can use on the PHPUnit
    website, that is, [https://phpunit.de/](https://phpunit.de/).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing from scratch
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you probably feel more comfortable with unit testing and you
    want to start coding your app as soon as possible, so let's get started with testing!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Our microservices application uses geolocalization to find secrets and other
    players. This means that your location microservice will need a way to calculate
    the distance between two geospatial points. We will also need, given an origin
    point, to get a list of the closest stored points (they can be the closest users
    or secrets). As this is a core feature, you need to ensure that what we described
    is fully tested.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app, the localization has its own service. Therefore, open the source
    code of the location microservice with your IDE and create the `app/Http/Controllers/LocationController.php`
    file with the following content:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code has created our location controller in Lumen and, as we mentioned
    before, as soon as we have this class created, we need to create a similar class
    for our unit tests. In order to do this, you only need to create the `tests/app/Http/Controllers/LocationControllerTest.php`
    file. As you can see, we are even replicating the folder structure; this is the
    best approach to easily know which class we are testing for.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to start creating tests for the distance calculation and for the function that
    allows us to get the closest secrets given a specific geolocation point. One approach
    is to create two different tests. Therefore, fill your `LocationControllerTest.php`
    with the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We didn't add anything special to our test class, we only declared two tests.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `testDistance()`. In this test, we want to ensure that given
    two geospatial points, the calculated distance between them is accurate enough
    for our purposes. In unit testing, you need to start describing the known scenario--as
    points, we have chosen London (latitude: `51.50`, longitude: `-0.13`) and Amsterdam
    (latitude: `52.37`, longitude: `4.90`). The known distance between these two cities
    is around 358.06 km, and this is the result we aim to get from our distance calculator.
    Let''s fill our test with the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding piece of code, we defined the known scenario, the location
    of our two points and the distance known between them. Once we had our known scenario
    ready, we created an instance of our `LocationController` and we used the defined
    `getDistance` function to obtain a result we want to test. As soon as we got the
    result, we tested that our `LocationController` had a `conversionRate` static
    attribute that we can use to transform the distance to different units. Our last
    and most important assertion checks the match between the calculated distance
    and the known distance between these two points. We have our basic test ready,
    and it is time to start coding our `getDistance` function.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The distance calculation between two geospatial points can be calculated in
    very different ways. You can use a strategy pattern here, but to keep the example
    simple we will code the different calculation algorithms in different functions
    inside our controller.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `LocationController` and add some auxiliary code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we have defined our conversion rates, a constant we can
    use to round our results, and a simple conversion function. We will use this `convertDistance`
    function later.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first approach for distance calculation is to use the Euclidean function
    to get our result. A simple implementation is described in the following code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have our algorithm ready, we can add it to our `getDistance` function,
    as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At this point, you have everything in place and you can start the tests. Enter
    the location container and run PHPUnit in `/var/www/html`. This is our first approach;
    the PHPUnit result will be a fail, and the output of this application will tell
    you where the problem is. In our case, the main reason for the fail is that the
    algorithm we used is not accurate enough for our application. We can't deploy
    this version of our application because it has failed tests and we have to change
    our test or the code that implements our tests.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, there are multiple ways of calculating the distance
    between two points and each one can be more or less accurate. The first implementation
    we tried failed because it is used for plains and our world is a sphere.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `LocationController` again and create a new distance implementation
    using a haversine calculation:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, this distance calculation function is a little more complex
    and considers the spherical form of our world. Change the `getDistance` function
    to use our new algorithm:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now run PHPUnit again and everything should be okay; the test will pass and
    our code is ready for production.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'With unit testing and TDD, the process is always the same:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Create the tests.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make your code to pass the tests.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests and if they fail, start again from step 2.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another feature we want to have in our location microservice is to get the
    closest secrets we have near our current position. Open the `LocationControllerTest`
    file and add the following code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding piece of code, we defined our current location (New York) and
    asked our implementation to give us a list of the closest secrets. Our location
    implementation will have a cache list of secrets, and we know where they are located
    (this will help us to know the correct order).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `LocationController.php` and first add a cache list of secrets. In the
    real world, we don''t have hardcoded values, but it''s good enough for testing
    purposes:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once we have our list of secrets ready, we can add our `getClosestSecrets`
    function as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code, we used our cache list of secrets to calculate the distance between
    the origin point and each of our secret points. As soon as we had the distance,
    we sorted the result and returned the closest three.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Running PHPUnit in our location container will show us that all the tests are
    being passed, giving us the confidence to deploy our code to production.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Future commits can make changes to the distance calculation or to the closest
    function, and they can break our tests. Luckily for you, there is a unit testing
    covering them and PHPUnit will throw an alert, so you can start rethinking your
    code implementation.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Let your imagination fly and test everything--from the simple and small case
    to any odd and obscure case you can imagine. The idea is that your application will
    break and break very badly, in the middle of the night or during your holidays.
    There is nothing you can do about this except adding as many tests as you can
    so that you can ensure that the release you have in production is stable enough
    to reduce the risks of breaking.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Behat
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Behat is an open source behavior-driven development framework. All the Behat
    tests are written in plain English and wrapped into readable scenarios. This framework
    uses the Gherkin syntax and was inspired by Cucumber, a Ruby tool. The main advantage
    of Behat is that most of the test scenarios can be understood by anyone.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Behat can be easily installed using Composer. You only need to edit the `composer.json`
    of each microservice and drop a new line with `"behat/behat" : "3.*"`. Your `require-dev`
    definition will be as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once you have updated the `dev` requirements, you need to enter each of your
    PHP-FPM containers and run Composer:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Test execution
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running Behat is as easy as running PHPUnit. You only need to enter your PHP-FPM
    container, go to the `/var/www/html` folder, and run the following command:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Behat example from scratch
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the key features of our microservices application is the ability to
    find secrets. Users should be able to save the secrets and, for this, they need
    a wallet. So, let''s write our user-story in our user microservice:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see, the test can be understood by anyone in the project--from the
    developers to the stakeholders. Each test scenario always has the same format:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can add some modifiers to the preceding basic template (and or but) to empower
    the scenario description. At this point, with your scenario ready, you can save
    it as a `features/wallet.feature` file.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time you start writing a Behat test on your project, you need to
    initialize the suite with the following command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding command will create the files needed by Behat to run the scenario
    tests. The main file we will use is `features/bootstrap/FeatureContext.php`; this
    file will be our test environment.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our `FeatureContext` file in place, it is time to start creating
    our scenario steps. For example, place the following method in your `FeatureContext`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Behat uses doc-blocks for step definitions, step transformations, and hooks.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding piece of code, we are telling Behat that the `thereIsA()`
    function matches each `Given there is a(n)` step. In our example, that definition
    will match the steps in the following cases:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Given that there is an amber
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a diamond
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to map each of our scenario steps so that our `FeatureContext` will
    end up as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our tests use external classes that we need to define. These classes implement
    our logic and, for example, purposefully create the `features/bootstrap/SecretsCache.php`
    with the following content:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You also need to create `features/bootstrap/Wallet.php` with the following
    sample code:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding two classes are the implementation of our tests and, as you can
    see, they have the logic of storing secrets in a wallet. Now, if you run `vendor/bin/behat`
    on your console, the tool will check all our test scenarios and give us confidence
    that our code will behave the way we want it to.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: This was a simple example of testing an application with Behat. In our GitHub
    repository, you can find more specific examples. Also, feel free to explore the
    Behat ecosystem; you can find multiple tools and extensions that can help you
    test your application.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Selenium
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Selenium is a suite of tools to automate web browsers across many platforms
    and can be used as a browser extension, or it can be installed on a server to
    run our browser tests. The main advantage of Selenium is that you can easily record
    a full user journey and create a test from the record. This test can be later
    added to your pipeline to be executed on each commit to discover regressions.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Selenium WebDriver
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The WebDriver is the API that you can use to run your browser testing from other
    tools. It is a powerful testing environment normally placed in a dedicated server
    where it sits waiting to run browser tests.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Selenium IDE
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Selenium IDE is a Firefox extension that allows you to record, edit, and
    debug browser tests. This plugin is not only a recording tool, but a full IDE
    with autocomplete functionalities. You can even record and create tests with the
    IDE and later run them with the WebDriver.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, Selenium is used as a complimentary testing tool executed
    from another testing framework. For instance, you can improve your Behat tests
    with Selenium thanks to the Mink project ([http://mink.behat.org/en/latest/](http://mink.behat.org/en/latest/)).
    This project is a wrapper for different browser drivers, so you can use them in
    your BDD workflow.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about the deployment of our application in [Chapter 7](ch07.html
    "Chapter 7. Security"), *Security*. We will learn how to automate all these tests
    and integrate them in our CI/CD workflow.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you studied the importance of using tests on your application,
    tools such as Behat and Selenium, and also about implementing driven development.
    In the next chapter, you will study error handling, dependency management, and
    the microservices framework.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
