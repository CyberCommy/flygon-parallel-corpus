- en: Synchronizing the Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we built a network that was made up of five nodes.
    Every node was aware of all the other nodes in the network, which created a decentralized
    blockchain network. We now need to create a synchronized network, so that the
    blockchain on every node is the same and data is consistent throughout. We can't
    afford to have different versions of the blockchains running on different nodes,
    because this would totally destroy the purpose of having a blockchain. There should
    only be one version of the blockchain that is consistent across every node. Therefore,
    in this chapter, let's synchronize the network that we built in [Chapter 4](c20cb1a2-adc8-41e7-960d-5fd43abf8754.xhtml),
    *Creating a Decentralized Blockchain Network*. We'll do this by broadcasting transactions
    and new blocks that have been mined across all the nodes in the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need to synchronize the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `/transaction/broadcast` endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring the `createTransaction` method and the `/transaction` endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the transaction endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the mining information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `/receive-new-block` endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the new and updated `/mine` endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started with synchronizing the network.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need to synchronize the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to understand why the network needs to be synchronized. We currently
    have a decentralized blockchain network that consists of five nodes. The data
    across these nodes is not consistent; data on each node might vary, which would
    lead to the failure of the purpose of having a blockchain. Let''s try to understand
    this situation with the help of an example. Go to Postman and send a sample transaction,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95e23e83-399c-4276-8668-a3db6e116ee3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Send this transaction to the node that''s hosted on `localhost:3001` by clicking
    on the Send button. This transaction will appear in the `pendingTransactions`
    array of `localhost:3001/blockchain`, which you can observe in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5479e71-514c-4ebf-b15e-858d0f704ec1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, go to any of the other nodes and check for the transactions that were sent.
    We won't be able to view the transactions in the `pendingTransactions` array on
    those nodes. The sample transaction that is sent will only be present in the node
    on `localhost:3001`. It isn't broadcast to any other nodes in the network.
  prefs: []
  type: TYPE_NORMAL
- en: What you are going to do in this chapter is to refactor the `/transaction` endpoint,
    so that whenever a transaction is created, it is broadcast to all nodes. This
    means that all nodes will have the same data. We need to do the same thing in
    order to mine a block. Let's refactor the `/mine` endpoint so that whenever a
    new block is mined, it is also broadcast throughout the entire network. This means
    that the entire network is synchronized and has the exact same number of blocks. Having
    data synchronized through the network is an important feature of blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the createNewTransaction method and the /transaction endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let's refactor the `createNewTransaction` method by splitting
    it into two separate parts. One part will simply create a new transaction and
    then return that transaction, and the other part will push the new transaction
    into the `pendingTransactions` array. We'll do the latter part by creating a separate
    method for it. We also create a new transaction endpoint called `/transaction/broadcast`.
    This endpoint will allow us to broadcast transactions throughout the entire blockchain
    network, so that every node has the same data and so that the entire network is synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: Modifications to the createNewTransaction method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, let''s split up the `createNewTransaction` method into two separate methods,
    by modifying it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `createNewTransaction` method in your `dev/blockchain.js` file. We
    built this method in [Chapter 2](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml),
    *Building a Blockchain* in the *Creating createNewTransaction method* section. For
    reference, take a look at the following `createNewTransaction` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make the following highlighted modifications to the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, an ID is added to every transaction. To create this ID, a unique string
    is used, which is very similar to what we had used for creating the node addresses
    in [Chapter 3](fc6f37c3-df49-46cc-8618-704953dea6a9.xhtml), *Accessing the Blockchain
    through an API.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Unique strings for the IDs are created with the use of the `uuid` library.
    Therefore, at the start of the `dev/blockchain.js `file, where all the constants
    are defined, you need to add the following line of code in order to use the `uuid`
    library in our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the modified method, you can observe that the following line of code was
    added to create unique strings for the `transactionId` values. This is where the
    use of the `uuid` library was implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `.split()` function will take out the dashes that are added to the
    unique string, and then, the `.join()` function will rejoin the string to give
    an output of a unique `Id` for each transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Building the addTransactionToPendingTransactions method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we need to push the `newTransaction` that was returned to the `pendingTransactions`
    array of the blockchain. Therefore, let''s create another method, called `addTransactionToPendingTransactions`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `dev/blockchain.js` file, the `addTransactionToPendingTransactions` method
    will be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take the `transactionObj` and push it to the `pendingTransactions` array
    of the blockchain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we simply want to return the index of the block to which the transaction
    is added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To recap quickly, we modified the `createNewTransaction` method which creates
    a new transaction, and returns that new transaction. We then created a new method,
    called `addTransactionToPendingTransactions`. This method takes in a `transactionObj` and
    adds it to the `pendingTransactions` array on the blockchain. After that, we simply
    returned the index of the block to which the new transaction was added.
  prefs: []
  type: TYPE_NORMAL
- en: Building the /transaction/broadcast endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, let''s build a new endpoint called `/transaction/broadcast`. Anytime
    we want to create a new transaction from now on, we''re going to hit this `/transaction/broadcast`
    endpoint. This endpoint will do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It will create a new transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will then broadcast that new transaction to all the other nodes in the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go through the following steps to create the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add this endpoint, go to the `dev/networkNode.js` file where we have defined
    all the endpoints, and add this new endpoint as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in order for the endpoint to carry out the aforementioned functionalities,
    add the following highlighted code to the endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `createNewTransaction()` method here is the modified method from the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createNewTransaction()` method takes in the `amount`, `sender`, and `recipient` parameters.
    For our endpoint, let''s assume that all of that data is being sent on the `req.body`.
    Therefore, those parameters will be defined as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add the `newTransaction` variable to the `pendingTransactions`
    array on the node with the help of the `addTransactionToPendingTransactions` method.
    Therefore, after the preceding line of code, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, broadcast the new transactions to all the other nodes inside the network.
    This can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this `forEach` loop, let''s define the code to broadcast the transactions.
    To do this, make requests to the `/transaction` endpoints on all the other nodes
    inside the network. Therefore, define some options for these requests. Inside
    of the loop, let''s add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define all our options, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create an array of promises to push all the requests into that
    array, so that we can run all the requests at the same time. Let''s define the
    array before the `forEach` loop as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after defining all of the options, make the request as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this preceding line of code, we're going to push all the requests into
    the `requestPromises` array. After the `forEach` loop has run, we should have
    all of the requests that we have defined inside the `requestPromises` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s run all of the requests. After the `forEach` loop, add the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after all the requests have run, we''ll add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re not actually going to use the data that comes back from all of these requests,
    but we are going to send a response, because, at this point, the entire broadcast
    is complete. Therefore, inside the preceding block of code, add the following
    highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By adding this preceding line of code, we have successfully completed building
    the `/transaction/broadcast` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the /transaction endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to refactor the `/transaction` endpoint in this section, so that
    it works perfectly with the new `/transaction/broadcast` endpoint. Let''s apply
    the following steps to modify the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, go to the `dev/networkNode.js` file and delete everything that
    is in the `/transaction` endpoint. The only time the `/transaction` endpoint will
    be hit is when the broadcast takes place. When the `/transaction` endpoint is
    being hit, the `newTransaction` variable will be sent as data. This condition
    can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding highlighted line, the `newTransaction` variable is sent to
    the `/transaction` endpoint with the help of `req.body`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the new transaction to the `pendingTransactions` array of whichever
    node receives the call. To do this, the new `addTransactionToPendingTransactions` method
    will be used. Therefore, after the preceding line of code, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This method simply takes in the `newTransaction` variable that is received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from the `addTransactionToPendingTransactions` method, we get the index
    of the block in which the transaction will be added. Let''s save this block index
    in the new `/transaction` endpoint. At the start of the preceding line of code,
    add the variable as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The final thing to do is to send back a response. After the preceding line,
    add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We've now finished refactoring the `/transaction` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the transaction endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's test the `/transaction/broadcast` and `/transaction` endpoints to make
    sure that they are both working together correctly.
  prefs: []
  type: TYPE_NORMAL
- en: For this test, the first thing that we need to do is connect all the nodes together
    to make a network. You might remember how to do this, as we learned about it in
    [Chapter 4](c20cb1a2-adc8-41e7-960d-5fd43abf8754.xhtml), *Creating a Decentralized
    Blockchain Network*. We'll run through the steps quickly anyway, to refresh your
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: Recapping how to create the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following steps to understand how to connect all the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Postman and hit the `/register-and-broadcast-node` route. This can be
    done on any of your nodes. In our example, let's use `localhost:3001`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, inside the body, we want to add a new node to our network by passing its
    URL. Let''s start with our second node. Take a look at the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/87b035cc-5c80-4530-bb18-f0aea1856317.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, click on the Send button to send the request. After sending the request,
    you'll receive a response that says New node registered with the network successfully.
    You can send all the remaining nodes in the same way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify if all the nodes are connected properly to form a network, head over
    to the browser, type `localhost:3001/blockchain` in the address bar, and press
    *Enter*. You will see all the nodes in the `networkNodes` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing the transaction endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the blockchain network is set up, let's the test the endpoints that
    we created in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a transaction and send it to the `/transaction/broadcast` endpoint.
    Go back to Postman and hit the `/transaction/broadcast` endpoint at the node,
    which is hosted on port `3001`. Here, send some data as a transaction, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2f60fb5-2915-4f33-8eed-905d7fcc8109.png)'
  prefs: []
  type: TYPE_IMG
- en: The transaction data that you're sending can be any random data. All we need
    is the amount, the sender, and the recipient. Once the transaction data is added,
    let's send this request by clicking on the Send button. If the transaction is
    sent successfully, a response will be received that says, Transaction created
    and broadcast successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go to the browser, and you should be able to see the transaction that
    we created on every single node of the network. Let''s check whether this worked.
    In the address bar of the browser, type `localhost:3001/blockchain` and then press
    *Enter*. You should see the transaction data inside the `pendingTransactions`
    array, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b969bc3-62c2-44e6-bedd-56cdbb94b9ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the transaction that is inside the `pendingTransactions` array now also
    has a `transactionId` value, which starts with a random hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open another tab and type `localhost:3002/blockchain` in the address
    bar, then press *Enter*. You can see that the same transaction data can be seen
    in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ba59d42-0dbb-4812-ba14-19c3db20d31e.png)'
  prefs: []
  type: TYPE_IMG
- en: If you go over to the other nodes in the network, you can carry out a similar
    check for all the remaining nodes. You can observe the same transaction data in
    the `pendingTransactions` array of each node. Every node inside the blockchain
    network is now aware that a new transaction was created.
  prefs: []
  type: TYPE_NORMAL
- en: You can try testing the endpoints with other transaction data as well. Try to
    change the amount to `500`, and the address of the sender and the recipient to
    a random hash string, and try sending this request to the node that's hosted on
    `localhost:3004`. This shouldn't make a difference, because the broadcast endpoint
    sends the transaction data to all the nodes inside of the network. Therefore, this
    request should work just like the last one. Checking the response on the browser,
    you should be able to see two transactions with different transaction IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Try experimenting with different transaction data to gain a clear understanding
    of how the `/transaction` and `/transaction/broadcast` endpoints work.
  prefs: []
  type: TYPE_NORMAL
- en: From the test, we can conclude that the `/transaction/broadcast` endpoint and
    the `/transaction` endpoint are both working properly as we expected them to.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll continue synchronizing the network by refactoring
    the `/mine` endpoint, so that it will broadcast the new blocks that are created
    to the entire network.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the mining information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing that is required to synchronize the network is to update the
    `/mine` endpoint. We are also going to add a new endpoint, called `/receive-new-block`.
    There's a need to update the `/mine` endpoint so that whenever a new block is
    created by a node, that new block is broadcast to all the other nodes in the network.
    This means that every node on the network is aware that a new block has been created
    and all the nodes hosting the blockchain stay synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: The updated mining process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever a new block is mined, it will be mined on a particular node. To understand
    the updated mining process, let''s assume that we want a node, hosted on port `3001`,
    to mine a new block for the blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the `/mine` endpoint will be hit on the selected node. When the `/mine`
    endpoint is hit, a new block is created by doing a proof of work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the new block is created, it is broadcast to all the other nodes in the
    network. All the other nodes will receive that new block at their `/receive-new-block` endpoint. This
    is shown in the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/47f680ef-e0fc-49c0-ba54-d009efa5bd36.png)'
  prefs: []
  type: TYPE_IMG
- en: After the broadcast is complete, the entire network will be synchronized and
    all the nodes will host the same blockchain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another thing to note is that when a new block is broadcast and a node receives
    it, that new block will be added to the chain after the chain has validated that
    the block is legitimate. Then, the node clears out its `pendingTransactions` array,
    because all the pending transactions are now within the new block they just received.
  prefs: []
  type: TYPE_NORMAL
- en: In the next couple of sections, we're going to build this whole process step
    by step. As we build each of these steps, it should be easier to see how everything
    works together.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the /mine endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s refactor the `/mine` endpoint by implementing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to the `dev/networkNode.js` file. In the `/mine` endpoint, beneath
    the part where we had defined the `newBlock` variable, let''s add the functionality
    to broadcast the new block to all the other nodes in the network. To do this,
    follow the same process that we introduced in the previous sections—that is, to
    loop through all the other nodes inside the network, make a request to the nodes,
    and send the `newBlock` variable as data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line mentions that for each of the `networkNodes`, we're going
    to make a request and send along the `newBlock`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need some request options to send. These options will be defined as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first option in this object is the `uri`. The `uri` to which we want to
    send the request will be the `networkNodeUrl` and the new endpoint that we are
    going to create, which will be `/receive-new-block`. We''ll work on this endpoint
    in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next option to be added is the method that will be used, which is the `POST`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s send along the data that will be inside the body. We also want
    to send along a `newBlock` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after the `body`, set `json` to `true`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, make the request by adding the following highlighted line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time one of these requests is made, it''s going to return a promise.
    Let''s make an array of all of these promises by adding the following highlighted
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After our `forEach` loop has run, we should have an array that is filled with
    promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s run all of those promises. Therefore, after the `forEach` block,
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After all of the requests have run, we want to carry out another calculation
    inside `.then(data => {    })`. If you remember, when a new transaction is created,
    the mining rewards transaction code, `bitcoin.createNewTransaction(12.5, "00"
    , nodeAddress);`, needs to be broadcast throughout the entire blockchain network.
    At the moment, when a new block is mined, we create a mining reward transaction,
    but it is not broadcast to the whole network. To broadcast it, the request will
    be sent to the `/transaction/broadcast` endpoint, because it already has the functionality
    to broadcast transactions. We're just going to make a call to this endpoint with
    the mining reward transaction data passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before passing the mining reward transaction data, however, we need some request
    options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `body` data will be sent as an object. In the `body`, let''s add the mining
    reward transaction data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after the `body`, set `json` to `true` by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after the `requestOptions`, let''s send the following request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, inside the `/mine` endpoint, a bunch of calculations are being
    carried out to create a new block. Then, once the new block is created, it is
    broadcast to all the other nodes inside the network. After the broadcast is complete
    inside the `.then` block, a new request to the `/transaction/broadcast` endpoint
    is made. This request will create a mining reward transaction and the nodes will
    then broadcast it to the entire blockchain network. Then, after the request runs
    and all of the calculations are complete, a response is sent: New block mined
    successfully.'
  prefs: []
  type: TYPE_NORMAL
- en: You can view the complete updated mine endpoint code at [https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/blob/master/dev/networkNode.js](https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/blob/master/dev/networkNode.js).
  prefs: []
  type: TYPE_NORMAL
- en: Building the /receive-new-block endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing that we''re going to do is build the `/receive-new-block` endpoint
    that we use in the updated `/mine` endpoint. Let''s get started on building the
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `dev/networkNode.js` file, before the `/register-and-broadcast-node`
    endpoint, define the `/receive-new-block` endpoint as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this endpoint, the code expects to receive a new block that is being
    broadcast. Let''s save that new block in a variable, as highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When all of the other nodes receive this new block, they need to check whether
    it''s actually a real block and whether it fits into the chain properly. To verify
    this, the `previousBlockHash` on the `newBlock` is checked to make sure that it''s
    equal to the hash on the last block in the chain. For this, access to the last
    block in the chain is required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s test if the hash of the last block in the chain is equal to the `previousBlockHash` in
    the `newBlock` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, we know that this `newBlock` does indeed come right after the `lastBlock`
    in the chain. The preceding statement that is defined will return either `true`
    or `false`. The `true` or `false` value will be saved in a `correctHash` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preceding check, we also want to make sure that the `newBlock` has
    the correct index. This means that the `newBlock` should be one index above the
    `lastBlock` in the chain. Add the following check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, two different actions need to be taken depending on whether or not the `newBlock`
    is legitimate. If the `newBlock` is legitimate, it should be accepted and added
    to the chain. If not, it should simply be rejected. In order to define this condition,
    let''s use an `if`-`else` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, since the `newBlock` has been added to the chain, the `pendingTransactions` array
    needs to be cleared out, because the pending transactions are now inside the new
    block. Therefore, inside the `if` statement, the next condition to be added is
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the final thing that needs to be done is to send a response back, saying
    that the block has been accepted and added to the chain. Inside the `if` statement,
    below the preceding line, add the response as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `newBlock` is not legitimate and does not pass either of the tests defined
    previously, then a response is sent inside of the `else` statement to indicate
    that the block was rejected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: With the addition of this previous condition, we've finished building the `/receive-new-block`
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the new and updated /mine endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test the updated `/mine` endpoint and the `/receive-new-block` endpoint
    that we just created. Basically, the `/mine` endpoint will mine the new block
    for us. It will also take that block and broadcast it across the entire blockchain
    network so that every node is synchronized and all the nodes have the same blocks
    and the same data. This is the result we expect to observe when we test the `/mine`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you should have all five of the nodes running. You should also
    have connected them together to create a blockchain network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, go to the browser. The first thing to do here is to choose a node to
    mine the new block. We have got five nodes to choose from but in our case, we
    will just stick with the first node. Therefore, type `localhost:3001/mine` in
    the address bar and then hit *Enter*. You will get an output like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/23699e8a-d66a-44cb-9621-c9eb26d4a4a5.png)'
  prefs: []
  type: TYPE_IMG
- en: It looks like the mine endpoint has worked perfectly. The response indicates
    that the new block has been mined and broadcast successfully. You can also see
    the new block in the preceding screenshot with its index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s verify if the new block has been added to the network. First, verify
    it on the first node. In the browser, open another tab, type `localhost:3001/blockchain` in
    the address bar, and then press *Enter*. You can see that the new block has been
    added to the network as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/070cd0e5-35f0-4ba8-9d7b-eafda9c28a20.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you might also notice that there are some transactions
    present in the `pendingTransactions` array.  This pending transaction is actually
    the mining reward for the block that we just mined. The updated `/mine` endpoint
    defines that the mining reward transaction should be broadcast after a new block
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, whenever a new block is created, the mining reward for that block
    will go into the `pendingTransactions` array and will be added to the next block.
    This is how mining rewards work in the Bitcoin blockchain. When we first created
    our blockchain in the first two chapters, we put the mining reward right into
    the block that we mined. Now that the blockchain is more advanced and we've got
    a decentralized network, it's important for us to follow best practices and put
    the mining reward into the next block.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to the `/mine` endpoint and continue with the testing. Let's
    check the other nodes inside the network and verify whether the new block that
    was mined is added to those nodes or not. Also, let's check that the mining reward
    that was generated is also broadcast to the other nodes in the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another tab, type `localhost:3002/blockchain` in the address bar, and
    then press *Enter*. You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f734e62b-ecbf-42b6-92b6-4399269bacce.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see that the node on port `3002` received
    the newly mined block, along with the mining reward transaction. You can verify
    this for the remaining nodes in the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now mine another block from a different node. Instead of going to `localhost:3001`,
    type `localhost:3004/mine` in the browser''s address bar, and then press *Enter*.
    The new block will be mined; the output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94a59daa-dcdc-4080-96ac-ada1e5e99ea6.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, you can observe that this is the third block.
    This is correct because we have mined two blocks already. Inside the block's `transactions`
    array, you can see that we've got the mining reward from the previous block. This
    transaction was the mining reward that was generated when the node on port `3001`
    mined the previous block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to `localhost:3001/blockchain` and verify if this new block that
    we just mined has been added to the network. You will see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4040f16-0989-4758-aff8-66b3416b0bca.png)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, you can observe that the new block that was mined has been
    added to the node hosted on `3001`. The transaction array of this block consists
    of the mining reward from the previous block. We now also have a new mining reward
    in the `pendingTransactions` array, which was generated when the third block was
    mined. Following a similar process of verification, as we used before, you can
    check if the third block that we mined has been added to all the remaining nodes.
  prefs: []
  type: TYPE_NORMAL
- en: From these tests, it looks like the `/mine` endpoint is working just as it should.
    It's creating new blocks and broadcasting them to the entire network. This means
    the entire network is synchronized and has the exact same blockchain data, which
    is really important for a blockchain to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test the endpoint a little further. Head over to Postman, create a couple
    of transactions, and then broadcast them. After that, let''s mine a new block
    to see if the new transactions have been added to the blockchain correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to your Postman now and create the following transaction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b1d4bf96-cfd8-465a-a696-bd85c8ebe6b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, in order to broadcast the transaction, hit the `/transaction/broadcast`
    endpoint. You can send this transaction data to any node and it should be broadcast
    to the entire network. In our example, let''s send this transaction to the node
    on port `3002`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f5d8682a-6ae2-403d-a1a7-991f9fe295a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, click on the Send button. You'll then receive a response as the transaction
    was created and broadcast successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also try making other transactions just as we did previously, by changing
    the amount value and the sender's and recipient's addresses. Another test would
    be sending the transaction data to different nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now head back to the browser and check the nodes to verify that they''ve
    all received the transactions that we just created. As we loaded the node `3001`
    previously in our browser, let''s refresh it. You should get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/615252da-d04b-4aeb-8638-a48cb160e6aa.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, you can observe that the node has all three of
    the transactions that we created, plus it has the mining reward from the previous
    block inside the `pendingTransactions` array. Similarly, you can verify the `pendingTransaction`
    array for the remaining nodes. Thus, we can conclude that all of the transactions
    that we created are being broadcast to the entire network perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s mine a new block to verify whether all the pending transactions
    have been added to the new block. For this example, let''s mine a new block on node
    `3003` by typing `localhost:3003/mine` in the address bar of the new tab. The
    response will indicate that the block was mined and broadcast successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f5d3c19-68fc-4856-8426-5ef408dbe097.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screenshot, in the `transactions` array, it looks like all
    the transactions that we have created are present in the newly mined block. Let''s
    go to all the nodes and verify whether the transactions that we created are added
    to the new block. On `localhost:3001`, you can observe the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acb06fbf-885b-42cb-9e42-47f77aa2a7c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From this screenshot, we can observe that we''ve now got a fourth block that
    contains all the transactions that we sent. Then, if you check the `pendingTransactions`
    array, you can see that the transaction data has been cleared out and the new
    mining reward is present in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f703b8ef-1858-413a-8d6d-fe11a57bacf7.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we created a couple of new transactions on different nodes.
    These were then broadcast to the whole network successfully. Then, we mined a
    new block and all the transactions we created were added to that new block successfully.
    On top of that, our newly mined block was broadcast to all the nodes inside our
    blockchain network. All of the nodes across our entire network are now synchronized
    and all contain the same blockchain data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, you've achieved a lot in this book. You have created a decentralized
    blockchain network that's currently running across five nodes, and you built the
    functionality to synchronize the entire network, so that all the nodes have the
    exact same data. This mirrors how a blockchain would function in a real-world
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we successfully synchronized the entire blockchain network
    by refactoring the endpoints to broadcast the data to all the nodes present in
    the network. We started by splitting the functionality of the `/createNewTransaction`
    method into two separate parts: the `/createNewTransaction` method and the `addTransactionToPendingTransactions`
    method. Then, we built the `/transaction/broadcast` endpoint to broadcast the
    newly created transaction to all the nodes in the network. We also refactored
    the `/transaction` endpoint, so that the `/transaction/broadcast` endpoint and
    the `/transaction` endpoint could work together. Later on in the chapter, we refactored
    the `/mine` endpoint and also built a new endpoint, `/receive-new-block`. With
    the help of these endpoints, the newly created blocks can be broadcast to all
    the nodes in the network.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be building consensus algorithms to make sure that
    all of the nodes inside our network can agree on the correct data to hold inside
    the blockchain.
  prefs: []
  type: TYPE_NORMAL
