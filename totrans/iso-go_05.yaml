- en: End-to-End Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**End-to-end application routing** is the magic that allows us to leverage
    the benefits of the classic web application architecture along with the benefits
    of the single page application architecture. When implementing modern web applications,
    we have to strike a balance between satisfying the needs of two distinct audiences—humans
    and machines.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's first consider the experience from the human user's perspective. When
    a human user directly accesses the About page that we demonstrated in the previous
    chapter, template rendering is initially performed on the server side. This provides
    an initial page load that is perceived to be fast by the human user, since the
    web page content is readily available. This is the hallmark of the classic web
    application architecture. A different approach was taken for subsequent user interactions
    with the website. When the user clicked on the link to the About page from the
    navigation menu, template rendering was performed on the client side without the
    need of a full page reload, allowing for a more smooth and fluid user experience.
    This is the hallmark of the single page application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Machine users consist of the the various search engine bot crawlers that periodically
    visit the website. As you learned in the [Chapter 1](c90ed736-d3cf-4c9b-bae7-c8b894e25259.xhtml),
    *Isomorphic Web Applications with Go*, single page applications, are primarily
    not search-engine friendly since the vast majority of search engine bots don't
    have the intelligence to traverse them. Traditional search engine bots are accustomed
    to parsing well-formed HTML markup that has already been rendered. It's much more
    difficult for the bots to be trained to parse through the JavaScript that is used
    to implement the single page application architecture. If we want greater search
    engine discoverability, we must satisfy the needs of our machine audience.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of striking the balance between fulfilling the needs of these two distinct
    audiences is the essence of isomorphic web applications. We will learn how to
    accomplish this goal, in this chapter, while we implement the product-related
    pages of IGWEB.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Routing perspectives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design of the product-related pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing product-related templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling product data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing product data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering server-side routes with Gorilla Mux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side handler functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering client-side routes with the isokit router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side handler functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rest API endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing perspectives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider how routing works in an Isomorphic Go web application from the
    perspective of the server side and from that of the client side. Remember, our
    goal is to utilize end to end routing to provide web page content access to machine
    users, and to deliver an enhanced user experience to human users.
  prefs: []
  type: TYPE_NORMAL
- en: Routing on the server side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 5.1* depicts an initial page load in an Isomorphic Go application,
    implementing the classic web application architecture. The client can either be
    a web browser or a bot (machine) that accesses the website by providing a URL.
    The URL contains the route that the client is accessing. For example, the `/products`
    route, will serve the products listing page. The `/product-detail/swiss-army-knife`
    route, will serve the product detail page for the swiss army knife product that
    is being sold on the website. The request router is responsible for mapping the
    route to its designated route handler function. The request router we will be
    using on the server side is the Gorilla Mux router, and it is available in the
    `mux` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd37be68-f694-4e99-8e5a-dffc6f412520.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Initial page load in an Isomorphic Go application'
  prefs: []
  type: TYPE_NORMAL
- en: The route handler is responsible for servicing a particular route. It contains
    a set of logic that is executed to perform a given task for a route. For example,
    the route handler for the `/products` route is responsible for fetching the products
    to display, rendering the products listing web page from the associated template,
    and sending the response back to the client. The response from the web server
    is an HTML document, which contains links to associated CSS and JavaScript source
    files. It may also be possible that the returned web page contains inline CSS
    or JavaScript sections as well.
  prefs: []
  type: TYPE_NORMAL
- en: Take note that although the diagram depicts Golang running inside the web browser,
    in reality, it is the JavaScript representation (which was transpiled using GopherJS)
    of the Go program that is running inside the web browser. When the client receives
    the server response, the web page is rendered in the user interface inside the
    web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Routing on the client side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 5.2* depicts routing from the perspective of the client side in an
    Isomorphic Go application, implementing the single page application architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 5.1*, the client side played a trivial role in simply rendering the
    web page server response. Now, in addition to displaying the rendered web page,
    the client contains a request router, route handlers, and the application business
    logic inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the isokit router from the `isokit` package to perform client-side
    routing. The client-side router works much in the same manner as the server-side
    router, except instead of evaluating an HTTP request, the router intercepts the
    click of a hyperlink defined on the web page and routes it to a particular route
    handler defined on the client side itself. The client-side route handler that
    services a particular route, interacts with the server through a Rest API endpoint
    that is accessed by making XHR requests. The response from the web server is data
    that can take on a variety of formats, such as JSON, XML, Plain Text, and HTML
    Fragment, or even Gob-encoded data. We will use JSON as our means of data exchange
    in this chapter. The business logic of the application will determine how the
    data is handled, and it may be displayed to the user in the user interface. At
    this point, all rendering operations can take place on the client side, allowing
    us to prevent a full page reload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/563dbef7-1158-4954-a3a3-6146c5f0d36e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: End to End Routing consists of a router on both ends'
  prefs: []
  type: TYPE_NORMAL
- en: Design of the product-related pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The product-related pages of IGWEB consist of the products listing page and
    the product detail page. The Products page, which may also be referred to as the
    products listing page, will display a list of items that a user may purchase from
    the website. As depicted by the wireframe in *Figure 5.3*, each product will contain
    a thumbnail-sized image of the product, the product price, the product name, a
    brief description of the product, and a button to add the product to the shopping
    cart. Clicking on a product image will take the user to the product detail page
    for the given product. The route to access the products listing page is `/products`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d8d4c86-627c-409f-9dda-730870fbfc1b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Wireframe design of the Products page'
  prefs: []
  type: TYPE_NORMAL
- en: 'The product detail page contains information on an individual product. As depicted
    by the wireframe in *Figure 5.4*, the product detail page consists of a full size
    image of the product, the product name, the price of the product, a long description
    of the product, and a button to add the product to the shopping cart. The route
    to access the product detail page is `/product-detail/{productTitle}`. The `{productTitle}`
    is the **SEO** (short for, **search engine optimization**) friendly name of the
    product, for example, the swiss army knife product will have a `{productTitle}`
    value of `"swiss-army-knife"`. By defining SEO friendly product names inside our
    `/product-detail` route, we make it easier for search engine bots to index a website
    and derive semantic meaning from the collection of product detail URLs. In fact,
    a URL that is search engine friendly is known as a **semantic URL**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a11f748-d1e1-466f-99ad-906801884842.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Wireframe design of the Product detail page'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing product-related templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing the product-related templates consists of implementing the templates
    for the products listing page and the templates for the product detail page. The
    products listing page is depicted in *Figure 5.3*, and the product detail page
    is depicted in *Figure 5.4*. We will implement templates to realize these wireframe
    designs.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the templates for the products listing page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the `products_page.tmpl` source file found in the `shared/templates` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the page template for the products listing page. The primary purpose
    of this template is to render the contents of the `products_content` template
    and place it inside of the web page layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the `products_content.tmpl` source file found in the `shared/templates` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is the content template for the products listing page. The purpose of this
    template is to display all the available products for sale. Inside the `productsContainer` `div` element,
    we have specified an `{{if}}` conditional that checks whether there are products
    available to be displayed. If there are products available, we use the `{{range}}` template
    action to iterate over all the available `Product` objects and generate the HTML
    markup required for each product card. We have defined an anchor (`<a>`) tag to
    make the image clickable, so that the user can navigate directly to the product
    detail page upon clicking on the product image. We have also defined a button
    to add the product to the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: If there are no products to be displayed, we reach the `{{else}}` conditional
    and we place a helpful message to indicate that the products need to be loaded
    into the Redis database instance from the sample data set. For the reader's convenience,
    we have provided a hyperlink that can be clicked, which will populate the sample
    data into the Redis instance.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the templates for the product detail page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the `product_detail_page.tmpl` source file found in the `shared/templates` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is the page template for the product detail page. Its primary purpose is
    to render the contents of the `product_detail_content` template and place it inside
    of the web page layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the `product_detail_content.tmpl` source file found in the `shared/templates` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Inside this template, we defined the HTML markup required to render the product
    detail container for the product detail page. We render the product image along
    with the product name, product price, and a detailed summary of the product. Finally,
    we declared a button to add the product to the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling product data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have defined the `Product` struct in the `shared/models/product.go` source
    file to model product data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `SKU` field represents the product's stock keeping unit (`SKU`), a unique
    id that represents the product. In the sample data set provided, we use incrementing
    integer values, however, this field is of the `string` type to accommodate alphanumeric
    SKUs in the future for extensibility. The `Name` field represents the name of
    the product. The `Description` field represents the short description that will
    be included in the products listing page. The `ThumbnailPreviewURI` field provides
    the path to the thumbnail image of the product. The `Price` field represents the
    price of the product and is of the `float64` type. The `Route` field is the server
    relative path to the product detail page for the given product. The `SummaryDetail`
    field represents the long description for the product that will be displayed in
    the product detail page. Finally, the `Quantity` field, which is of the `int` type,
    is the quantity of the particular product item that is presently in the shopping
    cart. We will be making use of this field in the next chapter, when we implement
    the shopping cart functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing product data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our product data access needs, we have defined two methods in our Redis
    datastore. The `GetProducts` method will return a slice of products and will drive
    the data needs for the products listing page. The `GetProductDetail` method will
    return the profile information for a given product that will drive the data needs
    of the product detail page.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving products from the datastore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the `GetProducts` method defined in the `common/datastore/redis.go` source
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by checking whether the product registry key, `"product-registry"`,
    exists in the Redis datastore. If it does exist, we declare a string slice called
    `productKeys`, which is a slice containing all the keys of the available products
    to display on the products listing page. We use the `Cmd` method on the Redis
    datastore object, `r`, to issue a Redis `"GET"` command, which is used to retrieve
    a record, for a given key. We supply the `registryKey` as the second argument
    to the method. Finally, we chain the method call to the `.Str()` method, which
    will convert the output to a string type.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the product detail from the datastore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The product registry data store in the Redis datastore is JSON data representing
    a slice of strings. We use the `Unmarshal` function found in the `json` package
    to `unmarshal` the JSON encoded data into the `productKeys` variable. Now, that
    we have all the product keys that should be displayed on the products listing
    page, it's time to create a product instance for each key. We do so, by first
    declaring the products variable that will be a slice of products. We iterate through
    the product keys and derive the `productTitle` value, which is the SEO friendly
    name of the product. We supply the `productTitle` variable to the `GetProductDetail`
    method of the Redis datastore to fetch a product for the given product title.
    We assign the fetched product to the `product` variable and append it to the `products`
    slice. Once the `for` loop ends, we will have collected all the products that
    should be displayed on the product listing page. Finally, we return the `products`
    slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the `GetProductDetail` method defined in the `common/datastore/redis.go` source
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We assign the `productKey` variable of the `string` type with the value of the
    route to the product detail page. This involves concatenating the `"/product-detail"` string with
    the `productTitle` variable for the given product. We check to see whether the
    product key exists in the Redis datastore. If it doesn't exist, we return from
    the method, and if it does exist, we continue on and declare the `p` variable of
    the `Product` type. This will be the variable that the function will return. The
    product data stored in the Redis datastore is the JSON representation of a `Product`
    object. We `unmarshal` the JSON encoded data into the `p` variable. If we didn't
    encounter any errors, we return `p`, which represents the `Product` object for
    the requested `productTitle` variable that was specified as the input argument
    to the `GetProductDetail` method.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have satisfied the data needs to display a list of products
    for the `/products` route and to display a product's profile page for the `/product-detail/{productTitle}`
    route. Now it's time to register the server-side routes for the product-related
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: Registering server-side routes with Gorilla Mux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the Gorilla Mux router to handle the server-side application routing
    needs. This router is very flexible since it can not only handle simple routes
    such as `/products` but it can also handle routes with embedded variables. Recall
    that the `/product-detail` route contains the embedded `{productTitle}` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a new instance of the Gorilla Mux router and assigning
    it to the `r` variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the section of code from the `registerRoutes` function, defined in
    the `igweb.go` source file, where we register routes along with their associated
    handler functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use the `Handle` method to associate a route to a given handler function
    that is responsible for servicing the given route. For example, when the `/products`
    route is encountered, it will be handled by the `ProductsHandler` function defined
    in the `handlers` package. The `ProductsHandler` function will be responsible
    for fetching the products from the datastore, using the product records to render
    the products listing page from a template and sending the web page response back
    to the web client. Similarly, the `/product-detail/{productTitle}` route will
    be handled by the `ProductDetailHandler` function. This handler function will
    be responsible for fetching the product record for an individual product, using
    the product record to render the product detail page from a template and sending
    the web page response back to the web client.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side handler functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have registered the server-side routes for the product-related pages,
    it's time to examine the server-side handler functions that are responsible for
    servicing these routes.
  prefs: []
  type: TYPE_NORMAL
- en: The handler function for the products listing page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the `products.go` source file found in the `handlers` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we fetch the slice of products, featured on the Products page, by calling
    the `GetProducts` method on the Redis datastore object, `env.DB`. We declared
    the `templateData` variable of the `templatedata.Products` type, and it represents
    the data object that will be passed to the template engine, alongside the `products_page`
    template, to render the Products page. The `PageTitle` field represents the web
    page title, and the `Products` field is the slice of the products that are to
    be displayed on the Products page.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `ProductsHandler` function, we call the `GetProducts` method on the
    datastore object to fetch the available products for displaying from the datastore.
    We then create a template data instance having a `PageTitle` field value of `"Products"`,
    and we assign the products that were fetched from the datastore to the `Products`
    field. Finally, we render the `products_page` template from the template set.
    With regard to the `RenderParams` object that we pass to the `env.TemplateSet`
    object's `Render` method, we set the `Writer` property to the `w` variable, which
    is `http.ResponseWriter`, and we set the `Data` property to the `templateData`
    variable, which is the data object that will be supplied to the template. At this
    point, the rendered web page will be sent back to the web client in the server
    response.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.5* shows the rendered Products page that has been generated after
    accessing the `/products` route by visiting the following link: `http://localhost:8080/products`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0b0b6da-70a7-4a86-9e6d-f66e37778726.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: The Products Page'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are able to display the Products page, let's take a look at the
    handler function for the product detail page.
  prefs: []
  type: TYPE_NORMAL
- en: The handler function for the product detail page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the `productdetail.go` source file found in the `handlers` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is the handler function that handles the `/product/{productTitle}` route.
    Remember, this is the route with the embedded variable inside of it. Inside the
    `ProductDetailHandler` function, we first gather the variables defined in the
    route, by calling the `Vars` function of the `mux` package. We supply `r`, the
    pointer to `http.Request`, as the input parameter to the `Vars` function. The
    result of this function is a map of the `map[string]string` type, where the key
    is the name of the variable in the route and the value is the value for that particular
    variable. For example, if we were accessing the `/product-detail/swiss-army-knife`
    route, the key would be `"productTitle"` and the value would be `"swiss-army-knife"`.
  prefs: []
  type: TYPE_NORMAL
- en: We get the value supplied for the `productTitle` variable in the route, and
    assign it to the `productTitle` variable. We then get the product object from
    the datastore by supplying the `GetProductDetail` method of the datastore object
    with the `productTitle` variable. We then set up our template data object, setting
    the fields for the page title and the product record. Finally, we call the render
    method on the template set indicating that we want to render the `product_detail_page`
    template. We assign the `http` response writer object and the template data object
    to the respective fields of the render `params` object, which is passed in as
    the second argument to the template set's Render method.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have everything that we need in place to render the product
    detail page. Let''s visit the product detail page for the swiss army knife from `http://localhost:8080/products/swiss-army-knife`.
    Here is the rendered product detail page in the web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/246bdb8e-387d-49a4-ba26-10f3bddf3e98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: The Product detail page for the Swiss Army Knife'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have made the `/products` and `/product-title/{productTitle}` routes
    available to humans and machines alike, and we have implemented the classic web
    application architecture. Our machine users (the search engine bots) will be satisfied,
    since they can easily index the links of all the products available in the products
    listing page, and they can readily parse the HTML markup on each product detail
    page.
  prefs: []
  type: TYPE_NORMAL
- en: However, we haven't completely satisfied our human audience yet. You may have
    noticed that clicking on an individual product from the product listing page results
    in a full page reload. In a brief instance, the screen may go white in the transition
    of leaving one page and rendering the next page within the web browser. The same
    full page reload happens when we click on the Products link in the navigation
    menu to return to the products listing page from the product detail page. We can
    enhance the user experience of transitioning through web pages by implementing
    the single page architecture for subsequent interactions with the website, after
    the initial page load. In order to do so, we need to define client-side routes
    along with their associated client-side route handler functions.
  prefs: []
  type: TYPE_NORMAL
- en: Registering client-side routes with the isokit router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the client side, we use the isokit router to handle routes. The isokit router
    works by intercepting the click events to hyperlinks and checking if the hyperlink
    contains a route defined in its routing table.
  prefs: []
  type: TYPE_NORMAL
- en: We can register a route in the router's routing table using the `Handle` method
    of the isokit router object. The `Handle` method takes two parameters—the first
    parameter is the route and the second parameter is the handler function that should
    service the route. Notice that the code to declare and register routes is very
    similar to the Gorilla Mux router on the server side. Because of this similarity,
    registering routes on the client side, with the isokit router, is straightforward
    and feels like second nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the section of code from the `registerRoutes` function defined in the `client.go`
    source file found in the `client` folder, which is responsible for registering
    routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by creating a new isokit router by calling the `NewRouter` function
    from the `isokit` package and assigning it to the `r` variable. We have defined
    the `/products` route for the product listing page, and the `/product-data/{productTitle}`
    route for the product detail page. After defining all the routes, we make a call
    to the `Listen` method of the router object, `r`. The `Listen` method is responsible
    for adding an event listener to all hyperlinks, to listen for click events. Links
    that are defined in the router's routing table will be intercepted upon a click
    event and their associated client-side route handler function will service them.
    Finally, we assign the `r` router to the `Router` field of the `env` object, so
    that we can access the router throughout the client-side web application.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side handler functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've registered the routes for the product-related pages on the client
    side, let's take a look at the client-side route handlers functions that are responsible
    for servicing these routes.
  prefs: []
  type: TYPE_NORMAL
- en: The handler function for the products listing page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the `ProductsHandler` function in the `products.go` source file
    found in the `client/handlers` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Recall that from the diagram depicted in *Figure 5.2*, that the client-side
    web application accesses the server-side functionality through the use of XHR
    calls to Rest API endpoints. Here, we create the `productsChannel` channel to
    retrieve a slice of the `Product` objects. We call the `FetchProducts` function,
    which will make the XHR call to the Rest API endpoint on the server that is responsible
    for retrieving the list of available products to display on the Products page.
    Notice that we call the `FetchProducts` function as a goroutine. We must do this
    to ensure that the XHR call does not block. We supply the `productsChannel` channel
    as the sole input argument to the `FetchProducts` function. We then retrieve the
    list of products over the `productsChannel` channel and assign it to the `products`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new template data object instance, `templateData`, and set the respective
    fields for the `PageTitle` and the `Products` field. After this, we call the `Render`
    method on the `env.TemplateSet` object, specifying that we want to render the
    `products_content` template. In the `RenderParams` object that we supply to the
    `Render` function, we set the `Data` field with the template data object, `templateData`.
    We set the `Disposition` field to `isokit.PlacementReplaceInnerContents` to specify
    that the disposition of the render should replace the inner HTML contents of the
    associated element. We set the `Element` field to be the primary content `div` container,
    where the main page content is rendered. We call the `InitializeProductsEventHandlers`
    function to set up the event handlers found in the products page. For the Products
    page, the only DOM element needing an event handler is the Add To Cart button,
    which we will cover in [Chapter 6](5759cf7a-e435-431d-b7ca-24a846d6165a.xhtml), *Isomorphic
    Handoff*.
  prefs: []
  type: TYPE_NORMAL
- en: As far as client-side routing is concerned, the last line of code in the `ProductsHandler`
    function is the most important line. When each product card is rendered by the
    template renderer, we need to intercept the links of each product item. We can
    tell the isokit router to intercept these links by providing a query selector
    that will target the links found in the primary content `div` container. We do
    this by calling the `RegisterLinks` method of the isokit router object and specifying
    that the query selector should be `"#primaryContent a"`. This will ensure that
    all the links for the product items are intercepted, and that when we click on
    a product item, instead of performing a full page reload to get to the `/product-detail/{productTitle}`
    route, the client-side route handler for the product-detail route will kick in
    and service the request.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the list of products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve seen how the client-side route handler function works, let''s
    take a look at the `FetchProducts` function that is used to make the XHR call
    to the server and gather the list of products to display on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `xhr` package to make XHR calls to the server. We call the
    `Send` function from the `xhr` package and specify that our request will be using
    the `GET` method, and we will be making the request to the `/restapi/get-products`
    endpoint. For the third argument to the function, we pass a value of `nil` to
    indicate that we are not sending data in our XHR call. If the XHR call is successful,
    we will receive JSON data from the server, which will represent a slice of the `Product`
    objects. We create a new JSON Decoder to decode the data and store it in the `products`
    variable, which we send over the `productsChannel`. We will be examining the Rest
    API endpoint that services this XHR call, in the section, *The endpoint to get
    the list of products*.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our web application has attained the goal of being able to render
    the Products page without causing a full page reload on subsequent interactions
    with the website. For example, if we were to access the About page at `http://localhost:8080/about`,
    the initial page load will be serviced on the server side. If we initiated a subsequent
    interaction by clicking on the Products link in the navigation menu, the client-side
    routing will kick in, and the Products page will load, without a full page reload
    taking place.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Verifying client-side routing functionality* section, we will show you
    how you can verify that client-side routing is functioning properly, using the
    web browser's inspector. Now it's time to implement the client-side route handler
    for the product detail page.
  prefs: []
  type: TYPE_NORMAL
- en: The handler function for the product detail page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the `ProductDetailHandler` function defined in the `productdetail.go`
    source file found in the `client/handlers` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `ProductDetailHandler` function returns an `isokit.Handler` value. Notice
    that we specify `isokit.HandlerFunc` as a closure, so that we can perform a dependency
    injection of the `env` object to our client-side handler function. Notice that
    the input argument to `isokit.HandlerFunc` is of the `context.Context` type. This
    context object is important because it contains the variable information embedded
    within a route. By calling the `Value` method on the `ctx` context object, we
    can obtain the route variables by specifying the key of `"Vars"` to the context
    object. Notice that we perform a type assertion to specify that the value obtained
    from the context object is of the `map[string]string` type. We can extract the
    value for the `productTitle` from the route by providing the ``product-detail/{productTitle}`` key.
    The value for the `productTitle` is important since we will be sending it as a
    route variable in the XHR call we make to the server to obtain a product object.
  prefs: []
  type: TYPE_NORMAL
- en: We create a product channel, `productChannel`, that will be used to send and
    receive a `Product` object. We call the `FetchProductDetail` function, providing `productChannel`
    and `productTitle` as input arguments to the function. Notice that we call the
    function as a goroutine, and upon successfully running the function, we will have
    a product object sent over `productChannel`.
  prefs: []
  type: TYPE_NORMAL
- en: We set up our template data object, specifying values for the `PageTitle` and
    `Product` fields. We then set the title of the page to the product name. Once
    this is done, we call the `Render` method of the template set object, and we specify
    that we want to render the `product_detail_content` template. We set the fields
    of the render parameters object, populating the fields for the template data object,
    the disposition, and the associated element where the template will be rendered
    to, which is the primary content `<div>` container. Finally, we make a call to
    the `InitializeProductDetailEventHanders` function, which is responsible for setting
    up the event handlers for the product detail page. The only element in need of
    handlers for this page is the Add To Cart button, which we will cover in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the product detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the `FetchProductDetail` function defined in the `productdetail.go`
    source file in the `client/handlers` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function is responsible for making the XHR call to the Rest API endpoint
    on the server that provides the product data. The function takes in a product
    channel and a product title as input arguments. We make the XHR call by calling
    the `Send` function of the `xhr` package. Take note that in the second input argument
    to the function (the destination that we are making the request to), we concatenate
    the `prouductTitle` variable to the `/restapi/get-product-detail` route. So, for
    example, if we wanted to request the product object for the swiss army knife,
    we would specify a route of `/restapi/get-product-detail/swiss-army-knife`, and
    in this scenario, the `productTitle` variable would be equal to `"swiss-army-knife"`.
  prefs: []
  type: TYPE_NORMAL
- en: If the XHR call was successful, the server will return the JSON encoded product
    object. We use a JSON decoder to decode the JSON data returned from the server,
    and we set the `product` variable to the decoded `Product` object. Finally, we
    pass `product` over `productChannel`.
  prefs: []
  type: TYPE_NORMAL
- en: Rest API endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rest API endpoints on the server side are pretty handy. They are the means
    to provide the client-side web application with data, behind the scenes, and we
    apply this data to the respective template to display the page content without
    having the need to do a full page reload.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll consider what goes in to creating these Rest API endpoints. We will
    first have to register routes for them on the server side. We will follow the
    same procedure that we did at the beginning of this chapter for the product listing
    page and the product detail page. The only difference is that our handler functions
    will be found in the `endpoints` package as opposed to being in the `handlers`
    package. The fundamental difference here is that the `handlers` package contains
    handler functions that return a full web page response back to the web client.
    The `endpoints` package, on the other hand, contains handler functions that will
    return data, most likely in the JSON format, back to the web client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the section of code from the `igweb.go` source file, where we register
    our Rest API endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `/restapi/get-products` route that drives the data needs for
    the client-side products page is serviced by the `GetProductsEndpoint` function
    found in the `endpoints` package.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `/restapi/get-product-detail/{productTitle}` route that drives
    the data needs for the client-side product detail page, is serviced by the `GetProductDetailEndpoint`
    function found in the `endpoints` package.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint to get the list of products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the `products.go` source file in the `endpoints` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `GetProductsEndpoint` function, we first fetch the slice of products
    that will be displayed on the client-side products page by calling the `GetProducts`
    method of the datastore object, `env.DB`. We then set a header to indicate that
    the server response will be in JSON format. Finally, we use a JSON encoder to
    encode the slice of products as JSON data and write it out using the the `http.ResponseWriter`,
    `w`.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint to get the product detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the `productdetail.go` source file in the endpoints folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `GetProductDetailEndpoint` function, we fetch embedded route variables,
    by calling the `Vars` function from the `mux` package and supplying the router
    object, `r`, as the sole input argument to the function. We then obtain the value
    for the `{productTitle}` embedded route variable and assign it to the variable
    `productTitle`. We supply the `productTitle` to the `GetProductDetail` method
    of the datastore object, `env.DB`, to retrieve the corresponding `Product` object
    from the datastore. We set a header to indicate that the server response will
    be in the JSON format, and we use the JSON encoder to encode the `Product` object
    as JSON data, which will be sent out to the web client using `http.ResponseWriter`,
    `w`.
  prefs: []
  type: TYPE_NORMAL
- en: We have now reached a major milestone. We have implemented the product-related
    pages in a manner that is friendly to both humans and machines alike. When a user
    initially access the products listing page, by entering the URL (`http://localhost:8080/products`)
    in the web browser, the page is rendered on the server side, and the web page
    response is sent back to the client. The user is able to see the web page instantly
    since the web page response is pre-rendered. This behavior exhibits the desired
    trait from the classic web application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: When the human user initiates subsequent interactions, by clicking on a product
    item, the product detail page is rendered from the client side, and the user is
    saved from having to experience a full page reload. This behavior exhibits the
    desired trait from the SPA architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The machine users (the search engine bot crawlers) are also satisfied since
    they can traverse each link to a product item on the products page and readily
    index the website, since we have semantic URLs in place along with well-formed
    HTML markup that the search engine bots can understand.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the client-side routing functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To ensure that the client-side routing is functioning properly, you can exercise
    the following procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Access the Products page in your web browser and open up the web browser's inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the network tab to watch network traffic, and make sure to filter on
    XHR calls. Now, click on a product item to get to the product's detail page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the Products page by clicking the Products link on the navigation
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat this process several times, and you should be able to see all the XHR
    calls being made in the background. *Figure 5.7* includes a screenshot of this
    procedure to verify that the client-side routing is functioning properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d31a4c4-b979-476b-8daf-fb608ee1a690.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: The XHR calls in the web console confirms that the client-side
    routing is functioning properly'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented end to end application routing for IGWEB as
    we built the products-related pages. We started by registering server-side routes
    using the Gorilla Mux router. We associated each route with a corresponding, server-side
    route handler function that would service the server-side route. We then examined
    the implementation of the server-side route handler functions for the product-related
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: Having satisfied the needs of implementing the classic web application architecture
    for the initial page load, we moved on to the client side by first registering
    routes for the product-related pages, using the isokit router. Just as we had
    done on the server side, we associated each client-side route with a corresponding
    client side route handler function that would service the client-side route. You
    learned how to implement client-side route handlers and how to make XHR calls
    from them to server-side Rest API endpoints. Finally, you learned how to create
    server-side Rest API endpoints that handled XHR requests and returned JSON data
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The product-related pages had a persistent state since the list of available
    products where driven by the contents of the datastore. How do we maintain state
    in a situation where the user interaction with the website changes the given state?
    For example, if the user added items to the shopping cart, how can we go about
    maintaining the state of the shopping cart and syncing it up between the server
    side and the client side? You are going to learn about *isomorphic handoff*, the
    process of handing off state between the server and the client in [Chapter 6](5759cf7a-e435-431d-b7ca-24a846d6165a.xhtml), *Isomorphic
    Handoff*. We will implement the shopping cart functionality for the website in
    the process of doing this.
  prefs: []
  type: TYPE_NORMAL
