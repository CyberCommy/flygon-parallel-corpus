- en: Ready to Cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've made enormous strides in the performance of our application. Our JavaScript
    is now split into smaller chunks based on the routes of our application, and we've
    deferred loading the less important bits until our app has some idle time. We've
    also introduced progressive enhancement to show our users content as soon as possible,
    and learned a lot about how to analyze our app's performance according to RAIL
    metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there remains one central, core inefficiency in our web application.
    If our user leaves our page to go elsewhere (I know, how dare they) and then returns,
    we repeat the same process all over again: download the `index.html`, download
    the different JavaScript bundles, download the images, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: We're asking our user to download the exact same files, over and over and over,
    every time they visit the page. Their device has more than enough memory to store
    those files for us. Why don't we just save them to the user's device, and then
    retrieve them as needed?
  prefs: []
  type: TYPE_NORMAL
- en: 'Welcome to caching. In this chapter, we''ll cover these things:'
  prefs: []
  type: TYPE_NORMAL
- en: What is caching?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Cache API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Cache API in our service worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing our caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is caching?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Caching** is the act of reducing network requests or computation. Backend
    caching may consist of saving the result of a rigorous computation (say, generating
    statistics) so that when the client requests it a second time, we don''t have
    to crunch the numbers again. Client-side caching usually consists of saving the
    response of a network request so that we don’t have to make that call again.'
  prefs: []
  type: TYPE_NORMAL
- en: As we said before, **service workers** are bits of code that sit between our
    application and the network. This means they are perfect for caching, as they
    can intercept a network request and respond with the requested file, grabbing
    it from the cache instead of the server; time is saved.
  prefs: []
  type: TYPE_NORMAL
- en: From a broader perspective, you can think of caching as not having to do the
    same thing more than once, using memory to store the result.
  prefs: []
  type: TYPE_NORMAL
- en: The upside of caching with Progressive Web Apps is that since the cache is stored
    in device memory, it's available regardless of network connectivity. This means
    everything stored in the cache can be accessed whether or not the device is connected.
    All of a sudden, our website is available offline.
  prefs: []
  type: TYPE_NORMAL
- en: For mobile users skipping between Wi-Fi zones, the convenience factor can be
    huge, giving them the ability to quickly check a message from a friend or a set
    of directions (anyone who has ever traveled without a roaming plan will know this
    feeling). Neither is this solely an advantage for purely offline users; for users
    with intermittent or low-quality connections, being able to continue working without
    a loss of functionality  as the network skips in and out is a big win.
  prefs: []
  type: TYPE_NORMAL
- en: So, with one fell stroke, we can improve our app's performance for all our users
    and make it available offline. However, before we get to work implementing caching
    in Chatastrophe (hopefully, not a cachetastrophe), let's look at a story about
    the importance of caching.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2013, the US government launched [https://healthcare.gov/](https://healthcare.gov/),
    a website for citizens to sign up for the Affordable Care Act (also known as **Obamacare**).
    From the get-go, the site was plagued with serious technological problems. For
    thousands of people, it simply wouldn’t load.
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, the site was under enormous strain, visited an estimated 20 million
    times in its first month of operation (source--[http://www.bbc.com/news/world-us-canada-24613022](http://www.bbc.com/news/world-us-canada-24613022)),
    but that strain was to be expected.
  prefs: []
  type: TYPE_NORMAL
- en: If you were building a website for millions of people to sign up for health
    care (all starting at the same time), performance would probably be at the top
    of your mind, but in the end, [https://healthcare.gov/](https://healthcare.gov/)
    failed to deliver.
  prefs: []
  type: TYPE_NORMAL
- en: In response to the crisis (which threatened the credibility of the ACA), the
    administration put together a team to fix the problems, kind of like the Avengers,
    but software developers (so not the Avengers at all).
  prefs: []
  type: TYPE_NORMAL
- en: Given the goal of the site, the engineers were shocked to find that [https://healthcare.gov/](https://healthcare.gov/)
    implemented no basic caching. None. So every time a user visited the site, the
    server had to deal with a network request and generate the information to reply.
  prefs: []
  type: TYPE_NORMAL
- en: This lack of caching had a compounding effect. The first wave of users clogged
    up the pipes, so the second wave of users got a loading screen. In response, they
    refreshed their screen, making more and more network requests, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Devengers implemented caching, they cut the response time down by three-fourths.
    From then on, the site was able to handle even peak traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Chatastrophe may not be dealing with [https://healthcare.gov/](https://healthcare.gov/)
    levels of traffic (yet…), but caching is always a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: The Cache API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mechanism we will use for caching is the **Web Cache API**.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Mozilla Developer Network defines the Cache API as **experimental
    technology**, and as of August 2017, it only has the support of Chrome, Firefox,
    and the latest version of Opera.
  prefs: []
  type: TYPE_NORMAL
- en: The API specification has a few quirks we need to talk about. First, you can
    store multiple cache objects in the cache. In this way, we're able to store multiple
    versions of our cache, named whatever string we like.
  prefs: []
  type: TYPE_NORMAL
- en: That said, the browser has a limit of how much data it can store from any one
    site. If the cache gets too full, it may simply delete all data from that origin,
    so our best bet is to store the bare minimum.
  prefs: []
  type: TYPE_NORMAL
- en: However, there's an additional difficulty. Items in the cache never expire,
    unless explicitly deleted, so if we keep trying to stuff new cache objects into
    our cache, eventually it'll get too full and delete everything. Managing, updating,
    and deleting cache objects is entirely up to us. We have to clean up our own mess,
    in other words.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use five methods to interact with the Cache API: `open`, `addAll`,
    `match`, `keys`, and `delete`. In the following, **Caches** will refer to the
    Cache API itself, and **Cache** to a specific cache object, to distinguish between
    methods called on an individual cache versus the API itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Caches.open()` takes a cache object name (also known as a cache key) as an
    argument (it can be any string), and either creates a new cache object or opens
    an existing one by the same name. It returns a `Promise` that resolves with the
    cache object as a parameter, which we can then use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cache.addAll()` takes in an array of URLs. It''ll then go fetch those URLs
    from the server, and store the resulting file in the current cache object. Its
    little cousin is `Cache.add`, which does the same with a single URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Caches.match()` takes a network request as an argument (we''ll see how to
    grab that as we go ahead). It looks in the cache for a file that matches the URL,
    and returns a `Promise` that resolves with that file. We can then return that
    file, superseding the need to make the request to the server. Its big brother
    is `Caches.matchAll()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Caches.keys()` returns the names of all the existing cache objects. We can
    then delete the outdated ones by passing their key to `Caches.delete()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last method in the Cache API, which we won’t use here but which may be of
    interest, is `Caches.put`. This takes a network request and fetches it, and then
    saves the result to the cache. This is useful if you want to cache every request
    without having to define what the URLs are ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: The asset manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our build process automatically generates an `asset-manifest.json` file for
    us, with a list of every JavaScript file our application contains. It looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In other words, we have a list of every JS file we want to cache. More importantly,
    the asset manifest is updated with the new hash of every file, so we don't have
    to worry about keeping that up to date.
  prefs: []
  type: TYPE_NORMAL
- en: We can thus use the URLs in the asset manifest alongside the `Cache.addAll()`
    method to instantly cache all our JavaScript assets in one go. We'll also need
    to manually add our static assets (images) to the cache, but to do so, we'll have
    to tap into our service worker life cycle methods and do some basic setup.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll move through our three main service worker life cycle
    events, and interact with our cache individually in each event. By the end, we
    will have automatic caching for all static files.
  prefs: []
  type: TYPE_NORMAL
- en: A warning, though--working with caches in development is, at best, tolerable,
    and at worst, infuriating. "Why aren't you updating?" we yell at our screen, until
    we realize that our cache has been serving up old code; it happens to the best
    of us. In this section, we'll take steps to avoid caching our development files
    and dodge this bullet, but in the future, remember that weird errors are probably
    caused by caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only two hard things in Computer Science: cache invalidation and
    naming things.-- Phil Karlton'
  prefs: []
  type: TYPE_NORMAL
- en: 'And another take:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two hard problems in computer science: cache invalidation, naming
    things, and off-by-1 errors.-- Leon Bambrick'
  prefs: []
  type: TYPE_NORMAL
- en: The install event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When our service worker installs, we want to go ahead and set up our cache,
    and begin caching the relevant assets. So, our step-by-step guide to our install
    event goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the relevant cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get our asset manifest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the relevant URLs to our cache, plus our static assets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s open up `firebase-messaging-sw.js` and get to work!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you still have the `console.log` event listener for install, great! Delete
    the `console.log`; otherwise, set it up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Right above this function, we’ll also assign our cache object name to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This name can be literally anything, but we'll want to up the version every
    time we deploy, just to ensure that old caches are invalidated and everyone gets
    the freshest possible code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's run through our checklist.
  prefs: []
  type: TYPE_NORMAL
- en: Opening up the cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get to the good stuff, we need to talk about extendable events.
  prefs: []
  type: TYPE_NORMAL
- en: Once our service worker is activated and installed, it may immediately go into
    "waiting" mode--waiting for an event to occur to which it must respond. However,
    we don’t want it to go into waiting mode while we're in the middle of opening
    the cache, which is an asynchronous operation. So, we need a way of telling our
    service worker, "Hey, don’t consider yourself fully installed until the cache
    is populated."
  prefs: []
  type: TYPE_NORMAL
- en: The way we do so is via `event.waitUntil()`. This method extends the life of
    an event (here, the install event) until all Promises within it are resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can open our cache. Our Cache API is available in the caches global
    variable, so we can just call `caches.open()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since no cache object with the name `'v1'` will currently exist, we will automatically
    create one. Once we get that cache object, we can move to step 2.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the asset manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fetching the asset manifest sounds exactly like it sounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we should have no asset-manifest in development; we need to ensure
    that the request response is okay before proceeding, lest we throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `asset-manifest.json` returns, rather surprisingly, some JSON. Let''s parse
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a manifest variable that is a plain JavaScript object matching the
    content of `asset-manifest.json`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the relevant URLs to the cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we have a JavaScript object to access the URLs, we can pick and choose
    what we want to cache, but in this case, we want everything, so let''s iterate
    over the object and get an array of URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to cache the `index.html` and our icon, so let''s push in `/`
    and `/assets/icon.png`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add all these URLs to the cache with `cache.addAll()`. Note that
    we’re referring to the specific cache object we opened, and not the general caches
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Done! We have caching, but it's not worth much yet, as we have no way of retrieving
    items from the cache. Let’s do that next.
  prefs: []
  type: TYPE_NORMAL
- en: The fetch event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When our application requests a file from the server, we want to intercept that
    request inside our service worker, and respond with the cached file (if it exists).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do so by listening to the fetch event, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The event passed in as argument has two properties of interest. The first is
    `event.request`, which is the target URL. We’ll use that to see whether we have
    the item in our cache, but the event also has a method called `respondWith`, which
    basically means "stop this network request from going through, and respond to
    it with the following."
  prefs: []
  type: TYPE_NORMAL
- en: Here's the unintuitive part--we're essentially canceling this fetch event as
    soon as we call `event.respondWith`. This means if we don’t have the item in our
    cache, we have to start another fetch request (which does not, thankfully, trigger
    another event listener; no recursion here). This is something to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s call `event.respondWith`, and then use `caches.match` to see whether
    we have a file matching the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The response, in this case, will be either the file in question or null. If
    it’s the file, we return it; otherwise, we make another fetch request and return
    its result. Here’s the one-line version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! Now all fetch requests for files in our asset manifest will go to
    the cache first, and only make an actual network request if the said file isn’t
    there.
  prefs: []
  type: TYPE_NORMAL
- en: The activate event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The activate event is the first of our three service worker events to take place,
    so it may seem odd that we’re talking about it last, but there's a good reason.
  prefs: []
  type: TYPE_NORMAL
- en: The activate event is when we do cache clean up. We ensure that we get rid of
    any expired cache objects so that our share of the browser cache doesn’t get too
    cluttered and become terminated.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we basically delete any cache object whose name doesn't match the
    current value of `CACHE_NAME`.
  prefs: []
  type: TYPE_NORMAL
- en: '"But Scott," you say, "what if our service worker doesn’t update properly,
    and still contains the old `CACHE_NAME`?" This is a valid point. However, as said,
    our service worker should automatically update whenever there is a byte-sized
    difference between it and the previous service worker, so that should not be a
    concern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our process is less intensive this time, but let''s still break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: Grab the list of cache names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop over them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete any cache whose key doesn't match `CACHE_NAME`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A quick reminder--you can have multiple caches if you want to keep your CSS
    in a seperate cache from your JS. There’s no real benefit of doing so, but you
    may like things organized. An approach that will work is to create a `CACHE_NAMES`
    object instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then, in the subsequent steps, we'll have to iterate over that object; just
    something to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let's get to work.
  prefs: []
  type: TYPE_NORMAL
- en: Grab the list of cache names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, we have to do an `event.waitUntil()` while we complete this async code.
    This means we'll have to eventually return a `Promise` to the `event.waitUntil()`,
    which will affect how we write our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we grab the list of cache keys, by calling `cache.keys()`, which returns
    a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Loop over them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to go through each key and call `caches.delete()` if it doesn't match
    our `CACHE_NAME`. Since we may have multiple caches to delete, and multiple calls
    to `caches.delete()`, which returns a `Promise` in itself, we'll map over `keyList`
    and return a set of Promises using `Promise.all()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Delete any cache whose key doesn’t match `CACHE_NAME`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `if` statement, and a call to `caches.delete()`, and we''re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now our caches will be exactly the size we want them to be (only on cache object)
    and will be checked every time our service worker activates.
  prefs: []
  type: TYPE_NORMAL
- en: There is, thus, an inherent mechanism to how our cache stays up to date. Every
    time we update our JavaScript, we should update the version in our service worker.
    This causes our service worker to update, and thus reactivate, which triggers
    a check and invalidation of the previous caches; a beautiful system.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Run your app locally quickly with **`yarn start`** to check for any obvious
    errors (typos and such), and if all looks good, fire up **`yarn deploy`**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your live application and the Chrome DevTools. Turn off Update on reload
    under Application | Service Workers, refresh once, and then go to the Network
    tab. You should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00089.jpeg)If this doesn''t work, try Unregistering any service
    workers under Application | Service Workers, and then reload twice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key point is (from service worker) beside our JavaScript files. Our static
    assets are being served up by our service worker cache, and if you scroll to the
    top of the network tab, you''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The document itself is being served from the service worker, which means we
    can run our app under any network condition, even offline; let's try it. Click
    on the Offline checkbox at the top of the Network tab, and click on reload.
  prefs: []
  type: TYPE_NORMAL
- en: If all goes well, there should be no difference between our application's load
    time, even though we have no network connection! Our application still loads,
    and so do our chat messages.
  prefs: []
  type: TYPE_NORMAL
- en: The message loading is a benefit of the database of Firebase, not really our
    doing, but having the document itself load from the cache, that's the real achievement!
  prefs: []
  type: TYPE_NORMAL
- en: Of course, our UX isn't set up well for offline access. We should have some
    way of informing the user they're currently offline, perhaps with some sort of
    dialog, but we'll leave that as a stretch goal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We achieved the progressive dream--an application that works under any network
    conditions, including an absence of any network at all. Caching is a difficult
    subject, so give yourself a pat on the back for making it this far.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we get too excited and submit our prototype to the Chatastrophe
    board, let’s ensure that we did things right. We need some way to put a rubber
    stamp on our project, which says, "Approved! This is a Progressive Web App!".
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, a little startup by the name of Google has given us a tool to do exactly
    like that.
  prefs: []
  type: TYPE_NORMAL
- en: Up next is auditing our completed progressive web app, AKA the victory lap.
  prefs: []
  type: TYPE_NORMAL
