- en: Chapter 3. Creating Your First React Element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a simple web application today involves writing HTML, CSS, and JavaScript
    code. The reason we use three different technologies is that we want to separate
    three different concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: Content (HTML)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling (CSS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic (JavaScript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This separation works great for creating a web page because traditionally,
    we had different people working on different parts of our web page: one person
    structured the content using HTML and styled it using CSS, and then another person
    implemented the dynamic behavior of various elements on that web page using JavaScript.
    It was a content-centric approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Today, we mostly don't think of a website as a collection of web pages anymore.
    Instead, we build web applications that might have only one web page and that
    web page does not represent the layout for our content—it represents a container
    for our web application. Such a web application with a single web page is called
    (unsurprisingly) a **Single Page Application** (**SPA**). You might be wondering
    how do we represent the rest of the content in a SPA? Surely, we need to create
    an additional layout using HTML tags. Otherwise, how does a web browser know what
    to render?
  prefs: []
  type: TYPE_NORMAL
- en: These are all valid questions. Let's take a look at how it works. Once you load
    your web page in a web browser, it creates a **Document Object Model** (**DOM**)
    of that web page. A DOM represents your web page in a tree structure, and at this
    point, it reflects the structure of the layout that you created with HTML tags
    only. This is what happens regardless of whether you're building a traditional
    web page or a SPA. The difference between the two is what happens next. If you
    are building a traditional web page, then you would finish creating your web page's
    layout. On the other hand, if you are building a SPA, then you would need to start
    creating additional elements by manipulating the DOM with JavaScript. A web browser
    provides you with the **JavaScript DOM API** to do this. You can learn more about
    it at [https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, manipulating (or mutating) the DOM with JavaScript has two issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Your programming style will be imperative if you decide to use the JavaScript
    DOM API directly. As we discussed in the previous chapter, this programming style
    leads to a code base that is harder to maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOM mutations are slow because they cannot be optimized for speed unlike other
    JavaScript code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, React solves both these problems for us.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why do we need to manipulate the DOM in the first place? It is because our
    web applications are not static. They have a state represented by a **user interface**
    (**UI)** that a web browser renders, and that state can be changed when an event
    occurs. What kind of events are we talking about? There are two types of events
    that we''re interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User events**: When a user types, clicks, scrolls, resizes, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server events**: When an application receives data or an error from a server,
    among others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What happens while handling these events? Usually, we update the data that
    our application depends on and that data represents a state of our data model.
    In turn, when a state of our data model changes, we might want to reflect this
    change by updating a state of our UI. Looks like what we want is a way of syncing
    two different states: the UI state and data model state. We want one to react
    to the changes in the other and vice versa. How can we achieve this?'
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways to sync your application's UI state with an underlying data
    model's state is a two-way data binding. There are different types of two-way
    data binding. One of them is **Key-Value Observation** (**KVO**), which is used
    in `Ember.js`, Knockout, Backbone, and iOS, among others. Another one is dirty
    checking, which is used in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of a two-way data binding, React offers a different solution called
    the **virtual DOM**. The virtual DOM is a fast in-memory representation of the
    real DOM, and it''s an abstraction that allows us to treat JavaScript and DOM
    as if they were reactive. Let''s take a look at how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a state of your data model changes, the virtual DOM and React will
    re-render your UI to a virtual DOM representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It then calculates the difference between the two virtual DOM representations:
    the previous virtual DOM representation that was computed before the data was
    changed and the current virtual DOM representation that was computed after the
    data was changed. This difference between the two virtual DOM representations
    is what actually needs to be changed in the real DOM.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update only what needs to be updated in the real DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process of finding a difference between the two representations of the virtual
    DOM and re-rendering only the updated patches in a real DOM is fast. Also, the
    best part is—as a React developer—that you don't need to worry about what actually
    needs to be re-rendered. React allows you to write your code as if you were re-rendering
    the entire DOM every time your application's state changes.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to learn more about the virtual DOM, the rationale behind
    it, and how it can be compared to data binding, then I would strongly recommend
    that you watch this very informative talk by Pete Hunt from Facebook at [https://www.youtube.com/watch?v=-DX3vJiqxm4](https://www.youtube.com/watch?v=-DX3vJiqxm4).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned about the virtual DOM, let's mutate a real DOM by installing
    React and creating our first React element.
  prefs: []
  type: TYPE_NORMAL
- en: Installing React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start using the React library, we need to first install it.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the latest version of React library is 16.0.0\. Over
    time, React gets updated, so make sure that you use the latest version that is
    available to you, unless it introduces breaking changes that are incompatible
    with the code samples provided in this book. Visit [https://github.com/PacktPublishing/React-Essentials-Second-Edition](https://github.com/PacktPublishing/React-Essentials-Second-Edition)
    to learn about any compatibility issues between the code samples and the latest
    version of React.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Installing Powerful Tools for Your Project"),
    *Installing Powerful Tools for Your Project*, I introduced you to **Webpack**,
    which allows us to import all the dependency modules for our application using
    the `import` function. We''ll be using `import` to import the React library as
    well, which means that instead of adding a `<script>` tag to our `index.html`
    file, we''ll be using the `npm install` command to install React:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `~/snapterest/` directory and run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open the `~/snapterest/source/app.js` file in your text editor, and import
    the React and ReactDOM libraries to the `React` and `ReactDOM` variables, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `react` package contains methods that are concerned with the key idea behind
    React, that is, describing what you want to render in a declarative way. On the
    other hand, the `react-dom` package offers methods that are responsible for rendering
    to the DOM. You can read more about why developers at Facebook think it's a good
    idea to separate the React library into two packages at [https://facebook.github.io/react/blog/2015/07/03/react-v0.14-beta-1.html#two-packages](https://facebook.github.io/react/blog/2015/07/03/react-v0.14-beta-1.html#two-packages).
  prefs: []
  type: TYPE_NORMAL
- en: Now we're ready to start using the React library in our project. Next, let's
    create our first React element!
  prefs: []
  type: TYPE_NORMAL
- en: Creating React elements with JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start by familiarizing ourselves with fundamental React terminology. It
    will help us build a clear picture of what the React library is made of. This
    terminology will most likely update over time, so keep an eye on the official
    documentation at [https://facebook.github.io/react/docs/react-api.html](https://facebook.github.io/react/docs/react-api.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the DOM is a tree of nodes, React''s virtual DOM is a tree of React
    nodes. One of the core types in React is called `ReactNode`. It''s a building
    block for a virtual DOM and it can be any one of these core types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReactElement`: This is the primary type in React. It''s a light, stateless,
    immutable, virtual representation of a `DOMElement`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReactText`: This is a string or a number. It represents textual content and
    it''s a virtual representation of a text node in the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReactElement` and `ReactText` are `ReactNode`. An array of `ReactNode` is
    called a `ReactFragment`. You will see examples of all of these in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example of `ReactElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your `~/snapterest/source/app.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now your `app.js` file should look exactly like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the `~/snapterest/` directory and run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the `~/snapterest/build/` directory, and open `index.html` in a
    web browser. You will see a blank web page. Open **Developer tools** in your web
    browser and inspect the HTML markup for your blank web page. You should see this
    line, among others:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Well done! We've just rendered your first React element. Let's see exactly how
    we did it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entry point to the React library is the `React` object. This object has
    a method called `createElement()` that takes three parameters: `type`, `props`,
    and `children`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at each parameter in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The type parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `type` parameter can be either a string or `ReactClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: A string could be an HTML tag name, such as `'div'`, `'p'`, and `'h1'`. React
    supports all the common HTML tags and attributes. For a complete list of HTML
    tags and attributes supported by React, you can refer to [https://facebook.github.io/react/docs/dom-elements.html](https://facebook.github.io/react/docs/dom-elements.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ReactClass` class is created via the `React.createClass()` method. I'll introduce
    this in more detail in [Chapter 4](ch04.html "Chapter 4. Creating Your First React
    Component"), *Creating Your First React Component*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `type` argument describes how an HTML tag or a `ReactClass` class is going
    to be rendered. In our example, we're rendering the `h1` HTML tag.
  prefs: []
  type: TYPE_NORMAL
- en: The props parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `props` parameter is a JavaScript object passed from a parent element to
    a child element (and not the other way around) with some properties that are considered
    immutable, that is, those that should not be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'While creating DOM elements with React, we can pass the `props` object with
    properties that represent the HTML attributes such as `class` and `style`. For
    example, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create an `h1` HTML element with a `class` attribute
    set to `header`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we name our property `className` rather than `class`. The reason
    for this is that the `class` keyword is reserved in JavaScript. If you use `class`
    as a property name, it will be ignored by React, and a helpful warning message
    will be printed on the web browser''s console:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning: Unknown DOM property class. Did you mean className?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use className instead.**'
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering what this `data-reactroot` attribute is doing in our
    `h1` tag? We didn't pass it to our `props` object, so where did it come from?
    It is added and used by React to track the DOM nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The children parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `children` parameter describes what child elements this html element should
    have, if any. A child element can be any type of `ReactNode`: a virtual DOM element
    represented by `ReactElement`, a string or a number represented by `ReactText`,
    or an array of other `ReactNode` nodes, which is also called `ReactFragment`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create an `h1` HTML element with a `class` attribute
    and a text node, `This is React`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `h1` tag is represented by `ReactElement`, while the `This is React` string
    is represented by `ReactText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create a React element with a number of other React elements as
    its children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created three React elements: `h1`, `p`, and `section`. The `h1` and
    `p` both have child text nodes, `''This is React''` and `''And that is how it
    works.''`, respectively. The `section` tag has a child that is an array of two
    `ReactElement` types, `h1` and `p`, called `reactFragment`. This is also an array
    of `ReactNode`. Each `ReactElement` type in the `reactFragment` array must have
    a `key` property that helps React to identify that `ReactElement` type. As a result,
    we get the following HTML markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we understand how to create React elements. What if we want to create a
    number of React elements of the same type? Does it mean that we need to call `React.createElement(''type'')`
    over and over again for each element of the same type? We can, but we don''t need
    to because React provides us with a factory function called `React.createFactory()`.
    A factory function is a function that creates other functions. This is exactly
    what `React.createFactory(type)` does: it creates a function that produces `ReactElement`
    of a given type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example produces this HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify it by first creating a factory function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we're first calling the `React.createFactory()` function
    and passing a `li` HTML tag name as a type parameter. Then, the `React.createFactory()`
    function returns a new function that we can use as a convenient shorthand to create
    elements of the `li` type. We store a reference to this function in a variable
    called `createListItemElement`. Then, we call this function three times, and each
    time we only pass the `props` and `children` parameters, which are unique for
    each element. Notice that `React.createElement()` and `React.createFactory()`
    both expect an HTML tag name string (such as `li`) or the `ReactClass` object
    as a type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'React provides us with a number of built-in factory functions to create common
    HTML tags. You can call them from the `React.DOM` object; for example, `React.DOM.ul()`,
    `React.DOM.li()`, and `React.DOM.div()`. Using them, we can simplify our previous
    example even further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we know how to create a tree of `ReactNode`. However, there is one important
    line of code that we need to discuss before we can progress further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you might have already guessed, it renders our `ReactNode` tree to the DOM.
    Let's take a closer look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering React elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ReactDOM.render()` method takes three parameters: `ReactElement`, a regular
    `DOMElement` container, and a `callback` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A `ReactElement` type is a root element in the tree of `ReactNode` that you've
    created. A regular `DOMElement` parameter is a container DOM node for that tree.
    The `callback` parameter is a function executed after the tree is rendered or
    updated. It's important to note that if this `ReactElement` type was previously
    rendered to a parent `DOMElement` container, then `ReactDOM.render()` will perform
    an update on the already rendered DOM tree and only mutate the DOM, as it is necessary
    to reflect the latest version of the `ReactElement` type. This is why a virtual
    DOM requires fewer DOM mutations.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've assumed that we're always creating our virtual DOM in a web browser.
    This is understandable because, after all, React is a user interface library,
    and all user interfaces are rendered in a web browser. Can you think of a case
    when rendering a user interface on a client would be slow? Some of you might have
    already guessed that I am talking about the initial page load. The problem with
    the initial page load is the one I mentioned at the beginning of this chapter—we're
    not creating static web pages anymore. Instead, when a web browser loads our web
    application, it receives only the bare minimum HTML markup that is usually used
    as a container or a parent element for our web application. Then, our JavaScript
    code creates the rest of the DOM, but in order for it to do so, it often needs
    to request extra data from the server. However, getting this data takes time.
    Once this data is received, our JavaScript code starts to mutate the DOM. We know
    that DOM mutations are slow. How can we solve this problem?
  prefs: []
  type: TYPE_NORMAL
- en: The solution is somewhat unexpected. Instead of mutating the DOM in a web browser,
    we mutate it on a server, just like we would with our static web pages. A web
    browser will then receive an HTML that fully represents a user interface of our
    web application at the time of the initial page load. Sounds simple, but we can't
    mutate the DOM on a server because it doesn't exist outside a web browser. Or
    can we?
  prefs: []
  type: TYPE_NORMAL
- en: We have a virtual DOM that is just JavaScript, and using Node.js, we can run
    JavaScript on a server. So, technically, we can use the React library on a server,
    and we can create our `ReactNode` tree on a server. The question is how can we
    render it to a string that we can send to a client?
  prefs: []
  type: TYPE_NORMAL
- en: 'React has a method called `ReactDOMServer.renderToString()` just to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `ReactDOMServer.renderToString()` method takes `ReactElement` as a parameter
    and renders it to its initial HTML. Not only is this faster than mutating a DOM
    on a client, but it also improves the **Search Engine Optimization** (**SEO**)
    of your web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of generating static web pages, we can do this too with React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `ReactDOMServer.renderToString()`, this method also takes `ReactElement`
    as a parameter and outputs an HTML string. However, it doesn't create extra DOM
    attributes that React uses internally, producing shorter HTML strings that we
    can transfer to the wire quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know not only how to create a virtual DOM tree using React elements,
    but you also know how to render it to a client and server. Our next question is
    whether we can do it quickly and in a more visual manner.
  prefs: []
  type: TYPE_NORMAL
- en: Creating React elements with JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we build our virtual DOM by constantly calling the `React.createElement()`
    method, it becomes quite hard to translate these multiple function calls visually
    into a hierarchy of HTML tags. Don't forget that even though we're working with
    a virtual DOM, we're still creating a structure layout for our content and user
    interface. Wouldn't it be great to be able to visualize that layout easily by
    simply looking at our React code?
  prefs: []
  type: TYPE_NORMAL
- en: '**JSX** is an optional HTML-like syntax that allows us to create a virtual
    DOM tree, without using the `React.createElement()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the previous example that we created without JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Translate this into the one with JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, JSX allows us to write HTML-like syntax in our JavaScript code.
    More importantly, we can now clearly see what our HTML layout will look like once
    it's rendered. JSX is a convenience tool and it comes with a price in the form
    of an additional transformation step. A transformation of JSX syntax into a valid
    JavaScript syntax must happen before our "invalid" JavaScript code is interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous chapter, we installed the `babel-preset-react` module that
    transforms our JSX syntax into valid JavaScript. This transformation happens every
    time we run Webpack. Navigate to `~/snapterest/` and run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand JSX syntax better, I recommend that you play with the Babel REPL
    tool: [https://babeljs.io/repl/](https://babeljs.io/repl/)—it converts your JSX
    syntax to plain JavaScript on the fly.'
  prefs: []
  type: TYPE_NORMAL
- en: Using JSX, you might feel very unusual in the beginning, but it can become a
    very intuitive and convenient tool to use. The best part is that you can choose
    whether to use it or not. I found that JSX saves me development time, so I chose
    to use it in this project that we're building.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a question about what we discussed in this chapter, then you can
    refer to [https://github.com/fedosejev/react-essentials](https://github.com/fedosejev/react-essentials)
    and create a new issue.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by discussing the issues with single web page applications
    and how they can be addressed. Then, you learned what a virtual DOM is and how
    React allows us to build one. We also installed React and created our first React
    element using only JavaScript. Then, you also learned how to render React elements
    in a web browser and on a server. Finally, we looked at a simpler way of creating
    React elements with JSX.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dive deeper into the world of React components.
  prefs: []
  type: TYPE_NORMAL
