- en: Templating with Handlebars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JavaScript template engines are the reason why node.js proves to be an
    isomorphic technology. It adds a server-side UI rendering functionality in node.js,
    stimulating its client-side rendering performance. Next, it also eases the maintenance
    of client-side code as it is tightly coupled in server-side code. Lets understand
    it more clearly in this chapter by exploring the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Handlebars templating framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The steps to develop the templates necessary to build the presentation layer
    of our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start exploring the capabilities of Handlebars, we need to have an
    idea of what a templating framework generally does.
  prefs: []
  type: TYPE_NORMAL
- en: Templating engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, an MVC application framework divides the application-specific
    code into models, views, and controllers. Controllers are supposed to be handling
    the task of binding the appropriate data to its relevant views to generate the
    output for an incoming web application request. So, views are supposed to be independent
    of the data and only contain code relevant to the presentation of the data, which
    will be mostly HTML. Apart from HTML, views will need to contain presentation
    logic, which will be conditions written on the data passed to them via controllers.
    Then, the main task that templating frameworks do in this case is that they make
    this process of embedding presentational logic simpler and readable. Also, they
    attempt to segregate the views into more understandable subcomponents.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side and client-side templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templating solutions can be generally classified as client-side and server-side
    templating solutions. The web applications we build usually follow a server-side
    or client-side templating approach or a hybrid of both.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a case where the web application, after loading the page, makes an API
    call via AJAX and gets a JSON response in return. How will it render the data
    it received into its corresponding HTML? Client-side templates are required in
    this case to keep our JavaScript code neat and clean, or else we will end up putting
    too much unreadable HTML code as strings inside the JavaScript code. Client-side
    templating frameworks allow us to dump the templates corresponding to the components
    of a page in the markup inside specific tags and render them via JavaScript code
    whenever necessary. The common disadvantage of following a client-side approach
    is the impact it has on the initial render time of this page.
  prefs: []
  type: TYPE_NORMAL
- en: Another important advantage of using client-side templating is that it helps
    to offload the templating effort from the server to the client. This helps to
    reduce the computational load on your server to a great extent, as the templating
    logic is executed only in the browser via JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server-side templating is where we will render the markup via calling the corresponding
    views before sending the HTML response back to the web browser. This is what we
    will explore in this chapter via Handlebars.
  prefs: []
  type: TYPE_NORMAL
- en: Many different rendering engines are available that can be used with Node and
    Express. The most popular among them are Jade, EJS, and Handlebars. The particular
    engine we will explore in this book is Handlebars.js.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Handlebars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Handlebars** is a really simple and easy-to-use templating framework. It
    works on the principle of interpolation of data within the template. To get an
    overview of Handlebars, consider the following block diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79f68b2d-0cfe-4024-baef-1f18685afb88.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the compile method accepts the HTML expression templates and results in
    a function with a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through and explore the basic syntax of writing a Handlebars template.
  prefs: []
  type: TYPE_NORMAL
- en: Binding an object to the template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that the following JavaScript object is passed to a Handlebars
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The template file itself will contain the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding markup contains `name` as the HTML expression that will be interpolated
    by its context object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to write the JavaScript method that makes it work, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This output variable will contain the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Embedding presentation logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, there''s a lot more that you can do than just this! Handlebars also
    supports conditional statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using an `if` block helper, as shown in the preceding code, you can check for
    true conditionals and only display HTML and/or data if the condition is true.
    Alternatively, you can use the `unless` helper to do the opposite and display
    HTML only if a condition is false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can use both `if` and `else` as well as `unless` the same way you would
    use conditional `if/else` in other programming languages. So that's it! These
    were all the basics that we need to know to resume our application.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A view is what we refer to an HTML page as. They are called views because of
    the MVC design pattern. As we already discussed, a model is a data that will be
    displayed on a page, the view is the page itself, and the controller is the brain
    that communicates between the model and the view.
  prefs: []
  type: TYPE_NORMAL
- en: Our particular application is going to need two views. The first view is the
    home page and the second view is the image page.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML in the following section relies heavily on Bootstrap, a popular HTML
    framework created by Twitter, which provides a standard set of user interface
    elements. These include buttons, fonts, layout grids, color schemes, and a whole
    lot more. Using Bootstrap allows us to not only present our application with a
    nice clean UI but also build it so that it is responsive and will look correct
    on any device that is viewing it. You can learn more about Bootstrap by visiting
    [http://getbootstrap.com](http://getbootstrap.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the home page view. Create a new file within the `views`
    folder, name it `index.Handlebars`, and insert the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The reason we named our file `index.Handlebars` is a purely personal choice,
    but it is also based on common naming conventions on the web. Typically, an HTML
    page that acts as the root file for any website is named `index.whatever` (`.php`,
    `.aspx`, `.html`, and so on). Again, this is just a common convention and not
    something you need to specifically adhere to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a basic HTML form and set `method` to `post` and `action` to `/images`.
    Ensure that you set the `enctype` attribute of the form, since we will be uploading
    files as well as submitting data via form fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have included a standard HTML input field for the file to be uploaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Another standard HTML input field for the title of the file can be whatever
    the user wants, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A standard HTML `textarea` input field to allow for a description is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A standard HTML button is provided that will submit the form to the server.
    Using Bootstrap classes, we provide `btn` and `btn-success` to make this look
    like a Bootstrap-style button with the default color for success (green):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After the upload form section, we will display a list of the newest images
    uploaded to the website. Refer to the `each` block in the code snippet that follows.
    It is a keyword supported by Handlebars to loop over the data provided to the
    template in case of reusable HTML blocks. We will discuss this in detail in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are two important sections in the main home page HTML code. The first
    is
  prefs: []
  type: TYPE_NORMAL
- en: the form we define, which will be the main way in which users will upload images
    to the website. As we will be accepting image files as well as details of the
    image (title, description, and so on), we need to ensure that the form is set
    up to accept multipart data. We also set the form action to point to the `/images`
    route we defined earlier in our `routes` and `image` controller modules. When
    a user completes the form and clicks on the Submit button, the form will send
    a `POST` request to `http://localhost:3300/images` and our router will catch that
    and forward it to our `image` controller. From there, the `image` controller will
    handle the processing of the data and will save it to the database, saving the
    image file to the filesystem, and redirecting to the image details page. We will
    actually be writing this logic in the next chapter. For now, nothing will actually
    happen if you submit the form.
  prefs: []
  type: TYPE_NORMAL
- en: Below the main image uploading form on the home page, we also have a section
    that performs a Handlebars loop using `each` and iterates through an image collection,
    displaying each image as a thumbnail and the link to the image page. The `images`
    collection will be populated from our `home` controller. It's important to note
    here that when you are inside a `{{#each}}` loop in a Handlebars template, your
    context changes. That is, the path you use to access data inside `each` is now
    based on each item in the collection. Here, our object, which will be bound to
    the view, will have an image collection, and each item in the image collection
    will have a property for `uniqueid`, `filename`, and `title`. With the home page
    view out of the way, let's set up the view for the image page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another file in the `views` folder and name it `image.Handlebars`. This
    file is going to have a bit more functionality, so I''m going to break it down
    into chunks so that you can review each section. First, insert the following block
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This block of code defines the bulk of the content that will be displayed on
    the page for a specific image. The `viewModel` for this page is going to consist
    of an `image` object that has various properties defined that you see being used
    throughout the code; properties such as `title`, `description`, `filename`, `likes`,
    `views`, and the timestamp of when the image upload was performed.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed a slightly different piece of syntax in the code specific
    to the `{{ timeago image.timestamp }}` timestamp. That is actually a Handlebars
    helper.
  prefs: []
  type: TYPE_NORMAL
- en: It is a custom function we will write shortly, which will perform some special
    string formatting-specifically, converting a timestamp string to how long it was
    some time ago (that is, 2 days ago, 12 hours ago, 15 minutes ago, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to allow users to post comments to images, so let''s include a simple
    form for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is another standard HTML form with the method and action set.
    This form allows a user to enter, via standard HTML input fields, their name,
    email address, and comments. Another Submit button is provided to save the comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The form action for comments is set to `/images/{{ image.uniqueid }}/comment`.
    Again, if you recall from the routes we set up, we specifically defined a route
    to handle this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we want to display any comments that have been submitted for this
    image. Our `viewModel` includes a collection of comments in addition to the image
    details, so we can simply iterate over that collection using the Handlebars `#each`
    block helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Much like the loop, which we performed on the home page to display a collection
    of images, here, we simply iterate through every comment in the `comments` collection
    and display the comment and string-formatted timestamp (again using our `timeago`
    global helper). We also use Gravatar to display universal avatar images for users
    who have commented (assuming that they have provided their email addresses).
  prefs: []
  type: TYPE_NORMAL
- en: Gravatar is a service provided by [https://wordpress.com/](https://wordpress.com/)
    that allows a user's personal profile image to be provided via his/her email address.
    Many popular web services rely on Gravatar as a quick and easy way to display
    a user's personal profile image, without requiring the additional functionality
    to support such a feature. You can learn more about Gravatar at [http://gravatar.com](http://gravatar.com).
  prefs: []
  type: TYPE_NORMAL
- en: Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve created two specific views for our website: one for the home
    page and one for the details of an image. However, there''s no consistent UI wrapping
    both of these pages together. We have no consistent navigation or logo. There''s
    no common footer with standard copyright or additional information.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, with any website that you create, you're going to want to have some
    form of a standard layout or master template that every page will use. This layout
    typically includes the website logo and title, main navigation, sidebar (if any),
    and the footer. It would be bad practice to include the HTML code for the layout
    in every single page on the website because if you wanted to make even the smallest
    change to the main layout, you would have to edit every single page as a result.
    Fortunately, Handlebars helps lessen the work of utilizing a layout file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a layout file for our app by creating a new file named `main.Handlebars`
    within the `views/layouts` folder and inserting the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Most of the preceding code is just HTML and a lot of it uses Bootstrap for the
    actual physical layout of the page as well as a few other UI-related elements.
    The most important part is the highlighted section in the middle with `{{{ body
    }}}` and the few lines below that, as they pertain to the use of Handlebars.
  prefs: []
  type: TYPE_NORMAL
- en: The `{{{ body }}}` is a reserved word in Handlebars that is used specifically
    for layouts. What we are basically saying is that any page we render that uses
    our default layout file will have its content inserted into the area where `{{{
    body }}}` is defined. If you recall from the `configure` module we created earlier,
    we defined our default layout file when we set up Handlebars as our rendering
    engine. The slightly odd use of `{{{` and `}}}` around the body is due to the
    fact that Handlebars escapes HTML by default when using `{{` and `}}`. Since our
    views contain mostly HTML, we want this to stay intact so that we use `{{{` and
    `}}}` instead.
  prefs: []
  type: TYPE_NORMAL
- en: The other three lines that use the `{{ > ... }}` render Handlebars partials,
    which are like the shared HTML code blocks, and will be covered next.
  prefs: []
  type: TYPE_NORMAL
- en: Partial views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we created a view, which acts as the bulk of the HTML for a specific
    page, and a layout, which acts as the wrapper for the consistent parts of the
    website on every page. Next, let's take a look at creating partials, which are
    really just small views that we can reuse and inject inside our layouts or views.
  prefs: []
  type: TYPE_NORMAL
- en: Partials are a terrific way to create reusable components in a website and reduce
    code duplication. Consider the comments in our application. We have an HTML form
    defined that a user uses to submit a comment, but what if we wanted to allow users
    to post comments from a number of different areas throughout the website? This
    type of scenario is a great candidate for moving our comment form out to its own
    partial and then just including that partial anywhere we want to display the comment
    form.
  prefs: []
  type: TYPE_NORMAL
- en: For this app, we're using partials specifically for the sidebar in the main
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: With every view's `viewModel`, we will include a JavaScript object called `sidebar`
  prefs: []
  type: TYPE_NORMAL
- en: that will contain the data specifically for the stats, popular images, and recent
    comments found within the sidebar partial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the HTML for each of the partials. First, create a file named
    `stats.Handlebars` within the `views/partials/` path and include the following
    HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create `views/partials/popular.Handlebars` and insert the following HTML
    code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create `views/partials/comments.Handlebars` and insert the following
    HTML code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Handlebars helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handlebars supports the idea of helpers, which are special custom functions
    you can write to perform some special logic from within the template during runtime.
    This will encourage developers to migrate the common presentation logic present
    in views into helpers and reuse them, thereby adding much more readability to
    the views. A great example of a helper would be the date string formatter we've
    been using. Helpers can be registered globally and made available to every template
    file, or they can be defined per view and passed to the template on an as-needed
    basis as part of the `viewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Global helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's create a global helper that will be available to every Handlebars
    template we render. The global helper that we will create will be used to format
    a timestamp so that it is worded according to how long ago the event occurred.
    We will use this throughout our application for things such as comments and image
    timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is update our `server/configure.js` module, where
    we originally configured Handlebars as our rendering engine. We will add the following
    section to define our helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the additional code we added (highlighted in the preceding
    code), we defined the `helpers` property of the configuration options within `create()`.
    Inside the `helpers` property, we can define any number of functions we want.
    In this case, we defined a simple `timeago` function that actually uses another
    `npm` module called `moment`. The `moment` module is a great library for performing
    numerous different types of date string formatting. As we are using a new module,
    we need to be sure to perform `require()` at the top of our `configure` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we need to actually install it via `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: View-specific helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While defining helpers globally is nice because they are available to every
    view that''s rendered, sometimes you might only need to define a helper for use
    within a single view. In this case, you can include the helper with the model
    itself when calling `res.render()`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Not only are we defining a custom helper that can be used specifically from
    this view in its model object but, in this particular instance, we are overriding
    the existing `timeago` global helper with a slightly different version that is
    perfectly valid.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a minute to do a quick recap and see what we''ve done up to this
    point. So far, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We created `index.Handlebars` and `image.Handlebars`, the views for the two
    main pages of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created `layouts/main.handelbars`, the main layout file for every page in
    the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created `partials/comments.Handlebars`, `popular.Handlebars`, and `stats.Handlebars`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a global `timeago` Handlebars helper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, so good; however, none of these views actually do anything, receive
    any `viewModels`, or even appear when you run the application! Let's make a few
    quick minor modifications to our controllers to get our views to render properly.
  prefs: []
  type: TYPE_NORMAL
- en: Open `/controllers/home.js` so that you can edit the `home` controller module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the contents of that file so that it looks identical to the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Instead of performing `res.send`, which just sends a simple response, we are
    calling `res.render` and passing in the name of the template file we want to render
    as the only parameter (for now). Using the defaults that were defined in our `configure`
    module, the `index` file will be loaded from our `views` folder. Again, also using
    the defaults, we configured the default layout of `main` that will be applied
    to this view in our `configure` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the `image` controller to do the same thing as well. Edit `/controllers/image.js`
    and change the `index` function so that it looks identical to the following block
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! Let's fire up the server, open the app in our browser, and see
    how
  prefs: []
  type: TYPE_NORMAL
- en: 'it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command uses `npm start` to start the application. Please note
    that this command will work only if you have the application entrypoint file configured
    in the `package.json` file. If this is not working, then you have to set the main
    attribute in the `package.json` and set it to the `server.js` file. Also, as an
    alternative, you can manually invoke the `server.js` file by using `node server.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success! Hopefully, you see something that closely resembles the following
    screenshot of the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/464d7d90-c835-43d7-8dd4-775e358b010c.png)'
  prefs: []
  type: TYPE_IMG
- en: Additionally, if you provide a random URL to a specific image, for example,
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:3300/images/1`, you should see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d75936c4-08ce-4be0-b6d7-834a6426b932.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the Handlebars template-rendering engine was introduced,
  prefs: []
  type: TYPE_NORMAL
- en: following which we reviewed the syntax used when creating dynamic HTML
  prefs: []
  type: TYPE_NORMAL
- en: pages. We created the main layout for our app as well as the home page and image
    page views. We included partial views for the sidebar in the layout and created
    a global Handlebars helper to display custom formatted dates.
  prefs: []
  type: TYPE_NORMAL
- en: Even though none of the views are currently displaying any data (because we
    aren't passing models to the views yet), you can see that things are starting
    to come along nicely! In the next chapter, we will wire up the actual logic in
    the controllers for each page and build up the model objects so that we start
    seeing some actual content on our screens.
  prefs: []
  type: TYPE_NORMAL
