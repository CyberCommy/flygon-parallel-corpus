- en: 'Chapter 8: Exploring Continuous Configuration Automation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have worked with single VMs, deploying and configuring them manually.
    This is nice for labs and very small environments, but if you have to manage bigger
    environments, this is a very time-consuming and even boring job. It's also very
    easy to make mistakes and forget things, such as the slight differences between
    VMs, not to mention the concomitant stability and security risks. For example,
    choosing the wrong version during deployment will result in consistency issues,
    and performing an upgrade later is a tedious process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automating deployment and configuration management is the ideal way to mitigate
    this boring task. However, after a while, you might notice some problems with
    that approach. There are so many reasons why there are problems, and some of the
    reasons for failure are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The script fails because something changed, caused by, for instance, a software
    update.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a newer version of a base image that is slightly different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts can be hard to read and difficult to maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts are dependent on other components; for instance, the OS, script language,
    and available internal and external commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, there is always that one colleagueâ€”the script works for you but, for some
    reason, it always fails when they execute it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, things have improved over time:'
  prefs: []
  type: TYPE_NORMAL
- en: Many script languages are multiplatform now, such as Bash, Python, and PowerShell.
    They are available on Windows, macOS, and Linux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `systemd`, the `systemctl` utility with the `-H` parameter can execute commands
    remotely, and it works even if the remote host is another Linux distribution.
    The newer `systemd` version has more features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewalld` and `systemd` work with easy-to-deploy configuration files and
    overrides.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Automation is most likely not the answer in your quest to deploy, install,
    configure, and manage your workload. Luckily, there is another way: orchestration.'
  prefs: []
  type: TYPE_NORMAL
- en: In musical terms, orchestration is the study of how to write music for an orchestra.
    You have to understand each instrument and know what sounds they can make. Then,
    you can start writing the music; to do this, you have to understand how the instruments
    sound together. Most of the time, you start with a single instrument, for instance,
    a piano. After that, you scale up to include the other instruments. Hopefully,
    the result will be a masterpiece and the members of the orchestra will be able
    to start playing it. It's not that important how the members start, but, in the
    end, the conductor makes sure that the results count.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many similarities to orchestration in computation. Before you can
    start, you have to understand how all the components work, how they fit together,
    and what the components do so that you can get the job done. After that, you can
    start writing the code to achieve the ultimate goal: a manageable environment.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest advantages of a cloud environment is that really every component
    of the environment is written in software. Yes, we know, at the end of the line,
    there is still a datacenter with many hardware components, but as a cloud user,
    you don't care about that. Everything you need is written in software and has
    APIs to talk to. So, it's not only possible to automate the deployment of your
    Linux workloads, but you can automate and orchestrate the configuration of the
    Linux operating system and the installation and configuration of applications
    and keep everything up to date. You can also use orchestration tools to configure
    Azure resources, and it's even possible to create Linux VMs using these tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'In orchestration, there are two different approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Imperative**: Tell the orchestration tool what to do to reach this goal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative**: Tell the orchestration tool what the goal you want to achieve
    is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some orchestration tools can do both, but, in general, the declarative approach
    is the better approach in a cloud environment, where you have so many options
    to configure and you can declare each option and achieve the exact goal. The good
    news is that if it's becoming too complex for this method, for instance, when
    the orchestration tool is not able to understand the goal, you can always extend
    this method with a little bit of the imperative method using scripts.
  prefs: []
  type: TYPE_NORMAL
- en: A big part of this chapter is about Ansible, but we'll also cover PowerShell
    **Desired State Configuration** (**DSC**) and Terraform as examples of declarative
    implementations. The focus, in this chapter, is to understand orchestration and
    know enough to get started. And, of course, we'll discuss integration with Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key takeaways from this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the third-party automation tools such as Ansible and Terraform
    and how they can be used in Azure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure's native automation and PowerShell DSC to achieve the desired state
    of the machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement Azure Policy Guest Configuration and audit the settings in
    your Linux VMs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of other solutions available on the market to automate deployments
    and configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In practice, you'll need at least one VM as a control machine, or you can use
    your workstation running Linux or **Windows Subsystem for Linux** (**WSL**). Along
    with this, we need a node, which needs to be an Azure VM. However, in order to
    provide a better explanation, we've deployed three nodes. If you have budget constraints
    in your Azure subscription, feel free to proceed with one node. It doesn't matter
    which Linux distribution you're using. The examples in this section, to orchestrate
    the node, are for an Ubuntu node, but it's easy to translate them to other distributions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, multiple orchestration tools are explored. For every tool,
    you'll need a clean environment. So, when you are finished with the Ansible section
    in this chapter, remove the VMs and deploy new ones before going into Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Configuration Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the introduction of this chapter, you might have read the term *configuration
    management*. Let''s understand this in more depth. Configuration management refers
    to how you want your VM to be configured. For example, you want an Apache webserver
    to host a website in a Linux VM; so, the configuration part of the VM involves:'
  prefs: []
  type: TYPE_NORMAL
- en: Installation of Apache package and dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening firewall ports for HTTP traffic or HTTPS traffic if you are using SSL
    (Secure Sockets Layer) certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling the service and bootstrapping it so the Apache service is started on
    boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example is for a very simple web server. Think about a complex scenario
    where you have a front-end web server and back-end databases, so the configuration
    involved is very high. So far, we've been talking about a single VM; what if you
    want multiple VMs with the same configuration? We are back to square one, where
    you have to repeat the configuration multiple times, which is a time-consuming
    and boring task. Here comes the role of orchestration, as we discussed in the
    introduction. We can make use of orchestration tools to deploy the VM with the
    state we want. The tools will take care of the configuration. Also, in Azure,
    we have Azure Policy Guest Configuration, which can be used to audit the settings.
    Using this policy, we can define a condition that the VM should be in. If the
    evaluation fails or the condition is not met, Azure will mark this machine as
    non-compliant.
  prefs: []
  type: TYPE_NORMAL
- en: A big part of this chapter is about Ansible, but we'll also cover PowerShell
    DSC and Terraform as examples of declarative implementations. The focus, in this
    chapter, is to understand orchestration and learn enough to get started. And,
    of course, we'll discuss integration with Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible is minimal in nature, has almost no dependencies, and it doesn''t deploy
    agents to nodes. Only OpenSSH and Python are required for Ansible. It''s also
    highly reliable: changes can be applied multiple times without changing the result
    beyond the initial application and there shouldn''t be any side effects on the
    rest of the system (unless you write really bad code). There is a strong focus
    on the reuse of code, which makes it even more reliable.'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible doesn't have a very steep learning curve. You can start with just a
    few lines of code and scale up afterward without breaking anything. In our opinion,
    if you want to try an orchestration tool, start with Ansible, and if you want
    to try another, the learning curve will be much less steep.
  prefs: []
  type: TYPE_NORMAL
- en: Installation of Ansible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Azure Marketplace, a ready-to-go VM is available for Ansible. There are
    three versions of Ansible available in Azure Marketplace currently: Ansible Instance,
    Ansible Tower, and AWX, which is a Community edition of Ansible Tower. In this
    book, we will concentrate on the community project that is freely available; it''s
    more than enough to learn and get started with Ansible. After that, you can go
    to the Ansible website to explore the differences, download the trial version
    of the enterprise edition of Ansible, and decide whether you need the enterprise
    version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to install Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the repository of your distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the latest release available at [https://releases.ansible.com/ansible](https://releases.ansible.com/ansible
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using GitHub: [https://github.com/ansible](https://github.com/ansible )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the Python installer, the preferred method, which works on every OS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Python''s `pip` is not available for installation in the standard repositories
    of Red Hat and CentOS. You have to use the extra EPEL repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing Ansible, check the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You don''t have to install Ansible if you don''t want to: Ansible is preinstalled
    in Azure Cloud Shell. At the time of writing this book, Cloud Shell supports Ansible
    version 2.9.0\. However, to give a walk-through of the installation, we''ll go
    for the local installation of Ansible on the VM. For integration with Azure, you
    also need to install the Azure CLI to get the information you''ll need to provide
    to Ansible.'
  prefs: []
  type: TYPE_NORMAL
- en: SSH Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The machine where you installed Ansible is now called the ansible-master or,
    in other words, it's just a VM with Ansible, the Ansible configuration file, and
    the instructions for orchestration. Communication with the nodes is done using
    communication protocols. For Linux, SSH is used as a communication protocol. To
    make Ansible be able to communicate in a secure way with the nodes, use key-based
    authentication. If this has not already been done, generate an SSH key pair and
    copy the key to the VM you want to orchestrate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the SSHs key, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you generate the key, it will be saved to the home directory of the user
    in the `.ssh` directory by default. To display the key, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the key, we have to copy this value to the node server. Follow
    these steps to copy the key:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the contents of the `id_rsa.pub` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SSH to your node server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to superuser using the `sudo` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `authorized_keys` file in `~/.ssh/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the key we copied from the Ansible server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify whether the process was successful, go back to the machine where Ansible
    is installed (going forward, we'll call this ansible-master) and `ssh` to the
    node. It will ask for the passphrase if you used one while generating the key.
    Another method to automate the entire process of copying keys is to use the `ssh-copy-id`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Bare-Minimum Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To configure Ansible, you''ll need an `ansible.cfg` file. There are different
    locations where this configuration file can be stored, and Ansible searches in
    the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Ansible will process the preceding list and uses the first file found; all others
    are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `ansible` directory in `/etc` if not available and add a file called
    `ansible.cfg`. This is where we are going to save our configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This command, called an ad hoc command, executes `systemctl status sshd` to
    all hosts defined in `/etc/ansiblehosts`. If you have multiple usernames for each
    host, you can also specify the username for these nodes in the format as shown
    in the following ansible hosts file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So you can add the user to the inventory file line items as shown in the following
    screenshot, if needed, and the file will look like this for three nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code to add users to the inventory file line items](img/B15455_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Adding the user to the inventory file line items'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Try again. Instead of your local username, the remote user is used. You're now
    able to log in and execute the command.
  prefs: []
  type: TYPE_NORMAL
- en: Inventory File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ansible inventory file defines the hosts and groups of hosts. Based on this,
    you can call out the host or group (group of hosts) and run a specific playbook
    or execute a command.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are going to call our group `nodepool` and add IPs of our nodes. Since
    all our VMs are in the same Azure VNet, we are using the private IP. If they are
    in different networks, you can add the public IP. Here, we are using three VMs
    to aid explanation. If you have only one node, just input that one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can use the DNS name of the VMs, but they should be added to your
    `/etc/hosts` file for resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Another parameter that will be useful is `ansible_ssh_user`. You can use this
    to specify the username used to sign in to the node. This scenario comes into
    the picture if you are using multiple usernames across your VMs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using `all` in our example, you can use a group name that is `ansible-nodes`.
    It''s also possible to use generic variables that are valid for every host and
    override them per server; for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, you''ll need privileges to execute a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For ad hoc commands, just add the `-b` option as an Ansible parameter to enable
    privilege escalation. It will use the `sudo` method by default. In Azure images,
    you don't need to give your root password if you are using `sudo`. This is why
    the `-b` option works without a problem. If you configured `sudo` to prompt for
    a password, use `-K`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would suggest running other commands, such as `netstat` and `ping`, to understand
    how the commands are executed in these machines. Running `netstat` and grepping
    for `sshd` will give a similar output to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output of netstat and grep ssh command](img/B15455_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Running netstat and grepping for sshd'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might get deprecation warnings when running the `ansible all` command. To
    suppress this, use `deprecation_warnings=False` in `ansible.cfg`.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Playbooks and Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using ad hoc commands is an imperative method and is not any better than just
    using the SSH client to execute commands remotely.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two components that you need to make it into real, imperative orchestration:
    a playbook and a module. The playbook is the basis for the deployment, configuration,
    and maintenance of your system. It can orchestrate everything, even between hosts!
    A playbook is there to describe the state you want to reach. Playbooks are written
    in YAML and can be executed with the `ansible-playbook` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The second component is the module. The best way to describe a module is as
    follows: the task to be executed to reach the desired state. They are also known
    as task plugins or library plugins.'
  prefs: []
  type: TYPE_NORMAL
- en: All the available modules are documented; you can find the documentation online
    and on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all the available plugin documentation, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will take a while. We suggest that you redirect the result to a file. This
    way, it takes less time and it's easier to search for a module.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's try to create a playbook that will create a user using
    the **user** module if the user doesn't already exist. In other words, the desired
    state is that a specific user exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by reading the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file in the Ansible directory, for instance, `playbook1.yaml`, with
    the following content. Verify the parameters in the user documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output, you can see that all hosts returned `OK` and the user was
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parametres of the created ansible file](img/B15455_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Running the Ansible playbook'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Just to make sure that the user is created, we will check the `/etc/passwd`
    file in all the hosts. From the output, we can see that the user has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking the password file of the hosts to verify user creation](img/B15455_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Verifying user creation using /etc/passwd'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Make sure that the indentation is correct because YAML is a very strict language
    when it comes to indentation and white space. Using an editor such as vi, Emacs,
    or Visual Studio Code with YAML support really helps.
  prefs: []
  type: TYPE_NORMAL
- en: If you are required to run a command privilege escalation, `become` and `become_method`
    or `â€“b` can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the Ansible syntax, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's go ahead and see how we can authenticate to Azure and start the deployment
    in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating to Microsoft Azure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To integrate Ansible with Microsoft Azure, you need to create a configuration
    file to provide the credentials for Azure to Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The credentials must be stored in your home directory in the `~/.azure/credentials`
    file. First, we have to collect the necessary information with the Azure CLI.
    Authenticate to Azure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re successfully logged in, you will get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User credentials indicating successful Azure login](img/B15455_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Logging in to Azure with the az login command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is already a part of the information you''ll need. If you were already
    logged in, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Service Principal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The app ID is your `client_id`, and the password is your `secret`, which will
    be referenced in the credentials file we are going to create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `~/.azure/credentials` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Use `ansible-doc -l | grep azure` to find out which Ansible modules are available
    for Azure. Redirect the content to a file for reference.
  prefs: []
  type: TYPE_NORMAL
- en: Resource Group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s check everything works as expected. Create a new playbook named `resourcegroup.yaml`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that the hosts directive is localhost! Execute the playbook and
    verify whether the resource group is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be very similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Virtual Machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a VM in Azure using Ansible. To do this, create a `virtualmachine.yaml`
    file with the following content. Examine the `name` field of each block to understand
    what the code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Considering the length of the code, we have just shown a few lines here. You
    can download the entire `virtualmachine.yaml` file from the `chapter 8` folder
    in the GitHub repository of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see that all the resources required for
    the VM are created by Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating all the required resources for the VM with Ansible](img/B15455_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Creating all the required resources for the VM with Ansible'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can find a full example for Azure VM deployment using Ansible in Ansible's
    Microsoft Azure Guide ([https://docs.ansible.com/ansible/latest/scenario_guides/guide_azure.html](https://docs.ansible.com/ansible/latest/scenario_guides/guide_azure.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Azure Inventory Management in Ansible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have learned two ways to use Ansible in Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible in an inventory file to connect to Linux machines. In fact, it
    doesn't matter whether it's running in Azure or somewhere else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible to manage Azure resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we're going one step further. Instead of using a static inventory,
    we will ask Azure what is running in your environment using dynamic inventory
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to download the dynamic inventory script for Azure. Execute
    with `sudo` if you are not a root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Edit the `/etc/ansible/ansible.cfg` file and remove the `inventory=/etc/ansible/hosts`
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s carry out the first step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It will probably fail on account of authentication problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Host connection failure due to authentication issues](img/B15455_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Host connection failure due to authentication issues'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you have a different login for different VMs, you can always use the user
    directive per task. Here, we are using `azure` which means all VMs. You can always
    query for a machine using the VM name. For example, you can ping the `ansible-node3`
    VM using a user credential:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the user credentials to ping the ansible-node3 VM](img/B15455_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Querying for the ansible-node3 VM'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Ideally, Ansible expects you to use SSH keys instead of passwords. If you would
    like to use a password, you can use `â€“extra-vars` and pass the password. Please
    note that for this you need to install an application called `sshpass`. To ping
    a VM in Azure that uses a password via Ansible, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take the instance of the VM we created using Ansible in the previous
    example, where the username was `student` and the password was `welk0mITG!`. From
    the screenshot, you can see that the ping succeeds. You might see some warnings,
    but they can be safely ignored. However, further investigation is needed if the
    ping fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot indicating that ping to the user succeeds](img/B15455_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Sending a ping for the username student'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'By creating an `azure_rm.ini` file in the same directory as the `azure_rm.py`
    directory, you can modify the behavior of the inventory script. Here is an example
    `ini` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It works in a very similar way to the `hosts` file. The `[azure]` section means
    all VMs. You can also provide sections for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Location name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource group name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security group name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag key value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another method for selecting one or more VMs is to use tags. To be able to
    tag a VM, you''ll need the ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can tag the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also tag the VM in the Azure portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tagging the VM in the Azure portal](img/B15455_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Tagging the VM in the Azure portal'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click on **change** and add a tag, with or without a value (you can use the
    value to filter the value too). To verify, use the tag name host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the tagged VM is pinged. Let''s create a playbook for this tagged VM,
    for instance, `/etc/ansible/example9.yaml`. The tag is, again, used in the `hosts`
    directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Once the playbook has been run, if you check the VM, you can see that Apache
    is installed.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, Ansible is not the only tool. There is another popular
    one called Terraform. In the next section, will be discussing Terraform on Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Using Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraform is another **Infrastructure as Code** (**IaC**) tool that is developed
    by HashiCorp. You might wonder why it is called an IaC tool. The reason is you
    can define how your infrastructure needs to be using code, and Terraform will
    help you deploy it. Terraform uses **HashiCorp Configuration Language** (**HCL**);
    however, you can also use JSON. Terraform is supported in macOS, Linux, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform supports a wide range of Azure resources such as networks, subnets,
    storage, tags, and VMs. If you recall, we discussed the imperative and declarative
    ways of writing code. Terraform is declarative in nature, and it can maintain
    the state of the infrastructure. Once deployed, Terraform remembers the current
    state of the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: As in every section, the first part of the process involves the installation
    of Terraform. Let's proceed with the Linux installation of Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Terraform's core executable can be downloaded from [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)
    and can be copied to one of the directories added to your `$PATH` variable. You
    can also use the `wget` command to download the core executable. To do this, first
    you have to find out the latest version of Terraform from the aforementioned link.
    At the time of writing, the latest version available is 0.12.16
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the version, we will download the executable using `wget`
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The ZIP will be downloaded to the current working directory. Now we will use
    the unzip tool to get the executable extracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`unzip` might not be installed by default. If it''s throwing an error, install
    `unzip` using `apt` or `yum` depending on the distribution you are using.'
  prefs: []
  type: TYPE_NORMAL
- en: The extraction process will get you the Terraform executable, and you can copy
    this to any location in your `$PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify whether the installation was successful, you can execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have confirmed that Terraform been installed, let's go ahead and
    set up the authentication to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating to Azure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are multiple ways by which you can authenticate to Azure. You can use
    Azure CLI, Service Principal using a Client Certificate, Service Principal and
    Client Secret, and many more methods. For testing purposes, Azure CLI using the
    `az` login command is the right choice. However, if we want to automate deployment,
    this is not an ideal method. We should go for Service Principal and Client Secret,
    the same as we did in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a Service Principal for Terraform. If you already
    have a Service Principal created for the previous section, feel free to use that.
    To create a new Service Principal from Azure CLI, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you might be already familiar with the output, which contains
    the `appID`, password, and tenant ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note down the values in the output, and we will be creating variables to store
    this value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So, we have stored all the values to variables that will be used by Terraform
    for authentication. Since we have dealt with authentication, let's write code
    in HCL with which we can deploy resources in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment to Azure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use any code editor for this purpose. Since we are already on a Linux
    machine, you can use vi or nano. If you want, you can also use Visual Studio Code,
    which has extensions for Terraform and Azure, which will get you IntelliSense
    and syntax highlighting.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a terraform directory to store all our code, and inside the `terraform`
    directory, we will create further directories based on what we are going to deploy.
    In our first example, we will be using Terraform to create a resource group in
    Azure. Later, we will discuss how to deploy a VM in this resource group.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to create a `terraform` directory and to create a `resource-group` subfolder
    within this directory, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a main.tf file with the below content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The code is very simple. Let's take a closer look at each of the items.
  prefs: []
  type: TYPE_NORMAL
- en: The provider directive shows that we would like to use the version 1.33 of the
    `azurerm` provider. In other words, we are indicating that we are going to use
    version 1.33 of the Terraform Azure Resource Manager provider, which is one of
    the plugins available for Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: The `resource` directive says that we are going to deploy an Azure resource
    of the `azurerm_resource_group` type with two parameters, `name` and `location`.
  prefs: []
  type: TYPE_NORMAL
- en: '`rg` stands for the resource configuration. Resource names must be unique per
    type in each module. For example, if you want to create another resource group
    in the same template, you cannot use `rg` again as you have already used it; instead,
    you can go for anything other than `rg`, such as `rg2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start the deployment using the template, we first need to initialize
    the project directory, which is our `resource-group` folder. To initialize Terraform,
    execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'During initialization, Terraform will download the `azurerm` provider from
    its repository and will show a similar output as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Terraform downloading the azurerm provider from its repository](img/B15455_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Initializing Terraform to download the azurerm provider'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Since we''ve already exported the Service Principal details to the variables,
    we can deploy using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will connect Terraform to your Azure subscription and check whether
    the resource exists. If Terraform figures out that the resource doesn''t exist,
    it will go ahead and create an execution plan to deploy. You will get the output
    shown in the following screenshot. To proceed with the deployment, type `yes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using terraform apply to connect terraform to the Azure subscription](img/B15455_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: Connecting Terraform to the Azure subscription'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once you have given the input, Terraform will start the resource creation.
    After creation, Terraform will show you a summary of everything that was created
    and how many resources were added and destroyed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A summary of the resources created using the terraform apply command](img/B15455_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: Summary of the created resources'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A state file named `terraform.tfstate` will be generated in the project directory
    from where we initialized Terraform. This file will have the state information
    and also the list of resources we deployed to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully created the resource group; in the next section, we will
    discuss how to create a Linux VM using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Virtual Machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous example, where we created the resource group, we used `azurerm_resource_group`
    as the resource to be created. For each resource there will be a directive, for
    example, for a VM, it'll be `azurerm_virtual_machine`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we created the resource group using the `terraform apply` command. But
    Terraform also offers a way to work with an execution plan. So instead of deploying
    straight away, we can create a plan and see what changes will be made and then
    deploy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, you can go back to the `terraform` directory and create a new
    directory called `vm`. It''s always a good idea to have separate directories for
    different projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are in the directory, you can create a new `main.tf` file with the
    content shown in the following code block. Use the comments added to see the purpose
    of each block. Considering the length of the code, we are showing the truncated
    version of the code block. You can find the `main.tf` code file in the `chapter
    8` folder of the GitHub repository of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the section for `azurerm_virtual_network`, you can see that instead
    of writing down the resource name, we gave a reference in the format `type.resource_configuration.parameter`.
    In this case, instead of writing down the resource group name, the reference was
    given as `azurerm_resource_group.rg.name`. Likewise, throughout the code, we have
    taken references to make the deployment easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting the deployment planning, we have to initialize the project
    using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, we will go with the execution plan. To create an execution
    plan and save it to a `vm-plan.plan` file, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get a lot of warnings; they can be safely ignored. Make sure that
    the code doesn''t show any errors. If the execution plan is successfully created,
    it will show the next step to be taken to execute the plan, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Successful creation of the execution plan](img/B15455_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: Displaying the execution plan'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As suggested in the output, we will execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the deployment will start and will show what resource it''s deploying,
    how much time has elapsed, and so on, as shown in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Details of the resources in deployment](img/B15455_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: Resource deployment details'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'At the end, Terraform will give a summary of the number of resources deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary of the deployed resources](img/B15455_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.16: Summary of the number of resources deployed'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There is also another command, which is the `show` command. This will show
    the complete state of the deployment, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking the complete state of the deployment](img/B15455_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.17: Displaying the complete state of the deployment'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have written a small piece of code that can deploy a VM in Azure. However,
    there are lots of arguments that can be added to the code by which advanced state
    configuration can be made. The complete list of arguments is available in the
    Terraform documentation ([https://www.terraform.io/docs/providers/azurerm/r/virtual_machine.html](https://www.terraform.io/docs/providers/azurerm/r/virtual_machine.html))
    and the Microsoft documentation ([https://docs.microsoft.com/en-us/azure/virtual-machines/linux/terraform-create-complete-vm](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/terraform-create-complete-vm)).
  prefs: []
  type: TYPE_NORMAL
- en: As these templates are a bit advanced, they will be using variables instead
    of values that are repeating. Nevertheless, once you get used to this, you'll
    understand how powerful Terraform is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can destroy the entire deployment or project by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will delete all the resources we mentioned in the `main.tf` file of the
    project. If you have multiple projects, you have to navigate to the project directory
    and execute the `destroy` command. On executing this command, you will be asked
    you to confirm the deletion; once you say `yes`, the resources will be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Destroying the entire deployment with terraform destroy command](img/B15455_08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.18: Deleting all the resources with the terraform destroy command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'And finally, you will get a summary, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary of the destroyed resources](img/B15455_08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.19: Summary of the destroyed resources'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now we are familiar with using Terraform on Azure and deploying a simple VM.
    Nowadays, Terraform is gaining a lot of popularity due to the usability and adoption
    of DevOps. Terraform has made the process of evaluating infrastructure and rebuilding
    it hassle-free.
  prefs: []
  type: TYPE_NORMAL
- en: Using PowerShell DSC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Bash, PowerShell is a shell with strong scripting possibilities. We might
    think that PowerShell is more of a scripting language and that can be used to
    carry out simple operations or to create resources as we have done so far. However,
    the capabilities of PowerShell are beyond that and extend all the way to automation
    and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: DSC is an important but little-known part of PowerShell that, instead of automating
    scripts in the PowerShell language, provides declarative orchestration in PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: If you compare it to Ansible, support for Linux is very limited. But it is very
    useful for common administration tasks, and missing features can be compensated
    for with PowerShell scripts. Microsoft is very focused on getting it on a par
    with Windows Server. When that happens, it will be replaced by PowerShell DSC
    Core, a move very similar to what they did before with PowerShell | PowerShell
    Core. This will be finished by the end of 2019.
  prefs: []
  type: TYPE_NORMAL
- en: Another important note is that, for some reason, the Python scripts that come
    with DSC don't workâ€”from time to time, you'll get a 401 error or even an undefined
    error. First, make sure that you have the latest version of the OMI server and
    DSC and just try again; sometimes, you have to try two or three times.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Automation DSC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way to use DSC is to use Azure Automation DSC. This way, you don't have
    to use a separate machine as a controller node. To be able to use Azure Automation
    DSC, you'll need an Azure Automation account.
  prefs: []
  type: TYPE_NORMAL
- en: '**Automation account**'
  prefs: []
  type: TYPE_NORMAL
- en: In the Azure portal, select **All Services** in the left-hand bar, navigate
    to **Management + governance**, and choose **Automation Accounts**. Create an
    automation account and make sure that you choose **Run As Account**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate again to **All Services**, **Management Tools**, and then select the
    **just-created account**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting the newly created automation account](img/B15455_08_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.20: Creating an automation account in the Azure portal'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, you can manage your nodes, configurations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this service is not exactly free. Process automation is priced
    per job execution minute, while configuration management is priced per managed
    node.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use this account, you'll need the registration URL and the corresponding
    key of your **Run As Account**. Both values are available under **Account** and
    **Key Settings**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, in PowerShell, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There is a VM extension available for Linux; this way, you can deploy VMs, including
    their configuration, fully orchestrated.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, visit [https://github.com/Azure/azure-linux-extensions/tree/master/DSC](https://github.com/Azure/azure-linux-extensions/tree/master/DSC)
    and [https://docs.microsoft.com/en-us/azure/virtual-machines/extensions/dsc-linux](https://docs.microsoft.com/en-us/azure/virtual-machines/extensions/dsc-linux).
  prefs: []
  type: TYPE_NORMAL
- en: Because we're going to play with Linux and DSC, we'll need a DSC module called
    `nx`. This module contains DSC resources for Linux. In the settings of your automation
    account, select `nx` and import the module.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PowerShell DSC on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To be able to use PowerShell DSC on Linux, you''ll need the Open Management
    Infrastructure Service. The supported versions of Linux distributions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 12.04 LTS, 14.04 LTS, and 16.04 LTS. Ubuntu 18.04 is not supported at
    the moment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RHEL/CentOS 6.5 and higher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: openSUSE 13.1 and higher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SUSE Linux Enterprise Server 11 SP3 and higher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The software is available for download at [https://github.com/Microsoft/omi](https://github.com/Microsoft/omi).
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation on Red Hatâ€“based distributions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For Ubuntu, you can download the `deb` file from the GitHub repository using
    `wget` and install it using `dpkg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Make sure you download the file that matches your SSL version. Your SSL version
    can be checked using the `openssl version` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installation, the service is automatically started. Check the status
    of the service by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To show product and version information, including the configuration directories
    used, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '![Product information with list of configuration directories used](img/B15455_08_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.21: Displaying the product and version information'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Creating a Desired State
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PowerShell DSC is not just a script or a code with parameters, like in Ansible.
    To start with PowerShell DSC, you'll need a configuration file that must be compiled
    into a **Management Object Format** (**MOF**) file.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, first things first. Let''s create a file, `example1.ps1`, with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Let's investigate this configuration. As stated, it's very similar to a function
    declaration. The configuration gets a label and is executed at the end of the
    script. The necessary modules are imported, the hostname of the VM is declared,
    and the configuration starts.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell DSC Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this configuration file, a resource called `nxPackage` is used. There are
    several built-in resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nxArchive`: Provides a mechanism to unpack archive (`.tar`, `.zip`) files
    at a specific path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nxEnvironment`: Manages environment variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nxFile`: Manages files and directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nxFileLine`: Manages lines in a Linux file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nxGroup`: Manages local Linux groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nxPackage`: Manages packages on Linux nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nxScript`: Runs scripts. Most of the time, this is used to switch temporarily
    to a more imperative orchestration approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nxService`: Manages Linux services (daemons).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nxUser`: Manages Linux users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also write your own resources in the MOF language, C#, Python, or C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: You can make use of the official documentation by visiting [https://docs.microsoft.com/en-us/powershell/dsc/lnxbuiltinresources](https://docs.microsoft.com/en-us/powershell/dsc/lnxbuiltinresources).
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script and execute it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As a result of the script, a directory is created with the same name as the
    configuration name. In it, there's a localhost file in MOF format. This is the
    language used to describe CIM classes (**CIM** stands for **Common Information
    Model**). CIM is an open standard for the management of a complete environment,
    including hardware.
  prefs: []
  type: TYPE_NORMAL
- en: We think that this description alone is enough to understand why Microsoft chooses
    this model and the corresponding language file for orchestration!
  prefs: []
  type: TYPE_NORMAL
- en: You can also upload the configuration file to Azure, under **DSC Configurations**.
    Press the **Compile** button to generate the MOF file in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Applying the Resources in Azure**'
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can apply the desired state locally, using scripts in `/opt/microsoft/dsc/Scripts`,
    which is, in our opinion, not as easy as it should be. And, because this chapter
    is about orchestration in Azure, we'll just move straight on to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Register the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the configuration again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The node is now visible in the **DSC Nodes** pane under your **Automation Account**
    settings. Now, you can link the uploaded and compiled DSC configuration. The configuration
    is applied!
  prefs: []
  type: TYPE_NORMAL
- en: Another way is to use the **Add Node** option and then select the DSC configuration.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, the primary use case scenario of PowerShell DSC is to write, manage,
    and compile DSC configurations, as well as import and assign these configurations
    to the target nodes in the cloud. Before using any tool, you need to understand
    the use case scenarios and how they fit into your environment to achieve the goal.
    So far, we have been configuring VMs; the next section is all about how to audit
    the settings inside the Linux VM using Azure Policy Guest Configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Policy Guest Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Policies are mainly used for the governance of resources. Azure Policy is a
    service in Azure by which you can create, manage, and assign policies in Azure.
    These policies can be used for auditing and for compliance. For example, if you
    are hosting a secured application in the East US location and you want to limit
    the deployments in East US only, Azure Policy can be used to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you don't want to deploy SQL servers in a subscription. In Azure Policy,
    you can create a policy and specify the allowed services, and only they can be
    deployed in that subscription. Please note, if you are assigning a policy to a
    subscription that already has resources, Azure Policy can only act on resources
    that are created post assignment. However, if any of the existing resources before
    assignment don't comply with the policy, they will be marked as "non-compliant"
    so an administrator can rectify them if necessary. Also, Azure Policy will only
    kick in during the validation phase of the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the built-in policies are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Allowed locations: Using this, you can enforce geo-compliance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allowed virtual machine SKUs: Defines a set of virtual machine SKUs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a tag to resources: Adds a tag to the resource. If no value is passed,
    it will take the default tag value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enforce a tag and its value: Used to enforce a required tag and its value to
    the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not allowed resource types: Prevents the deployment of selected resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allowed storage account SKUs: We discussed different SKUs that are available
    for storage accounts in the previous chapter, such as LRS, GRS, ZRS, and RA-GRS.
    You can specify the allowed SKUs, and the rest of them are denied from being deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allowed resource type: As we mentioned in the example, you can specify which
    resources are allowed in the subscription. For example, if you want only VMs and
    networking, you can accept the **Microsoft.Compute** and **Microsoft.Network**
    resource providers; all other providers are denied from deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have discussed how Azure Policy can be used to audit Azure resources,
    but it can be also used to audit settings inside a VM. Azure Policy accomplishes
    this task using the Guest Configuration extension and client. The extension and
    client work hand-in-hand to confirm the configuration of the guest OS, the presence
    of an application, its state, and also the environmental settings of the guest
    OS.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Policy Guest Configuration can only help you audit the guest VM. Applying
    configurations is not available at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Guest Configuration Extension for Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The guest policy configuration is done by the Guest Configuration extension
    and agent. The Guest Configuration agent on VMs is configured by using the Guest
    Configuration extension for Linux. As discussed earlier, they work hand-in-hand,
    allowing the user to run the in-guest policy on the VMs, which, in turn, helps
    the user to audit the policies on the VM. Chef InSpec ([https://www.inspec.io/docs/](https://www.inspec.io/docs/))
    is the In-Guest policy for Linux. Let's see how to deploy the extension to a VM
    and use the commands supported by the extension.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment to a Virtual Machine**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you need to have a Linux VM. We will be deploying the Guest Configuration
    extension onto the VM by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get a similar output to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying the Guest Configuration extension onto the VM](img/B15455_08_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.22: Deploying the Guest Configuration extension onto the VM'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Guest Configuration extension supports the `install`, `uninstall`, `enable`,
    `disable`, and `update` commands. To execute these commands; you need to switch
    the current working directory to `/var/lib/waagent/Microsoft.GuestConfiguration.ConfigurationForLinux-1.9.0/bin`.
    After that, you can chain the available commands with the `guest-configuration-shim`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Check whether the execute bit is enabled for the file. If not, use `chmod +x
    guest-configuration-shim` to set the execution permission.
  prefs: []
  type: TYPE_NORMAL
- en: The general syntax for executing any command is `./guest-configuration-shim
    <commandÂ name>`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to install Guest Configuration Extension, you can use
    the `install` command. When the extension is already installed, `enable` will
    be called, which will extract the Agent package, which installs and enables the
    agent.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `update` will update the Agent Service to the new agent, `disable`
    disables the agent, and, finally, `uninstall` will uninstall the agent.
  prefs: []
  type: TYPE_NORMAL
- en: The agent is downloaded to a path such as `/var/lib/waagent/Microsoft.GuestConfiguration.ConfigurationForLinux-<version>/GCAgent/DSC`,
    and the `agent` output is saved to the `stdout` and `stderr` files in this directory.
    If you encounter any issues, verify the contents of these files. Try to understand
    the error and then troubleshoot.
  prefs: []
  type: TYPE_NORMAL
- en: Logs are saved to `/var/log/azure/Microsoft.GuestConfiguration.ConfigurationForLinux`.
    You can use these to debug the issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, these are the supported OS versions for Azure Policy Guest Configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![OS versions for Azure Policy Guest Configuration](img/B15455_08_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.23: OS versions supported for Azure Policy Guest Configuration'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Azure Policy is written as a JSON manifest. As writing policies is not part
    of this book; you can refer the sample policy shared by Microsoft ([https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/governance/policy/samples/guest-configuration-applications-installed-linux.md](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/governance/policy/samples/guest-configuration-applications-installed-linux.md)).
    This sample is to audit if specific applications are installed inside Linux VMs.
  prefs: []
  type: TYPE_NORMAL
- en: If you investigate the sample, you will learn what the components are and how
    you can use the parameters in your context.
  prefs: []
  type: TYPE_NORMAL
- en: Other Solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another big player in the orchestration market is Puppet. Until very recently,
    the support for Azure in Puppet was very limited, but that is changing very quickly.
    The Puppet module, `puppetlabs/azure_arm`, is still somewhat in its infancy, but
    `puppetlabs/azure` provides you with everything you'll need. Both modules need
    the Azure CLI to work. The integration of the Azure CLI in their commercial Puppet
    Enterprise product is amazingly good. Azure has a VM extension that's available
    for VMs that will become Puppet nodes.
  prefs: []
  type: TYPE_NORMAL
- en: More information can be found at [https://puppet.com/products/managed-technology/microsoft-windows-azure](https://puppet.com/products/managed-technology/microsoft-windows-azure).
  prefs: []
  type: TYPE_NORMAL
- en: You can also go for the Chef software, which provides an automation and orchestration
    platform that has been around for a long time. Its development started in 2009!
    The user writes "recipes" that describe how Chef manages the "kitchen" using tools
    such as a knife. In Chef, much of its terminology comes from the kitchen. Chef
    integrates very well with Azure, especially if you use Chef Automate from Azure
    Marketplace. There is also a VM extension available. Chef is intended for big
    environments and has a relatively steep learning curve, but it's worth trying
    it at least.
  prefs: []
  type: TYPE_NORMAL
- en: More information can be found at [https://www.chef.io/partners/azure/](https://www.chef.io/partners/azure/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We started this chapter with a short introduction to orchestration, the reasons
    to use orchestration, and the different approaches: imperative versus declarative.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we covered the Ansible, Terraform, and PowerShell DSC platforms.
    Many details were covered about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to install the platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with resources at the OS level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible is by far the most complete solution, and maybe the one with the least
    steep learning curve. However, all of the solutions are very powerful and there
    are always ways around their limitations. And for all orchestration platforms,
    the future is promising in terms of even more features and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Linux VMs is not the only way to create a workload in Azure; you can
    also use container virtualization to deploy a platform for your application. In
    the next chapter, we're going to cover container technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this chapter, let's skip the normal questions. Fire up some VMs and choose
    the orchestration platform of your choice. Configure the network security groups
    to allow HTTP traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to configure the following resources with Ansible, Terraform, or PowerShell
    DSC:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a user and make it a member of the group `wheel` (RH-based distributions)
    or `sudo` (Ubuntu).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install an Apache web server, serve content from `/wwwdata`, secure it with
    AppArmor (Ubuntu) or SELinux (RHEL-based distributions), and serve a nice `index.html`
    page on this web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restrict SSH to your IP address. HTTP ports must be open to the whole world.
    You can use systemd methods by providing override files or FirewallD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy a new VM with the distribution and version of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `/etc/hosts` file using variables. If you use PowerShell DSC,
    you''ll need PowerShell as well for this task. For experts: use the hostnames
    and IP addresses of other machines in your resource group.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We really hope that you enjoyed this introduction to orchestration platforms.
    It was only a short introduction to make you curious to learn more. All the websites
    of the orchestration tools mentioned in this chapter are great resources and a
    pleasure to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some extra resources to mention include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learning PowerShell DSC â€“ Second Edition* by James Pogran.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible: We do think that *Learn Ansible* by Russ McKendrick, and other titles
    by the same author about Ansible, deserve a lot of credit. If you are too lazy
    to read the book, then you can refer to the Ansible documentation to start with.
    If you want some hands-on tutorials, you can use this GitHub repository: [https://github.com/leucos/ansible-tuto](https://github.com/leucos/ansible-tuto).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Terraform: **Terraform on Microsoft Azure - Part 1: Introduction** is a blog
    series written by Julien Corioland, who is a Senior Software Engineer at Microsoft.
    The blog includes a series of topics discussing Terraform on Azure. It''s worth
    reading and trying out the tasks. The blog is available at [https://blog.jcorioland.io/archives/2019/09/04/terraform-microsoft-azure-introduction.html](https://blog.jcorioland.io/archives/2019/09/04/terraform-microsoft-azure-introduction.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Chef* by Mayank Joshi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning Puppet* by Jussi Heinonen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
