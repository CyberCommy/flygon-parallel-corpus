- en: Part 1. Pythonic Classes via Special Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*[The _init_() Method](ch01.html "Chapter 1. The __init__() Method")*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Integrating Seamlessly with Python – Basic Special Methods](ch02.html "Chapter 2. Integrating
    Seamlessly with Python Basic Special Methods")*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Attribute Access, Properties, and Descriptors](ch03.html "Chapter 3. Attribute
    Access, Properties, and Descriptors")*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[The ABCs of Consistent Design](ch04.html "Chapter 4. The ABCs of Consistent
    Design")*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Using Callables and Contexts](ch05.html "Chapter 5. Using Callables and Contexts")*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Creating Containers and Collections](ch06.html "Chapter 6. Creating Containers
    and Collections")*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Creating Numbers](ch07.html "Chapter 7. Creating Numbers")*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Decorators and Mixins – Cross-cutting Aspects](ch08.html "Chapter 8. Decorators
    and Mixins – Cross-cutting Aspects")*'
  prefs: []
  type: TYPE_NORMAL
- en: Pythonic Classes via Special Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python exposes a great deal of its internal mechanisms through its special method
    names. The idea is pervasive throughout Python. A function such as `len()` will
    exploit the `__len__()` special method of a class.
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that we have a tidy, universal public interface (`len(x)`)
    that works on any kind of class. Python's polymorphism is based in part on the
    way any class can implement a `__len__()` method; objects of any such class will
    respond to the `len()` function.
  prefs: []
  type: TYPE_NORMAL
- en: When we define a class, we can (and should) include these special methods to
    improve the integration between our class and the rest of Python. [Part 1](pt01.html
    "Part 1. Pythonic Classes via Special Methods"), *Pythonic Classes via Special
    Methods*, will extend basic object-oriented programming techniques to create classes
    that are more *Pythonic*. Any class should be able to integrate seamlessly with
    other parts of Python. A close fit with other parts of Python will allow us to
    use many language and standard library features, and the clients of our packages
    and modules will be more confident about using them and more successful in maintaining
    and extending them.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, our classes can appear as extensions of Python. We want our classes
    to be so much like native Python classes that distinctions between language, standard
    library, and our application are minimized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python language uses a large number of special method names. They fall
    into the following few discrete categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attribute Access**: These special methods implement what we see as `object.attribute`
    in an expression, `object.attribute` on the left-hand side of an assignment, and
    `object.attribute` in a `del` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callables**: This special method implements what we see as a function that
    is applied to arguments, much like the built-in `len()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collections**: These special methods implement the numerous features of collections.
    This involves methods such as `sequence[index]`, `mapping[key]`, and `some_set|another_set`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numbers**: These special methods provide arithmetic operators and comparison
    operators. We can use these methods to expand the domain of numbers that Python
    works with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contexts**: There are two special methods we''ll use to implement a context
    manager that works with the `with` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterators**: There are special methods that define an iterator. This isn''t
    essential since generator functions handle this feature so elegantly. However,
    we''ll take a look at how we can design our own iterators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few of these special method names have been introduced in *Python 3 Object
    Oriented Programming*. We'll review these topics and introduce some additional
    special method names that fit into a kind of *basic* category.
  prefs: []
  type: TYPE_NORMAL
- en: Even within this basic category, we've got deeper topics to discover. We'll
    start with the truly basic special methods. There are some rather advanced special
    methods that are thrown into the basic category because they don't seem to belong
    anywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__()` method permits a great deal of latitude in providing the initial
    values for an object. In the case of an immutable object, this is the essential
    definition of the instance, and clarity becomes very important. In the first chapter,
    we'll review the numerous design alternatives for this method.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1. The __init__() Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `__init__()` method is profound for two reasons. Initialization is the first
    big step in an object's life; every object must be initialized properly to work
    properly. The second reason is that the argument values for `__init__()` can take
    on many forms.
  prefs: []
  type: TYPE_NORMAL
- en: Because there are so many ways to provide argument values to `__init__()`, there
    is a vast array of use cases for object creation. We take a look at several of
    them. We want to maximize clarity, so we need to define an initialization that
    properly characterizes the problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can get to the `__init__()` method, however, we need to take a look
    at the implicit class hierarchy in Python, glancing, briefly, at the class named
    `object`. This will set the stage for comparing default behavior with the different
    kinds of behavior we want from our own classes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we take a look at different forms of initialization for simple
    objects (for example, playing cards). After this, we can take a look at more complex
    objects, such as hands that involve collections and players that involve strategies
    and states.
  prefs: []
  type: TYPE_NORMAL
- en: The implicit superclass – object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each Python class definition has an implicit superclass: `object`. It''s a
    very simple class definition that does almost nothing. We can create instances
    of `object`, but we can''t do much with them because many of the special methods
    simply raise exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we define our own class, `object` is the superclass. The following is
    an example class definition that simply extends `object` with a new name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some interactions with our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can see that a class is an object of the class named `type` and that the
    base class for our new class is the class named `object`.
  prefs: []
  type: TYPE_NORMAL
- en: As we look at each method, we also take a look at the default behavior inherited
    from `object`. In some cases, the superclass special method behavior will be exactly
    what we want. In other cases, we'll need to override the special method.
  prefs: []
  type: TYPE_NORMAL
- en: The base class object __init__() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fundamental to the life cycle of an object are its creation, initialization,
    and destruction. We'll defer creation and destruction to a later chapter on more
    advanced special methods and only focus on initialization for now.
  prefs: []
  type: TYPE_NORMAL
- en: The superclass of all classes, `object`, has a default implementation of `__init__()`
    that amounts to `pass`. We aren't required to implement `__init__()`. If we don't
    implement it, then no instance variables will be created when the object is created.
    In some cases, this default behavior is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can always add attributes to an object that''s a subclass of the foundational
    base class, `object`. Consider the following class that requires two instance
    variables but doesn''t initialize them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Rectangle` class has a method that uses two attributes to return a value.
    The attributes have not been initialized anywhere. This is legal Python. It's
    a little strange to avoid specifically setting attributes, but it's valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an interaction with the `Rectangle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: While this is legal, it's a potential source of deep confusion, which is a good
    reason to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: However, this kind of design grants flexibility, so there could be times when
    we needn't set all of the attributes in the `__init__()` method. We walk a fine
    line here. An optional attribute is a kind of subclass that's not formally declared
    as a proper subclass. We're creating polymorphism in a way that could lead to
    confusing and inappropriate use of convoluted `if` statements. While uninitialized
    attributes may be useful, they could be the symptom of a bad design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Zen of Python* poem (`import this`) offers the following advice:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Explicit is better than implicit."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An `__init__()` method should make the instance variables explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Pretty Poor Polymorphism**'
  prefs: []
  type: TYPE_NORMAL
- en: There's a fine line between flexibility and foolishness.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may have stepped over the edge off *flexible* into *foolish* as soon as
    we feel the need to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It's time to reconsider the API and add a common method or attribute. Refactoring
    is better than adding `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing __init__() in a superclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We initialize an object by implementing the `__init__()` method. When an object
    is created, Python first creates an empty object and then calls the `__init__()`
    method for that new object. This method function generally creates the object's
    instance variables and performs any other one-time processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some example definitions of a `Card` class hierarchy. We''ll
    define a `Card` superclass and three subclasses that are variations of the basic
    theme of `Card`. We have two instance variables that have been set directly from
    argument values and two variables that have been calculated by an initialization
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we factored the `__init__()` method into the superclass so
    that a common initialization in the superclass, `Card`, applies to all the three
    subclasses `NumberCard`, `AceCard`, and `FaceCard`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows a common polymorphic design. Each subclass provides a unique implementation
    of the `_points()` method. All the subclasses have identical signatures: they
    have the same methods and attributes. Objects of these three subclasses can be
    used interchangeably in an application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we simply use characters for suits, we will be able to create `Card` instances
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We enumerated the class, rank, and suit for several cards in a list. In the
    long run, we need a much smarter factory function to build `Card` instances; enumerating
    all 52 cards this way is tedious and error prone. Before we get to the factory
    functions, we take a look at a number of other issues.
  prefs: []
  type: TYPE_NORMAL
- en: Using __init__() to create manifest constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can define a class for the suits of our cards. In blackjack, the suits don't
    matter, and a simple character string could work.
  prefs: []
  type: TYPE_NORMAL
- en: We use suit construction as an example of creating constant objects. In many
    cases, our application will have a small domain of objects that can be defined
    by a collection of constants. A small domain of static objects may be part of
    implementing a **Strategy** or **State** design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we may have a pool of constant objects created in an initialization
    or configuration file, or we might create constant objects based on command-line
    parameters. We'll return to the details of initialization design and startup design
    in [Chapter 16](ch16.html "Chapter 16. Coping With the Command Line"), *Coping
    with the Command Line*.
  prefs: []
  type: TYPE_NORMAL
- en: Python has no simple formal mechanism for defining an object as immutable. We'll
    look at techniques to assure immutability in [Chapter 3](ch03.html "Chapter 3. Attribute
    Access, Properties, and Descriptors"), *Attribute Access, Properties, and Descriptors*.
    In this example, it might make sense for the attributes of a suit to be immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class that we''ll use to build four manifest constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the domain of "constants" built around this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create `cards` as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For an example this small, this method isn't a huge improvement over single
    character suit codes. In more complex cases, there may be a short list of Strategy
    or State objects that can be created like this. This can make the Strategy or
    State design patterns work efficiently by reusing objects from a small, static
    pool of constants.
  prefs: []
  type: TYPE_NORMAL
- en: We do have to acknowledge that in Python these objects aren't technically constant;
    they are mutable. There may be some benefit in doing the extra coding to make
    these objects truly immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The irrelevance of immutability**'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability can become an attractive nuisance. It's sometimes justified by
    the mythical "malicious programmer" who modifies the constant value in their application.
    As a design consideration, this is silly. This mythical, malicious programmer
    can't be stopped this way. There's no easy way to "idiot-proof" code in Python.
    The malicious programmer has access to the source and can tweak it just as easily
    as they can write code to modify a constant.
  prefs: []
  type: TYPE_NORMAL
- en: It's better not to struggle too long to define the classes of immutable objects.
    In [Chapter 3](ch03.html "Chapter 3. Attribute Access, Properties, and Descriptors"),
    *Attribute Access, Properties, and Descriptors*, we'll show ways to implement
    immutability that provides suitable diagnostic information for a buggy program.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging __init__() via a factory function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can build a complete deck of cards via a factory function. This beats enumerating
    all 52 cards. In Python, we have two common approaches to factories as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We define a function that creates objects of the required classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define a class that has methods for creating objects. This is the full factory
    design pattern, as described in books on design patterns. In languages such as
    Java, a factory class hierarchy is required because the language doesn't support
    standalone functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Python, a class isn't *required*. It's merely a good idea when there are
    related factories that are complex. One of the strengths of Python is that we're
    not forced to use a class hierarchy when a simple function might do just as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While this is a book about object-oriented programming, a function really is
    fine. It's common, idiomatic Python.
  prefs: []
  type: TYPE_NORMAL
- en: We can always rewrite a function to be a proper callable object if the need
    arises. From a callable object, we can refactor it into a class hierarchy for
    our factories. We'll look at callable objects in [Chapter 5](ch05.html "Chapter 5. Using
    Callables and Contexts"), *Using Callables and Contexts*.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of class definitions in general is to achieve code reuse via inheritance.
    The function of a factory class is to wrap some target class hierarchy and the
    complexities of object construction. If we have a factory class, we can add subclasses
    to the factory class when extending the target class hierarchy. This gives us
    polymorphic factory classes; the different factory class definitions have the
    same method signatures and can be used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: This class-level polymorphism can be very helpful with statically compiled languages
    such as Java or C++. The compiler can resolve the details of the class and methods
    when generating code.
  prefs: []
  type: TYPE_NORMAL
- en: If the alternative factory definitions don't actually reuse any code, then a
    class hierarchy won't be helpful in Python. We can simply use functions that have
    the same signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a factory function for our various `Card` subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function builds a `Card` class from a numeric `rank` number and a `suit`
    object. We can now build cards more simply. We've encapsulated the construction
    issues into a single factory function, allowing an application to be built without
    knowing precisely how the class hierarchy and polymorphic design works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how we can build a deck with this factory function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This enumerates all the ranks and suits to create a complete deck of 52 cards.
  prefs: []
  type: TYPE_NORMAL
- en: Faulty factory design and the vague else clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the structure of the `if` statement in the `card()` function. We did not
    use a catch-all `else` clause to do any processing; we merely raised an exception.
    The use of a catch-all `else` clause is subject to a tiny scrap of debate.
  prefs: []
  type: TYPE_NORMAL
- en: On the one hand, it can be argued that the condition that belongs on an `else`
    clause should never be left unstated because it may hide subtle design errors.
    On the other hand, some `else` clause conditions are truly obvious.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to avoid the vague `else` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following variant on this factory function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is what will happen when we try to build a deck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Does it work? What if the `if` conditions were more complex?
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers can understand this `if` statement at a glance. Others will
    struggle to determine if all of the cases are properly exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: For advanced Python programming, we should not leave it to the reader to deduce
    the conditions that apply to an `else` clause. Either the condition should be
    obvious to the newest of n00bz, or it should be explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**When to use catch-all else**'
  prefs: []
  type: TYPE_NORMAL
- en: Rarely. Use it only when the condition is obvious. When in doubt, be explicit
    and use `else` to raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid the vague `else` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity and consistency using elif sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our factory function, `card()`, is a mixture of two very common factory design
    patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: An `if-elif` sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the sake of simplicity, it's better to focus on just one of these techniques
    rather than on both.
  prefs: []
  type: TYPE_NORMAL
- en: We can always replace a mapping with `elif` conditions. (Yes, always. The reverse
    is not true though; transforming `elif` conditions to a mapping can be challenging.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a `Card` factory without the mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We rewrote the `card()` factory function. The mapping was transformed into additional
    `elif` clauses. This function has the advantage that it is more consistent than
    the previous version.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity using mapping and class objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases, we can use a mapping instead of a chain of `elif` conditions.
    It's possible to find conditions that are so complex that a chain of `elif` conditions
    is the only sensible way to express them. For simple cases, however, a mapping
    often works better and can be easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: Since `class` is a first-class object, we can easily map from the `rank` parameter
    to the class that must be constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a `Card` factory that uses only a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We've mapped the `rank` object to a class. Then, we applied the class to the
    `rank` and `suit` values to build the final `Card` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a `defaultdict` class as well. However, it''s no simpler for a trivial
    static mapping. It looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that the *default* of a `defaultdict` class must be a function of zero
    arguments. We've used a `lambda` construct to create the necessary function wrapper
    around a constant. This function, however, has a serious deficiency. It lacks
    the translation from `1` to `A` and `13` to `K` that we had in previous versions.
    When we try to add that feature, we run into a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to change the mapping to provide both a `Card` subclass as well as
    the string version of the `rank` object. What can we do for this two-part mapping?
    There are four common solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: We can do two parallel mappings. We don't suggest this, but we'll show it to
    emphasize what's undesirable about it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can map to a two-tuple. This also has some disadvantages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can map to a `partial()` function. The `partial()` function is a feature
    of the `functools` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also consider modifying our class definition to fit more readily with
    this kind of mapping. We'll look at this alternative in the next section on pushing
    `__init__()` into the subclass definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at each of these with a concrete example.
  prefs: []
  type: TYPE_NORMAL
- en: Two parallel mappings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following is the essence of the two parallel mappings solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is not desirable. It involves a repetition of the sequence of the mapping
    keys `1`, `11`, `12`, and `13`. Repetition is bad because parallel structures
    never seem to stay that way after the software has been updated.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Don''t use parallel structures**'
  prefs: []
  type: TYPE_NORMAL
- en: Two parallel structures should be replaced with tuples or some kind of proper
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping to a tuple of values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following is the essence of how mapping is done to a two-tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is reasonably pleasant. It's not much code to sort out the special cases
    of playing cards. We will see how it could be modified or expanded if we need
    to alter the `Card` class hierarchy to add additional subclasses of `Card`.
  prefs: []
  type: TYPE_NORMAL
- en: It does feel odd to map a `rank` value to a `class` object and just one of the
    two arguments to that class initializer. It seems more sensible to map the rank
    to a simple class or function object without the clutter of providing some (but
    not all) of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The partial function solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rather than map to a two-tuple of function and one of the arguments, we can
    create a `partial()` function. This is a function that already has some (but not
    all) of its arguments provided. We'll use the `partial()` function from the `functools`
    library to create a partial of a class with the `rank` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a mapping from `rank` to a `partial()` function that can be
    used for object construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The mapping associates a `rank` object with a `partial()` function that is assigned
    to `part_class`. This `partial()` function can then be applied to the `suit` object
    to create the final object. The use of `partial()` functions is a common technique
    for functional programming. It works in this specific situation where we have
    a function instead of an object method.
  prefs: []
  type: TYPE_NORMAL
- en: In general, however, `partial()` functions aren't helpful for most object-oriented
    programming. Rather than create `partial()` functions, we can simply update the
    methods of a class to accept the arguments in different combinations. A `partial()`
    function is similar to creating a fluent interface for object construction.
  prefs: []
  type: TYPE_NORMAL
- en: Fluent APIs for factories
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some cases, we design a class where there's a defined order for method usage.
    Evaluating methods sequentially is very much like creating a `partial()` function.
  prefs: []
  type: TYPE_NORMAL
- en: We might have `x.a().b()` in an object notation. We can think of it as ![Fluent
    APIs for factories](graphics/0971OS_01_01.jpg). The `x.a()` function is a kind
    of `partial()` function that's waiting for `b()`. We can think of this as if it
    were ![Fluent APIs for factories](graphics/0971OS_01_02.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is that Python offers us two alternatives for managing a state.
    We can either update an object or create a `partial()` function that is (in a
    way) stateful. Because of this equivalence, we can rewrite a `partial()` function
    into a fluent factory object. We make the setting of the `rank` object a fluent
    method that returns `self`. Setting the `suit` object will actually create the
    `Card` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a fluent `Card` factory class with two method functions that
    must be used in a specific order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `rank()` method updates the state of the constructor, and the `suit()` method
    actually creates the final `Card` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This factory class can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a factory instance, then we use that instance to create `Card`
    instances. This doesn't materially change how `__init__()` itself works in the
    `Card` class hierarchy. It does, however, change the way that our client application
    creates objects.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing __init__() in each subclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we look at the factory functions for creating `Card` objects, we see some
    alternative designs for the `Card` class. We might want to refactor the conversion
    of the rank number so that it is the responsibility of the `Card` class itself.
    This pushes the initialization down into each subclass.
  prefs: []
  type: TYPE_NORMAL
- en: This often requires some common initialization of a superclass as well as subclass-specific
    initialization. We need to follow the **Don't Repeat Yourself** (**DRY**) principle
    to keep the code from getting cloned into each of the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example where the initialization is the responsibility
    of each subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is still clearly polymorphic. The lack of a truly common initialization,
    however, leads to some unpleasant redundancy. What's unpleasant here is the repeated
    initialization of `suit`. This must be *pulled up* into the superclass. We can
    have each `__init__()` subclass make an explicit reference to the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'This version of the `Card` class has an initializer at the superclass level
    that is used by each subclass, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve provided `__init__()` at both the subclass and superclass level. This
    has the small advantage that it simplifies our factory function, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Simplifying a factory function should not be our focus. We can see from this
    variation that we've created rather complex `__init__()` methods for a relatively
    minor improvement in a factory function. This is a common trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Factory functions encapsulate complexity**'
  prefs: []
  type: TYPE_NORMAL
- en: There's a trade-off that occurs between sophisticated `__init__()` methods and
    factory functions. It's often better to stick with more direct but less programmer-friendly
    `__init__()` methods and push the complexity into factory functions. A factory
    function works well if you wish to wrap and encapsulate the construction complexities.
  prefs: []
  type: TYPE_NORMAL
- en: Simple composite objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A composite object can also be called a **container**. We''ll look at a simple
    composite object: a deck of individual cards. This is a basic collection. Indeed,
    it''s so basic that we can, without too much struggle, use a simple `list` as
    a deck.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before designing a new class, we need to ask this question: is using a simple
    `list` appropriate?'
  prefs: []
  type: TYPE_NORMAL
- en: We can use `random.shuffle()` to shuffle the deck and `deck.pop()` to deal cards
    into a player's `Hand`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some programmers rush to define new classes as if using a built-in class violates
    some object-oriented design principle. Avoiding a new class leaves us with something
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If it's that simple, why write a new class?
  prefs: []
  type: TYPE_NORMAL
- en: The answer isn't perfectly clear. One advantage is that a class offer a simplified,
    implementation-free interface to the object. As we noted previously, when discussing
    factories, a class isn't a requirement in Python.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the deck only has two simple use cases and a class definition
    doesn't seem to simplify things very much. It does have the advantage of concealing
    the implementation's details. But the details are so trivial that exposing them
    seems to have little cost. We're focused primarily on the `__init__()` method
    in this chapter, so we'll look at some designs to create and initialize a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To design a collection of objects, we have the following three general design
    strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wrap**: This design pattern is an existing collection definition. This might
    be an example of the **Facade** design pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extend**: This design pattern is an existing collection class. This is ordinary
    subclass definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invent**: This is designed from scratch. We''ll look at this in [Chapter
    6](ch06.html "Chapter 6. Creating Containers and Collections"), *Creating Containers
    and Collections*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three concepts are central to object-oriented design. We must always make
    this choice when designing a class.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a collection class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a wrapper design that contains an internal collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We've defined `Deck` so that the internal collection is a `list` object. The
    `pop()` method of `Deck` simply delegates to the wrapped `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then create a `Hand` instance with the following kind of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Generally, a Facade design pattern or wrapper class contains methods that are
    simply delegated to the underlying implementation class. This delegation can become
    wordy. For a sophisticated collection, we may wind up delegating a large number
    of methods to the wrapped object.
  prefs: []
  type: TYPE_NORMAL
- en: Extending a collection class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative to wrapping is to extend a built-in class. By doing this, we
    have the advantage of not having to reimplement the `pop()` method; we can simply
    inherit it.
  prefs: []
  type: TYPE_NORMAL
- en: The `pop()` method has the advantage that it creates a class without writing
    too much code. In this example, extending the `list` class has the disadvantage
    that this provides many more functions than we truly need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a definition of `Deck` that extends the built-in `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, our methods will have to explicitly use the superclass methods
    in order to have proper class behavior. We'll see other examples of this in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: We leverage the superclass's `__init__()` method to populate our `list` object
    with an initial single deck of cards. Then we shuffle the cards. The `pop()` method
    is simply inherited from `list` and works perfectly. Other methods inherited from
    the `list` also work.
  prefs: []
  type: TYPE_NORMAL
- en: More requirements and another design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a casino, the cards are often dealt from a shoe that has half a dozen decks
    of cards all mingled together. This consideration makes it necessary for us to
    build our own version of `Deck` and not simply use an unadorned `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, a casino shoe is not dealt fully. Instead, a marker card is inserted.
    Because of the marker, some cards are effectively set aside and not used for play.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is `Deck` definition that contains multiple sets of 52-card decks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the `__init__()` superclass to build an empty collection. Then,
    we used `self.extend()` to append multiple 52-card decks to the shoe. We could
    also use `super().extend()` since we did not provide an overriding implementation
    in this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also carry out the entire task via `super().__init__()` using a more
    deeply nested generator expression, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This class provides us with a collection of `Card` instances that we can use
    to emulate casino blackjack as dealt from a shoe.
  prefs: []
  type: TYPE_NORMAL
- en: There's a peculiar ritual in a casino where they reveal the burned card. If
    we're going to design a card-counting player strategy, we might want to emulate
    this nuance too.
  prefs: []
  type: TYPE_NORMAL
- en: Complex composite objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is an example of a blackjack `Hand` description that might be
    suitable for emulating play strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have an instance variable `self.dealer_card` based on a
    parameter of the `__init__()` method. The `self.cards` instance variable, however,
    is not based on any parameter. This kind of initialization creates an empty collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an instance of `Hand`, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This has the disadvantage that a long-winded sequence of statements is used
    to build an instance of a `Hand` object. It can become difficult to serialize
    the `Hand` object and rebuild it with an initialization such as this one. Even
    if we were to create an explicit `append()` method in this class, it would still
    take multiple steps to initialize the collection.
  prefs: []
  type: TYPE_NORMAL
- en: We could try to create a fluent interface, but that doesn't really simplify
    things; it's merely a change in the syntax of the way that a `Hand` object is
    built. A fluent interface still leads to multiple method evaluations. When we
    take a look at the serialization of objects in [Part 2](pt02.html "Part 2. Persistence
    and Serialization"), *Persistence and Serialization* we'd like an interface that's
    a single class-level function, ideally the class constructor. We'll look at this
    in depth in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML,
    Pickle, CSV, and XML"), *Serializing and Saving - JSON, YAML, Pickle, CSV, and
    XML*.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that the hard total and soft total method functions shown here don't
    fully follow the rules of blackjack. We return to this issue in [Chapter 2](ch02.html
    "Chapter 2. Integrating Seamlessly with Python Basic Special Methods"), *Integrating
    Seamlessly with Python – Basic Special Methods*.
  prefs: []
  type: TYPE_NORMAL
- en: Complete composite object initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideally, the `__init__()` initializer method will create a complete instance
    of an object. This is a bit more complex when creating a complete instance of
    a container that contains an internal collection of other objects. It'll be helpful
    if we can build this composite in a single step.
  prefs: []
  type: TYPE_NORMAL
- en: It's common to have both a method to incrementally accrete items as well as
    the initializer special method that can load all of the items in one step.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might have a class such as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This initialization sets all of the instance variables in a single step. The
    other methods are simply copies of the previous class definition. We can build
    a `Hand2` object in two ways. This first example loads one card at a time into
    a `Hand2` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This second example uses the `*cards` parameter to load a sequence of `Cards`
    class in a single step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For unit testing, it's often helpful to build a composite object in a single
    statement in this way. More importantly, some of the serialization techniques
    from the next part will benefit from a way of building a composite object in a
    single, simple evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless objects without __init__()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is an example of a degenerate class that doesn''t need an `__init__()`
    method. It''s a common design pattern for **Strategy** objects. A Strategy object
    is plugged into a Master object to implement an algorithm or decision. It may
    rely on data in the master object; the Strategy object may not have any data of
    its own. We often design strategy classes to follow the **Flyweight** design pattern:
    we avoid internal storage in the `Strategy` object. All values are provided to
    `Strategy` as method argument values. The `Strategy` object itself can be stateless.
    It''s more a collection of method functions than anything else.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''re providing the game play decisions for a `Player` instance.
    The following is an example of a (dumb) strategy to pick cards and decline the
    other bets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Each method requires the current `Hand` as an argument value. The decisions
    are based on the available information; that is, on the dealer's cards and the
    player's cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build a single instance of this strategy for use by various `Player`
    instances as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can imagine creating a family of related strategy classes, each one using
    different rules for the various decisions a player is offered in blackjack.
  prefs: []
  type: TYPE_NORMAL
- en: Some additional class definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As noted previously, a player has two strategies: one for betting and one for
    playing their hand. Each `Player` instance has a sequence of interactions with
    a larger simulation engine. We''ll call the larger engine the `Table` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Table` class requires the following sequence of events by the `Player`
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: The player must place an initial bet based on the betting strategy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player will then receive a hand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the hand is splittable, the player must decide to split or not based on the
    play strategy. This can create additional `Hand` instances. In some casinos, the
    additional hands are also splittable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each `Hand` instance, the player must decide to hit, double, or stand based
    on the play strategy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player will then receive payouts, and they must update their betting strategy
    based on their wins and losses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this, we can see that the `Table` class has a number of API methods to
    receive a bet, create a `Hand` object, offer a split, resolve each hand, and pay
    off the bets. This is a large object that tracks the state of play with a collection
    of `Players`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the beginning of a `Table` class that handles the bets and
    cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `Table` class is used by the `Player` class to accept a bet, create a `Hand`
    object, and determine if theinsurance bet is in play for this hand. Additional
    methods can be used by the `Player` class to get cards and determine the payout.
  prefs: []
  type: TYPE_NORMAL
- en: The exception handling shown in `get_hand()` is not a precise model of casino
    play. This may lead to minor statistical inaccuracies. A more accurate simulation
    requires developing a deck that reshuffles itself when empty instead of raising
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: In order to interact properly and simulate realistic play, the `Player` class
    needs a betting strategy. The betting strategy is a stateful object that determines
    the level of the initial bet. The various betting strategies generally change
    the bet based on whether the game was a win or a loss.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we'd like to have a family of betting strategy objects. Python has
    a module with decorators that allows us to create an abstract superclass. An informal
    approach to creating Strategy objects is to raise an exception for methods that
    *must* be implemented by a subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve defined an abstract superclass as well as a specific subclass as follows
    to define a flat betting strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The superclass defines the methods with handy default values. The basic `bet()`
    method in the abstract superclass raises an exception. The subclass must override
    the `bet()` method. The other methods can be left to provide the default values.
    Given the game strategy in the previous section plus the betting strategy here,
    we can look at more complex `__init__()` techniques surrounding the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make use of the `abc` module to formalize an abstract superclass definition.
    It would look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This has the advantage that it makes the creation of an instance of `BettingStrategy2,`
    or any subclass that failed to implement `bet(),` impossible. If we try to create
    an instance of this class with an unimplemented abstract method, it will raise
    an exception instead of creating an object.
  prefs: []
  type: TYPE_NORMAL
- en: And yes, the abstract method has an implementation. It can be accessed via `super().bet()`.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-strategy __init__()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may have objects that are created from a variety of sources. For example,
    we might need to clone an object as part of creating a memento, or freeze an object
    so that it can be used as the key of a dictionary or placed into a set; this is
    the idea behind the `set` and `frozenset` built-in classes.
  prefs: []
  type: TYPE_NORMAL
- en: There are several overall design patterns that have multiple ways to build an
    object. One design pattern is complex `__init__()` that is called multi-strategy
    initialization. Also, there are multiple class-level (static) constructor methods.
  prefs: []
  type: TYPE_NORMAL
- en: These are incompatible approaches. They have radically different interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Avoid clone methods**'
  prefs: []
  type: TYPE_NORMAL
- en: A clone method that unnecessarily duplicates an object is rarely needed in Python.
    Using cloning may be an indication of failure to understand the object-oriented
    design principles available in Python.
  prefs: []
  type: TYPE_NORMAL
- en: A clone method encapsulates the knowledge of object creation in the wrong place.
    The source object that's being cloned cannot know about the structure of the target
    object that was built from the clone. However, the reverse (targets having knowledge
    about a source) is acceptable if the source provides a reasonably well-encapsulated
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The examples we have shown here are effectively cloning because they're so simple.
    We'll expand on them in the next chapter. However, to show ways in which these
    fundamental techniques are used to do more than trivial cloning, we'll look at
    turning a mutable `Hand` object into a frozen, immutable `Hand` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a `Hand` object that can be built in either
    of the two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, a `Hand3` instance has been built from an existing `Hand3`
    object. In the second case, a `Hand3` object has been built from individual `Card`
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'This parallels the way a `frozenset` object can be built from individual items
    or an existing `set` object. We look more at creating immutable objects in the
    next chapter. Creating a new `Hand` from an existing `Hand` allows us to create
    a memento of a `Hand` object using a construct like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We saved the `Hand` object in the `memento` variable. This can be used to compare
    the final with the original hand that was dealt, or we can *freeze* it for use
    in a set or mapping too.
  prefs: []
  type: TYPE_NORMAL
- en: More complex initialization alternatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to write a multi-strategy initialization, we're often forced to give
    up on specific named parameters. This design has the advantage that it is flexible,
    but the disadvantage that it has opaque, meaningless parameter names. It requires
    a great deal of documentation explaining the variant use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can expand our initialization to also split a `Hand` object. The result
    of splitting a `Hand` object is simply another constructor. The following code
    snippet shows how the splitting of a `Hand` object might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This design involves getting extra cards to build proper, split hands. When
    we create one `Hand4` object from another `Hand4` object, we provide a split keyword
    argument that uses the index of the `Card` class from the original `Hand4` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we''d use this to split a hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We created an initial `h` instance of `Hand4` and split it into two other `Hand4`
    instances, `s1` and `s2`, and dealt an additional `Card` class into each. The
    rules of blackjack only allow this when the initial hand has two cards of equal
    rank.
  prefs: []
  type: TYPE_NORMAL
- en: While this `__init__()` method is rather complex, it has the advantage that
    it can parallel the way in which `fronzenset` is created from an existing set.
    The disadvantage is that it needs a large docstring to explain all these variations.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing static methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we have multiple ways to create an object, it's sometimes more clear to
    use static methods to create and return instances rather than complex `__init__()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to use class methods as alternate initializers, but there's
    little tangible advantage to receiving the class as an argument to the method.
    In the case of freezing or splitting a `Hand` object, we might want to create
    two new static methods to freeze or split a `Hand` object. Using static methods
    as surrogate constructors is a tiny syntax change in construction, but it has
    huge advantages when organizing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a version of `Hand` with static methods that can be used to
    build new instances of `Hand` from an existing `Hand` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: One method freezes or creates a memento version. The other method splits a `Hand5`
    instance to create two new child instances of `Hand5`.
  prefs: []
  type: TYPE_NORMAL
- en: This is considerably more readable and preserves the use of the parameter names
    to explain the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can split a `Hand5` instance with this
    version of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We created an initial `h` instance of `Hand5`, split it into two other hands,
    `s1` and `s2`, and dealt an additional `Card` class into each. The `split()` static
    method is much simpler than the equivalent functionality implemented via `__init__()`.
    However, it doesn't follow the pattern of creating a `fronzenset` object from
    an existing `set` object.
  prefs: []
  type: TYPE_NORMAL
- en: Yet more __init__() techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll take a look at a few other, more advanced `__init__()` techniques. These
    aren't quite so universally useful as the techniques in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a definition for the `Player` class that uses two strategy
    objects and a `table` object. This shows an unpleasant-looking `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__()` method for `Player` seems to do little more than bookkeeping.
    We're simply transferring named parameters to same-named instance variables. If
    we have numerous parameters, simply transferring the parameters into the internal
    variables will amount to a lot of redundant-looking code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this `Player` class (and related objects) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can provide a very short and very flexible initialization by simply transferring
    keyword argument values directly into the internal instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a way to build a `Player` class using keyword argument values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This sacrifices a great deal of readability for succinctness. It crosses over
    into a realm of potential obscurity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `__init__()` method is reduced to one line, it removes a certain
    level of "wordiness" from the method. This wordiness, however, is transferred
    to each individual object constructor expression. We have to add the keywords
    to the object initialization expression since we''re no longer using positional
    parameters, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Why do this?
  prefs: []
  type: TYPE_NORMAL
- en: It does have a *potential* advantage. A class defined like this is quite open
    to extension. We can, with only a few specific worries, supply additional keyword
    parameters to a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the expected use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a bonus use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We've added a `log_name` attribute without touching the class definition. This
    can be used, perhaps, as part of a larger statistical analysis. The `Player2.log_name`
    attribute can be used to annotate logs or other collected data.
  prefs: []
  type: TYPE_NORMAL
- en: We are limited in what we can add; we can only add parameters that fail to conflict
    with the names already in use within the class. Some knowledge of the class implementation
    is required to create a subclass that doesn't abuse the set of keywords already
    in use. Since the `**kw` parameter provides little information, we need to read
    carefully. In most cases, we'd rather trust the class to work than review the
    implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of keyword-based initialization can be done in a superclass definition
    to make it slightly simpler for the superclass to implement subclasses. We can
    avoiding writing an additional `__init__()` method in each subclass when the unique
    feature of the subclass involves simple new instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of this is that we have obscure instance variables that aren't
    formally documented via a subclass definition. If it's only one small variable,
    an entire subclass might be too much programming overhead to add a single variable
    to a class. However, one small variable often leads to a second and a third. Before
    long, we'll realize that a subclass would have been smarter than an extremely
    flexible superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can (and should) hybridize this with a mixed positional and keyword implementation
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This is more sensible than a completely open definition. We've made the required
    parameters positional parameters. We've left any nonrequired parameters as keywords.
    This clarifies the use of any extra keyword arguments given to the `__init__()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of flexible, keyword-based initialization depends on whether we have
    relatively transparent class definitions. This openness to change requires some
    care to avoid debugging name clashes because the keyword parameter names are open-ended.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization with type validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type validation is rarely a sensible requirement. In a way, this might be a
    failure to fully understand Python. The notional objective is to validate that
    all of the arguments are of a *proper* type. The issue with trying to do this
    is that the definition of *proper* is often far too narrow to be truly useful.
  prefs: []
  type: TYPE_NORMAL
- en: This is different from validating that objects meet other criteria. Numeric
    range checking, for example, may be essential to prevent infinite loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'What can create problems is trying to do something like the following in an
    `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `isinstance()` method checks circumvent Python's normal **duck typing**.
  prefs: []
  type: TYPE_NORMAL
- en: We write a casino game simulation in order to experiment with endless variations
    on `GameStrategy`. These are so simple (merely four methods) that there's little
    real benefit from inheritance from the superclass. We could define the classes
    independently, lacking an overall superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The initialization error-checking shown in this example would force us to create
    subclasses merely to pass the error check. No usable code is inherited from the
    abstract superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the biggest duck typing issues surrounds numeric types. Different numeric
    types will work in different contexts. Attempts to validate the types of arguments
    may prevent a perfectly sensible numeric type from working properly. When attempting
    validation, we have the following two choices in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: We write validation so that a relatively narrow collection of types is permitted,
    and someday the code will break because a new type that would have worked sensibly
    is prohibited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We eschew validation so that a broad collection of types is permitted, and someday
    the code will break because a type that would not work sensibly was used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that both are essentially the same. The code could perhaps break someday.
    It either breaks because a type was prevented from being used even though it's
    sensible or a type that's not really sensible was used.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Just allow it**'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, it's considered better Python style to simply permit any type of
    data to be used.
  prefs: []
  type: TYPE_NORMAL
- en: We'll return to this in [Chapter 4](ch04.html "Chapter 4. The ABCs of Consistent
    Design"), *The ABCs of Consistent Design*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is this: why restrict potential future use cases?'
  prefs: []
  type: TYPE_NORMAL
- en: And the usual answer is that there's no good reason to restrict potential future
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than prevent a sensible, but possibly unforeseen, use case, we can provide
    documentation, testing, and debug logging to help other programmers understand
    any restrictions on the types that can be processed. We have to provide the documentation,
    logging, and test cases anyway, so there's minimal additional work involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example docstring that provides the expectations of the
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The programmer using this class has been warned about what the type restrictions
    are. The use of other types is permitted. If the type isn't compatible with the
    expected type, then things will break. Ideally, we'll use too like `unittest`
    or `doctest` to uncover the breakage.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization, encapsulation, and privacy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The general Python policy regarding privacy can be summed up as follows: *we''re
    all adults here*.'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design makes an explicit distinction between interface and implementation.
    This is a consequence of the idea of encapsulation. A class encapsulates a data
    structure, an algorithm, an external interface, or something meaningful. The idea
    is to have the capsule separate the class-based interface from the implementation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: However, no programming language reflects every design nuance. Python, typically,
    doesn't implement all design considerations as explicit code.
  prefs: []
  type: TYPE_NORMAL
- en: One aspect of a class design that is not fully carried into code is the distinction
    between the *private* (implementation) and *public* (interface) methods or attributes
    of an object. The notion of privacy in languages that support it (C++ or Java
    are two examples) is already quite complex. These languages include settings such
    as private, protected, and public as well as "not specified", which is a kind
    of semiprivate. The private keyword is often used incorrectly, making subclass
    definition needlessly difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s notion of privacy is simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It's all *essentially* public. The source code is available. We're all adults.
    Nothing can be truly hidden.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conventionally, we'll treat some names in a way that's less public. They're
    generally implementation details that are subject to change without notice, but
    there's no formal notion of private.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names that begin with `_` are honored as less public by some parts of Python.
    The `help()` function generally ignores these methods. Tools such as Sphinx can
    conceal these names from documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Python's internal names begin (and end) with `__`. This is how Python internals
    are kept from colliding with application features above the internals. The collection
    of these internal names is fully defined by the language reference. Further, there's
    no benefit to trying to use `__` to attempt to create a "super private" attribute
    or method in our code. All that happens is that we create a potential future problem
    if a release of Python ever starts using a name we chose for internal purposes.
    Also, we're likely to run afoul of the internal name mangling that is applied
    to these names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for the visibility of Python names are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Most names are public.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names that start with `_` are somewhat less public. Use them for implementation
    details that are truly subject to change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names that begin and end with `__` are internal to Python. We never make these
    up; we use the names defined by the language reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, the Python approach is to register the intent of a method (or attribute)
    using documentation and a well-chosen name. Often, the interface methods will
    have elaborate documentation, possibly including `doctest` examples, while the
    implementation methods will have more abbreviated documentation and may not have
    `doctest` examples.
  prefs: []
  type: TYPE_NORMAL
- en: For programmers new to Python, it's sometimes surprising that privacy is not
    more widely used. For programmers experienced in Python, it's surprising how many
    brain calories get burned sorting out private and public declarations that aren't
    really very helpful because the intent is obvious from the method names and the
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have reviewed the various design alternatives of the `__init__()`
    method. In the next chapter, we will take a look at the special methods, along
    with a few advanced ones as well.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2. Integrating Seamlessly with Python Basic Special Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of special methods that permit close integration between
    our classes and Python. *Standard Library Reference* calls them **basic**. A better
    term might be *foundational* or *essential*. These special methods form a foundation
    for building classes that seamlessly integrate with other Python features.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we need string representations of a given object's value. The base
    class, `object`, has a default implementation of `__repr__()` and `__str__()`
    that provides string representations of an object. Sadly, these default representations
    are remarkably uninformative. We'll almost always want to override one or both
    of these default definitions. We'll also look at `__format__()`, which is a bit
    more sophisticated but serves the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also look at other conversions, specifically `__hash__()`, `__bool__()`,
    and `__bytes__()`. These methods will convert an object into a number, a true/false
    value, or a string of bytes. When we implement `__bool__()`, for example, we can
    use our object in an `if` statement as follows: `if someobject:`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can look at the special methods that implement the comparison operators
    `__lt__()`, `__le__()`, `__eq__()`, `__ne__()`, `__gt__()`, and `__ge__()`.
  prefs: []
  type: TYPE_NORMAL
- en: These basic special methods are almost always needed in class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at `__new__()` and `__del__()` last because the use cases for these
    methods are rather complex. We don't need these as often as we need the other
    basic special methods.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look in detail at how we can expand a simple class definition to add these
    special methods. We'll need to look at both the default behaviors inherited from
    object so that we can understand what overrides are needed and when they're actually
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: The __repr__() and __str__() methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has two string representations of an object. These are closely aligned
    with the built-in functions `repr()`, `str()`, `print()`, and the `string.format()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the `str()` method representation of an object is commonly expected
    to be more friendly to humans. This is built by an object's `__str__()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `repr()` method representation is often going to be more technical, perhaps
    even a complete Python expression to rebuild the object. The documentation says:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For many types, this function makes an attempt to return a string that would
    yield an object with the same value when passed to `eval()`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is built by an object's `__repr__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `print()` function will use `str()` to prepare an object for printing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `format()` method of a string can also access these methods. When we use
    `{!r}` or `{!s}` formatting, we're requesting `__repr__()` or `__str__()`, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the default implementations first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple class hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We've defined two simple classes with four attributes in each class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an interaction with an object of one of these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We can see from this output that the default implementations of `__str__()`
    and `__repr__()` are not very informative.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two broad design cases that we consider when overriding `__str__()`
    and `__repr__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-collection objects**: A "simple" object doesn''t contain a collection
    of other objects and generally doesn''t involve very complex formatting of that
    collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection objects**: An object that contains a collection involves somewhat
    more complex formatting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non collection __str__() and __repr__()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we saw previously, the output from `__str__()` and `__repr__()` are not
    very informative. We''ll almost always need to override them. The following is
    an approach to override `__str__()` and `__repr__()` when there''s no collection
    involved. These methods belong to the `Card` class, defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: These two methods rely on passing the object's internal instance variable dictionary,
    `__dict__`, to the `format()` function. This isn't appropriate for objects that
    use `__slots__`; often, these are immutable objects. The use of names in the format
    specifications makes the formatting more explicit. It also makes the format template
    longer. In the case of `__repr__()`, we passed in the internal `__dict__` plus
    the object's `__class__` as keyword argument values to the `format()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template string uses two kinds of format specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: The `{__class__.__name__}` template that could also be written as `{__class__.__name__!s}`
    to be more explicit about providing a simple string version of the class name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `{suit!r}` and `{rank!r}` template both use the `!r` format specification
    to produce the `repr()` method of the attribute values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of `__str__()`, we've only passed the object's internal `__dict__`.
    The formatting uses implicit `{!s}` format specifications to produce the `str()`
    method of the attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: Collection __str__() and __repr__()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When there''s a collection involved, we need to format each individual item
    in the collection as well as the overall container for those items. The following
    is a simple collection with both `__str__()` and `__repr__()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__str__()` method is a simple recipe, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Map `str()` to each item in the collection. This will create an iterator over
    the resulting string values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `", ".join()` to merge all the item strings into a single, long string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `__repr__()` method is a multiple-part recipe, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Map `repr()` to each item in the collection. This will create an iterator over
    the resulting string values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `", ".join()` to merge all the item strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a set of keywords with `__class__`, the collection string, and the various
    attributes from `__dict__`. We've named the collection string `_cards_str` so
    that it doesn't conflict with an existing attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `"{__class__.__name__}({dealer_card!r}, {_cards_str})".format()` to combine
    the class name and the long string of item values. We use the `!r` formatting
    to ensure that the attribute uses the `repr()` conversion too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In some cases, this can be optimized and made somewhat simpler. Use of positional
    arguments for the formatting can somewhat shorten the template string.
  prefs: []
  type: TYPE_NORMAL
- en: The __format__() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `__format__()` method is used by `string.format()` as well as the `format()`
    built-in function. Both of these interfaces are used to get presentable string
    versions of a given object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two ways in which arguments will be presented to `__format__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`someobject.__format__("")`: This happens when the application does `format(someobject)`
    or something equivalent to `"{0}".format(someobject)`. In these cases, a zero-length
    string specification was provided. This should produce a default format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`someobject.__format__(specification)`: This happens when the application does
    `format(someobject, specification)` or something equivalent to `"{0:specification}".format(someobject)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that something equivalent to `"{0!r}".format()` or `"{0!s}".format()` doesn't
    use the `__format__()` method. These use `__repr__()` or `__str__()` directly.
  prefs: []
  type: TYPE_NORMAL
- en: With a specification of `""`, a sensible response is `return str(self)`. This
    provides an obvious consistency between the various string representations of
    an object.
  prefs: []
  type: TYPE_NORMAL
- en: The format specification will be all the text after the `":"` in a format string.
    When we write `"{0:06.4f}"`, the `06.4f` is the format specification that applies
    to item `0` of the argument list to be formatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Section 6.1.3.1 of the *Python Standard Library* documentation defines a sophisticated
    numeric specification as a nine-part string. This is the format specification
    mini-language. It has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can parse these standard specifications with a **regular expression** (**RE**)
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This RE will break the specification into eight groups. The first group will
    have both the `fill` and `alignment` fields from the original specification. We
    can use these groups to work out the formatting for the numeric data of the classes
    that we've defined.
  prefs: []
  type: TYPE_NORMAL
- en: However, Python's format specification mini-language might not apply very well
    to the classes that we've defined. Therefore, we might need to define our own
    specification mini-language and process it in our class `__format__()` method.
    If we're defining numeric types, we should stick to the predefined mini-language.
    For other types, however, there's no reason to stick to the predefined language.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, here's a trivial language that uses the character `%r` to show
    us the rank and the character `%s` to show us the suit. The `%%` character becomes
    `%` in the resulting string. All other characters are repeated literally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could extend our `Card` class with formatting as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This definition checks for a format specification. If there's no specification,
    then the `str()` function is used. If a specification was provided, a series of
    replacements is done to fold rank, suit, and any `%` characters into the format
    specification, turning it into the output string.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to format cards as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The format specification (`"%r of %s"`) is passed to our `__format__()` method
    as the `format` parameter. Using this, we're able to provide a consistent interface
    for the presentation of the objects of the classes that we've defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can define things as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This has the advantage of putting all string presentations into the `__format__()`
    method instead of spreading it between `__format__()` and `__str__()`. This has
    a disadvantage because we don't always need to implement `__format__()`, but we
    almost always need to implement `__str__()`.
  prefs: []
  type: TYPE_NORMAL
- en: Nested formatting specifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `string.format()` method can handle nested instances of `{}` to perform
    simple keyword substitution into the format specification. This replacement is
    done to create the final format string that's passed to our class `__format__()`
    method. This kind of nested substitution simplifies some kinds of relatively complex
    numeric formatting by parameterizing an otherwise generic specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example where we''ve made `width` easy to change in the
    `format` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a generic format, `"{hand:%r%s} {count:{width}d}"`, which requires
    a `width` parameter to make it into a proper format specification.
  prefs: []
  type: TYPE_NORMAL
- en: The value provided with the `width=` parameter to the `format()` method is used
    to replace the `{width}` nested specification. Once this is replaced, the final
    format as a whole is provided to the `__format__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Collections and delegating format specifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When formatting a complex object that includes a collection, we have two formatting
    issues: how to format the overall object and how to format the items in the collection.
    When we look at `Hand`, for example, we see that we have a collection of individual
    `Cards` class. We''d like to have `Hand` delegate some formatting details to the
    individual `Card` instances in the `Hand` collection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a `__format__()` method that applies to `Hand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `format_specification` parameter will be used for each individual `Card`
    instance within the `Hand` collection. The format specification of `"{0:{fs}}"`
    uses the nested format specification technique to push the `format_specification`
    string to create a format that applies to each `Card` instance. Given this method,
    we can format a `Hand` object, `player_hand`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This will apply the `%r%s` format specification to each `Card` instance of the
    `Hand` object.
  prefs: []
  type: TYPE_NORMAL
- en: The __hash__() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The built-in `hash()` function invokes the `__hash__()` method of a given object.
    This hash is a calculation which reduces a (potentially complex) value to a small
    integer value. Ideally, a hash reflects all the bits of the source value. Other
    hash calculations—often used for cryptographic purposes—can produce very large
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python includes two hash libraries. The cryptographic-quality hash functions
    are in `hashlib`. The `zlib` module has two high-speed hash functions: `adler32()`
    and `crc32()`. For relatively simple values, we don''t use either of these. For
    large, complex values, these algorithms can be of help.'
  prefs: []
  type: TYPE_NORMAL
- en: The `hash()` function (and the associated `__hash__()` method) is used to create
    a small integer key that is used to work with collections such as `set`, `frozenset`,
    and `dict`. These collections use the hash value of an **immutable** object to
    rapidly locate the object in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability is important here; we'll mention it many times. Immutable objects
    don't change their state. The number `3`, for example, doesn't change state. It's
    always `3`. More complex objects, similarly, can have an immutable state. Python
    strings are immutable so that they can be used as keys to mappings and sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default `__hash__()` implementation inherited from an object returns a
    value based on the object''s internal ID value. This value can be seen with the
    `id()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: From this, we can see that on the author's particular system, the hash value
    is the object's `id//16`. This detail might vary from platform to platform. CPython,
    for example, uses portable `C` libraries where Jython relies on the Java JVM.
  prefs: []
  type: TYPE_NORMAL
- en: What's essential is that there is a strong correlation between the internal
    ID and the default `__hash__()` method. This means that the default behavior is
    for each object to be hashable as well as utterly distinct, even if it appears
    to have the same value.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to modify this if we want to coalesce different objects with the
    same value into a single hashable object. We'll look at an example in the next
    section, where we would like two instances of a single `Card` instance to be treated
    as if they were the same object.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding what to hash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not every object should provide a hash value. Specifically, if we're creating
    a class of stateful, mutable objects, the class should *never* return a hash value.
    The definition of `__hash__` should be `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable objects, on the other hand, might sensibly return a hash value so
    that the object can be used as the key in a dictionary or a member of a set. In
    this case, the hash value needs to parallel the way the test for equality works.
    It's bad to have objects that claim to be equal and have different hash values.
    The reverse—objects with the same hash that are actually not equal—is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: The `__eq__()` method, which we'll also look at in the section on comparison
    operators, is intimately tied up with hashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three tiers of equality comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Same Hash Value**: This means that two objects could be equal. The hash value
    provides us with a quick check for likely equality. If the hash value is different,
    the two objects cannot possibly be equal, nor can they be the same object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compare As Equal**: This means that the hash values must also have been equal.
    This is the definition of the `==` operator. The objects may be the same object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Same IDD**: This means that they are the same object. They also compare as
    equal and will have the same hash value. This is the definition of the `is` operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Fundamental Law of Hash** (**FLH**) is this: objects that compare as
    equal have the same hash value.'
  prefs: []
  type: TYPE_NORMAL
- en: We can think of a hash comparison as being the first step in an equality test.
  prefs: []
  type: TYPE_NORMAL
- en: The inverse, however, is not true. Objects can have the same hash value but
    compare as not equal. This is valid and leads to some expected processing overhead
    when creating sets or dictionaries. We can't reliably create distinct 64 bit hash
    values from much larger data structures. There will be unequal objects that are
    reduced to coincidentally equal hash values.
  prefs: []
  type: TYPE_NORMAL
- en: Coincidentally, equal hash values are an expected overhead when working with
    `sets` and `dicts`. These collections have internal algorithms to use alternate
    locations in the event of hash collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three use cases for defining equality tests and hash values via the
    `__eq__()` and `__hash__()` method functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutable objects**: These are stateless objects of types such as tuples,
    namedtuples, and frozensets that cannot be updated. We have two choices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define neither `__hash__()` nor `__eq__()`. This means doing nothing and using
    the inherited definitions. In this case, `__hash__()` returns a trivial function
    of the ID value for the object, and `__eq__()` compares the ID values. The default
    equality test may sometimes be counterintuitive. Our application might require
    two instances of `Card( 1, Clubs )` to test as equal and compute the same hash;
    this won't happen by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define both `__hash__()` and `__eq__()`. Note that we're expected to define
    both for an immutable object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutable objects**: These are stateful objects that can be modified internally.
    We have one design choice:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define `__eq__()` but set `__hash__` to `None`. These cannot be used as `dict`
    keys or items in `sets`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that there''s an additional possible combination: defining `__hash__()`
    but using a default definition for `__eq__()`. This is simply a waste of code,
    as the default `__eq__()` method is the same as the `is` operator. The default
    `__hash__()` method would have involved writing less code for the same behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at each of the three situations in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting definitions for immutable objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see how the default definitions operate. The following is a simple class
    hierarchy that uses the default definitions of `__hash__()` and `__eq__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This is a class hierarchy for *philosophically* immutable objects. We haven't
    taken care to implement the special methods that prevent the attributes from getting
    updated. We'll look at attribute access in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we use this class hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined two instances of what appear to be the same `Card` instance. We
    can check the `id()` values as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: They have different `id()` numbers; they're distinct objects. This meets our
    expectations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check to see if they''re the same using the `is` operator as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The "is test" is based on the `id()` numbers; it shows us that they are indeed
    separate objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that their hash values are different from each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'These hash values come directly from the `id()` values. This is our expectation
    for the inherited methods. In this implementation, we can compute the hash from
    the `id()` function as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'As the hash values are different, they must not compare as equal. This fits
    the definitions of hash and equality. However, this violates our expectations
    for this class. The following is an equality check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We created them with the same arguments. They didn't compare as equal. In some
    applications, this might not be good. For example, when accumulating statistical
    counts around dealer cards, we don't want to have six counts for one card because
    the simulation used a 6-deck shoe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that they''re proper immutable objects as we can put them into a
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This is the documented behavior from the *Standard Library Reference* documentation.
    By default, we'll get a `__hash__()` method based on the ID of the object so that
    each instance appears unique. However, this isn't always what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding definitions for immutable objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a simple class hierarchy that provides us with definitions
    of `__hash__()` and `__eq__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This object is immutable in principle. There's no formal mechanism to make it
    immutable. We'll look at how to prevent the attribute value changes in [Chapter
    3](ch03.html "Chapter 3. Attribute Access, Properties, and Descriptors"), *Attribute
    Access, Properties, and Descriptors*.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the preceding code omits two of the subclasses that didn't change
    significantly from the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__eq__()` method function compares these two essential values: `suit`
    and `rank`. It doesn''t compare the hard and soft values; they''re derived from
    `rank`.'
  prefs: []
  type: TYPE_NORMAL
- en: The rules for Blackjack make this definition a bit suspicious. Suit doesn't
    actually matter in Blackjack. Should we merely compare rank? Should we define
    an additional method that compares rank only? Or, should we rely on the application
    to compare ranks properly? There's no best answer to these questions; these are
    just trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: The `__hash__()` method function computes a bit pattern from the two essential
    values using an exclusive OR of the bits that comprise each value. Using the ^
    operator is a quick-and-dirty hash method that often works pretty well. For larger
    and more complex objects, a more sophisticated hash might be appropriate. Start
    with `ziplib` before inventing something that has bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how objects of these classes behave. We expect them to compare as
    equal and behave properly with sets and dictionaries. Here are two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined two instances of what appear to be the same card. We can check the
    ID values to be sure that they''re distinct objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: These have different `id()` numbers. When we test with the `is` operator, we
    see that they're distinct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare the hash values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The hash values are identical. This means that they could be equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equality operator shows us that they properly compare as equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'As they''re immutable, we can put them into a set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This meets our expectations for complex immutable objects. We had to override
    both special methods to get consistent, meaningful results.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding definitions for mutable objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example will continue using the `Cards` class. The idea of mutable cards
    is strange, perhaps even wrong. However, we'd like to apply just one small tweak
    to the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class hierarchy that provides us with the definitions of
    `__hash__()` and `__eq__()`, appropriate for mutable objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how objects of these classes behave. We expect them to compare as
    equal but not work at all with sets or dictionaries. We''ll create two objects
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We've defined two instances of what appear to be the same card.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at their ID values to ensure they really are distinct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'No surprise here. We''ll see if we can get hash values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: As `__hash__` is set to `None`, these `Card3` objects can't be hashed and can't
    provide a value for the `hash()` function. This is the expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can perform equality comparisons, though, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The equality test works properly, allowing us to compare cards. They just can't
    be inserted into sets or used as a key to a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what happens when we try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We get a proper exception when trying to put these into a set.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this is not a proper definition for something that—in real life—is
    immutable like a card. This style of definition is more appropriate for stateful
    objects such as `Hand`, where the content of the hand is always changing. We'll
    provide you with a second example of stateful objects in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Making a frozen hand from a mutable hand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to perform statistical analysis of specific `Hand` instances, we
    might want to create a dictionary that maps a `Hand` instance to a count. We can''t
    use a mutable `Hand` class as the key in a mapping. We can, however, parallel
    the design of `set` and `frozenset` and create two classes: `Hand` and `FrozenHand`.
    This allows us to "freeze" a `Hand` class via `FrozenHand`; the frozen version
    is immutable and can be used as a key in a dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple `Hand` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This is a mutable object (`__hash__` is `None`) that has a proper equality test
    that compares two hands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a frozen version of `Hand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The frozen version has a constructor that will build one `Hand` class from another
    `Hand` class. It defines a `__hash__()` method that sums the card's hash value
    that is limited to the `sys.hash_info.modulus` value. For the most part, this
    kind of modulus-based calculation works out reasonably well for computing hashes
    of composite objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use these classes for operations such as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We've initialized a statistics dictionary, `stats`, as a `defaultdict` dictionary
    that can collect integer counts. We could also use a `collections.Counter` object
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: By freezing a `Hand` class, we can use it as a key in a dictionary, collecting
    counts of each hand that actually gets dealt.
  prefs: []
  type: TYPE_NORMAL
- en: The __bool__() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a pleasant definition of falsity. The reference manual lists a large
    number of values that will test as equivalent to `False`. This includes things
    such as `False`, `0`, `''`, `()`, `[]`, and `{}`. Most other objects will test
    as equivalent to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, we''ll want to check for an object being "not empty" with a simple statement
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, this is the job of the `bool()` built-in function. This function
    depends on the `__bool__()` method of a given object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default `__bool__()` method returns `True`. We can see this with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: For most classes, this is perfectly valid. Most objects are not expected to
    be `False`. For collections, however, this is not appropriate. An empty collection
    should be equivalent to `False`. A nonempty collection can return `True`. We might
    want to add a method like this to our `Deck` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re wrapping a list, we might have something as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This delegates the Boolean function to the internal `_cards` collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re extending a list, we might have something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: This delegates to the superclass definition of the `__bool__()` function.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, we're specifically delegating the Boolean test. In the wrap case,
    we're delegating to the collection. In the extend case, we're delegating to the
    superclass. Either way, wrap or extend, an empty collection will be `False`. This
    will give us a way to see whether the `Deck` object has been entirely dealt and
    is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do things as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This loop will deal all the cards without getting an `IndexError` exception
    when the deck has been exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: The __bytes__() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are relatively few occasions to transform an object into bytes. We'll
    look at this in detail in [Part 2](pt02.html "Part 2. Persistence and Serialization"),
    *Persistence and Serialization*.
  prefs: []
  type: TYPE_NORMAL
- en: In the most common situation, an application can create a string representation,
    and the built-in encoding capabilities of the Python IO classes will be used to
    transform the string into bytes. This works perfectly for almost all situations.
    The main exception would be when we're defining a new kind of string. In that
    case, we'd need to define the encoding of that string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bytes()` function does a variety of things, depending on the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bytes(integer)`: This returns an immutable bytes object with the given number
    of `0x00` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bytes(string)`: This will encode the given string into bytes. Additional parameters
    for encoding and error handling will define the details of the encoding process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bytes(something)`: This will invoke `something.__bytes__()` to create a bytes
    object. The encoding or error arguments will not be used here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The base `object` class does not define `__bytes__()`. This means our classes
    don't provide a `__bytes__()` method by default.
  prefs: []
  type: TYPE_NORMAL
- en: There are some exceptional cases where we might have an object that will need
    to be encoded directly into bytes before being written to a file. It's often simpler
    to work with strings and allow the `str` type to produce bytes for us. When working
    with bytes, it's important to note that there's no *trivial* way to decode bytes
    from a file or interface. The built-in `bytes` class will only decode strings,
    not our unique, new objects. We might need to parse the strings that are decoded
    from the bytes. Or, we might need to explicitly parse the bytes using the `struct`
    module and create our unique objects from the parsed values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at encoding and decoding `Card` to bytes. As there are only 52
    card values, each card could be packed into a single byte. However, we''ve elected
    to use a character to represent `suit` and a character to represent `rank`. Further,
    we''ll need to properly reconstruct the subclass of `Card`, so we have to encode
    several things:'
  prefs: []
  type: TYPE_NORMAL
- en: The subclass of `Card` (`AceCard`, `NumberCard`, `FaceCard`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameters to the subclass-defined `__init__()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that some of our alternative `__init__()` methods will transform a numeric
    rank into a string, losing the original numeric value. For the purposes of a reversible
    byte encoding, we need to reconstruct this original numeric rank value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an implementation of `__bytes__()`, which returns a **UTF-8**
    encoding of the `Cards` class, `rank`, and `suit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This works by creating a string representation of the `Card` object and then
    encoding the string into bytes. This is often the simplest and most flexible approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are given a pile of bytes, we can decode the string and then parse
    the string into a new `Card` object. The following is a method that can be used
    to create a `Card` object from bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we've decoded the bytes into a string. Then we've parsed
    the string into individual values. From those values, we can locate the class
    and build the original `Card` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build a bytes representation of a `Card` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reconstruct the `Card` object from the bytes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that the external bytes representation is often challenging
    to design. We're creating a representation of the state of an object. Python already
    has a number of representations that work well for our class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: It's often better to use the `pickle` or `json` modules than to invent a low-level
    bytes representation of an object. This is the subject of [Chapter 9](ch09.html
    "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and XML"), *Serializing
    and Saving – JSON, YAML, Pickle, CSV, and XML*.
  prefs: []
  type: TYPE_NORMAL
- en: The comparison operator methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has six comparison operators. These operators have special method implementations.
    According to the documentation, the mapping works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x<y` calls `x.__lt__(y)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x<=y` calls `x.__le__(y)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x==y` calls `x.__eq__(y)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x!=y` calls `x.__ne__(y)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x>y` calls `x.__gt__(y)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x>=y` calls `x.__ge__(y)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll return to comparison operators again when looking at numbers in [Chapter
    7](ch07.html "Chapter 7. Creating Numbers"), *Creating Numbers*.
  prefs: []
  type: TYPE_NORMAL
- en: There's an additional rule regarding what operators are actually implemented
    that's relevant here. These rules are based on the idea that the object's class
    on the left defines the required special method. If it doesn't, Python can try
    an alternative operation by changing the order.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Here are the two basic rules**'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the operand on the left is checked for an operator implementation: `A<B`
    means `A.__lt__(B)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, the operand on the right is checked for a reversed operator implementation:
    `A<B` means `B.__gt__(A)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The rare exception to this occurs when the right operand is a subclass of the
    left operand; then, the right operand is checked first to allow a subclass to
    override a superclass.
  prefs: []
  type: TYPE_NORMAL
- en: We can see how this works by defining a class with only one of the operators
    defined and then using it for other operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a partial class that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This follows the Blackjack comparison rules where suits don't matter. We've
    omitted comparison methods to see how Python will fallback when an operator is
    missing. This class will allow us to perform the `<` comparisons. Interestingly,
    Python can also use this to perform the `>` comparisons by switching the argument
    order. In other words, *x<y≡y>x*. This is the mirror reflection rule; we'll see
    it again in [Chapter 7](ch07.html "Chapter 7. Creating Numbers"), *Creating Numbers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see this when we try to evaluate different comparison operations. We''ll
    create two `Cards` classes and compare them in various ways as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: From this, we can see where `two < three` maps to `two.__lt__(three)`.
  prefs: []
  type: TYPE_NORMAL
- en: However, for `two > three`, there's no `__gt__()` method defined; Python uses
    `three.__lt__(two)` as a fallback plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `__eq__()` method is inherited from `object`; it compares the
    object IDs; the objects participate in `==` and `!=` tests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the results aren't quite what we expect. We'll often need to
    override the default implementation of `__eq__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, there''s no logical connection among the operators. Mathematically, we
    can derive all the necessary comparisons from just two. Python doesn''t do this
    automatically. Instead, Python handles the following four simple reflection pairs
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The comparison operator methods](graphics/0971OS_02_01.jpg)![The comparison
    operator methods](graphics/0971OS_02_02.jpg)![The comparison operator methods](graphics/0971OS_02_03.jpg)![The
    comparison operator methods](graphics/0971OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This means that we must, at the minimum, provide one from each of the four pairs.
    For example, we could provide `__eq__()`, `__ne__()`, `__lt__()`, and `__le__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@functools.total_ordering` decorator overcomes the default limitation
    and deduces the rest of the comparisons from just `__eq__()` and one of these:
    `__lt__()`, `__le__()`, `__gt__()`, or `__ge__()`. We''ll revisit this in [Chapter
    7](ch07.html "Chapter 7. Creating Numbers"), *Creating Numbers*.'
  prefs: []
  type: TYPE_NORMAL
- en: Designing comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two considerations when defining the comparison operators:'
  prefs: []
  type: TYPE_NORMAL
- en: The obvious question of how to compare two objects of the same class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The less obvious question of how to compare objects of different classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a class with multiple attributes, we often have a profound ambiguity when
    looking at the comparison operators. It might not be perfectly clear what we're
    going to compare.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the humble playing card (again!). An expression such as `card1 == card2`
    is clearly intended to compare `rank` and `suit`. Right? Or is that always true?
    After all, `suit` doesn't matter in Blackjack.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to decide whether a `Hand` object can be split, we have to see which
    of the two code snippets is better. The following is the first code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the second code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: While one is shorter, brevity is not always best. If we define equality to only
    consider `rank`, we will have trouble defining unit tests because a simple `TestCase.assertEqual()`
    method will tolerate a wide variety of cards when a unit test should be focused
    on exactly correct cards.
  prefs: []
  type: TYPE_NORMAL
- en: An expression such as `card1 <= 7` is clearly intended to compare `rank`.
  prefs: []
  type: TYPE_NORMAL
- en: Do we want some comparisons to compare all attributes of a card and other comparisons
    to compare just `rank`? What do we do to order cards by `suit`? Furthermore, equality
    comparison must parallel the hash calculation. If we've included multiple attributes
    in the hash, we need to include them in the equality comparison. In this case,
    it appears that equality (and inequality) between cards must be full `Card` comparisons
    because we're hashing the `Card` values to include `rank` and `suit`.
  prefs: []
  type: TYPE_NORMAL
- en: The ordering comparisons between `Card`, however, should be `rank` only. Comparisons
    against integers, similarly, should be `rank` only. For the special case of detecting
    a split, `hand.cards[0].rank == hand.cards[1].rank` will do nicely because it's
    explicit on the rule for a split.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of comparison for objects of the same class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll look at a simple same-class comparison by looking at a more complete
    `BlackJackCard` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: We've now defined all six comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve shown you two kinds of type checking: **explicit** and **implicit**.
    The explicit type checking uses `isinstance()`. The implicit type checking uses
    a `try:` block. There''s a tiny conceptual advantage to using the `try:` block:
    it avoids repeating the name of a class. It''s entirely possible that someone
    might want to invent a variation on a card that''s compatible with this definition
    of `BlackJackCard` but not defined as a proper subclass. Using `isinstance()`
    might prevent an otherwise valid class from working correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: The `try:` block might allow a class that coincidentally happens to have a `rank`
    attribute to work. The risk of this turning into a difficult-to-solve problem
    is nil, as the class would likely fail everywhere else it was used in this application.
    Also, who compares an instance of `Card` with a class from a financial modeling
    application that happens to have a rank-ordering attribute?
  prefs: []
  type: TYPE_NORMAL
- en: In future examples, we'll focus on the `try:` block. The `isinstance()` method
    check is idiomatic Python and is widely used. We explicitly return `NotImplemented`
    to inform Python that this operator isn't implemented for this type of data. Python
    can try reversing the argument order to see if the other operand provides an implementation.
    If no valid operator can be found, then a `TypeError` exception will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: We omitted the three subclass definitions and the factory function, `card21()`.
    They're left as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also omitted intraclass comparisons; we''ll save that for the next section.
    With this class, we can compare cards successfully. The following is an example
    where we create and compare three cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Given those `Cards` classes, we can perform a number of comparisons as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The definitions seem to work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of comparison for objects of mixed classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll use the `BlackJackCard` class as an example to see what happens when we
    attempt comparisons where the two operands are from different classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a `Card` instance that we can compare against the `int` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we expected: the subclass of `BlackJackCard`, `Number21Card` doesn''t
    provide the required special methods, so there''s a `TypeError` exception.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, consider the following two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Why do these provide responses? When confronted with a `NotImplemented` value,
    Python will reverse the operands. In this case, the integer values define an `int.__eq__()`
    method that tolerates objects of an unexpected class.
  prefs: []
  type: TYPE_NORMAL
- en: Hard totals, soft totals, and polymorphism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's define `Hand` so that it will perform a meaningful mixed-class comparison.
    As with other comparisons, we have to determine precisely what we're going to
    compare.
  prefs: []
  type: TYPE_NORMAL
- en: For equality comparisons between `Hands`, we should compare all cards.
  prefs: []
  type: TYPE_NORMAL
- en: For ordering comparisons between `Hands`, we need to compare an attribute of
    each `Hand` object. For comparisons against an `int` literal, we should compare
    the `Hand` object's total against the literal. In order to have a total, we have
    to sort out the subtlety of hard totals and soft totals in the game of Blackjack.
  prefs: []
  type: TYPE_NORMAL
- en: 'When there''s an ace in a hand, then the following are two candidate totals:'
  prefs: []
  type: TYPE_NORMAL
- en: The **soft total** treats an ace as 11\. If the soft total is over 21, then
    this version of the ace has to be ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **hard total** treats an ace as 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that the hand's total isn't a simple sum of the cards.
  prefs: []
  type: TYPE_NORMAL
- en: We have to determine if there's an ace in the hand first. Given that information,
    we can determine if there's a valid (less than or equal to 21) soft total. Otherwise,
    we'll fall back on the hard total.
  prefs: []
  type: TYPE_NORMAL
- en: One symptom of **Pretty Poor Polymorphism** is relying on `isinstance()` to
    determine the subclass membership. Generally, this is a violation of the basic
    encapsulation. A good set of polymorphic subclass definitions should be completely
    equivalent with the same method signatures. Ideally, the class definitions are
    opaque; we don't need to look inside the class definition. A poor set of polymorphic
    classes uses extensive `isinstance()` testing. In some cases, `isinstance()` is
    necessary. This can arise when using a built-in class. We can't retroactively
    add method functions to built-in classes, and it might not be worth the effort
    of subclassing them to add a polymorphism helper method.
  prefs: []
  type: TYPE_NORMAL
- en: In some of the special methods, it's necessary to see `isinstance()` used to
    implement operations that work across multiple classes of objects where there's
    no simple inheritance hierarchy. We'll show you an idiomatic use of `isinstance()`
    for unrelated classes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: For our cards class hierarchy, we want a method (or an attribute) that identifies
    an ace without having to use `isinstance()`. This is a polymorphism helper method.
    It ensures we can tell otherwise equivalent classes apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a class-level attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the way the insurance bet works, we have two reasons to check for
    aces. If the dealer's card is an ace, it triggers an insurance bet. If the dealer's
    hand (or the player's hand) has an ace, there will be a soft total versus hard
    total calculation.
  prefs: []
  type: TYPE_NORMAL
- en: The hard total and soft total always differ by the `card.soft–card.hard` value
    for the card that's an ace. We can look inside the definition of `AceCard` to
    see that this value is 10\. However, looking at the implementation breaks encapsulation
    by looking deeply at a class implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We can treat `BlackjackCard` as opaque and check to see whether `card.soft-card.hard!=0`
    is true. If this is true, it is sufficient information to work out the hard total
    versus soft total of the hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a version of the `total` method that makes use of the soft
    versus hard delta value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: We'll compute the largest difference between the hard and soft total as `delta_soft`.
    For most cards, the difference is zero. For an ace, the difference will be nonzero.
  prefs: []
  type: TYPE_NORMAL
- en: Given the hard total and `delta_soft`, we can determine which total to return.
    If `hard+delta_soft` is less than or equal to 21, the value is the soft total.
    If the soft total is greater than 21, then revert to a hard total.
  prefs: []
  type: TYPE_NORMAL
- en: We can consider making the value 21 a manifest constant in the class. A meaningful
    name is sometimes more helpful than a literal. Because of the rules of Blackjack,
    it's unlikely that 21 would ever change to a different value. It's difficult to
    find a more meaningful name than the literal 21.
  prefs: []
  type: TYPE_NORMAL
- en: A mixed class comparison example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given a definition of a total for a `Hand` object, we can meaningfully define
    comparisons between the `Hand` instances and comparisons between `Hand` and `int`.
    In order to determine which kind of comparison we're doing, we're forced to use
    `isinstance()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a partial definition of `Hand` with comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: We've defined three of the comparisons, not all six.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to interact with `Hands`, we''ll need a few `Card` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: We'll use this sequence of cards to see two different `hand` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'This first `Hands` object has an irrelevant dealer''s `Card` object and the
    set of four `Cards` created previously. One of the `Card` objects is an ace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The soft total is 18 and the hard total is 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a second `Hand` object that has an additional `Card` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The hard total is 13\. There's no soft total because it would be over 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'The comparisons among `Hands` work very nicely, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: We can rank `Hands` based on the comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also compare `Hands` with integers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The comparisons with integers work as long as Python isn't forced to try a fallback.
    The previous example shows us what happens when there's no `__gt__()` method.
    Python checks the reflected operands, and the integer 17 doesn't have a proper
    `__lt__()` method for `Hand` either.
  prefs: []
  type: TYPE_NORMAL
- en: We can add the necessary `__gt__()` and `__ge__()` functions to make `Hand`
    work properly with integers.
  prefs: []
  type: TYPE_NORMAL
- en: The __del__() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `__del__()` method has a rather obscure use case.
  prefs: []
  type: TYPE_NORMAL
- en: The intent is to give an object a chance to do any cleanup or finalization just
    before the object is removed from memory. This use case is handled much more cleanly
    by context manager objects and the `with` statement. This is the subject of [Chapter
    5](ch05.html "Chapter 5. Using Callables and Contexts"), *Using Callables and
    Contexts*. Creating a context is much more predictable than dealing with `__del__()`
    and the Python garbage collection algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In the case where a Python object has a related OS resource, the `__del__()`
    method is a last chance to cleanly disentangle the resource from the Python application.
    As examples, a Python object that conceals an open file, a mounted device, or
    perhaps a child subprocess might all benefit from having the resource released
    as part of `__del__()` processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__del__()` method is not invoked at any easy-to-predict time. It''s not
    always invoked when the object is deleted by a `del` statement, nor is it always
    invoked when an object is deleted because a namespace is being removed. The documentation
    on the `__del__()` method describes the circumstances as *precarious* and provides
    this additional note on exception processing: exceptions that occur during their
    execution are ignored, and a warning is printed to `sys.stderr` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, a context manager is often preferable to implementing `__del__()`.
  prefs: []
  type: TYPE_NORMAL
- en: The reference count and destruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the CPython implementation, objects have a reference count. The count is
    incremented when the object is assigned to a variable and decremented when the
    variable is removed. When the reference count is zero, the object is no longer
    needed and can be destroyed. For simple objects, `__del__()` will be invoked and
    the object will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: For complex objects that have circular references among objects, the reference
    count might never go to zero and `__del__()` can't be invoked easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class that we can use to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create (and see the removal of) these objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: We created and removed a `Noisy` object, and almost immediately we saw the message
    from the `__del__()` method. This indicates that the reference count properly
    went to zero when the `x` variable was deleted. Once the variable is gone, there's
    no longer a reference to the instance of `Noisy` and it, too, can be cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a common situation that involves the shallow copies that are
    often created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s no response to this `del` statement. The `Noisy` objects have not
    had their reference counts go to zero yet; they''re still being referenced somewhere,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The `ln2` variable was a shallow copy of the `ln` list. The `Noisy` objects
    were referenced in two lists. They could not be destroyed until both lists were
    removed, reducing the reference counts to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous other ways to create shallow copies. The following are a
    few ways to create shallow copies of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The point here is that we can often be confused by the number of references
    to an object that can exist because shallow copies are prevalent in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Circular references and garbage collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's a common situation that involves circularity. One class, `Parent`, contains
    a collection of children. Each `Child` instance contains a reference to the `Parent`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use these two classes to examine circular references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: A `Parent` instance has a collection of children as a simple `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Each `Child` instance has a reference to the `Parent` class that contains it.
    The reference is created during initialization when the children are inserted
    into the parent's internal collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve made both classes rather noisy so we can see when the objects are removed.
    The following is what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The `Parent` and two initial `Child` instances cannot be removed. They both
    contain references to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a childless `Parent` instance, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: This is deleted, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the mutual or circular references, a `Parent` instance and its list
    of `Child` instances cannot be removed from the memory. If we import the garbage
    collector interface, `gc`, we can collect and display these nonremovable objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the `gc.collect()` method to collect all the nonremovable objects
    that have a `__del__()` method, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: We can see that our `Parent` objects (for example, ID of `4313921808 = 0x101213910`)
    are prominent on the list of nonremovable garbage. To reduce the reference counts
    to zero, we would need to either update each `Parent` instance on the garbage
    list to remove the children, or update each `Child` instance on the list to remove
    the reference to the `Parent` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can't break the circularity by putting code in the `__del__()`
    method. The `__del__()` method is called *after* the circularity has been broken
    and the reference counts are already zero. When we have circular references, we
    can no longer rely on simple Python reference counting to clear out the memory
    of unused objects. We must either explicitly break the circularity or use a `weakref`
    reference, which permits garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Circular references and the weakref module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the cases where we need circular references but also want `__del__()` to
    work nicely, we can use **weak references**. One common use case for circular
    references are mutual references: a parent with a collection of children; each
    child has a reference back to the parent. If a `Player` class has multiple hands,
    it might be helpful for a `Hand` object to contain a reference to the owning `Player`
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: The default object references could be called **strong references**; however,
    direct references is a better term. They're used by the reference-counting mechanism
    in Python and can be discovered by the garbage collector if reference counting
    can't remove the objects. They cannot be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'A strong reference to an object is followed directly. Consider the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The `a` variable has a direct reference to the object of the `B` class that
    was created. The reference count to the instance of `B` is at least 1 because
    the `a` variable has a reference.
  prefs: []
  type: TYPE_NORMAL
- en: A weak reference involves a two-step process to find the associated object.
    A weak reference will use `x.parent()`, invoking the weak reference as a callable
    object to track down the actual parent object. This two-step process allows the
    reference counting or garbage collection to remove the referenced object, leaving
    the weak reference dangling.
  prefs: []
  type: TYPE_NORMAL
- en: The `weakref` module defines a number of collections that use weak references
    instead of strong references. This allows us to create dictionaries that, for
    example, permit the garbage collection of otherwise unused objects.
  prefs: []
  type: TYPE_NORMAL
- en: We can modify our `Parent` and `Child` classes to use weak references from `Child`
    to `Parent`, permitting a simpler destruction of unused objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a modified class that uses weak references from `Child` to
    `Parent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: We've changed the child to parent reference to be a `weakref` object reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'From within a `Child` class, we must locate the `parent` object via a two-step
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: We can explicitly check to be sure the referenced object was found. There's
    a possibility that the reference was left dangling.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use this new `Parent2` class, we see that reference counting goes to
    zero and the object is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'When a `weakref` reference is dead (because the referent was destroyed), we
    have three potential responses:'
  prefs: []
  type: TYPE_NORMAL
- en: Recreate the referent. Reload it from a database, perhaps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `warnings` module to write the debugging information on low-memory situations
    where the garbage collector removed objects unexpectedly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally, the `weakref` references are dead because objects have been removed:
    variables have gone out of scope, a namespace is no longer in use, the application
    is shutting down. For this reason, the third response is quite common. The object
    trying to create the reference is probably about to be removed as well.'
  prefs: []
  type: TYPE_NORMAL
- en: The __del__() and close() methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common use for `__del__()` is to ensure files are closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, class definitions that open files will have something like what''s
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure the `__del__()` method is also the `close()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Anything more complex than this is better done with a context manager. See [Chapter
    5](ch05.html "Chapter 5. Using Callables and Contexts"), *Using Callables and
    Contexts*, for more information on context managers.
  prefs: []
  type: TYPE_NORMAL
- en: The __new__() method and immutable objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One use case for the `__new__()` method is to initialize objects that are otherwise
    immutable. The `__new__()` method is where our code can build an uninitialized
    object. This allows processing before the `__init__()` method is called to set
    the attribute values of the object.
  prefs: []
  type: TYPE_NORMAL
- en: The `__new__()` method is used to extend the immutable classes where the `__init__()`
    method can't easily be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class that does not work. We''ll define a version of `float`
    that carries around information on units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: We're trying (improperly) to initialize an immutable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what happens when we try to use this class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: From this, we see that we can't easily override the `__init__()` method for
    the built-in immutable `float` class. We'd have similar problems with all other
    immutable classes. We can't set the attribute values on the immutable object,
    `self`, because that's the definition of immutability. We can only set attribute
    values during the object construction. Enter the `__new__()` method after this.
  prefs: []
  type: TYPE_NORMAL
- en: The `__new__()` method is auto-magically a static method. This is true without
    using the `@staticmethod` decorator. It doesn't use a `self` variable, as its
    job is to create the object that will eventually be assigned to the `self` variable.
  prefs: []
  type: TYPE_NORMAL
- en: For this use case, the method signature is `__new__( cls, *args, **kw )`. The
    `cls` parameter is the class for which an instance must be created. For the metaclass
    use case in the next section, the `args` sequence of values are more complex than
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default implementation of `__new__()` simply does this: `return super().__new__(
    cls )`. It delegates the operation to the superclass. The work winds up getting
    delegated to `object.__new__()`, which builds a simple, empty object of the required
    class. The arguments and keywords to `__new__()`, with the exception of the `cls`
    argument, will be passed to `__init__()` as part of the standard Python behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With two notable exceptions, this is exactly what we want. The following are
    the exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: When we want to subclass an immutable class definition. We'll dig into that
    later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we need to create a metaclass. That's the subject of the next section,
    as it's fundamentally different from creating immutable objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of overriding `__init__()` when creating a subclass of a built-in immutable
    type, we have to tweak the object at the time of the creation by overriding `__new__()`.
    The following is an example class definition that shows us the proper way to extend
    `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we set the value of an attribute during the creation
    of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet gives us a floating-point value with attached units
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Note that an expression such as `speed * 10` does not create a `Float_Units`
    object. This class definition inherits all the operator special methods from `float`;
    the `float` arithmetic special methods all create `float` objects. Creating `Float_Units`
    objects is the subject of [Chapter 7](ch07.html "Chapter 7. Creating Numbers"),
    *Creating Numbers*.
  prefs: []
  type: TYPE_NORMAL
- en: The __new__() method and metaclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other use case for the `__new__()` method as a part of a metaclass is to
    control how a class definition is built. This is distinct from how `__new__()`
    controls building an immutable object, shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: A metaclass builds a class. Once a class object has been built, the class object
    is used to build instances. The metaclass of all class definitions is `type`.
    The `type()` function is used to create class objects.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `type()` function can be used as a function to reveal the
    class of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a silly example of building a new, nearly useless class directly
    with `type()` as a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Once we've created this class, we can create objects of this `Useless` class.
    However, they won't do much because they have no methods or attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this newly-minted `Useless` class to create objects, for what little
    it''s worth. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: We can add attributes to the objects of this class. It does work, minimally,
    as an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is almost equivalent to using `types.SimpleNamespace` or defining a class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings up the important question: why would we mess with the way classes
    are defined in the first place?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is that some of the default features of a class aren''t *perfectly*
    applicable to some edge cases. We''ll talk about four situations where we might
    want to introduce a metaclass:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use a metaclass to preserve some information about the source text for
    a class. A class built by the built-in `type` uses `dict` to store the various
    methods and class-level attributes. As `dict` is inherently unordered, the attributes
    and methods appear in no particular order. It's extremely unlikely that they would
    appear in the order originally presented in the source. We'll show this in our
    first example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaclasses are used to create **Abstract Base Classes** (**ABC**) that we'll
    look at from Chapters 4 through 7\. An ABC relies on a metaclass `__new__()` method
    to confirm that the concrete subclass is complete. We'll introduce this in [Chapter
    4](ch04.html "Chapter 4. The ABCs of Consistent Design"), *The ABCs of Consistent
    Design*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaclasses can be used to simplify some aspects of object serialization. We'll
    look at this in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON,
    YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV,
    and XML*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a final and rather easy example, we'll look at a self-reference within a
    class. We'll design classes that reference a *master* class. This isn't a superclass-subclass
    relationship. It's a bunch of subclasses that are peer subclasses but have an
    association with one of its peer group as being the master. To be consistent with
    its peers, the master needs a reference to itself, something that's impossible
    without a metaclass. This will be our second example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaclass example 1 – ordered attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the canonical example in section 3.3.3, *Customizing Class Creation*,
    of *Python Language Reference*. This metaclass will record the order in which
    the attributes and method functions are defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipe has the following three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a metaclass. The `__prepare__()` and `__new__()` functions of that metaclass
    will change the way a target class is built, replacing a plain-old `dict` class
    with the `OrderedDict` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an abstract superclass that is based on the metaclass. This abstract
    class simplifies the inheritance for other classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create subclasses of the abstract superclass that benefit from the metaclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the example metaclass that will retain the order of the creation
    of the attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: This class extends the built-in default metaclass, `type`, with a new version
    of `__prepare__()` and `__new__()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `__prepare__()` method is executed prior to the creation of the class; its
    job is to create the initial namespace object into which the definitions will
    be added. This method could work on any other preparation prior to the execution
    of the class body that is being processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__new__()` static method is executed after the class body elements have
    been added to the namespace. It is given the class object, the class name, the
    superclass tuple, and the fully built namespace mapping object. This example is
    typical: it delegates the real work of `__new__()` to the superclass; the superclass
    of a metaclass is the built-in `type`; we use `type.__new__()` to create the default
    class object that can be tweaked.'
  prefs: []
  type: TYPE_NORMAL
- en: The `__new__()` method in this example adds an attribute, `_order`, into the
    class definition that shows us the original order of the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this metaclass instead of `type` when defining a new abstract superclass,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use this new abstract class as the superclass for any new classes
    that we define, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'When we look at the `Something` class, we see the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: We can consider exploiting this information to properly serialize the object
    or provide debugging information that is tied to the original source definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Metaclass example 2 – self-reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll look at an example that involves unit conversion. For example, units of
    length include meters, centimeters, inches, feet, and numerous other units. Managing
    unit conversions can be challenging. Superficially, we need a matrix of all possible
    conversion factors among all the various units. Feet to meters, feet to inches,
    feet to yards, meters to inches, meters to yards, and so on—every combination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Practically, however, we can do better than this if we define a standard unit
    for length. We can convert any unit to the standard and the standard to any other
    unit. By doing this, we can easily perform any possible conversion as a two-step
    operation, eliminating the complex matrix of all possible conversions: feet to
    standard, inches to standard, yards to standard, meters to standard.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we're not going to subclass `float` or `numbers.Number`
    in any way. Rather than binding the unit to the value, we'll allow each value
    to remain a simple number. This is an example of a **Flyweight** design pattern.
    The class doesn't define objects that contain the relevant value. The objects
    only contain the conversion factors.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative (binding units to values) leads to rather complex dimensional
    analysis. While interesting, it's rather complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll define two classes: `Unit` and `Standard_Unit`. We can easily be sure
    that each `Unit` class has a reference to its appropriate `Standard_Unit`. How
    can we ensure that each `Standard_Unit` class has a reference to itself? Self-referencing
    within a class definition is impossible because the class hasn''t been defined
    yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is our `Unit` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: The intent is that `Unit.value()` will convert a value in the given unit to
    the standard unit. The `Unit.convert()` method will convert a standard value to
    the given unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to work with units, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: The values created are built-in `float` values. For temperatures, the `value()`
    and `convert()` methods need to be overridden, as a simple multiplication doesn't
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `Standard_Unit`, we''d like to do something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: However, that won't work. `INCH` hasn't been defined within the body of `INCH`.
    The class doesn't exist until after the definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could, as a fallback, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: However, that's rather ugly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could define a decorator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: This decorator function could tweak the class definition to add an attribute.
    We'll return to this in [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins
    – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we''ll define a metaclass that can insert a circular reference into
    the class definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: This forces the class variable standard into the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: For most units, `SomeUnit.standard` references `TheStandardUnit` class. In parallel
    with that we'll also have `TheStandardUnit.standard` referencing `TheStandardUnit`
    class, also. This consistent structure among the `Unit` and `Standard_Unit` subclasses
    can help with writing the documentation and automating the unit conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `Standard_Unit` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: The unit conversion factor inherited from `Unit` is 1.0, so this class does
    nothing to the supplied values. It includes the special metaclass definition so
    that it will have a self-reference that clarifies that this class is the standard
    for this particular dimension of measurement.
  prefs: []
  type: TYPE_NORMAL
- en: As an optimization, we could override the `value()` and `convert()` methods
    to avoid the multiplication and division.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some sample class definitions for units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: We defined `INCH` as the standard unit. The other units' definitions will convert
    to and from inches.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve provided some documentation for each unit: the full name in the docstring
    and a short name in the `name` attribute. The conversion factor is automatically
    applied by the `convert()` and `value()` functions inherited from `Unit`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These definitions allow the following kind of programming in our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: We can set a particular measurement from a given value in inches and report
    that value in any other compatible unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'What the metaclass does is allow us to make queries like this from the unit-definition
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: These kinds of references can allow us to track all the various units of a given
    dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've looked at a number of *basic* special methods, which are essential features
    of any class that we design. These methods are already part of every class, but
    the defaults we inherit from the object may not match our processing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We'll almost always have a need to override `__repr__()`, `__str__()`, and `__format__()`.
    The default implementations of these methods aren't very helpful at all.
  prefs: []
  type: TYPE_NORMAL
- en: We rarely need to override `__bool__()` unless we're writing our own collection.
    That's the subject of [Chapter 6](ch06.html "Chapter 6. Creating Containers and
    Collections"), *Creating Containers and Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: We often need to override the comparison and `__hash__()` methods. The definitions
    are suitable for simple immutable objects but not at all appropriate for mutable
    objects. We may not need to write all the comparison operators; we'll look at
    the `@functools.total_ordering` decorator in [Chapter 8](ch08.html "Chapter 8. Decorators
    and Mixins – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*.
  prefs: []
  type: TYPE_NORMAL
- en: The other two *basic* special method names, `__new__()` and `__del__()`, are
    for more specialized purposes. Using `__new__()` to extend an immutable class
    is the most common use case for this method function.
  prefs: []
  type: TYPE_NORMAL
- en: 'These basic special methods, along with `__init__()`, will appear in almost
    every class definition we write. The rest of the special methods are for more
    specialized purposes; they fall into six discrete categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attribute Access**: These special methods implement what we see as `object.attribute`
    in an expression, `object.attribute` on the left-hand side of assignment, and
    `object.attribute` in a `del` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callables**: A special method implements what we see as a function applied
    to arguments, much like the built-in `len()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collections**: These special methods implement the numerous features of collections.
    This involves things such as `sequence[index]`, `mapping[key]`, and `set | set`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numbers**: These special methods provide the arithmetic operators and the
    comparison operators. We can use these methods to expand the domain of numbers
    that Python works with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contexts**: There are two special methods we''ll use to implement a context
    manager that works with the `with` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterators**: There are special methods that define an iterator. This isn''t
    essential, as generator functions handle this feature so elegantly. However, we''ll
    look at how we can design our own iterators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will address attributes, properties, and descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3. Attribute Access, Properties, and Descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object is a collection of features, including methods and attributes. The
    default behavior of the `object` class involves setting, getting, and deleting
    named attributes. We often need to modify this behavior to change the attributes
    available in an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will focus on the following five tiers of attribute access:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at built-in attribute processing, which is the simplest, but least
    sophisticated option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll review the `@property` decorator. A property extends the concept of an
    attribute to include the processing defined in method functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll look at how to make use of the lower-level special methods that control
    attribute access: `__getattr__()`, `__setattr__()`, and `__delattr__()`. These
    special methods allow us to build more sophisticated attribute processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also take a look at the `__getattribute__()` method, which provides more
    granular control over attributes. This can allow us to write very unusual attribute
    handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we'll take a look at descriptors. These are used to access an attribute,
    but they involve somewhat more complex design decisions. Descriptors are used
    heavily by Python under the hood to implement properties, static methods, and
    class methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we'll see how the default processing works in detail. We need
    to decide where and when to override the default behavior. In some cases, we want
    our attributes to do more than simply be instance variables. In other cases, we
    might want to prevent adding attributes. We may have attributes that have even
    more complex behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as we explore descriptors, we'll come to a much deeper understanding of
    how Python's internals work. We don't often need to use descriptors explicitly.
    We often use them implicitly, however, because they're the mechanism that implements
    a number of Python features.
  prefs: []
  type: TYPE_NORMAL
- en: Basic attribute processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, any class we create will permit the following four behaviors with
    respect to attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a new attribute by setting its value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To set the value of an existing attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the value of an attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To delete an attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can experiment with this using something as simple as the following code.
    We can create a simple, generic class and an object of that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code permits us to create, get, set, and delete attributes. We
    can easily create and get an attribute. The following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: We can add, change, and remove attributes. We will get exceptions if we try
    to get an otherwise unset attribute or delete an attribute that doesn't exist
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slightly better way to do this is using an instance of the class `types.SimpleNamespace`
    class. The feature set is the same, but we don''t need to create an extra class
    definition. We create an object of the `SimpleNamespace` class instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we can see that the same use cases work for a `SimpleNamespace`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: We can create attributes for this object. Any attempt to use an undefined attribute
    raises an exception. A `SimpleNamespace` class has different behavior from what
    we saw when we created an instance of the object class.. A simple instance of
    the object class doesn't permit the creation of new attributes; it lacks the internal
    `__dict__` structure that Python stores attributes and values in.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes and the __init__() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the time, we create an initial suite of attributes using the `__init__()`
    method of a class. Ideally, we provide default values for all the attributes in
    `__init__()`.
  prefs: []
  type: TYPE_NORMAL
- en: It's *not* required to provide all attributes in the `__init__()` method. Because
    of this, the presence or absence of an attribute can be used as part of an object's
    state.
  prefs: []
  type: TYPE_NORMAL
- en: An optional attribute pushes the edge of the envelope for class definition.
    It makes considerable sense for a class to have a well-defined set of attributes.
    Attributes can often be added (or removed) more clearly by creating a subclass
    or superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, optional attributes imply a kind of informal subclass relationship.
    Therefore, we bump up against Pretty Poor Polymorphism when we use optional attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a Blackjack game in which only a single split is permitted. If a hand
    is split, it cannot be resplit. There are several ways that we can model this:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create a subclass for `SplitHand` from the `Hand.split()` method. We
    won't show this in detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a status attribute on an object named `Hand`, which can be created
    from the `Hand.split()` method. Ideally, this is a Boolean value, but we can implement
    it as an optional attribute as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a version of `Hand.split()` that can detect splittable versus
    unsplittable hands via an optional attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: In effect, the `split()` method tests to see if there's a `split_count` attribute.
    If this attribute exists, then this is a split hand and the method raises an exception.
    If the `split_count` attribute does not exist, this is an initial deal, and splitting
    is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: An optional attribute has the advantage of leaving the `__init__()` method relatively
    uncluttered with status flags. It has the disadvantage of obscuring some aspects
    of object state. This use of a `try:` block to determine object state can be very
    confusing and should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Creating properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A property is a method function that appears (syntactically) to be a simple
    attribute. We can get, set, and delete property values similarly to how we can
    get, set, and delete attribute values. There's an important distinction here.
    A property is actually a method function and can process, rather than simply preserve,
    a reference to another object.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the level of sophistication, one other difference between properties
    and attributes is that we can't attach new properties to an existing object easily;
    however, we can add attributes to an object easily, by default. A property is
    not identical to simple attributes in this one respect.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to create properties. We can use the `@property` decorator
    or we can use the `property()` function. The differences are purely syntactic.
    We'll focus on the decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll take a look at two basic design patterns for properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eager calculation**: In this design pattern, when we set a value via a property,
    other attributes are also computed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy calculation**: In this design pattern, calculations are deferred until
    requested via a property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to compare the preceding two approaches to properties, we''ll split
    some common features of the `Hand` object into an abstract superclass, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined just some string representation methods and
    nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a subclass of `Hand`, where `total` is a lazy property that
    is computed only when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: The `Hand_Lazy` class initializes a `Hand` object with a list of the `Cards`
    object. The `total` property is a method that computes the total only when requested.
    Additionally, we defined some other properties to update the collection of cards
    in the hand. The `card` property can get, set, or delete cards in the hand. We'll
    take a look at these properties in setter and deleter properties section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a `Hand` object, `total` appears to be a simple attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: The total is computed lazily by rescanning the cards in the hand each time the
    total is requested. This can be an expensive overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Eagerly computed properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a subclass of `Hand`, where `total` is a simple attribute
    that''s computed eagerly as each card is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: In this case, each time a card is added, the `total` attribute is updated.
  prefs: []
  type: TYPE_NORMAL
- en: The other `card` property—the deleter—eagerly updates the `total` attribute
    whenever a card is removed. We'll take a look at the deleter in detail in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A client sees the same syntax between these two subclasses (`Hand_Lazy()` and
    `Hand_Eager()`) of `Hand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the client software simply uses the `total` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of using properties is that the syntax doesn''t have to change
    when the implementation changes. We can make a similar claim for getter/setter
    method functions. However, getter/setter method functions involve extra syntax
    that isn''t very helpful nor informative. The following are two examples, one
    of which is using a setter method and the other that is using the assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: The presence of the assignment operator (`=`) makes the intent very plain. Many
    programmers find it clearer to look for assignment statements than to look for
    setter method functions.
  prefs: []
  type: TYPE_NORMAL
- en: Setter and deleter properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous examples, we defined the `card` property to deal additional
    cards into an object of the `Hand` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since setter (and deleter) properties are created from the getter property,
    we must always define a getter property first using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to add a card to the hand with a simple statement like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: The preceding assignment statement has a disadvantage because it looks like
    it replaces all the cards with a single card. On the other hand, it also has an
    advantage because it uses simple assignment to update the state of a mutable object.
    We can use the `__iadd__()` special method to do this a little more cleanly. But,
    we'll wait until [Chapter 7](ch07.html "Chapter 7. Creating Numbers"), *Creating
    Numbers*, to introduce the other special methods.
  prefs: []
  type: TYPE_NORMAL
- en: For our current examples, there's no compelling reason to use a deleter property.
    Even without a compelling reason, there's still some use for a deleter. We could,
    however, make use of it to remove the last dealt card. This can be used as part
    of the process for splitting a hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will consider a version of `split()` that works like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method updates the given hand and returns a new hand. The following
    is an example of a hand being split:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Once we have two cards, we can use `split()` to produce the second hand. A card
    was removed from the initial hand.
  prefs: []
  type: TYPE_NORMAL
- en: This version of `split()` is certainly workable. However, it seems somewhat
    better to have the `split()` method return two fresh new `Hand` objects. That
    way, the old, presplit `Hand` instance can be used as a memento to gather statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Using special methods for attribute access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll look at the three canonical special methods for attribute access: `__getattr__()`,
    `__setattr__()`, and `__delattr__()`. Additionally, we''ll acknowledge the `__dir__()`
    method to reveal attribute names. We''ll defer `__getattribute__()` to the next
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default behavior shown in the first section is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `__setattr__()` method will create and set attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__getattr__()` method will do two things. Firstly, if an attribute already
    has a value, `__getattr__()` is not used; the attribute value is simply returned.
    Secondly, if the attribute does not have a value, then `__getattr__()` is given
    a chance to return a meaningful value. If there is no attribute, it must raise
    an `AttributeError` exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__delattr__()` method deletes an attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__dir__()` method returns a list of attribute names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__getattr__()` method function is only one step in a larger process; it
    is only used if the attribute is otherwise unknown. If the attribute is a known
    attribute, this method is not used. The `__setattr__()` and `__delattr__()` methods
    do not have built-in processing. These methods don't interact with additional
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a number of design choices for controlling attribute access. These
    follow our three essential design choices to extend, wrap, or invent. The design
    choices are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can extend a class, making it almost immutable by overriding `__setattr__()`
    and `__delattr__()`. We can also replace the internal `__dict__` with `__slots__`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can wrap a class and delegate attribute access to the object (or composite
    of objects) being wrapped. This may involve overriding all three of these methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can implement property-like behaviors in a class. Using these methods, we
    can assure that all property processing is centralized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create lazy attributes where the values aren't (or can't be) computed
    until they're needed. We may have an attribute that doesn't have a value until
    it's read from a file, database, or network. This is common use for `__getattr__()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can have eager attributes, where setting an attribute creates values in other
    attributes automagically. This is done via overrides to `__setattr__()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We won''t look at all of these alternatives. Instead, we''ll focus on the two
    most commonly used techniques: extending and wrapping. We''ll create immutable
    objects and look at other ways to eagerly compute attribute values.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating immutable objects with __slots__
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we are not able to set an attribute or create a new one, then the object
    is immutable. The following is what we''d like to see in interactive Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows that we are not allowed to change an attribute or add
    one to this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make two changes to a class definition for this to work. We''ll
    omit much of the class and focus on just the three features that make an object
    immutable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'We made three significant changes:'
  prefs: []
  type: TYPE_NORMAL
- en: We set `__slots__` to the names of only the allowed attributes. This turns off
    the internal `__dict__` feature of the object and limits us to just the attributes
    and no more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined `__setattr__()` to raise an exception rather than do anything useful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined `__init__()` to use the superclass version of `__setattr__()` so
    that values can be properly set in spite of the absence of a working `__setattr__()`
    method in this class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With some care, we can bypass the immutability feature if we work at it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: That brings us to a question. "How can we prevent an "evil" programmer from
    bypassing the immutability feature?" The question is silly. We can't stop the
    evil programmer. Another equally silly question is, "Why would some evil programmer
    write all that code to circumvent immutability?". We can't stop the evil programmer
    from doing evil things.
  prefs: []
  type: TYPE_NORMAL
- en: If this imaginary programmer doesn't like immutability in a class, they can
    modify the definition of the class to remove the redefinition of `__setattr__()`.
    The point of an immutable object like this is to guarantee `__hash__()` returning
    a consistent value and not to prevent people from writing rotten code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Don''t abuse __slots__**'
  prefs: []
  type: TYPE_NORMAL
- en: The `__slots__` feature is intended primarily to save memory by limiting the
    number of attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating immutable objects as a tuple subclass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also create an immutable object by making our `Card` property a subclass
    of `tuple` and an override to `__getattr__()`. In this case, we'll translate `__getattr__(name)`
    requests to `self[index]` requests. As we'll see in [Chapter 6](ch06.html "Chapter 6. Creating
    Containers and Collections"), *Creating Containers and Collections*, `self[index]`
    is implemented by `__getitem__(index)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a small extension to the built-in `tuple` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we simply raised a simple `AttributeError` exception rather
    than providing detailed error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the preceding code, we see the following kinds of interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: We can't change the value of a card easily. However, we can still tweak `d.__dict__`
    to introduce *additional* attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Is this really necessary?**'
  prefs: []
  type: TYPE_NORMAL
- en: This is, perhaps, too much work to simply assure that an object isn't accidentally
    misused. Practically, we're more interested in the diagnostic information available
    from an exception and traceback than we are in a super-secure immutable class.
  prefs: []
  type: TYPE_NORMAL
- en: Eagerly computed attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can define an object where attributes are computed eagerly as soon as possible
    after a value is set. This object optimizes access by doing a computation once
    and leaving the result to be used multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: We're able to define a number of property setters to do this. However, a lot
    of property setters, each of which compute a number of attributes, can get wordy
    for a complex calculation.
  prefs: []
  type: TYPE_NORMAL
- en: We can centralize the attribute processing. In the following example, we'll
    use a few tweaks to extend Python's internal `dict` type. The advantage of extending
    `dict` is that it works well with the `format()` method of a string. Also, we
    don't have to worry much about setting extra attribute values that are otherwise
    ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''d like something that looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set the values in this `RateTimeDistance` object. Additional attributes
    are computed as soon as sufficient data is present. We can do this either all
    at once, as shown earlier, or in stages, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the extension to the built-in `dict` . We''ve extended the
    essential mapping that `dict` implements to compute a missing attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: The `dict` type uses `__init__()` to populate the internal dictionary, then
    tries to solve if enough data is present. It uses `__setattr__()` to add new items
    to the dictionary. It also attempts to solve the equation each time a value is
    set.
  prefs: []
  type: TYPE_NORMAL
- en: In `__getattr__()`, we use `None` to indicate a missing value from the equation.
    This allows us to set an attribute to `None` to indicate that it is a missing
    value, and this will force the solution to look for this value. For example, we
    might do this based on user inputs or a network request where all parameters were
    given a value but one variable was set to `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we can't set attribute values inside this class definition easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: If we were to write the preceding code snippet, we'd have infinite recursions
    between `__setattr__()` and `_solve()`. When we used `self['distance']` in the
    example, we avoided the recursive call of `__setattr__()`.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to note that once all three values are set, this object
    can't be changed to provide new solutions easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t simply set a new value for `rate` and compute a new value for `time`
    while leaving `distance` unchanged. To tweak this model, we need to both clear
    one variable and set a new value for another variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Here, we cleared `time` and changed `rate` to get a new solution for `time`
    using the established value for `distance`.
  prefs: []
  type: TYPE_NORMAL
- en: We could design a model that tracked the order that the variables were set in;
    this model could save us from having to clear one variable before setting another
    to recompute a related result.
  prefs: []
  type: TYPE_NORMAL
- en: The __getattribute__() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An even lower level attribute processing is the `__getattribute__()` method.
    The default implementation attempts to locate the value as an existing attribute
    in the internal `__dict__` (or `__slots__`). If the attribute is not found, it
    calls `__getattr__()` as a fallback. If the value located is a descriptor (see
    in the following *Creating descriptors* section), then it processes the descriptor.
    Otherwise, the value is simply returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'By overriding this method, we can perform any of the following kinds of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: We can effectively prevent access to attributes. This method, by raising an
    exception instead of returning a value, can make an attribute more secret than
    if we were to merely use the leading underscore (`_`) to mark a name as private
    to the implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can invent new attributes similarly to how `__getattr__()` can invent new
    attributes. In this case, however, we can bypass the default lookup done by the
    default version of `__getattribute__()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can make attributes perform unique and different tasks. This might make the
    program very difficult to understand or maintain. This could be a terrible idea,
    also.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can change the way descriptors behave. While technically possible, changing
    a descriptor's behavior sounds like a terrible idea.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we implement the `__getattribute__()` method, it's important to note that
    there cannot be any internal attribute access in the method's body. If we attempt
    to get the value for `self.name`, it will lead to infinite recursions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `__getattribute__()` method cannot give any simple `self.name` attribute
    access; it will lead to infinite recursions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get attribute values within the `__getattribute__()` method, we
    must explicitly refer to the base method defined in `object`, as shown in the
    following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'We could, for example, revise our immutable class to use `__getattribute__()`
    and prevent access to the internal `__dict__` attribute. The following is a class
    that conceals all the names beginning with the underscore character (`_`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve overridden `__getattribute__()` to raise an attribute error on private
    names as well as Python''s internal names. This has a microscopic advantage over
    the previous example: we are not allowed to tweak the object at all. We''ll see
    an example of an interaction with an instance of this class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an object of this class being mutated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: As general advice, it's rarely a good idea to mess with `__getattribute__()`.
    The default method is quite sophisticated, and almost everything we need is available
    as a property or as a change to `__getattr__()`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A descriptor is a class that mediates attribute access. The descriptor class
    can be used to get, set, or delete attribute values. Descriptor objects are built
    inside a class at class definition time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The descriptor design pattern has two parts: an **owner class** and the **attribute
    descriptor** itself. The owner class uses one or more descriptors for its attributes.
    A descriptor class defines some combination of get, set, and delete methods. An
    instance of the descriptor class will be an attribute of the owner class.'
  prefs: []
  type: TYPE_NORMAL
- en: Properties are based on the method functions of the owner class. A descriptor,
    unlike a property, is an instance of a class different from the owning class.
    Therefore, descriptors are often reusable, generic kinds of attributes. The owning
    class can have multiple instances of each descriptor class to manage attributes
    with similar behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other attributes, descriptors are created at the class level. They're
    not created within the `__init__()` initialization. While descriptor values can
    be set during initialization, descriptors are generally built as part of the class,
    outside any method functions.
  prefs: []
  type: TYPE_NORMAL
- en: Each descriptor object will be an instance of a descriptor class bound to a
    distinct class-level attribute name when the owner class is defined.
  prefs: []
  type: TYPE_NORMAL
- en: To be recognized as a descriptor, a class must implement any combination of
    the following three methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`Descriptor.__get__( self, instance, owner ) → object`: In this method, the
    `instance` parameter is the `self` variable of the object being accessed. The
    `owner` parameter is the owning class object. If this descriptor is invoked in
    a class context, the `instance` parameter will get a `None` value. This must return
    the value of the descriptor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Descriptor.__set__( self, instance, value )`: In this method, the `instance`
    parameter is the `self` variable of the object being accessed. The `value` parameter
    is the new value that the descriptor needs to be set to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Descriptor.__delete__( self, instance )`: In this method, the `instance` parameter
    is the `self` variable of the object being accessed. This method of the descriptor
    must delete this attribute''s value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, a descriptor class will also need an `__init__()` method function
    to initialize the descriptor's internal state.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two species of descriptors based on the methods defined, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A nondata descriptor**: This kind of descriptor defines `__set__()` or `__delete__()`
    or both. It cannot define `__get__()`. The nondata descriptor object will often
    be used as part of some larger expression. It might be a callable object, or it
    might have attributes or methods of its own. An immutable nondata descriptor must
    implement `__set__()` but may simply raise `AttributeError`. These descriptors
    are slightly simpler to design because the interface is more flexible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A data descriptor**: This descriptor defines `__get__()` at a minimum. Usually,
    it defines both `__get__()` and `__set__()` to create a mutable object. The descriptor
    can''t define any further attributes or methods of this object since the descriptor
    will largely be invisible. A reference to an attribute that has a value of a data
    descriptor is delegated to the `__get__()`, `__set__()`, or `__delete__()` methods
    of the descriptor. These can be tricky to design, so we''ll look at them second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a wide variety of use cases for descriptors. Internally, Python uses
    descriptors for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, the methods of a class are implemented as descriptors. These
    are nondata descriptors that apply the method function to the object and the various
    parameter values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `property()` function is implemented by creating a data descriptor for the
    named attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class method or static method is implemented as a descriptor; this applies
    to the class instead of an instance of the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we look at object-relational mapping in [Chapter 11](ch11.html "Chapter 11. Storing
    and Retrieving Objects via SQLite"), *Storing and Retrieving Objects via SQLite*,
    we'll see that many of the ORM class definitions make heavy use of descriptors
    to map Python class definitions to SQL tables and columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we think about the purposes of a descriptor, we must also examine the three
    common use cases for the data that a descriptor works with as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **descriptor object** has, or acquires, the data. In this case, the descriptor
    object's `self` variable is relevant and the descriptor is stateful. With a data
    descriptor, the `__get__()` method returns this internal data. With a nondata
    descriptor, the descriptor has other methods or attributes to access this data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **owner instance** contains the data. In this case, the descriptor object
    must use the `instance` parameter to reference a value in the owning object. With
    a data descriptor, the `__get__()` method fetches the data from the instance.
    With a nondata descriptor, the descriptor's other methods access the instance
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **owner class** contains the relevant data. In this case, the descriptor
    object must use the `owner` parameter. This is commonly used when the descriptor
    implements a static method or class method that applies to the class as a whole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll take a look at the first case in detail. We'll look at creating a data
    descriptor with `__get__()` and `__set__()` methods. We'll also look at creating
    a nondata descriptor without a `__get__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The second case (the data in the owning instance) shows what the `@property`
    decorator does. The possible advantage that a descriptor has over a conventional
    property is that it moves the calculations into the descriptor class from the
    owner class. This tends to fragment class design and is probably not the best
    approach. If the calculations are truly of epic complexity, then a strategy pattern
    might be better.
  prefs: []
  type: TYPE_NORMAL
- en: The third case shows how the `@staticmethod` and `@classmethod` decorators are
    implemented. We don't need to reinvent those wheels.
  prefs: []
  type: TYPE_NORMAL
- en: Using a nondata descriptor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We often have small objects with a few tightly bound attribute values. For this
    example, we'll take a look at numeric values that are bound up with units of measure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple nondata descriptor class that lacks a `__get__()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: This class defines a simple pair of values, one that is mutable (the value)
    and another that is effectively immutable (the unit).
  prefs: []
  type: TYPE_NORMAL
- en: When this descriptor is accessed, the descriptor object itself is made available,
    and other methods or attributes of the descriptor can then be used. We can use
    this descriptor to create classes that manage measurements and other numbers associated
    with physical units.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class that does rate-time-distance calculations eagerly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: As soon as the object is created and the attributes loaded, the missing value
    is computed. Once computed, the descriptor can be examined to get the value or
    the unit's name. Additionally, the descriptor has a handy response to `str()`
    and formatting requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an interaction between a descriptor and the `RTD_1` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: We created an instance of `RTD_1` with `rate` and `distance` arguments. These
    were used to evaluate the `__set__()` methods of the `rate` and `distance` descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: When we asked for `str(m1)`, this evaluated the overall `__str__()` method of
    `RTD_1` that, in turn, used the `__format__()` method of the rate, time, and distance
    descriptors. This provided us with numbers with units attached to them.
  prefs: []
  type: TYPE_NORMAL
- en: We can also access the individual elements of a descriptor since nondata descriptors
    don't have `__get__()` and don't return their internal values.
  prefs: []
  type: TYPE_NORMAL
- en: Using a data descriptor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A data descriptor is somewhat trickier to design because it has such a limited
    interface. It must have a `__get__()` method and it can only have `__set__()`
    or `__delete__()`. This is the entire interface: from one to three of these methods
    and no other methods. Introducing an additional method means that Python will
    not recognize the class as being a proper data descriptor.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll design an overly simplistic unit conversion schema using descriptors that
    can do appropriate conversions in their `__get__()` and `__set__()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a superclass of a descriptor of units that will do conversions
    to and from a standard unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: This class does simple multiplications and divisions to convert standard units
    to other non-standard units and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: With this superclass, we can define some conversions from a standard unit. In
    the previous case, the standard unit is KPH (kilometers per hour).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two conversion descriptors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'The inherited methods are perfectly useful. The only thing that changes is
    the conversion factor. These classes can be used to work with values that involve
    unit conversion. We can work with MPH''s or knots interchangeably. The following
    is a unit descriptor for a standard unit, kilometers per hour:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: This class represents a standard, so it doesn't do any conversion. It uses a
    private variable in the instance to save the standard value for speed in KPH.
    Avoiding any arithmetic conversion is simply a technique of optimization. Avoiding
    any reference to one of the public attributes is essential to avoiding infinite
    recursions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class that provides a number of conversions for a given
    measurement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Each of the class-level attributes is a descriptor for a different unit. The
    get and set methods of the various descriptors will do appropriate conversions.
    We can use this class to convert speeds among a variety of units.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an interaction with the `Measurement` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: We created an object of the `Measurement` class by setting various descriptors.
    In the first case, we set the knots descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: When we displayed the value as a large string, each of the descriptor's `__get__()`
    methods was used. These methods fetched the internal `kph` attribute value from
    the owning object, applied a conversion factor, and returned the resulting value.
  prefs: []
  type: TYPE_NORMAL
- en: The `kph` attribute also uses a descriptor. This descriptor does not do any
    conversion; however, it simply returns a private value cached in the owning object.
    The `KPH` and `Knots` descriptors require that the owning class implement a `kph`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Summary, design considerations, and trade-offs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we looked at several ways to work with an object's attributes.
    We can use the built-in features of the `object` class and get and set attribute
    values. We can define properties to modify how attributes behave.
  prefs: []
  type: TYPE_NORMAL
- en: If we want more sophistication, we can tweak the underlying special method implementations
    for `__getattr__()`, `__setattr__()`, `__delattr__()`, or `__getattribute__()`.
    These allow us very fine-grained control over attribute behaviors. We walk a fine
    line when we touch these methods because we can make fundamental (and confusing)
    changes to Python's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, Python uses descriptors to implement features such as method functions,
    static method functions, and properties. Many of the cool use cases for descriptors
    are already first-class features of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers coming from other languages (particularly Java and C++) usually
    have the urge to try to make all attributes private and write extensive getter
    and setter functions. This kind of coding is necessary for languages where type
    definitions are statically compiled in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, it''s considerably simpler to treat all attributes as public. This
    means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: They should be well documented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They should properly reflect the state of the object; they shouldn't be temporary
    or transient values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the rare case of an attribute that has a potentially confusing (or brittle)
    value, a single leading underscore character (`_`) marks the name as "not part
    of the defined interface." It's not really private.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to think of private attributes as a nuisance. Encapsulation isn't
    broken by the lack of complex privacy mechanisms in the language; it is broken
    by bad design.
  prefs: []
  type: TYPE_NORMAL
- en: Properties versus attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most cases, attributes can be set outside a class with no adverse consequences.
    Our example of the `Hand` class shows this. For many versions of the class, we
    can simply append to `hand.cards`, and the lazy computation of `total` via a property
    will work perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where the changing of an attribute should lead to consequential changes
    in other attributes, some more sophisticated class design is required:'
  prefs: []
  type: TYPE_NORMAL
- en: A method function may clarify the state change. This will be necessary when
    multiple parameter values are required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A property setter may be clearer than a method function. This will be a sensible
    option when a single value is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use in-place operators. We'll defer this until [Chapter 7](ch07.html
    "Chapter 7. Creating Numbers"), *Creating Numbers*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no strict rule. In this case, where we need to set a single parameter
    value, the distinction between a method function and a property is entirely one
    of API syntax and how well that communicates the intent.
  prefs: []
  type: TYPE_NORMAL
- en: For computed values, a property allows lazy computation, while an attribute
    requires eager computation. This devolves to a performance question. The benefits
    of lazy versus eager computation are based on the expected use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Designing with descriptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many examples of descriptors are already part of Python. We don't need to reinvent
    properties, class methods, or static methods.
  prefs: []
  type: TYPE_NORMAL
- en: The most compelling cases for creating new descriptors relate to mapping between
    Python and something non-Python. Object-relational database mapping, for example,
    requires a great deal of care to ensure that a Python class has the right attributes
    in the right order to match a SQL table and columns. Also, when mapping to something
    outside Python, a descriptor class can handle encoding and decoding data or fetching
    the data from external sources.
  prefs: []
  type: TYPE_NORMAL
- en: When building a web service client, we might consider using descriptors to make
    web service requests. The `__get__()` method, for example, might turn into an
    HTTP GET request, and the `__set__()` method might turn into an HTTP PUT request.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, a single request may populate the data of several descriptors.
    In this case, the `__get__()` method would check the instance cache and return
    that value before making an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many data descriptor operations are more simply handled by properties. This
    provides us with a place to start: to write properties first. If the property
    processing becomes too expansive or complex, then we can switch to descriptors
    to refactor the class.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapter, we'll look closely at the **ABC**s (**Abstract Base Classes**)
    that we'll exploit in Chapters 5, 6, and 7\. These ABCs will help us define classes
    that integrate nicely with existing Python features. They will also allow us to
    create class hierarchies that enforce consistent design and extension.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4. The ABCs of Consistent Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python Standard Library provides abstract base classes for a number of features
    of containers. It provides a consistent framework for the built-in container classes,
    such as `list`, `map`, and `set`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the library provides abstract base classes for numbers. We can
    use these classes to extend the suite of numeric classes available in Python.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look in general at the abstract base classes in the `collections.abc`
    module. From there, we can focus on a few use cases that will be the subject of
    detailed examination in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three design strategies: Wrap, Extend, and Invent. We''ll look at the
    general concepts behind the various containers and collections that we might want
    to wrap or extend. Similarly, we''ll look at the concepts behind the numbers that
    we might want to implement.'
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to assure that our application classes integrate seamlessly with
    existing Python features. If we create a collection, for example, it's appropriate
    to have that collection also create an iterator by implementing `__iter__()`.
    A collection that implements `__iter__()` will work seamlessly with a `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract base classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core of the **Abstract Base Class** (**ABC**) definition is defined in a
    module named `abc`. This contains the required decorators and metaclasses to create
    abstractions. Other classes rely on these definitions.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.2, the abstract base classes for collections were buried in `collections`.
    In Python 3.3, however, the abstract base classes have been split into a separate
    submodule named `collections.abc`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at the `numbers` module, because it contains ABCs for numeric
    types. There are abstract base classes for I/O in the `io` module too.
  prefs: []
  type: TYPE_NORMAL
- en: We'll focus on Python Version 3.3\. The definitions will work very similarly
    for Python 3.2, but the `import` statement will change slightly to reflect the
    flatter library structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'An abstract base class has a number of features, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract means that these classes don't contain all of the method definitions
    required to work completely. For it to be a useful subclass, we will need to provide
    some method definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base means that other classes will use it as a superclass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract class provides some definitions for method functions. Most importantly,
    the abstract base classes provide the signatures for the missing method functions.
    A subclass must provide the right methods to create a concrete class that fits
    the interface defined by the abstract class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The features of the abstract base classes include the following ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use them to define a consistent set of base classes for Python's internal
    classes and our customized application classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use them to create some common, reusable abstractions that we can use
    in our applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use them to support the proper inspection of a class to determine what
    it does. This allows better collaboration among library classes and new classes
    in our applications. In order to do an inspection properly, it helps to have the
    formal definition of concepts such as "container" and "number".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without abstract base classes (that is, in the "bad old days") a container may,
    or may not, have provided all the features of a `Sequence` class consistently.
    This often leads to a class being almost a sequence or sequence-like. This, in
    turn, leads to odd inconsistencies and kludgy workarounds for a class that didn't
    quite provide all the features of a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: With an abstract base class, you can assure that an application's given class
    will have the advertised features. If it lacks a feature, the presence of an undefined
    abstract method will make the class unusable for building object instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use ABCs in several situations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll use ABC's as superclasses when defining our own classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use ABC's within a method to confirm that an operation is possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use ABC's within a diagnostic message or exception to indicate why an
    operation can't work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the first use case, we may write modules with code that looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Our `SomeApplicationClass` is defined to be a `Callable` class. It must then
    implement the specific methods required by `Callable`, or we will not be able
    to create an instance.
  prefs: []
  type: TYPE_NORMAL
- en: A function is a concrete example of a `Callable` class. The abstraction is a
    class that defines the `__call__()` method. We'll look at `Callables` classes
    in the following section and in [Chapter 5](ch05.html "Chapter 5. Using Callables
    and Contexts"), Using *Callables and Contexts*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second use case, we may write methods with code that looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Our `some_method()` requires for the `other` argument to be a subclass of `Iterator`.
    If the `other` argument can't pass this test, we get an exception. A common alternative
    to `assert` is an `if` statement that raises `TypeError`, which may be more meaningful.
    We'll see this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the third use case, we might have something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we wrote a diagnostic warning that shows the base classes for
    a given object. This may help debug the problem with the application design.
  prefs: []
  type: TYPE_NORMAL
- en: Base classes and polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll flirt with the idea of **Pretty Poor Polymorphism**.
    Inspection of argument values is a Python programming practice that should be
    isolated to a few special cases.
  prefs: []
  type: TYPE_NORMAL
- en: Well-done polymorphism follows what is sometimes called the **Liskov Substitution
    Principle**. Polymorphic classes can be used interchangeably. Each polymorphic
    class has the same suite of properties. For more information, visit [http://en.wikipedia.org/wiki/Liskov_substitution_principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle).
  prefs: []
  type: TYPE_NORMAL
- en: Overusing `isinstance()` to distinguish between the types of arguments can lead
    to a needlessly complex (and slow) program. Instance comparisons are made all
    the time, but errors are generally only introduced through software maintenance.
    Unit testing is a far better way to find programming errors than verbose type-checking
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Method functions with lots of `isinstance()` methods can be a symptom of a poor
    (or incomplete) design of polymorphic classes. Rather than having type-specific
    processing outside of a class definition, it's often better to extend or wrap
    classes to make them more properly polymorphic and encapsulate the type-specific
    processing within the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'One good use of the `isinstance()` method is to create diagnostic messages.
    A simple approach is to use the `assert` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'This will raise an `AssertionError` exception to indicate that there''s a problem.
    This has the advantage that it is short and to the point. However, it has two
    disadvantages: assertions can be silenced, and it would probably be better to
    raise a `TypeError` for this. The following example might be better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code has the advantage that it raises the correct error. However,
    it has the disadvantage that it is long winded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more Pythonic approach is summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"It''s better to ask for forgiveness than to ask for permission."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is generally taken to mean that we should minimize the upfront testing
    of arguments (asking permission) to see if they're the correct type. Argument-type
    inspections are rarely of any tangible benefit. Instead, we should handle the
    exceptions appropriately (asking forgiveness).
  prefs: []
  type: TYPE_NORMAL
- en: What's best is to combine diagnostic information with the exception in the unlikely
    event that an inappropriate type is used and somehow passed through unit testing
    into operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is often what''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: The `isinstance()` method assumes that `some_argument` is a proper instance
    of a `collections.abc.Container` class and will respond to the `in` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In the unlikely event that someone changes the application and `some_argument`
    is now of the wrong class, the application will write a diagnostic message and
    crash with a `TypeError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Callables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python's definition of **callable object** includes the obvious function definitions
    created with the `def` statement.
  prefs: []
  type: TYPE_NORMAL
- en: It also includes, informally, any class with a `__call__()` method. We can see
    several examples of this in *Python 3 Object Oriented Programming*, *Dusty Phillips*,
    *Packt Publishing*. For it to be more formal, we should make every callable class
    definition a proper subclass of `collections.abc.Callable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at any Python function, we see the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in `abs()` function is a proper instance of `collections.abc.Callable`.
    This is also true for the functions we define. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Every function reports itself as `Callable`. This simplifies the inspection
    of an argument value and helps write meaningful debugging messages.
  prefs: []
  type: TYPE_NORMAL
- en: We'll take a look at callables in detail in [Chapter 5](ch05.html "Chapter 5. Using
    Callables and Contexts"), *Using Callables and Contexts*.
  prefs: []
  type: TYPE_NORMAL
- en: Containers and collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `collections` module defines a number of collections above and beyond the
    built-in container classes. The container classes include `namedtuple()`, `deque`,
    `ChainMap`, `Counter`, `OrderedDict`, and `defaultdict`. All of these are examples
    of classes based on ABC definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a quick interaction to show how we can inspect collections
    to see the methods they will support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: We can inspect the simple `dict` class to see that it follows the basic mapping
    protocol and will support the required methods.
  prefs: []
  type: TYPE_NORMAL
- en: We can inspect a `defaultdict` collection to confirm that it is also a mapping.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a new kind of container, we can do it informally. We can create
    a class that has all of the right special methods. However, we aren't *required*
    to make a formal declaration that it's a certain kind of container.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s more clear (and more reliable) to use a proper ABC as the base class
    for one of our application classes. The additional formality has the following
    two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It advertises what our intention was to people reading (and possibly using or
    maintaining) our code. When we make a subclass of `collections.abc.Mapping`, we're
    making a very strong claim about how that class will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates some diagnostic support. If we somehow fail to implement all of the
    required methods properly, we can't create instances of the abstract base class.
    If we can't run the unit tests because we can't create instances of an object,
    then this indicates a serious problem that needs to be fixed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire family tree of built-in containers is reflected in the abstract base
    classes. Lower-level features include `Container`, `Iterable`, and `Sized`. These
    are a part of higher-level constructs; they require a few specific methods, particularly
    `__contains__()`, `__iter__()`, and `__len__()`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Higher-level features include the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sequence` and `MutableSequence`: These are the abstractions of the concrete
    classes `list` and `tuple`. Concrete sequence implementations also include `bytes`
    and `str`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MutableMapping`: This is the abstraction of `dict`. It extends `Mapping`,
    but there''s no built-in concrete implementation of this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set` and `MutableSet`: These are the abstractions of the concrete classes,
    `frozenset` and `set`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows us to build new classes or extend existing classes and maintain
    a clear and formal integration with the rest of Python's built-in features.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at containers and collections in detail in [Chapter 6](ch06.html
    "Chapter 6. Creating Containers and Collections"), *Creating Containers and Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating new numbers (or extending existing numbers), we'll turn to the
    `numbers` module. This module contains the abstract definitions of Python's built-in
    numeric types. These types form a tall, narrow hierarchy, from the simplest to
    the most elaborate. In this case, simplicity (and elaboration) refers to the collection
    of methods available.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an abstract base class named `numbers.Number` that defines all of
    the numeric and number-like classes. We can see that this is true with interactions
    like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, integer and float values are subclasses of the abstract `numbers.Number`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The subclasses include `numbers.Complex`, `numbers.Real`, `numbers.Rational`,
    and `numbers.Integral`. These definitions are roughly parallel mathematical thoughts
    on the various classes of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `decimal.Decimal` class, however, doesn''t fit this hierarchy extremely
    well. We can check the relationships using the `issubclass()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: It shouldn't be too surprising that `Decimal` doesn't fit the established number
    types well. For a concrete implementation of `numbers.Rational`, look at the `fractions`
    module. We'll look at the various kinds of numbers in detail in [Chapter 7](ch07.html
    "Chapter 7. Creating Numbers"), *Creating Numbers*.
  prefs: []
  type: TYPE_NORMAL
- en: Some additional abstractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at some other interesting ABC classes that are less widely extended.
    It's not that these abstractions are less widely used. It's more that the concrete
    implementations rarely need extensions or revisions.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at the iterator, which is defined by `collections.abc.Iterator`.
    We'll also look at the unrelated idea of a context manager. This isn't defined
    with the same formality as other ABC classes. We'll look at this in detail in
    [Chapter 5,](ch05.html "Chapter 5. Using Callables and Contexts") *Using Callables
    and Contexts*.
  prefs: []
  type: TYPE_NORMAL
- en: The iterator abstraction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Iterators are created implicitly when we use an iterable container with a `for`
    statement. We rarely care about the iterator itself. And the few times we do care
    about the iterator, we rarely want to extend or revise the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can expose the implicit iterators that Python uses via the `iter()` function.
    We can interact with an iterator in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: We created an iterator over a list object and then stepped through the values
    in that iterator using the `next()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The final `isinstance()` expression confirmed that this iterator object is an
    instance of `collections.abc.Iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, we'll work with iterators that have been created by the collection
    classes themselves. However, when we branch out and build our own collection classes
    or extend a collection class, we may also need to build a unique iterator. We'll
    look at iterators in [Chapter 6](ch06.html "Chapter 6. Creating Containers and
    Collections"), *Creating Containers and Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: Contexts and context managers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A context manager is used with the `with` statement. We''re working with a
    context manager when we write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding case, `function(arg)` creates the context manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'One very commonly used context manager is a file. When we open a file, we should
    define a context that will also automatically close the file. Consequently, we
    should almost always use a file in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the `with` statement, we're assured that the file will be closed
    properly. The `contextlib` module provides several tools for building proper context
    managers. Rather than providing an abstract base class, this library offers decorators,
    which will transform simple functions into context managers, as well as a `contextlib.ContextDecorator`
    base class, which can be used extended to build a class that is a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at context managers in [Chapter 5](ch05.html "Chapter 5. Using Callables
    and Contexts"), *Using Callables and Contexts*.
  prefs: []
  type: TYPE_NORMAL
- en: The abc module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core method of creating ABCs is defined in the `abc` module. This module
    includes the `ABCMeta` class that provides several features.
  prefs: []
  type: TYPE_NORMAL
- en: First, the `ABCMeta` class assures that abstract classes can't be instantiated.
    A subclass that provides all of the required definitions, however, can be instantiated.
    The metaclass will invoke the abstract class's special method, `__subclasshook__()`,
    as a part of processing `__new__()`. If that method returns `NotImplemented`,
    then an exception will be raised to show that the class didn't define all the
    required methods.
  prefs: []
  type: TYPE_NORMAL
- en: Second, it provides definitions for `__instancecheck__()` and `__subclasscheck__()`.
    These special methods implement the `isinstance()` and `issubclass()` built-in
    functions. They provide the checks to confirm that an object (or a class) belongs
    to the proper ABC. This includes a cache of subclasses to speed up the testing.
  prefs: []
  type: TYPE_NORMAL
- en: The `abc` module also includes a number of decorators for creating abstract
    method functions that must be provided by a concrete implementation of the abstract
    base class. The most important of these is the `@abstractmethod` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to create a new abstract base class, we would use something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: This class includes `ABCMeta` as its metaclass; it also uses the `__subclasshook__()`
    method, which checks for completeness. These provide the core features of an abstract
    class.
  prefs: []
  type: TYPE_NORMAL
- en: This abstraction uses the `abstractmethod` decorator to define three abstract
    methods. Any concrete subclass must define these in order to be a complete implementation
    of the abstract base class.
  prefs: []
  type: TYPE_NORMAL
- en: The `__subclasshook__` method requires that all of the three abstract methods
    be provided by a subclass. This is, perhaps, heavy-handed, since a super-simple
    betting strategy shouldn't have to provide methods for counting wins and losses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subclass hook relies on two internal features of a Python class definition:
    the `__dict__` attribute and the `__mro__` attribute. The `__dict__` attribute
    is where the method names and attribute names are recorded for a class definition.
    This is essentially the body of the class. The `__mro__` attribute is the method
    resolution order. This is the sequence of the superclasses of this class. Since
    Python uses multiple inheritance, there can be many superclasses, and the order
    of these superclasses determines the precedence for resolving names.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a concrete class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code can't be built because it doesn't provide necessary implementations
    for all three methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what happens when we try to build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message indicates that the concrete class is incomplete. The following
    is a better concrete class that passes the completeness test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: We can build an instance of this class and use it as part of our simulation.
  prefs: []
  type: TYPE_NORMAL
- en: As we noted earlier, the `bet()` method should probably be the only *required*
    method. The other two methods should be allowed to default to the single statement
    `pass`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary, design considerations, and trade-offs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we looked at the essential ingredients of abstract base classes.
    We saw a few features of each kind of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that one rule for good class design is to inherit as much as
    possible. We saw two broad patterns here. We also saw common exceptions to this
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: Some application classes don't have behaviors that overlap with internal features
    of Python. From our Blackjack examples, a `Card` isn't much like a number, a container,
    an iterator, or a context. It's just a playing card. In this case, we can generally
    invent a new class because there isn't any built-in features to inherit fro.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at `Hand`, however, we see that a hand is clearly a container.
    As we noted when looking at hand classes in [Chapters 1](ch01.html "Chapter 1. The
    __init__() Method"), *The __init__() Method*, and [Chapter 2](ch02.html "Chapter 2. Integrating
    Seamlessly with Python Basic Special Methods"), *Integrating Seamlessly with Python
    – Basic Special Methods*, the following are three fundamental design strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping an existing container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending an existing container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventing a wholly new kind of container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time, we'll be wrapping or extending an existing container. This
    fits with our rule of inheriting as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: When we extend an existing class, our application class will fit into the class
    hierarchy neatly. An extension to the built-in `list` is already an instance of
    `collections.abc.MutableSequence`.
  prefs: []
  type: TYPE_NORMAL
- en: When we wrap an existing class, however, we have to consider carefully what
    parts of the original interface we want to support and what parts we don't want
    to support. In our examples in the previous chapters, we only wanted to expose
    the `pop()` method from the list object we were wrapping.
  prefs: []
  type: TYPE_NORMAL
- en: Because a wrapper class is not a complete mutable sequence implementation, there
    are many things it can't do. On the other hand, an extension class participates
    in a number of use cases that just might turn out to be useful. For example, a
    hand that extends `list` will turn out to be iterable.
  prefs: []
  type: TYPE_NORMAL
- en: If we find that extending a class doesn't meet our requirements, we can resort
    to building an entirely new collection. The ABC definitions provide a great deal
    of guidance on what methods are required in order to create a collection that
    can integrate seamlessly with the rest of the Python universe. We'll look at a
    detailed example of inventing a collection in [Chapter 6](ch06.html "Chapter 6. Creating
    Containers and Collections"), *Creating Containers and Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the coming chapters, we'll make extensive use of these abstract base classes
    discussed in this chapter. In [Chapter 5](ch05.html "Chapter 5. Using Callables
    and Contexts"), *Using Callables and Contexts*, we'll look at the relatively simple
    features of callables and containers. In [Chapter 6](ch06.html "Chapter 6. Creating
    Containers and Collections"), *Creating Containers and Collections*, we'll look
    at the available containers and collections. We'll also look at building a unique,
    new kind of container in this chapter. Lastly, in [Chapter 7](ch07.html "Chapter 7. Creating
    Numbers"), *Creating Numbers*, we'll look at various numeric types and how we
    can create our own kind of number.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. Using Callables and Contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can exploit the `collections.abc.Callable` ABC and employ a technique called
    **memoization** to create objects that behave like functions but perform very
    quickly because they are able to cache previous results. In some cases, memoization
    is essential for creating an algorithm that finishes within a reasonable amount
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: The **context** concept allows us to create elegant, reliable resource management.
    The `with` statement defines a context and creates a context manager to control
    the resources used in that context. Python files are generally context managers;
    when used in a `with` statement, they are properly closed.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at several ways to create context managers using the tools in the
    `contextlib` module.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.2, the abstract base classes were in the `collections` module.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.3, the abstract base classes are in a separate submodule called
    `collections.abc`. In this chapter, we'll focus on Python Version 3.3\. The basic
    definitions will also be true for Python 3.2, but the `import` statement will
    change.
  prefs: []
  type: TYPE_NORMAL
- en: We'll show a number of variant designs for callable objects. This will show
    us why a stateful callable object is sometimes more useful than a simple function.
    We'll also look at how to use some of the existing Python context managers before
    we dive in and write our own context manager.
  prefs: []
  type: TYPE_NORMAL
- en: Designing with ABC callables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two easy ways to create callable objects in Python, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `def` statement to create a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By creating an instance of a class that uses `collections.abc.Callable` as its
    base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also assign a **lambda** form to a variable. A lambda is a small, anonymous
    function that consists of exactly one expression. We''d rather not emphasize saving
    lambdas in a variable as it leads to the confusing situation where we have a function-like
    callable that''s not defined with a `def` statement. The following is a simple
    callable object that has been created from a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three parts to the preceding callable object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We defined the class as a subclass of `abc.Callable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined the `__call__()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created an instance of the class, `pow1()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, the algorithm seems inefficient. We'll address that.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this is so simple that a full class definition isn't really necessary.
    In order to show the various optimizations, it's slightly simpler to start with
    a callable object rather than mutate a function into a callable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the `pow1()` function just as we''d use any other function.
    Here''s how to use the `pow1()` function in a Python command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: We've evaluated the callable object with various kinds of argument values. It's
    not *required* to make a callable object a subclass of `abc.Callable`. However,
    it does help with debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this flawed definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class definition has an error and doesn't meet the definition
    of the callable abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Found the error yet? If not, it's at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what happens when we try to create an instance of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: It may not be obvious exactly what went wrong, but we have a fighting chance
    to debug this. If we hadn't subclassed `collections.abc.Callable`, we'd have a
    somewhat more mysterious problem to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Here's what the more mysterious problem would look like. We'll skip the actual
    code for `Power3`. It's the same as `Power2`, except it doesn't subclass `collections.abc.Callable`.
    It starts `class Power3`; otherwise, it's identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what happens when we try to use `Power3` as a class that doesn''t
    meet the expectations of callables and isn''t a subclass of the `abc.Callable`
    either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: This error provides less guidance as to why the `Power3` class definition is
    flawed. The `Power2` error is much more explicit about the nature of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at two performance tweaks for the `Power3` class.
  prefs: []
  type: TYPE_NORMAL
- en: First, a better algorithm. Then, a better algorithm combined with memoization,
    which involves a cache; therefore, the function becomes stateful. This is where
    callable objects shine.
  prefs: []
  type: TYPE_NORMAL
- en: The first modification is to use a **Divide and Conquer** design strategy. The
    previous version chopped ![Improving performance](graphics/0971OS_05_01.jpg) into
    *n* steps; the loop carried out *n* individual multiplication operations. If we
    can find a way to split the problem into two equal portions, the problem decomposes
    into ![Improving performance](graphics/0971OS_05_02.jpg) steps. Given `pow1(2,1024)`,
    the `Power1` callable performs the calculation 1024 multiplications by 2\. We
    can optimize this down to 10 multiplications, a significant speedup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than simply multiplying by a fixed value, we''ll use the "fast exponentiation"
    algorithm. It uses three essential rules for computing ![Improving performance](graphics/0971OS_05_01.jpg),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If ![Improving performance](graphics/0971OS_05_03.jpg):![Improving performance](graphics/0971OS_05_04.jpg),
    the result is simply 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *n* is odd and ![Improving performance](graphics/0971OS_05_05.jpg), the result
    is ![Improving performance](graphics/0971OS_05_06.jpg). This involves a recursive
    computation of ![Improving performance](graphics/0971OS_05_07.jpg). This still
    does a multiplication but not a real optimization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *n* is even and ![Improving performance](graphics/0971OS_05_08.jpg), the
    result is ![Improving performance](graphics/0971OS_05_09.jpg). This involves a
    recursive computation of ![Improving performance](graphics/0971OS_05_10.jpg).
    This chops the number of multiplications in half.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the recursive callable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: We applied the three rules to the input value. If *n* is zero, we'll return
    1\. If *n* is odd, we'll make a recursive call and return ![Improving performance](graphics/0971OS_05_06.jpg).
    If *n* is even, we'll make a recursive call and return ![Improving performance](graphics/0971OS_05_09.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The execution time is dramatically faster. We can use the `timeit` module to
    see the difference in performance. See *Some Preliminaries*, for information on
    using `timeit`. When we compare running `pow1(2,1024)` and `pow4(2,1024)` 10,000
    times, we'll see something like 183 seconds for the previous version versus 8
    seconds for this version. We can do better, however, with memoization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how we can gather performance data using `timeit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: We imported the `timeit` module. The `timeit.timeit()` function will evaluate
    a given statement in the defined context. In this case, our expression is the
    simple `pow1(2,1024)` expression. The context for this statement is the definition
    of the `pow1()` function; it includes the import, class definition, and creation
    of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we provided `number=100000` to speed things up. If we had used the
    default value for the number of iterations, it could have taken almost 2 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Using memoization or caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea behind memoization is to cache previous results to avoid recomputing
    them. We'll use considerably more memory, but we can also dramatically speed up
    performance by avoiding computation.
  prefs: []
  type: TYPE_NORMAL
- en: An ordinary function doesn't have a place to cache previous results. A function
    is not expected to be stateful. A callable object, however, can be stateful. It
    can include a cache of previous results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a memoized version of our `Power` callable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: We revised our algorithm to work with the `self.memo` cache.
  prefs: []
  type: TYPE_NORMAL
- en: If the value of![Using memoization or caching](graphics/0971OS_05_01.jpg)has
    been requested previously, that result is returned and no computation is performed.
    This is the big speedup that we spoke of earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the value of ![Using memoization or caching](graphics/0971OS_05_01.jpg)
    must be computed and saved in the memoization cache. The three rules to compute
    the fast exponent are used to get and put values in the cache. This assures us
    that future calculations will be able to exploit the cached values.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of memoization can't be stressed enough. The reduction in computation
    can be dramatic. It is commonly done by replacing a slow, expensive function with
    a callable object.
  prefs: []
  type: TYPE_NORMAL
- en: Using functools for memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python library includes a memoization decorator in the `functools` module.
    We can use this module instead of creating our own callable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: This defined a function, `pow6()`, which is decorated with a **Least Recently
    Used** (**LRU**) cache. Previous requests are stored in a memoization cache. The
    requests are tracked in the cache, and the size is limited. The idea behind an
    LRU cache is that the most recently made requests are kept and the least recently
    made requests are quietly purged.
  prefs: []
  type: TYPE_NORMAL
- en: Using `timeit`, we can see that 10,000 iterations of `pow5()` run in about 1
    second, while the iterations for `pow6()` run in about 8 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: What this also shows is that a trivial use of `timeit` can misstate the performance
    of the memoization algorithms. The requests of the `timeit` module should be made
    more sophisticated to reflect more realistic use cases, to properly mix cache
    hits and cache misses. Simple random numbers aren't always appropriate for all
    problem domains.
  prefs: []
  type: TYPE_NORMAL
- en: Aiming for simplicity using the callable API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea behind a callable object is that we have an API that's focused on a
    single method.
  prefs: []
  type: TYPE_NORMAL
- en: Some objects have multiple relevant methods. A Blackjack `Hand`, for example,
    has to add cards and produce a total. A blackjack `Player` has to place bets,
    accept hands, and make play decisions (for example, hit, stand, split, insure,
    double down, and so on). These are more complex interfaces that are not suitable
    to be callables.
  prefs: []
  type: TYPE_NORMAL
- en: The betting strategy, however, is a candidate for being a callable.
  prefs: []
  type: TYPE_NORMAL
- en: The betting strategy can either be implemented as several methods (some setters
    and a getter method) or it can be a callable interface with a few public attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the straight betting strategy. It is always the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea of this API is that a `Player` object will inform the betting strategy
    of win amounts and loss amounts. The `Player` object might have methods such as
    the following to inform the betting strategy about the outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods inform a betting strategy object (the `self.bet` object) whether
    the hand was a win or a loss. When it''s time to place a bet, the `Player` will
    perform something like the following operation to get the current betting level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: This is a pleasantly short API. After all, the betting strategy doesn't do much
    other than encapsulate a few, relatively simple rules.
  prefs: []
  type: TYPE_NORMAL
- en: The shortness of this interface is one of the elegant features of a callable
    object. We don't have many method names, and we don't have a complex set of syntaxes
    for a simple thing.
  prefs: []
  type: TYPE_NORMAL
- en: Complexities and the callable API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how well this API holds up as our processing becomes more complex.
    The following is the double-up on each loss strategy (also known as the **Martingale**
    betting system):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Each loss doubles the betting by multiplying the stage by two. This goes on
    until we win and recoup our losses, reach the table limit, or go broke and can
    no longer place any bets. Casinos prevent this by imposing table limits.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we win, the betting is reset to the base bet. The stage is reset to
    have a value of one.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep the attribute interface—code such as `bet.win += 1`—we need
    to create properties to make the state changes correctly based on the wins and
    losses. We only really care about the setter properties, but we must define getter
    properties in order to clearly create setter properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this class in action as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: The API is still quite simple. We can either count the wins and reset the bet
    to the base, or we can count the losses, and the bets will double.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of properties made the class definition long and hideous. We''re really
    only interested in the setters and not the getters, so we can use `__setattr__()`
    to streamline the class definition somewhat, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: We used `__setattr__()` to monitor the updates to `win` and `loss`. In addition
    to setting the instance variables using `super().__setattr__()`, we also updated
    the internal state for the betting amount.
  prefs: []
  type: TYPE_NORMAL
- en: This is a nicer looking class definition, and it retains the simple API as a
    callable object with two attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Managing contexts and the with statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contexts and context managers are used in several places in Python. We'll look
    at a few examples to establish the basic terminology.
  prefs: []
  type: TYPE_NORMAL
- en: A context is defined by the `with` statement. The following program is a small
    example that parses a logfile to create a useful CSV summary of that log. Since
    there are two open files, we expect to see nested `with` contexts. The example
    uses a complex regular expression, `format_1_pat`. We'll define this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might see something like the following in an application program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Two contexts with two context managers were emphasized in this example.
  prefs: []
  type: TYPE_NORMAL
- en: The outermost context starts with `with open("subset.csv", "w") as target`.
    The built-in `open()` function opens a file that is also a context manager and
    assigns it to the `target` variable for further use.
  prefs: []
  type: TYPE_NORMAL
- en: The inner context starts with `with gzip.open(path, "r") as source`. This `gzip.open()`
    function behaves much like the `open()` function in that it opens a file that
    is also a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: When the `with` statements end, the contexts exit and the files are properly
    closed. Even if there's an exception in the body of the `with` context, the context
    manager's exit will be processed correctly and the file will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Always use a with around a file()**'
  prefs: []
  type: TYPE_NORMAL
- en: Since files involve OS resources, it's important to be sure that the entanglements
    between our applications and the OS are released as soon as they're no longer
    needed. The `with` statement ensures that resources are used properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to complete the example, the following is the regular expression used
    to parse Apache HTTP server logfiles in **Common Log Format**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: The preceding expression located the various log format fields used in the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Using the decimal context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another context that is used frequently is the decimal context. This context
    defines a number of properties of `decimal.Decimal` calculation, including the
    quantization rules used to round or truncate values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might see application programming that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows the default context as well as a local context.
    The default context has the default rounding rule. The localized context, however,
    shows how we can assure consistent operations by setting the decimal rounding
    for a particular calculation.
  prefs: []
  type: TYPE_NORMAL
- en: The `with` statement is used to assure that the original context is restored
    after the localized change. Outside this context, the default rounding applies.
    Inside this context, a specific rounding applies.
  prefs: []
  type: TYPE_NORMAL
- en: Other contexts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few other common contexts. Almost all of them are associated with
    basic input/output operations. Most modules that open a file create a context
    along with the file-like object.
  prefs: []
  type: TYPE_NORMAL
- en: Contexts are also associated with locking and database transactions. We may
    acquire and release an external lock, like a semaphore, or we may want a database
    transaction to properly commit when it's successful or roll back when it fails.
    These are all the things that have defined contexts in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The PEP 343 document provides a number of other examples of how the `with` statement
    and context managers might be used. There are other places where we might like
    to use a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: We may need to create classes that are simply context managers, or we may need
    to create classes that can have multiple purposes, one of which is to be a context
    manager. The `file()` object is similar. We'll look at a number of design strategies
    for contexts.
  prefs: []
  type: TYPE_NORMAL
- en: We'll return to this again in [Chapter 8](ch08.html "Chapter 8. Decorators and
    Mixins – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*,
    where we can cover a few more ways to create classes that have context manager
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the __enter__() and __exit__() methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The defining feature of a context manager is that it has two special methods:
    `__enter__()` and `__exit__()`. These are used by the `with` statement to enter
    and exit the context. We''ll use a simple context so that we can see how they
    work.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll often use context managers to make transient global changes. This might
    be a change to the database transaction status or a change to the locking status,
    something that we want to do and then undo when the transaction is complete.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we'll make a global change to the random number generator.
    We'll create a context in which the random number generator uses a fixed and known
    seed, providing a fixed sequence of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the context manager class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: We defined the required `__enter__()` and _`_exit__()` methods. The `__enter__()`
    method will save the previous state of the random module and then reset the seed
    to a given value. The `__exit__()` method will restore the original state of the
    random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `__enter__()` returns `self`. This is common for **mixin** context
    managers that have been added into other class definitions. We'll look at the
    concept of a mixin in [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins
    – Cross-cutting Aspects"), *Decorators And Mixins – Cross-cutting Aspects*.
  prefs: []
  type: TYPE_NORMAL
- en: The `__exit__()` method's parameters will have the value of `None` under normal
    circumstances. Unless we have specific exception-handling needs, we generally
    ignore the argument values. We'll look at exception-handling in the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Each time we create an instance of `KnownSequence`, we're modifying the way
    the `random` module works. During the context of the `with` statement, we'll get
    a fixed sequence of values. Outside the context, the random seed is restored,
    and we get random values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will look like the following (in most cases):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Some of this output is machine-dependent. While the exact values may vary, the
    second and fourth lines will match because the seed was fixed by the context.
    The other lines will not necessarily match because they rely on the `random` module's
    own randomization features.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exceptions that arise in a block will be passed to the `__exit__()` method of
    the context manager. The standard bits of an exception—the class, arguments, and
    the traceback stack—will all be provided as argument values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__exit__()` method can do one of the following two things with the exception
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: Silence the exception by returning some `True` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the exception to rise normally by returning any other `False` value. Returning
    nothing is the same as returning `None`, which is a `False` value; this allows
    the exception to propagate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exception might also be used to alter what the context manager does on exit.
    We might, for example, have to do special processing for certain types of OS errors
    that might arise.
  prefs: []
  type: TYPE_NORMAL
- en: Context manager as a factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create a context manager class, which is a factory for an application
    object. This gives us a pleasant separation of design considerations without cluttering
    up an application class with context management features.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we want a deterministic `Deck` for dealing in blackjack. This isn't
    as useful as it might sound. For unit testing, we'll need a completely mock deck
    with specific sequences of cards. This has the advantage that the context manager
    works with the classes we already saw.
  prefs: []
  type: TYPE_NORMAL
- en: We'll extend the simple context manager shown earlier to create a `Deck` that
    can be used within the `with` statement context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class that is a factory for `Deck` and also tweaks the `random`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: The preceding context manager class preserves the argument values so that it
    can create a `Deck` with the given arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The `__enter__()` method preserves the old random number state and then sets
    the `random` module in a mode that provides a fixed sequence of values. This is
    used to build and shuffle the deck.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `__enter__()` method returns a newly minted `Deck` object to be
    used in the `with` statement context. This is assigned via the `as` clause in
    the `with` statement.
  prefs: []
  type: TYPE_NORMAL
- en: We could have provided similar functionality in another way. We could create
    an instance of `random.Random(x=seed)` within the `Deck` class. While that also
    works well, it tends to clutter the `Deck` class with code that's only used for
    demonstrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a way to use this factory context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example of code guarantees a specific sequence of cards that we
    can use for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up in a context manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we'll discuss a more complex context manager that attempts
    some cleanup when there are problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'This addresses the common issue where we want to save a backup copy of a file
    that our application is rewriting. We want to be able to do something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: The intent is to have the original file renamed to `some_file copy`. If the
    context works normally—no exceptions—then the backup copy can be deleted or renamed
    to `some_file old`.
  prefs: []
  type: TYPE_NORMAL
- en: If the context doesn't work normally—there's an exception—we want to rename
    the new file to `some_file error` and rename the old file to `some_file`, putting
    the original file back the way it was before the exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need a context manager like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: This context manager's `__enter__()` method will attempt to preserve a previous
    copy of the named file if it already exists. If it didn't exist, there's nothing
    to preserve.
  prefs: []
  type: TYPE_NORMAL
- en: The `__exit__()` method be given information about any exception that occurred
    in the context. If there is no exception, it will simply return any previous file
    that exists was preserved the file created within the context will also exist.
    If there is an exception, then the `__exit__()` method will try to preserve the
    output (with a suffix of "error") for debugging purposes it will also put any
    previous version of file back in place.
  prefs: []
  type: TYPE_NORMAL
- en: This is functionally equivalent to a `try-except-finally` block. However, it
    has the advantage that it separates the relevant application processing from the
    context management. The application processing is written in the `with` statement.
    The context issues are set aside into a separate class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at three of the special methods for class definition. The `__call__()`
    method is used when creating a callable. The callable is used to create functions
    that are stateful. Our primary example is a function that memoizes previous results.
  prefs: []
  type: TYPE_NORMAL
- en: The `__enter__()` and `__exit__()` methods are used to create a context manager.
    The context is used to handle processing that is localized to the body of a with
    statement. Most of our examples include input-output processing. However, Python
    presents a number of other situations where a localized context can come handy.
    will focus on creating containers and collections.
  prefs: []
  type: TYPE_NORMAL
- en: Callable design considerations and trade-offs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When designing a callable object, we need to consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is the API of the object. If there's a reason for the object to have
    a function-like interface, then a callable object is a sensible design approach.
    Using `collections.abc.Callable` assures that the callable API is built correctly,
    and it informs anyone reading the code what the intent of the class is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the statefulness of the function. Ordinary functions in Python
    have no hysteresis—there's no saved state. A callable object, however, can easily
    save a state. The memoization design pattern makes good use of stateful callable
    objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only disadvantage of a callable object is the amount of syntax that is required.
    An ordinary function definition is shorter and therefore less error prone and
    easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy to migrate a defined function to a callable object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function can be converted into the following callable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: This is the minimal set of changes required to get the function to pass unit
    tests in the new form. The existing body will work in the new context unmodified.
  prefs: []
  type: TYPE_NORMAL
- en: Once the change has been made, features can be added to the callable object's
    version of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Context manager design considerations and trade-offs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A context is generally used to acquire/release, open/close, and lock/unlock
    types of operation pairs. Most of the examples are file I/O related, and most
    of the file-like objects in Python are already proper context managers.
  prefs: []
  type: TYPE_NORMAL
- en: A context manager is almost always required for anything that has steps which
    bracket the essential processing. In particular, anything that requires a final
    `close()` method should be wrapped by a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: Some Python libraries have open/close operations, but the objects aren't proper
    contexts. The `shelve` module, for example, doesn't create a proper context.
  prefs: []
  type: TYPE_NORMAL
- en: We can (and should) use the `contextllib.closing()` context on a `shelve` file.
    We'll show this in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving –
    JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML*.
  prefs: []
  type: TYPE_NORMAL
- en: For our own classes that require a `close()`method, we can use the `closing()`
    function. When confronted with a class that has any kind of acquire/release life
    cycle, we want to acquire resources in `__init__()` or a class-level `open()`method
    and release them in `close()`. That way, our class can integrate well with this
    `closing()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of some class being wrapped that requires a `close()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: The `contextllib.closing()` function will invoke the `close()` method of the
    object that is given as an argument. We can guarantee that `my_object` will have
    its `close()` method evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next two chapters, we'll look at the special methods used to create containers
    and numbers. In [Chapter 6](ch06.html "Chapter 6. Creating Containers and Collections"),
    *Creating Containers and Collections*, we'll look at the containers and collections
    in the standard library. We'll also look at building a unique, new kind of container.
    In [Chapter 7](ch07.html "Chapter 7. Creating Numbers"), *Creating Numbers*, we'll
    look at the various numeric types and how we can create our own kind of number.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6. Creating Containers and Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can extend a number of ABCs to create new kinds of collections. The ABCs
    provide us with design guidelines to extend the built-in containers. These allow
    us to fine-tune the features or radically define new data structures that fit
    our problem domain more precisely.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at the basics of ABC for container classes. There are a fairly large
    number of abstractions that are used to assemble the Python built-in types, such
    as `list`, `tuple`, `dict`, `set`, and `frozenset`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll review the variety of special methods that are involved in being a container
    and offering the various features of containers. We'll split these into the core
    container methods, separate from more specialized sequence, map, and set methods.
  prefs: []
  type: TYPE_NORMAL
- en: We'll address extending built-in containers to add features. We'll also look
    at wrapping built-in containers and delegating methods through the wrapper to
    the underlying container.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll look at building entirely new containers. This is a challenging
    territory, because there's a huge variety of interesting and useful collection
    algorithms already present in the Python Standard Library. In order to avoid deep
    computer science research, we'll build a pretty lame collection. Before starting
    on a real application, a careful study of *Introduction to Algorithms* by Cormen,
    Leiserson, Rivest, and Stein is essential.
  prefs: []
  type: TYPE_NORMAL
- en: We'll finish by summarizing some of the design considerations that go into extending
    or creating new collections.
  prefs: []
  type: TYPE_NORMAL
- en: ABCs of collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `collections.abc` module provides a wealth of abstract base classes that
    decompose collections into a number of discrete feature sets.
  prefs: []
  type: TYPE_NORMAL
- en: We can successfully use the `list` class without thinking too deeply about the
    various features and how they relate to the `set` class or the `dict` class. Once
    we start looking at the ABCs, however, we can see that there's a bit of subtlety
    to these classes. By decomposing the aspects of each collection, we can see areas
    of overlapping that manifest themselves as an elegant polymorphism even among
    different data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the base classes are some "one-trick pony" definitions. These
    are the base classes that require a single special method:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Container` base class requires the concrete class to implement the `__contains__()`
    method. This special method implements the `in` operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Iterable` base class requires `__iter__()`. This special method is used
    by the `for` statement and the generator expressions as well as the `iter()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Sized` base class requires `__len__()`. This method is used by the `len()`
    function. It's also prudent to implement `__bool__()`, but it's not required by
    this abstract base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Hashable` base class requires `__hash__()`. This is used by the `hash()`
    function. If this is implemented, it means that the object is immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these abstract classes is used to build the higher-level, composite
    definitions of structures we can use in our applications. These composite constructs
    include the lower-level base classes of `Sized`, `Iterable`, and `Container`.
    Here are some composite base classes that we might use in an application:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Sequence` and `MutableSequence` classes build on the basics and fold in
    methods such as `index()`, `count()`, `reverse()`, `extend()`, and `remove()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Mapping` and `MutableMapping` classes fold in methods such as `keys()`,
    `items()`, `values()`, and `get()`, among others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Set` and `MutableSet` classes fold in comparison and arithmetic operators
    to perform set operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we look more deeply into the built-in collections, we can see how the ABC
    class definitions serve to organize the special methods that we need to write
    or modify.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of special methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When looking at a blackjack `Hand` object, we have an interesting special case
    for containment. We often want to know if there''s an ace in the hand. If we define
    `Hand` as an extension to `list`, then we can''t ask for a generic ace. We can
    only ask for specific cards. We hate to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: That seems a long-winded way to look for an ace in a hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a better example, but it still is less-than-ideal, perhaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we''d like something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we''re modifying the meaning of "contains" for a `Hand` object
    that extends `list`. We''re not looking for a `Card` instance, we''re merely looking
    for the rank property of a `Card` object. We can override the `__contains__()`
    method to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to use a simpler `in` test for a given rank in a hand.
  prefs: []
  type: TYPE_NORMAL
- en: Similar design considerations can be applied to `__iter__()` and `__len__()`
    special methods. Be cautious, however. Changing the semantics of `len()` or how
    a collection interacts with the `for` statement might be disastrous.
  prefs: []
  type: TYPE_NORMAL
- en: Using the standard library extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at some extensions to built-in classes that are already part of the
    standard library. These are the collections that extend or modify the built-in
    collections. Most of these are covered in one form or another in books such as
    *Python 3 Object Oriented Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at the following six library collections:'
  prefs: []
  type: TYPE_NORMAL
- en: The `namedtuple()` function creates subclasses of tuple subclasses with named
    attributes. We can use this instead of defining a complete class, which merely
    assigns names to the attribute values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deque` (note the atypical spelling) is a double-ended queue, a list-like collection
    that can perform fast appends and pops on either end. A subset of the features
    of this class will create single-ended stacks or queues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, we can use `ChainMap` instead of merging mappings together. This
    is a view of multiple mappings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OrderedDict` collection is a mapping in which the original key entry order
    is maintained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultdict` (note the atypical spelling) is a `dict` subclass that uses a
    factory function to provide values for missing keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Counter` is a `dict` subclass that can be used for counting objects to
    create frequency tables. However, it's actually a more sophisticated data structure
    called a **multiset** or **bag**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll see examples of each one of the preceding collections. There are two
    important lessons to be learned from studying the library collections:'
  prefs: []
  type: TYPE_NORMAL
- en: What's already present and doesn't need to be reinvented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extend the ABCs to add interesting and useful structures to the language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, it''s important to read the source for the libraries. The source will
    show us numerous Python object-oriented programming techniques. Beyond these basics
    are even more modules. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `heapq` module is a set of functions that impose a heap queue structure
    on an existing `list` object. The heap queue invariant is the set of those items
    in the heap that are maintained in order to allow rapid retrieval in an ascending
    order. If we use the `heapq` methods on a `list` structure, we will never have
    to explicitly sort the list. This can have significant performance improvements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` module is a kind of sequence that optimizes storage for certain
    kinds of values. This provides list-like features over potentially large collections
    of simple values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, of course, there's the deeper computer science that supports these
    various data structure definitions.
  prefs: []
  type: TYPE_NORMAL
- en: The namedtuple() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `namedtuple()` function creates a new class definition from the supplied
    arguments. This will have a class name, field names, and a pair of optional keywords
    that define the behavior of the created class.
  prefs: []
  type: TYPE_NORMAL
- en: Using `namedtuple()` will condense a class definition into a very short definition
    of a simple immutable object. It saves us from having to write longer and more
    complex class definitions for the common case where we want to name a fixed set
    of attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For something like a playing card, we might want to insert the following code
    in a class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined a new class and provided precisely four named attributes: `rank`,
    `suit`, `hard`, and `soft`. Since each of these objects is immutable, we don''t
    need to worry about a badly behaved application attempting to change the rank
    of a `BlackjackCard` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a factory function to create instances of this class, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'This will build an instance of `BlackjackCard` with the hard and soft totals
    set properly for various card ranks. A new class called `namedtuple` is created
    by filling in a template for a subclass of `tuple` with the various parameters.
    Essentially, the template starts out with this kind of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: The template code extends the built-in `tuple` class. Nothing surprising there.
  prefs: []
  type: TYPE_NORMAL
- en: 'It sets `__slots__` to an empty tuple. There are two ways to manage instance
    variables: `__slots__` and `__dict__`. By setting `__slots__`, the `__dict__`
    alternative is disabled, removing the ability to add new instance variables to
    an object of this class. Also, the resulting object is kept to the absolute minimum
    size.'
  prefs: []
  type: TYPE_NORMAL
- en: The template creates a class-level variable named `_fields`, which names the
    fields. The `{field_names!r}` construct is where the template text is filled with
    the list of field names.
  prefs: []
  type: TYPE_NORMAL
- en: The template defines a `__new__()` method that is used to initialize the immutable
    object. The `{arg_list}` construct is where the template is filled with the list
    of arguments used to build each instance.
  prefs: []
  type: TYPE_NORMAL
- en: There are several other method functions, but this provides some hints as to
    how the `namedtuple` function works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: We can, of course, subclass a `namedtuple` class to add features. We have to
    be cautious about trying to add attributes to a `namedtuple` class, though. The
    list of attributes is encoded in `_fields`, as well as the arguments to `__new__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of subclassing a `namedtuple` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: We used `__slots__` to ensure that the subclass has no `__dict__`; we can't
    add any new attributes. We've overridden `__new__()` so that we can construct
    instances with only two values (`rank` and `suit`), yet populate all four values.
  prefs: []
  type: TYPE_NORMAL
- en: The deque class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `list` object is designed to provide uniform performance for any element within
    the container. Some operations have performance penalties. Most notably, any operation
    at the front of the list (`list.insert(0, item)` or `list.pop(0)`) will incur
    some overheads because the list size is changed and the position of each element
    has changed.
  prefs: []
  type: TYPE_NORMAL
- en: A `deque`—a double-ended queue—is designed to provide uniform performance for
    the first and last elements of a list. The idea is that appending and popping
    will be faster than the built-in `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Spelling irregularity**'
  prefs: []
  type: TYPE_NORMAL
- en: Class names are usually in title case. However, the `deque` class isn't.
  prefs: []
  type: TYPE_NORMAL
- en: Our design for a deck of cards avoids the potential performance pitfall of a
    `list` object by always popping from the end, never from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we're using so few features of a `list` object, perhaps a structure
    like that of a deque is a better fit for our problem. We're only storing cards
    so that they can be shuffled and popped from the collection. Other than shuffling,
    our applications never reference elements within the list by their indexed positions.
  prefs: []
  type: TYPE_NORMAL
- en: While the `deque.pop()` method might be very fast, shuffling may suffer. A shuffle
    will make random access to the container, something for which a deque is not designed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to confirm the potential costs, we can use `timeit` to compare `list`
    and `deque` shuffling performance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: We invoked `timeit` using `random.shuffle()`. One works on a `list` object,
    the other works on a deque.
  prefs: []
  type: TYPE_NORMAL
- en: These results indicate that shuffling a deque is only a trifle slower than shuffling
    a `list` object—about 2 percent slower. This distinction is a hair not worth splitting.
    We can confidently try a `deque` object in place of `list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change amounts to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: We replaced `list` with `deque` in the definition of `Deck`. Otherwise, the
    class is identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the actual performance difference? Let''s create decks of 100,000 cards
    and deal them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: We invoked `timeit` using `x.pop()`. One works on a `list`, the other works
    on a deque.
  prefs: []
  type: TYPE_NORMAL
- en: The dealing time is cut almost by half (42 percent, actually). We had big savings
    from a tiny change in the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it's important to pick the optimal data structure for the application.
    Trying several variations can show us what's more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: The ChainMap use case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use case for chaining maps together fits nicely with Python's concept of
    local versus global definitions. When we use a variable in Python, first the local
    namespaces, and then the global namespaces are searched, in that order. In addition
    to searching both namespaces for a variable, setting a variable works in the local
    namespace without disturbing the global namespace. This default behavior (without
    the `global` or `nonlocal` statements) is also how a `ChainMap` works.
  prefs: []
  type: TYPE_NORMAL
- en: When our applications start running, we often have properties that come from
    command-line parameters, configuration files, OS environment variables, and possibly,
    installation-wide settings. We'd like to merge this into a single dictionary-like
    structure so that we can easily locate a setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have an application startup that combines several sources of configuration
    options like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows us the configuration from several sources, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The command-line arguments. We saw one token argument called `playerclass`,
    but there are often many, many others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the arguments, `configuration`, is the name of a configuration file with
    additional parameters. This is expected to be in the JSON format, and the file's
    contents are read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, there's a `defaults.json` file with yet another place to look
    for the configuration values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the preceding sources, we can build a single `ChainMap` object use case
    that allows looking for a parameter in each of the listed locations. The `ChainMap`
    instance use case will search through each mapping, in an order, looking for the
    given value. This gives us a tidy, easy-to-use source for runtime options and
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at this again in [Chapter 13](ch13.html "Chapter 13. Configuration
    Files and Persistence"), *Configuration Files and Persistence*, as well as [Chapter
    16](ch16.html "Chapter 16. Coping With the Command Line"), *Coping with the Command
    Line*.
  prefs: []
  type: TYPE_NORMAL
- en: The OrderedDict collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `OrderedDict` collection class makes clever use of two storage structures.
    There's an underlying `dict` object type that maps keys to values. Plus, there's
    an additional doubly-linked list of keys that maintains the insertion order.
  prefs: []
  type: TYPE_NORMAL
- en: One common use for `OrderedDict` is when processing HTML or XML files, where
    the order of objects must be retained, but objects might have cross-references
    via ID and IDREF attributes. We can optimize the connections among objects by
    using the ID as a dictionary key. We can retain the source document's ordering
    with the `OrderedDict` structure.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to digress too far into the XML parsing here. That's a subject
    for [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this short example of an XML document that has a rather complex network
    of references between several indexes. We'll imagine a simple microblog document
    with ordered entries that have IDs and indices that have IDREFs to the original
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll break the XML into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'There will be a section on topics and another section on indices. Here''s the
    topics'' portion of the blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Each topic has a sequence of entries. Each entry has a unique ID. We're hinting
    that they might belong to **Universally Unique ID** (**UUID**), but we didn't
    produce actual examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s one of the indices for the blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: One index presents the blog entries by the tag. We can see that each tag has
    a list of entries. Each entry has a reference to the original microblog entry.
  prefs: []
  type: TYPE_NORMAL
- en: When we parse this XML document, we need to keep the topics in the original
    order. But, we also have to track the IDs as keys for each entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a technical spike that will parse the document and build an `OrderedDict`
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: The first part, `# Parse`, will parse the XML source document, creating an `ElementTree`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The second part, `# Gather`, will traverse the entries in the topics section
    of the XML document. Each topic is loaded into a topic's `OrderedDict` collection
    by ID. The original order is retained so that the material can be rendered in
    the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: The final part, `# Display`, shows us the entries in their original order and
    their ID.
  prefs: []
  type: TYPE_NORMAL
- en: The defaultdict subclass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ordinary `dict` type throws an exception when a key is not found. A `defaultdict`
    collection class evaluates a given function and inserts the value of that function
    into the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note the spelling irregularity**'
  prefs: []
  type: TYPE_NORMAL
- en: Class names are usually in TitleCase. However, the `defaultdict` class isn't.
  prefs: []
  type: TYPE_NORMAL
- en: A common use case for a `defaultdict` class is to create indices for objects.
    When several objects have a common key, we can create a list of objects that share
    this key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a part of a technical spike that shows us how we might accumulate a
    list of outcomes indexed by the dealer''s upcard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Each value of `outcomes[rank]` will be a list of simulated payouts. We can average
    or total these to summarize the payouts. We can count wins versus losses or perform
    other quantitative analysis to determine a strategy for play that minimizes losses
    and maximizes wins.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we might want to use a `defaultdict` collection class to provide
    a constant value. Instead of writing `container.get(key,"N/A")`, we'd like to
    write `container[key]` and have the string constant provided the value `"N/A"`
    if the key was not found. The difficulty with doing this is that a `defaultdict`
    class is created with a zero-argument function to create the default values. We
    can't use a constant trivially.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a zero-argument `lambda` object. This works very nicely. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'The default value is returned, and the key (in this example, `''other''`) is
    added to the dictionary. We can determine how many new values were entered by
    looking for all the keys that have a value of `"N/A"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: As you see in the preceding output, we found the key that was assigned the default
    value of `"N/A"`. This is often a helpful summary of the data that is being accumulated.
    It shows us all of the keys associated with the default value.
  prefs: []
  type: TYPE_NORMAL
- en: The counter collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most common use cases for a `defaultdict` class is when accumulating
    counts of events. We might write code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: We're counting the number of times each key value, `k`, appears in the sequence
    of values from `some_iterator()`.
  prefs: []
  type: TYPE_NORMAL
- en: This use case is so common that there's a variation on the `defaultdict` theme
    that performs the same operation shown in the preceding code—it's called `Counter`.
    A `Counter` collection, however, is considerably more sophisticated than a simple
    `defaultdict` class. Consider the additional use case of determining the most
    common value, known to statisticians as the **mode**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to restructure the values in the `defaultdict` object to find the mode.
    It''s not difficult, but it can be irksome because it''s a boilerplate code. It
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: We created a second dictionary. The keys for this new `by_value` dictionary
    are the frequency values. Each key is associated with all of the original `some_iterator()`
    values that occurred with this frequency.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the following processing to locate and display the most common
    values in the order of frequency of the occurrence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: This will create a kind of frequency histogram that shows us the list of key
    values with a given frequency and the frequency count shared by all those key
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these features are already a part of the `Counter` collection. Here''s
    an example to create a frequency histogram from some source of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: This example shows us how we can easily gather statistical data by providing
    any iterable item to `Counter`. It will gather frequency data on the values in
    that iterable item. In this case, we provided an iterable function named `some_iterator()`.
    We might have provided a sequence or some other collection.
  prefs: []
  type: TYPE_NORMAL
- en: We can then display the results in the descending order of popularity. But wait!
    That's *not* all.
  prefs: []
  type: TYPE_NORMAL
- en: The `Counter` collection is not merely a simplistic variation of the `defaultdict`
    collection. The name is misleading. A `Counter` object is actually a "multiset",
    sometimes called a "bag".
  prefs: []
  type: TYPE_NORMAL
- en: It's a collection that is set-like, but allows for repeats of values in the
    bag. It is not a sequence with items identified by an index or position; order
    doesn't matter. It is not a mapping with keys and values. It is like a set in
    which items stand for themselves and order doesn't matter. But it is unlike a
    set because, in this case, elements can repeat.
  prefs: []
  type: TYPE_NORMAL
- en: As elements can repeat, the `Counter` object represents multiple occurrences
    with an integer count. Hence, it's used as a frequency table. However, it does
    more than this. As a bag is like a set, we can compare the elements of two bags
    to create a union or an intersection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two bags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: We built each bag by examining a sequence of letters. For characters that occur
    more than once, there's a count that is more than one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily compute the union of the two bags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: This shows us the entire suite of letters between the two strings. There were
    three instances of `o`. Not surprisingly, other letters were less popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can just as easily compute the difference between the bags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: The first expression shows us characters in `bag1` that were not in `bag2`.
  prefs: []
  type: TYPE_NORMAL
- en: The second expression shows us characters in `bag2` that were not in `bag1`.
    Note that the letter `o` occurred twice in `bag2` and once in `bag1`. The difference
    only removed one of the `o` characters from `bag1`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new kinds of collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at some extensions we might make to Python's built-in container classes.
    Although, we won't show an example of extending each container. If we did, the
    book would become out of control in size.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll pick an example of extending a specific container and see how the process
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the requirements. This may include research on Wikipedia, generally
    starting here: [http://en.wikipedia.org/wiki/Data_structure](http://en.wikipedia.org/wiki/Data_structure).
    Designs of data structures can be complex because there are often complex edge
    cases.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If necessary, look at the `collections.abc` module to see what methods must
    be implemented to create the new functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create some test cases. This also requires careful study of the algorithms to
    ensure that the edge cases are properly covered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to emphasize the importance of researching the fundamentals before trying
    to invent a new kind of data structure. In addition to searching the Web for overviews
    and summaries, details will be necessary. See *Introduction to Algorithms* by
    Cormen, Leiserson, Rivest, and Stein or *Data Structures and Algorithms* by Aho,
    Ullman, and Hopcroft, or *The Algorithm Design Manual* by Steven Skiena.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw earlier, the ABCs define three broad kinds of collections: sequences,
    mappings, and sets. We have three design strategies that we can use to create
    new kinds of collections of our own:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extend**: This is an existing sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wrap**: This is an existing sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invent**: This is a new sequence from scratch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In principle, we could give as many as nine examples—each basic flavor of collection
    with each basic design strategy. We won't beat this subject to death like that.
    We'll dig deep to create new kinds of sequences, learning how to extend and wrap
    existing sequences.
  prefs: []
  type: TYPE_NORMAL
- en: As there are so many extended mappings (such as `ChainMap`, `OrderedDict`, `defaultdict`,
    and `Counter`), we'll only touch lightly on creating new kinds of mappings. We'll
    also dig deep to create a new kind of ordered multiset or bag.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a new kind of sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common requirement that we have when performing statistical analysis is to
    compute basic means, modes, and standard deviations on a collection of data. Our
    blackjack simulation will produce outcomes that must be analyzed statistically
    to see if we have actually invented a better strategy.
  prefs: []
  type: TYPE_NORMAL
- en: When we simulate a playing strategy, we should wind up with some outcome data
    that will be a sequence of numbers that show us the final result of playing a
    sequence of hands with a given strategy. The rate of play varies from about 50
    hands per hour at a crowded table to 200 hands per hour if one is alone with the
    dealer. We'll assume 200 hands as two hours of blackjack before having to take
    a biology break.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could accumulate the outcomes into a built-in `list` class. We can compute
    the mean via ![Defining a new kind of sequence](graphics/0971OS_06_01.jpg), where
    N is the number of elements in *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'Standard deviation can be computed via ![Defining a new kind of sequence](graphics/0971OS_06_02.jpg):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Both of these are relatively simple calculation functions that are easy to use.
    As things get more complex, however, loose functions like these become less helpful.
    One of the benefits of object-oriented programming is to bind the functionality
    with the data.
  prefs: []
  type: TYPE_NORMAL
- en: Our first example will not involve rewriting any of the special methods of `list`.
    We'll simply subclass `list` to add methods that will compute the statistics.
    This is a very common kind of extension.
  prefs: []
  type: TYPE_NORMAL
- en: We'll revisit this in the second example so that we can revise and extend the
    special methods. This will require some study of the ABC special methods to see
    what we need to add or modify so that our new list subclass properly inherits
    all the features of the built-in `list` class.
  prefs: []
  type: TYPE_NORMAL
- en: Because we're looking at sequences, we also have to wrestle with the Python
    `slice` notation. We'll look at what a slice is and how it works internally in
    the Working with `__getitem__`, `__setitem__`, `__delitem__`, and slices section.
  prefs: []
  type: TYPE_NORMAL
- en: The second important design strategy is wrapping. We'll create a wrapper around
    a list and see how we might delegate methods to the wrapped list. Wrapping has
    some advantages when it comes to object persistence, which is the subject of [Chapter
    9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and
    XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*.
  prefs: []
  type: TYPE_NORMAL
- en: We can also look at the kind of things that need to be done to invent a new
    kind of sequence from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: A statistical list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It makes good sense to incorporate mean and standard deviation features directly
    into a subclass of `list`. We can extend `list` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: With this simple extension to the built-in `list` class, we can accumulate data
    and report statistics with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: We can imagine an overall simulation script that looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Choosing eager versus lazy calculation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that our calculations are lazy; they are only done when requested. This
    also means that they're performed each and every time they're requested. This
    can be a considerable overhead, depending on the context in which objects of these
    classes are used.
  prefs: []
  type: TYPE_NORMAL
- en: It's actually sensible to transform these statistical summaries into eager calculations,
    as we know when elements are added and removed from a list. Although there's a
    hair more programming to create eager versions of these functions, it has a net
    impact of improving performance when there's a lot of data being accumulated.
  prefs: []
  type: TYPE_NORMAL
- en: The point of eager statistical calculations is to avoid the loops that compute
    sums. If we compute the sums eagerly, as the list is being created, we avoid extra
    looping through the data.
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the special methods for a `Sequence` class, we can see all of
    the places where data is added to, removed from, and modified in the sequence.
    We can use this information to recompute the two sums that are involved. We start
    with the `collections.abc` section of the *Python Standard Library* documentation,
    section 8.4.1 at [http://docs.python.org/3.4/library/collections.abc.html#collections-abstract-base-classes](http://docs.python.org/3.4/library/collections.abc.html#collections-abstract-base-classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the required methods for a `MutableSequence` class: `__getitem__`,
    `__setitem__`, `__delitem__`, `__len__`, `insert`, `append`, `reverse`, `extend`,
    `pop`, `remove`, and `__iadd__`. The documentation also mentions the **Inherited
    Sequence methods**. However, as those are for immutable sequences, we can certainly
    ignore them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the details of what must be done for each method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__getitem__`: Nothing, as there''s no change in the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__setitem__`: This changes an item. We need to take the old item out of each
    sum and fold the new item into each sum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__delitem__`: This removes an item. We need to take the old item out of each
    sum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__len__`: Nothing here either, as there''s no change in the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert`: As this adds a new item, we need to fold it into each sum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`append`: As this also adds a new item, we need to fold it into each sum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reverse`: Nothing here either, as there''s no change in the state of the mean
    or standard deviation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extend`: This adds many new items such as `__init__`, for which we''ll need
    to process each item before extending the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop`: This removes an item. We need to take the old item out of each sum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove`: This also removes an item. We need to take the old item out of each
    sum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__iadd__`: This is the `+=` augmented assignment statement, the in-place addition.
    It''s effectively the same as the `extend` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We won''t look at each method in detail, because there are really only two
    use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Fold in one new value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove one old value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The replacement case is a combination of the remove and fold in operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the elements of an eager `StatsList` class. We''re going to see just
    `insert` and `pop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: We provided three internal variables with quick comments to show the invariants
    that this class will maintain them. We'll call these the "sum invariants" because
    each of them contains a particular kind of sum that is maintained as invariant
    (always true) after each kind of state change. The essence of this eager calculation
    are the `_rmv()` and `_new()` methods, which update our three internal sums based
    on changes to the list, so that the relationships really remain invariant.
  prefs: []
  type: TYPE_NORMAL
- en: When we remove an item, that is, after a successful `pop()` operation, we have
    to adjust our sums. When we add an item (either initially, or via the `insert()`
    method), we also have to adjust our sums. The other methods we need to implement
    will make use of these two methods to ensure that the three sum invariants hold.
    We assure that L.sum0 is always ![Choosing eager versus lazy calculation](graphics/0971OS_06_03.jpg),
    sum1 is always ![Choosing eager versus lazy calculation](graphics/0971OS_06_04.jpg),
    and sum2 is always ![Choosing eager versus lazy calculation](graphics/0971OS_06_05.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Other methods such as `append()`, `extend()`, and `remove()`, are similar in
    many ways to these methods. We didn't show them because they're similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an important bit missing: individual item replacement via `list[index]=
    value`. We''ll delve into it in the following paragraph.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how this list works by playing with some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: We can create a list and the sums are computed initially. Each subsequent change
    eagerly updates the various sums. We can change, remove, insert, and pop an item;
    each change results in a new set of sums.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left is to add our mean and standard deviation calculations, which
    we can do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: These make use of the sums already computed. There's no additional looping over
    the data to compute these two statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Working with __getitem__(), __setitem__(), __delitem__(), and slices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `StatsList2` example didn't show us the implementation of `__setitem__()`
    or `__delitem__()` because they involve slices. We'll need to look at the implementation
    of a slice before we can implement these methods properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequences have two different kinds of indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a[i]`: This is a simple Integer index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a[i:j]` or `a[i:j:k]`: These are `slice` expressions with `start:stop:step`
    values. Slice expressions can be quite complex with seven different variations
    for different kinds of defaults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This basic syntax works in three contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: In an expression, relying on `__getitem__()` to get a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the left-hand side of assignment, relying on `__setitem__()` to set a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On a `del` statement, relying on `__delitem__()` to delete a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we do something like `seq[:-1]`, we write a `slice` expression. The underlying
    `__getitem__()` method will be given a `slice` object instead of a simple integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reference manual tells us a few things about slices. A `slice` object will
    have three attributes: `start`, `stop`, and `step`. It will also have a method
    function called `indices()`, which will properly compute any omitted attribute
    values for a slice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can explore the `slice` objects with a trivial class that extends `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: This class will dump the `slice` object and the value of the `indices()` function
    result. Then, use the superclass implementation so that the list behaves normally
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this class, we can try different `slice` expressions to see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `slice` expressions, we can see that a `slice` object has three
    attributes, and the values for those attributes come directly from the Python
    syntax. When we provide the proper length to the `indices()` function, it returns
    a three-tuple value with start, stop, and step values.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing __getitem__(), __setitem__(), and __delitem__()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we implement the methods `__getitem__()`, `__setitem__()` and `__delitem__()`,
    we must work with two kinds of argument values: `int` and `slice`.'
  prefs: []
  type: TYPE_NORMAL
- en: When we overload the various sequence methods, we must handle the slice situation
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a `__setitem__()` method that works with slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method has two processing paths:'
  prefs: []
  type: TYPE_NORMAL
- en: If the index is a `slice` object, we'll compute the `start`, `stop`, and `step`
    values. Then, locate all the old values that will be removed. We can then invoke
    the superclass operation and fold in the new values that replaced the old values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the index is a simple `int` object, the old value is a single item, and the
    new value is a single item, similarly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the `__delitem__()` method that works with slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code, too, expands the slice to determine what values could be
    removed. If the index is a simple integer, then just one value is removed.
  prefs: []
  type: TYPE_NORMAL
- en: When we introduce proper slice processing to our `StatsList2` class, we can
    create lists that do everything the base `list` class does and also (rapidly)
    returns mean and standard deviation for the values that are currently in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that these method functions will each create a temporary list object, `olds`;
    this involves some overhead that can be removed. As an exercise for the reader,
    it's helpful to move the `_rmv()` functions forward in these methods to eliminate
    the use of the `olds` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a list and delegating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll look at how we might wrap one of Python's built-in container classes.
    Wrapping an existing class means that some methods will have to be delegated to
    the underlying container.
  prefs: []
  type: TYPE_NORMAL
- en: As there are a large number of methods in any of the built-in collections, wrapping
    a collection may require a fair amount of code. When it comes to creating persistent
    classes, wrapping has advantages over extending. That's the subject of [Chapter
    9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and
    XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*. In some cases,
    we'll want to expose the internal collection to save writing a large number of
    sequence methods that delegate to an internal list.
  prefs: []
  type: TYPE_NORMAL
- en: A common restriction that applies to statistics data classes is that they need
    to be "insert only." We'll be disabling a number of method functions. This is
    the kind of dramatic change that requires a wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can design a class that supports only `append` and `__getitem__`, for example.
    It would wrap a `list` class. The following code can be used to accumulate data
    from simulations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: This class has an internal `_list` object that is the underlying list. The list
    is always initially empty. As we've only defined `append()` as a way to update
    the list, we can maintain the various sums easily. We need to be careful to delegate
    the work to the superclass to be sure that the list is actually updated before
    our subclass processes the argument value.
  prefs: []
  type: TYPE_NORMAL
- en: We can directly delegate `__getitem__()` to the internal list object without
    examining the arguments or the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: We created an empty list and appended items to the list. As we maintain the
    sums as items are appended, we can compute the mean and standard deviation extremely
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't intentionally make our class iterable. We didn't define `__iter__()`.
  prefs: []
  type: TYPE_NORMAL
- en: Because we've defined `__getitem__()`, several things now work. Not only can
    we get items, but it also turns out that there will be a default implementation
    that allows us to iterate through the sequence of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows us that a minimal wrapper around a collection is
    often enough to satisfy many use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we didn''t, for example, make the list sizeable. If we attempt to
    get the size, it will raise an exception, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: We might want to add a `__len__()` method that delegates the real work to the
    internal `_list` object. We might also want to set `__hash__` to `None`, which
    would be prudent as this is a mutable object.
  prefs: []
  type: TYPE_NORMAL
- en: We might want to define `__contains__()` and delegate this feature to the internal
    `_list` too. This will create a minimalist container that offers the low-level
    feature set of a container.
  prefs: []
  type: TYPE_NORMAL
- en: Creating iterators with __iter__()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When our design involves wrapping an existing class, we'll need to be sure our
    class is iterable. When we look at the documentation for `collections.abc.Iterable`,
    we see that we only need to define `__iter__()` to make an object iterable. The
    `__iter__()` method can either return a proper `Iterator` object, or it can be
    a generator function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an `Iterator` object, while not terribly complex, is rarely necessary.
    It's so much simpler to create generator functions. For a wrapped collection,
    we should always simply delegate the `__iter__()` method to the underlying collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our `StatsList3` class, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: This method function would delegate the iteration to the underlying list's `Iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new kind of mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a built-in mapping called `dict`, and numerous library mappings.
    In addition to the `collections` module extensions to `dict` (`defaultdict`, `Counter`,
    `OrderedDict`, and `ChainMap`), there are several other library modules that contain
    mapping-like structures.
  prefs: []
  type: TYPE_NORMAL
- en: The `shelve` module is an important example of another mapping. We'll look at
    this in [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via
    Shelve"), *Storing and Retrieving Objects via Shelve*. The `dbm` module is similar
    to `shelve`, in that it also maps a key to a value.
  prefs: []
  type: TYPE_NORMAL
- en: The `mailbox` module and `email.message` modules both have classes that provide
    an interface that is similar to `dict` for the mailbox structure used to manage
    local e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: As far as design strategies go, we can extend or wrap one of the existing mappings
    to add even more features.
  prefs: []
  type: TYPE_NORMAL
- en: We could upgrade `Counter` to add mean and standard deviation to data stored
    as a frequency distribution. Indeed, we can also calculate median and mode very
    easily from this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a `StatsCounter` extension to `Counter` that adds some statistical
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: We extended the `Counter` class with two new methods to compute the mean and
    standard deviation from the frequency distributions. The formulae are similar
    to the examples shown earlier for the eager calculations on a `list` object, even
    though they're lazy calculations on a `Counter` object.
  prefs: []
  type: TYPE_NORMAL
- en: We used `sum0= sum( v for k,v in self.items() )` to compute a sum of the values,
    `v`, ignoring the `k` keys. We could use an underscore (`_`) instead of `k` to
    emphasize that we're ignoring the keys. We could also use `sum( v for v in self.values()
    )` to emphasize that we're not using the keys. We prefer obvious parallel structures
    for `sum0` and `sum1`.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this class to efficiently gather statistics and to perform quantitative
    analysis on the raw data. We might run a number of simulations, using a `Counter`
    object to gather the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an interaction with a list of sample data that stands in for real results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: The results of `most_common()` are reported as a sequence of two-tuples with
    the mode value (4) and the number of times the value occurred (3). We might want
    to get the top three values to bracket the mode with the next two less-popular
    items. We get several popular values with an evaluation such as `sc.most_common(3)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `elements()` method reconstructs a `list` that's like the original data
    with the items repeated properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the sorted elements, we can extract the median, the middle-most item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: This method is not only lazy, it's rather extravagant with memory; it creates
    an entire sequence of the available values merely to find the middle-most item.
  prefs: []
  type: TYPE_NORMAL
- en: While it is simple, this is often an expensive way to use Python.
  prefs: []
  type: TYPE_NORMAL
- en: A smarter approach would be to compute the effective length and mid-point via
    `sum(self.values())//2`. Once this is known, the keys can be visited in that order,
    using the counts to compute the range of positions for a given key. Eventually,
    a key will be found with a range that includes the midpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: We stepped through the keys and the number of times they occur to locate the
    key that is midmost. Note that this uses the internal `sorted()` function, which
    is not without its own cost.
  prefs: []
  type: TYPE_NORMAL
- en: Via `timeit`, we can learn that the extravagant version takes 9.5 seconds; the
    smarter version takes 5.2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new kind of set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a whole new collection requires some preliminary work. We need to have
    new algorithms or new internal data structures that offer significant improvements
    over the built-in collections. It's important to do thorough "Big-O" complexity
    calculations before designing a new collection. It's also important to use `timeit`
    after an implementation to be sure that the new collection really is an improvement
    on the built-in class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might, for example, want to create a binary search tree structure that will
    keep the elements in a proper order. As we want this to be a mutable structure,
    we''ll have to perform the following kinds of design activities:'
  prefs: []
  type: TYPE_NORMAL
- en: Design the essential binary tree structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decide which structure is the basis: `MutableSequence`, `MutableMapping`, or
    `MutableSet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the special methods for the collection in the `collections.abc` section
    of the *Python Standard Library* documentation, section 8.4.1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A binary search tree has nodes with two branches: a "less than" branch for
    all keys less than this node, and a "greater than or equal to" branch for keys
    greater than or equal to this node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to examine the fit between our collection and the Python ABCs:'
  prefs: []
  type: TYPE_NORMAL
- en: It's not a great sequence because we don't usually use an index with a binary
    tree. We most often refer to elements in a search tree by their key. However,
    we can force an Integer index without too much difficulty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could be used for the keys of a mapping; this would keep the keys in a sorted
    order. That's a common use for a binary search tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a good alternative to a `set` or a `Counter` class because it trivially
    tolerates multiple items, making it easily bag-like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at creating a sorted multiset or a bag. This can contain multiple
    copies of an object. It will rely on relatively simple comparison tests among
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: This is a rather complex design. There are a great many details. To create a
    background, it's important to read articles such as [http://en.wikipedia.org/wiki/Binary_search_tree](http://en.wikipedia.org/wiki/Binary_search_tree).
    At the end of the previous Wikipedia page are a number of external links that
    will provide further information. It's essential to study the essential algorithms
    in books such as *Introduction to Algorithms* by Cormen, Leiserson, Rivest, and
    Stein or *Data Structures and Algorithms* by Aho, Ullman, and Hopcroft, or *The
    Algorithm Design Manual* by Steven Skiena.
  prefs: []
  type: TYPE_NORMAL
- en: Some design rationale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''re going to split the collection into two classes: `TreeNode` and `Tree`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `TreeNode` class will contains the item as well as the `more`, `less`, and
    `parent` references. We'll also delegate some functionality to this class.
  prefs: []
  type: TYPE_NORMAL
- en: For example, searching for a particular item in order to use `__contains__()`
    or `discard()` will be delegated to the node itself using a simple recursion.
    The algorithm's outline looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: If the target item is equal to the self item, then return `self`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the target item is less than `self.item`, then recursively use `less.find(target
    item)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the target item is greater than `self.item`, then recursively use `more.find(target.item)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use similar delegation to the TreeNode class for more of the real work
    of maintaining the tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: The second class will be a **Facade**, which defines the `Tree` itself. A Facade
    design can also be called a **Wrapper**; the idea is to add features required
    for a particular interface. We'll provide the external interface required by a
    `MutableSet` abstract base class.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithms can be somewhat simpler if there's a root node that's empty and
    always compares as less than all other key values. This can be challenging in
    Python because we don't know—in advance—what types of data the nodes might have;
    we can't easily define a bottom value for the root node. Instead, we'll use a
    special case value of `None`, and endure the overheads of `if` statements checking
    for the root node.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Tree class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s the core of an extension to `MutableSet` class that provides the minimal
    method functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: The initialization is similar to that of a `Counter` object; this class will
    accept an iterable and load the elements into the structure.
  prefs: []
  type: TYPE_NORMAL
- en: The `add()` and `discard()` methods keep track of the overall size. That saves
    counting nodes via a recursive traversal of the tree. These methods also delegate
    their work to the `TreeNode` object at the root of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: The `__contains__()` special method performs a recursive find. It transforms
    a `KeyError` exception into a `False` return value.
  prefs: []
  type: TYPE_NORMAL
- en: The `__iter__()` special method is a generator function. It also delegates the
    real work to recursive iterators within the `TreeNode` class.
  prefs: []
  type: TYPE_NORMAL
- en: We defined `discard()`; mutable sets require this to be silent when attempting
    to discard the missing keys. The abstract superclass provides a default implementation
    of `remove()`, which raises an exception if a key is not found. Both method functions
    must be present; we defined `discard()` based on `remove()` by silencing the exception.
    In some cases, it might be easier to define `remove()` based on `discard()` by
    raising an exception if a problem is found.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the TreeNode class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The overall `Tree` class relies on the `TreeNode` class to handle the detailed
    work of adding, removing, and iterating through the various items in the bag.
    This class is rather large, so we'll present it in three sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the first part that includes finding and iterating through the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: We defined the essential initialization for a node with two variants. We can
    provide as little as just the item; we can provide as much as the item, the two
    subtrees, and the parent link.
  prefs: []
  type: TYPE_NORMAL
- en: The properties are used to ensure that the parent attribute is actually a `weakref`
    attribute that appears like a strong reference. For more information on weak references,
    see [Chapter 2](ch02.html "Chapter 2. Integrating Seamlessly with Python Basic
    Special Methods"), *Integrating Seamlessly with Python – Basic Special Methods*.
    We have mutual references between a `TreeNode` parent object and its children
    objects; this circularity could make it difficult to remove `TreeNode` objects.
    Using a `weakref` breaks the circularity.
  prefs: []
  type: TYPE_NORMAL
- en: We saw the `find()` method, which performs a recursive search from a tree through
    the appropriate subtree looking for the target item.
  prefs: []
  type: TYPE_NORMAL
- en: The `__iter__()` method does what's called an inorder traversal of this node
    and its subtrees. As is typical, this is a generator function that yields the
    values from iterators over each collection of subtrees. Although we could create
    a separate iterator class that's tied to our `Tree` class, there's little benefit
    when a generator function does everything we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the next part of this class to add a new node to a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: This is the recursive search for the proper place to add a new node. The structure
    parallels the `find()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the (more complex) processing to remove a node from the tree.
    This requires some care to relink the tree around the missing node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: The `remove()` method has two sections. The first part is the recursive search
    for the target node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the node is found, there are three cases to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: When we delete a node with no children, we simply delete it and update the parent
    to replace the link with `None`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we delete a node with one child, we can push the single child up to replace
    this node under the parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are two children, we need to restructure the tree. We locate the
    successor node (the least item in the `more` subtree). We can replace the to-be-removed
    node with the content of this successor. Then, we can remove the duplicative former
    successor node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We rely on two private methods. The `_least()` method performs a recursive search
    for the least-valued node in a given tree. The `_replace()` method examines a
    parent to see whether it should touch the `less` or `more` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating the binary tree set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We built a complete new collection. The ABC definitions included a number of
    methods automatically. These inherited methods might not be particularly efficient,
    but they're defined, they work, and we didn't write the code for them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: This example shows us that the set `union` operator for set objects works properly,
    even though we didn't provide code for it specifically. As this is a bag, items
    are duplicated properly, too.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we looked at a number of built-in class definitions. The built-in
    collections are the starting place for most design work. We'll often start with
    `tuple`, `list`, `dict`, or `set`. We can leverage the extension to `tuple`, created
    by `namedtuple()`, for an application's immutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond these classes, we have other standard library classes in the `collections`
    mode that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deque`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChainMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderedDict`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultdict`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Counter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have three standard design strategies, too. We can wrap any of these existing
    classes, or we can extend a class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can also invent an entirely new kind of collection. This requires
    defining a number of method names and special methods.
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations and Trade-offs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with containers and collections, we have a multistep design strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the built-in versions of sequence, mapping, and set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider the library extensions in the collection module as well as extras such
    as `heapq`, `bisect`, and `array`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider a composition of existing class definitions. In many cases, a list
    of `tuple` objects or a `dict` of lists provides the needed features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider extending one of the earlier mentioned classes to provide additional
    methods or attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider wrapping an existing structure as another way to provide additional
    methods or attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, consider a novel data structure. Generally, there is a lot of careful
    analysis available. Start with Wikipedia articles like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/List_of_data_structures](http://en.wikipedia.org/wiki/List_of_data_structures)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the design alternatives have been identified, there are two parts of the
    evaluation left:'
  prefs: []
  type: TYPE_NORMAL
- en: How well the interface fits with the problem domain. This is a relatively subjective
    determination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How well the data structure performs as measured with `timeit`. This is an entirely
    objective result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to avoid the paralysis of analysis. We need to *effectively*
    find the proper collection.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, it is best to profile a working application to see which data
    structure is the performance bottleneck. In some cases, consideration of the complexity
    factors for a data structure will reveal its suitability for a particular kind
    of problem before starting the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most important consideration is this: "For highest performance,
    avoid search".'
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason sets and mappings require hashable objects. A hashable object
    can be located in a set or mapping with almost no processing. Locating an item
    by value (not by index) in a list can take a great deal of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a comparison of a bad set-like use of a list and proper use of a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: We removed and added an item from a list as well as a set.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, abusing a list to get it to perform set-like operations makes the collection
    run 2.7 times as long.
  prefs: []
  type: TYPE_NORMAL
- en: As a second example, we'll abuse a list to make it mapping-like. This is based
    on a real-world example where the original code had two parallel lists to mimic
    the keys and values of a mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll compare a proper mapping with two parallel lists, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: We used one list to look up a value and then set the value in a second, parallel
    list. In the other case, we simply updated a mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, performing an index and update on two parallel lists is a horrifying
    mistake. It takes 8.6 times as long to locate something via `list.index()` as
    it does to locate it via a mapping and the hash value.
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapter, we'll closely look at the built-in numbers and how to create
    new kinds of numbers. As with containers, Python offers a rich variety of built-in
    numbers. When creating a new kind of number, we'll have to define numerous special
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: After looking at numbers, we can look at some more sophisticated design techniques.
    We'll look at how we can create our own decorators and use those to simplify the
    class definition. We'll also look at using mixin class definitions, which are
    similar to the ABC definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. Creating Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can extend the ABC abstractions in the `numbers` module to create new kinds
    of numbers. We might need to do this to create numeric types that fit our problem
    domain more precisely than the built-in numeric types.
  prefs: []
  type: TYPE_NORMAL
- en: The abstractions in the `numbers` module need to be looked at first, since they
    define the existing built-in classes. Before working with new kinds of numbers,
    it's essential to see how the existing numbers work.
  prefs: []
  type: TYPE_NORMAL
- en: We'll digress to look at Python's operator-to-method mapping algorithm. The
    idea is that a binary operator has two operands; either operand can define the
    class that implements the operator. Python's rules for locating the relevant class
    are essential to decide what special methods to implement.
  prefs: []
  type: TYPE_NORMAL
- en: The essential arithmetic operators such as `+`, `-`, `*`, `/`, `//`, `%`, and
    `**` form the backbone of numeric operations. There are additional operators that
    include `^`, `|`, and `&`. These are used for the bit-wise processing of integers.
    They're also used as operators among sets. There are some more operators in this
    class, including `<<`, `>>`. The comparison operators were covered in [Chapter
    2](ch02.html "Chapter 2. Integrating Seamlessly with Python Basic Special Methods"),
    *Integrating Seamlessly with Python - Basic Special Methods*. These include `<`,
    `>`, `<=`, `>=`, `==`, and `!=`. We'll review and extend our study of the comparison
    operators in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of additional special methods for numbers. These include
    the various conversions to other built-in types. Python also defines "in-place"
    combinations of an assignment with an operator. These include `+=`, `-=`, `*=`,
    `/=`, `//=`, `%=`, `**=`, `&=`, `|=`, `^=`, `>>=`, and `<<=`. These are more appropriate
    for mutable objects than numbers. We'll finish by summarizing some of the design
    considerations that go into extending or creating new numbers.
  prefs: []
  type: TYPE_NORMAL
- en: ABCs of numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `numbers` package provides a tower of numeric types that are all implementations
    of `numbers.Number`. Additionally, the `fractions` and `decimal` modules provide
    extension numeric types: `fractions.Fraction` and `decimal.Decimal`.'
  prefs: []
  type: TYPE_NORMAL
- en: These definitions roughly parallel the mathematical thought on the various classes
    of numbers. An article available at [http://en.wikipedia.org/wiki/Number_theory](http://en.wikipedia.org/wiki/Number_theory)
    covers the basics of different kinds of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: What's important is the question of how well computers implement mathematical
    abstractions. To be more specific, we want to be sure that anything that is computable
    in the abstract world of mathematics can be computed using a concrete computer.
    This is why the question of computability is so important. The idea behind a "Turing
    Complete" programming language is that it can compute anything that's computable
    by an abstract Turing Machine. A helpful article can be found at [http://en.wikipedia.org/wiki/Computability_theory](http://en.wikipedia.org/wiki/Computability_theory).
  prefs: []
  type: TYPE_NORMAL
- en: Python defines the following abstractions and their associated implementation
    classes. Further, these classes form an inheritance hierarchy where each abstract
    class inherits from the class above it. As we move down the list, the classes
    have more features. Since there are very few classes, it forms a *tower* rather
    than a tree.
  prefs: []
  type: TYPE_NORMAL
- en: '`numbers.Complex` implemented by `complex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numbers.Real` implemented by `float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numbers.Rational` implemented by `fractions.Fraction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numbers.Integral` implemented by `int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we have `decimal.Decimal`, which is a bit like a float; it isn't
    a proper subclass of `numbers.Real`, but is somewhat like it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it may be obvious, it's still essential to repeat that the `float` value
    is merely an approximation. It's not exact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t be surprised by this sort of thing. The following is an example of using
    the ![ABCs of numbers](graphics/0971OS_07_01.jpg) approximations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>>> (3*5*7*11)/(11*13*17*23*29)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`0.0007123135264946712`'
  prefs: []
  type: TYPE_NORMAL
- en: '`>>> _*13*17*23*29`'
  prefs: []
  type: TYPE_NORMAL
- en: '`105.00000000000001`'
  prefs: []
  type: TYPE_NORMAL
- en: In principle, the further down the number tower we go, the smaller the order
    of infinity. This can be a confusing subject. While the various abstract definitions
    of numbers are each infinite, it's possible to prove that there are different
    orders of infinity. This leads to the idea that floats represent more numbers
    than integers in principle. Pragmatically, a 64-bit float and 64-bit integer have
    the same number of distinct values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the numeric class definitions, there are also a number of conversions
    among the various classes. It''s not possible to convert from every type to every
    other type, so we must work out a matrix that shows the conversions that work
    and conversions that can''t work. The following is a summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '`complex`: This can''t be converted to any other type. A `complex` value can
    be decomposed into the `real` and `imag` portions, both of which are `float`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`: This can be converted explicitly to any type including `decimal.Decimal`.
    Arithmetic operators won''t implicitly coerce a `float` value to `Decimal`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fractions.Fraction`: This can be converted to any of the other types, except
    `decimal.Decimal`. To get to `decimal` requires a two-part operation: (1) to `float`
    (2) to `decimal.Decimal`. This leads to an approximation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: This can be converted to any of the other types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Decimal`: This can be converted to any other type. It is not implicitly coerced
    to other types via arithmetic operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The up and down conversions come from the tower of numeric abstractions shown
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding which types to use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because of the conversions, we see the following four general domains of numerical
    processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complex**: Once we get involved in complex math, we''ll be using `complex`,
    `float`, plus the `cmath` module. We probably aren''t going to use `Fraction`
    or `Decimal` at all. However, there''s no reason to impose restrictions on the
    numeric types; most numbers will be converted to complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Currency**: For currency-related operations, we absolutely must use `Decimal`.
    Generally, when doing currency calculations, there''s no good reason to mix the
    decimal values with non-decimal values. Sometimes, we''ll use the `int` values,
    but there''s no good reason to work with `float` or `complex` along with `Decimal`.
    Remember, floats are approximations, and that''s unacceptable when working with
    currency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bit kicking**: For operations that involve bit and byte processing, we''ll
    generally use `int`, only `int`, and nothing but `int`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conventional**: The broad, vague "everything else" category. For most conventional
    mathematical operations `int`, `float`, and `Fraction` are all interchangeable.
    Indeed, a well-written function can often be properly polymorphic; it will work
    perfectly well with any numeric type. Python types, particularly `float` and `int`,
    will participate in a variety of implicit conversions. This makes the selection
    of a specific numeric type for these kinds of problems somewhat moot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are generally obvious aspects of a problem domain. It's usually easy to
    distinguish applications that might involve science or engineering and complex
    numbers from applications that involve financial calculations, currency, and decimal
    numbers. It's important to be as permissive as possible in the numeric types that
    are used in an application. Needlessly narrowing the domain of types via the `isinstance()`
    test is often a waste of time and code.
  prefs: []
  type: TYPE_NORMAL
- en: The method resolution and the reflected operator concept
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The arithmetic operators (`+`, `-`, `*`, `/`, `//`, `%`, `**`, and so on) all
    map to special method names. When we provide an expression such as `355+113`,
    the generic `+` operator will be mapped to a concrete `__add__()` method of a
    specific numeric class. This example will turn out to be evaluated as though we
    had written `355.__add__(113)`. The simplest rule is that the left-most operand
    determines the class of the operator being used.
  prefs: []
  type: TYPE_NORMAL
- en: But wait, there's more! When we have an expression with mixed types, Python
    may end up with two implementations of the special methods, one in each class.
    Consider `7-0.14` as an expression. Using the left-side `int` class, this expression
    will be attempted as `7.__sub__(0.14)`. This involves an unpleasant complexity,
    since the argument to an `int` operator is a `float` value `0.14` and converting
    `float` to `int` could potentially lose precision. Converting up the tower of
    types (from `int` toward `complex`) won't lose precision. Converting down the
    tower of types implies a potential loss of precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the right-side `float` version, however, this expression will be attempted
    as: `0.14.__rsub__(7)`. In this case, the argument to a `float` operator is an
    `int` value `7`; converting `int` up the tower to `float` doesn''t (generally)
    lose precision. (A truly giant `int` value can lose precision; however, that''s
    a technical quibble, not a general principle.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__rsub__()` operation is "reflected subtraction". The `X.__sub__(Y)` operation
    is the expected ![The method resolution and the reflected operator concept](graphics/0971OS_07_02.jpg).
    The `A.__rsub__(B)` operation is the reflection ![The method resolution and the
    reflected operator concept](graphics/0971OS_07_03.jpg); the implementation method
    comes from the right-hand side operand''s class. We''ve seen the following two
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Try the left-hand side operand's class first. If that works, good. If the operand
    returns `NotImplemented` as a value, then use rule 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try the right-hand side operand with the reflected operator. If that works,
    good. If it returns `NotImplemented`, then it really is not implemented, so an
    exception must be raised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The notable exception is when the two operands happen to have a subclass relationship.
    This additional rule applies before the first pair rules as a special case:'
  prefs: []
  type: TYPE_NORMAL
- en: If the right operand is a subclass of the left and the subclass defines the
    reflected special method name for the operator, then the subclass reflected operator
    will be tried. This allows a subclass override to be used, even if the subclass
    operand is on the right-hand side of the operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, use rule 1 and try the left side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine we wrote a subclass of float, `MyFloat`. In an expression like `2.0-MyFloat(1)`,
    the right operand is of a subclass of the left operand's class. Because of this
    subclass relationship, `MyFloat(1).__rsub__(2.0)` will be tried first. The point
    of this rule is to give precedence to the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: This means that a class that will do implicit coercion from other types must
    implement the forward, as well as the reflected operators. When we implement or
    extend a numeric type, we must work out the conversions that our type is able
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: The arithmetic operator's special methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a total of 13 binary operators and their associated special methods.
    We''ll focus on the obvious arithmetic operators first. The special method names
    match the operators (and functions), as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__add__(self, other)` | `+` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__sub__(self, other)` | `-` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__mul__(self, other)` | `*` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__truediv__(self, other)` | `/` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__floordiv__(self, other)` | `//` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__mod__(self, other)` | `%` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__divmod__(self, other)` | `divmod()` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__pow__(self, other[, modulo])` | `pow()` as well as `**` |'
  prefs: []
  type: TYPE_TB
- en: 'And yes, interestingly, two functions are included with the various symbolic
    operators. There are a number of unary operators and functions which have special
    method names, shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__neg__(self)` | `-` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__pos__(self)` | `+` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__abs__(self)` | `abs()` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__complex__(self)` | `complex()` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__int__(self)` | `int()` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__float__(self)` | `float()` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__round__(self[, n])` | `round()` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__trunc__(self[, n])` | `math.trunc()` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__ceil__(self[, n])` | `math.ceil()` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__floor__(self[, n])` | `math.floor()` |'
  prefs: []
  type: TYPE_TB
- en: 'And yes, there are a lot of functions in this list too. We can tinker with
    Python''s internal trace to see what''s going on under the hood. We''ll define
    a simplistic trace function that will provide us with a little bit of visibility
    into what''s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will dump special method names when the code associated with
    the traced frame has a name that starts with `"__"`. We can install this trace
    function into Python using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, everything passes through our `trace()` function. We''re filtering
    the trace events for special method names. We''ll define a subclass of a built-in
    class so that we can explore the method resolution rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'This class overrides just two of the operator''s special method names. When
    we add `noisyfloat` values, we''ll see a printed summary of the operation. Plus,
    the trace will tell us what''s going on. The following is the interaction that
    shows Python''s choice of class to implement a given operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: From `x+3`, we see how `noisyfloat+int` provided the `int` object, `3`, to the
    `__add__()` method. This value was passed to the superclass, `float`, which handled
    the coercion of 3 to a `float` and did the addition, too. `2+x` shows how the
    right side `noisyfloat` version of the operation was used. Again, `int` was passed
    to the superclass that handled the coercion to `float`. From `x+2.3`, we come
    to know that `noisyfloat+float` used the subclass that was on the left-hand side.
    On the other hand, `2.3+x` shows how `float+noisyfloat` used the subclass on the
    right-hand side and the reflected `__radd__()` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a numeric class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll try to design a new kind of number. This is no easy task when Python already
    offers integers of indefinite precision, rational fractions, standard floats,
    and decimal numbers for currency calculations. We'll define a class of "scaled"
    numbers. These are numbers that include an integer value coupled with a scaling
    factor. We can use these for currency calculations. For many currencies of the
    world, we can use a scale of 100 and do all our calculations to the nearest cent.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of scaled arithmetic is that it can be done very simply by using
    low-level hardware instructions. We could rewrite this module to be a C-language
    module and exploit hardware speed operations. The disadvantage of inventing new
    scaled arithmetic is that the `decimal` package already does a very neat job of
    exact decimal arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: We'll call this `FixedPoint` class because it will implement a kind of fixed
    decimal point number. The scale factor will be a simple integer, usually a power
    of 10\. In principle, a scaling factor that's a power of 2 could be considerably
    faster, but wouldn't be ideally suited for currency.
  prefs: []
  type: TYPE_NORMAL
- en: The reason a scaling factor that's a power of 2 can be faster is that we can
    replace `value*(2**scale)` with `value << scale` and replace `value/(2**scale)`
    with `value >> scale`. The left and right shift operations are often hardware
    instructions that are much faster than multiplication or division.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the scaling factor is a power of 10, but we don't explicitly enforce
    this. It's a relatively simple extension to track both a scaling power and the
    scale factor that goes with the power. We might store 2 as the power and ![Creating
    a numeric class](graphics/0971OS_07_04.jpg) as the factor. We've simplified this
    class definition to just track the factor.
  prefs: []
  type: TYPE_NORMAL
- en: Defining FixedPoint initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll start with initialization, which includes conversions of various types
    to the `FixedPoint` values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `FixedPoint` class is defined as a `numbers.Rational` subclass. We''re
    going to wrap two integer values, `scale` and `value`, and follow the general
    definitions for fractions. This requires a large number of special method definitions.
    The initialization is for an immutable object, so it overrides `__new__()` instead
    of `__init__()`. It defines a limited number of slots to prevent the adding of
    any additional attributes. The initialization includes several kinds of conversions
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If we're given another `FixedPoint` object, we'll copy the internal attributes
    to create a new `FixedPoint` object that's a kind of clone of the original. It
    will have a unique ID, but we can be sure it has the same hash value and compares
    as equal, making the clone largely indistinguishable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When given integral or rational values (concrete classes of `int` or `float`),
    these are used to set the `value` and `scale` attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add cases to handle `decimal.Decimal` and `fractions.Fraction`, as well
    as parsing input string values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve defined three special methods to produce string results: `__str__()`,
    `__repr__()`, and `__format__()`. For the format operation, we''ve decided to
    leverage the existing floating-point features of the format specification language.
    Because this is a rational number, we need to provide numerator and denominator
    methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could have also started with wrapping the existing `fractions.Fraction`
    class. Also, note that we're playing fast and loose with the rounding rules. This
    should also be defined with reasonable care before applying this class to a specific
    problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: Defining FixedPoint binary arithmetic operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The whole reason for defining a new class of numbers is to overload the arithmetic
    operators. Each `FixedPoint` object has two parts: `value` and `scale`. We can
    say this: ![Defining FixedPoint binary arithmetic operators](graphics/0971OS_07_05.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we've worked out the algebra in the example below using correct but
    inefficient floating point expressions. We'll discuss the slightly more efficient,
    pure integer operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general form for addition (and subtraction) is this: ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_06.jpg). But it creates a result
    with a lot of useless precision.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine adding 9.95 and 12.95\. We'd have (in principle) 229000/10000\. This
    can be properly reduced to 2290/100\. The problem is that it also reduces to 229/10,
    which is no longer in cents. We'd like to avoid reducing fractions in a general
    way and instead stick with cents or mils to the extent possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can identify two cases for ![Defining FixedPoint binary arithmetic operators](graphics/0971OS_07_07.jpg):'
  prefs: []
  type: TYPE_NORMAL
- en: '**The scale factors match**: In this case, the sum is ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_08.jpg). When adding `FixedPoint`
    and the plain old integer, this will also work, since we can force the plain old
    integer to have the required scale factor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The scale factors don''t match**: The right thing to do is to produce a result
    that has the maximum scale factor of the two input values, ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_09.jpg). From this, we can compute
    two scale factors, ![Defining FixedPoint binary arithmetic operators](graphics/0971OS_07_10.jpg)
    and ![Defining FixedPoint binary arithmetic operators](graphics/0971OS_07_11.jpg).
    One of those scale factors will be 1, the other will be less than 1\. We can now
    add with a common value in the denominator. Algebraically, it''s ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_12.jpg). This can be further optimized
    into two cases, since one of the factors is 1 and the other is a power of 10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can't really optimize multiplication. It's essentially ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_13.jpg). The precision really
    does increase when we multiply the `FixedPoint` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Division is multiplication by an inverse, ![Defining FixedPoint binary arithmetic
    operators](graphics/0971OS_07_14.jpg). If A and B have the same scale, these values
    will cancel so that we do have a handy optimization available. However, this changes
    the scale from cents to wholes, which might not be appropriate. The following
    is what the forward operators, built around a similar boilerplate, look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: For the simple addition, subtraction, and multiplication cases, we've provided
    versions that can be optimized to eliminate some of the relatively slow floating
    point intermediate results.
  prefs: []
  type: TYPE_NORMAL
- en: For the two divisions, the `__mod__()` and `__pow__()` methods, we haven't done
    any optimization to try and eliminate noise being introduced via floating-point
    division. Instead, we've provided a working Python implementation that can be
    used with a suite of unit tests as a basis for optimization and refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that the division operations can properly reduce the
    scale factors. However, that may be undesirable. When doing currency work, we
    might divide the currency rate (dollars) by a non-currency value (hours) to get
    the dollars-per-hour result. The proper answer might have zero relevant decimal
    places, this would be a scale of 1, but we might want to force the value to have
    a cents-oriented scale of 100\. This implementation assures that the left-hand
    side operand dictates the desired number of decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: Defining FixedPoint unary arithmetic operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the unary operators method functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: For the `__round__()`, `__trunc__()`, `__ceil__()`, and `__floor__()` operators,
    we've delegated the work to a Python library function. There are some potential
    optimizations, but we've taken the lazy route of creating a float approximation
    and using that to create the desired result. This suite of methods assures that
    our `FixedPoint` objects will work with a number of arithmetic functions. Yes,
    there are a lot of operators in Python. This isn't the entire suite. We haven't
    covered comparison or bit-kicking operators.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing FixedPoint reflected operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The reflected operators are used in the following two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The right-hand operand is a subclass of the left-hand operand. In this case,
    the reflected operator is tried first to assure that the subclass overrides the
    parent class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The left-hand operand's class doesn't implement the needed special method. In
    this case, the right-hand operand's reflected special method is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table shows the mapping between reflected special methods and
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__radd__(self, other)` | `+` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__rsub__(self, other)` | `-` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__rmul__(self, other)` | `*` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__rtruediv__(self, other)` | `/` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__rfloordiv__(self, other)` | `//` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__rmod__(self, other)` | `%` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__rdivmod__(self, other)` | `divmod()` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__rpow__(self, other[, modulo])` | `pow()` as well as `**` |'
  prefs: []
  type: TYPE_TB
- en: 'These reflected operation special methods are also built around a common boilerplate.
    Since these are reflected, the order of the operands in subtraction, division,
    modulus, and power is important. For commutative operations such as addition and
    multiplication, the order doesn''t matter. The following are the reflected operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: We've tried to use math that is identical to the forward operators. The idea
    is to switch the operands in a simple way. This is the most common situation.
    Having the text of the forward and reverse methods match each other simplifies
    code inspections.
  prefs: []
  type: TYPE_NORMAL
- en: As with the forward operators, we've kept the division, modulus, and power operators
    simple to avoid optimizations. The versions shown here can introduce noise from
    the conversion to a floating-point approximation and back to a `FixedPoint` value.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing FixedPoint comparison operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the six comparison operators and the special methods which
    implement them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__lt__(self, other)` | `<` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__le__(self, other)` | `<=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__eq__(self, other)` | `==` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__ne__(self, other)` | `!=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__gt__(self, other)` | `>` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__ge__(self, other)` | `>=` |'
  prefs: []
  type: TYPE_TB
- en: The `is` operator compares object IDs. We can't meaningfully override this,
    since it's independent of any specific class. The `in` comparison operator is
    implemented by `object.__contains__( self, value )`. This isn't meaningful for
    numeric values.
  prefs: []
  type: TYPE_NORMAL
- en: Note that equality testing is a subtle business. Since floats are approximations,
    we have to be very careful to avoid direct equality testing with float values.
    We really need to compare to see if the values are within a small range, that
    is, epsilon. It should never be written as `a == b`. The general approach to compare
    floating-point approximations should be `abs(a-b) <= eps`. Or, more correctly,
    `abs(a-b)/a <= eps`.
  prefs: []
  type: TYPE_NORMAL
- en: In our `FixedPoint` class, the scale indicates how close two values need to
    be for a `float` value to be considered equal. For a scale of 100, the epsilon
    could be 0.01\. We'll actually be more conservative than that and use 0.005 as
    the basis for comparison when the scale is 100.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we have to decide whether `FixedPoint(123, 100)` should be equal
    to `FixedPoint(1230, 1000)` or not. While they're mathematically equal, one value
    is in cents and one is in mils. This can be taken as a claim about the different
    accuracies of the two numbers; the presence of an additional significant digit
    may indicate that they're not supposed to simply appear equal. If we follow this
    approach, then we need to be sure the hash values are different too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We think the distinguishing scale is not appropriate for our application. We
    want `FixedPoint(123, 100)` to be equal to `FixedPoint(1230, 1000)`. This is the
    assumption behind the recommended `__hash__()` implementation too. The following
    are the implementations for our `FixedPoint` class comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: Each of the comparison functions tolerates a value that is not a `FixedPoint`
    value. The only requirement is that the other value must have a floating-point
    representation. We've defined a `__float__()` method for the `FixedPoint` objects,
    so the comparison operations will work perfectly well when comparing the two `FixedPoint`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to write all six comparisons. The `@functools.total_ordering`
    decorator can generate the missing methods from just two `FixedPoint` values.
    We'll look at this in [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins
    – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*.
  prefs: []
  type: TYPE_NORMAL
- en: Computing a numeric hash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We do need to define the `__hash__()` method properly. See section 4.4.4 of
    the *Python Standard Library* for information on computing hash values for numeric
    types. That section defines a `hash_fraction()` function, which is the recommended
    solution for what we''re doing here. Our method looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: This reduces a two-part rational fraction value to a single, standardized hash.
    This code is copied with a few modifications from the reference manual. The core
    of the calculation, which is highlighted, multiplies the numerator by the inverse
    of the denominator. In effect, it carries out the division of the numerator by
    the denominator, `mod P`. We can optimize this to make it more specific to our
    problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: First, we can (and should) modify our `__new__()` method to assure that the
    scale is nonzero, eliminating any need for `sys.hash_info.inf`. Second, we should
    explicitly limit the range of the scale factor to be less than `sys.hash_info.modulus`
    (generally ![Computing a numeric hash](graphics/0971OS_07_15.jpg) for 64-bit computers).
    We can eliminate the need to remove common factors of `P`. That would boil the
    hash down to `hash_ = (abs(m) % P) * pow(n, P - 2, P) % P`, the sign handling
    and the special case that -1 is mapped to -2.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we might want to memorize the result of any hash calculation. This
    requires an additional slot that's only populated once the first time a hash is
    requested. The `pow(n, P - 2, P)` expression is relatively expensive to evaluate
    and we don't want to compute it more often than necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Designing more useful rounding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We truncated the presentation on rounding. We defined the required functions
    for `round()` and `trunc()` without further explanation. These definitions are
    the minimum requirements of the abstract superclass. However, these definitions
    are not quite enough for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To process currency, we''ll often have code that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to round this value off to a scale of `100` to get a value of
    `942`. We need methods that will round (as well as truncate) a number to a new
    scale factor. The following is a method to round to a specific scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code allows us to properly rescale the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: This shows that we have a minimal set of functions to calculate currency.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing other special methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the core arithmetic and comparison operators, we have a group
    of additional operators that (generally) we only define for the `numbers.Integral`
    values. Since we''re not defining integral values, we can avoid these special
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__lshift__(self, other)` | `<<` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__rshift__(self, other)` | `>>` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__and__(self, other)` | `&` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__xor__(self, other)` | `^` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__or__(self, other)` | `&#124;` |'
  prefs: []
  type: TYPE_TB
- en: 'Also, there are reflected versions of these operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__rlshift__(self, other)` | `<<` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__rrshift__(self, other)` | `>>` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__rand__(self, other)` | `&` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__rxor__(self, other)` | `^` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__ror__(self, other)` | `&#124;` |'
  prefs: []
  type: TYPE_TB
- en: 'Additionally, there''s a unary operator for a bit-wise inverse of the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__invert__(self)` | `~` |'
  prefs: []
  type: TYPE_TB
- en: Interestingly, some of these operators are defined for the set collection, as
    well as integral numbers. They don't apply to our rational value. The principles
    to define these operators are the same as the other arithmetic operators.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization with the in-place operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, numbers are immutable. However, the numeric operators are also used
    for mutable objects. Lists and sets, for example, respond to a few of the defined
    augmented assignment operators. As an optimization, a class can include an in-place
    version of a selected operator. These methods implement the augmented assignment
    statements for mutable objects. Note that these methods are expected to end with
    `return self` to be compatible with ordinary assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__iadd__(self, other)` | `+=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__isub__(self, other)` | `-=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__imul__(self, other)` | `*=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__itruediv__(self, other)` | `/=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__ifloordiv__(self, other)` | `//=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__imod__(self, other)` | `%=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__ipow__(self, other[, modulo])` | `**=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__ilshift__(self, other)` | `<<=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__irshift__(self, other)` | `>>=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__iand__(self, other)` | `&=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__ixor__(self, other)` | `^=` |'
  prefs: []
  type: TYPE_TB
- en: '| `object.__ior__(self, other)` | `&#124;=` |'
  prefs: []
  type: TYPE_TB
- en: 'Since our `FixedPoint` objects are immutable, we should not define any of these.
    Stepping outside this example, for a moment, we can see a more typical use for
    in-place operators. We could easily define some in-place operators for our Blackjack
    `Hand` objects. We might want to add this definition to `Hand` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to deal into `hand` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: This seems to be an elegant way to indicate that `hand` is updated with another
    card.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've looked at the built-in numeric types. We've also looked at the vast number
    of special methods required to invent a new numeric type. Specialized numeric
    types that integrate seamlessly with the rest of Python is one of the core strengths
    of the language. That doesn't make the job easy. It merely makes it elegant and
    useful when done properly.
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations and trade-offs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with numbers, we have a multistep design strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the built-in versions of `complex`, `float`, and `int`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider the library extensions such as `decimal` and `fractions`. For financial
    calculations, `decimal` must be used; there is no alternative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider extending one of the above classes with additional methods or attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, consider a novel number. This is particularly challenging, since Python's
    variety of available numbers is very rich.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Defining new numbers involves several considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Completeness and consistency**: The new number must perform a complete set
    of operations and behave consistently in all kinds of expressions. This is really
    a question of properly implementing the formal mathematical definitions of this
    new kind of computable number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fit with the problem domain**: Is this number truly suitable? Does it help
    clarify the solution?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: As with other design questions, we must be sure that our implementation
    is efficient enough to warrant writing all that code. Our example in this chapter,
    for example, uses some inefficient floating-point operations that could be optimized
    by doing a little more math and a little less coding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking forward
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next chapter is about using decorators and mixins to simplify and normalize
    class design. We can use decorators to define features that should be present
    in a number of classes, which are not in a simple inheritance hierarchy. Similarly,
    we can use mixin class definitions to create a complete application class from
    component class definitions. One of the decorators that is helpful to define comparison
    operators is the `@functools.total_ordering` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8. Decorators and Mixins – Cross-cutting Aspects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A software design often has aspects that apply across several classes, functions,
    or methods. We might have a technical aspect, examples include logging, auditing,
    or security, that must be implemented consistently. The general method for reuse
    of functionality in object-oriented programming is inheritance through a class
    hierarchy. However, inheritance doesn't always work out well. Some aspects of
    a software design are orthogonal to the class hierarchy. These are sometimes called
    "cross-cutting concerns". They cut across the classes, making design more complex.
  prefs: []
  type: TYPE_NORMAL
- en: A decorator provides a way to define functionality that's not bound to the inheritance
    hierarchy. We can use decorators to design an aspect of our application and then
    apply the decorators across classes, methods, or functions.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we can use multiple inheritance in a disciplined way to create
    cross-cutting aspects. We'll consider a base class plus mixin class definitions
    to introduce features. Often, we'll use the mixin classes to build cross-cutting
    aspects.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that cross-cutting concerns are rarely specific to the
    application at hand. They're often generic considerations. The common examples
    of logging, auditing, and security could be considered as infrastructure separate
    from the application's details.
  prefs: []
  type: TYPE_NORMAL
- en: Python comes with many decorators, and we can expand this standard set of decorators.
    There are several different use cases. We'll look at simple function decorators,
    function decorators with arguments, class decorators, and method decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Class and meaning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One essential feature of objects is that they can be classified. Each object
    belongs to a class. This is a straightforward relationship between an object and
    class with a simple, single-inheritance design.
  prefs: []
  type: TYPE_NORMAL
- en: With multiple inheritance, the classification problem can become complex. When
    we look at real-world objects, such as coffee cups, we can classify them as containers
    without too much difficulty. That is, after all, their primary use case. The problem
    they solve is that of holding coffee. However, in another context, we may be interested
    in other use cases. In a decorative collection of ceramic mugs, we might be more
    interested in size, shape, and glaze than we are in the coffee-carrying aspect
    of a cup.
  prefs: []
  type: TYPE_NORMAL
- en: Most objects have a straightforward *is-a* relationship with a class. In our
    coffee-holding problem domain, the mug sitting on the desk is a coffee cup as
    well as a container. Objects may also have several *acts-as* relationships with
    other classes. A mug acts as a piece of ceramic art with size, shape, and glaze
    properties. A mug acts as a paper weight with mass and friction properties. Generally,
    these other features can be seen as mixin classes, and they define the additional
    interfaces or behaviors for an object.
  prefs: []
  type: TYPE_NORMAL
- en: When doing object-oriented design, it's common to identify the *is-a* class
    and the essential aspects defined by that class. Other classes can mix in interfaces
    or behaviors that an object will also have. We'll take a look at how classes are
    constructed and decorated. We'll start with function definition and decoration
    since it's somewhat simpler than class construction.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We construct functions in two stages. The first stage is the `def` statement
    with an original definition.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's technically possible to build a function using a lambda and assignment;
    we'll avoid that.
  prefs: []
  type: TYPE_NORMAL
- en: A `def` statement provides a name, parameters, defaults, a `docstring`, a code
    object, and a number of other details. A function is a collection of 11 attributes,
    defined in section 3.2 of the *Python Language Reference* which is the standard
    type hierarchy. See [http://docs.python.org/3.3/reference/datamodel.html#the-standard-type-hierarchy](http://docs.python.org/3.3/reference/datamodel.html#the-standard-type-hierarchy).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second stage is applying a decorator to the original definition. When we
    apply a decorator (`@d`) to a function (`F`), the effect is as if we have created
    a new function, ![Constructing the functions](graphics/0971OS_08_01.jpg). The
    name is the same, but the functionality can be different depending on the kind
    of features that have been added, removed, or modified. Then, we will write the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorator is written immediately in front of the function definition. What
    happens is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorator modifies the function definition to create a new function. Here
    is the list of attributes of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Contents |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `__doc__` | The docstring, or `None`. |'
  prefs: []
  type: TYPE_TB
- en: '| `__name__` | The original name of the function. |'
  prefs: []
  type: TYPE_TB
- en: '| `__module__` | The name of the module the function was defined in, or `None`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `__qualname__` | The function''s fully qualified name, `__module__.__name__`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `__defaults__` | The default argument values, or none if there are no defaults.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `__kwdefaults__` | The default values for keyword-only parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `__code__` | The code object representing the compiled function body. |'
  prefs: []
  type: TYPE_TB
- en: '| `__dict__` | A namespace for the function''s attributes. |'
  prefs: []
  type: TYPE_TB
- en: '| `__annotations__` | The annotations of parameters, including `''return''`
    for the return annotation. |'
  prefs: []
  type: TYPE_TB
- en: '| `__globals__` | The global namespace of the module that the function was
    defined in; this is used to resolve global variables and is read only. |'
  prefs: []
  type: TYPE_TB
- en: '| `__closure__` | Bindings for the function''s free variables or none. It is
    read-only. |'
  prefs: []
  type: TYPE_TB
- en: Except for `__globals__` and `__closure__`, a decorator can change any of these
    attributes. However, we'll see later that it's impractical to tinker with these
    too deeply.
  prefs: []
  type: TYPE_NORMAL
- en: Pragmatically, decoration usually involves defining a new function that *wraps*
    the existing function. A few of the previous attributes may need to be copied
    or updated. This defines a practical limit to what decorators can and should do.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Class construction is a nested set of two-stage processes. Making class construction
    more complex is the way references are made to class methods that involve a multistep
    lookup. An object's class will define a **Method Resolution Order** (**MRO**).
    This defines how base classes are searched to locate an attribute or method name.
    The MRO works its way up the inheritance hierarchy; this means that subclass names
    override superclass names. This implementation method search meets our expectation
    for what inheritance means.
  prefs: []
  type: TYPE_NORMAL
- en: The first stage in class construction is the `class` statement with the original
    definition. This stage involves the evaluation of the metaclass followed by the
    execution of the sequence of assignment and `def` statements within a `class`.
    Each `def` statement within the class expands to a nested two-stage function construction,
    as described previously. Decorators can be applied to each method function as
    part of the process of building the class.
  prefs: []
  type: TYPE_NORMAL
- en: The second stage in class construction is to apply an overall class decorator
    to a class definition. Generally, a `decorator` function can add features. It's
    somewhat more common to add attributes rather than adding methods. However, we
    will see decorators that can also add method functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The features inherited from superclasses clearly cannot be modified through
    decorators since they are resolved lazily by method resolution lookup. This leads
    to some important design considerations. We generally introduce methodsthrough
    classes and mixin classes. We''re limited to introducing attributes either via
    decorators or mixin class definitions. Here''s a list of some of the attributes
    that are built for a class. A number of additional attributes are part of the
    metaclass; they are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Contents |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `__doc__` | The class''s documentation string, or `None` if undefined |'
  prefs: []
  type: TYPE_TB
- en: '| `__name__` | The class name |'
  prefs: []
  type: TYPE_TB
- en: '| `__module__` | The module name that the class was defined in |'
  prefs: []
  type: TYPE_TB
- en: '| `__dict__` | The dictionary containing the class''s namespace |'
  prefs: []
  type: TYPE_TB
- en: '| `__bases__` | A tuple (possibly empty or a singleton) containing the base
    classes, in the order of their occurrence in the base class list; it is used to
    work out method resolution order |'
  prefs: []
  type: TYPE_TB
- en: '| `__class__` | The superclass of this class, often the `type` class |'
  prefs: []
  type: TYPE_TB
- en: Some additional method functions that are part of a class include `__subclasshook__`,
    `__reduce__`, and `__reduce_ex__`, which are part of the interface for `pickle`.
  prefs: []
  type: TYPE_NORMAL
- en: Some class design principles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When defining a class, we have the following three sources of attributes and
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The class statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorators applied to the class definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mixin classes with the base class that is given last
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to be cognizant of the level of visibility for each of these. The `class`
    statement is the most obvious source for attributes and methods. The mixins and
    the base class are somewhat less obvious than the class body. It's helpful to
    make sure that the base class name clarifies its role as essential. We've tried
    to name our base classes after real-world objects.
  prefs: []
  type: TYPE_NORMAL
- en: The mixin classes will generally define additional interfaces or behaviors of
    a class. It's important to be clear how the mixin classes are used to build the
    final class definitions. While a `docstring` class is an important part of this,
    the overall module `docstring` is also important to show how a proper class can
    be assembled from the various parts.
  prefs: []
  type: TYPE_NORMAL
- en: When writing the `class` statement, the essential superclass is listed last
    and the mixins are listed before that. This is not merely convention. The last
    listed class is the essential *is-a* class. The application of the decorator to
    the class will lead to somewhat more obscure features. Typically, a decorator
    will do relatively little. A strong focus on one or a few features helps to clarify
    what the decorator does.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-oriented programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Parts of **aspect-oriented programming** (**AOP**) are relevant to decorators.
    Our purpose here is to leverage a few aspect-oriented concepts to help show the
    purpose of decorators and mixins in Python. The idea of a **cross-cutting concern**
    is central to AOP. Here''s some additional background: [http://en.wikipedia.org/wiki/Cross-cutting_concern](http://en.wikipedia.org/wiki/Cross-cutting_concern).
    There are several common examples of cross-cutting concerns, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logging**: We often need to have logging features implemented consistently
    in many classes. We want to be sure the loggers are named consistently and logging
    events follow the class structure in a consistent manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auditability**: A variation of the logging theme is to provide an audit trail
    that shows each transformation of a mutable object. In many commerce-oriented
    applications, the transactions are business records that represent bills or payments.
    Each step in the processing of a business record needs to be auditable to show
    that no errors have been introduced by the processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Our applications will often have security aspects that pervade
    each HTTP request and each piece of content downloaded by the website. The idea
    is to confirm that each request involves an authenticated user who is authorized
    to make the request. Cookies, secure sockets, and other cryptographic techniques
    must be used consistently to assure that an entire web application is secured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some languages and tools have deep, formal support for AOP. Python borrows
    a few of the concepts. The Pythonic approach to AOP involves the following language
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decorators**: With a decorator, we can establish a consistent aspect implementation
    at one of two simple join points in a function. We can perform the aspect''s processing
    before or after the existing function. We can''t easily locate join points inside
    the code of a function. It''s easiest for decorators to transform a function or
    method by wrapping it with additional functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixins**: With a mixin, we can define a class that exists outside a single
    class hierarchy. The mixin class can be used with other classes to provide a consistent
    implementation of a cross-cutting aspect. For this to work, the mixin API must
    be used by the classes that it is mixed into. Generally, mixin classes are considered
    abstract since they can''t be meaningfully instantiated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using built-in decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has several built-in decorators that are part of the language. The `@property`,
    `@classmethod`, and `@staticmethod` decorators are used to annotate methods of
    a class. The `@property` decorator transforms a method function into a descriptor.
    We use this to give a method function the syntax of a simple attribute. The property
    decorator, when applied to a method, also creates an additional pair of properties
    that can be used to create a `setter` and `deleter` property. We looked at this
    in [Chapter 3](ch03.html "Chapter 3. Attribute Access, Properties, and Descriptors"),
    *Attribute Access, Properties, and Descriptors*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@classmethod` and `@staticmethod` decorators transform a method function
    into a class-level function. The decorated method can now be called from a class,
    not an object. In the case of a static method, there''s no explicit reference
    to the class. With a class method, on the other hand, the class is the first argument
    of the method function. The following is an example of a class that includes `@staticmethod`
    and some `@property` definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: This class defines an `Angle` that can be represented in degrees or radians.
    The constructor expects degrees. However, we've also defined a `from_radians()`
    method function that emits an instance of the class. This function does not work
    with an instance variable; it works with the class itself and returns an instance
    of the class. The `__new__()` method is implicitly a class method. A decorator
    is not used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we provide the `degrees()` and `radians()` method functions that
    have been decorated so that they are properties. Under the hood, these decorators
    create a descriptor so that accessing the attribute name `degrees` or `radians`
    will invoke the named method function. We can use the `static` method to create
    an instance and then use a `property` method to access a method function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: The static method is effectively a function because it's not tied to the `self`
    instance variable. It has the advantage that it is syntactically bound to the
    class; using `Angle.from_radians` can be microscopically more helpful than using
    a function named `angle_from_radians`. The use of these decorators assures that
    the implementation is done correctly and consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Using standard library decorators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The standard library has a number of decorators. Modules such as `contextlib`,
    `functools`, `unittest`, `atexit`, `importlib`, and `reprlib` contain decorators
    that are excellent examples of cross-cutting aspects of a software design. For
    example, the `functools` library offers the `total_ordering` decorator that defines
    comparison operators. It leverages `__eq__()` and either `__lt__()`, `__le__()`,
    `__gt__()`, or `__ge__()` to create a complete suite of comparisons. The following
    is a variation on the `Card` class that defines just two comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: 'Our class is wrapped by a class-level decorator, `@functools.total_ordering`.
    This decorator creates the missing method functions. We can use this class to
    create objects that can be compared using all of the comparison operators, even
    though only two were defined. Here''s an example of comparisons we''ve defined
    as well as comparisons we have not defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: This interaction shows that we are able to make comparisons that are not defined
    in the original class. The decorator added method functions to the original class
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: Using standard library mixin classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard library makes use of mixin class definitions. There are several
    modules that contain examples, including `io`, `socketserver`, `urllib.request`,
    `contextlib`, and `collections.abc`.
  prefs: []
  type: TYPE_NORMAL
- en: When we define our own collection based on the `collections.abc` abstract base
    classes, we're making use of mixins to assure that cross-cutting aspects of the
    containers are defined consistently. The top-level collections (`Set`, `Sequence`,
    and `Mapping`) are all built from multiple mixins. It's very important to look
    at section 8.4 of the *Python Standard Library* to see how the mixins contribute
    features, as the overall structure is built up from pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at just one line, the summary of `Sequence`, we see that it inherits
    from `Sized`, `Iterable`, and `Container`. These mixin classes lead to methods
    of `__contains__()`, `__iter__()`, `__reversed__()`, `index()`, and `count()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the context manager mixin class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we looked at context managers in [Chapter 5](ch05.html "Chapter 5. Using
    Callables and Contexts"), *Using Callables and Contexts*, we ignored the `ContextDecorator`
    mixin and focused on the special methods themselves. Using the mixin can make
    the definition clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous version of the example, we created a context manager that altered
    a global state; it reset the random number seed. We'll rework that design to make
    a deck that can be its own context manager. When used as a context manager, it
    can generate a fixed sequence of cards. This isn't really the best way to unit
    test a deck of cards. However, it's a simple use of a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining context management as a mixin of an application class requires some
    care. We may have to redesign the initialization method to remove some assumptions.
    Our application classes may be used in the following two distinct ways:'
  prefs: []
  type: TYPE_NORMAL
- en: When used outside a `with` statement, the `__enter__()` and `__exit__()` methods
    will not be evaluated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When used inside a `with` statement, the `__enter__()` and `__exit__()` methods
    will be evaluated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, we can''t assume that it''s valid to evaluate the `shuffle()`
    method during `__init__()` processing because we don''t know whether or not the
    context manager methods will be used. We can''t defer shuffling to `__enter__()`
    because it may not be used. This complexity may indicate that we''re offering
    too much flexibility. Either we have to shuffle lazily, just before the first
    `pop()`, or we have to provide a method function that can be turned off by a subclass.
    The following is a simple `Deck` definition that extends `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve defined this deck to have a removable `_init_shuffle()` method. A subclass
    can override this method to change when the shuffling is complete. A subclass
    of `Deck` can seed the random number generator before shuffling. This version
    of the class can avoid shuffling during creation. The following is a subclass
    of `Deck` that includes the `contextlib.ContextDecorator` mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: This subclass prevents shuffling during initialization by overriding the `_init_shuffle()`
    method. Because this mixes in `ContextDecorator`, it must also define `__enter__()`
    and `__exit__()`. This subclass of `Deck` can work in a `with` context. When used
    in a `with` statement, the random number seed is set, and the shuffling will use
    a known sequence. If it's used outside a `with` statement, then the shuffling
    will use the current random number settings and there will be no `__enter__()`
    evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of this style of programming is to separate the truly essential
    features of a class from other aspects of the `Deck` implementation. We have separated
    some of the random seed processing from other aspects of `Deck`. Clearly, we can
    simplify things a great deal if we simply insist that a context manager is required.
    This is not typical of the way the `open()` function works. However, it can be
    helpful simplification. We can use examples like the following to see the differences
    in behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows how `Deck` can be used by itself to generate randomized
    shuffles. This is the simple use of having `Deck` produce shuffled cards. The
    next example shows `TestDeck` with a given seed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: This shows `TestDeck`, the subclass of `Deck`, which is used as a context manager
    to produce a known sequence of cards. Each time we invoke it, we get the same
    sequence of cards.
  prefs: []
  type: TYPE_NORMAL
- en: Turning off a class feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve turned off the shuffle-during-initialization feature by redefining a
    method function to have a body of `pass`. This process may seem a bit long winded
    to remove a feature from a subclass. There''s an alternative to remove functionality
    in a subclass: to set the method name to be `None`. We can do this inside `TestDeck`
    to remove the initial shuffle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code requires a little more programming in the superclass to
    tolerate the missing method, which is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: This can be a somewhat more explicit way to remove a feature in a subclass definition.
    This shows that the method could be missing or has intentionally been set to `None`.
    Yet another alternative design is to move the call to `_init_shuffle()` from `__init__()`
    to the `__enter__()` method. This will require the use of a context manager that
    will make the object behave properly. That's not too odious a burden if it's documented
    clearly.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple function decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `decorator` function is a function (or a callable object) that returns a
    new function. The simplest case involves a single argument: the function that
    is to be decorated. The result of a decorator is a function that has been wrapped.
    Essentially, the additional features are put either before or after the original
    functionality. These are the two readily available join points in a function.'
  prefs: []
  type: TYPE_NORMAL
- en: When we define a decorator, we want to be sure that the decorated function has
    the original function's name and `docstring`. These attributes should be set by
    a decorator, which we will use to write the decorated functions. Using `functools.wraps`
    to write new decorators simplifies the work we need to do because this bit of
    bookkeeping is handled for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the two places where functionality can be inserted, we can create
    a debug trace decorator that will log parameters and return values from a function.
    This puts functionality both before and after the called function. The following
    is some defined function, `some_function`, that we want to wrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: This snippet shows how we'll have new processing to wrap the original function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s difficult to insert processing into a defined function by poking at the
    underlying `__code__` object. In the rare case where it seems necessary to inject
    an aspect in the middle of a function, it''s much easier to rewrite the function
    as a callable object, by breaking the functionality down into multiple method
    functions. Then, we can use mixin and subclass definitions rather than complex
    code rewriting. The following is a debug decorator that inserts logging before
    and after function evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve used the `functools.wraps` decorator to assure that the original function
    name and `docstring` are preserved in the result function. Now, we can use our
    decorator to produce noisy, detailed debugging. For example, we can do this to
    apply the decorator to some function, `ackermann()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition wraps the `ackermann()` function with debugging information
    written via the logging module to the `root` logger. We configure the logger to
    produce the following debugging output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll revisit logging in detail in [Chapter 14](ch14.html "Chapter 14. The
    Logging and Warning Modules"), *The Logging and Warning Modules*. We''ll see this
    kind of result when we evaluate `ackermann(2,4)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: Creating separate loggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a logging optimization, we might want to use a specific logger for each
    wrapped function and not overuse the root logger for this kind of debugging output.
    We''ll return to the logger in [Chapter 14](ch14.html "Chapter 14. The Logging
    and Warning Modules"), *The Logging and Warning Modules*. The following is a version
    of our decorator that creates a separate logger for each individual function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: 'This version modifies the output to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: The function name is now the logger name. This can be used to fine-tune the
    debugging output. We can now enable logging for individual functions. We can't
    trivially change the decorator and expect the decorated function to also change.
  prefs: []
  type: TYPE_NORMAL
- en: We need to apply the revised decorator to the function. This means that debugging
    and experimenting with decorators can't be done *trivially* from the `>>>` interactive
    prompt. We have to reload the function definitions after we tweak the decorator
    definition. This can involve a bunch of copy and paste, or it can involve rerunning
    a script that defines the decorator, the functions, and then runs tests or a demonstration
    script to show that everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing a decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we want to provide more elaborate parameters to a decorator. The idea
    is that we are going to customize the wrapping function. When we do this, decoration
    becomes a two-step process.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write the following code, we provide a parameterized decorator to a
    function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of the decorator is a shorthand for the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'Both examples do the following three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Defined a function, `func`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied the abstract decorator to its arguments to create a concrete decorator,
    `decorator(arg)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied the concrete decorator to the defined function to create the decorated
    version of the function, `decorator(arg)(func)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that a decorator with arguments will require indirect construction
    of the final function. Let''s tweak our debugging decorator yet again. We''d like
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'This kind of code allows us to specifically name the log that the debugging
    output will go to. We don''t use the root logger nor default to a distinct logger
    for each function. The outline of a parameterized decorator is something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s peel back the layers of this onion before looking at the example. The
    decorator definition (`def decorator(config)`) shows the parameters we will provide
    to the decorator when we use it. The body of this is the concrete decorator, which
    is returned. The concrete decorator (`def concrete_decorator(function)`) is the
    decorator that will be applied to the target function. This, then, is just like
    the simple function decorator shown in the previous section. It builds the wrapped
    function (`def wrapped(*args, **kw)`), which it returns. The following is our
    named logger version of debug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'This `decorator` function accepts an argument that is the name of the log to
    use. It creates and returns a concrete decorator function. When this is applied
    to a function, the concrete decorator returns the wrapped version of the given
    function. When the function is used in the following manner, the decorator adds
    noisy debug lines. They direct the output to a log named `recursion` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: Creating a method function decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A decorator for a method function of a class definition is identical to a decorator
    for a standalone function. It's simply used in a different context. One small
    consequence of this different context is that we often must explicitly name the
    `self` variable.
  prefs: []
  type: TYPE_NORMAL
- en: One application for method function decoration is to produce an audit trail
    for object state change. Business applications often create stateful records;
    commonly, these are represented as rows in a relational database. We'll look at
    object representation in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving
    – JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML*, [Chapter10](ch10.html "Chapter 10. Storing and Retrieving Objects
    via Shelve"), *Storing and Retrieving Objects via Shelve*, and [Chapter 11](ch11.html
    "Chapter 11. Storing and Retrieving Objects via SQLite"), *Storing and Retrieving
    Objects via SQLite*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we have stateful records, the state changes need to be auditable. An audit
    can confirm that appropriate changes have been made to the records. In order to
    do the audit, the before and after version of each record must be available somewhere.
    Stateful database records are a long-standing tradition but are not in any way
    required. Immutable database records are a viable design alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we design a stateful class, any setter method we write will cause a state
    change. These setter methods often use the `@property` decorator so that they
    appear to be simple attributes. If we do this, we can fold in an `@audit` decorator
    that can track changes to the object, so that we have a proper trail of changes.
    We''ll create an audit log via the `logging` module. We''ll use the `__repr__()`
    method function to produce a complete text representation that can be used to
    examine changes. The following is an audit decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created a text memento of the *before* version of the object. Then,
    we''ve applied the original method function. If there was an exception, we would
    produce an audit log that includes the exception details. Otherwise, we''ll produce
    an `INFO` entry in the log that has the qualified name of the method, the before
    memento, and the after memento of the object being changed. The following is a
    modification of the `Hand` class that shows how we''d use this decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: This definition modifies the `__iadd__()` method function, so that adding a
    card becomes an auditable event. This decorator will perform the audit operation,
    saving text mementos of `Hand` before and after the operation.
  prefs: []
  type: TYPE_NORMAL
- en: This use of a method decorator makes a formal declaration that a particular
    method function has made a significant state change. We can easily use code reviews
    to be sure that all of the appropriate method functions are marked for audit like
    this. An open issue is auditing object creation. It's not perfectly clear that
    object creation requires an audit record. It can be argued that object creation
    is not a state change.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the event that we want to audit creation, we can''t use this `audit` decorator
    on the `__init__()` method function. That''s because there''s no before image
    prior to the execution of `__init__()`. There are two things we can do as a remedy
    to this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can add a `__new__()` method that assures that an empty `_cards` attribute
    is seeded into the class as an empty collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can tweak the `audit()` decorator to tolerate `AttributeError` that will
    arise when `__init__()` is being processed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second option is considerably more flexible. We can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: 'This would record a message such as `AttributeError: ''Hand'' object has no
    attribute ''_cards''` for the before status during initialization.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Analogous to decorating a function, we can write a class decorator to add features
    to a class definition. The essential rules are the same. The decorator is a function
    (or callable object). It receives a class object as an argument and returns a
    class object as a result.
  prefs: []
  type: TYPE_NORMAL
- en: We have a limited number of join points inside a class definition as a whole.
    For the most part, a class decorator will fold additional attributes into a class
    definition. It's technically possible to create a new class that wraps an original
    class definition. This is challenging, since the wrapping class must be very generalized.
    It's also possible to create a new class that is a subclass of the decorated class
    definition. This may be baffling to users of the decorator. It's also possible
    to delete features from a class definition, which seems perfectly awful.
  prefs: []
  type: TYPE_NORMAL
- en: One sophisticated class decorator was shown previously. The `functools.Total_Ordering`
    decorator injects a number of new method functions into the class definition.
    The technique used in this implementation is to create lambda objects and assign
    them to attributes of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at a somewhat simpler decorator. During debugging and logging,
    we could have a small problem creating loggers that are focused on our classes.
    Often, we''d like to have a unique logger for each class. We''re often forced
    to do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: This class has the disadvantage that it creates a `logger` instance variable
    that's really not part of the class's operation, but is a separate aspect of the
    class. We'd like to avoid polluting the class with this additional aspect. That's
    not all. Even though `logging.getLogger()` is very efficient, the cost's nonzero.
    We'd like to avoid this additional overhead every time we create an instance of
    `UglyClass1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a slightly better version. The logger is promoted to be a class-level
    instance variable and is separate from each individual object of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the advantage that it implements `logging.getLogger()` just once.
    However, it suffers from a profound DRY problem. We can''t automatically set the
    class name within the class definition. The class hasn''t been created yet, so
    we''re forced to repeat the name. The DRY problem is solved by a small decorator
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'This decorator tweaks the class definition to add the `logger` reference as
    a class-level attribute. Now, each method can use `self.logger` to produce audit
    or debug information. When we want to use this feature, we can use the `@logged`
    decorator on the class as a whole. The following is an example of a logged class,
    `SomeClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: Now, our class has a `logger` attribute that can be used by any method. The
    logger value is not a feature of the object, which keeps this aspect separated
    from the rest of the class aspects. This attribute has the added benefit that
    it creates the logger instances during module import, reducing the overhead of
    logging slightly. Let's compare this with `UglyClass1`, where `logging.getLogger()`
    was evaluated for each instance creation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding method functions to a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A class decorator creates new method functions using a two-step process: by
    creating the method function and then inserting it into the class definition.
    This is often better done via a mixin class than a decorator. The obvious and
    expected use of a mixin is to insert methods. Inserting methods another way is
    less obvious and can be astonishing.'
  prefs: []
  type: TYPE_NORMAL
- en: In the example of the `Total_Ordering` decorator, the exact method functions
    inserted were flexible and depended on what was already provided. This was a kind
    of special case that was typical but also very clever.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might want to define a standardized `memento()` method. We''d like to include
    this standard method function in a variety of classes. We''ll look at the decorator
    and mixin versions of this design. The following is the decorator version of adding
    a standard method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: 'This decorator includes a method function definition that is inserted into
    the class. The following is how we use this `@memento` decorator to add a method
    function to a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorator incorporates a new method, `memento()`, into the decorated class.
    However, this has the following disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: We can't override the implementation of the `memento()` method function to handle
    special cases. It's built into the class *after* the definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can't extend the decorator function easily. We'd have to upgrade to a callable
    object to provide extensions or specializations. If we're going to upgrade to
    a callable object, we should discard this whole approach and use a mixin to add
    the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the mixin class that adds a standard method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is how we use this `Memento` mixin class to define an application
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: The mixin provides a new method, `memento()`; this is the expected, typical
    purpose of a mixin. We can more easily extend the `Memento` mixin class to add
    features. In addition, we can override the `memento()` method function to handle
    special cases.
  prefs: []
  type: TYPE_NORMAL
- en: Using decorators for security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software is filled with cross-cutting concerns, aspects that need to be implemented
    consistently even if they're in separate class hierarchies. It's often a mistake
    to try and impose a class hierarchy around a cross-cutting concern. We've looked
    at a few examples, such as logging and auditing.
  prefs: []
  type: TYPE_NORMAL
- en: We can't reasonably demand that every class that might need to write to the
    log also be a subclass of some `loggable` superclass. We can design a `loggable`
    mixin or a `loggable` decorator. These don't interfere with the proper inheritance
    hierarchy that we need to design to make polymorphism work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important cross-cutting concerns revolve around security. Within a web
    application, there are two sides to the security question as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Do we know who''s making the request?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Is the authenticated user allowed to make the request?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some web frameworks allow us to decorate our request handlers with security
    requirements. The Django framework, for example, has a number of decorators that
    allow us to specify security requirements for a view function or a view class.
    Some of these decorators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user_passes_test`: This is a low-level decorator that''s very generalized
    and is used to build the other two decorators. It requires a test function; the
    logged-in `User` object associated with the request must pass the given function.
    If the `User` instance is not able to pass the given test, they''re redirected
    to a login page so that the person can provide the credentials required to make
    the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login_required`: This decorator is based on `user_passes_test`. It confirms
    that the logged-in user is authenticated. This kind of decorator is used on web
    requests that apply to all people accessing the site. Requests such as changing
    a password or logging out, for example, shouldn''t require any more specific permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permission_required`: This decorator works with Django''s internally defined
    database permission scheme. It confirms that the logged-in user (or the user''s
    group) is associated with the given permission. This kind of decorator is used
    on web requests where specific administrative permissions are required to make
    the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other packages and frameworks also have ways to express this cross-cutting
    aspect of web applications. In many cases, a web application may have even more
    stringent security considerations. We might have a web application where user
    features are selectively unlocked based on contract terms and conditions. Perhaps,
    additional fees will unlock a feature. We might have to design a test like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve defined a function that checks the logged-in `User` `feature_set` collection
    to see if the named feature is associated with `User`. We''ve used our `has_feature()`
    function with Django''s `user_passes_test` decorator to create a new decorator
    that can be applied to the relevant `view` functions. We can then create a `view`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: This assures that the security concerns will be applied consistently across
    a number of `view` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've looked at using decorators to modify function and class definitions. We've
    also looked at mixins that allow us to decompose a larger class into components
    that are knitted together.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of both of these techniques is to separate application-specific features
    from generic features such as security, audit, or logging. We're going to distinguish
    between the inherent features of a class and aspects that aren't inherent but
    are additional concerns. The inherent features are part of the explicit design.
    They're part of the inheritance hierarchy; they define what an object is. The
    other aspects can be mixins or decorations; they define how an object might also
    act.
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations and trade-offs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most cases, this division between *is-a* and *acts-as* is quite clear. Inherent
    features are a part of the overall problem domain. When talking about simulating
    Blackjack play, things such as cards, hands, betting, hitting, and standing are
    clearly part of the problem domain. Similarly, the data collection and statistical
    analysis of outcomes is part of the solution. Other things, such as logging, debugging,
    and auditing are not part of the problem domain but associated with solution technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'While most cases are quite clear, the dividing line between inherent and decoration
    aspects can be fine. In some cases, it may devolve to an aesthetic judgment. Generally,
    the decision becomes difficult when writing framework and infrastructure classes
    that aren''t focused on a specific problem. The general strategy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, aspects that are central to the problem will lead directly to class definitions.
    Many classes are inherent to the problem and form proper class hierarchies so
    that polymorphism works as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, some aspects will lead to mixin class definitions. This often happens
    when there are aspects that are multidimensional. We might have independent axes
    or dimensions to a design. Each dimension can contribute polymorphic alternatives.
    When we look at Blackjack play, there are two kinds of strategies: play strategies
    and betting strategies. These are independent and might be considered the mixin
    elements of an overall player design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we define separate mixins, we can have separate inheritance hierarchies
    for the mixins. For Blackjack betting strategies, we can define a polymorphic
    hierarchy that's unrelated to the polymorphic hierarchy for play strategies. We
    can then define players that have mixin elements from both hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods are generally created from class definitions. They''re either part
    of the primary class or a mixin class. As noted above, we have three design strategies:
    Wrap, Extend, and Invent. We can introduce functionality through "wrapping" a
    class with another class. In some cases, we find that we''re forced to expose
    a large number of methods that are simply delegated to the underlying class. There''s
    a hazy boundary where we have too much delegation; a decorator or mixin would
    have been a better idea. In other cases, wrapping a class may be clearer than
    introducing a mixin class definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Aspects that are orthogonal to the problem can often be handled by decorator
    definitions. The decorators can be used to introduce features that are not part
    of the *is-a* relationship that an object has with its class.
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The coming chapters will change direction. We've seen almost all of Python's
    special method names. The next five chapters are going to focus on object persistence
    and serialization. We'll start out with serializing and saving objects in various
    external notations, including JSON, YAML, Pickle, CSV, and XML.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization and persistence introduce yet more object-oriented design considerations
    for our classes. We'll have a look at object relationships and how they're represented.
    We'll also have a look at the cost complexity of serializing and deserializing
    objects, and at the security issues related to the de-serialization of objects
    from untrustworthy sources.
  prefs: []
  type: TYPE_NORMAL
