- en: Part 1. Pythonic Classes via Special Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分1. 通过特殊方法创建Pythonic类
- en: '*[The _init_() Method](ch01.html "Chapter 1. The __init__() Method")*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: __init__()方法
- en: '*[Integrating Seamlessly with Python – Basic Special Methods](ch02.html "Chapter 2. Integrating
    Seamlessly with Python Basic Special Methods")*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python无缝集成 - 基本特殊方法
- en: '*[Attribute Access, Properties, and Descriptors](ch03.html "Chapter 3. Attribute
    Access, Properties, and Descriptors")*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 属性访问、属性和描述符
- en: '*[The ABCs of Consistent Design](ch04.html "Chapter 4. The ABCs of Consistent
    Design")*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一致设计的ABCs
- en: '*[Using Callables and Contexts](ch05.html "Chapter 5. Using Callables and Contexts")*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可调用对象和上下文
- en: '*[Creating Containers and Collections](ch06.html "Chapter 6. Creating Containers
    and Collections")*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 创建容器和集合
- en: '*[Creating Numbers](ch07.html "Chapter 7. Creating Numbers")*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数字
- en: '*[Decorators and Mixins – Cross-cutting Aspects](ch08.html "Chapter 8. Decorators
    and Mixins – Cross-cutting Aspects")*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器和混合 - 横切方面
- en: Pythonic Classes via Special Methods
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过特殊方法创建Pythonic类
- en: Python exposes a great deal of its internal mechanisms through its special method
    names. The idea is pervasive throughout Python. A function such as `len()` will
    exploit the `__len__()` special method of a class.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过其特殊方法名称暴露了大量的内部机制。这个想法在整个Python中都是普遍的。例如，`len()`这样的函数将利用类的`__len__()`特殊方法。
- en: What this means is that we have a tidy, universal public interface (`len(x)`)
    that works on any kind of class. Python's polymorphism is based in part on the
    way any class can implement a `__len__()` method; objects of any such class will
    respond to the `len()` function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们有一个整洁的、通用的公共接口（`len(x)`），可以在任何类型的类上使用。Python的多态性部分基于任何类都可以实现`__len__()`方法；任何这样的类的对象都将响应`len()`函数。
- en: When we define a class, we can (and should) include these special methods to
    improve the integration between our class and the rest of Python. [Part 1](pt01.html
    "Part 1. Pythonic Classes via Special Methods"), *Pythonic Classes via Special
    Methods*, will extend basic object-oriented programming techniques to create classes
    that are more *Pythonic*. Any class should be able to integrate seamlessly with
    other parts of Python. A close fit with other parts of Python will allow us to
    use many language and standard library features, and the clients of our packages
    and modules will be more confident about using them and more successful in maintaining
    and extending them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个类时，我们可以（也应该）包括这些特殊方法，以改进我们的类与Python其他部分之间的集成。[部分1](pt01.html "部分1. 通过特殊方法创建Pythonic类")，*通过特殊方法创建Pythonic类*，将扩展基本的面向对象编程技术，以创建更*Pythonic*的类。任何类都应该能够与Python的其他部分无缝集成。与Python的其他部分紧密结合将使我们能够使用许多语言和标准库功能，我们包和模块的客户端将更有信心地使用它们，并更成功地维护和扩展它们。
- en: In a way, our classes can appear as extensions of Python. We want our classes
    to be so much like native Python classes that distinctions between language, standard
    library, and our application are minimized.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，我们的类可以看作是Python的扩展。我们希望我们的类非常像本机Python类，以至于语言、标准库和我们的应用之间的区别被最小化。
- en: 'The Python language uses a large number of special method names. They fall
    into the following few discrete categories:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言使用了大量的特殊方法名称。它们可以分为以下几个离散的类别：
- en: '**Attribute Access**: These special methods implement what we see as `object.attribute`
    in an expression, `object.attribute` on the left-hand side of an assignment, and
    `object.attribute` in a `del` statement.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性访问：这些特殊方法实现了我们在表达式中看到的`object.attribute`，在赋值的左侧看到的`object.attribute`，以及在`del`语句中看到的`object.attribute`。
- en: '**Callables**: This special method implements what we see as a function that
    is applied to arguments, much like the built-in `len()` function.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可调用对象：这个特殊方法实现了我们所看到的作用于参数的函数，就像内置的`len()`函数一样。
- en: '**Collections**: These special methods implement the numerous features of collections.
    This involves methods such as `sequence[index]`, `mapping[key]`, and `some_set|another_set`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合：这些特殊方法实现了集合的许多特性。这涉及到诸如`sequence[index]`、`mapping[key]`和`some_set|another_set`等方法。
- en: '**Numbers**: These special methods provide arithmetic operators and comparison
    operators. We can use these methods to expand the domain of numbers that Python
    works with.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：这些特殊方法提供了算术运算符和比较运算符。我们可以使用这些方法来扩展Python处理的数字的领域。
- en: '**Contexts**: There are two special methods we''ll use to implement a context
    manager that works with the `with` statement.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文：有两个特殊方法，我们将使用它们来实现一个与`with`语句一起工作的上下文管理器。
- en: '**Iterators**: There are special methods that define an iterator. This isn''t
    essential since generator functions handle this feature so elegantly. However,
    we''ll take a look at how we can design our own iterators.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器：有一些特殊方法定义了迭代器。这并不是必需的，因为生成器函数如此优雅地处理了这个特性。然而，我们将看看如何设计我们自己的迭代器。
- en: A few of these special method names have been introduced in *Python 3 Object
    Oriented Programming*. We'll review these topics and introduce some additional
    special method names that fit into a kind of *basic* category.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这些特殊方法名称已经在《Python 3面向对象编程》中介绍过。我们将回顾这些主题，并介绍一些适合于一种*基本*类别的额外特殊方法名称。
- en: Even within this basic category, we've got deeper topics to discover. We'll
    start with the truly basic special methods. There are some rather advanced special
    methods that are thrown into the basic category because they don't seem to belong
    anywhere else.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个基本类别中，我们还有更深入的主题要探讨。我们将从真正基本的特殊方法开始。有一些相当高级的特殊方法被归类为基本类别，因为它们似乎不属于其他任何地方。
- en: The `__init__()` method permits a great deal of latitude in providing the initial
    values for an object. In the case of an immutable object, this is the essential
    definition of the instance, and clarity becomes very important. In the first chapter,
    we'll review the numerous design alternatives for this method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法允许在提供对象的初始值时具有很大的灵活性。对于不可变对象，这是实例的基本定义，清晰度变得非常重要。在第一章中，我们将回顾该方法的众多设计替代方案。'
- en: Chapter 1. The __init__() Method
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。`__init__()`方法
- en: The `__init__()` method is profound for two reasons. Initialization is the first
    big step in an object's life; every object must be initialized properly to work
    properly. The second reason is that the argument values for `__init__()` can take
    on many forms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法有两个重要原因。初始化是对象生命周期中的第一步；每个对象必须得到适当的初始化才能正常工作。第二个原因是`__init__()`的参数值可以采用许多形式。'
- en: Because there are so many ways to provide argument values to `__init__()`, there
    is a vast array of use cases for object creation. We take a look at several of
    them. We want to maximize clarity, so we need to define an initialization that
    properly characterizes the problem domain.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有很多种方法可以向`__init__()`提供参数值，所以有很多对象创建的用例。我们将看几种。我们希望最大限度地提高清晰度，因此需要定义一个正确描述问题域的初始化。
- en: Before we can get to the `__init__()` method, however, we need to take a look
    at the implicit class hierarchy in Python, glancing, briefly, at the class named
    `object`. This will set the stage for comparing default behavior with the different
    kinds of behavior we want from our own classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们可以进入`__init__()`方法之前，我们需要看一下Python中的隐式类层次结构，简要地看一下名为`object`的类。这将为比较默认行为与我们自己类的不同行为奠定基础。
- en: In this chapter, we take a look at different forms of initialization for simple
    objects (for example, playing cards). After this, we can take a look at more complex
    objects, such as hands that involve collections and players that involve strategies
    and states.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究简单对象（例如扑克牌）的不同初始化形式。之后，我们可以研究更复杂的对象，例如涉及集合的手和涉及策略和状态的玩家。
- en: The implicit superclass – object
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式超类 - object
- en: 'Each Python class definition has an implicit superclass: `object`. It''s a
    very simple class definition that does almost nothing. We can create instances
    of `object`, but we can''t do much with them because many of the special methods
    simply raise exceptions.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Python类定义都有一个隐式的超类：`object`。这是一个非常简单的类定义，几乎什么都不做。我们可以创建`object`的实例，但我们不能对它们做太多事情，因为许多特殊方法只是简单地引发异常。
- en: 'When we define our own class, `object` is the superclass. The following is
    an example class definition that simply extends `object` with a new name:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义自己的类时，`object`是超类。以下是一个简单扩展`object`的新名称的示例类定义：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following are some interactions with our class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与我们的类的一些交互：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that a class is an object of the class named `type` and that the
    base class for our new class is the class named `object`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个类是名为`type`的类的对象，我们新类的基类是名为`object`的类。
- en: As we look at each method, we also take a look at the default behavior inherited
    from `object`. In some cases, the superclass special method behavior will be exactly
    what we want. In other cases, we'll need to override the special method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看每种方法时，我们还会看一下从`object`继承的默认行为。在某些情况下，超类特殊方法的行为恰好是我们想要的。在其他情况下，我们需要覆盖特殊方法。
- en: The base class object __init__() method
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基类对象`__init__()`方法
- en: Fundamental to the life cycle of an object are its creation, initialization,
    and destruction. We'll defer creation and destruction to a later chapter on more
    advanced special methods and only focus on initialization for now.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的生命周期的创建、初始化和销毁是基本的。我们将把创建和销毁推迟到更高级特殊方法的后一章，现在只关注初始化。
- en: The superclass of all classes, `object`, has a default implementation of `__init__()`
    that amounts to `pass`. We aren't required to implement `__init__()`. If we don't
    implement it, then no instance variables will be created when the object is created.
    In some cases, this default behavior is acceptable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类的超类`object`具有`__init__()`的默认实现，相当于`pass`。我们不需要实现`__init__()`。如果我们不实现它，那么在创建对象时不会创建任何实例变量。在某些情况下，这种默认行为是可以接受的。
- en: 'We can always add attributes to an object that''s a subclass of the foundational
    base class, `object`. Consider the following class that requires two instance
    variables but doesn''t initialize them:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以始终向`object`的子类添加属性。考虑以下类，它需要两个实例变量，但没有初始化它们：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Rectangle` class has a method that uses two attributes to return a value.
    The attributes have not been initialized anywhere. This is legal Python. It's
    a little strange to avoid specifically setting attributes, but it's valid.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle`类有一个使用两个属性返回值的方法。这些属性在任何地方都没有被初始化。这是合法的Python。避免明确设置属性有点奇怪，但是是有效的。'
- en: 'The following is an interaction with the `Rectangle` class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与`Rectangle`类的交互：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While this is legal, it's a potential source of deep confusion, which is a good
    reason to avoid it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是合法的，但这可能是深度混淆的潜在来源，这是避免的一个很好的理由。
- en: However, this kind of design grants flexibility, so there could be times when
    we needn't set all of the attributes in the `__init__()` method. We walk a fine
    line here. An optional attribute is a kind of subclass that's not formally declared
    as a proper subclass. We're creating polymorphism in a way that could lead to
    confusing and inappropriate use of convoluted `if` statements. While uninitialized
    attributes may be useful, they could be the symptom of a bad design.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种设计方式提供了灵活性，因此可能有时我们不需要在`__init__()`方法中设置所有属性。我们在这里走了一条细线。可选属性是一种未正式声明为正确子类的子类。我们正在以一种可能导致混乱和不恰当使用复杂的`if`语句的方式创建多态性。虽然未初始化的属性可能有用，但它们可能是糟糕设计的症状。
- en: 'The *Zen of Python* poem (`import this`) offers the following advice:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python之禅*诗（`import this`）提供以下建议：'
- en: '"Explicit is better than implicit."'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “明确胜于含蓄。”
- en: An `__init__()` method should make the instance variables explicit.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法应该使实例变量明确。'
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Pretty Poor Polymorphism**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**相当差的多态性**'
- en: There's a fine line between flexibility and foolishness.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在灵活性和愚蠢之间有一条细微的界限。
- en: 'We may have stepped over the edge off *flexible* into *foolish* as soon as
    we feel the need to write:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们感到有必要编写：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It's time to reconsider the API and add a common method or attribute. Refactoring
    is better than adding `if` statements.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候重新考虑API并添加一个公共方法或属性了。重构比添加`if`语句更好。
- en: Implementing __init__() in a superclass
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在超类中实现__init__()
- en: We initialize an object by implementing the `__init__()` method. When an object
    is created, Python first creates an empty object and then calls the `__init__()`
    method for that new object. This method function generally creates the object's
    instance variables and performs any other one-time processing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现`__init__()`方法来初始化对象。当对象被创建时，Python首先创建一个空对象，然后调用该新对象的`__init__()`方法。这个方法通常创建对象的实例变量并执行任何其他一次性处理。
- en: 'The following are some example definitions of a `Card` class hierarchy. We''ll
    define a `Card` superclass and three subclasses that are variations of the basic
    theme of `Card`. We have two instance variables that have been set directly from
    argument values and two variables that have been calculated by an initialization
    method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Card`类层次结构的一些示例定义。我们将定义一个`Card`超类和三个子类，这些子类是`Card`基本主题的变体。我们有两个实例变量，它们直接从参数值设置，还有两个变量，它们是通过初始化方法计算得出的：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we factored the `__init__()` method into the superclass so
    that a common initialization in the superclass, `Card`, applies to all the three
    subclasses `NumberCard`, `AceCard`, and `FaceCard`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`__init__()`方法分解到超类中，以便超类`Card`中的通用初始化适用于所有三个子类`NumberCard`、`AceCard`和`FaceCard`。
- en: 'This shows a common polymorphic design. Each subclass provides a unique implementation
    of the `_points()` method. All the subclasses have identical signatures: they
    have the same methods and attributes. Objects of these three subclasses can be
    used interchangeably in an application.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了一个常见的多态设计。每个子类提供了`_points()`方法的独特实现。所有子类具有相同的签名：它们具有相同的方法和属性。这三个子类的对象可以在应用程序中互换使用。
- en: 'If we simply use characters for suits, we will be able to create `Card` instances
    as shown in the following code snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们简单地使用字符表示花色，我们就可以创建`Card`实例，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We enumerated the class, rank, and suit for several cards in a list. In the
    long run, we need a much smarter factory function to build `Card` instances; enumerating
    all 52 cards this way is tedious and error prone. Before we get to the factory
    functions, we take a look at a number of other issues.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在列表中为几张卡片枚举了类、等级和花色。从长远来看，我们需要一个更聪明的工厂函数来构建`Card`实例；以这种方式枚举所有52张卡片是乏味且容易出错的。在我们开始工厂函数之前，我们先看一下其他一些问题。
- en: Using __init__() to create manifest constants
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用__init__()创建显式常量
- en: We can define a class for the suits of our cards. In blackjack, the suits don't
    matter, and a simple character string could work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的卡片花色定义一个类。在21点游戏中，花色并不重要，一个简单的字符字符串就可以工作。
- en: We use suit construction as an example of creating constant objects. In many
    cases, our application will have a small domain of objects that can be defined
    by a collection of constants. A small domain of static objects may be part of
    implementing a **Strategy** or **State** design pattern.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以创建常量对象的方式作为示例来使用花色构造。在许多情况下，我们的应用程序将具有可以由一组常量定义的对象的小领域。静态对象的小领域可能是实现**策略**或**状态**设计模式的一部分。
- en: In some cases, we may have a pool of constant objects created in an initialization
    or configuration file, or we might create constant objects based on command-line
    parameters. We'll return to the details of initialization design and startup design
    in [Chapter 16](ch16.html "Chapter 16. Coping With the Command Line"), *Coping
    with the Command Line*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能会有一个在初始化或配置文件中创建的常量对象池，或者我们可能会根据命令行参数创建常量对象。我们将在[第16章](ch16.html
    "第16章。处理命令行")中详细讨论初始化设计和启动设计的细节，*处理命令行*。
- en: Python has no simple formal mechanism for defining an object as immutable. We'll
    look at techniques to assure immutability in [Chapter 3](ch03.html "Chapter 3. Attribute
    Access, Properties, and Descriptors"), *Attribute Access, Properties, and Descriptors*.
    In this example, it might make sense for the attributes of a suit to be immutable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有一个简单的正式机制来定义对象为不可变的。我们将在[第3章](ch03.html "第3章。属性访问、属性和描述符")中查看确保不可变性的技术，*属性访问、属性和描述符*。在这个例子中，使花色的属性不可变可能是有意义的。
- en: 'The following is a class that we''ll use to build four manifest constants:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将用来构建四个显式常量的类：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the domain of "constants" built around this class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是围绕这个类构建的“常量”领域：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now create `cards` as shown in the following code snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建`cards`，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For an example this small, this method isn't a huge improvement over single
    character suit codes. In more complex cases, there may be a short list of Strategy
    or State objects that can be created like this. This can make the Strategy or
    State design patterns work efficiently by reusing objects from a small, static
    pool of constants.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这么小的一个例子，这种方法并没有比单个字符的花色代码有多大的改进。在更复杂的情况下，可能会有一系列短的策略或状态对象可以像这样创建。这可以通过重用来自一个小的静态常量池的对象，使策略或状态设计模式能够高效地工作。
- en: We do have to acknowledge that in Python these objects aren't technically constant;
    they are mutable. There may be some benefit in doing the extra coding to make
    these objects truly immutable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须承认，在Python中，这些对象在技术上并不是常量；它们是可变的。做额外的编码使这些对象真正不可变可能会有一些好处。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The irrelevance of immutability**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变性的无关性**'
- en: Immutability can become an attractive nuisance. It's sometimes justified by
    the mythical "malicious programmer" who modifies the constant value in their application.
    As a design consideration, this is silly. This mythical, malicious programmer
    can't be stopped this way. There's no easy way to "idiot-proof" code in Python.
    The malicious programmer has access to the source and can tweak it just as easily
    as they can write code to modify a constant.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性可能成为一个有吸引力的麻烦。有时，这是由神秘的“恶意程序员”来证明的，他们修改了他们的应用程序中的常量值。作为设计考虑，这是愚蠢的。这个神秘的、恶意的程序员不能通过这种方式停止。在Python中，没有简单的方法来“防傻”代码。恶意的程序员可以访问源代码，并且可以像编写代码来修改常量一样轻松地调整它。
- en: It's better not to struggle too long to define the classes of immutable objects.
    In [Chapter 3](ch03.html "Chapter 3. Attribute Access, Properties, and Descriptors"),
    *Attribute Access, Properties, and Descriptors*, we'll show ways to implement
    immutability that provides suitable diagnostic information for a buggy program.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要花太多时间来定义不可变对象的类。在[第3章](ch03.html "第3章。属性访问、属性和描述符") *属性访问、属性和描述符*中，我们将展示实现不可变性的方法，为有错误的程序提供适当的诊断信息。
- en: Leveraging __init__() via a factory function
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过工厂函数利用__init__()
- en: 'We can build a complete deck of cards via a factory function. This beats enumerating
    all 52 cards. In Python, we have two common approaches to factories as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个工厂函数构建一副完整的扑克牌。这比枚举所有52张牌要好。在Python中，我们有两种常见的工厂方法，如下所示：
- en: We define a function that creates objects of the required classes.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义一个创建所需类的对象的函数。
- en: We define a class that has methods for creating objects. This is the full factory
    design pattern, as described in books on design patterns. In languages such as
    Java, a factory class hierarchy is required because the language doesn't support
    standalone functions.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义一个具有创建对象方法的类。这是完整的工厂设计模式，如设计模式书籍中所述。在诸如Java之类的语言中，需要工厂类层次结构，因为该语言不支持独立函数。
- en: In Python, a class isn't *required*. It's merely a good idea when there are
    related factories that are complex. One of the strengths of Python is that we're
    not forced to use a class hierarchy when a simple function might do just as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，一个类并不是*必需的*。当相关的工厂很复杂时，使用类层次结构只是一个好主意。Python的一个优点是，当一个简单的函数可能同样有效时，我们并不被迫使用类层次结构。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While this is a book about object-oriented programming, a function really is
    fine. It's common, idiomatic Python.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一本关于面向对象编程的书，但函数确实很好。这是常见的，符合惯例的Python。
- en: We can always rewrite a function to be a proper callable object if the need
    arises. From a callable object, we can refactor it into a class hierarchy for
    our factories. We'll look at callable objects in [Chapter 5](ch05.html "Chapter 5. Using
    Callables and Contexts"), *Using Callables and Contexts*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们总是可以重写一个函数成为一个适当的可调用对象。从可调用对象，我们可以将其重构为我们的工厂类层次结构。我们将在[第5章](ch05.html
    "第5章。使用可调用对象和上下文") *使用可调用对象和上下文*中讨论可调用对象。
- en: The advantage of class definitions in general is to achieve code reuse via inheritance.
    The function of a factory class is to wrap some target class hierarchy and the
    complexities of object construction. If we have a factory class, we can add subclasses
    to the factory class when extending the target class hierarchy. This gives us
    polymorphic factory classes; the different factory class definitions have the
    same method signatures and can be used interchangeably.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，类定义的优势是通过继承实现代码重用。工厂类的作用是包装一些目标类层次结构和对象构造的复杂性。如果有一个工厂类，我们可以在扩展目标类层次结构时将子类添加到工厂类中。这给我们多态工厂类；不同的工厂类定义具有相同的方法签名，并且可以互换使用。
- en: This class-level polymorphism can be very helpful with statically compiled languages
    such as Java or C++. The compiler can resolve the details of the class and methods
    when generating code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类级别的多态性对于静态编译语言（如Java或C++）非常有帮助。编译器在生成代码时可以解析类和方法的细节。
- en: If the alternative factory definitions don't actually reuse any code, then a
    class hierarchy won't be helpful in Python. We can simply use functions that have
    the same signatures.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果替代工厂定义实际上没有重用任何代码，那么在Python中类层次结构将不会有帮助。我们可以简单地使用具有相同签名的函数。
- en: 'The following is a factory function for our various `Card` subclasses:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们各种`Card`子类的工厂函数：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function builds a `Card` class from a numeric `rank` number and a `suit`
    object. We can now build cards more simply. We've encapsulated the construction
    issues into a single factory function, allowing an application to be built without
    knowing precisely how the class hierarchy and polymorphic design works.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从一个数字`rank`和一个`suit`对象构建一个`Card`类。现在我们可以更简单地构建卡片。我们将构造问题封装到一个单一的工厂函数中，允许应用程序构建而不需要精确知道类层次结构和多态设计的工作原理。
- en: 'The following is an example of how we can build a deck with this factory function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用这个工厂函数构建一副牌的示例：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This enumerates all the ranks and suits to create a complete deck of 52 cards.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这枚举了所有的等级和花色，以创建一副完整的52张牌。
- en: Faulty factory design and the vague else clause
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误的工厂设计和模糊的else子句
- en: Note the structure of the `if` statement in the `card()` function. We did not
    use a catch-all `else` clause to do any processing; we merely raised an exception.
    The use of a catch-all `else` clause is subject to a tiny scrap of debate.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`card()`函数中`if`语句的结构。我们没有使用一个通用的`else`子句来进行任何处理；我们只是引发了一个异常。使用通用的`else`子句是一个小小的争论点。
- en: On the one hand, it can be argued that the condition that belongs on an `else`
    clause should never be left unstated because it may hide subtle design errors.
    On the other hand, some `else` clause conditions are truly obvious.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，可以说属于`else`子句的条件不应该被省略，因为它可能隐藏了微妙的设计错误。另一方面，一些`else`子句条件确实是显而易见的。
- en: It's important to avoid the vague `else` clause.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 避免模糊的`else`子句是很重要的。
- en: 'Consider the following variant on this factory function definition:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下对这个工厂函数定义的以下变体：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is what will happen when we try to build a deck:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当我们尝试构建一副牌时会发生的情况：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Does it work? What if the `if` conditions were more complex?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效吗？如果`if`条件更复杂会怎么样？
- en: Some programmers can understand this `if` statement at a glance. Others will
    struggle to determine if all of the cases are properly exclusive.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有些程序员可以一眼看出这个`if`语句。其他人将努力确定所有情况是否都是正确排他的。
- en: For advanced Python programming, we should not leave it to the reader to deduce
    the conditions that apply to an `else` clause. Either the condition should be
    obvious to the newest of n00bz, or it should be explicit.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级Python编程，我们不应该让读者推断适用于`else`子句的条件。条件要么对最新的n00bz是显而易见的，要么应该是明确的。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**When to use catch-all else**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用catch-all else**'
- en: Rarely. Use it only when the condition is obvious. When in doubt, be explicit
    and use `else` to raise an exception.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 很少。只有在条件明显时才使用。如果有疑问，要明确使用`else`来引发异常。
- en: Avoid the vague `else` clause.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 避免模糊的`else`子句。
- en: Simplicity and consistency using elif sequences
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`elif`序列的简单和一致性
- en: 'Our factory function, `card()`, is a mixture of two very common factory design
    patterns:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工厂函数`card()`是两种非常常见的工厂设计模式的混合：
- en: An `if-elif` sequence
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`if-elif`序列
- en: A mapping
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个映射
- en: For the sake of simplicity, it's better to focus on just one of these techniques
    rather than on both.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，最好专注于这些技术中的一个，而不是两者都关注。
- en: We can always replace a mapping with `elif` conditions. (Yes, always. The reverse
    is not true though; transforming `elif` conditions to a mapping can be challenging.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以用`elif`条件替换映射。（是的，总是。反之则不然；将`elif`条件转换为映射可能具有挑战性。）
- en: 'The following is a `Card` factory without the mapping:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个没有映射的`Card`工厂：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We rewrote the `card()` factory function. The mapping was transformed into additional
    `elif` clauses. This function has the advantage that it is more consistent than
    the previous version.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写了`card()`工厂函数。映射被转换为额外的`elif`子句。这个函数的优点是它比以前的版本更一致。
- en: Simplicity using mapping and class objects
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用映射和类对象的简单性
- en: In some cases, we can use a mapping instead of a chain of `elif` conditions.
    It's possible to find conditions that are so complex that a chain of `elif` conditions
    is the only sensible way to express them. For simple cases, however, a mapping
    often works better and can be easy to read.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以使用映射来代替一系列`elif`条件。可能会发现条件非常复杂，以至于一系列`elif`条件是表达它们的唯一明智的方式。然而，对于简单的情况，映射通常效果更好，而且易于阅读。
- en: Since `class` is a first-class object, we can easily map from the `rank` parameter
    to the class that must be constructed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`class`是一个一流对象，我们可以很容易地从`rank`参数映射到必须构造的类。
- en: 'The following is a `Card` factory that uses only a mapping:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个只使用映射的`Card`工厂：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We've mapped the `rank` object to a class. Then, we applied the class to the
    `rank` and `suit` values to build the final `Card` instance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`rank`对象映射到一个类。然后，我们将该类应用于`rank`和`suit`值，以构建最终的`Card`实例。
- en: 'We can use a `defaultdict` class as well. However, it''s no simpler for a trivial
    static mapping. It looks like the following code snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`defaultdict`类。但是，对于一个微不足道的静态映射来说，它并不更简单。代码如下所示：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the *default* of a `defaultdict` class must be a function of zero
    arguments. We've used a `lambda` construct to create the necessary function wrapper
    around a constant. This function, however, has a serious deficiency. It lacks
    the translation from `1` to `A` and `13` to `K` that we had in previous versions.
    When we try to add that feature, we run into a problem.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`defaultdict`类的*default*必须是零参数的函数。我们使用了`lambda`构造来创建必要的函数包装器，围绕一个常量。然而，这个函数有一个严重的缺陷。它缺少从`1`到`A`和`13`到`K`的转换，这是我们在以前版本中有的。当我们尝试添加该功能时，我们遇到了问题。
- en: 'We need to change the mapping to provide both a `Card` subclass as well as
    the string version of the `rank` object. What can we do for this two-part mapping?
    There are four common solutions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要改变映射，以提供`Card`子类以及`rank`对象的字符串版本。对于这种两部分映射，我们可以做什么？有四种常见的解决方案：
- en: We can do two parallel mappings. We don't suggest this, but we'll show it to
    emphasize what's undesirable about it.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以做两个并行映射。我们不建议这样做，但我们将展示它以强调它的不可取之处。
- en: We can map to a two-tuple. This also has some disadvantages.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以映射到一个二元组。这也有一些缺点。
- en: We can map to a `partial()` function. The `partial()` function is a feature
    of the `functools` module.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以映射到`partial()`函数。`partial()`函数是`functools`模块的一个特性。
- en: We can also consider modifying our class definition to fit more readily with
    this kind of mapping. We'll look at this alternative in the next section on pushing
    `__init__()` into the subclass definitions.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以考虑修改我们的类定义，以更容易地适应这种映射。我们将在下一节关于将`__init__()`推入子类定义中看看这种替代方案。
- en: We'll look at each of these with a concrete example.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一个具体的例子来看看每一个。
- en: Two parallel mappings
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 两个并行映射
- en: 'The following is the essence of the two parallel mappings solution:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个并行映射解决方案的本质：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is not desirable. It involves a repetition of the sequence of the mapping
    keys `1`, `11`, `12`, and `13`. Repetition is bad because parallel structures
    never seem to stay that way after the software has been updated.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不可取的。它涉及到映射键`1`、`11`、`12`和`13`序列的重复。重复是不好的，因为并行结构在软件更新后似乎永远不会保持不变。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Don''t use parallel structures**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要使用并行结构**'
- en: Two parallel structures should be replaced with tuples or some kind of proper
    collection.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 两个并行结构应该被替换为元组或某种适当的集合。
- en: Mapping to a tuple of values
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 映射到一个值的元组
- en: 'The following is the essence of how mapping is done to a two-tuple:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是映射到二元组的本质：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is reasonably pleasant. It's not much code to sort out the special cases
    of playing cards. We will see how it could be modified or expanded if we need
    to alter the `Card` class hierarchy to add additional subclasses of `Card`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当愉快的。要解决纸牌的特殊情况并不需要太多的代码。我们将看到如果需要修改或扩展`Card`类层次结构以添加`Card`的其他子类，它可能会如何被修改或扩展。
- en: It does feel odd to map a `rank` value to a `class` object and just one of the
    two arguments to that class initializer. It seems more sensible to map the rank
    to a simple class or function object without the clutter of providing some (but
    not all) of the arguments.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将`rank`值映射到`class`对象，并将其中一个参数映射到该类初始化程序似乎有些奇怪。将rank映射到一个简单的类或函数对象，而不提供一些（但不是全部）参数，似乎更合理。
- en: The partial function solution
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部分函数解决方案
- en: Rather than map to a two-tuple of function and one of the arguments, we can
    create a `partial()` function. This is a function that already has some (but not
    all) of its arguments provided. We'll use the `partial()` function from the `functools`
    library to create a partial of a class with the `rank` argument.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个`partial()`函数，而不是映射到函数和一个参数的二元组。这是一个已经提供了一些（但不是全部）参数的函数。我们将使用`functools`库中的`partial()`函数来创建一个带有`rank`参数的部分。
- en: 'The following is a mapping from `rank` to a `partial()` function that can be
    used for object construction:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`rank`到可以用于对象构造的`partial()`函数的映射：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The mapping associates a `rank` object with a `partial()` function that is assigned
    to `part_class`. This `partial()` function can then be applied to the `suit` object
    to create the final object. The use of `partial()` functions is a common technique
    for functional programming. It works in this specific situation where we have
    a function instead of an object method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该映射将`rank`对象与分配给`part_class`的`partial()`函数相关联。然后可以将此`partial()`函数应用于`suit`对象以创建最终对象。使用`partial()`函数是函数式编程的一种常见技术。它在这种特定情况下起作用，其中我们有一个函数而不是对象方法。
- en: In general, however, `partial()` functions aren't helpful for most object-oriented
    programming. Rather than create `partial()` functions, we can simply update the
    methods of a class to accept the arguments in different combinations. A `partial()`
    function is similar to creating a fluent interface for object construction.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`partial()`函数对大多数面向对象编程并不是很有帮助。与其创建`partial()`函数，我们可以简单地更新类的方法，以接受不同组合的参数。`partial()`函数类似于为对象构造创建流畅的接口。
- en: Fluent APIs for factories
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工厂的流畅API
- en: In some cases, we design a class where there's a defined order for method usage.
    Evaluating methods sequentially is very much like creating a `partial()` function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们设计一个类，其中方法的使用顺序是有定义的。顺序评估方法非常类似于创建`partial()`函数。
- en: We might have `x.a().b()` in an object notation. We can think of it as ![Fluent
    APIs for factories](graphics/0971OS_01_01.jpg). The `x.a()` function is a kind
    of `partial()` function that's waiting for `b()`. We can think of this as if it
    were ![Fluent APIs for factories](graphics/0971OS_01_02.jpg).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象表示法中，我们可能会有`x.a().b()`。我们可以将其视为![工厂的流畅API](graphics/0971OS_01_01.jpg)。`x.a()`函数是一种等待`b()`的`partial()`函数。我们可以将其视为![工厂的流畅API](graphics/0971OS_01_02.jpg)。
- en: The idea here is that Python offers us two alternatives for managing a state.
    We can either update an object or create a `partial()` function that is (in a
    way) stateful. Because of this equivalence, we can rewrite a `partial()` function
    into a fluent factory object. We make the setting of the `rank` object a fluent
    method that returns `self`. Setting the `suit` object will actually create the
    `Card` instance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，Python为我们提供了两种管理状态的替代方案。我们可以更新对象，也可以创建一个（在某种程度上）有状态的`partial()`函数。由于这种等价性，我们可以将`partial()`函数重写为流畅的工厂对象。我们使`rank`对象的设置成为返回`self`的流畅方法。设置`suit`对象实际上将创建`Card`实例。
- en: 'The following is a fluent `Card` factory class with two method functions that
    must be used in a specific order:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个流畅的`Card`工厂类，其中有两个必须按特定顺序使用的方法函数：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `rank()` method updates the state of the constructor, and the `suit()` method
    actually creates the final `Card` object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`rank()`方法更新构造函数的状态，而`suit()`方法实际上创建最终的`Card`对象。'
- en: 'This factory class can be used as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工厂类可以如下使用：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we create a factory instance, then we use that instance to create `Card`
    instances. This doesn't materially change how `__init__()` itself works in the
    `Card` class hierarchy. It does, however, change the way that our client application
    creates objects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个工厂实例，然后使用该实例创建`Card`实例。这并不会实质性地改变`Card`类层次结构中`__init__()`本身的工作方式。但是，它改变了我们的客户端应用程序创建对象的方式。
- en: Implementing __init__() in each subclass
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在每个子类中实现`__init__()`
- en: As we look at the factory functions for creating `Card` objects, we see some
    alternative designs for the `Card` class. We might want to refactor the conversion
    of the rank number so that it is the responsibility of the `Card` class itself.
    This pushes the initialization down into each subclass.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看用于创建`Card`对象的工厂函数时，我们看到了`Card`类的一些替代设计。我们可能希望重构排名数字的转换，使其成为`Card`类本身的责任。这将初始化推入到每个子类中。
- en: This often requires some common initialization of a superclass as well as subclass-specific
    initialization. We need to follow the **Don't Repeat Yourself** (**DRY**) principle
    to keep the code from getting cloned into each of the subclasses.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常需要对超类进行一些常见的初始化，以及子类特定的初始化。我们需要遵循**不要重复自己**（**DRY**）原则，以防止代码被克隆到每个子类中。
- en: 'The following is an example where the initialization is the responsibility
    of each subclass:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中初始化是每个子类的责任：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is still clearly polymorphic. The lack of a truly common initialization,
    however, leads to some unpleasant redundancy. What's unpleasant here is the repeated
    initialization of `suit`. This must be *pulled up* into the superclass. We can
    have each `__init__()` subclass make an explicit reference to the superclass.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然显然是多态的。然而，缺乏一个真正共同的初始化导致了一些令人不快的冗余。这里令人不快的是`suit`的重复初始化。这必须被*提升*到超类中。我们可以让每个`__init__()`子类对超类进行显式引用。
- en: 'This version of the `Card` class has an initializer at the superclass level
    that is used by each subclass, as shown in the following code snippet:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Card`类的版本在超类级别有一个初始化器，每个子类都使用它，如下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ve provided `__init__()` at both the subclass and superclass level. This
    has the small advantage that it simplifies our factory function, as shown in the
    following code snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在子类和超类级别都提供了`__init__()`。这有一个小优点，就是它简化了我们的工厂函数，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Simplifying a factory function should not be our focus. We can see from this
    variation that we've created rather complex `__init__()` methods for a relatively
    minor improvement in a factory function. This is a common trade-off.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 简化工厂函数不应该是我们的重点。从这个变化中我们可以看到，我们为了在工厂函数中稍微改进而创建了相当复杂的`__init__()`方法。这是一个常见的权衡。
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Factory functions encapsulate complexity**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂函数封装复杂性**'
- en: There's a trade-off that occurs between sophisticated `__init__()` methods and
    factory functions. It's often better to stick with more direct but less programmer-friendly
    `__init__()` methods and push the complexity into factory functions. A factory
    function works well if you wish to wrap and encapsulate the construction complexities.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的`__init__()`方法和工厂函数之间存在一个权衡。通常更好的做法是坚持使用更直接但不太友好的`__init__()`方法，并将复杂性推入工厂函数。如果你希望包装和封装构造复杂性，工厂函数会起作用。
- en: Simple composite objects
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的复合对象
- en: 'A composite object can also be called a **container**. We''ll look at a simple
    composite object: a deck of individual cards. This is a basic collection. Indeed,
    it''s so basic that we can, without too much struggle, use a simple `list` as
    a deck.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复合对象也可以被称为**容器**。我们将看一个简单的复合对象：一叠单独的卡片。这是一个基本的集合。事实上，它是如此基本，以至于我们可以不费吹灰之力地使用一个简单的`list`作为一叠卡片。
- en: 'Before designing a new class, we need to ask this question: is using a simple
    `list` appropriate?'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计一个新的类之前，我们需要问这个问题：使用一个简单的`list`是否合适？
- en: We can use `random.shuffle()` to shuffle the deck and `deck.pop()` to deal cards
    into a player's `Hand`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`random.shuffle()`来洗牌，使用`deck.pop()`来发牌到玩家的`Hand`中。
- en: 'Some programmers rush to define new classes as if using a built-in class violates
    some object-oriented design principle. Avoiding a new class leaves us with something
    as shown in the following code snippet:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有些程序员急于定义新的类，好像使用内置类违反了某些面向对象设计原则。避免新类会使我们得到以下代码片段中所示的东西：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If it's that simple, why write a new class?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这么简单，为什么要写一个新的类呢？
- en: The answer isn't perfectly clear. One advantage is that a class offer a simplified,
    implementation-free interface to the object. As we noted previously, when discussing
    factories, a class isn't a requirement in Python.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 答案并不完全清晰。一个优点是，一个类提供了一个简化的、无实现的接口给对象。正如我们之前提到的，在讨论工厂时，一个类在Python中并不是必需的。
- en: In the preceding code, the deck only has two simple use cases and a class definition
    doesn't seem to simplify things very much. It does have the advantage of concealing
    the implementation's details. But the details are so trivial that exposing them
    seems to have little cost. We're focused primarily on the `__init__()` method
    in this chapter, so we'll look at some designs to create and initialize a collection.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，这个牌组只有两个简单的用例，而且一个类定义似乎并没有简化事情太多。它的优点在于隐藏了实现的细节。但是这些细节如此微不足道，以至于暴露它们似乎没有太大的成本。在本章中，我们主要关注`__init__()`方法，所以我们将看一些设计来创建和初始化一个集合。
- en: 'To design a collection of objects, we have the following three general design
    strategies:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计一个对象的集合，我们有以下三种一般的设计策略：
- en: '**Wrap**: This design pattern is an existing collection definition. This might
    be an example of the **Facade** design pattern.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包装**：这个设计模式是一个现有的集合定义。这可能是**外观**设计模式的一个例子。'
- en: '**Extend**: This design pattern is an existing collection class. This is ordinary
    subclass definition.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**：这个设计模式是一个现有的集合类。这是普通的子类定义。'
- en: '**Invent**: This is designed from scratch. We''ll look at this in [Chapter
    6](ch06.html "Chapter 6. Creating Containers and Collections"), *Creating Containers
    and Collections*.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发明**：这是从头开始设计的。我们将在[第6章](ch06.html "第6章。创建容器和集合")中看到这个，*创建容器和集合*。'
- en: These three concepts are central to object-oriented design. We must always make
    this choice when designing a class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个概念是面向对象设计的核心。在设计一个类时，我们必须始终做出这个选择。
- en: Wrapping a collection class
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装一个集合类
- en: 'The following is a wrapper design that contains an internal collection:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含内部集合的包装设计：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We've defined `Deck` so that the internal collection is a `list` object. The
    `pop()` method of `Deck` simply delegates to the wrapped `list` object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`Deck`，使得内部集合是一个`list`对象。`Deck`的`pop()`方法只是委托给了包装的`list`对象。
- en: 'We can then create a `Hand` instance with the following kind of code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以用以下代码创建一个`Hand`实例：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Generally, a Facade design pattern or wrapper class contains methods that are
    simply delegated to the underlying implementation class. This delegation can become
    wordy. For a sophisticated collection, we may wind up delegating a large number
    of methods to the wrapped object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，外观设计模式或包装类包含了简单地委托给底层实现类的方法。这种委托可能会变得啰嗦。对于一个复杂的集合，我们可能最终会委托大量的方法给包装对象。
- en: Extending a collection class
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展一个集合类
- en: An alternative to wrapping is to extend a built-in class. By doing this, we
    have the advantage of not having to reimplement the `pop()` method; we can simply
    inherit it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 包装的另一种选择是扩展内置类。通过这样做，我们不必重新实现`pop()`方法，我们可以直接继承它。
- en: The `pop()` method has the advantage that it creates a class without writing
    too much code. In this example, extending the `list` class has the disadvantage
    that this provides many more functions than we truly need.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()`方法的优点在于它可以创建一个类，而不需要编写太多的代码。在这个例子中，扩展`list`类的缺点在于它提供了比我们实际需要的更多的函数。'
- en: 'The following is a definition of `Deck` that extends the built-in `list`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是扩展内置`list`的`Deck`定义：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In some cases, our methods will have to explicitly use the superclass methods
    in order to have proper class behavior. We'll see other examples of this in the
    following sections.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们的方法将不得不明确地使用超类方法，以便具有适当的类行为。我们将在接下来的章节中看到其他例子。
- en: We leverage the superclass's `__init__()` method to populate our `list` object
    with an initial single deck of cards. Then we shuffle the cards. The `pop()` method
    is simply inherited from `list` and works perfectly. Other methods inherited from
    the `list` also work.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用超类的`__init__()`方法来用一副初始的牌组填充我们的`list`对象。然后我们洗牌。`pop()`方法只是从`list`继承而来，完美地工作。其他从`list`继承的方法也可以工作。
- en: More requirements and another design
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多要求和另一个设计
- en: In a casino, the cards are often dealt from a shoe that has half a dozen decks
    of cards all mingled together. This consideration makes it necessary for us to
    build our own version of `Deck` and not simply use an unadorned `list` object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在赌场里，牌通常是从一个混合了半打牌组的鞋子中发出的。这个考虑使我们必须建立我们自己的`Deck`版本，而不仅仅使用一个朴素的`list`对象。
- en: Additionally, a casino shoe is not dealt fully. Instead, a marker card is inserted.
    Because of the marker, some cards are effectively set aside and not used for play.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，赌场鞋子并不是完全发牌。相反，会插入一个标记牌。由于标记牌，一些牌实际上被搁置不用于游戏。
- en: 'The following is `Deck` definition that contains multiple sets of 52-card decks:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包含多副52张牌组的`Deck`定义：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we used the `__init__()` superclass to build an empty collection. Then,
    we used `self.extend()` to append multiple 52-card decks to the shoe. We could
    also use `super().extend()` since we did not provide an overriding implementation
    in this class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`__init__()`超类来构建一个空集合。然后，我们使用`self.extend()`来将多副52张牌的牌组附加到鞋子上。我们也可以使用`super().extend()`，因为在这个类中我们没有提供覆盖的实现。
- en: 'We could also carry out the entire task via `super().__init__()` using a more
    deeply nested generator expression, as shown in the following code snippet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过`super().__init__()`使用更深层嵌套的生成器表达式来完成整个任务，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This class provides us with a collection of `Card` instances that we can use
    to emulate casino blackjack as dealt from a shoe.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类为我们提供了一系列`Card`实例，我们可以用它来模拟从鞋子中发牌的赌场21点。
- en: There's a peculiar ritual in a casino where they reveal the burned card. If
    we're going to design a card-counting player strategy, we might want to emulate
    this nuance too.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在赌场里有一个奇怪的仪式，他们会揭示被烧毁的牌。如果我们要设计一个计牌玩家策略，我们可能也想模拟这种细微差别。
- en: Complex composite objects
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂的复合对象
- en: 'The following is an example of a blackjack `Hand` description that might be
    suitable for emulating play strategies:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个适合模拟玩法策略的21点`Hand`描述的例子：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, we have an instance variable `self.dealer_card` based on a
    parameter of the `__init__()` method. The `self.cards` instance variable, however,
    is not based on any parameter. This kind of initialization creates an empty collection.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个基于`__init__()`方法的参数的实例变量`self.dealer_card`。然而，`self.cards`实例变量并不基于任何参数。这种初始化方式创建了一个空集合。
- en: 'To create an instance of `Hand`, we can use the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`Hand`的一个实例，我们可以使用以下代码：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This has the disadvantage that a long-winded sequence of statements is used
    to build an instance of a `Hand` object. It can become difficult to serialize
    the `Hand` object and rebuild it with an initialization such as this one. Even
    if we were to create an explicit `append()` method in this class, it would still
    take multiple steps to initialize the collection.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种初始化方式的缺点是使用了一长串陈述来构建`Hand`对象的实例。使用这种初始化方式，将`Hand`对象序列化并重新构建会变得困难。即使我们在这个类中创建了一个显式的`append()`方法，初始化集合仍然需要多个步骤。
- en: We could try to create a fluent interface, but that doesn't really simplify
    things; it's merely a change in the syntax of the way that a `Hand` object is
    built. A fluent interface still leads to multiple method evaluations. When we
    take a look at the serialization of objects in [Part 2](pt02.html "Part 2. Persistence
    and Serialization"), *Persistence and Serialization* we'd like an interface that's
    a single class-level function, ideally the class constructor. We'll look at this
    in depth in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML,
    Pickle, CSV, and XML"), *Serializing and Saving - JSON, YAML, Pickle, CSV, and
    XML*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试创建一个流畅的接口，但这并不能真正简化事情；它只是改变了构建`Hand`对象的语法方式。流畅的接口仍然会导致多个方法的评估。当我们在[第2部分](pt02.html
    "第2部分。持久性和序列化")中查看对象的序列化时，*持久性和序列化*我们希望一个单一的类级函数接口，理想情况下是类构造函数。我们将在[第9章](ch09.html
    "第9章。序列化和保存 - JSON、YAML、Pickle、CSV和XML")中深入研究，*序列化和保存 - JSON、YAML、Pickle、CSV和XML*。
- en: Note also that the hard total and soft total method functions shown here don't
    fully follow the rules of blackjack. We return to this issue in [Chapter 2](ch02.html
    "Chapter 2. Integrating Seamlessly with Python Basic Special Methods"), *Integrating
    Seamlessly with Python – Basic Special Methods*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这里显示的硬总和和软总和方法函数并不完全遵循21点的规则。我们将在[第2章](ch02.html "第2章。与Python基本特殊方法无缝集成")中回到这个问题，*与Python无缝集成
    - 基本特殊方法*。
- en: Complete composite object initialization
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整的复合对象初始化
- en: Ideally, the `__init__()` initializer method will create a complete instance
    of an object. This is a bit more complex when creating a complete instance of
    a container that contains an internal collection of other objects. It'll be helpful
    if we can build this composite in a single step.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: It's common to have both a method to incrementally accrete items as well as
    the initializer special method that can load all of the items in one step.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might have a class such as the following code snippet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This initialization sets all of the instance variables in a single step. The
    other methods are simply copies of the previous class definition. We can build
    a `Hand2` object in two ways. This first example loads one card at a time into
    a `Hand2` object:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This second example uses the `*cards` parameter to load a sequence of `Cards`
    class in a single step:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For unit testing, it's often helpful to build a composite object in a single
    statement in this way. More importantly, some of the serialization techniques
    from the next part will benefit from a way of building a composite object in a
    single, simple evaluation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Stateless objects without __init__()
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is an example of a degenerate class that doesn''t need an `__init__()`
    method. It''s a common design pattern for **Strategy** objects. A Strategy object
    is plugged into a Master object to implement an algorithm or decision. It may
    rely on data in the master object; the Strategy object may not have any data of
    its own. We often design strategy classes to follow the **Flyweight** design pattern:
    we avoid internal storage in the `Strategy` object. All values are provided to
    `Strategy` as method argument values. The `Strategy` object itself can be stateless.
    It''s more a collection of method functions than anything else.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''re providing the game play decisions for a `Player` instance.
    The following is an example of a (dumb) strategy to pick cards and decline the
    other bets:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Each method requires the current `Hand` as an argument value. The decisions
    are based on the available information; that is, on the dealer's cards and the
    player's cards.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build a single instance of this strategy for use by various `Player`
    instances as shown in the following code snippet:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can imagine creating a family of related strategy classes, each one using
    different rules for the various decisions a player is offered in blackjack.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Some additional class definitions
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As noted previously, a player has two strategies: one for betting and one for
    playing their hand. Each `Player` instance has a sequence of interactions with
    a larger simulation engine. We''ll call the larger engine the `Table` class.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Table` class requires the following sequence of events by the `Player`
    instances:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The player must place an initial bet based on the betting strategy.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player will then receive a hand.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the hand is splittable, the player must decide to split or not based on the
    play strategy. This can create additional `Hand` instances. In some casinos, the
    additional hands are also splittable.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each `Hand` instance, the player must decide to hit, double, or stand based
    on the play strategy.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player will then receive payouts, and they must update their betting strategy
    based on their wins and losses.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this, we can see that the `Table` class has a number of API methods to
    receive a bet, create a `Hand` object, offer a split, resolve each hand, and pay
    off the bets. This is a large object that tracks the state of play with a collection
    of `Players`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the beginning of a `Table` class that handles the bets and
    cards:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `Table` class is used by the `Player` class to accept a bet, create a `Hand`
    object, and determine if theinsurance bet is in play for this hand. Additional
    methods can be used by the `Player` class to get cards and determine the payout.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The exception handling shown in `get_hand()` is not a precise model of casino
    play. This may lead to minor statistical inaccuracies. A more accurate simulation
    requires developing a deck that reshuffles itself when empty instead of raising
    an exception.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In order to interact properly and simulate realistic play, the `Player` class
    needs a betting strategy. The betting strategy is a stateful object that determines
    the level of the initial bet. The various betting strategies generally change
    the bet based on whether the game was a win or a loss.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we'd like to have a family of betting strategy objects. Python has
    a module with decorators that allows us to create an abstract superclass. An informal
    approach to creating Strategy objects is to raise an exception for methods that
    *must* be implemented by a subclass.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve defined an abstract superclass as well as a specific subclass as follows
    to define a flat betting strategy:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The superclass defines the methods with handy default values. The basic `bet()`
    method in the abstract superclass raises an exception. The subclass must override
    the `bet()` method. The other methods can be left to provide the default values.
    Given the game strategy in the previous section plus the betting strategy here,
    we can look at more complex `__init__()` techniques surrounding the `Player` class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make use of the `abc` module to formalize an abstract superclass definition.
    It would look like the following code snippet:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This has the advantage that it makes the creation of an instance of `BettingStrategy2,`
    or any subclass that failed to implement `bet(),` impossible. If we try to create
    an instance of this class with an unimplemented abstract method, it will raise
    an exception instead of creating an object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: And yes, the abstract method has an implementation. It can be accessed via `super().bet()`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Multi-strategy __init__()
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may have objects that are created from a variety of sources. For example,
    we might need to clone an object as part of creating a memento, or freeze an object
    so that it can be used as the key of a dictionary or placed into a set; this is
    the idea behind the `set` and `frozenset` built-in classes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: There are several overall design patterns that have multiple ways to build an
    object. One design pattern is complex `__init__()` that is called multi-strategy
    initialization. Also, there are multiple class-level (static) constructor methods.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: These are incompatible approaches. They have radically different interfaces.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Avoid clone methods**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: A clone method that unnecessarily duplicates an object is rarely needed in Python.
    Using cloning may be an indication of failure to understand the object-oriented
    design principles available in Python.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: A clone method encapsulates the knowledge of object creation in the wrong place.
    The source object that's being cloned cannot know about the structure of the target
    object that was built from the clone. However, the reverse (targets having knowledge
    about a source) is acceptable if the source provides a reasonably well-encapsulated
    interface.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: The examples we have shown here are effectively cloning because they're so simple.
    We'll expand on them in the next chapter. However, to show ways in which these
    fundamental techniques are used to do more than trivial cloning, we'll look at
    turning a mutable `Hand` object into a frozen, immutable `Hand` object.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a `Hand` object that can be built in either
    of the two ways:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the first case, a `Hand3` instance has been built from an existing `Hand3`
    object. In the second case, a `Hand3` object has been built from individual `Card`
    instances.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'This parallels the way a `frozenset` object can be built from individual items
    or an existing `set` object. We look more at creating immutable objects in the
    next chapter. Creating a new `Hand` from an existing `Hand` allows us to create
    a memento of a `Hand` object using a construct like the following code snippet:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We saved the `Hand` object in the `memento` variable. This can be used to compare
    the final with the original hand that was dealt, or we can *freeze* it for use
    in a set or mapping too.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: More complex initialization alternatives
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to write a multi-strategy initialization, we're often forced to give
    up on specific named parameters. This design has the advantage that it is flexible,
    but the disadvantage that it has opaque, meaningless parameter names. It requires
    a great deal of documentation explaining the variant use cases.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'We can expand our initialization to also split a `Hand` object. The result
    of splitting a `Hand` object is simply another constructor. The following code
    snippet shows how the splitting of a `Hand` object might look:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This design involves getting extra cards to build proper, split hands. When
    we create one `Hand4` object from another `Hand4` object, we provide a split keyword
    argument that uses the index of the `Card` class from the original `Hand4` object.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we''d use this to split a hand:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We created an initial `h` instance of `Hand4` and split it into two other `Hand4`
    instances, `s1` and `s2`, and dealt an additional `Card` class into each. The
    rules of blackjack only allow this when the initial hand has two cards of equal
    rank.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: While this `__init__()` method is rather complex, it has the advantage that
    it can parallel the way in which `fronzenset` is created from an existing set.
    The disadvantage is that it needs a large docstring to explain all these variations.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Initializing static methods
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we have multiple ways to create an object, it's sometimes more clear to
    use static methods to create and return instances rather than complex `__init__()`
    methods.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to use class methods as alternate initializers, but there's
    little tangible advantage to receiving the class as an argument to the method.
    In the case of freezing or splitting a `Hand` object, we might want to create
    two new static methods to freeze or split a `Hand` object. Using static methods
    as surrogate constructors is a tiny syntax change in construction, but it has
    huge advantages when organizing the code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a version of `Hand` with static methods that can be used to
    build new instances of `Hand` from an existing `Hand` instance:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: One method freezes or creates a memento version. The other method splits a `Hand5`
    instance to create two new child instances of `Hand5`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: This is considerably more readable and preserves the use of the parameter names
    to explain the interface.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can split a `Hand5` instance with this
    version of the class:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We created an initial `h` instance of `Hand5`, split it into two other hands,
    `s1` and `s2`, and dealt an additional `Card` class into each. The `split()` static
    method is much simpler than the equivalent functionality implemented via `__init__()`.
    However, it doesn't follow the pattern of creating a `fronzenset` object from
    an existing `set` object.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Yet more __init__() techniques
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll take a look at a few other, more advanced `__init__()` techniques. These
    aren't quite so universally useful as the techniques in the previous sections.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a definition for the `Player` class that uses two strategy
    objects and a `table` object. This shows an unpleasant-looking `__init__()` method:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `__init__()` method for `Player` seems to do little more than bookkeeping.
    We're simply transferring named parameters to same-named instance variables. If
    we have numerous parameters, simply transferring the parameters into the internal
    variables will amount to a lot of redundant-looking code.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this `Player` class (and related objects) as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can provide a very short and very flexible initialization by simply transferring
    keyword argument values directly into the internal instance variables.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a way to build a `Player` class using keyword argument values:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This sacrifices a great deal of readability for succinctness. It crosses over
    into a realm of potential obscurity.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `__init__()` method is reduced to one line, it removes a certain
    level of "wordiness" from the method. This wordiness, however, is transferred
    to each individual object constructor expression. We have to add the keywords
    to the object initialization expression since we''re no longer using positional
    parameters, as shown in the following code snippet:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Why do this?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: It does have a *potential* advantage. A class defined like this is quite open
    to extension. We can, with only a few specific worries, supply additional keyword
    parameters to a constructor.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the expected use case:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following is a bonus use case:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We've added a `log_name` attribute without touching the class definition. This
    can be used, perhaps, as part of a larger statistical analysis. The `Player2.log_name`
    attribute can be used to annotate logs or other collected data.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: We are limited in what we can add; we can only add parameters that fail to conflict
    with the names already in use within the class. Some knowledge of the class implementation
    is required to create a subclass that doesn't abuse the set of keywords already
    in use. Since the `**kw` parameter provides little information, we need to read
    carefully. In most cases, we'd rather trust the class to work than review the
    implementation details.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: This kind of keyword-based initialization can be done in a superclass definition
    to make it slightly simpler for the superclass to implement subclasses. We can
    avoiding writing an additional `__init__()` method in each subclass when the unique
    feature of the subclass involves simple new instance variables.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of this is that we have obscure instance variables that aren't
    formally documented via a subclass definition. If it's only one small variable,
    an entire subclass might be too much programming overhead to add a single variable
    to a class. However, one small variable often leads to a second and a third. Before
    long, we'll realize that a subclass would have been smarter than an extremely
    flexible superclass.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'We can (and should) hybridize this with a mixed positional and keyword implementation
    as shown in the following code snippet:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is more sensible than a completely open definition. We've made the required
    parameters positional parameters. We've left any nonrequired parameters as keywords.
    This clarifies the use of any extra keyword arguments given to the `__init__()`
    method.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: This kind of flexible, keyword-based initialization depends on whether we have
    relatively transparent class definitions. This openness to change requires some
    care to avoid debugging name clashes because the keyword parameter names are open-ended.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Initialization with type validation
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type validation is rarely a sensible requirement. In a way, this might be a
    failure to fully understand Python. The notional objective is to validate that
    all of the arguments are of a *proper* type. The issue with trying to do this
    is that the definition of *proper* is often far too narrow to be truly useful.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: This is different from validating that objects meet other criteria. Numeric
    range checking, for example, may be essential to prevent infinite loops.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'What can create problems is trying to do something like the following in an
    `__init__()` method:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `isinstance()` method checks circumvent Python's normal **duck typing**.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: We write a casino game simulation in order to experiment with endless variations
    on `GameStrategy`. These are so simple (merely four methods) that there's little
    real benefit from inheritance from the superclass. We could define the classes
    independently, lacking an overall superclass.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The initialization error-checking shown in this example would force us to create
    subclasses merely to pass the error check. No usable code is inherited from the
    abstract superclass.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the biggest duck typing issues surrounds numeric types. Different numeric
    types will work in different contexts. Attempts to validate the types of arguments
    may prevent a perfectly sensible numeric type from working properly. When attempting
    validation, we have the following two choices in Python:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: We write validation so that a relatively narrow collection of types is permitted,
    and someday the code will break because a new type that would have worked sensibly
    is prohibited
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We eschew validation so that a broad collection of types is permitted, and someday
    the code will break because a type that would not work sensibly was used
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that both are essentially the same. The code could perhaps break someday.
    It either breaks because a type was prevented from being used even though it's
    sensible or a type that's not really sensible was used.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Just allow it**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Generally, it's considered better Python style to simply permit any type of
    data to be used.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: We'll return to this in [Chapter 4](ch04.html "Chapter 4. The ABCs of Consistent
    Design"), *The ABCs of Consistent Design*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is this: why restrict potential future use cases?'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: And the usual answer is that there's no good reason to restrict potential future
    use cases.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Rather than prevent a sensible, but possibly unforeseen, use case, we can provide
    documentation, testing, and debug logging to help other programmers understand
    any restrictions on the types that can be processed. We have to provide the documentation,
    logging, and test cases anyway, so there's minimal additional work involved.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example docstring that provides the expectations of the
    class:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The programmer using this class has been warned about what the type restrictions
    are. The use of other types is permitted. If the type isn't compatible with the
    expected type, then things will break. Ideally, we'll use too like `unittest`
    or `doctest` to uncover the breakage.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Initialization, encapsulation, and privacy
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The general Python policy regarding privacy can be summed up as follows: *we''re
    all adults here*.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design makes an explicit distinction between interface and implementation.
    This is a consequence of the idea of encapsulation. A class encapsulates a data
    structure, an algorithm, an external interface, or something meaningful. The idea
    is to have the capsule separate the class-based interface from the implementation
    details.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: However, no programming language reflects every design nuance. Python, typically,
    doesn't implement all design considerations as explicit code.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: One aspect of a class design that is not fully carried into code is the distinction
    between the *private* (implementation) and *public* (interface) methods or attributes
    of an object. The notion of privacy in languages that support it (C++ or Java
    are two examples) is already quite complex. These languages include settings such
    as private, protected, and public as well as "not specified", which is a kind
    of semiprivate. The private keyword is often used incorrectly, making subclass
    definition needlessly difficult.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s notion of privacy is simple, as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: It's all *essentially* public. The source code is available. We're all adults.
    Nothing can be truly hidden.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conventionally, we'll treat some names in a way that's less public. They're
    generally implementation details that are subject to change without notice, but
    there's no formal notion of private.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names that begin with `_` are honored as less public by some parts of Python.
    The `help()` function generally ignores these methods. Tools such as Sphinx can
    conceal these names from documentation.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Python's internal names begin (and end) with `__`. This is how Python internals
    are kept from colliding with application features above the internals. The collection
    of these internal names is fully defined by the language reference. Further, there's
    no benefit to trying to use `__` to attempt to create a "super private" attribute
    or method in our code. All that happens is that we create a potential future problem
    if a release of Python ever starts using a name we chose for internal purposes.
    Also, we're likely to run afoul of the internal name mangling that is applied
    to these names.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for the visibility of Python names are as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Most names are public.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names that start with `_` are somewhat less public. Use them for implementation
    details that are truly subject to change.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names that begin and end with `__` are internal to Python. We never make these
    up; we use the names defined by the language reference.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, the Python approach is to register the intent of a method (or attribute)
    using documentation and a well-chosen name. Often, the interface methods will
    have elaborate documentation, possibly including `doctest` examples, while the
    implementation methods will have more abbreviated documentation and may not have
    `doctest` examples.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: For programmers new to Python, it's sometimes surprising that privacy is not
    more widely used. For programmers experienced in Python, it's surprising how many
    brain calories get burned sorting out private and public declarations that aren't
    really very helpful because the intent is obvious from the method names and the
    documentation.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have reviewed the various design alternatives of the `__init__()`
    method. In the next chapter, we will take a look at the special methods, along
    with a few advanced ones as well.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2. Integrating Seamlessly with Python Basic Special Methods
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of special methods that permit close integration between
    our classes and Python. *Standard Library Reference* calls them **basic**. A better
    term might be *foundational* or *essential*. These special methods form a foundation
    for building classes that seamlessly integrate with other Python features.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: For example, we need string representations of a given object's value. The base
    class, `object`, has a default implementation of `__repr__()` and `__str__()`
    that provides string representations of an object. Sadly, these default representations
    are remarkably uninformative. We'll almost always want to override one or both
    of these default definitions. We'll also look at `__format__()`, which is a bit
    more sophisticated but serves the same purpose.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also look at other conversions, specifically `__hash__()`, `__bool__()`,
    and `__bytes__()`. These methods will convert an object into a number, a true/false
    value, or a string of bytes. When we implement `__bool__()`, for example, we can
    use our object in an `if` statement as follows: `if someobject:`.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can look at the special methods that implement the comparison operators
    `__lt__()`, `__le__()`, `__eq__()`, `__ne__()`, `__gt__()`, and `__ge__()`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: These basic special methods are almost always needed in class definitions.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at `__new__()` and `__del__()` last because the use cases for these
    methods are rather complex. We don't need these as often as we need the other
    basic special methods.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: We'll look in detail at how we can expand a simple class definition to add these
    special methods. We'll need to look at both the default behaviors inherited from
    object so that we can understand what overrides are needed and when they're actually
    needed.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The __repr__() and __str__() methods
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has two string representations of an object. These are closely aligned
    with the built-in functions `repr()`, `str()`, `print()`, and the `string.format()`
    method.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the `str()` method representation of an object is commonly expected
    to be more friendly to humans. This is built by an object's `__str__()` method.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `repr()` method representation is often going to be more technical, perhaps
    even a complete Python expression to rebuild the object. The documentation says:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For many types, this function makes an attempt to return a string that would
    yield an object with the same value when passed to `eval()`.
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is built by an object's `__repr__()` method.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The `print()` function will use `str()` to prepare an object for printing.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `format()` method of a string can also access these methods. When we use
    `{!r}` or `{!s}` formatting, we're requesting `__repr__()` or `__str__()`, respectively.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the default implementations first.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple class hierarchy:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We've defined two simple classes with four attributes in each class.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an interaction with an object of one of these classes:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We can see from this output that the default implementations of `__str__()`
    and `__repr__()` are not very informative.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two broad design cases that we consider when overriding `__str__()`
    and `__repr__()`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-collection objects**: A "simple" object doesn''t contain a collection
    of other objects and generally doesn''t involve very complex formatting of that
    collection'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection objects**: An object that contains a collection involves somewhat
    more complex formatting'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non collection __str__() and __repr__()
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we saw previously, the output from `__str__()` and `__repr__()` are not
    very informative. We''ll almost always need to override them. The following is
    an approach to override `__str__()` and `__repr__()` when there''s no collection
    involved. These methods belong to the `Card` class, defined previously:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: These two methods rely on passing the object's internal instance variable dictionary,
    `__dict__`, to the `format()` function. This isn't appropriate for objects that
    use `__slots__`; often, these are immutable objects. The use of names in the format
    specifications makes the formatting more explicit. It also makes the format template
    longer. In the case of `__repr__()`, we passed in the internal `__dict__` plus
    the object's `__class__` as keyword argument values to the `format()` function.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'The template string uses two kinds of format specifications:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: The `{__class__.__name__}` template that could also be written as `{__class__.__name__!s}`
    to be more explicit about providing a simple string version of the class name
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `{suit!r}` and `{rank!r}` template both use the `!r` format specification
    to produce the `repr()` method of the attribute values
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of `__str__()`, we've only passed the object's internal `__dict__`.
    The formatting uses implicit `{!s}` format specifications to produce the `str()`
    method of the attribute values.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Collection __str__() and __repr__()
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When there''s a collection involved, we need to format each individual item
    in the collection as well as the overall container for those items. The following
    is a simple collection with both `__str__()` and `__repr__()` methods:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `__str__()` method is a simple recipe, as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Map `str()` to each item in the collection. This will create an iterator over
    the resulting string values.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `", ".join()` to merge all the item strings into a single, long string.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `__repr__()` method is a multiple-part recipe, as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Map `repr()` to each item in the collection. This will create an iterator over
    the resulting string values.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `", ".join()` to merge all the item strings.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a set of keywords with `__class__`, the collection string, and the various
    attributes from `__dict__`. We've named the collection string `_cards_str` so
    that it doesn't conflict with an existing attribute.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `"{__class__.__name__}({dealer_card!r}, {_cards_str})".format()` to combine
    the class name and the long string of item values. We use the `!r` formatting
    to ensure that the attribute uses the `repr()` conversion too.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In some cases, this can be optimized and made somewhat simpler. Use of positional
    arguments for the formatting can somewhat shorten the template string.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: The __format__() method
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `__format__()` method is used by `string.format()` as well as the `format()`
    built-in function. Both of these interfaces are used to get presentable string
    versions of a given object.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two ways in which arguments will be presented to `__format__()`:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '`someobject.__format__("")`: This happens when the application does `format(someobject)`
    or something equivalent to `"{0}".format(someobject)`. In these cases, a zero-length
    string specification was provided. This should produce a default format.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`someobject.__format__(specification)`: This happens when the application does
    `format(someobject, specification)` or something equivalent to `"{0:specification}".format(someobject)`.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that something equivalent to `"{0!r}".format()` or `"{0!s}".format()` doesn't
    use the `__format__()` method. These use `__repr__()` or `__str__()` directly.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: With a specification of `""`, a sensible response is `return str(self)`. This
    provides an obvious consistency between the various string representations of
    an object.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: The format specification will be all the text after the `":"` in a format string.
    When we write `"{0:06.4f}"`, the `06.4f` is the format specification that applies
    to item `0` of the argument list to be formatted.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'Section 6.1.3.1 of the *Python Standard Library* documentation defines a sophisticated
    numeric specification as a nine-part string. This is the format specification
    mini-language. It has the following syntax:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can parse these standard specifications with a **regular expression** (**RE**)
    as shown in the following code snippet:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This RE will break the specification into eight groups. The first group will
    have both the `fill` and `alignment` fields from the original specification. We
    can use these groups to work out the formatting for the numeric data of the classes
    that we've defined.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: However, Python's format specification mini-language might not apply very well
    to the classes that we've defined. Therefore, we might need to define our own
    specification mini-language and process it in our class `__format__()` method.
    If we're defining numeric types, we should stick to the predefined mini-language.
    For other types, however, there's no reason to stick to the predefined language.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: As an example, here's a trivial language that uses the character `%r` to show
    us the rank and the character `%s` to show us the suit. The `%%` character becomes
    `%` in the resulting string. All other characters are repeated literally.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'We could extend our `Card` class with formatting as shown in the following
    code snippet:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This definition checks for a format specification. If there's no specification,
    then the `str()` function is used. If a specification was provided, a series of
    replacements is done to fold rank, suit, and any `%` characters into the format
    specification, turning it into the output string.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to format cards as follows:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The format specification (`"%r of %s"`) is passed to our `__format__()` method
    as the `format` parameter. Using this, we're able to provide a consistent interface
    for the presentation of the objects of the classes that we've defined.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can define things as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This has the advantage of putting all string presentations into the `__format__()`
    method instead of spreading it between `__format__()` and `__str__()`. This has
    a disadvantage because we don't always need to implement `__format__()`, but we
    almost always need to implement `__str__()`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Nested formatting specifications
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `string.format()` method can handle nested instances of `{}` to perform
    simple keyword substitution into the format specification. This replacement is
    done to create the final format string that's passed to our class `__format__()`
    method. This kind of nested substitution simplifies some kinds of relatively complex
    numeric formatting by parameterizing an otherwise generic specification.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example where we''ve made `width` easy to change in the
    `format` parameter:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We've defined a generic format, `"{hand:%r%s} {count:{width}d}"`, which requires
    a `width` parameter to make it into a proper format specification.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: The value provided with the `width=` parameter to the `format()` method is used
    to replace the `{width}` nested specification. Once this is replaced, the final
    format as a whole is provided to the `__format__()` method.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Collections and delegating format specifications
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When formatting a complex object that includes a collection, we have two formatting
    issues: how to format the overall object and how to format the items in the collection.
    When we look at `Hand`, for example, we see that we have a collection of individual
    `Cards` class. We''d like to have `Hand` delegate some formatting details to the
    individual `Card` instances in the `Hand` collection.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a `__format__()` method that applies to `Hand`:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `format_specification` parameter will be used for each individual `Card`
    instance within the `Hand` collection. The format specification of `"{0:{fs}}"`
    uses the nested format specification technique to push the `format_specification`
    string to create a format that applies to each `Card` instance. Given this method,
    we can format a `Hand` object, `player_hand`, as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This will apply the `%r%s` format specification to each `Card` instance of the
    `Hand` object.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: The __hash__() method
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The built-in `hash()` function invokes the `__hash__()` method of a given object.
    This hash is a calculation which reduces a (potentially complex) value to a small
    integer value. Ideally, a hash reflects all the bits of the source value. Other
    hash calculations—often used for cryptographic purposes—can produce very large
    values.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'Python includes two hash libraries. The cryptographic-quality hash functions
    are in `hashlib`. The `zlib` module has two high-speed hash functions: `adler32()`
    and `crc32()`. For relatively simple values, we don''t use either of these. For
    large, complex values, these algorithms can be of help.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: The `hash()` function (and the associated `__hash__()` method) is used to create
    a small integer key that is used to work with collections such as `set`, `frozenset`,
    and `dict`. These collections use the hash value of an **immutable** object to
    rapidly locate the object in the collection.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Immutability is important here; we'll mention it many times. Immutable objects
    don't change their state. The number `3`, for example, doesn't change state. It's
    always `3`. More complex objects, similarly, can have an immutable state. Python
    strings are immutable so that they can be used as keys to mappings and sets.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'The default `__hash__()` implementation inherited from an object returns a
    value based on the object''s internal ID value. This value can be seen with the
    `id()` function as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: From this, we can see that on the author's particular system, the hash value
    is the object's `id//16`. This detail might vary from platform to platform. CPython,
    for example, uses portable `C` libraries where Jython relies on the Java JVM.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: What's essential is that there is a strong correlation between the internal
    ID and the default `__hash__()` method. This means that the default behavior is
    for each object to be hashable as well as utterly distinct, even if it appears
    to have the same value.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to modify this if we want to coalesce different objects with the
    same value into a single hashable object. We'll look at an example in the next
    section, where we would like two instances of a single `Card` instance to be treated
    as if they were the same object.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Deciding what to hash
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not every object should provide a hash value. Specifically, if we're creating
    a class of stateful, mutable objects, the class should *never* return a hash value.
    The definition of `__hash__` should be `None`.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Immutable objects, on the other hand, might sensibly return a hash value so
    that the object can be used as the key in a dictionary or a member of a set. In
    this case, the hash value needs to parallel the way the test for equality works.
    It's bad to have objects that claim to be equal and have different hash values.
    The reverse—objects with the same hash that are actually not equal—is acceptable.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: The `__eq__()` method, which we'll also look at in the section on comparison
    operators, is intimately tied up with hashing.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three tiers of equality comparison:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '**Same Hash Value**: This means that two objects could be equal. The hash value
    provides us with a quick check for likely equality. If the hash value is different,
    the two objects cannot possibly be equal, nor can they be the same object.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compare As Equal**: This means that the hash values must also have been equal.
    This is the definition of the `==` operator. The objects may be the same object.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Same IDD**: This means that they are the same object. They also compare as
    equal and will have the same hash value. This is the definition of the `is` operator.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Fundamental Law of Hash** (**FLH**) is this: objects that compare as
    equal have the same hash value.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: We can think of a hash comparison as being the first step in an equality test.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: The inverse, however, is not true. Objects can have the same hash value but
    compare as not equal. This is valid and leads to some expected processing overhead
    when creating sets or dictionaries. We can't reliably create distinct 64 bit hash
    values from much larger data structures. There will be unequal objects that are
    reduced to coincidentally equal hash values.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Coincidentally, equal hash values are an expected overhead when working with
    `sets` and `dicts`. These collections have internal algorithms to use alternate
    locations in the event of hash collisions.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three use cases for defining equality tests and hash values via the
    `__eq__()` and `__hash__()` method functions:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutable objects**: These are stateless objects of types such as tuples,
    namedtuples, and frozensets that cannot be updated. We have two choices:'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define neither `__hash__()` nor `__eq__()`. This means doing nothing and using
    the inherited definitions. In this case, `__hash__()` returns a trivial function
    of the ID value for the object, and `__eq__()` compares the ID values. The default
    equality test may sometimes be counterintuitive. Our application might require
    two instances of `Card( 1, Clubs )` to test as equal and compute the same hash;
    this won't happen by default.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define both `__hash__()` and `__eq__()`. Note that we're expected to define
    both for an immutable object.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutable objects**: These are stateful objects that can be modified internally.
    We have one design choice:'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define `__eq__()` but set `__hash__` to `None`. These cannot be used as `dict`
    keys or items in `sets`.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that there''s an additional possible combination: defining `__hash__()`
    but using a default definition for `__eq__()`. This is simply a waste of code,
    as the default `__eq__()` method is the same as the `is` operator. The default
    `__hash__()` method would have involved writing less code for the same behavior.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at each of the three situations in detail.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting definitions for immutable objects
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see how the default definitions operate. The following is a simple class
    hierarchy that uses the default definitions of `__hash__()` and `__eq__()`:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is a class hierarchy for *philosophically* immutable objects. We haven't
    taken care to implement the special methods that prevent the attributes from getting
    updated. We'll look at attribute access in the next chapter.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we use this class hierarchy:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We defined two instances of what appear to be the same `Card` instance. We
    can check the `id()` values as shown in the following code snippet:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: They have different `id()` numbers; they're distinct objects. This meets our
    expectations.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check to see if they''re the same using the `is` operator as shown in
    the following code snippet:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The "is test" is based on the `id()` numbers; it shows us that they are indeed
    separate objects.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that their hash values are different from each other:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'These hash values come directly from the `id()` values. This is our expectation
    for the inherited methods. In this implementation, we can compute the hash from
    the `id()` function as shown in the following code snippet:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As the hash values are different, they must not compare as equal. This fits
    the definitions of hash and equality. However, this violates our expectations
    for this class. The following is an equality check:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We created them with the same arguments. They didn't compare as equal. In some
    applications, this might not be good. For example, when accumulating statistical
    counts around dealer cards, we don't want to have six counts for one card because
    the simulation used a 6-deck shoe.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that they''re proper immutable objects as we can put them into a
    set:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This is the documented behavior from the *Standard Library Reference* documentation.
    By default, we'll get a `__hash__()` method based on the ID of the object so that
    each instance appears unique. However, this isn't always what we want.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Overriding definitions for immutable objects
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a simple class hierarchy that provides us with definitions
    of `__hash__()` and `__eq__()`:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This object is immutable in principle. There's no formal mechanism to make it
    immutable. We'll look at how to prevent the attribute value changes in [Chapter
    3](ch03.html "Chapter 3. Attribute Access, Properties, and Descriptors"), *Attribute
    Access, Properties, and Descriptors*.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the preceding code omits two of the subclasses that didn't change
    significantly from the previous example.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__eq__()` method function compares these two essential values: `suit`
    and `rank`. It doesn''t compare the hard and soft values; they''re derived from
    `rank`.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: The rules for Blackjack make this definition a bit suspicious. Suit doesn't
    actually matter in Blackjack. Should we merely compare rank? Should we define
    an additional method that compares rank only? Or, should we rely on the application
    to compare ranks properly? There's no best answer to these questions; these are
    just trade-offs.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: The `__hash__()` method function computes a bit pattern from the two essential
    values using an exclusive OR of the bits that comprise each value. Using the ^
    operator is a quick-and-dirty hash method that often works pretty well. For larger
    and more complex objects, a more sophisticated hash might be appropriate. Start
    with `ziplib` before inventing something that has bugs.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how objects of these classes behave. We expect them to compare as
    equal and behave properly with sets and dictionaries. Here are two objects:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We defined two instances of what appear to be the same card. We can check the
    ID values to be sure that they''re distinct objects:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: These have different `id()` numbers. When we test with the `is` operator, we
    see that they're distinct.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare the hash values:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The hash values are identical. This means that they could be equal.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'The equality operator shows us that they properly compare as equal:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'As they''re immutable, we can put them into a set as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This meets our expectations for complex immutable objects. We had to override
    both special methods to get consistent, meaningful results.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: Overriding definitions for mutable objects
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example will continue using the `Cards` class. The idea of mutable cards
    is strange, perhaps even wrong. However, we'd like to apply just one small tweak
    to the previous examples.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class hierarchy that provides us with the definitions of
    `__hash__()` and `__eq__()`, appropriate for mutable objects:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let''s see how objects of these classes behave. We expect them to compare as
    equal but not work at all with sets or dictionaries. We''ll create two objects
    as follows:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We've defined two instances of what appear to be the same card.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at their ID values to ensure they really are distinct:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'No surprise here. We''ll see if we can get hash values:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As `__hash__` is set to `None`, these `Card3` objects can't be hashed and can't
    provide a value for the `hash()` function. This is the expected behavior.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'We can perform equality comparisons, though, as shown in the following code
    snippet:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The equality test works properly, allowing us to compare cards. They just can't
    be inserted into sets or used as a key to a dictionary.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what happens when we try:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We get a proper exception when trying to put these into a set.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this is not a proper definition for something that—in real life—is
    immutable like a card. This style of definition is more appropriate for stateful
    objects such as `Hand`, where the content of the hand is always changing. We'll
    provide you with a second example of stateful objects in the following section.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Making a frozen hand from a mutable hand
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to perform statistical analysis of specific `Hand` instances, we
    might want to create a dictionary that maps a `Hand` instance to a count. We can''t
    use a mutable `Hand` class as the key in a mapping. We can, however, parallel
    the design of `set` and `frozenset` and create two classes: `Hand` and `FrozenHand`.
    This allows us to "freeze" a `Hand` class via `FrozenHand`; the frozen version
    is immutable and can be used as a key in a dictionary.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple `Hand` definition:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This is a mutable object (`__hash__` is `None`) that has a proper equality test
    that compares two hands.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a frozen version of `Hand`:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The frozen version has a constructor that will build one `Hand` class from another
    `Hand` class. It defines a `__hash__()` method that sums the card's hash value
    that is limited to the `sys.hash_info.modulus` value. For the most part, this
    kind of modulus-based calculation works out reasonably well for computing hashes
    of composite objects.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use these classes for operations such as the following code snippet:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We've initialized a statistics dictionary, `stats`, as a `defaultdict` dictionary
    that can collect integer counts. We could also use a `collections.Counter` object
    for this.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: By freezing a `Hand` class, we can use it as a key in a dictionary, collecting
    counts of each hand that actually gets dealt.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: The __bool__() method
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a pleasant definition of falsity. The reference manual lists a large
    number of values that will test as equivalent to `False`. This includes things
    such as `False`, `0`, `''`, `()`, `[]`, and `{}`. Most other objects will test
    as equivalent to `True`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, we''ll want to check for an object being "not empty" with a simple statement
    as follows:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Under the hood, this is the job of the `bool()` built-in function. This function
    depends on the `__bool__()` method of a given object.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'The default `__bool__()` method returns `True`. We can see this with the following
    code:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: For most classes, this is perfectly valid. Most objects are not expected to
    be `False`. For collections, however, this is not appropriate. An empty collection
    should be equivalent to `False`. A nonempty collection can return `True`. We might
    want to add a method like this to our `Deck` objects.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re wrapping a list, we might have something as shown in the following
    code snippet:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This delegates the Boolean function to the internal `_cards` collection.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re extending a list, we might have something as follows:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This delegates to the superclass definition of the `__bool__()` function.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, we're specifically delegating the Boolean test. In the wrap case,
    we're delegating to the collection. In the extend case, we're delegating to the
    superclass. Either way, wrap or extend, an empty collection will be `False`. This
    will give us a way to see whether the `Deck` object has been entirely dealt and
    is empty.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do things as shown in the following code snippet:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This loop will deal all the cards without getting an `IndexError` exception
    when the deck has been exhausted.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: The __bytes__() method
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are relatively few occasions to transform an object into bytes. We'll
    look at this in detail in [Part 2](pt02.html "Part 2. Persistence and Serialization"),
    *Persistence and Serialization*.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: In the most common situation, an application can create a string representation,
    and the built-in encoding capabilities of the Python IO classes will be used to
    transform the string into bytes. This works perfectly for almost all situations.
    The main exception would be when we're defining a new kind of string. In that
    case, we'd need to define the encoding of that string.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bytes()` function does a variety of things, depending on the arguments:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '`bytes(integer)`: This returns an immutable bytes object with the given number
    of `0x00` values.'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bytes(string)`: This will encode the given string into bytes. Additional parameters
    for encoding and error handling will define the details of the encoding process.'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bytes(something)`: This will invoke `something.__bytes__()` to create a bytes
    object. The encoding or error arguments will not be used here.'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The base `object` class does not define `__bytes__()`. This means our classes
    don't provide a `__bytes__()` method by default.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: There are some exceptional cases where we might have an object that will need
    to be encoded directly into bytes before being written to a file. It's often simpler
    to work with strings and allow the `str` type to produce bytes for us. When working
    with bytes, it's important to note that there's no *trivial* way to decode bytes
    from a file or interface. The built-in `bytes` class will only decode strings,
    not our unique, new objects. We might need to parse the strings that are decoded
    from the bytes. Or, we might need to explicitly parse the bytes using the `struct`
    module and create our unique objects from the parsed values.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at encoding and decoding `Card` to bytes. As there are only 52
    card values, each card could be packed into a single byte. However, we''ve elected
    to use a character to represent `suit` and a character to represent `rank`. Further,
    we''ll need to properly reconstruct the subclass of `Card`, so we have to encode
    several things:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: The subclass of `Card` (`AceCard`, `NumberCard`, `FaceCard`)
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameters to the subclass-defined `__init__()`
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that some of our alternative `__init__()` methods will transform a numeric
    rank into a string, losing the original numeric value. For the purposes of a reversible
    byte encoding, we need to reconstruct this original numeric rank value.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an implementation of `__bytes__()`, which returns a **UTF-8**
    encoding of the `Cards` class, `rank`, and `suit`:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This works by creating a string representation of the `Card` object and then
    encoding the string into bytes. This is often the simplest and most flexible approach.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are given a pile of bytes, we can decode the string and then parse
    the string into a new `Card` object. The following is a method that can be used
    to create a `Card` object from bytes:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In the preceding code, we've decoded the bytes into a string. Then we've parsed
    the string into individual values. From those values, we can locate the class
    and build the original `Card` object.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build a bytes representation of a `Card` object as follows:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We can reconstruct the `Card` object from the bytes as follows:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: It's important to note that the external bytes representation is often challenging
    to design. We're creating a representation of the state of an object. Python already
    has a number of representations that work well for our class definitions.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: It's often better to use the `pickle` or `json` modules than to invent a low-level
    bytes representation of an object. This is the subject of [Chapter 9](ch09.html
    "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and XML"), *Serializing
    and Saving – JSON, YAML, Pickle, CSV, and XML*.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: The comparison operator methods
  id: totrans-600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has six comparison operators. These operators have special method implementations.
    According to the documentation, the mapping works as follows:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '`x<y` calls `x.__lt__(y)`'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x<=y` calls `x.__le__(y)`'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x==y` calls `x.__eq__(y)`'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x!=y` calls `x.__ne__(y)`'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x>y` calls `x.__gt__(y)`'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x>=y` calls `x.__ge__(y)`'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll return to comparison operators again when looking at numbers in [Chapter
    7](ch07.html "Chapter 7. Creating Numbers"), *Creating Numbers*.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: There's an additional rule regarding what operators are actually implemented
    that's relevant here. These rules are based on the idea that the object's class
    on the left defines the required special method. If it doesn't, Python can try
    an alternative operation by changing the order.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Here are the two basic rules**'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the operand on the left is checked for an operator implementation: `A<B`
    means `A.__lt__(B)`.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, the operand on the right is checked for a reversed operator implementation:
    `A<B` means `B.__gt__(A)`.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: The rare exception to this occurs when the right operand is a subclass of the
    left operand; then, the right operand is checked first to allow a subclass to
    override a superclass.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: We can see how this works by defining a class with only one of the operators
    defined and then using it for other operations.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a partial class that we can use:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This follows the Blackjack comparison rules where suits don't matter. We've
    omitted comparison methods to see how Python will fallback when an operator is
    missing. This class will allow us to perform the `<` comparisons. Interestingly,
    Python can also use this to perform the `>` comparisons by switching the argument
    order. In other words, *x<y≡y>x*. This is the mirror reflection rule; we'll see
    it again in [Chapter 7](ch07.html "Chapter 7. Creating Numbers"), *Creating Numbers*.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'We see this when we try to evaluate different comparison operations. We''ll
    create two `Cards` classes and compare them in various ways as shown in the following
    code snippet:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: From this, we can see where `two < three` maps to `two.__lt__(three)`.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: However, for `two > three`, there's no `__gt__()` method defined; Python uses
    `three.__lt__(two)` as a fallback plan.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `__eq__()` method is inherited from `object`; it compares the
    object IDs; the objects participate in `==` and `!=` tests as follows:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We can see that the results aren't quite what we expect. We'll often need to
    override the default implementation of `__eq__()`.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, there''s no logical connection among the operators. Mathematically, we
    can derive all the necessary comparisons from just two. Python doesn''t do this
    automatically. Instead, Python handles the following four simple reflection pairs
    by default:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '![The comparison operator methods](graphics/0971OS_02_01.jpg)![The comparison
    operator methods](graphics/0971OS_02_02.jpg)![The comparison operator methods](graphics/0971OS_02_03.jpg)![The
    comparison operator methods](graphics/0971OS_02_04.jpg)'
  id: totrans-627
  prefs: []
  type: TYPE_IMG
- en: This means that we must, at the minimum, provide one from each of the four pairs.
    For example, we could provide `__eq__()`, `__ne__()`, `__lt__()`, and `__le__()`.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@functools.total_ordering` decorator overcomes the default limitation
    and deduces the rest of the comparisons from just `__eq__()` and one of these:
    `__lt__()`, `__le__()`, `__gt__()`, or `__ge__()`. We''ll revisit this in [Chapter
    7](ch07.html "Chapter 7. Creating Numbers"), *Creating Numbers*.'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: Designing comparisons
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two considerations when defining the comparison operators:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: The obvious question of how to compare two objects of the same class
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The less obvious question of how to compare objects of different classes
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a class with multiple attributes, we often have a profound ambiguity when
    looking at the comparison operators. It might not be perfectly clear what we're
    going to compare.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: Consider the humble playing card (again!). An expression such as `card1 == card2`
    is clearly intended to compare `rank` and `suit`. Right? Or is that always true?
    After all, `suit` doesn't matter in Blackjack.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to decide whether a `Hand` object can be split, we have to see which
    of the two code snippets is better. The following is the first code snippet:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The following is the second code snippet:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: While one is shorter, brevity is not always best. If we define equality to only
    consider `rank`, we will have trouble defining unit tests because a simple `TestCase.assertEqual()`
    method will tolerate a wide variety of cards when a unit test should be focused
    on exactly correct cards.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: An expression such as `card1 <= 7` is clearly intended to compare `rank`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: Do we want some comparisons to compare all attributes of a card and other comparisons
    to compare just `rank`? What do we do to order cards by `suit`? Furthermore, equality
    comparison must parallel the hash calculation. If we've included multiple attributes
    in the hash, we need to include them in the equality comparison. In this case,
    it appears that equality (and inequality) between cards must be full `Card` comparisons
    because we're hashing the `Card` values to include `rank` and `suit`.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: The ordering comparisons between `Card`, however, should be `rank` only. Comparisons
    against integers, similarly, should be `rank` only. For the special case of detecting
    a split, `hand.cards[0].rank == hand.cards[1].rank` will do nicely because it's
    explicit on the rule for a split.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of comparison for objects of the same class
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll look at a simple same-class comparison by looking at a more complete
    `BlackJackCard` class:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We've now defined all six comparison operators.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve shown you two kinds of type checking: **explicit** and **implicit**.
    The explicit type checking uses `isinstance()`. The implicit type checking uses
    a `try:` block. There''s a tiny conceptual advantage to using the `try:` block:
    it avoids repeating the name of a class. It''s entirely possible that someone
    might want to invent a variation on a card that''s compatible with this definition
    of `BlackJackCard` but not defined as a proper subclass. Using `isinstance()`
    might prevent an otherwise valid class from working correctly.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: The `try:` block might allow a class that coincidentally happens to have a `rank`
    attribute to work. The risk of this turning into a difficult-to-solve problem
    is nil, as the class would likely fail everywhere else it was used in this application.
    Also, who compares an instance of `Card` with a class from a financial modeling
    application that happens to have a rank-ordering attribute?
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: In future examples, we'll focus on the `try:` block. The `isinstance()` method
    check is idiomatic Python and is widely used. We explicitly return `NotImplemented`
    to inform Python that this operator isn't implemented for this type of data. Python
    can try reversing the argument order to see if the other operand provides an implementation.
    If no valid operator can be found, then a `TypeError` exception will be raised.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: We omitted the three subclass definitions and the factory function, `card21()`.
    They're left as an exercise.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 'We also omitted intraclass comparisons; we''ll save that for the next section.
    With this class, we can compare cards successfully. The following is an example
    where we create and compare three cards:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Given those `Cards` classes, we can perform a number of comparisons as shown
    in the following code snippet:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The definitions seem to work as expected.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of comparison for objects of mixed classes
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll use the `BlackJackCard` class as an example to see what happens when we
    attempt comparisons where the two operands are from different classes.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a `Card` instance that we can compare against the `int` values:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This is what we expected: the subclass of `BlackJackCard`, `Number21Card` doesn''t
    provide the required special methods, so there''s a `TypeError` exception.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 'However, consider the following two examples:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Why do these provide responses? When confronted with a `NotImplemented` value,
    Python will reverse the operands. In this case, the integer values define an `int.__eq__()`
    method that tolerates objects of an unexpected class.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Hard totals, soft totals, and polymorphism
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's define `Hand` so that it will perform a meaningful mixed-class comparison.
    As with other comparisons, we have to determine precisely what we're going to
    compare.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: For equality comparisons between `Hands`, we should compare all cards.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: For ordering comparisons between `Hands`, we need to compare an attribute of
    each `Hand` object. For comparisons against an `int` literal, we should compare
    the `Hand` object's total against the literal. In order to have a total, we have
    to sort out the subtlety of hard totals and soft totals in the game of Blackjack.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: 'When there''s an ace in a hand, then the following are two candidate totals:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: The **soft total** treats an ace as 11\. If the soft total is over 21, then
    this version of the ace has to be ignored.
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **hard total** treats an ace as 1.
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that the hand's total isn't a simple sum of the cards.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: We have to determine if there's an ace in the hand first. Given that information,
    we can determine if there's a valid (less than or equal to 21) soft total. Otherwise,
    we'll fall back on the hard total.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: One symptom of **Pretty Poor Polymorphism** is relying on `isinstance()` to
    determine the subclass membership. Generally, this is a violation of the basic
    encapsulation. A good set of polymorphic subclass definitions should be completely
    equivalent with the same method signatures. Ideally, the class definitions are
    opaque; we don't need to look inside the class definition. A poor set of polymorphic
    classes uses extensive `isinstance()` testing. In some cases, `isinstance()` is
    necessary. This can arise when using a built-in class. We can't retroactively
    add method functions to built-in classes, and it might not be worth the effort
    of subclassing them to add a polymorphism helper method.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: In some of the special methods, it's necessary to see `isinstance()` used to
    implement operations that work across multiple classes of objects where there's
    no simple inheritance hierarchy. We'll show you an idiomatic use of `isinstance()`
    for unrelated classes in the next section.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: For our cards class hierarchy, we want a method (or an attribute) that identifies
    an ace without having to use `isinstance()`. This is a polymorphism helper method.
    It ensures we can tell otherwise equivalent classes apart.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two choices:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: Add a class-level attribute
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a method
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the way the insurance bet works, we have two reasons to check for
    aces. If the dealer's card is an ace, it triggers an insurance bet. If the dealer's
    hand (or the player's hand) has an ace, there will be a soft total versus hard
    total calculation.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: The hard total and soft total always differ by the `card.soft–card.hard` value
    for the card that's an ace. We can look inside the definition of `AceCard` to
    see that this value is 10\. However, looking at the implementation breaks encapsulation
    by looking deeply at a class implementation.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: We can treat `BlackjackCard` as opaque and check to see whether `card.soft-card.hard!=0`
    is true. If this is true, it is sufficient information to work out the hard total
    versus soft total of the hand.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a version of the `total` method that makes use of the soft
    versus hard delta value:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: We'll compute the largest difference between the hard and soft total as `delta_soft`.
    For most cards, the difference is zero. For an ace, the difference will be nonzero.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: Given the hard total and `delta_soft`, we can determine which total to return.
    If `hard+delta_soft` is less than or equal to 21, the value is the soft total.
    If the soft total is greater than 21, then revert to a hard total.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: We can consider making the value 21 a manifest constant in the class. A meaningful
    name is sometimes more helpful than a literal. Because of the rules of Blackjack,
    it's unlikely that 21 would ever change to a different value. It's difficult to
    find a more meaningful name than the literal 21.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: A mixed class comparison example
  id: totrans-688
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given a definition of a total for a `Hand` object, we can meaningfully define
    comparisons between the `Hand` instances and comparisons between `Hand` and `int`.
    In order to determine which kind of comparison we're doing, we're forced to use
    `isinstance()`.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a partial definition of `Hand` with comparisons:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: We've defined three of the comparisons, not all six.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to interact with `Hands`, we''ll need a few `Card` objects:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We'll use this sequence of cards to see two different `hand` instances.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: 'This first `Hands` object has an irrelevant dealer''s `Card` object and the
    set of four `Cards` created previously. One of the `Card` objects is an ace:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The soft total is 18 and the hard total is 8.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a second `Hand` object that has an additional `Card` object:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The hard total is 13\. There's no soft total because it would be over 21.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: 'The comparisons among `Hands` work very nicely, as shown in the following code
    snippet:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We can rank `Hands` based on the comparison operators.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also compare `Hands` with integers, as follows:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The comparisons with integers work as long as Python isn't forced to try a fallback.
    The previous example shows us what happens when there's no `__gt__()` method.
    Python checks the reflected operands, and the integer 17 doesn't have a proper
    `__lt__()` method for `Hand` either.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: We can add the necessary `__gt__()` and `__ge__()` functions to make `Hand`
    work properly with integers.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: The __del__() method
  id: totrans-709
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `__del__()` method has a rather obscure use case.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: The intent is to give an object a chance to do any cleanup or finalization just
    before the object is removed from memory. This use case is handled much more cleanly
    by context manager objects and the `with` statement. This is the subject of [Chapter
    5](ch05.html "Chapter 5. Using Callables and Contexts"), *Using Callables and
    Contexts*. Creating a context is much more predictable than dealing with `__del__()`
    and the Python garbage collection algorithm.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: In the case where a Python object has a related OS resource, the `__del__()`
    method is a last chance to cleanly disentangle the resource from the Python application.
    As examples, a Python object that conceals an open file, a mounted device, or
    perhaps a child subprocess might all benefit from having the resource released
    as part of `__del__()` processing.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__del__()` method is not invoked at any easy-to-predict time. It''s not
    always invoked when the object is deleted by a `del` statement, nor is it always
    invoked when an object is deleted because a namespace is being removed. The documentation
    on the `__del__()` method describes the circumstances as *precarious* and provides
    this additional note on exception processing: exceptions that occur during their
    execution are ignored, and a warning is printed to `sys.stderr` instead.'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, a context manager is often preferable to implementing `__del__()`.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: The reference count and destruction
  id: totrans-715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the CPython implementation, objects have a reference count. The count is
    incremented when the object is assigned to a variable and decremented when the
    variable is removed. When the reference count is zero, the object is no longer
    needed and can be destroyed. For simple objects, `__del__()` will be invoked and
    the object will be removed.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: For complex objects that have circular references among objects, the reference
    count might never go to zero and `__del__()` can't be invoked easily.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class that we can use to see what happens:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We can create (and see the removal of) these objects as follows:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We created and removed a `Noisy` object, and almost immediately we saw the message
    from the `__del__()` method. This indicates that the reference count properly
    went to zero when the `x` variable was deleted. Once the variable is gone, there's
    no longer a reference to the instance of `Noisy` and it, too, can be cleaned up.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a common situation that involves the shallow copies that are
    often created:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'There''s no response to this `del` statement. The `Noisy` objects have not
    had their reference counts go to zero yet; they''re still being referenced somewhere,
    as shown in the following code snippet:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The `ln2` variable was a shallow copy of the `ln` list. The `Noisy` objects
    were referenced in two lists. They could not be destroyed until both lists were
    removed, reducing the reference counts to zero.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous other ways to create shallow copies. The following are a
    few ways to create shallow copies of objects:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The point here is that we can often be confused by the number of references
    to an object that can exist because shallow copies are prevalent in Python.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: Circular references and garbage collection
  id: totrans-731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's a common situation that involves circularity. One class, `Parent`, contains
    a collection of children. Each `Child` instance contains a reference to the `Parent`
    class.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use these two classes to examine circular references:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: A `Parent` instance has a collection of children as a simple `list`.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: Each `Child` instance has a reference to the `Parent` class that contains it.
    The reference is created during initialization when the children are inserted
    into the parent's internal collection.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve made both classes rather noisy so we can see when the objects are removed.
    The following is what happens:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The `Parent` and two initial `Child` instances cannot be removed. They both
    contain references to each other.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a childless `Parent` instance, as shown in the following code
    snippet:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: This is deleted, as expected.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: Because of the mutual or circular references, a `Parent` instance and its list
    of `Child` instances cannot be removed from the memory. If we import the garbage
    collector interface, `gc`, we can collect and display these nonremovable objects.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the `gc.collect()` method to collect all the nonremovable objects
    that have a `__del__()` method, as shown in the following code snippet:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: We can see that our `Parent` objects (for example, ID of `4313921808 = 0x101213910`)
    are prominent on the list of nonremovable garbage. To reduce the reference counts
    to zero, we would need to either update each `Parent` instance on the garbage
    list to remove the children, or update each `Child` instance on the list to remove
    the reference to the `Parent` instance.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can't break the circularity by putting code in the `__del__()`
    method. The `__del__()` method is called *after* the circularity has been broken
    and the reference counts are already zero. When we have circular references, we
    can no longer rely on simple Python reference counting to clear out the memory
    of unused objects. We must either explicitly break the circularity or use a `weakref`
    reference, which permits garbage collection.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: Circular references and the weakref module
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the cases where we need circular references but also want `__del__()` to
    work nicely, we can use **weak references**. One common use case for circular
    references are mutual references: a parent with a collection of children; each
    child has a reference back to the parent. If a `Player` class has multiple hands,
    it might be helpful for a `Hand` object to contain a reference to the owning `Player`
    class.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: The default object references could be called **strong references**; however,
    direct references is a better term. They're used by the reference-counting mechanism
    in Python and can be discovered by the garbage collector if reference counting
    can't remove the objects. They cannot be ignored.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 'A strong reference to an object is followed directly. Consider the following
    statement:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 'When we say:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The `a` variable has a direct reference to the object of the `B` class that
    was created. The reference count to the instance of `B` is at least 1 because
    the `a` variable has a reference.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: A weak reference involves a two-step process to find the associated object.
    A weak reference will use `x.parent()`, invoking the weak reference as a callable
    object to track down the actual parent object. This two-step process allows the
    reference counting or garbage collection to remove the referenced object, leaving
    the weak reference dangling.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: The `weakref` module defines a number of collections that use weak references
    instead of strong references. This allows us to create dictionaries that, for
    example, permit the garbage collection of otherwise unused objects.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: We can modify our `Parent` and `Child` classes to use weak references from `Child`
    to `Parent`, permitting a simpler destruction of unused objects.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a modified class that uses weak references from `Child` to
    `Parent`:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: We've changed the child to parent reference to be a `weakref` object reference.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: 'From within a `Child` class, we must locate the `parent` object via a two-step
    operation:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We can explicitly check to be sure the referenced object was found. There's
    a possibility that the reference was left dangling.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use this new `Parent2` class, we see that reference counting goes to
    zero and the object is removed:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'When a `weakref` reference is dead (because the referent was destroyed), we
    have three potential responses:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: Recreate the referent. Reload it from a database, perhaps.
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `warnings` module to write the debugging information on low-memory situations
    where the garbage collector removed objects unexpectedly.
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the problem.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally, the `weakref` references are dead because objects have been removed:
    variables have gone out of scope, a namespace is no longer in use, the application
    is shutting down. For this reason, the third response is quite common. The object
    trying to create the reference is probably about to be removed as well.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: The __del__() and close() methods
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common use for `__del__()` is to ensure files are closed.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, class definitions that open files will have something like what''s
    shown in the following code:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: This will ensure the `__del__()` method is also the `close()` method.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: Anything more complex than this is better done with a context manager. See [Chapter
    5](ch05.html "Chapter 5. Using Callables and Contexts"), *Using Callables and
    Contexts*, for more information on context managers.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: The __new__() method and immutable objects
  id: totrans-777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One use case for the `__new__()` method is to initialize objects that are otherwise
    immutable. The `__new__()` method is where our code can build an uninitialized
    object. This allows processing before the `__init__()` method is called to set
    the attribute values of the object.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: The `__new__()` method is used to extend the immutable classes where the `__init__()`
    method can't easily be overridden.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class that does not work. We''ll define a version of `float`
    that carries around information on units:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We're trying (improperly) to initialize an immutable object.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what happens when we try to use this class definition:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: From this, we see that we can't easily override the `__init__()` method for
    the built-in immutable `float` class. We'd have similar problems with all other
    immutable classes. We can't set the attribute values on the immutable object,
    `self`, because that's the definition of immutability. We can only set attribute
    values during the object construction. Enter the `__new__()` method after this.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: The `__new__()` method is auto-magically a static method. This is true without
    using the `@staticmethod` decorator. It doesn't use a `self` variable, as its
    job is to create the object that will eventually be assigned to the `self` variable.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: For this use case, the method signature is `__new__( cls, *args, **kw )`. The
    `cls` parameter is the class for which an instance must be created. For the metaclass
    use case in the next section, the `args` sequence of values are more complex than
    shown here.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: 'The default implementation of `__new__()` simply does this: `return super().__new__(
    cls )`. It delegates the operation to the superclass. The work winds up getting
    delegated to `object.__new__()`, which builds a simple, empty object of the required
    class. The arguments and keywords to `__new__()`, with the exception of the `cls`
    argument, will be passed to `__init__()` as part of the standard Python behavior.'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: 'With two notable exceptions, this is exactly what we want. The following are
    the exceptions:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: When we want to subclass an immutable class definition. We'll dig into that
    later.
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we need to create a metaclass. That's the subject of the next section,
    as it's fundamentally different from creating immutable objects.
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of overriding `__init__()` when creating a subclass of a built-in immutable
    type, we have to tweak the object at the time of the creation by overriding `__new__()`.
    The following is an example class definition that shows us the proper way to extend
    `float`:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: In the preceding code, we set the value of an attribute during the creation
    of an object.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet gives us a floating-point value with attached units
    information:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Note that an expression such as `speed * 10` does not create a `Float_Units`
    object. This class definition inherits all the operator special methods from `float`;
    the `float` arithmetic special methods all create `float` objects. Creating `Float_Units`
    objects is the subject of [Chapter 7](ch07.html "Chapter 7. Creating Numbers"),
    *Creating Numbers*.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: The __new__() method and metaclasses
  id: totrans-798
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other use case for the `__new__()` method as a part of a metaclass is to
    control how a class definition is built. This is distinct from how `__new__()`
    controls building an immutable object, shown previously.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: A metaclass builds a class. Once a class object has been built, the class object
    is used to build instances. The metaclass of all class definitions is `type`.
    The `type()` function is used to create class objects.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `type()` function can be used as a function to reveal the
    class of an object.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a silly example of building a new, nearly useless class directly
    with `type()` as a constructor:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Once we've created this class, we can create objects of this `Useless` class.
    However, they won't do much because they have no methods or attributes.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this newly-minted `Useless` class to create objects, for what little
    it''s worth. The following is an example:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: We can add attributes to the objects of this class. It does work, minimally,
    as an object.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: 'This is almost equivalent to using `types.SimpleNamespace` or defining a class
    as follows:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'This brings up the important question: why would we mess with the way classes
    are defined in the first place?'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is that some of the default features of a class aren''t *perfectly*
    applicable to some edge cases. We''ll talk about four situations where we might
    want to introduce a metaclass:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: We can use a metaclass to preserve some information about the source text for
    a class. A class built by the built-in `type` uses `dict` to store the various
    methods and class-level attributes. As `dict` is inherently unordered, the attributes
    and methods appear in no particular order. It's extremely unlikely that they would
    appear in the order originally presented in the source. We'll show this in our
    first example.
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaclasses are used to create **Abstract Base Classes** (**ABC**) that we'll
    look at from Chapters 4 through 7\. An ABC relies on a metaclass `__new__()` method
    to confirm that the concrete subclass is complete. We'll introduce this in [Chapter
    4](ch04.html "Chapter 4. The ABCs of Consistent Design"), *The ABCs of Consistent
    Design*.
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaclasses can be used to simplify some aspects of object serialization. We'll
    look at this in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON,
    YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV,
    and XML*.
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a final and rather easy example, we'll look at a self-reference within a
    class. We'll design classes that reference a *master* class. This isn't a superclass-subclass
    relationship. It's a bunch of subclasses that are peer subclasses but have an
    association with one of its peer group as being the master. To be consistent with
    its peers, the master needs a reference to itself, something that's impossible
    without a metaclass. This will be our second example.
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaclass example 1 – ordered attributes
  id: totrans-816
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the canonical example in section 3.3.3, *Customizing Class Creation*,
    of *Python Language Reference*. This metaclass will record the order in which
    the attributes and method functions are defined.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipe has the following three parts:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: Create a metaclass. The `__prepare__()` and `__new__()` functions of that metaclass
    will change the way a target class is built, replacing a plain-old `dict` class
    with the `OrderedDict` class.
  id: totrans-819
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an abstract superclass that is based on the metaclass. This abstract
    class simplifies the inheritance for other classes.
  id: totrans-820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create subclasses of the abstract superclass that benefit from the metaclass.
  id: totrans-821
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the example metaclass that will retain the order of the creation
    of the attribute:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: This class extends the built-in default metaclass, `type`, with a new version
    of `__prepare__()` and `__new__()`.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: The `__prepare__()` method is executed prior to the creation of the class; its
    job is to create the initial namespace object into which the definitions will
    be added. This method could work on any other preparation prior to the execution
    of the class body that is being processed.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__new__()` static method is executed after the class body elements have
    been added to the namespace. It is given the class object, the class name, the
    superclass tuple, and the fully built namespace mapping object. This example is
    typical: it delegates the real work of `__new__()` to the superclass; the superclass
    of a metaclass is the built-in `type`; we use `type.__new__()` to create the default
    class object that can be tweaked.'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: The `__new__()` method in this example adds an attribute, `_order`, into the
    class definition that shows us the original order of the attributes.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this metaclass instead of `type` when defining a new abstract superclass,
    as follows:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We can then use this new abstract class as the superclass for any new classes
    that we define, as follows:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'When we look at the `Something` class, we see the following code snippet:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: We can consider exploiting this information to properly serialize the object
    or provide debugging information that is tied to the original source definitions.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: Metaclass example 2 – self-reference
  id: totrans-835
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll look at an example that involves unit conversion. For example, units of
    length include meters, centimeters, inches, feet, and numerous other units. Managing
    unit conversions can be challenging. Superficially, we need a matrix of all possible
    conversion factors among all the various units. Feet to meters, feet to inches,
    feet to yards, meters to inches, meters to yards, and so on—every combination.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: 'Practically, however, we can do better than this if we define a standard unit
    for length. We can convert any unit to the standard and the standard to any other
    unit. By doing this, we can easily perform any possible conversion as a two-step
    operation, eliminating the complex matrix of all possible conversions: feet to
    standard, inches to standard, yards to standard, meters to standard.'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we're not going to subclass `float` or `numbers.Number`
    in any way. Rather than binding the unit to the value, we'll allow each value
    to remain a simple number. This is an example of a **Flyweight** design pattern.
    The class doesn't define objects that contain the relevant value. The objects
    only contain the conversion factors.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: The alternative (binding units to values) leads to rather complex dimensional
    analysis. While interesting, it's rather complex.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll define two classes: `Unit` and `Standard_Unit`. We can easily be sure
    that each `Unit` class has a reference to its appropriate `Standard_Unit`. How
    can we ensure that each `Standard_Unit` class has a reference to itself? Self-referencing
    within a class definition is impossible because the class hasn''t been defined
    yet.'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is our `Unit` class definition:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The intent is that `Unit.value()` will convert a value in the given unit to
    the standard unit. The `Unit.convert()` method will convert a standard value to
    the given unit.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to work with units, as shown in the following code snippet:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The values created are built-in `float` values. For temperatures, the `value()`
    and `convert()` methods need to be overridden, as a simple multiplication doesn't
    work.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: 'For `Standard_Unit`, we''d like to do something as follows:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: However, that won't work. `INCH` hasn't been defined within the body of `INCH`.
    The class doesn't exist until after the definition.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: 'We could, as a fallback, do this:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: However, that's rather ugly.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: 'We could define a decorator as follows:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This decorator function could tweak the class definition to add an attribute.
    We'll return to this in [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins
    – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we''ll define a metaclass that can insert a circular reference into
    the class definition, as follows:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: This forces the class variable standard into the class definition.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: For most units, `SomeUnit.standard` references `TheStandardUnit` class. In parallel
    with that we'll also have `TheStandardUnit.standard` referencing `TheStandardUnit`
    class, also. This consistent structure among the `Unit` and `Standard_Unit` subclasses
    can help with writing the documentation and automating the unit conversions.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `Standard_Unit` class:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The unit conversion factor inherited from `Unit` is 1.0, so this class does
    nothing to the supplied values. It includes the special metaclass definition so
    that it will have a self-reference that clarifies that this class is the standard
    for this particular dimension of measurement.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: As an optimization, we could override the `value()` and `convert()` methods
    to avoid the multiplication and division.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some sample class definitions for units:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: We defined `INCH` as the standard unit. The other units' definitions will convert
    to and from inches.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve provided some documentation for each unit: the full name in the docstring
    and a short name in the `name` attribute. The conversion factor is automatically
    applied by the `convert()` and `value()` functions inherited from `Unit`.'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: 'These definitions allow the following kind of programming in our applications:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: We can set a particular measurement from a given value in inches and report
    that value in any other compatible unit.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: 'What the metaclass does is allow us to make queries like this from the unit-definition
    classes:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: These kinds of references can allow us to track all the various units of a given
    dimension.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-874
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've looked at a number of *basic* special methods, which are essential features
    of any class that we design. These methods are already part of every class, but
    the defaults we inherit from the object may not match our processing requirements.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: We'll almost always have a need to override `__repr__()`, `__str__()`, and `__format__()`.
    The default implementations of these methods aren't very helpful at all.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: We rarely need to override `__bool__()` unless we're writing our own collection.
    That's the subject of [Chapter 6](ch06.html "Chapter 6. Creating Containers and
    Collections"), *Creating Containers and Collections*.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: We often need to override the comparison and `__hash__()` methods. The definitions
    are suitable for simple immutable objects but not at all appropriate for mutable
    objects. We may not need to write all the comparison operators; we'll look at
    the `@functools.total_ordering` decorator in [Chapter 8](ch08.html "Chapter 8. Decorators
    and Mixins – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: The other two *basic* special method names, `__new__()` and `__del__()`, are
    for more specialized purposes. Using `__new__()` to extend an immutable class
    is the most common use case for this method function.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: 'These basic special methods, along with `__init__()`, will appear in almost
    every class definition we write. The rest of the special methods are for more
    specialized purposes; they fall into six discrete categories:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: '**Attribute Access**: These special methods implement what we see as `object.attribute`
    in an expression, `object.attribute` on the left-hand side of assignment, and
    `object.attribute` in a `del` statement.'
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callables**: A special method implements what we see as a function applied
    to arguments, much like the built-in `len()` function.'
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collections**: These special methods implement the numerous features of collections.
    This involves things such as `sequence[index]`, `mapping[key]`, and `set | set`.'
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numbers**: These special methods provide the arithmetic operators and the
    comparison operators. We can use these methods to expand the domain of numbers
    that Python works with.'
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contexts**: There are two special methods we''ll use to implement a context
    manager that works with the `with` statement.'
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterators**: There are special methods that define an iterator. This isn''t
    essential, as generator functions handle this feature so elegantly. However, we''ll
    look at how we can design our own iterators.'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will address attributes, properties, and descriptors.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3. Attribute Access, Properties, and Descriptors
  id: totrans-888
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object is a collection of features, including methods and attributes. The
    default behavior of the `object` class involves setting, getting, and deleting
    named attributes. We often need to modify this behavior to change the attributes
    available in an object.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will focus on the following five tiers of attribute access:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at built-in attribute processing, which is the simplest, but least
    sophisticated option.
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll review the `@property` decorator. A property extends the concept of an
    attribute to include the processing defined in method functions.
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll look at how to make use of the lower-level special methods that control
    attribute access: `__getattr__()`, `__setattr__()`, and `__delattr__()`. These
    special methods allow us to build more sophisticated attribute processing.'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also take a look at the `__getattribute__()` method, which provides more
    granular control over attributes. This can allow us to write very unusual attribute
    handling.
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we'll take a look at descriptors. These are used to access an attribute,
    but they involve somewhat more complex design decisions. Descriptors are used
    heavily by Python under the hood to implement properties, static methods, and
    class methods.
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we'll see how the default processing works in detail. We need
    to decide where and when to override the default behavior. In some cases, we want
    our attributes to do more than simply be instance variables. In other cases, we
    might want to prevent adding attributes. We may have attributes that have even
    more complex behaviors.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: Also, as we explore descriptors, we'll come to a much deeper understanding of
    how Python's internals work. We don't often need to use descriptors explicitly.
    We often use them implicitly, however, because they're the mechanism that implements
    a number of Python features.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: Basic attribute processing
  id: totrans-898
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, any class we create will permit the following four behaviors with
    respect to attributes:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: To create a new attribute by setting its value
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To set the value of an existing attribute
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the value of an attribute
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To delete an attribute
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can experiment with this using something as simple as the following code.
    We can create a simple, generic class and an object of that class:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The preceding code permits us to create, get, set, and delete attributes. We
    can easily create and get an attribute. The following are some examples:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: We can add, change, and remove attributes. We will get exceptions if we try
    to get an otherwise unset attribute or delete an attribute that doesn't exist
    yet.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: 'A slightly better way to do this is using an instance of the class `types.SimpleNamespace`
    class. The feature set is the same, but we don''t need to create an extra class
    definition. We create an object of the `SimpleNamespace` class instead, as follows:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'In the following code, we can see that the same use cases work for a `SimpleNamespace`
    class:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: We can create attributes for this object. Any attempt to use an undefined attribute
    raises an exception. A `SimpleNamespace` class has different behavior from what
    we saw when we created an instance of the object class.. A simple instance of
    the object class doesn't permit the creation of new attributes; it lacks the internal
    `__dict__` structure that Python stores attributes and values in.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: Attributes and the __init__() method
  id: totrans-914
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the time, we create an initial suite of attributes using the `__init__()`
    method of a class. Ideally, we provide default values for all the attributes in
    `__init__()`.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: It's *not* required to provide all attributes in the `__init__()` method. Because
    of this, the presence or absence of an attribute can be used as part of an object's
    state.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: An optional attribute pushes the edge of the envelope for class definition.
    It makes considerable sense for a class to have a well-defined set of attributes.
    Attributes can often be added (or removed) more clearly by creating a subclass
    or superclass.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, optional attributes imply a kind of informal subclass relationship.
    Therefore, we bump up against Pretty Poor Polymorphism when we use optional attributes.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a Blackjack game in which only a single split is permitted. If a hand
    is split, it cannot be resplit. There are several ways that we can model this:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: We can create a subclass for `SplitHand` from the `Hand.split()` method. We
    won't show this in detail.
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a status attribute on an object named `Hand`, which can be created
    from the `Hand.split()` method. Ideally, this is a Boolean value, but we can implement
    it as an optional attribute as well.
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a version of `Hand.split()` that can detect splittable versus
    unsplittable hands via an optional attribute:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: In effect, the `split()` method tests to see if there's a `split_count` attribute.
    If this attribute exists, then this is a split hand and the method raises an exception.
    If the `split_count` attribute does not exist, this is an initial deal, and splitting
    is allowed.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: An optional attribute has the advantage of leaving the `__init__()` method relatively
    uncluttered with status flags. It has the disadvantage of obscuring some aspects
    of object state. This use of a `try:` block to determine object state can be very
    confusing and should be avoided.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: Creating properties
  id: totrans-926
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A property is a method function that appears (syntactically) to be a simple
    attribute. We can get, set, and delete property values similarly to how we can
    get, set, and delete attribute values. There's an important distinction here.
    A property is actually a method function and can process, rather than simply preserve,
    a reference to another object.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: Besides the level of sophistication, one other difference between properties
    and attributes is that we can't attach new properties to an existing object easily;
    however, we can add attributes to an object easily, by default. A property is
    not identical to simple attributes in this one respect.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to create properties. We can use the `@property` decorator
    or we can use the `property()` function. The differences are purely syntactic.
    We'll focus on the decorator.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll take a look at two basic design patterns for properties:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '**Eager calculation**: In this design pattern, when we set a value via a property,
    other attributes are also computed'
  id: totrans-931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy calculation**: In this design pattern, calculations are deferred until
    requested via a property'
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to compare the preceding two approaches to properties, we''ll split
    some common features of the `Hand` object into an abstract superclass, as follows:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: In the preceding code, we defined just some string representation methods and
    nothing else.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a subclass of `Hand`, where `total` is a lazy property that
    is computed only when needed:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The `Hand_Lazy` class initializes a `Hand` object with a list of the `Cards`
    object. The `total` property is a method that computes the total only when requested.
    Additionally, we defined some other properties to update the collection of cards
    in the hand. The `card` property can get, set, or delete cards in the hand. We'll
    take a look at these properties in setter and deleter properties section.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a `Hand` object, `total` appears to be a simple attribute:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The total is computed lazily by rescanning the cards in the hand each time the
    total is requested. This can be an expensive overhead.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: Eagerly computed properties
  id: totrans-942
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a subclass of `Hand`, where `total` is a simple attribute
    that''s computed eagerly as each card is added:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: In this case, each time a card is added, the `total` attribute is updated.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: The other `card` property—the deleter—eagerly updates the `total` attribute
    whenever a card is removed. We'll take a look at the deleter in detail in the
    next section.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: 'A client sees the same syntax between these two subclasses (`Hand_Lazy()` and
    `Hand_Eager()`) of `Hand`:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: In both cases, the client software simply uses the `total` attribute.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of using properties is that the syntax doesn''t have to change
    when the implementation changes. We can make a similar claim for getter/setter
    method functions. However, getter/setter method functions involve extra syntax
    that isn''t very helpful nor informative. The following are two examples, one
    of which is using a setter method and the other that is using the assignment operator:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The presence of the assignment operator (`=`) makes the intent very plain. Many
    programmers find it clearer to look for assignment statements than to look for
    setter method functions.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: Setter and deleter properties
  id: totrans-953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous examples, we defined the `card` property to deal additional
    cards into an object of the `Hand` class.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: 'Since setter (and deleter) properties are created from the getter property,
    we must always define a getter property first using the following code:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'This allows us to add a card to the hand with a simple statement like the following:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The preceding assignment statement has a disadvantage because it looks like
    it replaces all the cards with a single card. On the other hand, it also has an
    advantage because it uses simple assignment to update the state of a mutable object.
    We can use the `__iadd__()` special method to do this a little more cleanly. But,
    we'll wait until [Chapter 7](ch07.html "Chapter 7. Creating Numbers"), *Creating
    Numbers*, to introduce the other special methods.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: For our current examples, there's no compelling reason to use a deleter property.
    Even without a compelling reason, there's still some use for a deleter. We could,
    however, make use of it to remove the last dealt card. This can be used as part
    of the process for splitting a hand.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: 'We will consider a version of `split()` that works like the following code:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'The preceding method updates the given hand and returns a new hand. The following
    is an example of a hand being split:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Once we have two cards, we can use `split()` to produce the second hand. A card
    was removed from the initial hand.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: This version of `split()` is certainly workable. However, it seems somewhat
    better to have the `split()` method return two fresh new `Hand` objects. That
    way, the old, presplit `Hand` instance can be used as a memento to gather statistics.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: Using special methods for attribute access
  id: totrans-967
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll look at the three canonical special methods for attribute access: `__getattr__()`,
    `__setattr__()`, and `__delattr__()`. Additionally, we''ll acknowledge the `__dir__()`
    method to reveal attribute names. We''ll defer `__getattribute__()` to the next
    section.'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: 'The default behavior shown in the first section is as follows:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: The `__setattr__()` method will create and set attributes.
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__getattr__()` method will do two things. Firstly, if an attribute already
    has a value, `__getattr__()` is not used; the attribute value is simply returned.
    Secondly, if the attribute does not have a value, then `__getattr__()` is given
    a chance to return a meaningful value. If there is no attribute, it must raise
    an `AttributeError` exception.
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__delattr__()` method deletes an attribute.
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__dir__()` method returns a list of attribute names.
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__getattr__()` method function is only one step in a larger process; it
    is only used if the attribute is otherwise unknown. If the attribute is a known
    attribute, this method is not used. The `__setattr__()` and `__delattr__()` methods
    do not have built-in processing. These methods don't interact with additional
    processing.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a number of design choices for controlling attribute access. These
    follow our three essential design choices to extend, wrap, or invent. The design
    choices are as follows:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: We can extend a class, making it almost immutable by overriding `__setattr__()`
    and `__delattr__()`. We can also replace the internal `__dict__` with `__slots__`.
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can wrap a class and delegate attribute access to the object (or composite
    of objects) being wrapped. This may involve overriding all three of these methods.
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can implement property-like behaviors in a class. Using these methods, we
    can assure that all property processing is centralized.
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create lazy attributes where the values aren't (or can't be) computed
    until they're needed. We may have an attribute that doesn't have a value until
    it's read from a file, database, or network. This is common use for `__getattr__()`.
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can have eager attributes, where setting an attribute creates values in other
    attributes automagically. This is done via overrides to `__setattr__()`.
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We won''t look at all of these alternatives. Instead, we''ll focus on the two
    most commonly used techniques: extending and wrapping. We''ll create immutable
    objects and look at other ways to eagerly compute attribute values.'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: Creating immutable objects with __slots__
  id: totrans-982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we are not able to set an attribute or create a new one, then the object
    is immutable. The following is what we''d like to see in interactive Python:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The preceding code shows that we are not allowed to change an attribute or add
    one to this object.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make two changes to a class definition for this to work. We''ll
    omit much of the class and focus on just the three features that make an object
    immutable, as follows:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'We made three significant changes:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: We set `__slots__` to the names of only the allowed attributes. This turns off
    the internal `__dict__` feature of the object and limits us to just the attributes
    and no more.
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined `__setattr__()` to raise an exception rather than do anything useful.
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined `__init__()` to use the superclass version of `__setattr__()` so
    that values can be properly set in spite of the absence of a working `__setattr__()`
    method in this class.
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With some care, we can bypass the immutability feature if we work at it.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: That brings us to a question. "How can we prevent an "evil" programmer from
    bypassing the immutability feature?" The question is silly. We can't stop the
    evil programmer. Another equally silly question is, "Why would some evil programmer
    write all that code to circumvent immutability?". We can't stop the evil programmer
    from doing evil things.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: If this imaginary programmer doesn't like immutability in a class, they can
    modify the definition of the class to remove the redefinition of `__setattr__()`.
    The point of an immutable object like this is to guarantee `__hash__()` returning
    a consistent value and not to prevent people from writing rotten code.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-996
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Don''t abuse __slots__**'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: The `__slots__` feature is intended primarily to save memory by limiting the
    number of attributes.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: Creating immutable objects as a tuple subclass
  id: totrans-999
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also create an immutable object by making our `Card` property a subclass
    of `tuple` and an override to `__getattr__()`. In this case, we'll translate `__getattr__(name)`
    requests to `self[index]` requests. As we'll see in [Chapter 6](ch06.html "Chapter 6. Creating
    Containers and Collections"), *Creating Containers and Collections*, `self[index]`
    is implemented by `__getitem__(index)`.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a small extension to the built-in `tuple` class:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: In this example, we simply raised a simple `AttributeError` exception rather
    than providing detailed error messages.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the preceding code, we see the following kinds of interaction:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: We can't change the value of a card easily. However, we can still tweak `d.__dict__`
    to introduce *additional* attributes.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1007
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Is this really necessary?**'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: This is, perhaps, too much work to simply assure that an object isn't accidentally
    misused. Practically, we're more interested in the diagnostic information available
    from an exception and traceback than we are in a super-secure immutable class.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: Eagerly computed attributes
  id: totrans-1010
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can define an object where attributes are computed eagerly as soon as possible
    after a value is set. This object optimizes access by doing a computation once
    and leaving the result to be used multiple times.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: We're able to define a number of property setters to do this. However, a lot
    of property setters, each of which compute a number of attributes, can get wordy
    for a complex calculation.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: We can centralize the attribute processing. In the following example, we'll
    use a few tweaks to extend Python's internal `dict` type. The advantage of extending
    `dict` is that it works well with the `format()` method of a string. Also, we
    don't have to worry much about setting extra attribute values that are otherwise
    ignored.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: 'We''d like something that looks like the following code:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'We can set the values in this `RateTimeDistance` object. Additional attributes
    are computed as soon as sufficient data is present. We can do this either all
    at once, as shown earlier, or in stages, as shown in the following code:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'The following is the extension to the built-in `dict` . We''ve extended the
    essential mapping that `dict` implements to compute a missing attribute:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: The `dict` type uses `__init__()` to populate the internal dictionary, then
    tries to solve if enough data is present. It uses `__setattr__()` to add new items
    to the dictionary. It also attempts to solve the equation each time a value is
    set.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: In `__getattr__()`, we use `None` to indicate a missing value from the equation.
    This allows us to set an attribute to `None` to indicate that it is a missing
    value, and this will force the solution to look for this value. For example, we
    might do this based on user inputs or a network request where all parameters were
    given a value but one variable was set to `None`.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it as follows:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Note
  id: totrans-1024
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we can't set attribute values inside this class definition easily.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following line of code:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: If we were to write the preceding code snippet, we'd have infinite recursions
    between `__setattr__()` and `_solve()`. When we used `self['distance']` in the
    example, we avoided the recursive call of `__setattr__()`.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to note that once all three values are set, this object
    can't be changed to provide new solutions easily.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t simply set a new value for `rate` and compute a new value for `time`
    while leaving `distance` unchanged. To tweak this model, we need to both clear
    one variable and set a new value for another variable:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Here, we cleared `time` and changed `rate` to get a new solution for `time`
    using the established value for `distance`.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: We could design a model that tracked the order that the variables were set in;
    this model could save us from having to clear one variable before setting another
    to recompute a related result.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: The __getattribute__() method
  id: totrans-1034
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An even lower level attribute processing is the `__getattribute__()` method.
    The default implementation attempts to locate the value as an existing attribute
    in the internal `__dict__` (or `__slots__`). If the attribute is not found, it
    calls `__getattr__()` as a fallback. If the value located is a descriptor (see
    in the following *Creating descriptors* section), then it processes the descriptor.
    Otherwise, the value is simply returned.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: 'By overriding this method, we can perform any of the following kinds of tasks:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: We can effectively prevent access to attributes. This method, by raising an
    exception instead of returning a value, can make an attribute more secret than
    if we were to merely use the leading underscore (`_`) to mark a name as private
    to the implementation.
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can invent new attributes similarly to how `__getattr__()` can invent new
    attributes. In this case, however, we can bypass the default lookup done by the
    default version of `__getattribute__()`.
  id: totrans-1038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can make attributes perform unique and different tasks. This might make the
    program very difficult to understand or maintain. This could be a terrible idea,
    also.
  id: totrans-1039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can change the way descriptors behave. While technically possible, changing
    a descriptor's behavior sounds like a terrible idea.
  id: totrans-1040
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we implement the `__getattribute__()` method, it's important to note that
    there cannot be any internal attribute access in the method's body. If we attempt
    to get the value for `self.name`, it will lead to infinite recursions.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1042
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `__getattribute__()` method cannot give any simple `self.name` attribute
    access; it will lead to infinite recursions.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get attribute values within the `__getattribute__()` method, we
    must explicitly refer to the base method defined in `object`, as shown in the
    following declaration:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'We could, for example, revise our immutable class to use `__getattribute__()`
    and prevent access to the internal `__dict__` attribute. The following is a class
    that conceals all the names beginning with the underscore character (`_`):'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'We''ve overridden `__getattribute__()` to raise an attribute error on private
    names as well as Python''s internal names. This has a microscopic advantage over
    the previous example: we are not allowed to tweak the object at all. We''ll see
    an example of an interaction with an instance of this class.'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an object of this class being mutated:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: As general advice, it's rarely a good idea to mess with `__getattribute__()`.
    The default method is quite sophisticated, and almost everything we need is available
    as a property or as a change to `__getattr__()`.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: Creating descriptors
  id: totrans-1052
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A descriptor is a class that mediates attribute access. The descriptor class
    can be used to get, set, or delete attribute values. Descriptor objects are built
    inside a class at class definition time.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: 'The descriptor design pattern has two parts: an **owner class** and the **attribute
    descriptor** itself. The owner class uses one or more descriptors for its attributes.
    A descriptor class defines some combination of get, set, and delete methods. An
    instance of the descriptor class will be an attribute of the owner class.'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: Properties are based on the method functions of the owner class. A descriptor,
    unlike a property, is an instance of a class different from the owning class.
    Therefore, descriptors are often reusable, generic kinds of attributes. The owning
    class can have multiple instances of each descriptor class to manage attributes
    with similar behaviors.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other attributes, descriptors are created at the class level. They're
    not created within the `__init__()` initialization. While descriptor values can
    be set during initialization, descriptors are generally built as part of the class,
    outside any method functions.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: Each descriptor object will be an instance of a descriptor class bound to a
    distinct class-level attribute name when the owner class is defined.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: To be recognized as a descriptor, a class must implement any combination of
    the following three methods.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '`Descriptor.__get__( self, instance, owner ) → object`: In this method, the
    `instance` parameter is the `self` variable of the object being accessed. The
    `owner` parameter is the owning class object. If this descriptor is invoked in
    a class context, the `instance` parameter will get a `None` value. This must return
    the value of the descriptor.'
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Descriptor.__set__( self, instance, value )`: In this method, the `instance`
    parameter is the `self` variable of the object being accessed. The `value` parameter
    is the new value that the descriptor needs to be set to.'
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Descriptor.__delete__( self, instance )`: In this method, the `instance` parameter
    is the `self` variable of the object being accessed. This method of the descriptor
    must delete this attribute''s value.'
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, a descriptor class will also need an `__init__()` method function
    to initialize the descriptor's internal state.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two species of descriptors based on the methods defined, as follows:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '**A nondata descriptor**: This kind of descriptor defines `__set__()` or `__delete__()`
    or both. It cannot define `__get__()`. The nondata descriptor object will often
    be used as part of some larger expression. It might be a callable object, or it
    might have attributes or methods of its own. An immutable nondata descriptor must
    implement `__set__()` but may simply raise `AttributeError`. These descriptors
    are slightly simpler to design because the interface is more flexible.'
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A data descriptor**: This descriptor defines `__get__()` at a minimum. Usually,
    it defines both `__get__()` and `__set__()` to create a mutable object. The descriptor
    can''t define any further attributes or methods of this object since the descriptor
    will largely be invisible. A reference to an attribute that has a value of a data
    descriptor is delegated to the `__get__()`, `__set__()`, or `__delete__()` methods
    of the descriptor. These can be tricky to design, so we''ll look at them second.'
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a wide variety of use cases for descriptors. Internally, Python uses
    descriptors for several reasons:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, the methods of a class are implemented as descriptors. These
    are nondata descriptors that apply the method function to the object and the various
    parameter values.
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `property()` function is implemented by creating a data descriptor for the
    named attribute.
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class method or static method is implemented as a descriptor; this applies
    to the class instead of an instance of the class.
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we look at object-relational mapping in [Chapter 11](ch11.html "Chapter 11. Storing
    and Retrieving Objects via SQLite"), *Storing and Retrieving Objects via SQLite*,
    we'll see that many of the ORM class definitions make heavy use of descriptors
    to map Python class definitions to SQL tables and columns.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: 'As we think about the purposes of a descriptor, we must also examine the three
    common use cases for the data that a descriptor works with as follows:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: The **descriptor object** has, or acquires, the data. In this case, the descriptor
    object's `self` variable is relevant and the descriptor is stateful. With a data
    descriptor, the `__get__()` method returns this internal data. With a nondata
    descriptor, the descriptor has other methods or attributes to access this data.
  id: totrans-1072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **owner instance** contains the data. In this case, the descriptor object
    must use the `instance` parameter to reference a value in the owning object. With
    a data descriptor, the `__get__()` method fetches the data from the instance.
    With a nondata descriptor, the descriptor's other methods access the instance
    data.
  id: totrans-1073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **owner class** contains the relevant data. In this case, the descriptor
    object must use the `owner` parameter. This is commonly used when the descriptor
    implements a static method or class method that applies to the class as a whole.
  id: totrans-1074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll take a look at the first case in detail. We'll look at creating a data
    descriptor with `__get__()` and `__set__()` methods. We'll also look at creating
    a nondata descriptor without a `__get__()` method.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: The second case (the data in the owning instance) shows what the `@property`
    decorator does. The possible advantage that a descriptor has over a conventional
    property is that it moves the calculations into the descriptor class from the
    owner class. This tends to fragment class design and is probably not the best
    approach. If the calculations are truly of epic complexity, then a strategy pattern
    might be better.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: The third case shows how the `@staticmethod` and `@classmethod` decorators are
    implemented. We don't need to reinvent those wheels.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: Using a nondata descriptor
  id: totrans-1078
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We often have small objects with a few tightly bound attribute values. For this
    example, we'll take a look at numeric values that are bound up with units of measure.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple nondata descriptor class that lacks a `__get__()`
    method:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: This class defines a simple pair of values, one that is mutable (the value)
    and another that is effectively immutable (the unit).
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: When this descriptor is accessed, the descriptor object itself is made available,
    and other methods or attributes of the descriptor can then be used. We can use
    this descriptor to create classes that manage measurements and other numbers associated
    with physical units.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class that does rate-time-distance calculations eagerly:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: As soon as the object is created and the attributes loaded, the missing value
    is computed. Once computed, the descriptor can be examined to get the value or
    the unit's name. Additionally, the descriptor has a handy response to `str()`
    and formatting requests.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an interaction between a descriptor and the `RTD_1` class:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: We created an instance of `RTD_1` with `rate` and `distance` arguments. These
    were used to evaluate the `__set__()` methods of the `rate` and `distance` descriptors.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: When we asked for `str(m1)`, this evaluated the overall `__str__()` method of
    `RTD_1` that, in turn, used the `__format__()` method of the rate, time, and distance
    descriptors. This provided us with numbers with units attached to them.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: We can also access the individual elements of a descriptor since nondata descriptors
    don't have `__get__()` and don't return their internal values.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: Using a data descriptor
  id: totrans-1092
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A data descriptor is somewhat trickier to design because it has such a limited
    interface. It must have a `__get__()` method and it can only have `__set__()`
    or `__delete__()`. This is the entire interface: from one to three of these methods
    and no other methods. Introducing an additional method means that Python will
    not recognize the class as being a proper data descriptor.'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: We'll design an overly simplistic unit conversion schema using descriptors that
    can do appropriate conversions in their `__get__()` and `__set__()` methods.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a superclass of a descriptor of units that will do conversions
    to and from a standard unit:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: This class does simple multiplications and divisions to convert standard units
    to other non-standard units and vice versa.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: With this superclass, we can define some conversions from a standard unit. In
    the previous case, the standard unit is KPH (kilometers per hour).
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two conversion descriptors:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'The inherited methods are perfectly useful. The only thing that changes is
    the conversion factor. These classes can be used to work with values that involve
    unit conversion. We can work with MPH''s or knots interchangeably. The following
    is a unit descriptor for a standard unit, kilometers per hour:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: This class represents a standard, so it doesn't do any conversion. It uses a
    private variable in the instance to save the standard value for speed in KPH.
    Avoiding any arithmetic conversion is simply a technique of optimization. Avoiding
    any reference to one of the public attributes is essential to avoiding infinite
    recursions.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class that provides a number of conversions for a given
    measurement:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Each of the class-level attributes is a descriptor for a different unit. The
    get and set methods of the various descriptors will do appropriate conversions.
    We can use this class to convert speeds among a variety of units.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an interaction with the `Measurement` class:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: We created an object of the `Measurement` class by setting various descriptors.
    In the first case, we set the knots descriptor.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: When we displayed the value as a large string, each of the descriptor's `__get__()`
    methods was used. These methods fetched the internal `kph` attribute value from
    the owning object, applied a conversion factor, and returned the resulting value.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: The `kph` attribute also uses a descriptor. This descriptor does not do any
    conversion; however, it simply returns a private value cached in the owning object.
    The `KPH` and `Knots` descriptors require that the owning class implement a `kph`
    attribute.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: Summary, design considerations, and trade-offs
  id: totrans-1113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we looked at several ways to work with an object's attributes.
    We can use the built-in features of the `object` class and get and set attribute
    values. We can define properties to modify how attributes behave.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: If we want more sophistication, we can tweak the underlying special method implementations
    for `__getattr__()`, `__setattr__()`, `__delattr__()`, or `__getattribute__()`.
    These allow us very fine-grained control over attribute behaviors. We walk a fine
    line when we touch these methods because we can make fundamental (and confusing)
    changes to Python's behavior.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: Internally, Python uses descriptors to implement features such as method functions,
    static method functions, and properties. Many of the cool use cases for descriptors
    are already first-class features of the language.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: Programmers coming from other languages (particularly Java and C++) usually
    have the urge to try to make all attributes private and write extensive getter
    and setter functions. This kind of coding is necessary for languages where type
    definitions are statically compiled in.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, it''s considerably simpler to treat all attributes as public. This
    means the following:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: They should be well documented.
  id: totrans-1119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They should properly reflect the state of the object; they shouldn't be temporary
    or transient values.
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the rare case of an attribute that has a potentially confusing (or brittle)
    value, a single leading underscore character (`_`) marks the name as "not part
    of the defined interface." It's not really private.
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to think of private attributes as a nuisance. Encapsulation isn't
    broken by the lack of complex privacy mechanisms in the language; it is broken
    by bad design.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: Properties versus attributes
  id: totrans-1123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most cases, attributes can be set outside a class with no adverse consequences.
    Our example of the `Hand` class shows this. For many versions of the class, we
    can simply append to `hand.cards`, and the lazy computation of `total` via a property
    will work perfectly.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where the changing of an attribute should lead to consequential changes
    in other attributes, some more sophisticated class design is required:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: A method function may clarify the state change. This will be necessary when
    multiple parameter values are required.
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A property setter may be clearer than a method function. This will be a sensible
    option when a single value is required.
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use in-place operators. We'll defer this until [Chapter 7](ch07.html
    "Chapter 7. Creating Numbers"), *Creating Numbers*.
  id: totrans-1128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no strict rule. In this case, where we need to set a single parameter
    value, the distinction between a method function and a property is entirely one
    of API syntax and how well that communicates the intent.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: For computed values, a property allows lazy computation, while an attribute
    requires eager computation. This devolves to a performance question. The benefits
    of lazy versus eager computation are based on the expected use cases.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: Designing with descriptors
  id: totrans-1131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many examples of descriptors are already part of Python. We don't need to reinvent
    properties, class methods, or static methods.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: The most compelling cases for creating new descriptors relate to mapping between
    Python and something non-Python. Object-relational database mapping, for example,
    requires a great deal of care to ensure that a Python class has the right attributes
    in the right order to match a SQL table and columns. Also, when mapping to something
    outside Python, a descriptor class can handle encoding and decoding data or fetching
    the data from external sources.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: When building a web service client, we might consider using descriptors to make
    web service requests. The `__get__()` method, for example, might turn into an
    HTTP GET request, and the `__set__()` method might turn into an HTTP PUT request.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, a single request may populate the data of several descriptors.
    In this case, the `__get__()` method would check the instance cache and return
    that value before making an HTTP request.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: 'Many data descriptor operations are more simply handled by properties. This
    provides us with a place to start: to write properties first. If the property
    processing becomes too expansive or complex, then we can switch to descriptors
    to refactor the class.'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  id: totrans-1137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapter, we'll look closely at the **ABC**s (**Abstract Base Classes**)
    that we'll exploit in Chapters 5, 6, and 7\. These ABCs will help us define classes
    that integrate nicely with existing Python features. They will also allow us to
    create class hierarchies that enforce consistent design and extension.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4. The ABCs of Consistent Design
  id: totrans-1139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python Standard Library provides abstract base classes for a number of features
    of containers. It provides a consistent framework for the built-in container classes,
    such as `list`, `map`, and `set`.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the library provides abstract base classes for numbers. We can
    use these classes to extend the suite of numeric classes available in Python.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: We'll look in general at the abstract base classes in the `collections.abc`
    module. From there, we can focus on a few use cases that will be the subject of
    detailed examination in future chapters.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three design strategies: Wrap, Extend, and Invent. We''ll look at the
    general concepts behind the various containers and collections that we might want
    to wrap or extend. Similarly, we''ll look at the concepts behind the numbers that
    we might want to implement.'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to assure that our application classes integrate seamlessly with
    existing Python features. If we create a collection, for example, it's appropriate
    to have that collection also create an iterator by implementing `__iter__()`.
    A collection that implements `__iter__()` will work seamlessly with a `for` statement.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: Abstract base classes
  id: totrans-1145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core of the **Abstract Base Class** (**ABC**) definition is defined in a
    module named `abc`. This contains the required decorators and metaclasses to create
    abstractions. Other classes rely on these definitions.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.2, the abstract base classes for collections were buried in `collections`.
    In Python 3.3, however, the abstract base classes have been split into a separate
    submodule named `collections.abc`.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at the `numbers` module, because it contains ABCs for numeric
    types. There are abstract base classes for I/O in the `io` module too.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: We'll focus on Python Version 3.3\. The definitions will work very similarly
    for Python 3.2, but the `import` statement will change slightly to reflect the
    flatter library structure.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: 'An abstract base class has a number of features, as follows:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: Abstract means that these classes don't contain all of the method definitions
    required to work completely. For it to be a useful subclass, we will need to provide
    some method definitions.
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base means that other classes will use it as a superclass.
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract class provides some definitions for method functions. Most importantly,
    the abstract base classes provide the signatures for the missing method functions.
    A subclass must provide the right methods to create a concrete class that fits
    the interface defined by the abstract class.
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The features of the abstract base classes include the following ideas:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: We can use them to define a consistent set of base classes for Python's internal
    classes and our customized application classes.
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use them to create some common, reusable abstractions that we can use
    in our applications.
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use them to support the proper inspection of a class to determine what
    it does. This allows better collaboration among library classes and new classes
    in our applications. In order to do an inspection properly, it helps to have the
    formal definition of concepts such as "container" and "number".
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without abstract base classes (that is, in the "bad old days") a container may,
    or may not, have provided all the features of a `Sequence` class consistently.
    This often leads to a class being almost a sequence or sequence-like. This, in
    turn, leads to odd inconsistencies and kludgy workarounds for a class that didn't
    quite provide all the features of a sequence.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: With an abstract base class, you can assure that an application's given class
    will have the advertised features. If it lacks a feature, the presence of an undefined
    abstract method will make the class unusable for building object instances.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use ABCs in several situations, as follows:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: We'll use ABC's as superclasses when defining our own classes
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use ABC's within a method to confirm that an operation is possible
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use ABC's within a diagnostic message or exception to indicate why an
    operation can't work
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the first use case, we may write modules with code that looks like the
    following:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Our `SomeApplicationClass` is defined to be a `Callable` class. It must then
    implement the specific methods required by `Callable`, or we will not be able
    to create an instance.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: A function is a concrete example of a `Callable` class. The abstraction is a
    class that defines the `__call__()` method. We'll look at `Callables` classes
    in the following section and in [Chapter 5](ch05.html "Chapter 5. Using Callables
    and Contexts"), Using *Callables and Contexts*.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second use case, we may write methods with code that looks like the
    following:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Our `some_method()` requires for the `other` argument to be a subclass of `Iterator`.
    If the `other` argument can't pass this test, we get an exception. A common alternative
    to `assert` is an `if` statement that raises `TypeError`, which may be more meaningful.
    We'll see this in the following section.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: 'For the third use case, we might have something like the following:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: In this case, we wrote a diagnostic warning that shows the base classes for
    a given object. This may help debug the problem with the application design.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: Base classes and polymorphism
  id: totrans-1174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll flirt with the idea of **Pretty Poor Polymorphism**.
    Inspection of argument values is a Python programming practice that should be
    isolated to a few special cases.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: Well-done polymorphism follows what is sometimes called the **Liskov Substitution
    Principle**. Polymorphic classes can be used interchangeably. Each polymorphic
    class has the same suite of properties. For more information, visit [http://en.wikipedia.org/wiki/Liskov_substitution_principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle).
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: Overusing `isinstance()` to distinguish between the types of arguments can lead
    to a needlessly complex (and slow) program. Instance comparisons are made all
    the time, but errors are generally only introduced through software maintenance.
    Unit testing is a far better way to find programming errors than verbose type-checking
    in the code.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: Method functions with lots of `isinstance()` methods can be a symptom of a poor
    (or incomplete) design of polymorphic classes. Rather than having type-specific
    processing outside of a class definition, it's often better to extend or wrap
    classes to make them more properly polymorphic and encapsulate the type-specific
    processing within the class definition.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: 'One good use of the `isinstance()` method is to create diagnostic messages.
    A simple approach is to use the `assert` statement:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'This will raise an `AssertionError` exception to indicate that there''s a problem.
    This has the advantage that it is short and to the point. However, it has two
    disadvantages: assertions can be silenced, and it would probably be better to
    raise a `TypeError` for this. The following example might be better:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The preceding code has the advantage that it raises the correct error. However,
    it has the disadvantage that it is long winded.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: 'The more Pythonic approach is summarized as follows:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: '"It''s better to ask for forgiveness than to ask for permission."'
  id: totrans-1185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is generally taken to mean that we should minimize the upfront testing
    of arguments (asking permission) to see if they're the correct type. Argument-type
    inspections are rarely of any tangible benefit. Instead, we should handle the
    exceptions appropriately (asking forgiveness).
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: What's best is to combine diagnostic information with the exception in the unlikely
    event that an inappropriate type is used and somehow passed through unit testing
    into operation.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is often what''s done:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: The `isinstance()` method assumes that `some_argument` is a proper instance
    of a `collections.abc.Container` class and will respond to the `in` operator.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: In the unlikely event that someone changes the application and `some_argument`
    is now of the wrong class, the application will write a diagnostic message and
    crash with a `TypeError` exception.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: Callables
  id: totrans-1192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python's definition of **callable object** includes the obvious function definitions
    created with the `def` statement.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: It also includes, informally, any class with a `__call__()` method. We can see
    several examples of this in *Python 3 Object Oriented Programming*, *Dusty Phillips*,
    *Packt Publishing*. For it to be more formal, we should make every callable class
    definition a proper subclass of `collections.abc.Callable`.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at any Python function, we see the following behavior:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'The built-in `abs()` function is a proper instance of `collections.abc.Callable`.
    This is also true for the functions we define. The following is an example:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Every function reports itself as `Callable`. This simplifies the inspection
    of an argument value and helps write meaningful debugging messages.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: We'll take a look at callables in detail in [Chapter 5](ch05.html "Chapter 5. Using
    Callables and Contexts"), *Using Callables and Contexts*.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: Containers and collections
  id: totrans-1201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `collections` module defines a number of collections above and beyond the
    built-in container classes. The container classes include `namedtuple()`, `deque`,
    `ChainMap`, `Counter`, `OrderedDict`, and `defaultdict`. All of these are examples
    of classes based on ABC definitions.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a quick interaction to show how we can inspect collections
    to see the methods they will support:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: We can inspect the simple `dict` class to see that it follows the basic mapping
    protocol and will support the required methods.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: We can inspect a `defaultdict` collection to confirm that it is also a mapping.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: When creating a new kind of container, we can do it informally. We can create
    a class that has all of the right special methods. However, we aren't *required*
    to make a formal declaration that it's a certain kind of container.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s more clear (and more reliable) to use a proper ABC as the base class
    for one of our application classes. The additional formality has the following
    two advantages:'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: It advertises what our intention was to people reading (and possibly using or
    maintaining) our code. When we make a subclass of `collections.abc.Mapping`, we're
    making a very strong claim about how that class will be used.
  id: totrans-1209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates some diagnostic support. If we somehow fail to implement all of the
    required methods properly, we can't create instances of the abstract base class.
    If we can't run the unit tests because we can't create instances of an object,
    then this indicates a serious problem that needs to be fixed.
  id: totrans-1210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire family tree of built-in containers is reflected in the abstract base
    classes. Lower-level features include `Container`, `Iterable`, and `Sized`. These
    are a part of higher-level constructs; they require a few specific methods, particularly
    `__contains__()`, `__iter__()`, and `__len__()`, respectively.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: 'Higher-level features include the following characteristics:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: '`Sequence` and `MutableSequence`: These are the abstractions of the concrete
    classes `list` and `tuple`. Concrete sequence implementations also include `bytes`
    and `str`.'
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MutableMapping`: This is the abstraction of `dict`. It extends `Mapping`,
    but there''s no built-in concrete implementation of this.'
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set` and `MutableSet`: These are the abstractions of the concrete classes,
    `frozenset` and `set`.'
  id: totrans-1215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows us to build new classes or extend existing classes and maintain
    a clear and formal integration with the rest of Python's built-in features.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at containers and collections in detail in [Chapter 6](ch06.html
    "Chapter 6. Creating Containers and Collections"), *Creating Containers and Collections*.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  id: totrans-1218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating new numbers (or extending existing numbers), we'll turn to the
    `numbers` module. This module contains the abstract definitions of Python's built-in
    numeric types. These types form a tall, narrow hierarchy, from the simplest to
    the most elaborate. In this case, simplicity (and elaboration) refers to the collection
    of methods available.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an abstract base class named `numbers.Number` that defines all of
    the numeric and number-like classes. We can see that this is true with interactions
    like the following one:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Clearly, integer and float values are subclasses of the abstract `numbers.Number`
    class.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: The subclasses include `numbers.Complex`, `numbers.Real`, `numbers.Rational`,
    and `numbers.Integral`. These definitions are roughly parallel mathematical thoughts
    on the various classes of numbers.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: 'The `decimal.Decimal` class, however, doesn''t fit this hierarchy extremely
    well. We can check the relationships using the `issubclass()` method as follows:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: It shouldn't be too surprising that `Decimal` doesn't fit the established number
    types well. For a concrete implementation of `numbers.Rational`, look at the `fractions`
    module. We'll look at the various kinds of numbers in detail in [Chapter 7](ch07.html
    "Chapter 7. Creating Numbers"), *Creating Numbers*.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: Some additional abstractions
  id: totrans-1227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at some other interesting ABC classes that are less widely extended.
    It's not that these abstractions are less widely used. It's more that the concrete
    implementations rarely need extensions or revisions.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at the iterator, which is defined by `collections.abc.Iterator`.
    We'll also look at the unrelated idea of a context manager. This isn't defined
    with the same formality as other ABC classes. We'll look at this in detail in
    [Chapter 5,](ch05.html "Chapter 5. Using Callables and Contexts") *Using Callables
    and Contexts*.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: The iterator abstraction
  id: totrans-1230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Iterators are created implicitly when we use an iterable container with a `for`
    statement. We rarely care about the iterator itself. And the few times we do care
    about the iterator, we rarely want to extend or revise the class definition.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: 'We can expose the implicit iterators that Python uses via the `iter()` function.
    We can interact with an iterator in the following way:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: We created an iterator over a list object and then stepped through the values
    in that iterator using the `next()` function.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: The final `isinstance()` expression confirmed that this iterator object is an
    instance of `collections.abc.Iterator`.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, we'll work with iterators that have been created by the collection
    classes themselves. However, when we branch out and build our own collection classes
    or extend a collection class, we may also need to build a unique iterator. We'll
    look at iterators in [Chapter 6](ch06.html "Chapter 6. Creating Containers and
    Collections"), *Creating Containers and Collections*.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: Contexts and context managers
  id: totrans-1237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A context manager is used with the `with` statement. We''re working with a
    context manager when we write something like the following:'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: In the preceding case, `function(arg)` creates the context manager.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: 'One very commonly used context manager is a file. When we open a file, we should
    define a context that will also automatically close the file. Consequently, we
    should almost always use a file in the following way:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: At the end of the `with` statement, we're assured that the file will be closed
    properly. The `contextlib` module provides several tools for building proper context
    managers. Rather than providing an abstract base class, this library offers decorators,
    which will transform simple functions into context managers, as well as a `contextlib.ContextDecorator`
    base class, which can be used extended to build a class that is a context manager.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at context managers in [Chapter 5](ch05.html "Chapter 5. Using Callables
    and Contexts"), *Using Callables and Contexts*.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: The abc module
  id: totrans-1245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core method of creating ABCs is defined in the `abc` module. This module
    includes the `ABCMeta` class that provides several features.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: First, the `ABCMeta` class assures that abstract classes can't be instantiated.
    A subclass that provides all of the required definitions, however, can be instantiated.
    The metaclass will invoke the abstract class's special method, `__subclasshook__()`,
    as a part of processing `__new__()`. If that method returns `NotImplemented`,
    then an exception will be raised to show that the class didn't define all the
    required methods.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: Second, it provides definitions for `__instancecheck__()` and `__subclasscheck__()`.
    These special methods implement the `isinstance()` and `issubclass()` built-in
    functions. They provide the checks to confirm that an object (or a class) belongs
    to the proper ABC. This includes a cache of subclasses to speed up the testing.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: The `abc` module also includes a number of decorators for creating abstract
    method functions that must be provided by a concrete implementation of the abstract
    base class. The most important of these is the `@abstractmethod` decorator.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to create a new abstract base class, we would use something like
    the following:'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: This class includes `ABCMeta` as its metaclass; it also uses the `__subclasshook__()`
    method, which checks for completeness. These provide the core features of an abstract
    class.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: This abstraction uses the `abstractmethod` decorator to define three abstract
    methods. Any concrete subclass must define these in order to be a complete implementation
    of the abstract base class.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: The `__subclasshook__` method requires that all of the three abstract methods
    be provided by a subclass. This is, perhaps, heavy-handed, since a super-simple
    betting strategy shouldn't have to provide methods for counting wins and losses.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: 'The subclass hook relies on two internal features of a Python class definition:
    the `__dict__` attribute and the `__mro__` attribute. The `__dict__` attribute
    is where the method names and attribute names are recorded for a class definition.
    This is essentially the body of the class. The `__mro__` attribute is the method
    resolution order. This is the sequence of the superclasses of this class. Since
    Python uses multiple inheritance, there can be many superclasses, and the order
    of these superclasses determines the precedence for resolving names.'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a concrete class:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: The preceding code can't be built because it doesn't provide necessary implementations
    for all three methods.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what happens when we try to build it:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-1260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'The error message indicates that the concrete class is incomplete. The following
    is a better concrete class that passes the completeness test:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: We can build an instance of this class and use it as part of our simulation.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: As we noted earlier, the `bet()` method should probably be the only *required*
    method. The other two methods should be allowed to default to the single statement
    `pass`.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: Summary, design considerations, and trade-offs
  id: totrans-1265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we looked at the essential ingredients of abstract base classes.
    We saw a few features of each kind of abstraction.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that one rule for good class design is to inherit as much as
    possible. We saw two broad patterns here. We also saw common exceptions to this
    rule.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: Some application classes don't have behaviors that overlap with internal features
    of Python. From our Blackjack examples, a `Card` isn't much like a number, a container,
    an iterator, or a context. It's just a playing card. In this case, we can generally
    invent a new class because there isn't any built-in features to inherit fro.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at `Hand`, however, we see that a hand is clearly a container.
    As we noted when looking at hand classes in [Chapters 1](ch01.html "Chapter 1. The
    __init__() Method"), *The __init__() Method*, and [Chapter 2](ch02.html "Chapter 2. Integrating
    Seamlessly with Python Basic Special Methods"), *Integrating Seamlessly with Python
    – Basic Special Methods*, the following are three fundamental design strategies:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping an existing container
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending an existing container
  id: totrans-1271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventing a wholly new kind of container
  id: totrans-1272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time, we'll be wrapping or extending an existing container. This
    fits with our rule of inheriting as much as possible.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: When we extend an existing class, our application class will fit into the class
    hierarchy neatly. An extension to the built-in `list` is already an instance of
    `collections.abc.MutableSequence`.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: When we wrap an existing class, however, we have to consider carefully what
    parts of the original interface we want to support and what parts we don't want
    to support. In our examples in the previous chapters, we only wanted to expose
    the `pop()` method from the list object we were wrapping.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: Because a wrapper class is not a complete mutable sequence implementation, there
    are many things it can't do. On the other hand, an extension class participates
    in a number of use cases that just might turn out to be useful. For example, a
    hand that extends `list` will turn out to be iterable.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: If we find that extending a class doesn't meet our requirements, we can resort
    to building an entirely new collection. The ABC definitions provide a great deal
    of guidance on what methods are required in order to create a collection that
    can integrate seamlessly with the rest of the Python universe. We'll look at a
    detailed example of inventing a collection in [Chapter 6](ch06.html "Chapter 6. Creating
    Containers and Collections"), *Creating Containers and Collections*.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  id: totrans-1278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the coming chapters, we'll make extensive use of these abstract base classes
    discussed in this chapter. In [Chapter 5](ch05.html "Chapter 5. Using Callables
    and Contexts"), *Using Callables and Contexts*, we'll look at the relatively simple
    features of callables and containers. In [Chapter 6](ch06.html "Chapter 6. Creating
    Containers and Collections"), *Creating Containers and Collections*, we'll look
    at the available containers and collections. We'll also look at building a unique,
    new kind of container in this chapter. Lastly, in [Chapter 7](ch07.html "Chapter 7. Creating
    Numbers"), *Creating Numbers*, we'll look at various numeric types and how we
    can create our own kind of number.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. Using Callables and Contexts
  id: totrans-1280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can exploit the `collections.abc.Callable` ABC and employ a technique called
    **memoization** to create objects that behave like functions but perform very
    quickly because they are able to cache previous results. In some cases, memoization
    is essential for creating an algorithm that finishes within a reasonable amount
    of time.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: The **context** concept allows us to create elegant, reliable resource management.
    The `with` statement defines a context and creates a context manager to control
    the resources used in that context. Python files are generally context managers;
    when used in a `with` statement, they are properly closed.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at several ways to create context managers using the tools in the
    `contextlib` module.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.2, the abstract base classes were in the `collections` module.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.3, the abstract base classes are in a separate submodule called
    `collections.abc`. In this chapter, we'll focus on Python Version 3.3\. The basic
    definitions will also be true for Python 3.2, but the `import` statement will
    change.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: We'll show a number of variant designs for callable objects. This will show
    us why a stateful callable object is sometimes more useful than a simple function.
    We'll also look at how to use some of the existing Python context managers before
    we dive in and write our own context manager.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: Designing with ABC callables
  id: totrans-1287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two easy ways to create callable objects in Python, as follows:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: Using the `def` statement to create a function
  id: totrans-1289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By creating an instance of a class that uses `collections.abc.Callable` as its
    base class
  id: totrans-1290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also assign a **lambda** form to a variable. A lambda is a small, anonymous
    function that consists of exactly one expression. We''d rather not emphasize saving
    lambdas in a variable as it leads to the confusing situation where we have a function-like
    callable that''s not defined with a `def` statement. The following is a simple
    callable object that has been created from a class:'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'There are three parts to the preceding callable object, as follows:'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: We defined the class as a subclass of `abc.Callable`
  id: totrans-1294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined the `__call__()` method
  id: totrans-1295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created an instance of the class, `pow1()`
  id: totrans-1296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, the algorithm seems inefficient. We'll address that.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this is so simple that a full class definition isn't really necessary.
    In order to show the various optimizations, it's slightly simpler to start with
    a callable object rather than mutate a function into a callable object.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the `pow1()` function just as we''d use any other function.
    Here''s how to use the `pow1()` function in a Python command line:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: We've evaluated the callable object with various kinds of argument values. It's
    not *required* to make a callable object a subclass of `abc.Callable`. However,
    it does help with debugging.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this flawed definition:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: The preceding class definition has an error and doesn't meet the definition
    of the callable abstraction.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: Found the error yet? If not, it's at the end of the chapter.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what happens when we try to create an instance of this class:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: It may not be obvious exactly what went wrong, but we have a fighting chance
    to debug this. If we hadn't subclassed `collections.abc.Callable`, we'd have a
    somewhat more mysterious problem to debug.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: Here's what the more mysterious problem would look like. We'll skip the actual
    code for `Power3`. It's the same as `Power2`, except it doesn't subclass `collections.abc.Callable`.
    It starts `class Power3`; otherwise, it's identical.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what happens when we try to use `Power3` as a class that doesn''t
    meet the expectations of callables and isn''t a subclass of the `abc.Callable`
    either:'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-1311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: This error provides less guidance as to why the `Power3` class definition is
    flawed. The `Power2` error is much more explicit about the nature of the problem.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance
  id: totrans-1313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at two performance tweaks for the `Power3` class.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: First, a better algorithm. Then, a better algorithm combined with memoization,
    which involves a cache; therefore, the function becomes stateful. This is where
    callable objects shine.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: The first modification is to use a **Divide and Conquer** design strategy. The
    previous version chopped ![Improving performance](graphics/0971OS_05_01.jpg) into
    *n* steps; the loop carried out *n* individual multiplication operations. If we
    can find a way to split the problem into two equal portions, the problem decomposes
    into ![Improving performance](graphics/0971OS_05_02.jpg) steps. Given `pow1(2,1024)`,
    the `Power1` callable performs the calculation 1024 multiplications by 2\. We
    can optimize this down to 10 multiplications, a significant speedup.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than simply multiplying by a fixed value, we''ll use the "fast exponentiation"
    algorithm. It uses three essential rules for computing ![Improving performance](graphics/0971OS_05_01.jpg),
    as follows:'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: If ![Improving performance](graphics/0971OS_05_03.jpg):![Improving performance](graphics/0971OS_05_04.jpg),
    the result is simply 1.
  id: totrans-1318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *n* is odd and ![Improving performance](graphics/0971OS_05_05.jpg), the result
    is ![Improving performance](graphics/0971OS_05_06.jpg). This involves a recursive
    computation of ![Improving performance](graphics/0971OS_05_07.jpg). This still
    does a multiplication but not a real optimization.
  id: totrans-1319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *n* is even and ![Improving performance](graphics/0971OS_05_08.jpg), the
    result is ![Improving performance](graphics/0971OS_05_09.jpg). This involves a
    recursive computation of ![Improving performance](graphics/0971OS_05_10.jpg).
    This chops the number of multiplications in half.
  id: totrans-1320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the recursive callable object:'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-1322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: We applied the three rules to the input value. If *n* is zero, we'll return
    1\. If *n* is odd, we'll make a recursive call and return ![Improving performance](graphics/0971OS_05_06.jpg).
    If *n* is even, we'll make a recursive call and return ![Improving performance](graphics/0971OS_05_09.jpg).
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: The execution time is dramatically faster. We can use the `timeit` module to
    see the difference in performance. See *Some Preliminaries*, for information on
    using `timeit`. When we compare running `pow1(2,1024)` and `pow4(2,1024)` 10,000
    times, we'll see something like 183 seconds for the previous version versus 8
    seconds for this version. We can do better, however, with memoization.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how we can gather performance data using `timeit`:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: We imported the `timeit` module. The `timeit.timeit()` function will evaluate
    a given statement in the defined context. In this case, our expression is the
    simple `pow1(2,1024)` expression. The context for this statement is the definition
    of the `pow1()` function; it includes the import, class definition, and creation
    of the instance.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: Note that we provided `number=100000` to speed things up. If we had used the
    default value for the number of iterations, it could have taken almost 2 minutes.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: Using memoization or caching
  id: totrans-1329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea behind memoization is to cache previous results to avoid recomputing
    them. We'll use considerably more memory, but we can also dramatically speed up
    performance by avoiding computation.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: An ordinary function doesn't have a place to cache previous results. A function
    is not expected to be stateful. A callable object, however, can be stateful. It
    can include a cache of previous results.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a memoized version of our `Power` callable object:'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-1333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: We revised our algorithm to work with the `self.memo` cache.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: If the value of![Using memoization or caching](graphics/0971OS_05_01.jpg)has
    been requested previously, that result is returned and no computation is performed.
    This is the big speedup that we spoke of earlier.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the value of ![Using memoization or caching](graphics/0971OS_05_01.jpg)
    must be computed and saved in the memoization cache. The three rules to compute
    the fast exponent are used to get and put values in the cache. This assures us
    that future calculations will be able to exploit the cached values.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: The importance of memoization can't be stressed enough. The reduction in computation
    can be dramatic. It is commonly done by replacing a slow, expensive function with
    a callable object.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: Using functools for memoization
  id: totrans-1338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python library includes a memoization decorator in the `functools` module.
    We can use this module instead of creating our own callable object.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it as follows:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: This defined a function, `pow6()`, which is decorated with a **Least Recently
    Used** (**LRU**) cache. Previous requests are stored in a memoization cache. The
    requests are tracked in the cache, and the size is limited. The idea behind an
    LRU cache is that the most recently made requests are kept and the least recently
    made requests are quietly purged.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: Using `timeit`, we can see that 10,000 iterations of `pow5()` run in about 1
    second, while the iterations for `pow6()` run in about 8 seconds.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: What this also shows is that a trivial use of `timeit` can misstate the performance
    of the memoization algorithms. The requests of the `timeit` module should be made
    more sophisticated to reflect more realistic use cases, to properly mix cache
    hits and cache misses. Simple random numbers aren't always appropriate for all
    problem domains.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: Aiming for simplicity using the callable API
  id: totrans-1345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea behind a callable object is that we have an API that's focused on a
    single method.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: Some objects have multiple relevant methods. A Blackjack `Hand`, for example,
    has to add cards and produce a total. A blackjack `Player` has to place bets,
    accept hands, and make play decisions (for example, hit, stand, split, insure,
    double down, and so on). These are more complex interfaces that are not suitable
    to be callables.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: The betting strategy, however, is a candidate for being a callable.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: The betting strategy can either be implemented as several methods (some setters
    and a getter method) or it can be a callable interface with a few public attributes.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the straight betting strategy. It is always the same:'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'The idea of this API is that a `Player` object will inform the betting strategy
    of win amounts and loss amounts. The `Player` object might have methods such as
    the following to inform the betting strategy about the outcome:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'These methods inform a betting strategy object (the `self.bet` object) whether
    the hand was a win or a loss. When it''s time to place a bet, the `Player` will
    perform something like the following operation to get the current betting level:'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: This is a pleasantly short API. After all, the betting strategy doesn't do much
    other than encapsulate a few, relatively simple rules.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: The shortness of this interface is one of the elegant features of a callable
    object. We don't have many method names, and we don't have a complex set of syntaxes
    for a simple thing.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: Complexities and the callable API
  id: totrans-1358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how well this API holds up as our processing becomes more complex.
    The following is the double-up on each loss strategy (also known as the **Martingale**
    betting system):'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-1360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Each loss doubles the betting by multiplying the stage by two. This goes on
    until we win and recoup our losses, reach the table limit, or go broke and can
    no longer place any bets. Casinos prevent this by imposing table limits.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we win, the betting is reset to the base bet. The stage is reset to
    have a value of one.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep the attribute interface—code such as `bet.win += 1`—we need
    to create properties to make the state changes correctly based on the wins and
    losses. We only really care about the setter properties, but we must define getter
    properties in order to clearly create setter properties.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this class in action as follows:'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: The API is still quite simple. We can either count the wins and reset the bet
    to the base, or we can count the losses, and the bets will double.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of properties made the class definition long and hideous. We''re really
    only interested in the setters and not the getters, so we can use `__setattr__()`
    to streamline the class definition somewhat, as shown in the following code:'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: We used `__setattr__()` to monitor the updates to `win` and `loss`. In addition
    to setting the instance variables using `super().__setattr__()`, we also updated
    the internal state for the betting amount.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: This is a nicer looking class definition, and it retains the simple API as a
    callable object with two attributes.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: Managing contexts and the with statement
  id: totrans-1371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contexts and context managers are used in several places in Python. We'll look
    at a few examples to establish the basic terminology.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: A context is defined by the `with` statement. The following program is a small
    example that parses a logfile to create a useful CSV summary of that log. Since
    there are two open files, we expect to see nested `with` contexts. The example
    uses a complex regular expression, `format_1_pat`. We'll define this shortly.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: 'We might see something like the following in an application program:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Two contexts with two context managers were emphasized in this example.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: The outermost context starts with `with open("subset.csv", "w") as target`.
    The built-in `open()` function opens a file that is also a context manager and
    assigns it to the `target` variable for further use.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: The inner context starts with `with gzip.open(path, "r") as source`. This `gzip.open()`
    function behaves much like the `open()` function in that it opens a file that
    is also a context manager.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: When the `with` statements end, the contexts exit and the files are properly
    closed. Even if there's an exception in the body of the `with` context, the context
    manager's exit will be processed correctly and the file will be closed.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-1380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Always use a with around a file()**'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: Since files involve OS resources, it's important to be sure that the entanglements
    between our applications and the OS are released as soon as they're no longer
    needed. The `with` statement ensures that resources are used properly.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to complete the example, the following is the regular expression used
    to parse Apache HTTP server logfiles in **Common Log Format**:'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-1384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: The preceding expression located the various log format fields used in the previous
    example.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: Using the decimal context
  id: totrans-1386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another context that is used frequently is the decimal context. This context
    defines a number of properties of `decimal.Decimal` calculation, including the
    quantization rules used to round or truncate values.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: 'We might see application programming that looks like the following:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: The preceding example shows the default context as well as a local context.
    The default context has the default rounding rule. The localized context, however,
    shows how we can assure consistent operations by setting the decimal rounding
    for a particular calculation.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: The `with` statement is used to assure that the original context is restored
    after the localized change. Outside this context, the default rounding applies.
    Inside this context, a specific rounding applies.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: Other contexts
  id: totrans-1392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few other common contexts. Almost all of them are associated with
    basic input/output operations. Most modules that open a file create a context
    along with the file-like object.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: Contexts are also associated with locking and database transactions. We may
    acquire and release an external lock, like a semaphore, or we may want a database
    transaction to properly commit when it's successful or roll back when it fails.
    These are all the things that have defined contexts in Python.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: The PEP 343 document provides a number of other examples of how the `with` statement
    and context managers might be used. There are other places where we might like
    to use a context manager.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: We may need to create classes that are simply context managers, or we may need
    to create classes that can have multiple purposes, one of which is to be a context
    manager. The `file()` object is similar. We'll look at a number of design strategies
    for contexts.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: We'll return to this again in [Chapter 8](ch08.html "Chapter 8. Decorators and
    Mixins – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*,
    where we can cover a few more ways to create classes that have context manager
    features.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: Defining the __enter__() and __exit__() methods
  id: totrans-1398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The defining feature of a context manager is that it has two special methods:
    `__enter__()` and `__exit__()`. These are used by the `with` statement to enter
    and exit the context. We''ll use a simple context so that we can see how they
    work.'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: We'll often use context managers to make transient global changes. This might
    be a change to the database transaction status or a change to the locking status,
    something that we want to do and then undo when the transaction is complete.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we'll make a global change to the random number generator.
    We'll create a context in which the random number generator uses a fixed and known
    seed, providing a fixed sequence of values.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the context manager class definition:'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-1403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: We defined the required `__enter__()` and _`_exit__()` methods. The `__enter__()`
    method will save the previous state of the random module and then reset the seed
    to a given value. The `__exit__()` method will restore the original state of the
    random number generator.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: Note that `__enter__()` returns `self`. This is common for **mixin** context
    managers that have been added into other class definitions. We'll look at the
    concept of a mixin in [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins
    – Cross-cutting Aspects"), *Decorators And Mixins – Cross-cutting Aspects*.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: The `__exit__()` method's parameters will have the value of `None` under normal
    circumstances. Unless we have specific exception-handling needs, we generally
    ignore the argument values. We'll look at exception-handling in the following
    code.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using the context:'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Each time we create an instance of `KnownSequence`, we're modifying the way
    the `random` module works. During the context of the `with` statement, we'll get
    a fixed sequence of values. Outside the context, the random seed is restored,
    and we get random values.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will look like the following (in most cases):'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Some of this output is machine-dependent. While the exact values may vary, the
    second and fourth lines will match because the seed was fixed by the context.
    The other lines will not necessarily match because they rely on the `random` module's
    own randomization features.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  id: totrans-1413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exceptions that arise in a block will be passed to the `__exit__()` method of
    the context manager. The standard bits of an exception—the class, arguments, and
    the traceback stack—will all be provided as argument values.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__exit__()` method can do one of the following two things with the exception
    information:'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: Silence the exception by returning some `True` value.
  id: totrans-1416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the exception to rise normally by returning any other `False` value. Returning
    nothing is the same as returning `None`, which is a `False` value; this allows
    the exception to propagate.
  id: totrans-1417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exception might also be used to alter what the context manager does on exit.
    We might, for example, have to do special processing for certain types of OS errors
    that might arise.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: Context manager as a factory
  id: totrans-1419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create a context manager class, which is a factory for an application
    object. This gives us a pleasant separation of design considerations without cluttering
    up an application class with context management features.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we want a deterministic `Deck` for dealing in blackjack. This isn't
    as useful as it might sound. For unit testing, we'll need a completely mock deck
    with specific sequences of cards. This has the advantage that the context manager
    works with the classes we already saw.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: We'll extend the simple context manager shown earlier to create a `Deck` that
    can be used within the `with` statement context.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a class that is a factory for `Deck` and also tweaks the `random`
    module:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: The preceding context manager class preserves the argument values so that it
    can create a `Deck` with the given arguments.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: The `__enter__()` method preserves the old random number state and then sets
    the `random` module in a mode that provides a fixed sequence of values. This is
    used to build and shuffle the deck.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `__enter__()` method returns a newly minted `Deck` object to be
    used in the `with` statement context. This is assigned via the `as` clause in
    the `with` statement.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: We could have provided similar functionality in another way. We could create
    an instance of `random.Random(x=seed)` within the `Deck` class. While that also
    works well, it tends to clutter the `Deck` class with code that's only used for
    demonstrations.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a way to use this factory context manager:'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-1430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: The preceding example of code guarantees a specific sequence of cards that we
    can use for demonstration purposes.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up in a context manager
  id: totrans-1432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we'll discuss a more complex context manager that attempts
    some cleanup when there are problems.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: 'This addresses the common issue where we want to save a backup copy of a file
    that our application is rewriting. We want to be able to do something like the
    following:'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: The intent is to have the original file renamed to `some_file copy`. If the
    context works normally—no exceptions—then the backup copy can be deleted or renamed
    to `some_file old`.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: If the context doesn't work normally—there's an exception—we want to rename
    the new file to `some_file error` and rename the old file to `some_file`, putting
    the original file back the way it was before the exception.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need a context manager like the following:'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-1439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: This context manager's `__enter__()` method will attempt to preserve a previous
    copy of the named file if it already exists. If it didn't exist, there's nothing
    to preserve.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: The `__exit__()` method be given information about any exception that occurred
    in the context. If there is no exception, it will simply return any previous file
    that exists was preserved the file created within the context will also exist.
    If there is an exception, then the `__exit__()` method will try to preserve the
    output (with a suffix of "error") for debugging purposes it will also put any
    previous version of file back in place.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: This is functionally equivalent to a `try-except-finally` block. However, it
    has the advantage that it separates the relevant application processing from the
    context management. The application processing is written in the `with` statement.
    The context issues are set aside into a separate class.
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at three of the special methods for class definition. The `__call__()`
    method is used when creating a callable. The callable is used to create functions
    that are stateful. Our primary example is a function that memoizes previous results.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: The `__enter__()` and `__exit__()` methods are used to create a context manager.
    The context is used to handle processing that is localized to the body of a with
    statement. Most of our examples include input-output processing. However, Python
    presents a number of other situations where a localized context can come handy.
    will focus on creating containers and collections.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: Callable design considerations and trade-offs
  id: totrans-1446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When designing a callable object, we need to consider the following:'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: The first is the API of the object. If there's a reason for the object to have
    a function-like interface, then a callable object is a sensible design approach.
    Using `collections.abc.Callable` assures that the callable API is built correctly,
    and it informs anyone reading the code what the intent of the class is.
  id: totrans-1448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the statefulness of the function. Ordinary functions in Python
    have no hysteresis—there's no saved state. A callable object, however, can easily
    save a state. The memoization design pattern makes good use of stateful callable
    objects.
  id: totrans-1449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only disadvantage of a callable object is the amount of syntax that is required.
    An ordinary function definition is shorter and therefore less error prone and
    easier to read.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy to migrate a defined function to a callable object, as follows:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-1452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'The preceding function can be converted into the following callable object:'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-1454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: This is the minimal set of changes required to get the function to pass unit
    tests in the new form. The existing body will work in the new context unmodified.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: Once the change has been made, features can be added to the callable object's
    version of the function.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: Context manager design considerations and trade-offs
  id: totrans-1457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A context is generally used to acquire/release, open/close, and lock/unlock
    types of operation pairs. Most of the examples are file I/O related, and most
    of the file-like objects in Python are already proper context managers.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: A context manager is almost always required for anything that has steps which
    bracket the essential processing. In particular, anything that requires a final
    `close()` method should be wrapped by a context manager.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: Some Python libraries have open/close operations, but the objects aren't proper
    contexts. The `shelve` module, for example, doesn't create a proper context.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: We can (and should) use the `contextllib.closing()` context on a `shelve` file.
    We'll show this in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving –
    JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML*.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: For our own classes that require a `close()`method, we can use the `closing()`
    function. When confronted with a class that has any kind of acquire/release life
    cycle, we want to acquire resources in `__init__()` or a class-level `open()`method
    and release them in `close()`. That way, our class can integrate well with this
    `closing()` function.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of some class being wrapped that requires a `close()`
    function:'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-1464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: The `contextllib.closing()` function will invoke the `close()` method of the
    object that is given as an argument. We can guarantee that `my_object` will have
    its `close()` method evaluated.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  id: totrans-1466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next two chapters, we'll look at the special methods used to create containers
    and numbers. In [Chapter 6](ch06.html "Chapter 6. Creating Containers and Collections"),
    *Creating Containers and Collections*, we'll look at the containers and collections
    in the standard library. We'll also look at building a unique, new kind of container.
    In [Chapter 7](ch07.html "Chapter 7. Creating Numbers"), *Creating Numbers*, we'll
    look at the various numeric types and how we can create our own kind of number.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6. Creating Containers and Collections
  id: totrans-1468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can extend a number of ABCs to create new kinds of collections. The ABCs
    provide us with design guidelines to extend the built-in containers. These allow
    us to fine-tune the features or radically define new data structures that fit
    our problem domain more precisely.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at the basics of ABC for container classes. There are a fairly large
    number of abstractions that are used to assemble the Python built-in types, such
    as `list`, `tuple`, `dict`, `set`, and `frozenset`.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: We'll review the variety of special methods that are involved in being a container
    and offering the various features of containers. We'll split these into the core
    container methods, separate from more specialized sequence, map, and set methods.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: We'll address extending built-in containers to add features. We'll also look
    at wrapping built-in containers and delegating methods through the wrapper to
    the underlying container.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll look at building entirely new containers. This is a challenging
    territory, because there's a huge variety of interesting and useful collection
    algorithms already present in the Python Standard Library. In order to avoid deep
    computer science research, we'll build a pretty lame collection. Before starting
    on a real application, a careful study of *Introduction to Algorithms* by Cormen,
    Leiserson, Rivest, and Stein is essential.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: We'll finish by summarizing some of the design considerations that go into extending
    or creating new collections.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: ABCs of collections
  id: totrans-1475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `collections.abc` module provides a wealth of abstract base classes that
    decompose collections into a number of discrete feature sets.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: We can successfully use the `list` class without thinking too deeply about the
    various features and how they relate to the `set` class or the `dict` class. Once
    we start looking at the ABCs, however, we can see that there's a bit of subtlety
    to these classes. By decomposing the aspects of each collection, we can see areas
    of overlapping that manifest themselves as an elegant polymorphism even among
    different data structures.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the base classes are some "one-trick pony" definitions. These
    are the base classes that require a single special method:'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: The `Container` base class requires the concrete class to implement the `__contains__()`
    method. This special method implements the `in` operator.
  id: totrans-1479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Iterable` base class requires `__iter__()`. This special method is used
    by the `for` statement and the generator expressions as well as the `iter()` function.
  id: totrans-1480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Sized` base class requires `__len__()`. This method is used by the `len()`
    function. It's also prudent to implement `__bool__()`, but it's not required by
    this abstract base class.
  id: totrans-1481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Hashable` base class requires `__hash__()`. This is used by the `hash()`
    function. If this is implemented, it means that the object is immutable.
  id: totrans-1482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these abstract classes is used to build the higher-level, composite
    definitions of structures we can use in our applications. These composite constructs
    include the lower-level base classes of `Sized`, `Iterable`, and `Container`.
    Here are some composite base classes that we might use in an application:'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: The `Sequence` and `MutableSequence` classes build on the basics and fold in
    methods such as `index()`, `count()`, `reverse()`, `extend()`, and `remove()`.
  id: totrans-1484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Mapping` and `MutableMapping` classes fold in methods such as `keys()`,
    `items()`, `values()`, and `get()`, among others.
  id: totrans-1485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Set` and `MutableSet` classes fold in comparison and arithmetic operators
    to perform set operations.
  id: totrans-1486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we look more deeply into the built-in collections, we can see how the ABC
    class definitions serve to organize the special methods that we need to write
    or modify.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: Examples of special methods
  id: totrans-1488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When looking at a blackjack `Hand` object, we have an interesting special case
    for containment. We often want to know if there''s an ace in the hand. If we define
    `Hand` as an extension to `list`, then we can''t ask for a generic ace. We can
    only ask for specific cards. We hate to write something like this:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: That seems a long-winded way to look for an ace in a hand.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a better example, but it still is less-than-ideal, perhaps:'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'So, we''d like something like this:'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'This means that we''re modifying the meaning of "contains" for a `Hand` object
    that extends `list`. We''re not looking for a `Card` instance, we''re merely looking
    for the rank property of a `Card` object. We can override the `__contains__()`
    method to do this:'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-1497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: This allows us to use a simpler `in` test for a given rank in a hand.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: Similar design considerations can be applied to `__iter__()` and `__len__()`
    special methods. Be cautious, however. Changing the semantics of `len()` or how
    a collection interacts with the `for` statement might be disastrous.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: Using the standard library extensions
  id: totrans-1500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at some extensions to built-in classes that are already part of the
    standard library. These are the collections that extend or modify the built-in
    collections. Most of these are covered in one form or another in books such as
    *Python 3 Object Oriented Programming*.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at the following six library collections:'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: The `namedtuple()` function creates subclasses of tuple subclasses with named
    attributes. We can use this instead of defining a complete class, which merely
    assigns names to the attribute values.
  id: totrans-1503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deque` (note the atypical spelling) is a double-ended queue, a list-like collection
    that can perform fast appends and pops on either end. A subset of the features
    of this class will create single-ended stacks or queues.'
  id: totrans-1504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, we can use `ChainMap` instead of merging mappings together. This
    is a view of multiple mappings.
  id: totrans-1505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OrderedDict` collection is a mapping in which the original key entry order
    is maintained.
  id: totrans-1506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultdict` (note the atypical spelling) is a `dict` subclass that uses a
    factory function to provide values for missing keys.'
  id: totrans-1507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Counter` is a `dict` subclass that can be used for counting objects to
    create frequency tables. However, it's actually a more sophisticated data structure
    called a **multiset** or **bag**.
  id: totrans-1508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll see examples of each one of the preceding collections. There are two
    important lessons to be learned from studying the library collections:'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: What's already present and doesn't need to be reinvented
  id: totrans-1510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extend the ABCs to add interesting and useful structures to the language
  id: totrans-1511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, it''s important to read the source for the libraries. The source will
    show us numerous Python object-oriented programming techniques. Beyond these basics
    are even more modules. They are as follows:'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: The `heapq` module is a set of functions that impose a heap queue structure
    on an existing `list` object. The heap queue invariant is the set of those items
    in the heap that are maintained in order to allow rapid retrieval in an ascending
    order. If we use the `heapq` methods on a `list` structure, we will never have
    to explicitly sort the list. This can have significant performance improvements.
  id: totrans-1513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` module is a kind of sequence that optimizes storage for certain
    kinds of values. This provides list-like features over potentially large collections
    of simple values.
  id: totrans-1514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, of course, there's the deeper computer science that supports these
    various data structure definitions.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: The namedtuple() function
  id: totrans-1516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `namedtuple()` function creates a new class definition from the supplied
    arguments. This will have a class name, field names, and a pair of optional keywords
    that define the behavior of the created class.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: Using `namedtuple()` will condense a class definition into a very short definition
    of a simple immutable object. It saves us from having to write longer and more
    complex class definitions for the common case where we want to name a fixed set
    of attributes.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: 'For something like a playing card, we might want to insert the following code
    in a class definition:'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-1520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'We defined a new class and provided precisely four named attributes: `rank`,
    `suit`, `hard`, and `soft`. Since each of these objects is immutable, we don''t
    need to worry about a badly behaved application attempting to change the rank
    of a `BlackjackCard` instance.'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a factory function to create instances of this class, as shown in
    the following code:'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'This will build an instance of `BlackjackCard` with the hard and soft totals
    set properly for various card ranks. A new class called `namedtuple` is created
    by filling in a template for a subclass of `tuple` with the various parameters.
    Essentially, the template starts out with this kind of code:'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-1525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: The template code extends the built-in `tuple` class. Nothing surprising there.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: 'It sets `__slots__` to an empty tuple. There are two ways to manage instance
    variables: `__slots__` and `__dict__`. By setting `__slots__`, the `__dict__`
    alternative is disabled, removing the ability to add new instance variables to
    an object of this class. Also, the resulting object is kept to the absolute minimum
    size.'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: The template creates a class-level variable named `_fields`, which names the
    fields. The `{field_names!r}` construct is where the template text is filled with
    the list of field names.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: The template defines a `__new__()` method that is used to initialize the immutable
    object. The `{arg_list}` construct is where the template is filled with the list
    of arguments used to build each instance.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: There are several other method functions, but this provides some hints as to
    how the `namedtuple` function works under the hood.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: We can, of course, subclass a `namedtuple` class to add features. We have to
    be cautious about trying to add attributes to a `namedtuple` class, though. The
    list of attributes is encoded in `_fields`, as well as the arguments to `__new__()`.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of subclassing a `namedtuple` class:'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-1533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: We used `__slots__` to ensure that the subclass has no `__dict__`; we can't
    add any new attributes. We've overridden `__new__()` so that we can construct
    instances with only two values (`rank` and `suit`), yet populate all four values.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: The deque class
  id: totrans-1535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `list` object is designed to provide uniform performance for any element within
    the container. Some operations have performance penalties. Most notably, any operation
    at the front of the list (`list.insert(0, item)` or `list.pop(0)`) will incur
    some overheads because the list size is changed and the position of each element
    has changed.
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: A `deque`—a double-ended queue—is designed to provide uniform performance for
    the first and last elements of a list. The idea is that appending and popping
    will be faster than the built-in `list` object.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-1538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Spelling irregularity**'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: Class names are usually in title case. However, the `deque` class isn't.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: Our design for a deck of cards avoids the potential performance pitfall of a
    `list` object by always popping from the end, never from the beginning.
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: However, as we're using so few features of a `list` object, perhaps a structure
    like that of a deque is a better fit for our problem. We're only storing cards
    so that they can be shuffled and popped from the collection. Other than shuffling,
    our applications never reference elements within the list by their indexed positions.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: While the `deque.pop()` method might be very fast, shuffling may suffer. A shuffle
    will make random access to the container, something for which a deque is not designed.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to confirm the potential costs, we can use `timeit` to compare `list`
    and `deque` shuffling performance as follows:'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: We invoked `timeit` using `random.shuffle()`. One works on a `list` object,
    the other works on a deque.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: These results indicate that shuffling a deque is only a trifle slower than shuffling
    a `list` object—about 2 percent slower. This distinction is a hair not worth splitting.
    We can confidently try a `deque` object in place of `list`.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: 'The change amounts to this:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: We replaced `list` with `deque` in the definition of `Deck`. Otherwise, the
    class is identical.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the actual performance difference? Let''s create decks of 100,000 cards
    and deal them:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: We invoked `timeit` using `x.pop()`. One works on a `list`, the other works
    on a deque.
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: The dealing time is cut almost by half (42 percent, actually). We had big savings
    from a tiny change in the data structure.
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: In general, it's important to pick the optimal data structure for the application.
    Trying several variations can show us what's more efficient.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: The ChainMap use case
  id: totrans-1556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use case for chaining maps together fits nicely with Python's concept of
    local versus global definitions. When we use a variable in Python, first the local
    namespaces, and then the global namespaces are searched, in that order. In addition
    to searching both namespaces for a variable, setting a variable works in the local
    namespace without disturbing the global namespace. This default behavior (without
    the `global` or `nonlocal` statements) is also how a `ChainMap` works.
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: When our applications start running, we often have properties that come from
    command-line parameters, configuration files, OS environment variables, and possibly,
    installation-wide settings. We'd like to merge this into a single dictionary-like
    structure so that we can easily locate a setting.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have an application startup that combines several sources of configuration
    options like this:'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-1560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'The preceding code shows us the configuration from several sources, such as
    the following:'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: The command-line arguments. We saw one token argument called `playerclass`,
    but there are often many, many others.
  id: totrans-1562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the arguments, `configuration`, is the name of a configuration file with
    additional parameters. This is expected to be in the JSON format, and the file's
    contents are read.
  id: totrans-1563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, there's a `defaults.json` file with yet another place to look
    for the configuration values.
  id: totrans-1564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the preceding sources, we can build a single `ChainMap` object use case
    that allows looking for a parameter in each of the listed locations. The `ChainMap`
    instance use case will search through each mapping, in an order, looking for the
    given value. This gives us a tidy, easy-to-use source for runtime options and
    parameters.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at this again in [Chapter 13](ch13.html "Chapter 13. Configuration
    Files and Persistence"), *Configuration Files and Persistence*, as well as [Chapter
    16](ch16.html "Chapter 16. Coping With the Command Line"), *Coping with the Command
    Line*.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: The OrderedDict collection
  id: totrans-1567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `OrderedDict` collection class makes clever use of two storage structures.
    There's an underlying `dict` object type that maps keys to values. Plus, there's
    an additional doubly-linked list of keys that maintains the insertion order.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: One common use for `OrderedDict` is when processing HTML or XML files, where
    the order of objects must be retained, but objects might have cross-references
    via ID and IDREF attributes. We can optimize the connections among objects by
    using the ID as a dictionary key. We can retain the source document's ordering
    with the `OrderedDict` structure.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to digress too far into the XML parsing here. That's a subject
    for [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: Consider this short example of an XML document that has a rather complex network
    of references between several indexes. We'll imagine a simple microblog document
    with ordered entries that have IDs and indices that have IDREFs to the original
    entries.
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll break the XML into two parts:'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-1573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'There will be a section on topics and another section on indices. Here''s the
    topics'' portion of the blog:'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-1575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Each topic has a sequence of entries. Each entry has a unique ID. We're hinting
    that they might belong to **Universally Unique ID** (**UUID**), but we didn't
    produce actual examples.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s one of the indices for the blog:'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-1578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: One index presents the blog entries by the tag. We can see that each tag has
    a list of entries. Each entry has a reference to the original microblog entry.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: When we parse this XML document, we need to keep the topics in the original
    order. But, we also have to track the IDs as keys for each entry.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a technical spike that will parse the document and build an `OrderedDict`
    collection:'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-1582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: The first part, `# Parse`, will parse the XML source document, creating an `ElementTree`
    object.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: The second part, `# Gather`, will traverse the entries in the topics section
    of the XML document. Each topic is loaded into a topic's `OrderedDict` collection
    by ID. The original order is retained so that the material can be rendered in
    the correct order.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: The final part, `# Display`, shows us the entries in their original order and
    their ID.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: The defaultdict subclass
  id: totrans-1586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ordinary `dict` type throws an exception when a key is not found. A `defaultdict`
    collection class evaluates a given function and inserts the value of that function
    into the dictionary.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-1588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note the spelling irregularity**'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: Class names are usually in TitleCase. However, the `defaultdict` class isn't.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: A common use case for a `defaultdict` class is to create indices for objects.
    When several objects have a common key, we can create a list of objects that share
    this key.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a part of a technical spike that shows us how we might accumulate a
    list of outcomes indexed by the dealer''s upcard:'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-1593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Each value of `outcomes[rank]` will be a list of simulated payouts. We can average
    or total these to summarize the payouts. We can count wins versus losses or perform
    other quantitative analysis to determine a strategy for play that minimizes losses
    and maximizes wins.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we might want to use a `defaultdict` collection class to provide
    a constant value. Instead of writing `container.get(key,"N/A")`, we'd like to
    write `container[key]` and have the string constant provided the value `"N/A"`
    if the key was not found. The difficulty with doing this is that a `defaultdict`
    class is created with a zero-argument function to create the default values. We
    can't use a constant trivially.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a zero-argument `lambda` object. This works very nicely. Here''s
    an example:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-1597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'The default value is returned, and the key (in this example, `''other''`) is
    added to the dictionary. We can determine how many new values were entered by
    looking for all the keys that have a value of `"N/A"`:'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-1599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: As you see in the preceding output, we found the key that was assigned the default
    value of `"N/A"`. This is often a helpful summary of the data that is being accumulated.
    It shows us all of the keys associated with the default value.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: The counter collection
  id: totrans-1601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most common use cases for a `defaultdict` class is when accumulating
    counts of events. We might write code that looks like this:'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-1603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: We're counting the number of times each key value, `k`, appears in the sequence
    of values from `some_iterator()`.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: This use case is so common that there's a variation on the `defaultdict` theme
    that performs the same operation shown in the preceding code—it's called `Counter`.
    A `Counter` collection, however, is considerably more sophisticated than a simple
    `defaultdict` class. Consider the additional use case of determining the most
    common value, known to statisticians as the **mode**.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to restructure the values in the `defaultdict` object to find the mode.
    It''s not difficult, but it can be irksome because it''s a boilerplate code. It
    looks like this:'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-1607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: We created a second dictionary. The keys for this new `by_value` dictionary
    are the frequency values. Each key is associated with all of the original `some_iterator()`
    values that occurred with this frequency.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the following processing to locate and display the most common
    values in the order of frequency of the occurrence:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-1610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: This will create a kind of frequency histogram that shows us the list of key
    values with a given frequency and the frequency count shared by all those key
    values.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these features are already a part of the `Counter` collection. Here''s
    an example to create a frequency histogram from some source of data:'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-1613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: This example shows us how we can easily gather statistical data by providing
    any iterable item to `Counter`. It will gather frequency data on the values in
    that iterable item. In this case, we provided an iterable function named `some_iterator()`.
    We might have provided a sequence or some other collection.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: We can then display the results in the descending order of popularity. But wait!
    That's *not* all.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: The `Counter` collection is not merely a simplistic variation of the `defaultdict`
    collection. The name is misleading. A `Counter` object is actually a "multiset",
    sometimes called a "bag".
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: It's a collection that is set-like, but allows for repeats of values in the
    bag. It is not a sequence with items identified by an index or position; order
    doesn't matter. It is not a mapping with keys and values. It is like a set in
    which items stand for themselves and order doesn't matter. But it is unlike a
    set because, in this case, elements can repeat.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: As elements can repeat, the `Counter` object represents multiple occurrences
    with an integer count. Hence, it's used as a frequency table. However, it does
    more than this. As a bag is like a set, we can compare the elements of two bags
    to create a union or an intersection.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two bags:'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-1620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: We built each bag by examining a sequence of letters. For characters that occur
    more than once, there's a count that is more than one.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily compute the union of the two bags:'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-1623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: This shows us the entire suite of letters between the two strings. There were
    three instances of `o`. Not surprisingly, other letters were less popular.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: 'We can just as easily compute the difference between the bags:'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-1626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: The first expression shows us characters in `bag1` that were not in `bag2`.
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: The second expression shows us characters in `bag2` that were not in `bag1`.
    Note that the letter `o` occurred twice in `bag2` and once in `bag1`. The difference
    only removed one of the `o` characters from `bag1`.
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: Creating new kinds of collections
  id: totrans-1629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at some extensions we might make to Python's built-in container classes.
    Although, we won't show an example of extending each container. If we did, the
    book would become out of control in size.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll pick an example of extending a specific container and see how the process
    works:'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the requirements. This may include research on Wikipedia, generally
    starting here: [http://en.wikipedia.org/wiki/Data_structure](http://en.wikipedia.org/wiki/Data_structure).
    Designs of data structures can be complex because there are often complex edge
    cases.'
  id: totrans-1632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If necessary, look at the `collections.abc` module to see what methods must
    be implemented to create the new functionality.
  id: totrans-1633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create some test cases. This also requires careful study of the algorithms to
    ensure that the edge cases are properly covered.
  id: totrans-1634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code.
  id: totrans-1635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to emphasize the importance of researching the fundamentals before trying
    to invent a new kind of data structure. In addition to searching the Web for overviews
    and summaries, details will be necessary. See *Introduction to Algorithms* by
    Cormen, Leiserson, Rivest, and Stein or *Data Structures and Algorithms* by Aho,
    Ullman, and Hopcroft, or *The Algorithm Design Manual* by Steven Skiena.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw earlier, the ABCs define three broad kinds of collections: sequences,
    mappings, and sets. We have three design strategies that we can use to create
    new kinds of collections of our own:'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: '**Extend**: This is an existing sequence.'
  id: totrans-1638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wrap**: This is an existing sequence.'
  id: totrans-1639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invent**: This is a new sequence from scratch.'
  id: totrans-1640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In principle, we could give as many as nine examples—each basic flavor of collection
    with each basic design strategy. We won't beat this subject to death like that.
    We'll dig deep to create new kinds of sequences, learning how to extend and wrap
    existing sequences.
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: As there are so many extended mappings (such as `ChainMap`, `OrderedDict`, `defaultdict`,
    and `Counter`), we'll only touch lightly on creating new kinds of mappings. We'll
    also dig deep to create a new kind of ordered multiset or bag.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: Defining a new kind of sequence
  id: totrans-1643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common requirement that we have when performing statistical analysis is to
    compute basic means, modes, and standard deviations on a collection of data. Our
    blackjack simulation will produce outcomes that must be analyzed statistically
    to see if we have actually invented a better strategy.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: When we simulate a playing strategy, we should wind up with some outcome data
    that will be a sequence of numbers that show us the final result of playing a
    sequence of hands with a given strategy. The rate of play varies from about 50
    hands per hour at a crowded table to 200 hands per hour if one is alone with the
    dealer. We'll assume 200 hands as two hours of blackjack before having to take
    a biology break.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: 'We could accumulate the outcomes into a built-in `list` class. We can compute
    the mean via ![Defining a new kind of sequence](graphics/0971OS_06_01.jpg), where
    N is the number of elements in *x*:'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-1647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'Standard deviation can be computed via ![Defining a new kind of sequence](graphics/0971OS_06_02.jpg):'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-1649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: Both of these are relatively simple calculation functions that are easy to use.
    As things get more complex, however, loose functions like these become less helpful.
    One of the benefits of object-oriented programming is to bind the functionality
    with the data.
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: Our first example will not involve rewriting any of the special methods of `list`.
    We'll simply subclass `list` to add methods that will compute the statistics.
    This is a very common kind of extension.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: We'll revisit this in the second example so that we can revise and extend the
    special methods. This will require some study of the ABC special methods to see
    what we need to add or modify so that our new list subclass properly inherits
    all the features of the built-in `list` class.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: Because we're looking at sequences, we also have to wrestle with the Python
    `slice` notation. We'll look at what a slice is and how it works internally in
    the Working with `__getitem__`, `__setitem__`, `__delitem__`, and slices section.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: The second important design strategy is wrapping. We'll create a wrapper around
    a list and see how we might delegate methods to the wrapped list. Wrapping has
    some advantages when it comes to object persistence, which is the subject of [Chapter
    9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and
    XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: We can also look at the kind of things that need to be done to invent a new
    kind of sequence from scratch.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: A statistical list
  id: totrans-1656
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It makes good sense to incorporate mean and standard deviation features directly
    into a subclass of `list`. We can extend `list` like this:'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-1658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: With this simple extension to the built-in `list` class, we can accumulate data
    and report statistics with relative ease.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: We can imagine an overall simulation script that looks like this.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  id: totrans-1661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: Choosing eager versus lazy calculation
  id: totrans-1662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that our calculations are lazy; they are only done when requested. This
    also means that they're performed each and every time they're requested. This
    can be a considerable overhead, depending on the context in which objects of these
    classes are used.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: It's actually sensible to transform these statistical summaries into eager calculations,
    as we know when elements are added and removed from a list. Although there's a
    hair more programming to create eager versions of these functions, it has a net
    impact of improving performance when there's a lot of data being accumulated.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: The point of eager statistical calculations is to avoid the loops that compute
    sums. If we compute the sums eagerly, as the list is being created, we avoid extra
    looping through the data.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the special methods for a `Sequence` class, we can see all of
    the places where data is added to, removed from, and modified in the sequence.
    We can use this information to recompute the two sums that are involved. We start
    with the `collections.abc` section of the *Python Standard Library* documentation,
    section 8.4.1 at [http://docs.python.org/3.4/library/collections.abc.html#collections-abstract-base-classes](http://docs.python.org/3.4/library/collections.abc.html#collections-abstract-base-classes).
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the required methods for a `MutableSequence` class: `__getitem__`,
    `__setitem__`, `__delitem__`, `__len__`, `insert`, `append`, `reverse`, `extend`,
    `pop`, `remove`, and `__iadd__`. The documentation also mentions the **Inherited
    Sequence methods**. However, as those are for immutable sequences, we can certainly
    ignore them.'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the details of what must be done for each method:'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: '`__getitem__`: Nothing, as there''s no change in the state.'
  id: totrans-1669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__setitem__`: This changes an item. We need to take the old item out of each
    sum and fold the new item into each sum.'
  id: totrans-1670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__delitem__`: This removes an item. We need to take the old item out of each
    sum.'
  id: totrans-1671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__len__`: Nothing here either, as there''s no change in the state.'
  id: totrans-1672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert`: As this adds a new item, we need to fold it into each sum.'
  id: totrans-1673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`append`: As this also adds a new item, we need to fold it into each sum.'
  id: totrans-1674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reverse`: Nothing here either, as there''s no change in the state of the mean
    or standard deviation.'
  id: totrans-1675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extend`: This adds many new items such as `__init__`, for which we''ll need
    to process each item before extending the list.'
  id: totrans-1676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop`: This removes an item. We need to take the old item out of each sum.'
  id: totrans-1677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove`: This also removes an item. We need to take the old item out of each
    sum.'
  id: totrans-1678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__iadd__`: This is the `+=` augmented assignment statement, the in-place addition.
    It''s effectively the same as the `extend` keyword.'
  id: totrans-1679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We won''t look at each method in detail, because there are really only two
    use cases:'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: Fold in one new value
  id: totrans-1681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove one old value
  id: totrans-1682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The replacement case is a combination of the remove and fold in operations.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the elements of an eager `StatsList` class. We''re going to see just
    `insert` and `pop`:'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  id: totrans-1685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: We provided three internal variables with quick comments to show the invariants
    that this class will maintain them. We'll call these the "sum invariants" because
    each of them contains a particular kind of sum that is maintained as invariant
    (always true) after each kind of state change. The essence of this eager calculation
    are the `_rmv()` and `_new()` methods, which update our three internal sums based
    on changes to the list, so that the relationships really remain invariant.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: When we remove an item, that is, after a successful `pop()` operation, we have
    to adjust our sums. When we add an item (either initially, or via the `insert()`
    method), we also have to adjust our sums. The other methods we need to implement
    will make use of these two methods to ensure that the three sum invariants hold.
    We assure that L.sum0 is always ![Choosing eager versus lazy calculation](graphics/0971OS_06_03.jpg),
    sum1 is always ![Choosing eager versus lazy calculation](graphics/0971OS_06_04.jpg),
    and sum2 is always ![Choosing eager versus lazy calculation](graphics/0971OS_06_05.jpg).
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: Other methods such as `append()`, `extend()`, and `remove()`, are similar in
    many ways to these methods. We didn't show them because they're similar.
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an important bit missing: individual item replacement via `list[index]=
    value`. We''ll delve into it in the following paragraph.'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how this list works by playing with some data:'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  id: totrans-1691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: We can create a list and the sums are computed initially. Each subsequent change
    eagerly updates the various sums. We can change, remove, insert, and pop an item;
    each change results in a new set of sums.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left is to add our mean and standard deviation calculations, which
    we can do as follows:'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  id: totrans-1694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: These make use of the sums already computed. There's no additional looping over
    the data to compute these two statistics.
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: Working with __getitem__(), __setitem__(), __delitem__(), and slices
  id: totrans-1696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `StatsList2` example didn't show us the implementation of `__setitem__()`
    or `__delitem__()` because they involve slices. We'll need to look at the implementation
    of a slice before we can implement these methods properly.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequences have two different kinds of indexes:'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: '`a[i]`: This is a simple Integer index.'
  id: totrans-1699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a[i:j]` or `a[i:j:k]`: These are `slice` expressions with `start:stop:step`
    values. Slice expressions can be quite complex with seven different variations
    for different kinds of defaults.'
  id: totrans-1700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This basic syntax works in three contexts:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: In an expression, relying on `__getitem__()` to get a value
  id: totrans-1702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the left-hand side of assignment, relying on `__setitem__()` to set a value
  id: totrans-1703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On a `del` statement, relying on `__delitem__()` to delete a value
  id: totrans-1704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we do something like `seq[:-1]`, we write a `slice` expression. The underlying
    `__getitem__()` method will be given a `slice` object instead of a simple integer.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: 'The reference manual tells us a few things about slices. A `slice` object will
    have three attributes: `start`, `stop`, and `step`. It will also have a method
    function called `indices()`, which will properly compute any omitted attribute
    values for a slice.'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: 'We can explore the `slice` objects with a trivial class that extends `list`:'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  id: totrans-1708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: This class will dump the `slice` object and the value of the `indices()` function
    result. Then, use the superclass implementation so that the list behaves normally
    otherwise.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this class, we can try different `slice` expressions to see what we get:'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  id: totrans-1711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: In the preceding `slice` expressions, we can see that a `slice` object has three
    attributes, and the values for those attributes come directly from the Python
    syntax. When we provide the proper length to the `indices()` function, it returns
    a three-tuple value with start, stop, and step values.
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: Implementing __getitem__(), __setitem__(), and __delitem__()
  id: totrans-1713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we implement the methods `__getitem__()`, `__setitem__()` and `__delitem__()`,
    we must work with two kinds of argument values: `int` and `slice`.'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: When we overload the various sequence methods, we must handle the slice situation
    appropriately.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a `__setitem__()` method that works with slices:'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  id: totrans-1717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'The preceding method has two processing paths:'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: If the index is a `slice` object, we'll compute the `start`, `stop`, and `step`
    values. Then, locate all the old values that will be removed. We can then invoke
    the superclass operation and fold in the new values that replaced the old values.
  id: totrans-1719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the index is a simple `int` object, the old value is a single item, and the
    new value is a single item, similarly.
  id: totrans-1720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the `__delitem__()` method that works with slices:'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: The preceding code, too, expands the slice to determine what values could be
    removed. If the index is a simple integer, then just one value is removed.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: When we introduce proper slice processing to our `StatsList2` class, we can
    create lists that do everything the base `list` class does and also (rapidly)
    returns mean and standard deviation for the values that are currently in the list.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that these method functions will each create a temporary list object, `olds`;
    this involves some overhead that can be removed. As an exercise for the reader,
    it's helpful to move the `_rmv()` functions forward in these methods to eliminate
    the use of the `olds` variable.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a list and delegating
  id: totrans-1727
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll look at how we might wrap one of Python's built-in container classes.
    Wrapping an existing class means that some methods will have to be delegated to
    the underlying container.
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: As there are a large number of methods in any of the built-in collections, wrapping
    a collection may require a fair amount of code. When it comes to creating persistent
    classes, wrapping has advantages over extending. That's the subject of [Chapter
    9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and
    XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*. In some cases,
    we'll want to expose the internal collection to save writing a large number of
    sequence methods that delegate to an internal list.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: A common restriction that applies to statistics data classes is that they need
    to be "insert only." We'll be disabling a number of method functions. This is
    the kind of dramatic change that requires a wrapper.
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: 'We can design a class that supports only `append` and `__getitem__`, for example.
    It would wrap a `list` class. The following code can be used to accumulate data
    from simulations:'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-1732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: This class has an internal `_list` object that is the underlying list. The list
    is always initially empty. As we've only defined `append()` as a way to update
    the list, we can maintain the various sums easily. We need to be careful to delegate
    the work to the superclass to be sure that the list is actually updated before
    our subclass processes the argument value.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: We can directly delegate `__getitem__()` to the internal list object without
    examining the arguments or the results.
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this class as follows:'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  id: totrans-1736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: We created an empty list and appended items to the list. As we maintain the
    sums as items are appended, we can compute the mean and standard deviation extremely
    quickly.
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: We didn't intentionally make our class iterable. We didn't define `__iter__()`.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: Because we've defined `__getitem__()`, several things now work. Not only can
    we get items, but it also turns out that there will be a default implementation
    that allows us to iterate through the sequence of values.
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  id: totrans-1741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: The preceding output shows us that a minimal wrapper around a collection is
    often enough to satisfy many use cases.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we didn''t, for example, make the list sizeable. If we attempt to
    get the size, it will raise an exception, as shown in the following:'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: We might want to add a `__len__()` method that delegates the real work to the
    internal `_list` object. We might also want to set `__hash__` to `None`, which
    would be prudent as this is a mutable object.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: We might want to define `__contains__()` and delegate this feature to the internal
    `_list` too. This will create a minimalist container that offers the low-level
    feature set of a container.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: Creating iterators with __iter__()
  id: totrans-1747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When our design involves wrapping an existing class, we'll need to be sure our
    class is iterable. When we look at the documentation for `collections.abc.Iterable`,
    we see that we only need to define `__iter__()` to make an object iterable. The
    `__iter__()` method can either return a proper `Iterator` object, or it can be
    a generator function.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: Creating an `Iterator` object, while not terribly complex, is rarely necessary.
    It's so much simpler to create generator functions. For a wrapped collection,
    we should always simply delegate the `__iter__()` method to the underlying collection.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: 'For our `StatsList3` class, it would look like this:'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  id: totrans-1751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: This method function would delegate the iteration to the underlying list's `Iterator`.
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new kind of mapping
  id: totrans-1753
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a built-in mapping called `dict`, and numerous library mappings.
    In addition to the `collections` module extensions to `dict` (`defaultdict`, `Counter`,
    `OrderedDict`, and `ChainMap`), there are several other library modules that contain
    mapping-like structures.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: The `shelve` module is an important example of another mapping. We'll look at
    this in [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via
    Shelve"), *Storing and Retrieving Objects via Shelve*. The `dbm` module is similar
    to `shelve`, in that it also maps a key to a value.
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: The `mailbox` module and `email.message` modules both have classes that provide
    an interface that is similar to `dict` for the mailbox structure used to manage
    local e-mails.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: As far as design strategies go, we can extend or wrap one of the existing mappings
    to add even more features.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: We could upgrade `Counter` to add mean and standard deviation to data stored
    as a frequency distribution. Indeed, we can also calculate median and mode very
    easily from this class.
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a `StatsCounter` extension to `Counter` that adds some statistical
    functions:'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  id: totrans-1760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: We extended the `Counter` class with two new methods to compute the mean and
    standard deviation from the frequency distributions. The formulae are similar
    to the examples shown earlier for the eager calculations on a `list` object, even
    though they're lazy calculations on a `Counter` object.
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: We used `sum0= sum( v for k,v in self.items() )` to compute a sum of the values,
    `v`, ignoring the `k` keys. We could use an underscore (`_`) instead of `k` to
    emphasize that we're ignoring the keys. We could also use `sum( v for v in self.values()
    )` to emphasize that we're not using the keys. We prefer obvious parallel structures
    for `sum0` and `sum1`.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: We can use this class to efficiently gather statistics and to perform quantitative
    analysis on the raw data. We might run a number of simulations, using a `Counter`
    object to gather the results.
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an interaction with a list of sample data that stands in for real results:'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  id: totrans-1765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: The results of `most_common()` are reported as a sequence of two-tuples with
    the mode value (4) and the number of times the value occurred (3). We might want
    to get the top three values to bracket the mode with the next two less-popular
    items. We get several popular values with an evaluation such as `sc.most_common(3)`.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: The `elements()` method reconstructs a `list` that's like the original data
    with the items repeated properly.
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: 'From the sorted elements, we can extract the median, the middle-most item:'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  id: totrans-1769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: This method is not only lazy, it's rather extravagant with memory; it creates
    an entire sequence of the available values merely to find the middle-most item.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: While it is simple, this is often an expensive way to use Python.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: A smarter approach would be to compute the effective length and mid-point via
    `sum(self.values())//2`. Once this is known, the keys can be visited in that order,
    using the counts to compute the range of positions for a given key. Eventually,
    a key will be found with a range that includes the midpoint.
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: 'The code would look something like the following:'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-1774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: We stepped through the keys and the number of times they occur to locate the
    key that is midmost. Note that this uses the internal `sorted()` function, which
    is not without its own cost.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: Via `timeit`, we can learn that the extravagant version takes 9.5 seconds; the
    smarter version takes 5.2 seconds.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new kind of set
  id: totrans-1777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a whole new collection requires some preliminary work. We need to have
    new algorithms or new internal data structures that offer significant improvements
    over the built-in collections. It's important to do thorough "Big-O" complexity
    calculations before designing a new collection. It's also important to use `timeit`
    after an implementation to be sure that the new collection really is an improvement
    on the built-in class.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: 'We might, for example, want to create a binary search tree structure that will
    keep the elements in a proper order. As we want this to be a mutable structure,
    we''ll have to perform the following kinds of design activities:'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: Design the essential binary tree structure
  id: totrans-1780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decide which structure is the basis: `MutableSequence`, `MutableMapping`, or
    `MutableSet`'
  id: totrans-1781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the special methods for the collection in the `collections.abc` section
    of the *Python Standard Library* documentation, section 8.4.1.
  id: totrans-1782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A binary search tree has nodes with two branches: a "less than" branch for
    all keys less than this node, and a "greater than or equal to" branch for keys
    greater than or equal to this node.'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to examine the fit between our collection and the Python ABCs:'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: It's not a great sequence because we don't usually use an index with a binary
    tree. We most often refer to elements in a search tree by their key. However,
    we can force an Integer index without too much difficulty.
  id: totrans-1785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could be used for the keys of a mapping; this would keep the keys in a sorted
    order. That's a common use for a binary search tree.
  id: totrans-1786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a good alternative to a `set` or a `Counter` class because it trivially
    tolerates multiple items, making it easily bag-like.
  id: totrans-1787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at creating a sorted multiset or a bag. This can contain multiple
    copies of an object. It will rely on relatively simple comparison tests among
    objects.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: This is a rather complex design. There are a great many details. To create a
    background, it's important to read articles such as [http://en.wikipedia.org/wiki/Binary_search_tree](http://en.wikipedia.org/wiki/Binary_search_tree).
    At the end of the previous Wikipedia page are a number of external links that
    will provide further information. It's essential to study the essential algorithms
    in books such as *Introduction to Algorithms* by Cormen, Leiserson, Rivest, and
    Stein or *Data Structures and Algorithms* by Aho, Ullman, and Hopcroft, or *The
    Algorithm Design Manual* by Steven Skiena.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: Some design rationale
  id: totrans-1790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''re going to split the collection into two classes: `TreeNode` and `Tree`.'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: The `TreeNode` class will contains the item as well as the `more`, `less`, and
    `parent` references. We'll also delegate some functionality to this class.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: For example, searching for a particular item in order to use `__contains__()`
    or `discard()` will be delegated to the node itself using a simple recursion.
    The algorithm's outline looks like this.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: If the target item is equal to the self item, then return `self`
  id: totrans-1794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the target item is less than `self.item`, then recursively use `less.find(target
    item)`
  id: totrans-1795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the target item is greater than `self.item`, then recursively use `more.find(target.item)`
  id: totrans-1796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use similar delegation to the TreeNode class for more of the real work
    of maintaining the tree structure.
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: The second class will be a **Facade**, which defines the `Tree` itself. A Facade
    design can also be called a **Wrapper**; the idea is to add features required
    for a particular interface. We'll provide the external interface required by a
    `MutableSet` abstract base class.
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: The algorithms can be somewhat simpler if there's a root node that's empty and
    always compares as less than all other key values. This can be challenging in
    Python because we don't know—in advance—what types of data the nodes might have;
    we can't easily define a bottom value for the root node. Instead, we'll use a
    special case value of `None`, and endure the overheads of `if` statements checking
    for the root node.
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Tree class
  id: totrans-1800
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s the core of an extension to `MutableSet` class that provides the minimal
    method functions:'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  id: totrans-1802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: The initialization is similar to that of a `Counter` object; this class will
    accept an iterable and load the elements into the structure.
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: The `add()` and `discard()` methods keep track of the overall size. That saves
    counting nodes via a recursive traversal of the tree. These methods also delegate
    their work to the `TreeNode` object at the root of the tree.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: The `__contains__()` special method performs a recursive find. It transforms
    a `KeyError` exception into a `False` return value.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: The `__iter__()` special method is a generator function. It also delegates the
    real work to recursive iterators within the `TreeNode` class.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: We defined `discard()`; mutable sets require this to be silent when attempting
    to discard the missing keys. The abstract superclass provides a default implementation
    of `remove()`, which raises an exception if a key is not found. Both method functions
    must be present; we defined `discard()` based on `remove()` by silencing the exception.
    In some cases, it might be easier to define `remove()` based on `discard()` by
    raising an exception if a problem is found.
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: Defining the TreeNode class
  id: totrans-1808
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The overall `Tree` class relies on the `TreeNode` class to handle the detailed
    work of adding, removing, and iterating through the various items in the bag.
    This class is rather large, so we'll present it in three sections.
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the first part that includes finding and iterating through the nodes:'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  id: totrans-1811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: We defined the essential initialization for a node with two variants. We can
    provide as little as just the item; we can provide as much as the item, the two
    subtrees, and the parent link.
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: The properties are used to ensure that the parent attribute is actually a `weakref`
    attribute that appears like a strong reference. For more information on weak references,
    see [Chapter 2](ch02.html "Chapter 2. Integrating Seamlessly with Python Basic
    Special Methods"), *Integrating Seamlessly with Python – Basic Special Methods*.
    We have mutual references between a `TreeNode` parent object and its children
    objects; this circularity could make it difficult to remove `TreeNode` objects.
    Using a `weakref` breaks the circularity.
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: We saw the `find()` method, which performs a recursive search from a tree through
    the appropriate subtree looking for the target item.
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: The `__iter__()` method does what's called an inorder traversal of this node
    and its subtrees. As is typical, this is a generator function that yields the
    values from iterators over each collection of subtrees. Although we could create
    a separate iterator class that's tied to our `Tree` class, there's little benefit
    when a generator function does everything we need.
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the next part of this class to add a new node to a tree:'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  id: totrans-1817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: This is the recursive search for the proper place to add a new node. The structure
    parallels the `find()` method.
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the (more complex) processing to remove a node from the tree.
    This requires some care to relink the tree around the missing node:'
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  id: totrans-1820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: The `remove()` method has two sections. The first part is the recursive search
    for the target node.
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the node is found, there are three cases to consider:'
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: When we delete a node with no children, we simply delete it and update the parent
    to replace the link with `None`.
  id: totrans-1823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we delete a node with one child, we can push the single child up to replace
    this node under the parent.
  id: totrans-1824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are two children, we need to restructure the tree. We locate the
    successor node (the least item in the `more` subtree). We can replace the to-be-removed
    node with the content of this successor. Then, we can remove the duplicative former
    successor node.
  id: totrans-1825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We rely on two private methods. The `_least()` method performs a recursive search
    for the least-valued node in a given tree. The `_replace()` method examines a
    parent to see whether it should touch the `less` or `more` attribute.
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating the binary tree set
  id: totrans-1827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We built a complete new collection. The ABC definitions included a number of
    methods automatically. These inherited methods might not be particularly efficient,
    but they're defined, they work, and we didn't write the code for them.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  id: totrans-1829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: This example shows us that the set `union` operator for set objects works properly,
    even though we didn't provide code for it specifically. As this is a bag, items
    are duplicated properly, too.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1831
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we looked at a number of built-in class definitions. The built-in
    collections are the starting place for most design work. We'll often start with
    `tuple`, `list`, `dict`, or `set`. We can leverage the extension to `tuple`, created
    by `namedtuple()`, for an application's immutable objects.
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond these classes, we have other standard library classes in the `collections`
    mode that we can use:'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: '`deque`'
  id: totrans-1834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChainMap`'
  id: totrans-1835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderedDict`'
  id: totrans-1836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultdict`'
  id: totrans-1837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Counter`'
  id: totrans-1838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have three standard design strategies, too. We can wrap any of these existing
    classes, or we can extend a class.
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can also invent an entirely new kind of collection. This requires
    defining a number of method names and special methods.
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations and Trade-offs
  id: totrans-1841
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with containers and collections, we have a multistep design strategy:'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: Consider the built-in versions of sequence, mapping, and set.
  id: totrans-1843
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider the library extensions in the collection module as well as extras such
    as `heapq`, `bisect`, and `array`.
  id: totrans-1844
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider a composition of existing class definitions. In many cases, a list
    of `tuple` objects or a `dict` of lists provides the needed features.
  id: totrans-1845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider extending one of the earlier mentioned classes to provide additional
    methods or attributes.
  id: totrans-1846
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider wrapping an existing structure as another way to provide additional
    methods or attributes.
  id: totrans-1847
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, consider a novel data structure. Generally, there is a lot of careful
    analysis available. Start with Wikipedia articles like this:'
  id: totrans-1848
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/List_of_data_structures](http://en.wikipedia.org/wiki/List_of_data_structures)'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the design alternatives have been identified, there are two parts of the
    evaluation left:'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: How well the interface fits with the problem domain. This is a relatively subjective
    determination.
  id: totrans-1851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How well the data structure performs as measured with `timeit`. This is an entirely
    objective result.
  id: totrans-1852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to avoid the paralysis of analysis. We need to *effectively*
    find the proper collection.
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, it is best to profile a working application to see which data
    structure is the performance bottleneck. In some cases, consideration of the complexity
    factors for a data structure will reveal its suitability for a particular kind
    of problem before starting the implementation.
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most important consideration is this: "For highest performance,
    avoid search".'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason sets and mappings require hashable objects. A hashable object
    can be located in a set or mapping with almost no processing. Locating an item
    by value (not by index) in a list can take a great deal of time.
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a comparison of a bad set-like use of a list and proper use of a set:'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  id: totrans-1858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: We removed and added an item from a list as well as a set.
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, abusing a list to get it to perform set-like operations makes the collection
    run 2.7 times as long.
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
- en: As a second example, we'll abuse a list to make it mapping-like. This is based
    on a real-world example where the original code had two parallel lists to mimic
    the keys and values of a mapping.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll compare a proper mapping with two parallel lists, as follows:'
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  id: totrans-1863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: We used one list to look up a value and then set the value in a second, parallel
    list. In the other case, we simply updated a mapping.
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, performing an index and update on two parallel lists is a horrifying
    mistake. It takes 8.6 times as long to locate something via `list.index()` as
    it does to locate it via a mapping and the hash value.
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  id: totrans-1866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapter, we'll closely look at the built-in numbers and how to create
    new kinds of numbers. As with containers, Python offers a rich variety of built-in
    numbers. When creating a new kind of number, we'll have to define numerous special
    methods.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
- en: After looking at numbers, we can look at some more sophisticated design techniques.
    We'll look at how we can create our own decorators and use those to simplify the
    class definition. We'll also look at using mixin class definitions, which are
    similar to the ABC definitions.
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. Creating Numbers
  id: totrans-1869
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can extend the ABC abstractions in the `numbers` module to create new kinds
    of numbers. We might need to do this to create numeric types that fit our problem
    domain more precisely than the built-in numeric types.
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
- en: The abstractions in the `numbers` module need to be looked at first, since they
    define the existing built-in classes. Before working with new kinds of numbers,
    it's essential to see how the existing numbers work.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: We'll digress to look at Python's operator-to-method mapping algorithm. The
    idea is that a binary operator has two operands; either operand can define the
    class that implements the operator. Python's rules for locating the relevant class
    are essential to decide what special methods to implement.
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
- en: The essential arithmetic operators such as `+`, `-`, `*`, `/`, `//`, `%`, and
    `**` form the backbone of numeric operations. There are additional operators that
    include `^`, `|`, and `&`. These are used for the bit-wise processing of integers.
    They're also used as operators among sets. There are some more operators in this
    class, including `<<`, `>>`. The comparison operators were covered in [Chapter
    2](ch02.html "Chapter 2. Integrating Seamlessly with Python Basic Special Methods"),
    *Integrating Seamlessly with Python - Basic Special Methods*. These include `<`,
    `>`, `<=`, `>=`, `==`, and `!=`. We'll review and extend our study of the comparison
    operators in this chapter.
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of additional special methods for numbers. These include
    the various conversions to other built-in types. Python also defines "in-place"
    combinations of an assignment with an operator. These include `+=`, `-=`, `*=`,
    `/=`, `//=`, `%=`, `**=`, `&=`, `|=`, `^=`, `>>=`, and `<<=`. These are more appropriate
    for mutable objects than numbers. We'll finish by summarizing some of the design
    considerations that go into extending or creating new numbers.
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
- en: ABCs of numbers
  id: totrans-1875
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `numbers` package provides a tower of numeric types that are all implementations
    of `numbers.Number`. Additionally, the `fractions` and `decimal` modules provide
    extension numeric types: `fractions.Fraction` and `decimal.Decimal`.'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
- en: These definitions roughly parallel the mathematical thought on the various classes
    of numbers. An article available at [http://en.wikipedia.org/wiki/Number_theory](http://en.wikipedia.org/wiki/Number_theory)
    covers the basics of different kinds of numbers.
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: What's important is the question of how well computers implement mathematical
    abstractions. To be more specific, we want to be sure that anything that is computable
    in the abstract world of mathematics can be computed using a concrete computer.
    This is why the question of computability is so important. The idea behind a "Turing
    Complete" programming language is that it can compute anything that's computable
    by an abstract Turing Machine. A helpful article can be found at [http://en.wikipedia.org/wiki/Computability_theory](http://en.wikipedia.org/wiki/Computability_theory).
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: Python defines the following abstractions and their associated implementation
    classes. Further, these classes form an inheritance hierarchy where each abstract
    class inherits from the class above it. As we move down the list, the classes
    have more features. Since there are very few classes, it forms a *tower* rather
    than a tree.
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
- en: '`numbers.Complex` implemented by `complex`'
  id: totrans-1880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numbers.Real` implemented by `float`'
  id: totrans-1881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numbers.Rational` implemented by `fractions.Fraction`'
  id: totrans-1882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numbers.Integral` implemented by `int`'
  id: totrans-1883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we have `decimal.Decimal`, which is a bit like a float; it isn't
    a proper subclass of `numbers.Real`, but is somewhat like it.
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-1885
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it may be obvious, it's still essential to repeat that the `float` value
    is merely an approximation. It's not exact.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t be surprised by this sort of thing. The following is an example of using
    the ![ABCs of numbers](graphics/0971OS_07_01.jpg) approximations:'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
- en: '`>>> (3*5*7*11)/(11*13*17*23*29)`'
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
- en: '`0.0007123135264946712`'
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
- en: '`>>> _*13*17*23*29`'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
- en: '`105.00000000000001`'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
- en: In principle, the further down the number tower we go, the smaller the order
    of infinity. This can be a confusing subject. While the various abstract definitions
    of numbers are each infinite, it's possible to prove that there are different
    orders of infinity. This leads to the idea that floats represent more numbers
    than integers in principle. Pragmatically, a 64-bit float and 64-bit integer have
    the same number of distinct values.
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the numeric class definitions, there are also a number of conversions
    among the various classes. It''s not possible to convert from every type to every
    other type, so we must work out a matrix that shows the conversions that work
    and conversions that can''t work. The following is a summary:'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
- en: '`complex`: This can''t be converted to any other type. A `complex` value can
    be decomposed into the `real` and `imag` portions, both of which are `float`.'
  id: totrans-1894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`: This can be converted explicitly to any type including `decimal.Decimal`.
    Arithmetic operators won''t implicitly coerce a `float` value to `Decimal`.'
  id: totrans-1895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fractions.Fraction`: This can be converted to any of the other types, except
    `decimal.Decimal`. To get to `decimal` requires a two-part operation: (1) to `float`
    (2) to `decimal.Decimal`. This leads to an approximation.'
  id: totrans-1896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: This can be converted to any of the other types.'
  id: totrans-1897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Decimal`: This can be converted to any other type. It is not implicitly coerced
    to other types via arithmetic operations.'
  id: totrans-1898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The up and down conversions come from the tower of numeric abstractions shown
    previously.
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
- en: Deciding which types to use
  id: totrans-1900
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because of the conversions, we see the following four general domains of numerical
    processing:'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
- en: '**Complex**: Once we get involved in complex math, we''ll be using `complex`,
    `float`, plus the `cmath` module. We probably aren''t going to use `Fraction`
    or `Decimal` at all. However, there''s no reason to impose restrictions on the
    numeric types; most numbers will be converted to complex.'
  id: totrans-1902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Currency**: For currency-related operations, we absolutely must use `Decimal`.
    Generally, when doing currency calculations, there''s no good reason to mix the
    decimal values with non-decimal values. Sometimes, we''ll use the `int` values,
    but there''s no good reason to work with `float` or `complex` along with `Decimal`.
    Remember, floats are approximations, and that''s unacceptable when working with
    currency.'
  id: totrans-1903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bit kicking**: For operations that involve bit and byte processing, we''ll
    generally use `int`, only `int`, and nothing but `int`.'
  id: totrans-1904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conventional**: The broad, vague "everything else" category. For most conventional
    mathematical operations `int`, `float`, and `Fraction` are all interchangeable.
    Indeed, a well-written function can often be properly polymorphic; it will work
    perfectly well with any numeric type. Python types, particularly `float` and `int`,
    will participate in a variety of implicit conversions. This makes the selection
    of a specific numeric type for these kinds of problems somewhat moot.'
  id: totrans-1905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are generally obvious aspects of a problem domain. It's usually easy to
    distinguish applications that might involve science or engineering and complex
    numbers from applications that involve financial calculations, currency, and decimal
    numbers. It's important to be as permissive as possible in the numeric types that
    are used in an application. Needlessly narrowing the domain of types via the `isinstance()`
    test is often a waste of time and code.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
- en: The method resolution and the reflected operator concept
  id: totrans-1907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The arithmetic operators (`+`, `-`, `*`, `/`, `//`, `%`, `**`, and so on) all
    map to special method names. When we provide an expression such as `355+113`,
    the generic `+` operator will be mapped to a concrete `__add__()` method of a
    specific numeric class. This example will turn out to be evaluated as though we
    had written `355.__add__(113)`. The simplest rule is that the left-most operand
    determines the class of the operator being used.
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
- en: But wait, there's more! When we have an expression with mixed types, Python
    may end up with two implementations of the special methods, one in each class.
    Consider `7-0.14` as an expression. Using the left-side `int` class, this expression
    will be attempted as `7.__sub__(0.14)`. This involves an unpleasant complexity,
    since the argument to an `int` operator is a `float` value `0.14` and converting
    `float` to `int` could potentially lose precision. Converting up the tower of
    types (from `int` toward `complex`) won't lose precision. Converting down the
    tower of types implies a potential loss of precision.
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the right-side `float` version, however, this expression will be attempted
    as: `0.14.__rsub__(7)`. In this case, the argument to a `float` operator is an
    `int` value `7`; converting `int` up the tower to `float` doesn''t (generally)
    lose precision. (A truly giant `int` value can lose precision; however, that''s
    a technical quibble, not a general principle.)'
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__rsub__()` operation is "reflected subtraction". The `X.__sub__(Y)` operation
    is the expected ![The method resolution and the reflected operator concept](graphics/0971OS_07_02.jpg).
    The `A.__rsub__(B)` operation is the reflection ![The method resolution and the
    reflected operator concept](graphics/0971OS_07_03.jpg); the implementation method
    comes from the right-hand side operand''s class. We''ve seen the following two
    rules:'
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
- en: Try the left-hand side operand's class first. If that works, good. If the operand
    returns `NotImplemented` as a value, then use rule 2.
  id: totrans-1912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try the right-hand side operand with the reflected operator. If that works,
    good. If it returns `NotImplemented`, then it really is not implemented, so an
    exception must be raised.
  id: totrans-1913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The notable exception is when the two operands happen to have a subclass relationship.
    This additional rule applies before the first pair rules as a special case:'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
- en: If the right operand is a subclass of the left and the subclass defines the
    reflected special method name for the operator, then the subclass reflected operator
    will be tried. This allows a subclass override to be used, even if the subclass
    operand is on the right-hand side of the operator.
  id: totrans-1915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, use rule 1 and try the left side.
  id: totrans-1916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine we wrote a subclass of float, `MyFloat`. In an expression like `2.0-MyFloat(1)`,
    the right operand is of a subclass of the left operand's class. Because of this
    subclass relationship, `MyFloat(1).__rsub__(2.0)` will be tried first. The point
    of this rule is to give precedence to the subclass.
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
- en: This means that a class that will do implicit coercion from other types must
    implement the forward, as well as the reflected operators. When we implement or
    extend a numeric type, we must work out the conversions that our type is able
    to do.
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
- en: The arithmetic operator's special methods
  id: totrans-1919
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a total of 13 binary operators and their associated special methods.
    We''ll focus on the obvious arithmetic operators first. The special method names
    match the operators (and functions), as shown in the following table:'
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  id: totrans-1921
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1922
  prefs: []
  type: TYPE_TB
- en: '| `object.__add__(self, other)` | `+` |'
  id: totrans-1923
  prefs: []
  type: TYPE_TB
- en: '| `object.__sub__(self, other)` | `-` |'
  id: totrans-1924
  prefs: []
  type: TYPE_TB
- en: '| `object.__mul__(self, other)` | `*` |'
  id: totrans-1925
  prefs: []
  type: TYPE_TB
- en: '| `object.__truediv__(self, other)` | `/` |'
  id: totrans-1926
  prefs: []
  type: TYPE_TB
- en: '| `object.__floordiv__(self, other)` | `//` |'
  id: totrans-1927
  prefs: []
  type: TYPE_TB
- en: '| `object.__mod__(self, other)` | `%` |'
  id: totrans-1928
  prefs: []
  type: TYPE_TB
- en: '| `object.__divmod__(self, other)` | `divmod()` |'
  id: totrans-1929
  prefs: []
  type: TYPE_TB
- en: '| `object.__pow__(self, other[, modulo])` | `pow()` as well as `**` |'
  id: totrans-1930
  prefs: []
  type: TYPE_TB
- en: 'And yes, interestingly, two functions are included with the various symbolic
    operators. There are a number of unary operators and functions which have special
    method names, shown in the following table:'
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  id: totrans-1932
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1933
  prefs: []
  type: TYPE_TB
- en: '| `object.__neg__(self)` | `-` |'
  id: totrans-1934
  prefs: []
  type: TYPE_TB
- en: '| `object.__pos__(self)` | `+` |'
  id: totrans-1935
  prefs: []
  type: TYPE_TB
- en: '| `object.__abs__(self)` | `abs()` |'
  id: totrans-1936
  prefs: []
  type: TYPE_TB
- en: '| `object.__complex__(self)` | `complex()` |'
  id: totrans-1937
  prefs: []
  type: TYPE_TB
- en: '| `object.__int__(self)` | `int()` |'
  id: totrans-1938
  prefs: []
  type: TYPE_TB
- en: '| `object.__float__(self)` | `float()` |'
  id: totrans-1939
  prefs: []
  type: TYPE_TB
- en: '| `object.__round__(self[, n])` | `round()` |'
  id: totrans-1940
  prefs: []
  type: TYPE_TB
- en: '| `object.__trunc__(self[, n])` | `math.trunc()` |'
  id: totrans-1941
  prefs: []
  type: TYPE_TB
- en: '| `object.__ceil__(self[, n])` | `math.ceil()` |'
  id: totrans-1942
  prefs: []
  type: TYPE_TB
- en: '| `object.__floor__(self[, n])` | `math.floor()` |'
  id: totrans-1943
  prefs: []
  type: TYPE_TB
- en: 'And yes, there are a lot of functions in this list too. We can tinker with
    Python''s internal trace to see what''s going on under the hood. We''ll define
    a simplistic trace function that will provide us with a little bit of visibility
    into what''s going on:'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  id: totrans-1945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'This function will dump special method names when the code associated with
    the traced frame has a name that starts with `"__"`. We can install this trace
    function into Python using the following code:'
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  id: totrans-1947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'Once installed, everything passes through our `trace()` function. We''re filtering
    the trace events for special method names. We''ll define a subclass of a built-in
    class so that we can explore the method resolution rules:'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  id: totrans-1949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'This class overrides just two of the operator''s special method names. When
    we add `noisyfloat` values, we''ll see a printed summary of the operation. Plus,
    the trace will tell us what''s going on. The following is the interaction that
    shows Python''s choice of class to implement a given operation:'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  id: totrans-1951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: From `x+3`, we see how `noisyfloat+int` provided the `int` object, `3`, to the
    `__add__()` method. This value was passed to the superclass, `float`, which handled
    the coercion of 3 to a `float` and did the addition, too. `2+x` shows how the
    right side `noisyfloat` version of the operation was used. Again, `int` was passed
    to the superclass that handled the coercion to `float`. From `x+2.3`, we come
    to know that `noisyfloat+float` used the subclass that was on the left-hand side.
    On the other hand, `2.3+x` shows how `float+noisyfloat` used the subclass on the
    right-hand side and the reflected `__radd__()` operator.
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
- en: Creating a numeric class
  id: totrans-1953
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll try to design a new kind of number. This is no easy task when Python already
    offers integers of indefinite precision, rational fractions, standard floats,
    and decimal numbers for currency calculations. We'll define a class of "scaled"
    numbers. These are numbers that include an integer value coupled with a scaling
    factor. We can use these for currency calculations. For many currencies of the
    world, we can use a scale of 100 and do all our calculations to the nearest cent.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of scaled arithmetic is that it can be done very simply by using
    low-level hardware instructions. We could rewrite this module to be a C-language
    module and exploit hardware speed operations. The disadvantage of inventing new
    scaled arithmetic is that the `decimal` package already does a very neat job of
    exact decimal arithmetic.
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
- en: We'll call this `FixedPoint` class because it will implement a kind of fixed
    decimal point number. The scale factor will be a simple integer, usually a power
    of 10\. In principle, a scaling factor that's a power of 2 could be considerably
    faster, but wouldn't be ideally suited for currency.
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
- en: The reason a scaling factor that's a power of 2 can be faster is that we can
    replace `value*(2**scale)` with `value << scale` and replace `value/(2**scale)`
    with `value >> scale`. The left and right shift operations are often hardware
    instructions that are much faster than multiplication or division.
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the scaling factor is a power of 10, but we don't explicitly enforce
    this. It's a relatively simple extension to track both a scaling power and the
    scale factor that goes with the power. We might store 2 as the power and ![Creating
    a numeric class](graphics/0971OS_07_04.jpg) as the factor. We've simplified this
    class definition to just track the factor.
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
- en: Defining FixedPoint initialization
  id: totrans-1959
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll start with initialization, which includes conversions of various types
    to the `FixedPoint` values as follows:'
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  id: totrans-1961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'Our `FixedPoint` class is defined as a `numbers.Rational` subclass. We''re
    going to wrap two integer values, `scale` and `value`, and follow the general
    definitions for fractions. This requires a large number of special method definitions.
    The initialization is for an immutable object, so it overrides `__new__()` instead
    of `__init__()`. It defines a limited number of slots to prevent the adding of
    any additional attributes. The initialization includes several kinds of conversions
    as follows:'
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
- en: If we're given another `FixedPoint` object, we'll copy the internal attributes
    to create a new `FixedPoint` object that's a kind of clone of the original. It
    will have a unique ID, but we can be sure it has the same hash value and compares
    as equal, making the clone largely indistinguishable.
  id: totrans-1963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When given integral or rational values (concrete classes of `int` or `float`),
    these are used to set the `value` and `scale` attributes.
  id: totrans-1964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add cases to handle `decimal.Decimal` and `fractions.Fraction`, as well
    as parsing input string values.
  id: totrans-1965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve defined three special methods to produce string results: `__str__()`,
    `__repr__()`, and `__format__()`. For the format operation, we''ve decided to
    leverage the existing floating-point features of the format specification language.
    Because this is a rational number, we need to provide numerator and denominator
    methods.'
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could have also started with wrapping the existing `fractions.Fraction`
    class. Also, note that we're playing fast and loose with the rounding rules. This
    should also be defined with reasonable care before applying this class to a specific
    problem domain.
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
- en: Defining FixedPoint binary arithmetic operators
  id: totrans-1968
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The whole reason for defining a new class of numbers is to overload the arithmetic
    operators. Each `FixedPoint` object has two parts: `value` and `scale`. We can
    say this: ![Defining FixedPoint binary arithmetic operators](graphics/0971OS_07_05.jpg).'
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
- en: Note that we've worked out the algebra in the example below using correct but
    inefficient floating point expressions. We'll discuss the slightly more efficient,
    pure integer operations.
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
- en: 'The general form for addition (and subtraction) is this: ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_06.jpg). But it creates a result
    with a lot of useless precision.'
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
- en: Imagine adding 9.95 and 12.95\. We'd have (in principle) 229000/10000\. This
    can be properly reduced to 2290/100\. The problem is that it also reduces to 229/10,
    which is no longer in cents. We'd like to avoid reducing fractions in a general
    way and instead stick with cents or mils to the extent possible.
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
- en: 'We can identify two cases for ![Defining FixedPoint binary arithmetic operators](graphics/0971OS_07_07.jpg):'
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
- en: '**The scale factors match**: In this case, the sum is ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_08.jpg). When adding `FixedPoint`
    and the plain old integer, this will also work, since we can force the plain old
    integer to have the required scale factor.'
  id: totrans-1974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The scale factors don''t match**: The right thing to do is to produce a result
    that has the maximum scale factor of the two input values, ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_09.jpg). From this, we can compute
    two scale factors, ![Defining FixedPoint binary arithmetic operators](graphics/0971OS_07_10.jpg)
    and ![Defining FixedPoint binary arithmetic operators](graphics/0971OS_07_11.jpg).
    One of those scale factors will be 1, the other will be less than 1\. We can now
    add with a common value in the denominator. Algebraically, it''s ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_12.jpg). This can be further optimized
    into two cases, since one of the factors is 1 and the other is a power of 10.'
  id: totrans-1975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can't really optimize multiplication. It's essentially ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_13.jpg). The precision really
    does increase when we multiply the `FixedPoint` values.
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
- en: 'Division is multiplication by an inverse, ![Defining FixedPoint binary arithmetic
    operators](graphics/0971OS_07_14.jpg). If A and B have the same scale, these values
    will cancel so that we do have a handy optimization available. However, this changes
    the scale from cents to wholes, which might not be appropriate. The following
    is what the forward operators, built around a similar boilerplate, look like:'
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  id: totrans-1978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: For the simple addition, subtraction, and multiplication cases, we've provided
    versions that can be optimized to eliminate some of the relatively slow floating
    point intermediate results.
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
- en: For the two divisions, the `__mod__()` and `__pow__()` methods, we haven't done
    any optimization to try and eliminate noise being introduced via floating-point
    division. Instead, we've provided a working Python implementation that can be
    used with a suite of unit tests as a basis for optimization and refactoring.
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that the division operations can properly reduce the
    scale factors. However, that may be undesirable. When doing currency work, we
    might divide the currency rate (dollars) by a non-currency value (hours) to get
    the dollars-per-hour result. The proper answer might have zero relevant decimal
    places, this would be a scale of 1, but we might want to force the value to have
    a cents-oriented scale of 100\. This implementation assures that the left-hand
    side operand dictates the desired number of decimal places.
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
- en: Defining FixedPoint unary arithmetic operators
  id: totrans-1982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the unary operators method functions:'
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  id: totrans-1984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: For the `__round__()`, `__trunc__()`, `__ceil__()`, and `__floor__()` operators,
    we've delegated the work to a Python library function. There are some potential
    optimizations, but we've taken the lazy route of creating a float approximation
    and using that to create the desired result. This suite of methods assures that
    our `FixedPoint` objects will work with a number of arithmetic functions. Yes,
    there are a lot of operators in Python. This isn't the entire suite. We haven't
    covered comparison or bit-kicking operators.
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
- en: Implementing FixedPoint reflected operators
  id: totrans-1986
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The reflected operators are used in the following two cases:'
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
- en: The right-hand operand is a subclass of the left-hand operand. In this case,
    the reflected operator is tried first to assure that the subclass overrides the
    parent class.
  id: totrans-1988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The left-hand operand's class doesn't implement the needed special method. In
    this case, the right-hand operand's reflected special method is used.
  id: totrans-1989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table shows the mapping between reflected special methods and
    operators.
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  id: totrans-1991
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1992
  prefs: []
  type: TYPE_TB
- en: '| `object.__radd__(self, other)` | `+` |'
  id: totrans-1993
  prefs: []
  type: TYPE_TB
- en: '| `object.__rsub__(self, other)` | `-` |'
  id: totrans-1994
  prefs: []
  type: TYPE_TB
- en: '| `object.__rmul__(self, other)` | `*` |'
  id: totrans-1995
  prefs: []
  type: TYPE_TB
- en: '| `object.__rtruediv__(self, other)` | `/` |'
  id: totrans-1996
  prefs: []
  type: TYPE_TB
- en: '| `object.__rfloordiv__(self, other)` | `//` |'
  id: totrans-1997
  prefs: []
  type: TYPE_TB
- en: '| `object.__rmod__(self, other)` | `%` |'
  id: totrans-1998
  prefs: []
  type: TYPE_TB
- en: '| `object.__rdivmod__(self, other)` | `divmod()` |'
  id: totrans-1999
  prefs: []
  type: TYPE_TB
- en: '| `object.__rpow__(self, other[, modulo])` | `pow()` as well as `**` |'
  id: totrans-2000
  prefs: []
  type: TYPE_TB
- en: 'These reflected operation special methods are also built around a common boilerplate.
    Since these are reflected, the order of the operands in subtraction, division,
    modulus, and power is important. For commutative operations such as addition and
    multiplication, the order doesn''t matter. The following are the reflected operators:'
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  id: totrans-2002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: We've tried to use math that is identical to the forward operators. The idea
    is to switch the operands in a simple way. This is the most common situation.
    Having the text of the forward and reverse methods match each other simplifies
    code inspections.
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
- en: As with the forward operators, we've kept the division, modulus, and power operators
    simple to avoid optimizations. The versions shown here can introduce noise from
    the conversion to a floating-point approximation and back to a `FixedPoint` value.
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
- en: Implementing FixedPoint comparison operators
  id: totrans-2005
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the six comparison operators and the special methods which
    implement them:'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  id: totrans-2007
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2008
  prefs: []
  type: TYPE_TB
- en: '| `object.__lt__(self, other)` | `<` |'
  id: totrans-2009
  prefs: []
  type: TYPE_TB
- en: '| `object.__le__(self, other)` | `<=` |'
  id: totrans-2010
  prefs: []
  type: TYPE_TB
- en: '| `object.__eq__(self, other)` | `==` |'
  id: totrans-2011
  prefs: []
  type: TYPE_TB
- en: '| `object.__ne__(self, other)` | `!=` |'
  id: totrans-2012
  prefs: []
  type: TYPE_TB
- en: '| `object.__gt__(self, other)` | `>` |'
  id: totrans-2013
  prefs: []
  type: TYPE_TB
- en: '| `object.__ge__(self, other)` | `>=` |'
  id: totrans-2014
  prefs: []
  type: TYPE_TB
- en: The `is` operator compares object IDs. We can't meaningfully override this,
    since it's independent of any specific class. The `in` comparison operator is
    implemented by `object.__contains__( self, value )`. This isn't meaningful for
    numeric values.
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
- en: Note that equality testing is a subtle business. Since floats are approximations,
    we have to be very careful to avoid direct equality testing with float values.
    We really need to compare to see if the values are within a small range, that
    is, epsilon. It should never be written as `a == b`. The general approach to compare
    floating-point approximations should be `abs(a-b) <= eps`. Or, more correctly,
    `abs(a-b)/a <= eps`.
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
- en: In our `FixedPoint` class, the scale indicates how close two values need to
    be for a `float` value to be considered equal. For a scale of 100, the epsilon
    could be 0.01\. We'll actually be more conservative than that and use 0.005 as
    the basis for comparison when the scale is 100.
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we have to decide whether `FixedPoint(123, 100)` should be equal
    to `FixedPoint(1230, 1000)` or not. While they're mathematically equal, one value
    is in cents and one is in mils. This can be taken as a claim about the different
    accuracies of the two numbers; the presence of an additional significant digit
    may indicate that they're not supposed to simply appear equal. If we follow this
    approach, then we need to be sure the hash values are different too.
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
- en: 'We think the distinguishing scale is not appropriate for our application. We
    want `FixedPoint(123, 100)` to be equal to `FixedPoint(1230, 1000)`. This is the
    assumption behind the recommended `__hash__()` implementation too. The following
    are the implementations for our `FixedPoint` class comparisons:'
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  id: totrans-2020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: Each of the comparison functions tolerates a value that is not a `FixedPoint`
    value. The only requirement is that the other value must have a floating-point
    representation. We've defined a `__float__()` method for the `FixedPoint` objects,
    so the comparison operations will work perfectly well when comparing the two `FixedPoint`
    values.
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to write all six comparisons. The `@functools.total_ordering`
    decorator can generate the missing methods from just two `FixedPoint` values.
    We'll look at this in [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins
    – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*.
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
- en: Computing a numeric hash
  id: totrans-2023
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We do need to define the `__hash__()` method properly. See section 4.4.4 of
    the *Python Standard Library* for information on computing hash values for numeric
    types. That section defines a `hash_fraction()` function, which is the recommended
    solution for what we''re doing here. Our method looks like the following:'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  id: totrans-2025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: This reduces a two-part rational fraction value to a single, standardized hash.
    This code is copied with a few modifications from the reference manual. The core
    of the calculation, which is highlighted, multiplies the numerator by the inverse
    of the denominator. In effect, it carries out the division of the numerator by
    the denominator, `mod P`. We can optimize this to make it more specific to our
    problem domain.
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
- en: First, we can (and should) modify our `__new__()` method to assure that the
    scale is nonzero, eliminating any need for `sys.hash_info.inf`. Second, we should
    explicitly limit the range of the scale factor to be less than `sys.hash_info.modulus`
    (generally ![Computing a numeric hash](graphics/0971OS_07_15.jpg) for 64-bit computers).
    We can eliminate the need to remove common factors of `P`. That would boil the
    hash down to `hash_ = (abs(m) % P) * pow(n, P - 2, P) % P`, the sign handling
    and the special case that -1 is mapped to -2.
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we might want to memorize the result of any hash calculation. This
    requires an additional slot that's only populated once the first time a hash is
    requested. The `pow(n, P - 2, P)` expression is relatively expensive to evaluate
    and we don't want to compute it more often than necessary.
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
- en: Designing more useful rounding
  id: totrans-2029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We truncated the presentation on rounding. We defined the required functions
    for `round()` and `trunc()` without further explanation. These definitions are
    the minimum requirements of the abstract superclass. However, these definitions
    are not quite enough for our purposes.
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
- en: 'To process currency, we''ll often have code that looks like the following:'
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  id: totrans-2032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'Then, we need to round this value off to a scale of `100` to get a value of
    `942`. We need methods that will round (as well as truncate) a number to a new
    scale factor. The following is a method to round to a specific scale:'
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  id: totrans-2034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'The following code allows us to properly rescale the value:'
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  id: totrans-2036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: This shows that we have a minimal set of functions to calculate currency.
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
- en: Implementing other special methods
  id: totrans-2038
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the core arithmetic and comparison operators, we have a group
    of additional operators that (generally) we only define for the `numbers.Integral`
    values. Since we''re not defining integral values, we can avoid these special
    methods:'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  id: totrans-2040
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2041
  prefs: []
  type: TYPE_TB
- en: '| `object.__lshift__(self, other)` | `<<` |'
  id: totrans-2042
  prefs: []
  type: TYPE_TB
- en: '| `object.__rshift__(self, other)` | `>>` |'
  id: totrans-2043
  prefs: []
  type: TYPE_TB
- en: '| `object.__and__(self, other)` | `&` |'
  id: totrans-2044
  prefs: []
  type: TYPE_TB
- en: '| `object.__xor__(self, other)` | `^` |'
  id: totrans-2045
  prefs: []
  type: TYPE_TB
- en: '| `object.__or__(self, other)` | `&#124;` |'
  id: totrans-2046
  prefs: []
  type: TYPE_TB
- en: 'Also, there are reflected versions of these operators:'
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  id: totrans-2048
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2049
  prefs: []
  type: TYPE_TB
- en: '| `object.__rlshift__(self, other)` | `<<` |'
  id: totrans-2050
  prefs: []
  type: TYPE_TB
- en: '| `object.__rrshift__(self, other)` | `>>` |'
  id: totrans-2051
  prefs: []
  type: TYPE_TB
- en: '| `object.__rand__(self, other)` | `&` |'
  id: totrans-2052
  prefs: []
  type: TYPE_TB
- en: '| `object.__rxor__(self, other)` | `^` |'
  id: totrans-2053
  prefs: []
  type: TYPE_TB
- en: '| `object.__ror__(self, other)` | `&#124;` |'
  id: totrans-2054
  prefs: []
  type: TYPE_TB
- en: 'Additionally, there''s a unary operator for a bit-wise inverse of the value:'
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  id: totrans-2056
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2057
  prefs: []
  type: TYPE_TB
- en: '| `object.__invert__(self)` | `~` |'
  id: totrans-2058
  prefs: []
  type: TYPE_TB
- en: Interestingly, some of these operators are defined for the set collection, as
    well as integral numbers. They don't apply to our rational value. The principles
    to define these operators are the same as the other arithmetic operators.
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
- en: Optimization with the in-place operators
  id: totrans-2060
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, numbers are immutable. However, the numeric operators are also used
    for mutable objects. Lists and sets, for example, respond to a few of the defined
    augmented assignment operators. As an optimization, a class can include an in-place
    version of a selected operator. These methods implement the augmented assignment
    statements for mutable objects. Note that these methods are expected to end with
    `return self` to be compatible with ordinary assignment.
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Operator |'
  id: totrans-2062
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2063
  prefs: []
  type: TYPE_TB
- en: '| `object.__iadd__(self, other)` | `+=` |'
  id: totrans-2064
  prefs: []
  type: TYPE_TB
- en: '| `object.__isub__(self, other)` | `-=` |'
  id: totrans-2065
  prefs: []
  type: TYPE_TB
- en: '| `object.__imul__(self, other)` | `*=` |'
  id: totrans-2066
  prefs: []
  type: TYPE_TB
- en: '| `object.__itruediv__(self, other)` | `/=` |'
  id: totrans-2067
  prefs: []
  type: TYPE_TB
- en: '| `object.__ifloordiv__(self, other)` | `//=` |'
  id: totrans-2068
  prefs: []
  type: TYPE_TB
- en: '| `object.__imod__(self, other)` | `%=` |'
  id: totrans-2069
  prefs: []
  type: TYPE_TB
- en: '| `object.__ipow__(self, other[, modulo])` | `**=` |'
  id: totrans-2070
  prefs: []
  type: TYPE_TB
- en: '| `object.__ilshift__(self, other)` | `<<=` |'
  id: totrans-2071
  prefs: []
  type: TYPE_TB
- en: '| `object.__irshift__(self, other)` | `>>=` |'
  id: totrans-2072
  prefs: []
  type: TYPE_TB
- en: '| `object.__iand__(self, other)` | `&=` |'
  id: totrans-2073
  prefs: []
  type: TYPE_TB
- en: '| `object.__ixor__(self, other)` | `^=` |'
  id: totrans-2074
  prefs: []
  type: TYPE_TB
- en: '| `object.__ior__(self, other)` | `&#124;=` |'
  id: totrans-2075
  prefs: []
  type: TYPE_TB
- en: 'Since our `FixedPoint` objects are immutable, we should not define any of these.
    Stepping outside this example, for a moment, we can see a more typical use for
    in-place operators. We could easily define some in-place operators for our Blackjack
    `Hand` objects. We might want to add this definition to `Hand` as follows:'
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  id: totrans-2077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'This allows us to deal into `hand` with the following code:'
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  id: totrans-2079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: This seems to be an elegant way to indicate that `hand` is updated with another
    card.
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-2081
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've looked at the built-in numeric types. We've also looked at the vast number
    of special methods required to invent a new numeric type. Specialized numeric
    types that integrate seamlessly with the rest of Python is one of the core strengths
    of the language. That doesn't make the job easy. It merely makes it elegant and
    useful when done properly.
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations and trade-offs
  id: totrans-2083
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with numbers, we have a multistep design strategy:'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
- en: Consider the built-in versions of `complex`, `float`, and `int`.
  id: totrans-2085
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider the library extensions such as `decimal` and `fractions`. For financial
    calculations, `decimal` must be used; there is no alternative.
  id: totrans-2086
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider extending one of the above classes with additional methods or attributes.
  id: totrans-2087
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, consider a novel number. This is particularly challenging, since Python's
    variety of available numbers is very rich.
  id: totrans-2088
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Defining new numbers involves several considerations:'
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
- en: '**Completeness and consistency**: The new number must perform a complete set
    of operations and behave consistently in all kinds of expressions. This is really
    a question of properly implementing the formal mathematical definitions of this
    new kind of computable number.'
  id: totrans-2090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fit with the problem domain**: Is this number truly suitable? Does it help
    clarify the solution?'
  id: totrans-2091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: As with other design questions, we must be sure that our implementation
    is efficient enough to warrant writing all that code. Our example in this chapter,
    for example, uses some inefficient floating-point operations that could be optimized
    by doing a little more math and a little less coding.'
  id: totrans-2092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking forward
  id: totrans-2093
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next chapter is about using decorators and mixins to simplify and normalize
    class design. We can use decorators to define features that should be present
    in a number of classes, which are not in a simple inheritance hierarchy. Similarly,
    we can use mixin class definitions to create a complete application class from
    component class definitions. One of the decorators that is helpful to define comparison
    operators is the `@functools.total_ordering` decorator.
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8. Decorators and Mixins – Cross-cutting Aspects
  id: totrans-2095
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A software design often has aspects that apply across several classes, functions,
    or methods. We might have a technical aspect, examples include logging, auditing,
    or security, that must be implemented consistently. The general method for reuse
    of functionality in object-oriented programming is inheritance through a class
    hierarchy. However, inheritance doesn't always work out well. Some aspects of
    a software design are orthogonal to the class hierarchy. These are sometimes called
    "cross-cutting concerns". They cut across the classes, making design more complex.
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
- en: A decorator provides a way to define functionality that's not bound to the inheritance
    hierarchy. We can use decorators to design an aspect of our application and then
    apply the decorators across classes, methods, or functions.
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we can use multiple inheritance in a disciplined way to create
    cross-cutting aspects. We'll consider a base class plus mixin class definitions
    to introduce features. Often, we'll use the mixin classes to build cross-cutting
    aspects.
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that cross-cutting concerns are rarely specific to the
    application at hand. They're often generic considerations. The common examples
    of logging, auditing, and security could be considered as infrastructure separate
    from the application's details.
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
- en: Python comes with many decorators, and we can expand this standard set of decorators.
    There are several different use cases. We'll look at simple function decorators,
    function decorators with arguments, class decorators, and method decorators.
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
- en: Class and meaning
  id: totrans-2101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One essential feature of objects is that they can be classified. Each object
    belongs to a class. This is a straightforward relationship between an object and
    class with a simple, single-inheritance design.
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
- en: With multiple inheritance, the classification problem can become complex. When
    we look at real-world objects, such as coffee cups, we can classify them as containers
    without too much difficulty. That is, after all, their primary use case. The problem
    they solve is that of holding coffee. However, in another context, we may be interested
    in other use cases. In a decorative collection of ceramic mugs, we might be more
    interested in size, shape, and glaze than we are in the coffee-carrying aspect
    of a cup.
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
- en: Most objects have a straightforward *is-a* relationship with a class. In our
    coffee-holding problem domain, the mug sitting on the desk is a coffee cup as
    well as a container. Objects may also have several *acts-as* relationships with
    other classes. A mug acts as a piece of ceramic art with size, shape, and glaze
    properties. A mug acts as a paper weight with mass and friction properties. Generally,
    these other features can be seen as mixin classes, and they define the additional
    interfaces or behaviors for an object.
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
- en: When doing object-oriented design, it's common to identify the *is-a* class
    and the essential aspects defined by that class. Other classes can mix in interfaces
    or behaviors that an object will also have. We'll take a look at how classes are
    constructed and decorated. We'll start with function definition and decoration
    since it's somewhat simpler than class construction.
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the functions
  id: totrans-2106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We construct functions in two stages. The first stage is the `def` statement
    with an original definition.
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-2108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's technically possible to build a function using a lambda and assignment;
    we'll avoid that.
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
- en: A `def` statement provides a name, parameters, defaults, a `docstring`, a code
    object, and a number of other details. A function is a collection of 11 attributes,
    defined in section 3.2 of the *Python Language Reference* which is the standard
    type hierarchy. See [http://docs.python.org/3.3/reference/datamodel.html#the-standard-type-hierarchy](http://docs.python.org/3.3/reference/datamodel.html#the-standard-type-hierarchy).
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
- en: 'The second stage is applying a decorator to the original definition. When we
    apply a decorator (`@d`) to a function (`F`), the effect is as if we have created
    a new function, ![Constructing the functions](graphics/0971OS_08_01.jpg). The
    name is the same, but the functionality can be different depending on the kind
    of features that have been added, removed, or modified. Then, we will write the
    following code:'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  id: totrans-2112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'The decorator is written immediately in front of the function definition. What
    happens is this:'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  id: totrans-2114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'The decorator modifies the function definition to create a new function. Here
    is the list of attributes of a function:'
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Contents |'
  id: totrans-2116
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2117
  prefs: []
  type: TYPE_TB
- en: '| `__doc__` | The docstring, or `None`. |'
  id: totrans-2118
  prefs: []
  type: TYPE_TB
- en: '| `__name__` | The original name of the function. |'
  id: totrans-2119
  prefs: []
  type: TYPE_TB
- en: '| `__module__` | The name of the module the function was defined in, or `None`.
    |'
  id: totrans-2120
  prefs: []
  type: TYPE_TB
- en: '| `__qualname__` | The function''s fully qualified name, `__module__.__name__`.
    |'
  id: totrans-2121
  prefs: []
  type: TYPE_TB
- en: '| `__defaults__` | The default argument values, or none if there are no defaults.
    |'
  id: totrans-2122
  prefs: []
  type: TYPE_TB
- en: '| `__kwdefaults__` | The default values for keyword-only parameters. |'
  id: totrans-2123
  prefs: []
  type: TYPE_TB
- en: '| `__code__` | The code object representing the compiled function body. |'
  id: totrans-2124
  prefs: []
  type: TYPE_TB
- en: '| `__dict__` | A namespace for the function''s attributes. |'
  id: totrans-2125
  prefs: []
  type: TYPE_TB
- en: '| `__annotations__` | The annotations of parameters, including `''return''`
    for the return annotation. |'
  id: totrans-2126
  prefs: []
  type: TYPE_TB
- en: '| `__globals__` | The global namespace of the module that the function was
    defined in; this is used to resolve global variables and is read only. |'
  id: totrans-2127
  prefs: []
  type: TYPE_TB
- en: '| `__closure__` | Bindings for the function''s free variables or none. It is
    read-only. |'
  id: totrans-2128
  prefs: []
  type: TYPE_TB
- en: Except for `__globals__` and `__closure__`, a decorator can change any of these
    attributes. However, we'll see later that it's impractical to tinker with these
    too deeply.
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
- en: Pragmatically, decoration usually involves defining a new function that *wraps*
    the existing function. A few of the previous attributes may need to be copied
    or updated. This defines a practical limit to what decorators can and should do.
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the class
  id: totrans-2131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Class construction is a nested set of two-stage processes. Making class construction
    more complex is the way references are made to class methods that involve a multistep
    lookup. An object's class will define a **Method Resolution Order** (**MRO**).
    This defines how base classes are searched to locate an attribute or method name.
    The MRO works its way up the inheritance hierarchy; this means that subclass names
    override superclass names. This implementation method search meets our expectation
    for what inheritance means.
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
- en: The first stage in class construction is the `class` statement with the original
    definition. This stage involves the evaluation of the metaclass followed by the
    execution of the sequence of assignment and `def` statements within a `class`.
    Each `def` statement within the class expands to a nested two-stage function construction,
    as described previously. Decorators can be applied to each method function as
    part of the process of building the class.
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
- en: The second stage in class construction is to apply an overall class decorator
    to a class definition. Generally, a `decorator` function can add features. It's
    somewhat more common to add attributes rather than adding methods. However, we
    will see decorators that can also add method functions.
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
- en: 'The features inherited from superclasses clearly cannot be modified through
    decorators since they are resolved lazily by method resolution lookup. This leads
    to some important design considerations. We generally introduce methodsthrough
    classes and mixin classes. We''re limited to introducing attributes either via
    decorators or mixin class definitions. Here''s a list of some of the attributes
    that are built for a class. A number of additional attributes are part of the
    metaclass; they are described in the following table:'
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Contents |'
  id: totrans-2136
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2137
  prefs: []
  type: TYPE_TB
- en: '| `__doc__` | The class''s documentation string, or `None` if undefined |'
  id: totrans-2138
  prefs: []
  type: TYPE_TB
- en: '| `__name__` | The class name |'
  id: totrans-2139
  prefs: []
  type: TYPE_TB
- en: '| `__module__` | The module name that the class was defined in |'
  id: totrans-2140
  prefs: []
  type: TYPE_TB
- en: '| `__dict__` | The dictionary containing the class''s namespace |'
  id: totrans-2141
  prefs: []
  type: TYPE_TB
- en: '| `__bases__` | A tuple (possibly empty or a singleton) containing the base
    classes, in the order of their occurrence in the base class list; it is used to
    work out method resolution order |'
  id: totrans-2142
  prefs: []
  type: TYPE_TB
- en: '| `__class__` | The superclass of this class, often the `type` class |'
  id: totrans-2143
  prefs: []
  type: TYPE_TB
- en: Some additional method functions that are part of a class include `__subclasshook__`,
    `__reduce__`, and `__reduce_ex__`, which are part of the interface for `pickle`.
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
- en: Some class design principles
  id: totrans-2145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When defining a class, we have the following three sources of attributes and
    methods:'
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
- en: The class statement
  id: totrans-2147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorators applied to the class definition
  id: totrans-2148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mixin classes with the base class that is given last
  id: totrans-2149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to be cognizant of the level of visibility for each of these. The `class`
    statement is the most obvious source for attributes and methods. The mixins and
    the base class are somewhat less obvious than the class body. It's helpful to
    make sure that the base class name clarifies its role as essential. We've tried
    to name our base classes after real-world objects.
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
- en: The mixin classes will generally define additional interfaces or behaviors of
    a class. It's important to be clear how the mixin classes are used to build the
    final class definitions. While a `docstring` class is an important part of this,
    the overall module `docstring` is also important to show how a proper class can
    be assembled from the various parts.
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
- en: When writing the `class` statement, the essential superclass is listed last
    and the mixins are listed before that. This is not merely convention. The last
    listed class is the essential *is-a* class. The application of the decorator to
    the class will lead to somewhat more obscure features. Typically, a decorator
    will do relatively little. A strong focus on one or a few features helps to clarify
    what the decorator does.
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-oriented programming
  id: totrans-2153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Parts of **aspect-oriented programming** (**AOP**) are relevant to decorators.
    Our purpose here is to leverage a few aspect-oriented concepts to help show the
    purpose of decorators and mixins in Python. The idea of a **cross-cutting concern**
    is central to AOP. Here''s some additional background: [http://en.wikipedia.org/wiki/Cross-cutting_concern](http://en.wikipedia.org/wiki/Cross-cutting_concern).
    There are several common examples of cross-cutting concerns, as follows:'
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
- en: '**Logging**: We often need to have logging features implemented consistently
    in many classes. We want to be sure the loggers are named consistently and logging
    events follow the class structure in a consistent manner.'
  id: totrans-2155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auditability**: A variation of the logging theme is to provide an audit trail
    that shows each transformation of a mutable object. In many commerce-oriented
    applications, the transactions are business records that represent bills or payments.
    Each step in the processing of a business record needs to be auditable to show
    that no errors have been introduced by the processing.'
  id: totrans-2156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Our applications will often have security aspects that pervade
    each HTTP request and each piece of content downloaded by the website. The idea
    is to confirm that each request involves an authenticated user who is authorized
    to make the request. Cookies, secure sockets, and other cryptographic techniques
    must be used consistently to assure that an entire web application is secured.'
  id: totrans-2157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some languages and tools have deep, formal support for AOP. Python borrows
    a few of the concepts. The Pythonic approach to AOP involves the following language
    features:'
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
- en: '**Decorators**: With a decorator, we can establish a consistent aspect implementation
    at one of two simple join points in a function. We can perform the aspect''s processing
    before or after the existing function. We can''t easily locate join points inside
    the code of a function. It''s easiest for decorators to transform a function or
    method by wrapping it with additional functionality.'
  id: totrans-2159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixins**: With a mixin, we can define a class that exists outside a single
    class hierarchy. The mixin class can be used with other classes to provide a consistent
    implementation of a cross-cutting aspect. For this to work, the mixin API must
    be used by the classes that it is mixed into. Generally, mixin classes are considered
    abstract since they can''t be meaningfully instantiated.'
  id: totrans-2160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using built-in decorators
  id: totrans-2161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has several built-in decorators that are part of the language. The `@property`,
    `@classmethod`, and `@staticmethod` decorators are used to annotate methods of
    a class. The `@property` decorator transforms a method function into a descriptor.
    We use this to give a method function the syntax of a simple attribute. The property
    decorator, when applied to a method, also creates an additional pair of properties
    that can be used to create a `setter` and `deleter` property. We looked at this
    in [Chapter 3](ch03.html "Chapter 3. Attribute Access, Properties, and Descriptors"),
    *Attribute Access, Properties, and Descriptors*.
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@classmethod` and `@staticmethod` decorators transform a method function
    into a class-level function. The decorated method can now be called from a class,
    not an object. In the case of a static method, there''s no explicit reference
    to the class. With a class method, on the other hand, the class is the first argument
    of the method function. The following is an example of a class that includes `@staticmethod`
    and some `@property` definitions:'
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  id: totrans-2164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: This class defines an `Angle` that can be represented in degrees or radians.
    The constructor expects degrees. However, we've also defined a `from_radians()`
    method function that emits an instance of the class. This function does not work
    with an instance variable; it works with the class itself and returns an instance
    of the class. The `__new__()` method is implicitly a class method. A decorator
    is not used.
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we provide the `degrees()` and `radians()` method functions that
    have been decorated so that they are properties. Under the hood, these decorators
    create a descriptor so that accessing the attribute name `degrees` or `radians`
    will invoke the named method function. We can use the `static` method to create
    an instance and then use a `property` method to access a method function:'
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  id: totrans-2167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: The static method is effectively a function because it's not tied to the `self`
    instance variable. It has the advantage that it is syntactically bound to the
    class; using `Angle.from_radians` can be microscopically more helpful than using
    a function named `angle_from_radians`. The use of these decorators assures that
    the implementation is done correctly and consistently.
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
- en: Using standard library decorators
  id: totrans-2169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The standard library has a number of decorators. Modules such as `contextlib`,
    `functools`, `unittest`, `atexit`, `importlib`, and `reprlib` contain decorators
    that are excellent examples of cross-cutting aspects of a software design. For
    example, the `functools` library offers the `total_ordering` decorator that defines
    comparison operators. It leverages `__eq__()` and either `__lt__()`, `__le__()`,
    `__gt__()`, or `__ge__()` to create a complete suite of comparisons. The following
    is a variation on the `Card` class that defines just two comparisons:'
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  id: totrans-2171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: 'Our class is wrapped by a class-level decorator, `@functools.total_ordering`.
    This decorator creates the missing method functions. We can use this class to
    create objects that can be compared using all of the comparison operators, even
    though only two were defined. Here''s an example of comparisons we''ve defined
    as well as comparisons we have not defined:'
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  id: totrans-2173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: This interaction shows that we are able to make comparisons that are not defined
    in the original class. The decorator added method functions to the original class
    definition.
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
- en: Using standard library mixin classes
  id: totrans-2175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard library makes use of mixin class definitions. There are several
    modules that contain examples, including `io`, `socketserver`, `urllib.request`,
    `contextlib`, and `collections.abc`.
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
- en: When we define our own collection based on the `collections.abc` abstract base
    classes, we're making use of mixins to assure that cross-cutting aspects of the
    containers are defined consistently. The top-level collections (`Set`, `Sequence`,
    and `Mapping`) are all built from multiple mixins. It's very important to look
    at section 8.4 of the *Python Standard Library* to see how the mixins contribute
    features, as the overall structure is built up from pieces.
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
- en: Looking at just one line, the summary of `Sequence`, we see that it inherits
    from `Sized`, `Iterable`, and `Container`. These mixin classes lead to methods
    of `__contains__()`, `__iter__()`, `__reversed__()`, `index()`, and `count()`.
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
- en: Using the context manager mixin class
  id: totrans-2179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we looked at context managers in [Chapter 5](ch05.html "Chapter 5. Using
    Callables and Contexts"), *Using Callables and Contexts*, we ignored the `ContextDecorator`
    mixin and focused on the special methods themselves. Using the mixin can make
    the definition clearer.
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-2181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous version of the example, we created a context manager that altered
    a global state; it reset the random number seed. We'll rework that design to make
    a deck that can be its own context manager. When used as a context manager, it
    can generate a fixed sequence of cards. This isn't really the best way to unit
    test a deck of cards. However, it's a simple use of a context manager.
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining context management as a mixin of an application class requires some
    care. We may have to redesign the initialization method to remove some assumptions.
    Our application classes may be used in the following two distinct ways:'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
- en: When used outside a `with` statement, the `__enter__()` and `__exit__()` methods
    will not be evaluated
  id: totrans-2184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When used inside a `with` statement, the `__enter__()` and `__exit__()` methods
    will be evaluated
  id: totrans-2185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, we can''t assume that it''s valid to evaluate the `shuffle()`
    method during `__init__()` processing because we don''t know whether or not the
    context manager methods will be used. We can''t defer shuffling to `__enter__()`
    because it may not be used. This complexity may indicate that we''re offering
    too much flexibility. Either we have to shuffle lazily, just before the first
    `pop()`, or we have to provide a method function that can be turned off by a subclass.
    The following is a simple `Deck` definition that extends `list`:'
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  id: totrans-2187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'We''ve defined this deck to have a removable `_init_shuffle()` method. A subclass
    can override this method to change when the shuffling is complete. A subclass
    of `Deck` can seed the random number generator before shuffling. This version
    of the class can avoid shuffling during creation. The following is a subclass
    of `Deck` that includes the `contextlib.ContextDecorator` mixin:'
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  id: totrans-2189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: This subclass prevents shuffling during initialization by overriding the `_init_shuffle()`
    method. Because this mixes in `ContextDecorator`, it must also define `__enter__()`
    and `__exit__()`. This subclass of `Deck` can work in a `with` context. When used
    in a `with` statement, the random number seed is set, and the shuffling will use
    a known sequence. If it's used outside a `with` statement, then the shuffling
    will use the current random number settings and there will be no `__enter__()`
    evaluation.
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of this style of programming is to separate the truly essential
    features of a class from other aspects of the `Deck` implementation. We have separated
    some of the random seed processing from other aspects of `Deck`. Clearly, we can
    simplify things a great deal if we simply insist that a context manager is required.
    This is not typical of the way the `open()` function works. However, it can be
    helpful simplification. We can use examples like the following to see the differences
    in behavior:'
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  id: totrans-2192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: 'This example shows how `Deck` can be used by itself to generate randomized
    shuffles. This is the simple use of having `Deck` produce shuffled cards. The
    next example shows `TestDeck` with a given seed:'
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  id: totrans-2194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: This shows `TestDeck`, the subclass of `Deck`, which is used as a context manager
    to produce a known sequence of cards. Each time we invoke it, we get the same
    sequence of cards.
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
- en: Turning off a class feature
  id: totrans-2196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve turned off the shuffle-during-initialization feature by redefining a
    method function to have a body of `pass`. This process may seem a bit long winded
    to remove a feature from a subclass. There''s an alternative to remove functionality
    in a subclass: to set the method name to be `None`. We can do this inside `TestDeck`
    to remove the initial shuffle:'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  id: totrans-2198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: 'The preceding code requires a little more programming in the superclass to
    tolerate the missing method, which is shown in the following snippet:'
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  id: totrans-2200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: This can be a somewhat more explicit way to remove a feature in a subclass definition.
    This shows that the method could be missing or has intentionally been set to `None`.
    Yet another alternative design is to move the call to `_init_shuffle()` from `__init__()`
    to the `__enter__()` method. This will require the use of a context manager that
    will make the object behave properly. That's not too odious a burden if it's documented
    clearly.
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple function decorator
  id: totrans-2202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `decorator` function is a function (or a callable object) that returns a
    new function. The simplest case involves a single argument: the function that
    is to be decorated. The result of a decorator is a function that has been wrapped.
    Essentially, the additional features are put either before or after the original
    functionality. These are the two readily available join points in a function.'
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
- en: When we define a decorator, we want to be sure that the decorated function has
    the original function's name and `docstring`. These attributes should be set by
    a decorator, which we will use to write the decorated functions. Using `functools.wraps`
    to write new decorators simplifies the work we need to do because this bit of
    bookkeeping is handled for us.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the two places where functionality can be inserted, we can create
    a debug trace decorator that will log parameters and return values from a function.
    This puts functionality both before and after the called function. The following
    is some defined function, `some_function`, that we want to wrap:'
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  id: totrans-2206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: This snippet shows how we'll have new processing to wrap the original function.
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s difficult to insert processing into a defined function by poking at the
    underlying `__code__` object. In the rare case where it seems necessary to inject
    an aspect in the middle of a function, it''s much easier to rewrite the function
    as a callable object, by breaking the functionality down into multiple method
    functions. Then, we can use mixin and subclass definitions rather than complex
    code rewriting. The following is a debug decorator that inserts logging before
    and after function evaluation:'
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  id: totrans-2209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'We''ve used the `functools.wraps` decorator to assure that the original function
    name and `docstring` are preserved in the result function. Now, we can use our
    decorator to produce noisy, detailed debugging. For example, we can do this to
    apply the decorator to some function, `ackermann()`, as follows:'
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  id: totrans-2211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'This definition wraps the `ackermann()` function with debugging information
    written via the logging module to the `root` logger. We configure the logger to
    produce the following debugging output:'
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  id: totrans-2213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'We''ll revisit logging in detail in [Chapter 14](ch14.html "Chapter 14. The
    Logging and Warning Modules"), *The Logging and Warning Modules*. We''ll see this
    kind of result when we evaluate `ackermann(2,4)`:'
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  id: totrans-2215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: Creating separate loggers
  id: totrans-2216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a logging optimization, we might want to use a specific logger for each
    wrapped function and not overuse the root logger for this kind of debugging output.
    We''ll return to the logger in [Chapter 14](ch14.html "Chapter 14. The Logging
    and Warning Modules"), *The Logging and Warning Modules*. The following is a version
    of our decorator that creates a separate logger for each individual function:'
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  id: totrans-2218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: 'This version modifies the output to look like the following:'
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  id: totrans-2220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: The function name is now the logger name. This can be used to fine-tune the
    debugging output. We can now enable logging for individual functions. We can't
    trivially change the decorator and expect the decorated function to also change.
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
- en: We need to apply the revised decorator to the function. This means that debugging
    and experimenting with decorators can't be done *trivially* from the `>>>` interactive
    prompt. We have to reload the function definitions after we tweak the decorator
    definition. This can involve a bunch of copy and paste, or it can involve rerunning
    a script that defines the decorator, the functions, and then runs tests or a demonstration
    script to show that everything works as expected.
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing a decorator
  id: totrans-2223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we want to provide more elaborate parameters to a decorator. The idea
    is that we are going to customize the wrapping function. When we do this, decoration
    becomes a two-step process.
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write the following code, we provide a parameterized decorator to a
    function definition:'
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  id: totrans-2226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'The use of the decorator is a shorthand for the following code:'
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  id: totrans-2228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'Both examples do the following three things:'
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
- en: Defined a function, `func`
  id: totrans-2230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied the abstract decorator to its arguments to create a concrete decorator,
    `decorator(arg)`
  id: totrans-2231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied the concrete decorator to the defined function to create the decorated
    version of the function, `decorator(arg)(func)`
  id: totrans-2232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that a decorator with arguments will require indirect construction
    of the final function. Let''s tweak our debugging decorator yet again. We''d like
    to do the following:'
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  id: totrans-2234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'This kind of code allows us to specifically name the log that the debugging
    output will go to. We don''t use the root logger nor default to a distinct logger
    for each function. The outline of a parameterized decorator is something like
    the following:'
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  id: totrans-2236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'Let''s peel back the layers of this onion before looking at the example. The
    decorator definition (`def decorator(config)`) shows the parameters we will provide
    to the decorator when we use it. The body of this is the concrete decorator, which
    is returned. The concrete decorator (`def concrete_decorator(function)`) is the
    decorator that will be applied to the target function. This, then, is just like
    the simple function decorator shown in the previous section. It builds the wrapped
    function (`def wrapped(*args, **kw)`), which it returns. The following is our
    named logger version of debug:'
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  id: totrans-2238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'This `decorator` function accepts an argument that is the name of the log to
    use. It creates and returns a concrete decorator function. When this is applied
    to a function, the concrete decorator returns the wrapped version of the given
    function. When the function is used in the following manner, the decorator adds
    noisy debug lines. They direct the output to a log named `recursion` as follows:'
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  id: totrans-2240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: Creating a method function decorator
  id: totrans-2241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A decorator for a method function of a class definition is identical to a decorator
    for a standalone function. It's simply used in a different context. One small
    consequence of this different context is that we often must explicitly name the
    `self` variable.
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
- en: One application for method function decoration is to produce an audit trail
    for object state change. Business applications often create stateful records;
    commonly, these are represented as rows in a relational database. We'll look at
    object representation in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving
    – JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML*, [Chapter10](ch10.html "Chapter 10. Storing and Retrieving Objects
    via Shelve"), *Storing and Retrieving Objects via Shelve*, and [Chapter 11](ch11.html
    "Chapter 11. Storing and Retrieving Objects via SQLite"), *Storing and Retrieving
    Objects via SQLite*.
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-2244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we have stateful records, the state changes need to be auditable. An audit
    can confirm that appropriate changes have been made to the records. In order to
    do the audit, the before and after version of each record must be available somewhere.
    Stateful database records are a long-standing tradition but are not in any way
    required. Immutable database records are a viable design alternative.
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
- en: 'When we design a stateful class, any setter method we write will cause a state
    change. These setter methods often use the `@property` decorator so that they
    appear to be simple attributes. If we do this, we can fold in an `@audit` decorator
    that can track changes to the object, so that we have a proper trail of changes.
    We''ll create an audit log via the `logging` module. We''ll use the `__repr__()`
    method function to produce a complete text representation that can be used to
    examine changes. The following is an audit decorator:'
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  id: totrans-2247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'We''ve created a text memento of the *before* version of the object. Then,
    we''ve applied the original method function. If there was an exception, we would
    produce an audit log that includes the exception details. Otherwise, we''ll produce
    an `INFO` entry in the log that has the qualified name of the method, the before
    memento, and the after memento of the object being changed. The following is a
    modification of the `Hand` class that shows how we''d use this decorator:'
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  id: totrans-2249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: This definition modifies the `__iadd__()` method function, so that adding a
    card becomes an auditable event. This decorator will perform the audit operation,
    saving text mementos of `Hand` before and after the operation.
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
- en: This use of a method decorator makes a formal declaration that a particular
    method function has made a significant state change. We can easily use code reviews
    to be sure that all of the appropriate method functions are marked for audit like
    this. An open issue is auditing object creation. It's not perfectly clear that
    object creation requires an audit record. It can be argued that object creation
    is not a state change.
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
- en: 'In the event that we want to audit creation, we can''t use this `audit` decorator
    on the `__init__()` method function. That''s because there''s no before image
    prior to the execution of `__init__()`. There are two things we can do as a remedy
    to this, as follows:'
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
- en: We can add a `__new__()` method that assures that an empty `_cards` attribute
    is seeded into the class as an empty collection
  id: totrans-2253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can tweak the `audit()` decorator to tolerate `AttributeError` that will
    arise when `__init__()` is being processed
  id: totrans-2254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second option is considerably more flexible. We can do the following:'
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  id: totrans-2256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'This would record a message such as `AttributeError: ''Hand'' object has no
    attribute ''_cards''` for the before status during initialization.'
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class decorator
  id: totrans-2258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Analogous to decorating a function, we can write a class decorator to add features
    to a class definition. The essential rules are the same. The decorator is a function
    (or callable object). It receives a class object as an argument and returns a
    class object as a result.
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
- en: We have a limited number of join points inside a class definition as a whole.
    For the most part, a class decorator will fold additional attributes into a class
    definition. It's technically possible to create a new class that wraps an original
    class definition. This is challenging, since the wrapping class must be very generalized.
    It's also possible to create a new class that is a subclass of the decorated class
    definition. This may be baffling to users of the decorator. It's also possible
    to delete features from a class definition, which seems perfectly awful.
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
- en: One sophisticated class decorator was shown previously. The `functools.Total_Ordering`
    decorator injects a number of new method functions into the class definition.
    The technique used in this implementation is to create lambda objects and assign
    them to attributes of the class.
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at a somewhat simpler decorator. During debugging and logging,
    we could have a small problem creating loggers that are focused on our classes.
    Often, we''d like to have a unique logger for each class. We''re often forced
    to do something like the following:'
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  id: totrans-2263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: This class has the disadvantage that it creates a `logger` instance variable
    that's really not part of the class's operation, but is a separate aspect of the
    class. We'd like to avoid polluting the class with this additional aspect. That's
    not all. Even though `logging.getLogger()` is very efficient, the cost's nonzero.
    We'd like to avoid this additional overhead every time we create an instance of
    `UglyClass1`.
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a slightly better version. The logger is promoted to be a class-level
    instance variable and is separate from each individual object of the class:'
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  id: totrans-2266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'This has the advantage that it implements `logging.getLogger()` just once.
    However, it suffers from a profound DRY problem. We can''t automatically set the
    class name within the class definition. The class hasn''t been created yet, so
    we''re forced to repeat the name. The DRY problem is solved by a small decorator
    as follows:'
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  id: totrans-2268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'This decorator tweaks the class definition to add the `logger` reference as
    a class-level attribute. Now, each method can use `self.logger` to produce audit
    or debug information. When we want to use this feature, we can use the `@logged`
    decorator on the class as a whole. The following is an example of a logged class,
    `SomeClass`:'
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  id: totrans-2270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: Now, our class has a `logger` attribute that can be used by any method. The
    logger value is not a feature of the object, which keeps this aspect separated
    from the rest of the class aspects. This attribute has the added benefit that
    it creates the logger instances during module import, reducing the overhead of
    logging slightly. Let's compare this with `UglyClass1`, where `logging.getLogger()`
    was evaluated for each instance creation.
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
- en: Adding method functions to a class
  id: totrans-2272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A class decorator creates new method functions using a two-step process: by
    creating the method function and then inserting it into the class definition.
    This is often better done via a mixin class than a decorator. The obvious and
    expected use of a mixin is to insert methods. Inserting methods another way is
    less obvious and can be astonishing.'
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
- en: In the example of the `Total_Ordering` decorator, the exact method functions
    inserted were flexible and depended on what was already provided. This was a kind
    of special case that was typical but also very clever.
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
- en: 'We might want to define a standardized `memento()` method. We''d like to include
    this standard method function in a variety of classes. We''ll look at the decorator
    and mixin versions of this design. The following is the decorator version of adding
    a standard method:'
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  id: totrans-2276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: 'This decorator includes a method function definition that is inserted into
    the class. The following is how we use this `@memento` decorator to add a method
    function to a class:'
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  id: totrans-2278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'The decorator incorporates a new method, `memento()`, into the decorated class.
    However, this has the following disadvantages:'
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
- en: We can't override the implementation of the `memento()` method function to handle
    special cases. It's built into the class *after* the definition.
  id: totrans-2280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can't extend the decorator function easily. We'd have to upgrade to a callable
    object to provide extensions or specializations. If we're going to upgrade to
    a callable object, we should discard this whole approach and use a mixin to add
    the method.
  id: totrans-2281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the mixin class that adds a standard method:'
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  id: totrans-2283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'The following is how we use this `Memento` mixin class to define an application
    class:'
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  id: totrans-2285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: The mixin provides a new method, `memento()`; this is the expected, typical
    purpose of a mixin. We can more easily extend the `Memento` mixin class to add
    features. In addition, we can override the `memento()` method function to handle
    special cases.
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
- en: Using decorators for security
  id: totrans-2287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software is filled with cross-cutting concerns, aspects that need to be implemented
    consistently even if they're in separate class hierarchies. It's often a mistake
    to try and impose a class hierarchy around a cross-cutting concern. We've looked
    at a few examples, such as logging and auditing.
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
- en: We can't reasonably demand that every class that might need to write to the
    log also be a subclass of some `loggable` superclass. We can design a `loggable`
    mixin or a `loggable` decorator. These don't interfere with the proper inheritance
    hierarchy that we need to design to make polymorphism work correctly.
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important cross-cutting concerns revolve around security. Within a web
    application, there are two sides to the security question as follows:'
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Do we know who''s making the request?'
  id: totrans-2291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Is the authenticated user allowed to make the request?'
  id: totrans-2292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some web frameworks allow us to decorate our request handlers with security
    requirements. The Django framework, for example, has a number of decorators that
    allow us to specify security requirements for a view function or a view class.
    Some of these decorators are as follows:'
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
- en: '`user_passes_test`: This is a low-level decorator that''s very generalized
    and is used to build the other two decorators. It requires a test function; the
    logged-in `User` object associated with the request must pass the given function.
    If the `User` instance is not able to pass the given test, they''re redirected
    to a login page so that the person can provide the credentials required to make
    the request.'
  id: totrans-2294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login_required`: This decorator is based on `user_passes_test`. It confirms
    that the logged-in user is authenticated. This kind of decorator is used on web
    requests that apply to all people accessing the site. Requests such as changing
    a password or logging out, for example, shouldn''t require any more specific permissions.'
  id: totrans-2295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permission_required`: This decorator works with Django''s internally defined
    database permission scheme. It confirms that the logged-in user (or the user''s
    group) is associated with the given permission. This kind of decorator is used
    on web requests where specific administrative permissions are required to make
    the request.'
  id: totrans-2296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other packages and frameworks also have ways to express this cross-cutting
    aspect of web applications. In many cases, a web application may have even more
    stringent security considerations. We might have a web application where user
    features are selectively unlocked based on contract terms and conditions. Perhaps,
    additional fees will unlock a feature. We might have to design a test like the
    following:'
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  id: totrans-2298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: 'We''ve defined a function that checks the logged-in `User` `feature_set` collection
    to see if the named feature is associated with `User`. We''ve used our `has_feature()`
    function with Django''s `user_passes_test` decorator to create a new decorator
    that can be applied to the relevant `view` functions. We can then create a `view`
    function as follows:'
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  id: totrans-2300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: This assures that the security concerns will be applied consistently across
    a number of `view` functions.
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-2302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've looked at using decorators to modify function and class definitions. We've
    also looked at mixins that allow us to decompose a larger class into components
    that are knitted together.
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
- en: The idea of both of these techniques is to separate application-specific features
    from generic features such as security, audit, or logging. We're going to distinguish
    between the inherent features of a class and aspects that aren't inherent but
    are additional concerns. The inherent features are part of the explicit design.
    They're part of the inheritance hierarchy; they define what an object is. The
    other aspects can be mixins or decorations; they define how an object might also
    act.
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations and trade-offs
  id: totrans-2305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most cases, this division between *is-a* and *acts-as* is quite clear. Inherent
    features are a part of the overall problem domain. When talking about simulating
    Blackjack play, things such as cards, hands, betting, hitting, and standing are
    clearly part of the problem domain. Similarly, the data collection and statistical
    analysis of outcomes is part of the solution. Other things, such as logging, debugging,
    and auditing are not part of the problem domain but associated with solution technology.
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
- en: 'While most cases are quite clear, the dividing line between inherent and decoration
    aspects can be fine. In some cases, it may devolve to an aesthetic judgment. Generally,
    the decision becomes difficult when writing framework and infrastructure classes
    that aren''t focused on a specific problem. The general strategy is as follows:'
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
- en: First, aspects that are central to the problem will lead directly to class definitions.
    Many classes are inherent to the problem and form proper class hierarchies so
    that polymorphism works as expected.
  id: totrans-2308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, some aspects will lead to mixin class definitions. This often happens
    when there are aspects that are multidimensional. We might have independent axes
    or dimensions to a design. Each dimension can contribute polymorphic alternatives.
    When we look at Blackjack play, there are two kinds of strategies: play strategies
    and betting strategies. These are independent and might be considered the mixin
    elements of an overall player design.'
  id: totrans-2309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we define separate mixins, we can have separate inheritance hierarchies
    for the mixins. For Blackjack betting strategies, we can define a polymorphic
    hierarchy that's unrelated to the polymorphic hierarchy for play strategies. We
    can then define players that have mixin elements from both hierarchies.
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods are generally created from class definitions. They''re either part
    of the primary class or a mixin class. As noted above, we have three design strategies:
    Wrap, Extend, and Invent. We can introduce functionality through "wrapping" a
    class with another class. In some cases, we find that we''re forced to expose
    a large number of methods that are simply delegated to the underlying class. There''s
    a hazy boundary where we have too much delegation; a decorator or mixin would
    have been a better idea. In other cases, wrapping a class may be clearer than
    introducing a mixin class definition.'
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
- en: Aspects that are orthogonal to the problem can often be handled by decorator
    definitions. The decorators can be used to introduce features that are not part
    of the *is-a* relationship that an object has with its class.
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  id: totrans-2313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The coming chapters will change direction. We've seen almost all of Python's
    special method names. The next five chapters are going to focus on object persistence
    and serialization. We'll start out with serializing and saving objects in various
    external notations, including JSON, YAML, Pickle, CSV, and XML.
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
- en: Serialization and persistence introduce yet more object-oriented design considerations
    for our classes. We'll have a look at object relationships and how they're represented.
    We'll also have a look at the cost complexity of serializing and deserializing
    objects, and at the security issues related to the de-serialization of objects
    from untrustworthy sources.
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
