- en: '*Chapter 19*:'
  prefs: []
  type: TYPE_NORMAL
- en: System Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalability is, for sure, one of the most critical demands for the success of
    a web application. An application's capacity to scale depends on the whole system
    architecture, and building a project while having scalability in mind is the best
    way to go. You'll be very thankful later when the success of the business may
    require the application to be highly scalable due to heavy loads of traffic.
  prefs: []
  type: TYPE_NORMAL
- en: So, as the web grows, designing and building scalable applications is also becoming
    more important. In this chapter, we cover all the scalability interview questions
    you may be asked during a junior/middle-level interview for a position such as
    a web application software architect, Java architect, or software engineer. If
    you are looking for a position that doesn't involve tasks related to software
    architecture and design, then most probably scalability will not be an interview
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our agenda for this chapter includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalability in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions and coding challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Scalability in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most predictable yet important question your interviewer will ask you is:
    What is scalability? Scalability is the capability and ability of a process (system,
    network, application) to cope with an increase in workload (by workload, we understand
    anything that pushes the system to the limit, such as traffic, storage capacity,
    a maximum number of transactions, and so on) when adding resources (typically
    hardware). Scalability can be expressed as the ratio between the increase in system
    performance and the rise in resources used. Moreover, scalability also means the
    ability to add extra resources without affecting/modifying the structure of the
    main nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: If adding more resources results in a slight increase in performance, or even
    worse, boosting the resources has no effect on performance, then you are facing
    so-called *poor scalability*.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can you achieve scalability? During an interview that involves scalability
    questions, you will most probably be asked this question as well. Giving a general,
    comprehensive, and not too time-consuming answer is the best choice. The main
    points that should be touched upon are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Leverage 12factor** (https://12factor.net/): This methodology is independent
    of the programming language and can be really helpful for delivering flexible
    and scalable applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement persistence wisely**: From choosing the proper database for your
    application and developing the most optimized schema, to mastering techniques
    for scaling the persistence layer (for example, clustering, replicas, sharding,
    and so on), this is one of the key aspects that deserve your entire attention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t underestimate queries**: Database queries are a key factor in acquiring
    short transactions. Tune your connection pool and queries for scalability. For
    example, pay attention to cross-node joins, which can quickly downgrade performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Choose hosting and tools**: Scaling is not only about the code! The infrastructure
    counts a lot as well. Today, many cloud players (for example, Amazon) provide
    autoscaling and dedicated tools (Docker, Kubernetes, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consider load balancing and reverse proxying**: One day, you have to switch
    from a single server to a multi-server architecture. Running under a cloud infrastructure
    (for example, Amazon) will easily provide these facilities with just several configurations
    (for most cloud providers, load balancing and reverse proxying are part of the
    *ready-to-go* offer). Otherwise, you have to be prepared for this significant
    change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: While scaling your application, consider new caching strategies,
    topologies, and tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relieve the backend**: Move as many computations as possible from the backend
    to the frontend. This way, you take some work from your backend shoulders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test and monitor**: Testing and monitoring your code will help you to discover
    issues as soon as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other aspects to discuss, but at this point, the interviewer
    should be ready to advance the interview to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Questions and coding challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we cover 13 questions and coding challenges that represent
    *must-knows* in junior/middle-level scalability interviews. Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 1 – Scaling types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What do scaling up and scaling out mean?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Scaling up (or vertical scaling) is achieved by adding more resources
    to an existing system to achieve better performance and successfully face a greater
    workload. By resources, we can understand more storage, more memory, more network,
    more threads, more connections, more powerful hosts, more caching, and so on.
    Once the new resources are added, the application should be capable of respecting
    the SLAs. Today, scaling up in the cloud is very efficient and fast. Clouds such
    as AWS, Azure, Oracle, Heroku, Google Cloud, and so on can automatically allocate
    more resources based on the threshold plan in just a couple of minutes. When the
    traffic decreases, AWS can disable these extra resources. This way, you pay only
    for what you use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scaling out (or horizontal scaling) is typically related to distributed architectures.
    There are two basic forms of scaling out:'
  prefs: []
  type: TYPE_NORMAL
- en: Add more infrastructure capacity in pre-packaged blocks of infrastructure/nodes
    (for example, hyper-converged).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an independent distributed service that can harvest information about customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, scaling out is done by adding more servers or CPUs that are the same
    type as those that are currently used or any compatible kind. Scaling out makes
    it easy for service providers to offer customers a *pay-as-you-grow* infrastructure
    and services. Scaling out happens quite fast since nothing has to be imported
    or rebuilt. Nevertheless, scale-out speed is limited by the speed with which the
    servers can communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Clouds such as AWS can automatically allocate more infrastructure based on the
    threshold plan in just a couple of minutes. When the traffic is low, AWS can disable
    these extra infrastructures. This way, you pay only for what you use.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, scaling up offers better performance than scaling out.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 2 – High availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is high availability?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: High availability and low latency are mission-critical for tons
    of businesses.'
  prefs: []
  type: TYPE_NORMAL
- en: Typically expressed as a percentage of uptime in a given year, high availability
    is achieved when an application is available to its users without interruption
    (99.9% of the time during a year).
  prefs: []
  type: TYPE_NORMAL
- en: Achieving high availability is commonly done via clustering.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 3 – Low latency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is low latency?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Low latency is a term used in relation to computer networks that
    are optimized to handle and process an extremely high volume of data with minimal
    delay or latency. Such networks are designed and built to handle operations that
    attempt to achieve near real-time data processing capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 4 – Clustering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is a cluster and why do we need clustering?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: A cluster is a group of machines that can individually run an
    application. We can have an application server cluster, a database server cluster,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Having a cluster significantly reduces the chances of our service becoming unavailable
    in the event that one of the machines from the cluster fails. In other words,
    clustering's main purpose consists of achieving 100% availability or zero downtime
    in service (high availability – see *Coding challenge 2*). Of course, there is
    still be a small chance of all the cluster machines failing at the same time,
    but that is typically mitigated by having the machines located at different locations
    or supported by their own resources.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 5 – Latency, bandwidth, and throughput
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What are latency, bandwidth, and throughput?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The best way to explain these notions during an interview relies
    on a simple analogy with a tube as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.1 – Latency versus bandwidth versus throughput'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.1_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.1 – Latency versus bandwidth versus throughput
  prefs: []
  type: TYPE_NORMAL
- en: '**Latency** is the amount of time it takes to travel through the tube, not
    the tube length. It is, however, measured as a function of the tube length.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bandwidth** is how wide the tube is.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Throughput** is the amount of water flowing through the tube.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 6 – Load balancing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is load balancing?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Load balancing is a technique used for distributing workloads
    across multiple machines or clusters. Among the algorithms used by load balancing,
    we have Round Robin, sticky session (or session affinity), and IP address affinity.
    A common and simple algorithm is Round Robin, which divides the workload in a
    circular order, ensuring that all the available machines get an equal number of
    requests and none of them is overloaded or underloaded.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following figure marks the place of a load balancer in a typical
    master-slave architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.2 – Load balancer in a master-slave architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.2_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.2 – Load balancer in a master-slave architecture
  prefs: []
  type: TYPE_NORMAL
- en: By dividing the work across the machines, load balancing strives to achieve
    maximum throughput and response time.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 7 – Sticky session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is sticky session (or session affinity)?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Sticky session (or session affinity) is a notion encountered
    in a load balancer. Typically, the user information is stored in the session,
    and the session is replicated on all the machines from the cluster. But session
    replication (see *Coding challenge 11*) can be avoided by serving a particular
    user session requests from the same machine.'
  prefs: []
  type: TYPE_NORMAL
- en: For this, the session is associated with a machine. This happens when the sessions
    are created. All the incoming requests for this session are always redirected
    to the associated machine. The user data is only on that machine.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, sticky session is typically done via the `jsessionid` cookie. At the
    first request, the cookie is sent to the client. For each subsequent request,
    the client request contains the cookie as well. This way, the cookie identifies
    the session.
  prefs: []
  type: TYPE_NORMAL
- en: The main drawback of the sticky session approach consists of the fact that if
    the machine fails then the user information is lost, and that session is unrecoverable.
    If the client browser doesn't support cookies or cookies are disabled, then sticky
    session via cookies cannot be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 8 – Sharding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is sharding?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Sharding is an architectural technique for distributing a single
    logical database system across a cluster of machines. The following figure depicts
    this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.3 – Sharding'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.3_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.3 – Sharding
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding figure, sharding is about the horizontal partitioning
    of the database scheme. Mainly, the rows of a database table (for example, `teams`)
    are stored separately (West Data Center holds odd rows, while East Data Center
    holds even rows), instead of splitting the table into columns (splitting into
    columns is known as normalization and vertical partitioning).
  prefs: []
  type: TYPE_NORMAL
- en: Each partition is called a *shard.* As you can see from the preceding figure,
    each shard can be independently located on a physical location or on a separate
    database server.
  prefs: []
  type: TYPE_NORMAL
- en: The sharding goal is to make a database system highly scalable. The small number
    of rows in each shard reduces the index size and improves the read/search operations'
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The drawbacks of sharding are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The application must be aware of the data location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding/removing nodes from the system requires rebalancing the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cross-node join queries come with performance penalties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding challenge 9 – Shared-nothing architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is shared-nothing architecture?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Shared-nothing architecture (denoted as **SN**) is a distributed
    computing technique that holds that each node is independent and contains everything
    it needs to have autonomy. Moreover, there is no single point of contention required
    across the system. The main aspects of an SN architecture are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The nodes work independently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No resources (memory, files, and so on) are shared between the nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a node fails, then it affects only its users (other nodes continue to work).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having a linear and theoretically infinite scalability, the SN architecture
    is quite popular. Google is one of the major players that relies on SN.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 10 – Failover
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is failover?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Failover is a technique used for achieving high availability
    by switching to another machine from the cluster when one of the machines fails.
    Commonly, failover is applied automatically by a load balancer via a heartbeat
    check mechanism. Mainly, the load balancer checks the machines'' availability
    by ensuring that they respond. If a heartbeat of a machine fails (the machine
    doesn''t respond), then the load balancer doesn''t send any requests to it and
    redirects the requests to another machine from the cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 11 – Session replication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is session replication?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Session replication is commonly encountered in application server
    clusters with the main goal of achieving session failover.'
  prefs: []
  type: TYPE_NORMAL
- en: Session replication is applied every time a user changes their current session.
    Mainly, the user session is automatically replicated to other machines from the
    cluster. This way, if a machine fails, the load balancer sends the incoming requests
    to another machine from the cluster. Since every machine in the cluster has a
    copy of the user session, the load balancer can choose any of those machines.
  prefs: []
  type: TYPE_NORMAL
- en: While session replication sustains session failover, it may have extra cost
    in terms of memory and network bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 12 – The CAP theorem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is the CAP theorem?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The CAP theorem was published by Eric Brewer and is specific
    to distributed computing. Conforming to this theorem, a distributed computer system
    can simultaneously provide only two of the following three things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency**: Concurrent updates are available to all nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: Every request receives a response of success or fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partition tolerance**: The system continues to operate despite a partial
    failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure depicts the CAP theorem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.4 – The CAP theorem'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.4_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.4 – The CAP theorem
  prefs: []
  type: TYPE_NORMAL
- en: Companies such as Google, Facebook, and Amazon use the CAP theorem to decide
    their application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 13 – Social networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: How would you design the data structures for a social network
    like Facebook? Describe the algorithm to show the shortest path between two people
    (for example, Tom → Alice → Mary → Kely).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Commonly, social networks are designed using graphs. The result
    is a huge graph such as those in the next figure (this figure was gathered via
    Google Image via the *social network graph* keywords):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.5 – Social network graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.5_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.5 – Social network graph
  prefs: []
  type: TYPE_NORMAL
- en: So, finding a path between two people means finding a path in such a graph.
    In this case, the problem reduces to how to efficiently find a path between two
    nodes in such a huge graph.
  prefs: []
  type: TYPE_NORMAL
- en: We can start with one person and traverse the graph to find the other person.
    Traversing a graph can be done using **BFS** (**Breadth-first Search**) or **DFS**
    (**Depth-first Search**). For more details about these algorithms, check out [*Chapter
    13*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295), *Trees and Graphs*.
  prefs: []
  type: TYPE_NORMAL
- en: DFS will be very inefficient! Two persons might be only one degree of separation
    apart, but DFS may traverse millions of nodes (persons) before finding this relatively
    immediate connection.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the winner is BFS. More precisely, we can employ bidirectional BFS. Like
    two trains that come from opposite directions and intersect at some moment in
    time, we use one BFS that starts from person *A* (the source) and one BFS that
    starts from person *B* (the destination). When the searches collide, we have found
    a path between *A* and *B*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why not unidirectional BFS? Because going from *A* to *B* will traverse *p+p*p*
    people. Mainly, unidirectional BFS will traverse *A*''s *p* friends, and then
    each of their *p* friends. This means that for a path of length *q*, the unidirectional
    BFS will perform in O(pq) runtime. On the other hand, the bidirectional BFS traverses
    2*p* nodes: each of *A*''s *p* friends and each of *B*''s *p* friends. This means
    that for a path of length *q*, the bidirectional BFS performs in O(pq/2+ pq/2)
    = O(pq/2). Obviously, O(pq/2) is better than O(pq).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a path such as Ana -> Bob -> Carla -> Dan -> Elvira, where each
    person has 100 friends. A unidirectional BFS will traverse 100 million (1004)
    nodes. A bidirectional BFS will traverse only 20,000 nodes (2 x 1002).
  prefs: []
  type: TYPE_NORMAL
- en: Finding an efficient way to connect *A* and *B* is just one of the problems.
    Another problem is caused by the high number of persons, when the amount of data
    is so huge it cannot be stored on a single machine. This means that our graph
    will use multiple machines (for example, a cluster). If we represent the list
    of users as a list of IDs, then we can use sharding and store ranges of IDs on
    each machine. This way, we go to the next person in the path by going first onto
    the machine that contains the person's ID.
  prefs: []
  type: TYPE_NORMAL
- en: In order to mitigate a lot of random jumps between machines, which will downgrade
    performance, we can distribute the users across machines by taking into account
    country, city, state, and so on. It is more likely that users from the same country
    will be friends.
  prefs: []
  type: TYPE_NORMAL
- en: Further questions that need an answer refer to caching usage, when to stop a
    search with no results, what to do if a machine fails, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: It is clear that tackling problems such as the preceding one is not an easy
    task. It requires addressing a lot of questions and issues, therefore reading
    and practicing as much as possible is a must.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing is the key to success
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of this short chapter deserves an entire book. But, challenging yourself
    to solve the following top 10 problems will boost your insights about scalability
    and your chances of becoming a software engineer.
  prefs: []
  type: TYPE_NORMAL
- en: Designing bitly, TinyURL, and goo.gl (a service for shorting URLs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Questions to address:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you assign a unique identifier (ID) for each given URL?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having thousands of URLs per second, how do you generate unique identifiers
    (IDs) at scale?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you handle redirects?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you deal with custom short URLs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you deal with the expired URLs (delete them)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you track statistics (for example, click stats)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing Netflix, Twitch, and YouTube (a global video streaming service)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Questions to address:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you store and distribute data in a way that accommodates a large number
    of simultaneous users (the users can watch and share data)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you track statistics (for example, the total number of views, voting,
    and so on)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you allow users to add comments on videos (preferably, in real time)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing WhatsApp and Facebook Messenger (a global chat service)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Questions to address:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you design one-on-one conversations/meetings between users?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you design group chats/meetings?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you deal with offline users (not connected to the internet)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should you send push notifications?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you support end-to-end encryption?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing Reddit, HackerNews, Quora, and Voat (a message board service and social
    network)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Questions to address:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you track the stats of each answer (the total number of views, voting,
    and so on)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you allow users to follow other users or topics?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you design the timeline consisting of a user's top questions (similar
    to newsfeed generation)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing Google Drive, Google Photos, and Dropbox (a global file storage and
    sharing service)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Questions to address:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you design user features such as upload, search, view, and share files/photos?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you track permissions for file sharing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you allow a group of users to edit the same document?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing Twitter, Facebook, and Instagram (an extremely large social media
    service)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Questions to address:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you efficiently store and search for posts/tweets?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you implement newsfeed generation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you tackle the social graph (see *Coding challenge 13*)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing Lyft, Uber, and RideAustin (a ride-sharing service)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Questions to address:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you match a ride request with nearby drivers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you store millions of locations (geographical coordinates) for riders
    and drivers that are continuously moving?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you update the driver/rider locations (updates every second)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a type-ahead and web crawler (a search engine related service)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Questions to address:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you refresh data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you store the previous search queries?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you detect the best matches for the already typed string?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you tackle a case when the user is typing too fast?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you find new pages (web pages)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you assign priorities to web pages that are changing dynamically?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you guarantee that the crawler is not stuck on the same domain forever?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing an API rate limiter (for example, GitHub or Firebase)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Questions to address:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you limit the number of requests within a time window (for example, 30
    requests per second)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you implement rate-limiting to work in a cluster of servers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you tackle throttling (soft and hard)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing nearby places/friends and Yelp (a proximity server)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Questions to address:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you search for nearby friends or places?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you rank places?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you store location data according to the population density?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answering these challenges is not an easy task and requires significant experience.
    However, if you are a junior/middle-level programmer and you have read this introductory
    chapter about scalability, then you should be able to decide whether your career
    path should go in this direction or not. However, keep in mind that designing
    large-scale distributed systems is a very demanding area in software engineering
    interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last chapter of this book. We've just covered a bunch of problems
    that fit into the scalability topic.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on coming this far! Now, at the end of this book, remember to
    practice as much as possible, have confidence in your judgment, and never give
    up! I really hope that your next Java position will bring you the job of your
    dreams and that this book makes a contribution to your success.
  prefs: []
  type: TYPE_NORMAL
