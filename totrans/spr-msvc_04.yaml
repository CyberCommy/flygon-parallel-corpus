- en: Chapter 4. Microservices Evolution – A Case Study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like SOA, a microservices architecture can be interpreted differently by different
    organizations, based on the problem in hand. Unless a sizable, real world problem
    is examined in detail, microservices concepts are hard to understand.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce BrownField Airline (BF), a fictitious budget airline,
    and their journey from a monolithic **Passenger Sales and Service** (**PSS**)
    application to a next generation microservices architecture. This chapter examines
    the PSS application in detail, and explains the challenges, approach, and transformation
    steps of a monolithic system to a microservices-based architecture, adhering to
    the principles and practices that were explained in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The intention of this case study is to get us as close as possible to a live
    scenario so that the architecture concepts can be set in stone.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have learned about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A real world case for migrating monolithic systems to microservices-based ones,
    with the BrownField Airline's PSS application as an example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various approaches and transition strategies for migrating a monolithic application
    to microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a new futuristic microservices system to replace the PSS application
    using Spring Framework components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the microservices capability model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The examples in this chapter explore the following microservices capabilities
    from the microservices capability model discussed in [Chapter 3](ch03.html "Chapter 3. Applying
    Microservices Concepts"), *Applying Microservices Concepts*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Listener**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message Listener**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage Capabilities (Physical/In-Memory)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business Capability Definitions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Endpoints & Communication Protocols**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Interfaces**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security Service**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice Documentation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Reviewing the microservices capability model](img/B05447_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 2](ch02.html "Chapter 2. Building Microservices with Spring Boot"),
    *Building Microservices with Spring Boot*, we explored all these capabilities
    in isolation including how to secure Spring Boot microservices. This chapter will
    build a comprehensive microservices example based on a real world case study.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this chapter is available under the `Chapter 4` projects
    in the code files.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the PSS application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BrownField Airline is one of the fastest growing low-cost, regional airlines,
    flying directly to more than 100 destinations from its hub. As a start-up airline,
    BrownField Airline started its operations with few destinations and few aircrafts.
    BrownField developed its home-grown PSS application to handle their passenger
    sales and services.
  prefs: []
  type: TYPE_NORMAL
- en: Business process view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This use case is considerably simplified for discussion purposes. The process
    view in the following diagram shows BrownField Airline''s end-to-end passenger
    services operations covered by the current PSS solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Business process view](img/B05447_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The current solution is automating certain customer-facing functions as well
    as certain internally facing functions. There are two internally facing functions,
    **Pre-flight** and **Post-flight**. **Pre-flight** functions include the planning
    phase, used for preparing flight schedules, plans, aircrafts, and so on. **Post-flight**
    functions are used by the back office for revenue management, accounting, and
    so on. The **Search** and **Reserve** functions are part of the online seat reservation
    process, and the **Check-in** function is the process of accepting passengers
    at the airport. The **Check-in** function is also accessible to the end users
    over the Internet for online check-in.
  prefs: []
  type: TYPE_NORMAL
- en: The cross marks at the beginning of the arrows in the preceding diagram indicate
    that they are disconnected, and occur at different timelines. For example, passengers
    are allowed to book 360 days in advance, whereas the check-in generally happens
    24 hours before flight departure.
  prefs: []
  type: TYPE_NORMAL
- en: Functional view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram shows the functional building blocks of BrownField Airline''s
    PSS landscape. Each business process and its related subfunctions are represented
    in a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functional view](img/B05447_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each subfunction shown in the preceding diagram explains its role in the overall
    business process. Some subfunctions participate in more than one business process.
    For example, inventory is used in both search as well as in booking. To avoid
    any complication, this is not shown in the diagram. Data management and cross-cutting
    subfunctions are used across many business functions.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to effectively manage the end-to-end passenger operations, BrownField
    had developed an in-house PSS application, almost ten years back. This well-architected
    application was developed using Java and JEE technologies combined with the best-of-the-breed
    open source technologies available at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall architecture and technologies are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architectural view](img/B05447_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The architecture has well-defined boundaries. Also, different concerns are separated
    into different layers. The web application was developed as an *N*-tier, component-based
    modular system. The functions interact with each other through well-defined service
    contracts defined in the form of EJB endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Design view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application has many logical functional groupings or subsystems. Further,
    each subsystem has many components organized as depicted in the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design view](img/B05447_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Subsystems interact with each other through remote EJB calls using the IIOP
    protocol. The transactional boundaries span across subsystems. Components within
    the subsystems communicate with each other through local EJB component interfaces.
    In theory, since subsystems use remote EJB endpoints, they could run on different
    physically separated application servers. This was one of the design goals.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation view in the following diagram showcases the internal organization
    of a subsystem and its components. The purpose of the diagram is also to show
    the different types of artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation view](img/B05447_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the gray-shaded boxes are treated as different Maven
    projects, and translate into physical artifacts. Subsystems and components are
    designed adhering to the *program to an interface* principle. Interfaces are packaged
    as separate JAR files so that clients are abstracted from the implementations.
    The complexity of the business logic is buried in the domain model. Local EJBs
    are used as component interfaces. Finally, all subsystems are packaged into a
    single all-in-one EAR, and deployed in the application server.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application''s initial deployment was simple and straightforward as shown
    in the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deployment view](img/B05447_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The web modules and business modules were deployed into separate application
    server clusters. The application was scaled horizontally by adding more and more
    application servers to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Zero downtime deployments were handled by creating a standby cluster, and gracefully
    diverting the traffic to that cluster. The standby cluster is destroyed once the
    primary cluster is patched with the new version and brought back to service. Most
    of the database changes were designed for backward compatibility, but breaking
    changes were promoted with application outages.
  prefs: []
  type: TYPE_NORMAL
- en: Death of the monolith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PSS application was performing well, successfully supporting all business
    requirements as well as the expected service levels. The system had no issues
    in scaling with the organic growth of the business in the initial years.
  prefs: []
  type: TYPE_NORMAL
- en: The business has seen tremendous growth over a period of time. The fleet size
    increased significantly, and new destinations got added to the network. As a result
    of this rapid growth, the number of bookings has gone up, resulting in a steep
    increase in transaction volumes, up to 200 - to 500 - fold of what was originally
    estimated.
  prefs: []
  type: TYPE_NORMAL
- en: Pain points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rapid growth of the business eventually put the application under pressure.
    Odd stability issues and performance issues surfaced. New application releases
    started breaking the working code. Moreover, the cost of change and the speed
    of delivery started impacting the business operations profoundly.
  prefs: []
  type: TYPE_NORMAL
- en: 'An end-to-end architecture review was ordered, and it exposed the weaknesses
    of the system as well as the root causes of many failures, which were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stability**: The stability issues are primarily due to stuck threads, which
    limit the application server''s capability to accept more transactions. The stuck
    threads are mainly due to database table locks. Memory issues are another contributor
    to the stability issues. There were also issues in certain resource intensive
    operations that were impacting the whole application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Outages**: The outage window increased largely because of the increase in
    server startup time. The root cause of this issue boiled down to the large size
    of the EAR. Message pile up during any outage windows causes heavy usage of the
    application immediately after an outage window. Since everything is packaged in
    a single EAR, any small application code change resulted in full redeployment.
    The complexity of the zero downtime deployment model described earlier, together
    with the server startup times increased both the number of outages and their duration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agility**: The complexity of the code also increased considerably over time,
    partially due to the lack of discipline in implementing the changes. As a result,
    changes became harder to implement. Also, the impact analysis became too complex
    to perform. As a result, inaccurate impact analysis often led to fixes that broke
    the working code. The application build time went up severely, from a few minutes
    to hours, causing unacceptable drops in development productivity. The increase
    in build time also led to difficulty in build automation, and eventually stopped
    **continuous integration** (**CI**) and unit testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop gap fix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Performance issues were partially addressed by applying the Y-axis scale method
    in the scale cube, as described in [Chapter 1](ch01.html "Chapter 1. Demystifying
    Microservices"), *Demystifying Microservices*. The all-encompassing EAR is deployed
    into multiple disjoint clusters. A software proxy was installed to selectively
    route the traffic to designated clusters as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stop gap fix](img/B05447_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This helped BrownField's IT to scale the application servers. Therefore, the
    stability issues were controlled. However, this soon resulted in a bottleneck
    at the database level. Oracle's **Real Application Cluster** (**RAC**) was implemented
    as a solution to this problem at the database layer.
  prefs: []
  type: TYPE_NORMAL
- en: This new scaling model reduced the stability issues, but at a premium of increased
    complexity and cost of ownership. The technology debt also increased over a period
    of time, leading to a state where a complete rewrite was the only option for reducing
    this technology debt.
  prefs: []
  type: TYPE_NORMAL
- en: Retrospection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the application was well-architected, there was a clear segregation
    between the functional components. They were loosely coupled, programmed to interfaces,
    with access through standards-based interfaces, and had a rich domain model.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious question is, how come such a well-architected application failed
    to live up to the expectations? What else could the architects have done?
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand what went wrong over a period of time. In the
    context of this book, it is also important to understand how microservices can
    avoid the recurrence of these scenarios. We will examine some of these scenarios
    in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Shared data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost all functional modules require reference data such as the airline's details,
    airplane details, a list of airports and cities, countries, currencies, and so
    on. For example, fare is calculated based on the point of origin (city), a flight
    is between an origin and a destination (airports), check-in is at the origin airport
    (airport), and so on. In some functions, the reference data is a part of the information
    model, whereas in some other functions, it is used for validation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Much of this reference data is neither fully static nor fully dynamic. Addition
    of a country, city, airport, or the like could happen when the airline introduces
    new routes. Aircraft reference data could change when the airline purchases a
    new aircraft, or changes an existing airplane's seat configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the common usage scenarios of reference data is to filter the operational
    data based on certain reference data. For instance, say a user wishes to see all
    the flights to a country. In this case, the flow of events could be as follows:
    find all the cities in the selected country, then all airports in the cities,
    and then fire a request to get all the flights to the list of resulting airports
    identified in that country.'
  prefs: []
  type: TYPE_NORMAL
- en: The architects considered multiple approaches when designing the system. Separating
    the reference data as an independent subsystem like other subsystems was one of
    the options considered, but this could lead to performance issues. The team took
    the decision to follow an exception approach for handling reference data as compared
    to other transactions. Considering the nature of the query patterns discussed
    earlier, the approach was to use the reference data as a shared library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the subsystems were allowed to access the reference data directly
    using pass-by-reference semantic data instead of going through the EJB interfaces.
    This also meant that irrespective of the subsystems, hibernate entities could
    use the reference data as a part of their entity relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shared data](img/B05447_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As depicted in the preceding diagram, the **Booking** entity in the reservation
    subsystem is allowed to use the reference data entities, in this case **Airport**,
    as part of their relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Single database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though enough segregation was enforced at the middle tier, all functions pointed
    to a single database, even to the same database schema. The single schema approach
    opened a plethora of issues.
  prefs: []
  type: TYPE_NORMAL
- en: Native queries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Hibernate framework provides a good abstraction over the underlying databases.
    It generates efficient SQL statements, in most of the cases targeting the database
    using specific dialects. However, sometimes, writing native JDBC SQLs offers better
    performance and resource efficiency. In some cases, using native database functions
    gives an even better performance.
  prefs: []
  type: TYPE_NORMAL
- en: The single database approach worked well at the beginning. But over a period
    of time, it opened up a loophole for the developers by connecting database tables
    owned by different subsystems. Native JDBC SQL was a good vehicle for doing this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows an example of connecting two tables owned by two
    subsystems using a native JDBC SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Native queries](img/B05447_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, the Accounting component requires all booking
    records for a day, for a given city, from the Booking component to process the
    day-end billing. The subsystem-based design enforces Accounting to make a service
    call to Booking to get all booking records for a given city. Assume this results
    in *N* booking records. Now, for each booking record, Accounting has to execute
    a database call to find the applicable rules based on the fare code attached to
    each booking record. This could result in *N+1* JDBC calls, which is inefficient.
    Workarounds, such as batch queries or parallel and batch executions, are available,
    but this would lead to increased coding efforts and higher complexity. The developers
    tackled this issue with a native JDBC query as an easy-to-implement shortcut.
    Essentially, this approach could reduce the number of calls from *N+1* to a single
    database call, with minimal coding efforts.
  prefs: []
  type: TYPE_NORMAL
- en: This habit continued with many JDBC native queries connecting tables across
    multiple components and subsystems. This resulted not only in tightly coupled
    components, but also led to undocumented, hard-to-detect code.
  prefs: []
  type: TYPE_NORMAL
- en: Stored procedures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another issue that surfaced as a result of the use of a single database was
    the use of complex stored procedures. Some of the complex data-centric logic written
    at the middle layer was not performing well, causing slow response, memory issues,
    and thread-blocking issues.
  prefs: []
  type: TYPE_NORMAL
- en: In order to address this problem, the developers took the decision to move some
    of the complex business logic from the middle tier to the database tier by implementing
    the logic directly within the stored procedures. This decision resulted in better
    performance of some of the transactions, and removed some of the stability issues.
    More and more procedures were added over a period of time. However, this eventually
    broke the application's modularity.
  prefs: []
  type: TYPE_NORMAL
- en: Domain boundaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though the domain boundaries were well established, all the components were
    packaged as a single EAR file. Since all the components were set to run on a single
    container, there was no stopping the developers referencing objects across these
    boundaries. Over a period of time, the project teams changed, delivery pressure
    increased, and the complexity grew tremendously. The developers started looking
    for quick solutions rather than the right ones. Slowly, but steadily, the modular
    nature of the application went away.
  prefs: []
  type: TYPE_NORMAL
- en: 'As depicted in the following diagram, hibernate relationships were created
    across subsystem boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Domain boundaries](img/B05447_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Microservices to the rescue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are not many improvement opportunities left to support the growing demand
    of BrownField Airline's business. BrownField Airline was looking to re-platform
    the system with an evolutionary approach rather than a revolutionary model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices is an ideal choice in these situations—for transforming a legacy
    monolithic application with minimal disruption to the business:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices to the rescue](img/B05447_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, the objective is to move to a microservices-based
    architecture aligned to the business capabilities. Each microservice will hold
    the data store, the business logic, and the presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: The approach taken by BrownField Airline is to build a number of web portal
    applications targeting specific user communities such as customer facing, front
    office, and back office. The advantage of this approach lies in the flexibility
    for modeling, and also in the possibility to treat different communities differently.
    For example, the policies, architecture, and testing approaches for the Internet
    facing layer are different from the intranet-facing web application. Internet-facing
    applications may take advantage of **CDNs** (**Content Delivery Networks**) to
    move pages as close to the customer as possible, whereas intranet applications
    could serve pages directly from the data center.
  prefs: []
  type: TYPE_NORMAL
- en: The business case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building business cases for migration, one of the commonly asked questions
    is "how does the microservices architecture avoid resurfacing of the same issues
    in another five years' time?"
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices offers a full list of benefits, which you learned in [Chapter
    1](ch01.html "Chapter 1. Demystifying Microservices"), *Demystifying Microservices*,
    but it is important to list a few here that are critical in this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service dependencies**: While migrating from monolithic applications to microservices,
    the dependencies are better known, and therefore the architects and developers
    are much better placed to avoid breaking dependencies and to future-proof dependency
    issues. Lessons from the monolithic application helps architects and developers
    to design a better system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physical boundaries**: Microservices enforce physical boundaries in all areas
    including the data store, the business logic, and the presentation layer. Access
    across subsystems or microservices are truly restricted due to their physical
    isolation. Beyond the physical boundaries, they could even run on different technologies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selective scaling**: Selective scale out is possible in microservices architecture.
    This provides a much more cost-effective scaling mechanism compared to the Y-scale
    approach used in the monolithic scenario.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technology obsolescence**: Technology migrations could be applied at a microservices
    level rather than at the overall application level. Therefore, it does not require
    a humongous investment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plan the evolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not simple to break an application that has millions of lines of code,
    especially if the code has complex dependencies. How do we break it? More importantly,
    where do we start, and how do we approach this problem?
  prefs: []
  type: TYPE_NORMAL
- en: Evolutionary approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best way to address this problem is to establish a transition plan, and
    gradually migrate the functions as microservices. At every step, a microservice
    will be created outside of the monolithic application, and traffic will be diverted
    to the new service as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Evolutionary approach](img/B05447_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to run this migration successfully, a number of key questions need
    to be answered from the transition point of view:'
  prefs: []
  type: TYPE_NORMAL
- en: Identification of microservices' boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritizing microservices for migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling data synchronization during the transition phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user interface integration, working with old and new user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of reference data in the new system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing strategy to ensure the business capabilities are intact and correctly
    reproduced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identification of any prerequisites for microservice development such as microservices
    capabilities, frameworks, processes, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identification of microservices boundaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first and foremost activity is to identify the microservices' boundaries.
    This is the most interesting part of the problem, and the most difficult part
    as well. If identification of the boundaries is not done properly, the migration
    could lead to more complex manageability issues.
  prefs: []
  type: TYPE_NORMAL
- en: Like in SOA, a service decomposition is the best way to identify services. However,
    it is important to note that decomposition stops at a business capability or bounded
    context. In SOA, service decomposition goes further into an atomic, granular service
    level.
  prefs: []
  type: TYPE_NORMAL
- en: A top-down approach is typically used for domain decomposition. The bottom-up
    approach is also useful in the case of breaking an existing system, as it can
    utilize a lot of practical knowledge, functions, and behaviors of the existing
    monolithic application.
  prefs: []
  type: TYPE_NORMAL
- en: The previous decomposition step will give a potential list of microservices.
    It is important to note that this isn't the final list of microservices, but it
    serves as a good starting point. We will run through a number of filtering mechanisms
    to get to a final list. The first cut of functional decomposition will, in this
    case, be similar to the diagram shown under the functional view introduced earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Analyze dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to analyze the dependencies between the initial set of candidate
    microservices that we created in the previous section. At the end of this activity,
    a dependency graph will be produced.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A team of architects, business analysts, developers, release management and
    support staff is required for this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to produce a dependency graph is to list out all the components of
    the legacy system and overlay dependencies. This could be done by combining one
    or more of the approaches listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the manual code and regenerating dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the experience of the development team to regenerate dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Maven dependency graph. There are a number of tools we could use to
    regenerate the dependency graph, such as PomExplorer, PomParser, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using performance engineering tools such as AppDynamics to identify the call
    stack and roll up dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us assume that we reproduce the functions and their dependencies as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyze dependencies](img/B05447_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are many dependencies going back and forth between different modules.
    The bottom layer shows cross-cutting capabilities that are used across multiple
    modules. At this point, the modules are more like spaghetti than autonomous units.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to analyze these dependencies, and come up with a better, simplified
    dependency map.
  prefs: []
  type: TYPE_NORMAL
- en: Events as opposed to query
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Dependencies could be query-based or event-based. Event-based is better for
    scalable systems. Sometimes, it is possible to convert query-based communications
    to event-based ones. In many cases, these dependencies exist because either the
    business organizations are managed like that, or by virtue of the way the old
    system handled the business scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous diagram, we can extract the Revenue Management and the Fares
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Events as opposed to query](img/B05447_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Revenue Management is a module used for calculating optimal fare values, based
    on the booking demand forecast. In case of a fare change between an origin and
    a destination, Update Fare on the Fare module is called by Revenue Management
    to update the respective fares in the Fare module.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate way of thinking is that the Fare module is subscribed to Revenue
    Management for any changes in fares, and Revenue Management publishes whenever
    there is a fare change. This reactive programming approach gives an added flexibility
    by which the Fares and the Revenue Management modules could stay independent,
    and connect them through a reliable messaging system. This same pattern could
    be applied in many other scenarios from Check-In to the Loyalty and Boarding modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, examine the scenario of CRM and Booking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Events as opposed to query](img/B05447_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This scenario is slightly different from the previously explained scenario.
    The CRM module is used to manage passenger complaints. When CRM receives a complaint,
    it retrieves the corresponding passenger''s Booking data. In reality, the number
    of complaints are negligibly small when compared to the number of bookings. If
    we blindly apply the previous pattern where CRM subscribes to all bookings, we
    will find that it is not cost effective:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Events as opposed to query](img/B05447_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Examine another scenario between the Check-in and Booking modules. Instead of
    Check-in calling the Get Bookings service on Booking, can Check-in listen to booking
    events? This is possible, but the challenge here is that a booking can happen
    360 days in advance, whereas Check-in generally starts only 24 hours before the
    fight departure. Duplicating all bookings and booking changes in the Check-in
    module 360 days in advance would not be a wise decision as Check-in does not require
    this data until 24 hours before the flight departure.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate option is that when check-in opens for a flight (24 hours before
    departure), Check-in calls a service on the Booking module to get a snapshot of
    the bookings for a given flight. Once this is done, Check-in could subscribe for
    booking events specifically for that flight. In this case, a combination of query-based
    as well as event-based approaches is used. By doing so, we reduce the unnecessary
    events and storage apart from reducing the number of queries between these two
    services.
  prefs: []
  type: TYPE_NORMAL
- en: In short, there is no single policy that rules all scenarios. Each scenario
    requires logical thinking, and then the most appropriate pattern is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Events as opposed to synchronous updates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Apart from the query model, a dependency could be an update transaction as
    well. Consider the scenario between Revenue Management and Booking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Events as opposed to synchronous updates](img/B05447_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to do a forecast and analysis of the current demand, Revenue Management
    requires all bookings across all flights. The current approach, as depicted in
    the dependency graph, is that Revenue Management has a schedule job that calls
    Get Booking on Booking to get all incremental bookings (new and changed) since
    the last synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to send new bookings and the changes in bookings
    as soon as they take place in the Booking module as an asynchronous push. The
    same pattern could be applied in many other scenarios such as from Booking to
    Accounting, from Flight to Inventory, and also from Flight to Booking. In this
    approach, the source service publishes all state-change events to a topic. All
    interested parties could subscribe to this event stream and store locally. This
    approach removes many hard wirings, and keeps the systems loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependency is depicted in the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Events as opposed to synchronous updates](img/B05447_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case depicted in the preceding diagram, we changed both dependencies
    and converted them to asynchronous events.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last case to analyze is the Update Inventory call from the Booking module
    to the Inventory module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Events as opposed to synchronous updates](img/B05447_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When a booking is completed, the inventory status is updated by depleting the
    inventory stored in the Inventory service. For example, when there are 10 economy
    class seats available, at the end of the booking, we have to reduce it to 9\.
    In the current system, booking and updating inventory are executed within the
    same transaction boundaries. This is to handle a scenario in which there is only
    one seat left, and multiple customers are trying to book. In the new design, if
    we apply the same event-driven pattern, sending the inventory update as an event
    to Inventory may leave the system in an inconsistent state. This needs further
    analysis, which we will address later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge requirements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In many cases, the targeted state could be achieved by taking another look
    at the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Challenge requirements](img/B05447_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two Validate Flight calls, one from Booking and another one from
    the Search module. The Validate Flight call is to validate the input flight data
    coming from different channels. The end objective is to avoid incorrect data stored
    or serviced. When a customer does a flight search, say "BF100", the system validates
    this flight to see the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether this is a valid flight?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the flight exists on that particular date?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any booking restrictions set on this flight?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternate way of solving this is to adjust the inventory of the flight based
    on these given conditions. For example, if there is a restriction on the flight,
    update the inventory as zero. In this case, the intelligence will remain with
    Flight, and it keeps updating the inventory. As far as Search and Booking are
    concerned, both just look up the inventory instead of validating flights for every
    request. This approach is more efficient as compared to the original approach.
  prefs: []
  type: TYPE_NORMAL
- en: Next we will review the Payment use case. Payment is typically a disconnected
    function due to the nature of security constraints such as PCIDSS-like standards.
    The most obvious way to capture a payment is to redirect a browser to a payment
    page hosted in the Payment service. Since card handling applications come under
    the purview of PCIDSS, it is wise to remove any direct dependencies from the Payment
    service. Therefore, we can remove the Booking-to-Payment direct dependency, and
    opt for a UI-level integration.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge service boundaries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we will review some of the service boundaries based on the
    requirements and dependency graph, considering Check-in and its dependencies to
    Seating and Baggage.
  prefs: []
  type: TYPE_NORMAL
- en: The Seating function runs a few algorithms based on the current state of the
    seat allocation in the airplane, and finds out the best way to position the next
    passenger so that the weight and balance requirements can be met. This is based
    on a number of predefined business rules. However, other than Check-in, no other
    module is interested in the Seating function. From a business capability perspective,
    Seating is just a function of Check-in, not a business capability by itself. Therefore,
    it is better to embed this logic inside Check-in itself.
  prefs: []
  type: TYPE_NORMAL
- en: The same is applicable to Baggage as well. BrownField has a separate baggage
    handling system. The Baggage function in the PSS context is to print the baggage
    tag as well as store the baggage data against the Check-in records. There is no
    business capability associated with this particular functionality. Therefore,
    it is ideal to move this function to Check-in itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Book, Search, and Inventory functions, after redesigning, are shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Challenge service boundaries](img/B05447_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, Inventory and Search are more supporting functions of the Booking
    module. They are not aligned with any of the business capabilities as such. Similar
    to the previous judgement, it is ideal to move both the Search and Inventory functions
    to Booking. Assume, for the time being, that Search, Inventory, and Booking are
    moved to a single microservice named Reservation.
  prefs: []
  type: TYPE_NORMAL
- en: As per the statistics of BrownField, search transactions are 10 times more frequent
    than the booking transactions. Moreover, search is not a revenue-generating transaction
    when compared to booking. Due to these reasons, we need different scalability
    models for search and booking. Booking should not get impacted if there is a sudden
    surge of transactions in search. From the business point of view, dropping a search
    transaction in favor of saving a valid booking transaction is more acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a polyglot requirement, which overrules the business
    capability alignment. In this case, it makes more sense to have Search as a service
    separate from the Booking service. Let us assume that we remove Search. Only Inventory
    and Booking remain under Reservation. Now Search has to hit back to Reservation
    to perform inventory searches. This could impact the booking transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Challenge service boundaries](img/B05447_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A better approach is to keep Inventory along with the Booking module, and keep
    a read-only copy of the inventory under Search, while continuously synchronizing
    the inventory data over a reliable messaging system. Since both Inventory and
    Booking are collocated, this will also solve the need to have two-phase commits.
    Since both of them are local, they could work well with local transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now challenge the Fare module design. When a customer searches for a
    flight between A and B for a given date, we would like to show the flights and
    fares together. That means that our read-only copy of inventory can also combine
    both fares as well as inventory. Search will then subscribe to Fare for any fare
    change events. The intelligence still stays with the Fare service, but it keeps
    sending fare updates to the cached fare data under Search.
  prefs: []
  type: TYPE_NORMAL
- en: Final dependency graph
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are still a few synchronized calls, which, for the time being, we will
    keep as they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'By applying all these changes, the final dependency diagram will look like
    the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Final dependency graph](img/B05447_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can safely consider each box in the preceding diagram as a microservice.
    We have nailed down many dependencies, and modeled many of them as asynchronous
    as well. The overall system is more or less designed in the reactive style. There
    are still some synchronized calls shown in the diagram with bold lines, such as
    Get Bulk from Check-In, Get Booking from CRM, and Get Fare from Booking. These
    synchronous calls are essentially required as per the trade-off analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing microservices for migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have identified a first-cut version of our microservices-based architecture.
    As the next step, we will analyze the priorities, and identify the order of migration.
    This could be done by considering multiple factors explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency**: One of the parameters for deciding the priority is the dependency
    graph. From the service dependency graph, services with less dependency or no
    dependency at all are easy to migrate, whereas complex dependencies are way harder.
    Services with complex dependencies will also need dependent modules to be migrated
    along with them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accounting, Loyalty, CRM, and Boarding have less dependencies as compared to
    Booking and Check-in. Modules with high dependencies will also have higher risks
    in their migration.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction volume**: Another parameter that can be applied is analyzing
    the transaction volumes. Migrating services with the highest transaction volumes
    will relieve the load on the existing system. This will have more value from an
    IT support and maintenance perspective. However, the downside of this approach
    is the higher risk factor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As stated earlier, Search requests are ten times higher in volume as compared
    to Booking requests. Requests for Check-in are the third-highest in volume transaction
    after Search and Booking.
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource utilization**: Resource utilization is measured based on the current
    utilizations such as CPU, memory, connection pools, thread pools, and so on. Migrating
    resource intensive services out of the legacy system provides relief to other
    services. This helps the remaining modules to function better.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flight, Revenue Management, and Accounting are resource-intensive services,
    as they involve data-intensive transactions such as forecasting, billing, flight
    schedule changes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity**: Complexity is perhaps measured in terms of the business logic
    associated with a service such as function points, lines of code, number of tables,
    number of services, and others. Less complex modules are easy to migrate as compared
    to the more complex ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booking is extremely complex as compared to the Boarding, Search, and Check-in
    services.
  prefs: []
  type: TYPE_NORMAL
- en: '**Business criticality**: The business criticality could be either based on
    revenue or customer experience. Highly critical modules deliver higher business
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booking is the most revenue-generating service from the business stand point,
    whereas Check-in is business critical as it could lead to flight departure delays,
    which could lead to revenue loss as well as customer dissatisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Velocity of changes**: Velocity of change indicates the number of change
    requests targeting a function in a short time frame. This translates to speed
    and agility of delivery. Services with high velocity of change requests are better
    candidates for migration as compared to stable modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistics show that Search, Booking, and Fares go through frequent changes,
    whereas Check-in is the most stable function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Innovation**: Services that are part of a disruptive innovative process need
    to get priority over back office functions that are based on more established
    business processes. Innovations in legacy systems are harder to achieve as compared
    to applying innovations in the microservices world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the innovations are around Search, Booking, Fares, Revenue Management,
    and Check-in as compared to back office Accounting.
  prefs: []
  type: TYPE_NORMAL
- en: Based on BrownField's analysis, Search has the highest priority, as it requires
    innovation, has high velocity of changes, is less business critical, and gives
    better relief for both business and IT. The Search service has minimal dependency
    with no requirements to synchronize data back to the legacy system.
  prefs: []
  type: TYPE_NORMAL
- en: Data synchronization during migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the transition phase, the legacy system and the new microservices will
    run in parallel. Therefore, it is important to keep the data synchronized between
    the two systems.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest option is to synchronize the data between the two systems at the
    database level by using any data synchronization tool. This approach works well
    when both the old and the new systems are built on the same data store technologies.
    The complexity will be higher if the data store technologies are different. The
    second problem with this approach is that we allow a backdoor entry, hence exposing
    the microservices' internal data store outside. This is against the principle
    of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take this on a case-by-case basis before we can conclude with a generic
    solution. The following diagram shows the data migration and synchronization aspect
    once Search is taken out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data synchronization during migration](img/B05447_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let us assume that we use a NoSQL database for keeping inventory and fares under
    the Search service. In this particular case, all we need is the legacy system
    to supply data to the new service using asynchronous events. We will have to make
    some changes in the existing system to send the fare changes or any inventory
    changes as events. The Search service then accepts these events, and stores them
    locally into the local NoSQL store.
  prefs: []
  type: TYPE_NORMAL
- en: This is a bit more tedious in the case of the complex Booking service.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the new Booking microservice sends the inventory change events
    to the Search service. In addition to this, the legacy application also has to
    send the fare change events to Search. Booking will then store the new Booking
    service in its My SQL data store.
  prefs: []
  type: TYPE_NORMAL
- en: '![Data synchronization during migration](img/B05447_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The most complex piece, the Booking service, has to send the booking events
    and the inventory events back to the legacy system. This is to ensure that the
    functions in the legacy system continue to work as before. The simplest approach
    is to write an update component which accepts the events and updates the old booking
    records table so that there are no changes required in the other legacy modules.
    We will continue this until none of the legacy components are referring the booking
    and inventory data. This will help us minimize changes in the legacy system, and
    therefore, reduce the risk of failures.
  prefs: []
  type: TYPE_NORMAL
- en: In short, a single approach may not be sufficient. A multi-pronged approach
    based on different patterns is required.
  prefs: []
  type: TYPE_NORMAL
- en: Managing reference data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the biggest challenges in migrating monolithic applications to microservices
    is managing reference data. A simple approach is to build the reference data as
    another microservice itself as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing reference data](img/B05447_04_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, whoever needs reference data should access it through the microservice
    endpoints. This is a well-structured approach, but could lead to performance issues
    as encountered in the original legacy system.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate approach is to have reference data as a microservice service for
    all the admin and CRUD functions. A near cache will then be created under each
    service to incrementally cache data from the master services. A thin reference
    data access proxy library will be embedded in each of these services. The reference
    data access proxy abstracts whether the data is coming from cache or from a remote
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is depicted in the next diagram. The master node in the given diagram
    is the actual reference data microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing reference data](img/B05447_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The challenge is to synchronize the data between the master and the slave. A
    subscription mechanism is required for those data caches that change frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach is to replace the local cache with an in-memory data grid,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing reference data](img/B05447_04_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reference data microservice will write to the data grid, whereas the proxy
    libraries embedded in other services will have read-only APIs. This eliminates
    the requirement to have subscription of data, and is much more efficient and consistent.
  prefs: []
  type: TYPE_NORMAL
- en: User interfaces and web applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the transition phase, we have to keep both the old and new user interfaces
    together. There are three general approaches usually taken in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first approach is to have the old and new user interfaces as separate user
    applications with no link between them, as depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User interfaces and web applications](img/B05447_04_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A user signs in to the new application as well as into the old application,
    much like two different applications, with no **single sign-on** (**SSO**) between
    them. This approach is simple, and there is no overhead. In most of the cases,
    this may not be acceptable to the business unless it is targeted at two different
    user communities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach is to use the legacy user interface as the primary application,
    and then transfer page controls to the new user interfaces when the user requests
    pages of the new application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User interfaces and web applications](img/B05447_04_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, since the old and the new applications are web-based applications
    running in a web browser window, users will get a seamless experience. SSO has
    to be implemented between the old and the new user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third approach is to integrate the existing legacy user interface directly
    to the new microservices backend, as shown in the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User interfaces and web applications](img/B05447_04_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the new microservices are built as headless applications with
    no presentation layer. This could be challenging, as it may require many changes
    in the old user interface such as introducing service calls, data model conversions,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue in the last two cases is how to handle the authentication of resources
    and services.
  prefs: []
  type: TYPE_NORMAL
- en: Session handling and security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assume that the new services are written based on Spring Security with a token-based
    authorization strategy, whereas the old application uses a custom-built authentication
    with its local identity store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how to integrate between the old and the new services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Session handling and security](img/B05447_04_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The simplest approach, as shown in the preceding diagram, is to build a new
    identity store with an authentication service as a new microservice using Spring
    Security. This will be used for all our future resource and service protections,
    for all microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The existing user interface application authenticates itself against the new
    authentication service, and secures a token. This token will be passed to the
    new user interface or new microservice. In both cases, the user interface or microservice
    will make a call to the authentication service to validate the given token. If
    the token is valid, then the UI or microservice accepts the call.
  prefs: []
  type: TYPE_NORMAL
- en: The catch here is that the legacy identity store has to be synchronized with
    the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Test strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important question to answer from a testing point of view is how can we
    ensure that all functions work in the same way as before the migration?
  prefs: []
  type: TYPE_NORMAL
- en: Integration test cases should be written for the services that are getting migrated
    before the migration or refactoring. This ensures that once migrated, we get the
    same expected result, and the behavior of the system remains the same. An automated
    regression test pack has to be in place, and has to be executed every time we
    make a change in the new or old system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, for each service we need one test against the EJB
    endpoint, and another one against the microservices endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Test strategy](img/B05447_04_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building ecosystem capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we embark on actual migration, we have to build all of the microservice's
    capabilities mentioned under the capability model, as documented in [Chapter 3](ch03.html
    "Chapter 3. Applying Microservices Concepts"), *Applying Microservices Concepts*.
    These are the prerequisites for developing microservices-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these capabilities, certain application functions are also required
    to be built upfront such as reference data, security and SSO, and Customer and
    Notification. A data warehouse or a data lake is also required as a prerequisite.
    An effective approach is to build these capabilities in an incremental fashion,
    delaying development until it is really required.
  prefs: []
  type: TYPE_NORMAL
- en: Migrate modules only if required
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have examined approaches and steps for transforming
    from a monolithic application to microservices. It is important to understand
    that it is not necessary to migrate all modules to the new microservices architecture,
    unless it is really required. A major reason is that these migrations incur cost.
  prefs: []
  type: TYPE_NORMAL
- en: We will review a few such scenarios here. BrownField has already taken a decision
    to use an external revenue management system in place of the PSS revenue management
    function. BrownField is also in the process of centralizing their accounting functions,
    and therefore, need not migrate the accounting function from the legacy system.
    Migration of CRM does not add much value at this point to the business. Therefore,
    it is decided to keep the CRM in the legacy system itself. The business has plans
    to move to a SaaS-based CRM solution as part of their cloud strategy. Also note
    that stalling the migration halfway through could seriously impact the complexity
    of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Target architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The architecture blueprint shown in the following diagram consolidates earlier
    discussions into an architectural view. Each block in the diagram represents a
    microservice. The shaded boxes are core microservices, and the others are supporting
    microservices. The diagram also shows the internal capabilities of each microservice.
    User management is moved under security in the target architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Target architecture](img/B05447_04_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each service has its own architecture, typically consisting of a presentation
    layer, one or more service endpoints, business logic, business rules, and database.
    As we can see, we use different selections of databases that are more suitable
    for each microservice. Each one is autonomous with minimal orchestration between
    the services. Most of the services interact with each other using the service
    endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Internal layering of microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will further explore the internal structure of microservices.
    There is no standard to be followed for the internal architecture of a microservice.
    The rule of thumb is to abstract realizations behind simple service endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical structure would look like the one shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Internal layering of microservices](img/B05447_04_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The UI accesses REST services through a service gateway. The API gateway may
    be one per microservice or one for many microservices—it depends on what we want
    to do with the API gateway. There could be one or more rest endpoints exposed
    by microservices. These endpoints, in turn, connect to one of the business components
    within the service. Business components then execute all the business functions
    with the help of domain entities. A repository component is used for interacting
    with the backend data store.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestrating microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logic of the booking orchestration and the execution of rules sits within
    the Booking service. The brain is still inside the Booking service in the form
    of one or more booking business components. Internally, business components orchestrate
    private APIs exposed by other business components or even external services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Orchestrating microservices](img/B05447_04_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, the booking service internally calls to update
    the inventory of its own component other than calling the Fare service.
  prefs: []
  type: TYPE_NORMAL
- en: Is there any orchestration engine required for this activity? It depends on
    the requirements. In complex scenarios, we may have to do a number of things in
    parallel. For example, creating a booking internally applies a number of booking
    rules, it validates the fare, and it validates the inventory before creating a
    booking. We may want to execute them in parallel. In such cases, we may use Java
    concurrency APIs or reactive Java libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In extremely complex situations, we may opt for an integration framework such
    as Spring Integration or Apache Camel in embedded mode.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with other systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the microservices world, we use an API gateway or a reliable message bus
    for integrating with other non-microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Let us assume that there is another system in BrownField that needs booking
    data. Unfortunately, the system is not capable of subscribing to the booking events
    that the Booking microservice publishes. In such cases, an **Enterprise Application
    integration** (**EAI**) solution could be employed, which listens to our booking
    events, and then uses a native adaptor to update the database.
  prefs: []
  type: TYPE_NORMAL
- en: Managing shared libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Certain business logic is used in more than one microservice. Search and Reservation,
    in this case, use inventory rules. In such cases, these shared libraries will
    be duplicated in both the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Examine the booking scenario to understand the different exception handling
    approaches. In the following service sequence diagram, there are three lines marked
    with a cross mark. These are the potential areas where exceptions could occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling exceptions](img/B05447_04_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a synchronous communication between Booking and Fare. What if the Fare
    service is not available? If the Fare service is not available, throwing an error
    back to the user may cause revenue loss. An alternate thought is to trust the
    fare which comes as part of the incoming request. When we serve search, the search
    results will have the fare as well. When the user selects a flight and submits,
    the request will have the selected fare. In case the Fare service is not available,
    we trust the incoming request, and accept the Booking. We will use a circuit breaker
    and a fallback service which simply creates the booking with a special status,
    and queues the booking for manual action or a system retry.
  prefs: []
  type: TYPE_NORMAL
- en: What if creating the booking fails? If creating a booking fails unexpectedly,
    a better option is to throw a message back to the user. We could try alternative
    options, but that could increase the overall complexity of the system. The same
    is applicable for inventory updates.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of creating a booking and updating the inventory, we avoid a situation
    where a booking is created, and an inventory update somehow fails. As the inventory
    is critical, it is better to have both, create booking and update inventory, to
    be in a local transaction. This is possible as both components are under the same
    subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider the Check-in scenario, Check-in sends an event to Boarding and
    Booking as shown in the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling exceptions](img/B05447_04_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Consider a scenario where the Check-in services fail immediately after the Check-in
    Complete event is sent out. The other consumers processed this event, but the
    actual check-in is rolled back. This is because we are not using a two-phase commit.
    In this case, we need a mechanism for reverting that event. This could be done
    by catching the exception, and sending another Check-in Cancelled event.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, note that to minimize the use of compensating transactions, sending
    the Check-in event is moved towards the end of the Check-in transaction. This
    reduces the chance of failure after sending out the event.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, what if the check-in is successful, but sending the event
    failed? We could think of two approaches. The first approach would be to invoke
    a fallback service to store it locally, and then use another sweep-and-scan program
    to send the event at a later time. It could even retry multiple times. This could
    add more complexity and may not be efficient in all cases. An alternate approach
    is to throw the exception back to the user so that the user can retry. However,
    this might not always be good from a customer engagement standpoint. On the other
    hand, the earlier option is better for the system's health. A trade-off analysis
    is required to find out the best solution for the given situation.
  prefs: []
  type: TYPE_NORMAL
- en: Target implementation view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next diagram represents the implementation view of the BrownField PSS microservices
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Target implementation view](img/B05447_04_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding diagram, we are implementing four microservices as
    an example: Search, Fare, Booking, and Check-in. In order to test the application,
    there is a website application developed using Spring MVC with Thymeleaf templates.
    The asynchronous messaging is implemented with the help of RabbitMQ. In this sample
    implementation, the default H2 database is used as the in-memory store for demonstration
    purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: The code in this section demonstrates all the capabilities highlighted in the
    *Reviewing the microservices capability model* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic implementation of the BrownField Airline''s PSS microservices system
    has five core projects as summarized in the following table. The table also shows
    the port range used for these projects to ensure consistency throughout the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Microservice | Projects | Port Range |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Book microservice | `chapter4.book` | `8060`-`8069` |'
  prefs: []
  type: TYPE_TB
- en: '| Check-in microservice | `chapter4.checkin` | `8070`-`8079` |'
  prefs: []
  type: TYPE_TB
- en: '| Fare microservice | `chapter4.fares` | `8080`-`8089` |'
  prefs: []
  type: TYPE_TB
- en: '| Search microservice | `chapter4.search` | `8090`-`8099` |'
  prefs: []
  type: TYPE_TB
- en: '| Website | `chapter4.website` | `8001` |'
  prefs: []
  type: TYPE_TB
- en: The website is the UI application for testing the PSS microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'All microservice projects in this example follow the same pattern for package
    structure as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation projects](img/B05447_04_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The different packages and their purposes are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The root folder (`com.brownfield.pss.book`) contains the default Spring Boot
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `component` package hosts all the service components where the business
    logic is implemented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `controller` package hosts the REST endpoints and the messaging endpoints.
    Controller classes internally utilize the component classes for execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `entity` package contains the JPA entity classes for mapping to the database
    tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repository classes are packaged inside the `repository` package, and are based
    on Spring Data JPA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and testing the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the steps listed next to build and test the microservices developed
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build each of the projects using Maven. Ensure that the `test` flag is switched
    off. The test programs assume other dependent services are up and running. It
    fails if the dependent services are not available. In our example, Booking and
    Fare have direct dependencies. We will learn how to circumvent this dependency
    in [Chapter 7](ch07.html "Chapter 7. Logging and Monitoring Microservices"), *Logging
    and Monitoring Microservices*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the RabbitMQ server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands in separate terminal windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The website project has a `CommandLineRunner`, which executes all the test cases
    at startup. Once all the services are successfully started, open `http://localhost:8001`
    in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser asks for basic security credentials. Use `guest` or `guest123` as
    the credentials. This example only shows the website security with a basic authentication
    mechanism. As explained in [Chapter 2](ch02.html "Chapter 2. Building Microservices
    with Spring Boot"), *Building Microservices with Spring Boot*, service-level security
    can be achieved using OAuth2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Entering the correct security credentials displays the following screen. This
    is the home screen of our BrownField PSS application:![Running and testing the
    project](img/B05447_04_42.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **SUBMIT** button invokes the Search microservice to fetch the available
    flights that meet the conditions mentioned on the screen. A few flights are pre-populated
    at the startup of the Search microservice. Edit the Search microservice code to
    feed in additional flights, if required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output screen with a list of flights is shown in the next screenshot. The
    **Book** link will take us to the booking screen for the selected flight:![Running
    and testing the project](img/B05447_04_43.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following screenshot shows the booking screen. The user can enter the passenger
    details, and create a booking by clicking on the **CONFIRM** button. This invokes
    the Booking microservice, and internally, the Fare service as well. It also sends
    a message back to the Search microservice:![Running and testing the project](img/B05447_04_44.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If booking is successful, the next confirmation screen is displayed with a booking
    reference number:![Running and testing the project](img/B05447_04_45.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let us test the Check-in microservice. This can be done by clicking on **CheckIn**
    in the menu at the top of the screen. Use the booking reference number obtained
    in the previous step to test Check-in. This is shown in the following screenshot:![Running
    and testing the project](img/B05447_04_46.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on the **SEARCH** button in the previous screen invokes the Booking
    microservice, and retrieves the booking information. Click on the **CheckIn**
    link to perform the check-in. This invokes the Check-in microservice:![Running
    and testing the project](img/B05447_04_47.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If check-in is successful, it displays the confirmation message, as shown in
    the next screenshot, with a confirmation number. This is done by calling the Check-in
    service internally. The Check-in service sends a message to Booking to update
    the check-in status:![Running and testing the project](img/B05447_04_48.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented and tested the BrownField PSS microservice with
    basic Spring Boot capabilities. We learned how to approach a real use case with
    a microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We examined the various stages of a real-world evolution towards microservices
    from a monolithic application. We also evaluated the pros and cons of multiple
    approaches, and the obstacles encountered when migrating a monolithic application.
    Finally, we explained the end-to-end microservices design for the use case that
    we examined. Design and implementation of a fully-fledged microservice implementation
    was also validated.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how the Spring Cloud project helps us to transform
    the developed BrownField PSS microservices to an Internet-scale deployment.
  prefs: []
  type: TYPE_NORMAL
