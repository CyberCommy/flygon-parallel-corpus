- en: Testing and Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there was only one reason to choose Android Studio over other IDEs, it could
    easily be claimed that it was due to its powerful debugging and testing tools.
    These tools range from a simple Logcat reporting to complex testing mechanisms
    based on the JUnit framework. In addition to tools to help us identify bugs in
    our code, Android Studio also has a host of very smart, performance monitoring
    tools that allow developers to fine-tune projects and maximize their efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore each of these processes in turn, beginning with simple
    inline debug calls and then moving on to the different types of JUnit tests and
    concluding by taking a look at how to monitor the performance of our apps under
    a variety of conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure a Logcat debug filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create local unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build instrumented tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record Espresso tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test UIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform remote testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stress testapps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable advanced profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record method traces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record memory allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspect Java heap dumps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspect network traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logcat filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the simplest, but nevertheless the most useful debugging, techniques
    is the simple inclusion of a Logcat filter. This can be used to report variable
    values or simply keep track of which methods are being called. This is of particular
    use when keeping track of processes that are not visibly apparent, such as services,
    broadcast receivers and callbacks that have no obvious impact on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the very simplest debug tool available, and useful when we are in a
    hurry and just want to check for a single value or event, is to include a line
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is only an on the fly solution as the output will be buried in among the
    rest of the Logcat text. Far easier to manage is to configure a Logcat filter.
    The following short exercise demonstrates how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project, or open a new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select an activity or fragment and include the following field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Select a method that you wish to examine, and add a line resembling the one
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Open the Logcat tool using *Alt* + *6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Edit Filter Configuration from the dropdown in the top-right corner,
    and complete the resultant dialog, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/63c23fbd-c557-4978-8be9-e7ab5c431338.png)'
  prefs: []
  type: TYPE_IMG
- en: Filter configuration
  prefs: []
  type: TYPE_NORMAL
- en: Run the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Logcat tool can now be used to track any value, activity, or event in the
    same fashion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is, by far, the least sophisticated manner to interrogate code as it is
    running, but it has its uses: it can be applied at any time and very quickly.
    This approach is fine for combating individual errors; once we have working code,
    we will need to test them under some well-defined conditions. This is where Android
    Studio''s JUnit-based testing system comes into its own.'
  prefs: []
  type: TYPE_NORMAL
- en: JUnit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No development project is complete until it has been thoroughly and rigorously
    tested, and Android Studio incorporates JUnit testing directly into the workspace.
    As the name suggests, the framework allows the testing of individual units of
    code. These are often individual modules but can just as likely be a single class
    or method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android Studio JUnit test framework provides for two distinct types of
    test. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Local unit tests are used to test business logic in an isolated environment
    that is not dependent on Android components or other code, although it is possible
    to mock some dependencies. These tests run on the local Java virtual machine and
    are consequently considerably faster than testing on a hardware device or emulator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instrumented tests are used when we want to test elements of the Android framework
    itself, such as how our UIs behave. These tests generate an APK file and are,
    therefore, slower to build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During the course of most development life cycles, we will need to employ both
    these techniques, and we will take a look at each in turn next.
  prefs: []
  type: TYPE_NORMAL
- en: For nearly all projects, we can expect to spend around twice the time testing
    code stability than we will testing a functionality, and we will take a look at
    both of these in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Local unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have created an Android Studio project using the project wizard, then
    the basic test case for both test types will have been created automatically.
    The wizard will also include the necessary Gradle dependencies. If you are using
    a project created any other way, you will need to create a test directory structure
    and include Gradle dependencies by hand. These steps are outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside your `module/src` directory, create a new folder alongside `src/main`
    called `src/test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this `test` directory, recreate the folder structure inside your `main`
    directory, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This directory is where you will place your test classes, and it will now be
    accessible from the IDE's project explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, add the following dependency to your `build.gradle` file if it is
    not already included:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have created your project using the wizard, then it will have included
    an example test class, `ExampleUnitTest.Java`. This class contains a single method
    for testing arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple example, but it is nevertheless a good way to take a first
    look at how unit testing works in this setting. The best way to see this, is to
    create a project using the project setup wizard or open one that was created that
    way, so that it contains the test class.
  prefs: []
  type: TYPE_NORMAL
- en: Despite their actual location on disk, test modules can be found alongside your
    regular Java modules in the IDE's project explorer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7261c9a-0dbd-4f2b-bb5c-b2324f2cf68e.png)'
  prefs: []
  type: TYPE_IMG
- en: Accessing tests from the IDE
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to see these tests in action and explore other test features
    is to doctor the `addition_isCorrect()` method so that it fails. The `assertEquals()`
    method simply compares two expressions and can be set up to fail, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the predictable output shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07cda69c-e4ba-4462-bbcf-14e5e586d632.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit test output
  prefs: []
  type: TYPE_NORMAL
- en: The preceding run tool shown has a number of useful features that can be found
    in the toolbars. In particular, the third icon down on the left allows us to automatically
    rerun a test whenever we make any changes. The main toolbar allows us to filter
    and sort passed and ignored tests as well as import and export results, which
    can be saved as HTML, XML, or a custom format.
  prefs: []
  type: TYPE_NORMAL
- en: The Click to see differences link will open a failure comparison table that
    is very useful when multiple tests fail.
  prefs: []
  type: TYPE_NORMAL
- en: Tests can be run just as other code, mostly simply with the run icon in the
    main toolbar, but the Run menu and the Run Test icons in the left gutter of the
    code editor include the option to debug and also to display a class coverage window.
    These editor icons are particularly useful, as they can be used to run individual
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The example provided uses the JUnit `assertEquals()` assertion. There are many
    similar JUnit assertions and other structures available to us, and the complete
    documentation is available at [junit.org](http://junit.org/junit4/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example is self-contained and tells us nothing about how to use
    such classes to test our application code. The following example demonstrates
    how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Java class in the default package, with a single function, like the
    one here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class in the `test` package along these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the first example, the preceding code demonstrates how we can incorporate
    our business logic within test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we find ourselves with several tests, it can become useful to have some
    control over the order in which these tests run, and particularly if we wish to
    run preparatory code at the beginning of every test run. This can be achieved
    with a series of JUnit annotations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration annotation will cause the method to run once only,
    before all the other methods in the class are called as well as failing after
    50 ms. `@Before` can be used to cause a method to execute before every other test,
    and there are equivalent `@After` and `@AfterClass` annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many other assertions and other classes available in the `org.junit`
    package and full documentation can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[junit.sourceforge.net/javadoc/org/junit/package-summary.html#package_description](http://junit.sourceforge.net/javadoc/org/junit/package-summary.html#package_description)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you will want to run the same group of test classes together. Rather
    than running each of these separately each time, a suite of tests can be recreated
    and run as one, with code similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RunWith(Suite.class)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`@SuiteClasses({`'
  prefs: []
  type: TYPE_NORMAL
- en: '`        someClassTest.class,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`          someOtherClassTest.class })`'
  prefs: []
  type: TYPE_NORMAL
- en: It is not always possible, or desirable, to test every unit in complete isolation.
    Often, we will need to test a unit's interaction with Android and other Java interfaces
    and classes. This is generally achieved by creating mock dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: As the reader will know, there are many ways to create mock objects and classes,
    from the painstaking task of building them from scratch to using ready-made third-party
    frameworks. In most cases, this second option is preferable, perhaps the only
    exception being some full-screen games that completely redefine the UI. Otherwise,
    the easiest and, probably, the best option for Android Studio users would be Mockito.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mockito is a powerful Java framework, and although it is easily incorporated
    into Android Studio, it is by no means particular to it, and many readers will
    already be familiar with it from other IDEs. There is a great deal that could
    be covered on the subject, but this would be beyond the scope of this book. Naturally,
    Mockito needs to be declared as a dependency in our `build.gradle` files, and
    this is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, it is not necessary to create mock dependencies to be able to
    make calls to the Android API. If the default return values from any `android.jar`
    method are sufficient, then we can instruct Gradle to do this by adding the following
    snippet to theAndroid section of the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Mockito provides structures to mock up most of the Java classes we might need
    to test our business logic, but, at the end of the day, we are developing an Android
    application and will need to test it on real devices and emulators. Once we are
    satisfied that our model works well in isolation, we need to see how it performs
    in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although considered separately here, instrumented tests can also be unit tests.
    There are many non-UI Android classes that we need to test against, and although
    these can be mocked up, this can be a time-consuming process, particularly when
    we know these classes are sitting there, already fully implemented on our devices
    and emulators. If we are prepared to sacrifice the fast build times of mock testing,
    then we might as well plug in our devices and boot up our emulators.
  prefs: []
  type: TYPE_NORMAL
- en: One aspect of development that is difficult to mock is UI simulation and interaction,
    and generally speaking, when we want to test our layouts against physical gestures.
    Fortunately, there are some very handy tools and features at our disposal that
    help test and optimize our designs.
  prefs: []
  type: TYPE_NORMAL
- en: Testing views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the heart of instrumented UI testing lies the Android Testing Support Library.
    This includes the JUnit APIs, a UI Automator and the Espresso testing framework.
    There is virtually nothing involved in setting Espresso up on Android Studio,
    as it is included as a dependency by default if you are working on a project generated
    by the project setup wizard. If not, you will need to add the following to your
    `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you have developer animation options, such as window and transition animation
    scales set on your test device, you will need to disable them for the duration
    of your tests for Espresso to work smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put simply, Espresso allows us to perform three essential tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify and access views and other UI elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform an activity, such as clicks and swipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate assertions to test code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The best way to see how this works is with a simple example. Similarly to unit
    tests, instrumented tests need to be placed in the correct disk location to be
    recognized by Android Studio, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\SomeApp\app\src\androidTest`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1734add4-c0ee-47f9-9762-3fb3686cf7e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Instrumented test location
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps demonstrate how we can carry out the three tasks referred
    to a moment ago:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two views, as shown in the following code, in an activity; here, the
    main activity is used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a test class in the `androidTest` directory along these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the IDE identifies Espresso term in italics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/63090807-fe26-4bc8-b3f7-9dfd947a268b.png)'
  prefs: []
  type: TYPE_IMG
- en: Italicized Espresso terms
  prefs: []
  type: TYPE_NORMAL
- en: Run the test, either from the editor's left gutter or the Run menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application will open on the test device, `string` will be typed into the
    edit box, the button will be clicked, and the activity will be finished and closed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The test results can then be viewed in the IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are one or two items that could do with pointing out in the preceding
    code, especially if one is new to Espresso. `ActivityTestRule` is used to access
    the widgets in our activity, and the call to `closeSoftKeyboard()`; the latter
    is not strictly necessary, but, as you will see if you run the test, it does precisely
    as one might imagine and closes the soft keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: When running instrumented tests, the platform makes use of a test manifest,
    which, if you have created your project from a template or are working on a sample,
    will already be included. This will be located in the following directory on disk: `\SomeApplication\app\build\intermediates\manifest\androidTest\debug`
  prefs: []
  type: TYPE_NORMAL
- en: 'Nearly all of the libraries used in these tests will need to be imported, and
    although the code editor is good at picking up on missing imports, it is also
    good to know which libraries are needed. The following is a list of those required
    for the preceding test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Hamcrest assertion matchers can be included in JUnit tests by including the
    following dependency in the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Implementation ''org.hamcrest:hamcrest-library:1.3''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Espresso provides many other actions along with typing and clicking, such as
    scrolling and clearing text. Comprehensive documentation on Espresso can be found
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[google.github.io/android-testing-support-library/docs/](http://google.github.io/android-testing-support-library/docs/)'
  prefs: []
  type: TYPE_NORMAL
- en: Testing lists and data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example uses `onView()` to identify the views we want to test
    using their ID, and this is fine for components we have already named; however,
    items in lists cannot be identified so explicitly, and, for this, we will need
    another approach. When dealing with lists, such as recycler views and spinners,
    Espresso provides the `onData()` method to identify list items.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, add a spinner as shown in the following one of your
    app activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now write a test using `onData()` to interrogate the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though you have included Hamcrest as a Gradle dependency, the studio''s
    quick-fix feature will not kick in, and the following imports will need to be
    included in the test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import static org.hamcrest.Matchers.allOf;` `import static org.hamcrest.Matchers.containsString;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import static org.hamcrest.Matchers.instanceOf;` `import static org.hamcrest.Matchers.is;`'
  prefs: []
  type: TYPE_NORMAL
- en: Recording tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section we saw how Android Studio provides a comprehensive
    set of tools for testing our code, but writing these tests is time consuming,
    and with anything other than the most trivial of projects will require many individual
    tests. Fortunately, Android Studio provides a semi-automated way to construct
    tests, using our own UI interactions to create, identify, and perform code elements
    of the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following simple exercise shows how this is done to perform the preceding
    test we just wrote by hand:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project with the spinner we created in the previous exercise, or create
    a new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Record Espresso Test from the Run menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select an item from the spinner. This will be reflected in the Record Your Test
    dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Add Assertion button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the spinner by clicking on it, and complete the dialog, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6de46e02-8ab1-43af-8cff-d7766132b123.png)'
  prefs: []
  type: TYPE_IMG
- en: The Record Your Test dialog
  prefs: []
  type: TYPE_NORMAL
- en: Save and run the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, the IDE has taken our screen gestures and converted them into
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code is perhaps not as efficient or as user friendly as it might be, but
    the time saved is probably worth it, and, at the end of the day, all our tests
    are temporary and will be done away with once we are happy with our code.
  prefs: []
  type: TYPE_NORMAL
- en: It will not have escaped the reader's notice that when running tests from the
    Select Deployment Target dialog, there is also a Cloud Testing tab. This feature
    allows us access to the Firebase Test Lab directly from the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Remote testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing an Android application for a general release, it is desirable
    to test it on as many different device configurations and platform versions as
    possible. Testing on a large number of real devices is impractical, and it would
    seem that virtual devices offer the only other option. Fortunately, Firebase provides
    a cloud-based test lab that allows us to test our apps on a wide range of real
    devices and emulators across all platform versions.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase is a powerful and fully formed, cloud-based application development
    suite with many useful features, such as file hosting and real-time crash reporting.
    For the purpose of this chapter, we will focus on just one Firebase product, the
    test lab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firebase is well catered for within the IDE, and the simplest way to get started
    is the Firebase Assistant, which can be found in the Tools menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c576bfbe-3ddf-457e-bdf3-136e6e2dd4b7.png)'
  prefs: []
  type: TYPE_IMG
- en: The Firebase assistant
  prefs: []
  type: TYPE_NORMAL
- en: Before connecting Android Studio to Firebase, first log in using your Google
    account at [https://firebase.google.com/.](https://firebase.google.com/)
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the Learn more link will allow you to connect to Firebase directly
    from the IDE. This will take you through a quick wizard/tutorial, culminating
    in the clicking of a Connect to Firebase button.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now configure our cloud-based test by opening the Run/Debug Configurations...
    dialog from the Run | Edit Configurations... menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7075bf1c-e635-40d4-8382-0c72eb078e45.png)'
  prefs: []
  type: TYPE_IMG
- en: Test configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'These tests can now be started in the same way as any other project, with the
    Run icon or menu item, and you will see from the test output a link to view an
    HTML version of the results, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0d327e3-b6f8-4344-946f-4d467aa7cfe3.png)'
  prefs: []
  type: TYPE_IMG
- en: The Firebase output
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting at this point that, although many prefer it, Firebase is
    not the only cloud available device to test Android apps, and interested readers
    should look up **Amazon Web Service** (**AWS**) Device Farm, Xamarin Test Cloud,
    Sauce Labs, Perfecto, and several others.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding methods outlined demonstrate a variety of testing techniques that
    we can apply to our code and ways that Android Studio can speed up and automate
    much of this essential, but often unexciting, aspect of development. Before moving
    on to more interesting topics, there is one other form of testing that needs a
    little explanation, and although not strictly a part of the IDE, the Application
    Exerciser Monkey is nevertheless a very useful little tool.
  prefs: []
  type: TYPE_NORMAL
- en: Stress testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android Application Exerciser Monkey is a handy command line, application
    stress tester. It works by performing (or injecting) a stream of random input
    actions, such as clicking, typing, and swiping. It is akin to handing your app
    to a toddler and seeing if they can break it. All developers understand that the
    user can, and will, attempt to do utterly ridiculous and unpredictable things
    with their app, and short of sitting there trying to replicate every possible
    combination of gestures, the exerciser Monkey is as close as we can get to predict
    the unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Monkey is very simple to run: simply open the command prompt in your `sdk/platform-tools`
    directory and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Where 5000 is the number of random actions you want carried out, the output
    will resemble the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A table with all Monkey command-line options can be found at [https://developer.android.com/studio/test/monkey.html.](https://developer.android.com/studio/test/monkey.html)
  prefs: []
  type: TYPE_NORMAL
- en: Testing our business logic, how it incorporates itself with the rest of the
    system, and how it behaves on a wide range of devices under numerous conditions,
    is a vital part of any development life cycle. Once we are certain, however, that
    our code behaves as we intend, we can move on and interrogate how well it performs
    these tasks. We need to ask how efficient our work is, whether it contains memory
    or resource bottlenecks, or drains the battery unnecessarily. To do this, we will
    need to turn to the Android Profiler.
  prefs: []
  type: TYPE_NORMAL
- en: Performance monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may have ironed out all the glitches in our code, but there is still plenty
    of fine-tuning to do, and one of Android Studio's most innovative features, the
    Android Profiler, allows us to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: The Android Profiler is not available for modules developed using C++.
  prefs: []
  type: TYPE_NORMAL
- en: The Android Profiler was introduced in Android Studio 3.0 and replaced the previous
    Android Monitor. At the most basic level, it monitors live CPU, memory, and network
    usage. This allows us to test our app under different conditions and configurations
    and improve its performance. It can be accessed from the View | Tool Windows menu
    or the tool window bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6db1efeb-99e2-4faf-b033-5311c8a466c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Performance monitoring
  prefs: []
  type: TYPE_NORMAL
- en: This basic monitoring is no different from the Android Monitor of previous incarnations.
    This is because features such as method tracing and memory allocation inspection
    have a negative impact on build times. Advanced profiling can easily be enabled
    from the Run/Debug Configurations dialog, found via the Run | Edit Configurations...
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a45e9025-0f2a-4a30-b747-5f12f263cac0.png)'
  prefs: []
  type: TYPE_IMG
- en: Advanced performance monitoring
  prefs: []
  type: TYPE_NORMAL
- en: The profiler now displays a specific event information, along with a host of
    other features that we will explore now.
  prefs: []
  type: TYPE_NORMAL
- en: CPU profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android Profiler provides far deeper inspection than its predecessor, the
    Android Monitor, and allows detailed inspection of thread activity, UI events,
    and individual method performance. The CPU profiler also allows us to record method
    traces along with some sophisticated inspection tools to help us make our programs
    more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: The CPU advanced profiling features can be seen by clicking anywhere in the
    CPU timeline. This will then display the thread activity timeline in the lower
    portion of the display.
  prefs: []
  type: TYPE_NORMAL
- en: Observing our app's behavior live like this can be very revealing, but, to best
    see what is going on, we need to record a period of activity. This way, we can
    inspect individual threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following short exercise demonstrates how to record such a method trace:'
  prefs: []
  type: TYPE_NORMAL
- en: Click anywhere in the CPU timeline to open the advanced CPU profiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide which actions you want to record.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two new dropdowns at the top of this pane. Select Instrumented over
    Sampled and leave the other as is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are planning a long recording, zoom out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the record icon and perform your planned actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the same icon again to stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4f086260-e4c6-4df1-b954-9d8a8917fa87.png)'
  prefs: []
  type: TYPE_IMG
- en: A recorded CPU method trace
  prefs: []
  type: TYPE_NORMAL
- en: The ears on either side of the recorded sample can be dragged to adjust the
    length of the recording.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the exercise demonstrates, there are two kinds of recording, instrumented
    and sampled; their difference is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Instrumented recordings take exact timings from when methods are called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sampled recordings take samples of memory usage at regular intervals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you will see, there is a choice of how to represent these data, in the four
    tabs at the bottom of the tool window. Call chart and Flame chart present a graphical
    view of the method hierarchy, whereas Top down and Bottom up display this information
    as lists.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on any method in these charts will open the source code for that method.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to inspect program flow in detail like this is immensely helpful
    and can save a lot of unnecessary debugging, but it is not just processor time
    we need to consider; we also need to keep a close eye on just how much memory
    our apps are consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Memory profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fully understanding the impact our app has on a device's CPU is just one consideration.
    As developers, we have to create apps without knowing what the memory capabilities
    of our target devices are, and, furthermore, we have no way of knowing what other
    uses these devices are making of their memory at the time our app is running.
  prefs: []
  type: TYPE_NORMAL
- en: To assist us in planning memory use and avoiding leaks, Android Studio comes
    equipped with a powerful memory profiler. This allows us to view the Java heap
    and record memory allocation. Provided you have advanced profiling enabled, the
    advanced memory profiler can be opened in the same fashion as the processor profiler
    by clicking anywhere on the live timeline.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f1c6da6-be74-40e2-90cb-a5747490dcbe.png)'
  prefs: []
  type: TYPE_IMG
- en: The advanced memory profiler
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding image shows, the profiler also displays automatic garbage collections.
    Such clearing up can also be performed manually with the bin icon in the profiler's
    toolbar. This also contains buttons for recording memory allocation and capturing
    a Java heap dump (the download icon).
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a memory dump is as simple as clicking the icon and waiting a moment
    for the data to be collected. A heap dump displays the objects in use at the time
    the heap was dumped and is a great way to identify memory leaks. The best time
    to explore a heap dump is after an extended UI test by looking for objects that
    should have been discarded that still take up memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02b77b9c-d9ca-4f6a-99c7-d0ac3917862e.png)'
  prefs: []
  type: TYPE_IMG
- en: A Java heap dump
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on classes in the dump list will open the appropriate source code in
    the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Memory dumps like this are very useful for observing how much memory our objects
    are consuming, but they do not tell us what they are doing with this memory. To
    see that, we need to record memory allocation. This is accomplished in the same
    way that CPU recordings were taken, that is, by clicking the record icon. This
    handy memory inspection tool needs little more explanation, leading us to the
    third and final profiling tool, the network profile.
  prefs: []
  type: TYPE_NORMAL
- en: Network profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is not much in the way of a difference between the way that this profiler
    and the previous two operate. Rather than record network activity, simply click
    and drag over the area of the timeline that interests you. The files involved
    are then listed in the following pane, with details available when you select
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bd57470-bbf1-401e-a161-bb2b5510b43d.png)'
  prefs: []
  type: TYPE_IMG
- en: The advanced network profiler
  prefs: []
  type: TYPE_NORMAL
- en: The advanced network profiler provides a great way to identify inefficient network
    usage. Situations where the network controller has to switch the radios on and
    off often for small files should be avoided in preference of downloading several
    small files at once.
  prefs: []
  type: TYPE_NORMAL
- en: The network profiler along with the other two profilers are great examples of
    a time-saving tool that makes Android Studio such a good choice for developing
    mobile apps. Thorough testing and fine-tuning of an application can often make
    all the difference between a mediocre app and a successful one.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at the process of testing and profiling our
    apps. Not only did we see how to take advantage of JUnit integration to test the
    integrity of our own business logic, but also how to incorporate tools such as
    Mockito and Espresso to test the platform itself, and resources such as Firebase
    to test on a wider range of devices.
  prefs: []
  type: TYPE_NORMAL
- en: Besides testing our code and UIs, we need a way of testing our apps, hardware
    performance and whether there are issues with CPU, memory, or network usage. This
    is where Android Studio's built-in profiler, which allows us to inspect and record
    our app performance in great detail, comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: With our apps now running smoothly and fine-tuned for performance, we can take
    a look at the final stages of development, building, packaging, and deployment.
    Android Studio allows us to use the Gradle build system to simply create signed
    APKs, including those of different flavors as well as simplifying signing and
    security.
  prefs: []
  type: TYPE_NORMAL
