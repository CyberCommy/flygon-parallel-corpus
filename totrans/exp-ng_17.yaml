- en: Design Patterns in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript is an object-oriented programming language and, as such, we can leverage
    decades of knowledge on object-oriented architecture. In this chapter, we explore
    some of the most useful object-oriented design patterns and learn how to apply
    them in an Angular way.
  prefs: []
  type: TYPE_NORMAL
- en: Angular is, by itself, an object-oriented framework and it forces you to do
    most of your development in certain ways. For example, you are required to have
    components, services, pipes, and so on. Forcing upon you these building blocks
    contributes to building good architecture. Very much like what the Zend framework
    does for PHP or Ruby on Rails for Ruby. Frameworks are here to make your life
    easier and speed up the development time.
  prefs: []
  type: TYPE_NORMAL
- en: While the Angular way of designing things is way above average, we can always
    do better. I do not claim that what I present in this chapter is the ultimate
    design, and you will be able to use it to resolve anything from a one pager for
    a bakery to pagers to dashboards for the Mars One mission--such a design does
    not exist--but, it definitely improves your tool belt.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn to use the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Model-View-Controller(MVC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusable pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model-View-Controller (MVC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oh MVC, good old MVC. You served us well for many years. Now, people want you
    to retire, without fuss if possible. Moreover, even I can see how younger unidirectional
    user interface architectures can outsmart you and make you look like a relic from
    the past.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will first describe what the MVC is, regardless of the programming
    language used to implement it, and then we will see the shortcomings of applying
    MVC for frontend programming. Finally, I will present a way to implement an MVC
    that makes sense with Angular regarding ease of implementation, maintenance, and
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: MVC at large
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The whole principle behind the MVC design pattern is fairly straightforward.
    Indeed, as shown in the following figure, it is composed of three blocks: Model,
    View, and Controller. More specifically, the intent of the MVC is to define a
    one-to-many dependency between objects so that when one object changes state,
    all its dependents are notified and updated automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bbc1e9fd-1446-480e-aad3-bb764a93e5d1.png)MVC overview'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us analyze the preceding image block by block:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Model** stores the data required by the application according to commands
    sent by the **Controller**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Controller** receives actions from the **User** (that is, a click on a
    button) and directs **Model** updates accordingly. It can also set which **View**
    is used at any given moment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **View** is generated and updated every time the **Model** changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And that is it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what a simple MVC implementation would look like in pure TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define a `Movie` class like we did back in [Chapter 10](847dfea0-b857-4423-84fc-e6f719237f1d.xhtml),
    *Material Design in Angular*. In this version of the `Movie` class, we have only
    two attributes, `title` and `release_year` , which are defined using a TypeScript
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a `Model` class that imports the `movie.ts` file, containing
    the `Movie` class, using the reference keyword. This `Model` class, which will
    be responsible for updating the view, has a movie array and two methods. The first
    method, `addMovie(title:string, year:number)` is public and appends a new movie
    at the end of the movies attribute. It also calls the second method of the class:
    `appendView(movie:Movie)` which is private. This second method manipulates the
    view as per the MVC definition. The view manipulation is rather simple; we append
    a new `li` tag to the `movie` element of the view. The content of the newly created
    `li` tag is a concatenation of the movie title and release year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define a controller for our pure TypeScript MVC. The Controller
    has a private `model:Model` attribute that is initiated in the constructor. Also,
    a `click` method is defined. This method takes a string and a number in parameters
    for the title and the release year, respectively. As you can see, the `click`
    method forwards the title and the release year to the `addMovie` method of the
    model. Then, the controller''s job is done. It does not manipulate the view. You
    will also notice the last line of the `controller.ts` file: let `controller =
    new Controller()`;. This line allows us to create an instance of the `Controller`
    class that View can bind to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of our MVC implementation is the view. We have a bare-bones
    HTML form which, on submit, invokes the following: `controller.click(this.title.value,
    this.year.value); return false;.` The controller has been defined in the `controller.ts`
    file with `let controller = new Controller()`*;*. Then, for the parameters, we
    send `this.title.value` and `this.year.value` where this refers to the `<form>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The title and year refer to the field for the title and the release year of
    the movie, respectively. We also have to add return false to prevent the page
    from reloading. Indeed, the default behavior of an HTML form, on submit, is to
    navigate to the action URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the header, we add the `mvc.js` script generated by the following command:
    `tsc--out mvc.jscontroller.ts model.ts movie.ts`. The generated JavaScript looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On the execution side, at loading time, the HTML page would look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/94456d7f-cf35-4038-b636-0d9d10e7873c.png)MVC at loading time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if you use the form and add a movie, it will automatically impact the
    view and display the new movie as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0b4638a6-1dd7-4c1e-9442-76905de0f3d7.png)MVC after using the form.'
  prefs: []
  type: TYPE_NORMAL
- en: MVC limitations for the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, why is the MVC pattern not used that often when it comes to Frontend programming
    supported by a framework such as Angular? First, if you are using Angular for
    an app that provides a service, you are likely to have a Backend with which you
    exchange some information. Then, if your Backend also uses the MVC design pattern,
    you will end up with the following hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e0d23afd-59e0-4cf6-9c19-6145cc717c47.png)MVC Frontend and Backend.'
  prefs: []
  type: TYPE_NORMAL
- en: In this hierarchy, we have an MVC implementation on top of another MVC implementation.
    Both implementations communicate with each other via an API service that sends
    requests to the Backend Controller and parses the resulting view. As a concrete
    example, if your user has to sign in to your app, they will see the sign in View
    on the Frontend that is powered by a User Model and a sign Controller. Once all
    the information (email, password) has been entered, the User clicks on the Sign-in
    button.
  prefs: []
  type: TYPE_NORMAL
- en: This click triggers a Model update and the Model then triggers an API call using
    the API service. The API service makes a request to the `user/signin` endpoint
    of your API. On the Backend side, the request is received by the User Controller
    and forwarded to the User Model. The Backend User Model will query your database
    to see if there is a matching User with the provided user and password. Finally,
    a View will be output, containing the user information if the login was successful.
    Going back on the Frontend, the API service will parse the produced view and return
    the relevant information to the Frontend User Model. In turns, the Frontend User
    Model will update the Frontend View.
  prefs: []
  type: TYPE_NORMAL
- en: For some developers, that many layers and the fact that the architecture is
    duplicated on the Frontend and the Backend just feels wrong even though it brings
    maintainability through a well-defined separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: The dual MVC is not the only concern. Another problem is that the frontend models
    will not be pure models as they have to account for variables regarding the UI
    itself such as visible tabs, form validity, and so on. Hence, your Frontend Models
    tend to become a hideous blob of code where UI variables rub shoulders with the
    actual representation of your user, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as always, you can avoid these traps and harness the advantages of the
    MVC pattern. Let's see how in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Angular is MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I present an architecture for the MVC in Angular that has proved
    itself. I have used this architecture for the past eight months at `toolwatch.io`
    (web, Android, and iOS). Obviously, the features we propose on the web version
    or the mobile apps are the same and work the same way; what changes are the views
    and the navigation scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure presents the overall architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/65d357c3-82da-4505-a136-94c7a3791815.png)MVC for Angular.'
  prefs: []
  type: TYPE_NORMAL
- en: From top to bottom, we have the Backend, the reusable pieces of the Frontend,
    and the specialized Frontend (that is, mobile or the web). As you can see, on
    the Backend, nothing changes. We have kept our traditional MVC. Note that the
    Frontend parts would also work with the non-MVC Backend.
  prefs: []
  type: TYPE_NORMAL
- en: Our Model will use that service to get, put, and delete a plain TypeScript object
    from the remote database through a hypothetic JSON API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our user TypeScript object looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too fancy here. Only a plain TypeScript object that contains two attributes:
    `email:_string` and `password:_string`. These two attributes are initialized in
    the Constructor using the TypeScript inline declaration style. We also leverage
    the getter/setter of TypeScript to access the `password:string` and `_email:string`
    attributes. You might have noticed that the TypeScript getter/setter look like
    C# properties. Well, Microsoft is one of the principal industrial investigators
    for TypeScript, so it makes sense.'
  prefs: []
  type: TYPE_NORMAL
- en: I do like the conciseness of the writing, especially when combined with inline
    attribute declarations in the constructor. What I do not like, however, is the
    necessity to have underscored variables names. The problem is that, once again,
    this TypeScript will be transpiled to JavaScript, and in JavaScript, variables
    and function are a bit more abstract than, let's say, Java or C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, in our current example we could invoke the getter of the `user` class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, TypeScript does not care about the type of the target it is
    calling. It can be a variable named email or a function named `email()`. Either
    way, it works, with different results, but it works. The underlying rationale
    behind this odd behavior, for an object-oriented program, is that, in JavaScript,
    it is acceptable to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Consequently, we need to differentiate the actual variables of the function
    with different names. Hence the _.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our MVC implementation now that we have a full-proof user
    object to manipulate. Now we can have a `UserModel` that manipulates the user
    **Plain Old TypeScript Object** (**POTO**) and the needed variable for the graphical
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our model, named `UserModel`, receives an injection of an `APIService`. The
    implementation of the `APIService` is left to the reader as an exercise. However,
    it will be very similar to what we have seen in [Chapter 9](64f5991e-76eb-41dd-818c-0e46c41c168b.xhtml),
    *Advanced Forms in Angular 2*. In addition to the `APIService`, `UserModel` owns
    the `user:User` and `loading:bool` attributes. The `user:User` represents the
    actual user with its password and email. The `loading:bool`, however, will be
    used to determine whether or not a loading spinner should be visible in the view.
    As you can see, `UserModel` defines the `signin` and `signup` methods. In these
    methods, we call the `getUser` and `postUser` methods of the hypothetical `APIService`
    that both take a User in argument and return a Promise containing the said user
    synchronized via the JSON API. On receipt of the promises, we turn off the `loading:bool`
    spinner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let''s have a look at the controller, which will also be a component
    in an Angular environment as Angular components control the view which is displayed,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the controller (component) is simple. We only have a reference
    to the model, and we receive an injected `APIService` to be transferred to the
    model. Then, we have the `signinClick` and `signupClick` methods that receive
    user input from the view and transfer them to `model`. The last piece, the view,
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have two forms, one for the signin and one for signup. Both forms
    are alike except for the `onsubmit` method they use. The sign-in form uses the
    `signinClick` method of our controller, and the sign-up form uses the `signupClick`
    method. In addition to these two forms, we also have, on each form, a Font Awesome
    spinner that is only visible once the user model is loading. We achieve this by
    using the `[hidden]` Angular directive: `[hidden]="!model.loading"`. Similarly,
    the submit buttons are hidden when the model is loading.'
  prefs: []
  type: TYPE_NORMAL
- en: So, here it is, a functional MVC applied to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: As I said at the beginning of this section, for me, the actual usefulness of
    the MVC pattern in Angular comes from its extensibility. Indeed, leveraging the
    object-oriented aspect (and what comes with it) of TypeScript allows us to specialize
    a controller and model for different Angular applications. For example, if you
    have an Angular website and an Angular mobile application, as I do with `toolwatch.io`,
    then you have business logic you can reuse on both sides. It would be a shame
    to have two sign-ins, two sign-ups, and two of everything to code and maintain
    over time when we could have only one!
  prefs: []
  type: TYPE_NORMAL
- en: At `toolwatch.io`, for example, the web application uses standard Angular, and
    we built the mobile applications using Ionic2 and Angular. Obviously, we have
    a lot a frontend logic shared between the mobile apps (Android and iOS) and the
    website. Ultimately, they tend to achieve the same purposes and functionalities.
    The only difference is the medium used to use those functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, I loosely represent a complete way of leveraging the
    MVC pattern with a focus on reusability and extensibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/055395a5-090b-468e-bf7e-211dc47a51ad.png)Reusable MVC for Angular.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, the Backend stays as-is. We have the same MVC pattern there. As
    a reminder, the MVC pattern on the Backend is entirely up to you, and you could
    take advantage of the Frontend MVC pattern with a functional Go Backend, for example.
    What differs from the previous version of the MVC exposed here is the introduction
    of the Reusable Frontend part. In this part, we still have an API service in charge
    of consuming our JSON API. Then, we have a model that implements the `IModel`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This interface defines the `put`, `post`, `delete`, and `patch` methods that
    have to be implemented in the subsequent models. The `POTO` type that these methods
    take as parameters and return is the mother class for any domain model you have
    in your program. A domain model represents the synchronizable entity of your business
    logic such as the User we used before. The domain model and the model part of
    MVC are not to be confused. They are not the same thing at all. In this architecture,
    User would extend `POTO`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model (of MVC this time) contains a `POTO` also to implement the `IModel`
    interface. Also, it contains the variables and methods you need to update your
    views. The implementation of the model itself is rather straightforward as I have
    shown earlier in this section. However, we can kick things up a notch by leveraging
    the generic aspect of TypeScript and envision the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the generic `AbstractModel` that is constrained by `POTO`. It
    means that the actual instance of the `AbstractModel` generic class (known as
    a template in a language such as C++) is constrained to have a class-specializing
    `POTO`. In other words, only domain models such as `User` can be used. So far,
    the separation of concern is excellent as well as the reusability. The last piece
    of the reusable part is the controller. In our sign-up/sign-in example, it would
    look very much like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, why do we need an additional building block here and can't we use a simple
    Angular component as we did for the simpler version of the Angular MVC? Well,
    the thing is that, depending on what you use on top of your Angular core (Ionic,
    Meteor, and so on), the component is not necessarily the main building block.
    For example, in the Ionic2 world, you use pages that are the custom version of
    the classical component.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, the mobile part would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If need be, you can also extend `UserModel` and add some specialization as
    shown in the figure of Reusable MVC for Angular. On the browser side, add this
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once again you can also extend `UserModel` and add some specialization. The
    only remaining block to cover is the view. To my despair, there is no way to extend
    or add a style file for that. Hence, we are doomed to have a duplication of HTML
    files between clients unless the HTML file is the same between the mobile app
    and the browser app. From experience, this does not happen much.
  prefs: []
  type: TYPE_NORMAL
- en: The whole reusable frontend can be shipped as a Git submodule, standalone library,
    or a `NgModule`. I personally use the Git submodule approach, as it allows me
    to have two separate repositories while enjoying auto-refresh on the client I
    am working on when I do a modification on the shared frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this MVC also works if you have several frontends hitting the same
    backend instead of several types of frontend. For example, in an e-commerce setup,
    you might want to have differently branded websites to sell different products
    that are all managed in the same backend, like what's possible with Magento's
    views.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton and Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another handy pattern to use for frontend application is the singleton. The
    singleton ensures that only one instance of a given object exists in your program.
    Moreover, it provides a global point of access to the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what it looks like in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a class that has a `private static instance:MySingleton` attribute.
    Then, we have a `private` constructor that makes the following fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that it fails because your TypeScript transpiler complains about the visibility.
    However, if you transpile the `MySingleton` class to JavaScript and import it
    in another TypeScript project, you will be able to use the new operator as the
    transpiled JavaScript has no visibility at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this fairly simple implementation of the singleton pattern
    is concurrency. Indeed, if two processes hit the `getInstance():MySingleton` at
    the same time, then we will have two instances of the `MySingleton` on the program.
    To be sure that does not happen, we can use a technique called early instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'While you can implement your singleton in Typescript, you can also leverage
    the Angular way of creating a singleton: services! Indeed, in Angular, services
    are only instantiated once and injected to any components needing them. Here''s
    an example of a service and injection via the `NgModule` we have seen before in
    this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`APIService` displays the `@Injectable()` annotation that makes it, well, injectable.
    Also, the `APIService` has an `increment:number` attribute that is incremented
    every time a new instance is created. The `increment:number` being static, it
    will tell us exactly how many instances there are in our program. Finally, the
    `APIService` has a `toString:string` method that returns the current instance
    number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppComponent` is a classical component that receives an injection of the `APIService`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OtherComponent` is another classical component that receives an injection
    of the `APIService`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/app.module.ts` contains our `NgModule`. In the `NgModule`, most of the declarations
    shown here have already been discussed in this book. The novelty comes from the
    `providers: [APIService]` part. Here, we declare a provider for the `APIService`
    itself. As the `APIService` does not do anything too crazy, it can be provided
    by using a reference to the class. More complex services that, for example, require
    injection need custom-tailored providers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if we navigate to these two components, the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This proves that only one instance has been created and the same instance has
    been injected to both components. Hence, we have a singleton. However, this singleton,
    while convenient, isn''t safe. Why, you ask. Well, the `APIService` can also be
    provided at the component level, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In such a case, two separate instances would be created, resulting in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Consequently, using Angular services, you cannot enforce the singleton pattern
    contrary to its plain TypeScript counterpart. Also, the plain TypeScript would
    be an order of magnitude faster than the Angular services as we skip the injection
    process altogether. The exact number depends heavily on the CPU/RAM of your machine.
  prefs: []
  type: TYPE_NORMAL
- en: The only question left to answer in the case of a singleton is when to use it.
    A singleton enforces only one instance of a given class in your program. Consequently,
    it is a very good fit for any sort of communication with a backend or any hardware
    access. For example, in the case of communication with a backend, it might be
    desirable to have only one `APIService` handling API keys, API limits, and CSRF
    tokens across the board without having to make sure we pass the same instance
    of the service throughout all our components, models, and so on. In the case of
    hardware access, you might want to be sure that you have only one connection open
    to the webcam or the microphone of our users so you can properly release them
    when you are done with it.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype and reusable pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented developers looked at ways to reduce the cost of creating objects,
    especially, when those objects are expensive to create because they require, for
    example, a database pull or complex mathematical operations. Another reason to
    invest in reducing the creation cost of a particular object is when you create
    a lot of them. Nowadays, backend developers tend to disregard this aspect of optimization
    as on-demand CPU/memory have become cheap and easy to adjust. It will literally
    cost you a few bucks more a month to have an additional core or 256 MB RAM on
    your backend.
  prefs: []
  type: TYPE_NORMAL
- en: This used to be a big deal for desktop application developers too. On a client
    desktop, there is no way to add CPU/RAM on demand, but fairly cadenced quad cores
    and a *ridiculous* amount of RAM for consumer PCs made the issue less problematic.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, only game and intensive analytics solutions developers seem to care.
    So, why should you care about the creation time of your object after all? Well,
    you are building something that is likely to be accessed from old devices (I still
    use an iPad 1 for casual browsing on the kitchen or the couch). While a desktop
    application developer can publish minimum and recommended configurations--and
    enforce them by refusing to install itself--we, as web developers, don't have
    this luxury. Now, if your website does not behave properly, users will not question
    their machines but your skills. Ultimately, they will not use your products, even
    when on a capable machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use the `Prototype` design pattern. The `Prototype` design
    pattern allows an object to create customized objects without knowing their class
    or any details of how to create them. The intent is to create new objects by copying
    this prototype rather than actually instantiating a new object. First, we will
    need a `Prototype` interface as so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Prototype` interface only defines a `clone` method that returns a `Prototype`--compliant
    object. You will have guessed it, the optimized way of creating objects is to
    clone them when needed! So let''s say you have an object `Movie` that, for some
    reason, takes time to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the override function in TypeScript is different from most languages.
    Here, the two signatures of the constructor are on top of each other and share
    the same implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, that is it for the `Prototype` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other pattern that often goes with the prototype pattern is the object
    pool pattern. While working with expensive-to-create objects, cloning them sure
    makes a difference. What can make an even bigger difference is to not do anything
    at all: no creation, no cloning. To achieve this, we can use the pool pattern.
    In this pattern, we have a pool of objects ready to be shared by any clients or
    components in the case of an Angular application. The pool implementation is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'First and foremost, the pool is also a singleton. Indeed, it would not make
    much sense to have this costly object as a reusable design if anyone can create
    pools at will. Consequently, we have the `static instance:MoviePool` and the private
    constructor to ensure that only one pool can be created. Then, we have the following
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `movies` attribute stores a collection of movies and a Boolean used to determine
    if anyone is currently using any given movie. As the movie objects are hypothetically
    taxing to create or maintain in memory, it makes sense to have a hard limit on
    how many such objects we can have in our pool. This limit is managed by the private
    `static nbMaxMovie = 10`; attribute. To obtain movies, components would have to
    call the `getMovie():Movie` method. This method does a hard create on the first
    movie and then leverages the prototype pattern to create any subsequent movie.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a movie is checked out of the pool, the `getMovie` method changes
    the used Boolean to true. Note that, in the case where the pool is full and we
    do not have any free movies to give away, then an error is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, components need a way to check their movies back to the pool so others
    can use them. This is achieved by the `releaseMovie` method. This method receives
    a checked out movie and iterates over the movies of the pool to set the according
    Boolean to false. Hence, the movie becomes usable for other components.
  prefs: []
  type: TYPE_NORMAL
- en: Factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a `User` class with two private variables: `lastName:string`
    and `firstName:string`. Also, this simple class proposes the method hello that
    prints `"Hi I am", this.firstName, this.lastName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, consider that we receive users through a JSON API. Most likely, it will
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following snippet, we can create a `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Until now; the TypeScript compiler doesn''t complain, and it executes smoothly.
    It works because the parse method returns `any` (that is, the TypeScript equivalent
    of the Java Object). Sure enough, we can convert the `any` into `User`. However,
    `userFromJSONAPI.hello()`; will yield:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Why? Well, the left side of the = statement is defined as `User`, sure, but
    it will be erased when we transpile it to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type-safe TypeScript way to do it would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly enough, the `typeof` function will not help you either. In both
    cases it will display `Object` instead of `User` as the very concept of `User`
    does not exist in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: While the direct type-safe approach works, it is not very expansible nor reusable.
    Indeed, the map `callback` method would have to be duplicated everywhere you receive
    a JSON user. The most convenient way to do that is with the `Factory` pattern.
    A `Factory` is used to create objects without exposing the instantiation logic
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to have a factory to create a user; it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a static method named `buildUser` that receives a JSON object
    and takes all the required values inside the JSON object to invoke, with the right
    attributes, a hypothetical `User` constructor. The method is static as are all
    the methods of such a factory. Indeed, we do not need to save any states or instance-bound
    variables in a factory; we only encapsulate away the gruesome creation of users.
    Note that your factory will likely be shared with the rest of your POTOs.
  prefs: []
  type: TYPE_NORMAL
- en: Memento pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The memento pattern is a really-really useful pattern in the context of Angular.
    In Angular-powered applications, we use and overuse Two-way Data Binding between
    domain models such as `User` or `Movie`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider two components: one named `Dashboard` and the other one named
    `EditMovie`. On the Dashboard component, you have a list of movies displayed in
    the context of our IMDB-like application. The view of such a dashboard could look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This simple view owns a `ngFor` directive that iterates over the list of movies
    contained in a model. Then, for each movie, it displays two p elements containing
    the title and the release year, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `EditMovie` components access one of the movies in the `model.movies`
    array and allow the user to edit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the Two-way Data Binding used here, the modifications were to the
    movie title and year will directly impact the dashboard. As you can notice, we
    have a cancel button here. While the user might expect that the modification is
    synchronized in realtime*,* he/she also expects that the Cancel button/link cancels
    the modifications that have been done on the movie.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is where the Memento pattern comes into play. This pattern allows you
    to perform undo operations on objects. It can be implemented in many ways, but
    the simplest one is to go with cloning. Using cloning, we can store away one version
    of our object, at a given moment, and if need be get it back. Let''s enhance our
    `Movie` object from the `Prototype` pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this new version, we added the `restore(movie:Movie)` method that takes a
    `Movie` as an argument and sets the local attributes to the values of the received
    movie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in practice, the constructor of our `EditMovie` component could look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: What's interesting is that you are not limited to one memento over time; you
    can have as many as you want.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use some of the classical object-oriented
    patterns that are applicable, and useful, for reusable and easy-to-maintain/extend
    real-world applications. The MVC was adapted to Angular and expanded to enable
    highly reusable business logic between different applications. Then, we saw how
    to control the creation of our object with the singleton with and without Dependency
    Injection and the prototype coupled to a pool to limit the number of expensive
    objects in the system. Finally, we learned how to use the factory patterns to
    avoid the traps in JSON-to-TypeScript automatic (and partial) object conversion
    and saw how to perform *undo* operations with the memento pattern.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn even more about patterns to improve your performance, operations
    costs, and maintainability, you can check out the upcoming *Angular Design Patterns*
    *and Best Practices* book by Packt Publishing. This book goes in-depth into patterns
    and their implementation to find the best fit your application.
  prefs: []
  type: TYPE_NORMAL
