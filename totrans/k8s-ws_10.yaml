- en: 10\. ConfigMaps and Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to decouple application configuration data
    from the application itself and the advantages of taking this approach. By the
    end of this chapter, you will be able to define Kubernetes ConfigMap and Secret
    objects, run a simple Pod that uses data from ConfigMaps and Secrets, describe
    the advantages of decoupling configuration data from applications, and use ConfigMaps
    and Secrets to decouple application configuration data from the application container.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 5*, *Pods*, we learned that Pods are the minimal unit of deployment
    in Kubernetes. Pods can have multiple containers, and each container can have
    a container image associated with it. This container image generally packages
    the target application that you plan to run. Once the developers are satisfied
    that the code is running as expected, the next step is to promote the code to
    testing, integration, and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Easy, right? One problem, however, is that as we move our packaged container
    from one environment to another, although the application remains the same, it
    needs environment-specific data, for example, the database URL to connect to.
    To overcome this problem, we can write our applications in such a way that the
    environment-specific data is provided to the application by the environment it
    is being deployedÂ into.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discover what Kubernetes provides to associate **environment-specific
    data** with our application containers without changing our container image. There
    are multiple ways to provide **environment-specific configuration** data to our
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide command-line arguments to the Pods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide environment variables to the Pods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount configuration files in the containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we need to define our configuration data using an object called **ConfigMap**.
    Once the data is defined and loaded into Kubernetes, the second step is to provide
    the defined data to your application.
  prefs: []
  type: TYPE_NORMAL
- en: However, what if you have sensitive data, such as database passwords, that you
    want to provide to your application container? Well, Kubernetes **Secret** provides
    a way to define sensitive data to an application.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMap and Secret objects both serve a similar purpose. Both provide a way
    to define data that can be injected into your applications so that the same container
    can be used across different environments. There is little difference between
    them, which we will learn in detail later on in this chapter. As a quick rule,
    Secrets are designed to hold confidential data (such as passwords, private keys,
    and more), while ConfigMaps are more suited for general configuration data such
    as a database location. ConfigMaps and Secrets reside in the specific namespace
    in which they are created. They can only be referenced by Pods residing in the
    same namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes uses an internal key-value store called **etcd** as its database
    to store all the objects defined in Kubernetes. As ConfigMaps and Secrets are
    Kubernetes objects, they get stored in the internal key-value store.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dig a bit deeper into ConfigMaps first.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a ConfigMap?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A ConfigMap allows us to define application-related data. A ConfigMap decouples
    the application data from the application so that the same application can be
    ported across different environments. It also provides a way to inject customized
    data into running services from the same container image.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMaps can be created through a literal value or from a file or all the
    files in a directory. Note that the primary data we stored in ConfigMaps is for
    non-sensitive configuration, for example, config files or environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Once a ConfigMap is defined, it will be loaded to the application via an environment
    variable or a set of files. The application can then see the files as local files
    and can read from them. It is important to note that (from 1.9.6 version onward
    of Kubernetes), files loaded from ConfigMaps are read-only. ConfigMaps can also
    hold configuration data for system applications such as operators and controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercises, you will see different ways of defining ConfigMaps
    and different ways to make the ConfigMap data available to the running Pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what Kubernetes offers us in terms of ConfigMap creation. Kubernetes
    help commands provide a good starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Kubernetes built-in help for creating ConfigMap'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.1: Kubernetes built-in help for creating ConfigMap'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the preceding output, ConfigMaps can be created for a single
    value, a list of values, or from an entire file or directory. We will learn exactly
    how to do each of these in the exercises in this chapter. Note that the command
    to create a ConfigMap has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<map-name>` is the name you want to assign to the ConfigMap and `<data-source>`
    is the directory, file, or literal value to draw the data from.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data source corresponds to a key-value pair in the ConfigMap, where:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key** is the filename or the key you provided on the command line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value** is the file content or the literal value you provided on the command
    line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start with the exercises, let's make sure that you have Kubernetes
    running and that you can issue commands to it. We will use minikube to easily
    run a single-node cluster on your local computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start up minikube using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response as minikube starts up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Starting up minikube'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.2: Starting up minikube'
  prefs: []
  type: TYPE_NORMAL
- en: For all of the exercises in this chapter, we recommend creating a new namespace.
    Recall from *Chapter 5*, *Pods*, that namespaces are Kubernetes' way to group
    components of the solution together. Namespaces can be used to apply policies,
    quotas, and could also be used to separate resources if the same Kubernetes resources
    are being used by different teams.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, we will create a ConfigMap from literal values using
    the kubectl CLI commands. The idea is that we have some configuration data (for
    example, the master database name) that we can inject into, for example, a MySQL
    Pod, and it will create the database as per the given environment variable. This
    set of commands can also be used in the automated code pipelines that are responsible
    for application deployments across multiple environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.01: Creating a ConfigMap from Literal Values and Mounting It on
    a Pod Using Environment Variables'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a ConfigMap in the Kubernetes cluster. This
    exercise shows how to create ConfigMaps using a key-value pattern. Please follow
    these steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's begin by creating a namespace for all of the exercises in this
    chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `configmap-test` namespace for all the exercises in this chapter
    unless mentioned otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a ConfigMap that contains a single name-value pair. Use
    the command shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we create the ConfigMap, let''s confirm that it is created by issuing
    a command to get all the ConfigMaps in the namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As `singlevalue-map` is the only ConfigMap in the `configmap-test` namespace,
    you should see an output that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the Kubernetes ConfigMap object looks like. Enter the Kubernetes
    `get` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The full object should be described something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: Describing singlevalue-map'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.3: Describing singlevalue-map'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the third line of the preceding output, the ConfigMap is created
    and the literal value we entered is available as a key-value pair in the `data`
    section of the ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a YAML file named `configmap-as-env.yaml` to create a Pod
    into which we will inject fields from our ConfigMap as an environment variable.
    Using your favorite text editor, create a YAML file with the followingÂ content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `envFrom` section in the preceding file is loading the
    data from the ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a Pod from the preceding specification. This Pod is using the
    **busybox** container image, which runs the command specified in the `command`
    section of the YAML file mentioned in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the logs for this Pod using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the logs as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: Getting logs for configmap-env-pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.4: Getting logs for configmap-env-pod'
  prefs: []
  type: TYPE_NORMAL
- en: The `[ "/bin/sh", "-c", "env" ]` command will display all the environment variables
    loaded into the Pod. In the ConfigMap, we have defined the property name as `partner-url`,
    which is part of the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, the name of the environment variable, `partner-url`, is the
    same as the key in our key-value pair. We can also make the name of the environment
    variable different from the key. For example, if we want to have `partner-server-location`
    as the name of our environment variable, we can replace the content of the YAML
    file in the exercise with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Pay special attention to the `env` section in the preceding YAML file. The first
    `name` field after `env` defines the name of the environment variable, and the
    `key` field under `configMapKeyRef` defines the name of the key in the ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a ConfigMap from a File and Loading It onto a Pod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will create a ConfigMap from a file and then load the file
    onto the application Pod. As mentioned previously, this newly mounted file will
    be accessible as a local file to the application running inside the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: This is common when applications store their configuration data externally,
    allowing easier upgrades, as well as patches of the container image across different
    environments. We can have such a file in our source control repository, and we
    load the correct file in the correct container using a ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand this through an example. Imagine that you have written a web
    application that connects to a database to store information. When you deploy
    the application in a development environment, you will want to connect to the
    development database. Once you are satisfied that the application is working correctly,
    you will want to deploy the application to a testing environment. Since the application
    is packaged in a container, you would not want to change the container to deploy
    the application to the testing environment. But to run the application in the
    testing environment, you need to connect to a different database. An easy solution
    to this is that you configure your application to read the database server URL
    from a file, and that file can be mounted through a ConfigMap. This way, the file
    is not packaged as part of the container, but injected from outside via Kubernetes;
    thus, you do not need to modify your containerized application. Another use case
    would be that external software vendors can provide a container image, and any
    specific configuration settings can be mounted on the image as per a specific
    client'sÂ requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.02: Creating a ConfigMap from a File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a ConfigMap from a file, which can be mounted
    onto any Pods later on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a file named `application.properties` containing the following
    configuration details. You may use your preferred text editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a ConfigMap from the file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output indicating that the ConfigMap has beenÂ created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the list of all ConfigMaps to confirm that our ConfigMap has been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a list of all ConfigMaps, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the names of the ConfigMaps are displayed alongside the number
    of keys they have.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering, why does this output show only one key, even though
    we have added two keys? Let's understand this in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the ConfigMap is being stored by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Getting details of full-file-map'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.5: Getting details of full-file-map'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the name of the file, `application.properties`, becomes the **key**
    under the `data` section, and the entire file payload is the **value** of the
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined our ConfigMap, the next step is to mount it onto a
    container. Create a YAML file named `mount-configmap-as-volume.yaml` to be used
    as our Pod configuration using the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, let's focus on the `volumes` section in the preceding file. In this section,
    we are instructing Kubernetes to define a volume from our ConfigMap named `full-file-map`.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, in the `volumeMounts` section, we are defining that Kubernetes should
    mount the volume in the `/etc/appconfig` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `command` field in the container allows us to configure what command
    we want the container to execute when it starts. In this example, we are running
    the `ls` command, which is a Linux command to list the contents of a directory.
    This is similar to the Windows `dir` command. This will print the contents of
    directory `/etc/appconfig`, where we have mounted theÂ ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `name` field under the `volume` and `volumeMounts` sections has to be the
    same so that Kubernetes can identify which `volume` is associated with which `volumeMounts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, use the following command to start a Pod using the YAML file we justÂ created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get a response saying that the Pod has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The YAML file we used specifies the name of the Pod as `configmap-test-pod`
    and configures it to just display the content of the folder. To verify this, just
    issue the following command to get the output logs of the Pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This should print `application.properties`, which is the file we placed in
    the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we get the contents of `/etc/appconfig`, which is the output
    of the `ls` command in the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: You have just successfully defined a ConfigMap and mounted it as a file in a
    Pod that printed the name of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.03: Creating a ConfigMap from a Folder'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will load all the files in a folder as a ConfigMap. Each
    filename becomes a key for the ConfigMap, and when you mount it, all the files
    will be mounted at the `volumeMounts` location (as defined in the YAML file for
    theÂ container):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two files in a new folder. Name one of them `fileone.txt`, with its
    contents as `file one`, and name the other `filetwo.txt`, with its contents as
    `file two`. The folder name can be anything for this exercise. You can confirm
    that the files have been created using the `ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following list of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to create ConfigMap from a folder. Note that instead
    of specifying the filename, we just mentioned the name of the folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s describe the ConfigMap to see what it contains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Describing the map-from-folder ConfigMap'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.6: Describing the map-from-folder ConfigMap'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there are two keys in the ConfigMap â one for each file, that is,
    `fileone.txt` and `filetwo.txt`. The values of the keys are the contents of the
    files. Thus, we can see that a ConfigMap can be created from all the files in
    a folder.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Secret?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A ConfigMap provides a way to decouple application configuration data from the
    application itself. However, the problem with a ConfigMap is that it stores the
    data in plain text as a Kubernetes object. What if we want to store some **sensitive
    data** such as a database password? Kubernetes Secret provides a way to store
    sensitive data that can then be made available to the applications that require
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Secret versus ConfigMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can think of a Secret as the same as a ConfigMap with the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a ConfigMap, a Secret is intended to store a small amount (1 MB for a
    Secret) of sensitive data. A Secret is **base64**-encoded, so we cannot treat
    it as secure. It can also store binary data such as a public or private key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes ensures that Secrets are passed only to the nodes that are running
    the Pods that need the respective Secrets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Another way to store sensitive data is a vault solution, such as HashiCorp Vault.
    We have left such implementation out of the scope of the workshop.
  prefs: []
  type: TYPE_NORMAL
- en: But wait; if the Kubernetes Secrets are not secure enough due to their base64
    encoding, then what is the solution for storing extremely sensitive data? One
    way is to encrypt it and then store it in Secrets. The data can be decrypted while
    it is being loaded to the Pod, though we are leaving this implementation out of
    the scope of this workshop.
  prefs: []
  type: TYPE_NORMAL
- en: Once we define our Secrets, we need to expose them to the applications Pods.
    The way we expose Secrets to the running application is the same as for ConfigMaps,
    that is, by mounting them as an environment variable or as a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for ConfigMaps, let''s use the built-in `help` command for `secret` to see
    what types of Secrets are offered by Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `help` command should show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: Output of the built-in help command for Secret'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.7: Output of the built-in help command for Secret'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding output, the `Available Commands` section lists
    three types of Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`generic`: A generic Secret holds any custom-defined key-value pair.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tls`: A TLS Secret is a special kind of Secret for holding a public-private
    key pair for communication using the TLS protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-registry`: This is a special kind of Secret that stores the username,
    password, and email address to access a Docker registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take a deeper dive into the implementation and uses of these Secrets
    in the following exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.04: Defining a Secret from Literal Values and Loading the Values
    onto the Pod as an Environment Variable'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will define a Secret from a literal value and load it
    as an environment variable in the running Pod on Kubernetes. This literal value
    maybe something like a password to your internal database. Since we are creating
    this Secret from a literal value, it would be categorized as a **generic** Secret.
    Follow these steps to perform the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a Secret that will hold a simple password by using the followingÂ command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get a response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we define our Secret, we can use the Kubernetes `describe` command to
    obtain more details about it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 10.8: Describing test-secret'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.8: Describing test-secret'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that it stored our value against the `password` key:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our Secret is created, we will mount it as an environment variable
    in a Pod. To create a Pod, make a YAML file named `mount-secret-as-env.yaml` with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the `envFrom` section, which mentions the Secret to load. In
    the `command` section for the container, we specify the `env` command, which will
    make the container display all the environment variables loaded into the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use the YAML configuration to create a Pod and see it in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s get the logs for the Pod to see all the environment variables displayed
    by our container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the logs similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: Getting logs from secret-env-pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.9: Getting logs from secret-env-pod'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the highlighted line of the preceding output, the `password`
    key is displayed with its value as `secretvalue`, which was what we hadÂ specified.
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise demonstrates how to use a public-private key combination
    and mount the private key file into a Pod. The public key can then be made available
    to any other service connecting to this Pod, but that is not demonstrated in this
    exercise. Using a separate file as a Secret enables us to use any kind of file
    instead of simple key-value strings. This opens up the possibility of using binary
    files like private keyÂ stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.05: Defining a Secret from a File and Loading the Values onto the
    Pod as a File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a private key, store it in a new Secret, and
    then load it onto a Pod as a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a private key. We will use a tool used to create SSH keys.
    Enter the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If prompted, do not provide any password for the key.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you require more information about the SSH protocol and its uses, please
    refer to [https://www.ssh.com/ssh/protocol/](https://www.ssh.com/ssh/protocol/).
  prefs: []
  type: TYPE_NORMAL
- en: 'After this is executed successfully, you will see two files named `test_rsa`
    and `test_rsa.pub`. You should see an output similar to the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: Creating SSH keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.10: Creating SSH keys'
  prefs: []
  type: TYPE_NORMAL
- en: Your output may not be exactly the same as shown here because the keys areÂ randomized.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux distros include the `ssh-keygen` tool. However, if you don't have
    or cannot use `ssh-keygen`, you can use any other file instead of the private
    key to proceed with this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s load the newly created private key as a Secret. This time, we will
    use the `from-file` argument of the `create secret` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get a response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the Secret is created, we can get its details using the `describe` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The Secret should be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: Describing test-key-secret'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.11: Describing test-key-secret'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our Secret is created, let''s mount it onto a Pod. The process is
    similar to mounting a ConfigMap. First, create a YAML file named `mount-secret-as-volume.yaml`
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding Pod specification, note that `volumes` are mounted the same
    way as we mounted the earlier ConfigMap. In the volumes section, we are instructing
    Kubernetes to define a volume from our Secret. In the `volumeMounts` section,
    we are defining the specific path on which Kubernetes should mount the volume.
    The `"/bin/sh", "-c", "ls /etc/appconfig/; cat /etc/appconfig/private-key"` command
    will print out the contents of the file loaded onto it as a Secret.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `name` field in the `volume` and `volumeMounts` sections has to be the same
    so that Kubernetes can identify which `volume` is associated with which `volumeMounts`.
    For this example, we have used `secret-volume` as the name in both places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a Pod using the YAML file as the Pod definition using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If the Pod is successfully created, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether our Pod has the Secret loaded, we can get its logs and examine
    them. Use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The logs should show the contents of the private key, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12: Getting logs of secret-test-pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.12: Getting logs of secret-test-pod'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the log, the container is displaying the contents of the
    Secret mounted onto the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since the SSH key is randomized, your output may not look exactly the same as
    the one shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SSH key is randomized, so each time you will get a different output. You
    can try this exercise multiple times and see for yourself. Make sure to either
    delete the Pod or change the name every time. You can delete the Pod using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output if the Pod is successfully deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we created a key pair using another tool and loaded the private
    key onto our Pod by mounting it as a binary file. However, public-private key
    pairs are used for encryption in the TLS protocol, which is a cryptographic standard
    for securing web traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about TLS, please refer to [https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/](https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes provides its own way of creating a key pair and storing keys for
    TLS. Let's see how to create a TLS Secret in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.06: Creating a TLS Secret'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will see how to create a Secret that can store a cryptographic
    key for TLS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to create a pair of private-public keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This command creates the private key in the file named `tls.key`, and the public
    certificate in the file named `tls.crt`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more details on how the **openssl** tool is used here, you can refer to
    [https://www.openssl.org/docs/manmaster/man1/req.html](https://www.openssl.org/docs/manmaster/man1/req.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the key is successfully generated, you should see an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13: Creating SSL keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.13: Creating SSL keys'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is successful, we can create a Secret to hold the files using the followingÂ command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the Secret is successfully created, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that our Secret is created by listing down all Secrets in the `configmap-test`
    namespace using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Secret must be listed in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14: Listing down all secrets in configmap-test'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.14: Listing down all secrets in configmap-test'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we issue the `describe` command for the newly created Secret, you can see
    that it stores the two parts, the public and the private key, as two different
    keys of the Secret:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15: Describing test-tls'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.15: Describing test-tls'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we have created a set of public-private keys for TLS using a special set
    of commands provided by Kubernetes. This Secret can be mounted in a similar way
    as demonstrated in *Exercise 10.05*, *Defining a Secret from a File and Loading
    the Values onto the Pod as a File*.
  prefs: []
  type: TYPE_NORMAL
- en: Another common task is to fetch Docker images from an external Docker registry.
    Many organizations use **enterprise container registries** (for example, Nexus)
    for their applications, which can then be fetched and deployed as needed. Kubernetes
    also provides a special type of Secret to store authentication information for
    accessing these Docker registries. Let's see how to implement it in the followingÂ exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.07: Creating a docker-registry Secret'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a **docker-registry** Secret that can be used
    for authentication while fetching a Docker image from a registry:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create the Secret directly using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the command arguments, we need to specify the username, password,
    and email address for the Docker account. Once the Secret is created, you should
    see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that it is created by using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see `test-docker-registry-secret` as displayed in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16: Checking test-docker-registry-secret'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.16: Checking test-docker-registry-secret'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `describe` command and get more details about our Secret:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should return the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17: Describing test-docker-registry-secret'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_10_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.17: Describing test-docker-registry-secret'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see under the `Data` section of the preceding output, a single key
    with the name `.dockerconfigjson` has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This exercise is just an easy way to load a `.dockerconfigjson` file. You can
    create and load the file manually using other methods and achieve the same objective
    as we have in this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10.01: Using a ConfigMap and Secret to Promote an Application through
    Different Stages'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's assume that we have an application and we want to promote it to different
    environments. Your task is to promote the application from testing to production
    environments, and each environment has different configuration data.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we will use the ConfigMap and Secret to easily reconfigure
    the application for different stages in its life cycle. It should also give you
    an idea of how the separation of ConfigMap data and Secret data from the application
    can help in the easier transition of an application through various stages of
    development andÂ deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'These guidelines should help you to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a namespace called `my-app-test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a ConfigMap named `my-app-data` in the `my-app-test` namespace with
    the following key values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a Secret named `my-app-secret` in the `my-app-test` namespace with the
    following key values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Define a Pod specification and deploy the ConfigMap in the `/etc/app-data` folder
    with the filename `application-data.properties`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a Pod specification and deploy the Secret in the `/etc/secure-data` folder
    with the filename `application-secure.properties`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the Pod so that it displays all the contents from the ConfigMap and the
    Secret. You should see something like this:![Figure 10.18: Key values for the
    test environment'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B14870_10_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.18: Key values for the test environment'
  prefs: []
  type: TYPE_NORMAL
- en: Define another namespace called `my-app-production`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a ConfigMap named `my-app-data` in `my-app-production` with the following
    key values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a Secret named `my-app-secret` in `my-app-production` with the following
    key values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Use the same Pod specification as defined in *step 5* and run the Pod in the
    `my-app-production` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check whether the application running in `my-app-production` displays the correct
    data. You should see output like this:![Figure 10.19: Key values for the production
    environment'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B14870_10_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.19: Key values for the production environment'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).
    The GitHub repository also includes a Bash script for this activity, which will
    execute all these solution steps automatically. However, please take a look at
    the detailed steps provided in the solution to get a complete understanding of
    how to perform the activity.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen the different ways that Kubernetes provides to
    associate environment-specific data with our applications running as containers.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes provides ways to store sensitive data as Secrets and normal application
    data as ConfigMaps. We have also seen how to create ConfigMaps and Secrets and
    associate them with our containers via CLI. Running everything via the command
    line will facilitate the automation of these steps and improve the overall agility
    of yourÂ application.
  prefs: []
  type: TYPE_NORMAL
- en: Associating data with containers enables us to use the same container across
    different environments in our IT systems (for example, in test and production).
    Using the same container across different environments provides a way for secure
    and trusted code promotion techniques for IT processes. Each team can use a container
    as a unit of deployment and sign the container so that other parties can trust
    the container. This also provides a trusted way of distributing code not only
    across the same IT organizations but also across multiple organizations. For example,
    a software vendor can just provide you with a container as packaged software.
    ConfigMaps and Secrets can then be used to provide specific configurations for
    using the packaged software in your organization.
  prefs: []
  type: TYPE_NORMAL
- en: The next set of chapters is all about deploying Kubernetes and running it in
    high availability mode. These chapters will provide you with fundamental and practical
    knowledge regarding how to run stable clusters for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
