- en: SOLID Design in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever seen comments such as *If you like design patterns, use Java, not Go*?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will address this common sentiment regarding software design
    patterns and how they fit with developing high-quality Go applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal in this chapter is to understand the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why many Gophers loath Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Go does not support inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The principles of good software design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to apply the single responsibility principle in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The open/closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duck typing in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to model behavior in Go using interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to compose software using the interface segregation principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inner type promotion and how to embed interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why many Gophers loath Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*If you like design patterns, use Java, not Go.*'
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about where this thinking comes from. Java (as well as C++) tends
    to focus on type hierarchies and type taxonomies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the `ObjectRetrievalFailureException` class from the Spring Framework
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44e29e9c-4a08-41d8-813e-d062e604367b.png)'
  prefs: []
  type: TYPE_IMG
- en: This looks far too complicated and over-abstracted, right?
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Java, Go is designed to be a pragmatic language where we won't get lost
    in infinite levels of inheritance and type hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: When we implement a solution in a language that places so much emphasis on a
    type hierarchy, levels of abstractions, and class inheritance, our code refactorings
    tend to be much more time-consuming. It's best to get the design right before
    we begin coding. Leveraging design patterns can save a lot of time when implementing
    Java solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance creates a high level of coupling in object-oriented programming.
    In the preceding example, a change in the `DataAccessException` class could cause
    unwanted side effects in every class above it in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: It's easy to see why anyone might think there is no place for design patterns
    in Go.
  prefs: []
  type: TYPE_NORMAL
- en: '"If C++ and Java are about type hierarchies and the taxonomy of types, Go is
    about composition."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Rob Pike'
  prefs: []
  type: TYPE_NORMAL
- en: However, with careful use of abstraction, software design patterns can be entirely
    compatible with Go's composable simple design philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: More reasons for loathing Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Java** | **Golang** |'
  prefs: []
  type: TYPE_TB
- en: '| **Language specification** (PDF) | 788 pages ([https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf](https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf))
    | 89 pages ([https://golang.org/ref/spec](https://golang.org/ref/spec)) |'
  prefs: []
  type: TYPE_TB
- en: '| **Java JDK versus Go SDK** (compressed) | 279.59 MB ([http://jdk.java.net/9/](http://jdk.java.net/9/))
    | 13 MB |'
  prefs: []
  type: TYPE_TB
- en: '| **Concurrency implementation complexity** | Difficult | Easy |'
  prefs: []
  type: TYPE_TB
- en: 'The following is a diagram that compares the Java and Go technology stacks
    from a high level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe227eef-7ff6-4f60-8840-4d1ac45ce65e.png)'
  prefs: []
  type: TYPE_IMG
- en: The Java/JVM alternative has a much bigger footprint; The JVM does more (some
    of which your application will use) and requires more RAM. Furthermore, since
    there is more raw source code to the Java/JVM solution than Go, that means that
    there is a larger attack surface for hackers to attack. Performance? It takes
    time for the JIT compiler to convert your application's source code to executable
    binary code than Go, which is natively compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Go is smaller and simpler. Java was created for profit and has been aggressively
    marketed. Go is not marketed. There is a streamlined process for proposing changes
    to the Go language. See "How to Propose Changes To Go" in the Appendix. (I have
    found no such process for proposing changes to Java or the JVM, but I can only
    image that there would be much more time and effort involved).
  prefs: []
  type: TYPE_NORMAL
- en: Given the preceding comparisons of Go v. Java it seems to boil down to Simplicity
    v. Complexity. Gophers tend to prefer simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: '"Less is exponentially more."'
  prefs: []
  type: TYPE_NORMAL
- en: - Rob Pike
  prefs: []
  type: TYPE_NORMAL
- en: Digging deeper into error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Java, when an exception occurs in a method, the process of creating the exception
    object and handing it over to the runtime environment is called throwing an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The normal flow of the program halts when this happens, and JRE tries to find
    a handler in the call stack that can process the raised exception.
  prefs: []
  type: TYPE_NORMAL
- en: The exception object contains a lot of debugging information, such as the line
    number where the exception occurred, type of exception, the method hierarchy,
    call stack, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Dozens of common exception handling antipatterns exist in Java largely due to
    the design and misunderstanding of proper use of Java's type hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '"Don’t just check errors, handle them gracefully."'
  prefs: []
  type: TYPE_NORMAL
- en: - Dave Cheney
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than asserting the error is a specific type or value and passing up
    the line, we can assert that the error implements a particular behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the `IsRetryable` error occurs, then the caller would know they can retry
    the operation that generated the error. The caller does not need to import the
    library that implements the thrown error and attempt to understand the intricacies
    of its type hierarchy to handle the error properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `github.com/pkg/errors` package allows you to wrap errors with context so
    that later you can recover the cause like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`    func IsRetryable(err error) bool {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`        eb, ok := errors.Cause(err).(errorBehavior)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`        return ok && eb.Retryable()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    }`'
  prefs: []
  type: TYPE_NORMAL
- en: Once the error value has been inspected, it should be handled once. Repackaging
    the error and throwing it up for another handler to deal with is not considered
    a best practice in Go.
  prefs: []
  type: TYPE_NORMAL
- en: A conversation - Java developer, idiomatic Go developer, FP developer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Java developer: I hate having to write `if err != nil` everywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go developer: Get used to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java developer: Why not just throw an exception and let a handler up the call
    chain deal with it?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go developer: All good programmers are lazy and that''s extra typing.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Developer** | **Conversation** |'
  prefs: []
  type: TYPE_TB
- en: '| Java | I hate having to write `if err != nil` everywhere |'
  prefs: []
  type: TYPE_TB
- en: '| Go | Get used to it. |'
  prefs: []
  type: TYPE_TB
- en: '| Java | Why not just throw an exception and let a handler up the call chain
    deal with it? That''s less typing and all good programmers are lazy, right? |'
  prefs: []
  type: TYPE_TB
- en: '| Go | Errors should always be handled immediately.What if our `buggyCode`
    function returns an error yet we continue processing? Can you see how fragile
    and wrong that is?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| FP | What bothers me the most about throwing a Java exception is that when
    we throw an error up for another function to deal with we have just created a
    side effect. Our function is not pure. We have introduce indeterminism into our
    application. Since any caller in the call stack can handle an exception, how do
    we know which handler handles it? Since we wrote the code closest to the error,
    we should know better than any other developer what happened and how best to deal
    with it. |'
  prefs: []
  type: TYPE_TB
- en: '| Java | Okay. I get it, but I am not only lazy but I all that extra if `err
    != nil`  code looks like scaffolding that litters my code and makes me want to
    barf. Let me clarify my feelings with a couple of photos. |'
  prefs: []
  type: TYPE_TB
- en: 'Our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4df41f98-3e74-491e-9dc9-156c5f869ff5.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Java | You can see the difference, right? |'
  prefs: []
  type: TYPE_TB
- en: '| Go | Touche! But you need to realize I am mainly interested in programming
    backend systems where correctness trumps pretty. You can take your pretty J2EE
    enterprise business applications and wrap them with as many exception handlers
    as you like. |'
  prefs: []
  type: TYPE_TB
- en: '| Java | Seriously? You say you like simplicity, but more code looks more complex
    to me. That''s more code to maintain. That means that instead of having the option
    to handle all of my error handling in one place I have to insert little snippets
    of error handling code all throughout my application? Shit! I absolutely love
    Go''s fast compiles times, Go''s tiny footprint, the ease of programming concurrent
    applications, and so on. I am so frustrated. Is there no better error handling
    solution in Go? |'
  prefs: []
  type: TYPE_TB
- en: '| FP | Glad you asked. Depending on what you want to accomplish, there is a
    better way. This way will not only allow you to handle all your errors in one
    place, but will also do so with the determinism of pure FP. |'
  prefs: []
  type: TYPE_TB
- en: '| Go | B.S. I will stop reading this book now because there is no way this
    will work. |'
  prefs: []
  type: TYPE_TB
- en: '| Java | Yeah! What''s the catch? |'
  prefs: []
  type: TYPE_TB
- en: '| FP | The solution requires thought, time, and hard decisions, but just like
    learning to ride a bike. Once you get up and running you''ll keep doing it. It''s
    fun and gets you where you want to go more efficiently and it''s good for you.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Java | What''s it called? |'
  prefs: []
  type: TYPE_TB
- en: '| FP | The Lexical Workflow solution |'
  prefs: []
  type: TYPE_TB
- en: '| Go | You caught me. I''m still reading. Just long enough to say, That''s
    a ridiculous claim and the name is even more so. |'
  prefs: []
  type: TYPE_TB
- en: '| FP | I know it sounds like magic and it sort of is. It''s built on a things
    will even more ridiculous names: the Y-Combinator and  Monads. But we have a way
    to go before we discuss the details. It will take thought and time and decision
    making skills.  |'
  prefs: []
  type: TYPE_TB
- en: '| Java | What''s there to decide? If it works, I''ll use it. |'
  prefs: []
  type: TYPE_TB
- en: '| FP | The best use case for Lexical Workflow Solution is where you have data
    you want to transform. Do you have any workflows where you input data, transform
    it in some way and then produce an output? This covers a lot of business use case
    scenarios and some system level ones, too. |'
  prefs: []
  type: TYPE_TB
- en: '| Java | Sounds good. What does it do and what does it not do? |'
  prefs: []
  type: TYPE_TB
- en: '| FP | It handles your typical workflow use case where when you encounter an
    error, that error is handled and no further processing occurs in that workflow.
    If you want to keep processing even with errors, then we''d be better off using
    applicative functors. If Go supported TCO, then that would open up the door to
    many more FP possibilities. For now, we need to keep it real (and not worry about
    stack overflows or performance implications of using recursion). If/when Go does
    support TCO then us FP coders will be able to unleash a plethora of robust, expressive
    and performant FP solutions.  |'
  prefs: []
  type: TYPE_TB
- en: Software design methodology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Software design is where we:'
  prefs: []
  type: TYPE_NORMAL
- en: Gather requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create specifications from requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a solution based on the specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review results and iterate to improve the solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditional waterfall development depends on a perfect understanding of the
    product requirements at the outset and minimal errors being executed in each phase. Source: [http://scrumreferencecard.com/scrum-reference-card/](http://scrumreferencecard.com/scrum-reference-card/)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97dc5d5b-3f70-4b52-9fe5-bd9ca4693237.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Scrum blends all the development activities into each iteration, adapting to
    discovered realities at fixed intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/caaf5d0e-29c2-4da5-a658-b3f33f3fd88c.png)'
  prefs: []
  type: TYPE_IMG
- en: Source: [http://scrumreferencecard.com/scrum-reference-card/](http://scrumreferencecard.com/scrum-reference-card/)
  prefs: []
  type: TYPE_NORMAL
- en: In the process of creating specifications, artifacts such as **Unified Markup
    Language** (**UML**) diagrams are often created to help us think about the problem
    and craft a viable solution.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis is where we model real-world operations, breaking apart pieces into
    components. Design is where we craft a software solution based on the analysis
    work, our IT environment, and the frameworks/technology stacks at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: We abstract away all the concerns that are not pertinent. So, during analysis
    and design, we take away and break apart our problem into components that do simple
    things.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation is when we put those simple things back together again.
  prefs: []
  type: TYPE_NORMAL
- en: Good design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Good design is about saving money in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: If our project is small and the value of our time to market is high, then we
    can skip the design process. Otherwise, we should put effort into having a proper
    software design. This is a universal truth, regardless of the technology (Java,
    Go, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Bad design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If our application architecture diagram looks something like the following
    one, we have failed to properly design our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6e832c2-95c7-4d49-a93f-c7296b14ca4e.png)'
  prefs: []
  type: TYPE_IMG
- en: Simplicity is not easy, but it is worth striving for.
  prefs: []
  type: TYPE_NORMAL
- en: The more we add features to our already complex system, the more complex it
    becomes.
  prefs: []
  type: TYPE_NORMAL
- en: In a system like this, we cannot consider one thing at a time; we must think
    of everything together and all the possible weird interactions that may break
    our system.
  prefs: []
  type: TYPE_NORMAL
- en: Good versus bad design over time
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following diagram depicts the value of good design over time. As with most
    graphs, the *x* axis depicts the progression of time. The higher we go on the
    *y* axis, the more functionality and feature rich our application becomes. Below
    the **design payoff line**, applications with no design or poor design can quickly
    produce results.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there comes a point at which lack of design makes the application
    brittle, non-extensible, and difficult to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fbf42cb-2919-46c8-afbe-022bf32f944c.png)'
  prefs: []
  type: TYPE_IMG
- en: The application that has been properly designed can be extended easily and becomes
    much more maintainable in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: '"Over 90% of software cost happens during maintenance phase."'
  prefs: []
  type: TYPE_NORMAL
- en: - Fred Brooks, Mythical Man Month
  prefs: []
  type: TYPE_NORMAL
- en: SOLID design principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SOLID design principles of **Object-Oriented Programming** (**OOP**) apply
    to designing Go software solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Single responsibility principle says, *Do One Thing and Do It Well*. We see
    the SRP at play in the Go standard libraries. Here''re a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9de5a3cb-267f-4651-854b-ec515262c8d6.png)'
  prefs: []
  type: TYPE_IMG
- en: If a pull request enhances the `aes/crypto` package, would you expect that code
    merge to affect the functionality of the `database/sql/driver` package (or any
    package)? No. Of course not. Each package is clearly name spaced and highly cohesive;
    they perform specific tasks and do not cross over into other concerns.
  prefs: []
  type: TYPE_NORMAL
- en: '"A class should have one, and only one, reason to change."'
  prefs: []
  type: TYPE_NORMAL
- en: – Robert C Martin
  prefs: []
  type: TYPE_NORMAL
- en: When Mr. Martin said that a class should have only one reason to change, it's
    obvious that he was talking about OOP design, but the same principle applies to
    our Go application. Should the tax calculation update affect the user interface
    or layout of any reports, other than showing a different amount? No. Why? Because
    one is cosmetic in nature and the other is not. Those are two separate responsibilities
    that should be handled by different, loosely coupled classes/modules.
  prefs: []
  type: TYPE_NORMAL
- en: Our classes/modules should be highly cohesive, performing as specific a role
    as possible. Code that has a single responsibility can handle the changing requirements
    better without adversely affecting other parts of our application. If we have
    a request to change our class/module and since it does only one thing then the
    reason for the change can only be related to its one responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application of the SRP will drive our design towards smaller and smaller interfaces.
    Eventually, we will arrive at the ultimate interface. The interface with one method.
    For example, in [Chapter 5](../Text/Ch05.xhtml), *Adding Functionality with Decoration*, we''ll
    look at Go’s complimentary Reader and Writer interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What the SRP means to FP is aligned with the Unix philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: '"Although that philosophy can''t be written down in a single sentence, at its
    heart is the idea that the power of a system comes more from the relationships
    among programs than from the programs themselves. Many UNIX programs do quite
    trivial things in isolation, but, combined with other programs, become general
    and useful tools."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Rob Pike'
  prefs: []
  type: TYPE_NORMAL
- en: In lambda calculus, each function has exactly one parameter. It may look like
    our pure function accepts multiple parameters, but it's actually just currying
    the parameters. Our function takes the first argument in the list and returns
    a function which takes the rest of the arguments; It continues to process each
    argument until they are all consumed. Function composition works when every function
    accepts only one parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That was pseudo code for what happens when we curry. It converts a two parameter
    call into a one parameter call. Currying stores data (the number 1) and an operation
    (the addition operator) for use later. How is that like an object in OOP?
  prefs: []
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Function composition is where we combine two smaller functions to create a
    new function that accomplishes the same goal as the two smaller ones. Both ways
    get us from an `a` to `c`. Below, `f[1]` accepts an `a` and returns a `b`. `f[2]`
    accepts a `b` and returns a `c`. We can compose/combine those two functions and
    get a single function that accepts an `a` and returns a `c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc4b36c4-3ccb-48de-9ded-e28cabbe4bea.png)'
  prefs: []
  type: TYPE_IMG
- en: Function composition is the cornerstone to pure FP; It's what allows us to build
    larger abstractions out of smaller ones.
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed principle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Software should be open for extension but closed for modification. Embedding
    fields in a struct allows us to extend one type with another. The object (`CarWithSpare`)
    that embedded the other (`Car`) has access to its fields and methods. The `CarWithSpare`
    object can call `Car` methods, but cannot modify the `Car` object''s methods.
    Therefore, Go''s types, while being *open for extension*, are *closed for modification*.
    Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined our `Car` type and two methods, `Tires` and `PrintInfo`. Next, we''ll
    define our `CarWithSpare` type and embed the `Car` type as an unnamed field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In our `main.go` file, we create a Honda Accord and call its `PrintInfo` method.
    As expected it returns `4` tires.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a Toyota Highlander, but when we print its info, it prints `4`
    tires instead of `5`. Why?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That's because `PrintInfo` is a method of `Car`, but since `CarWithSpare` is
    missing that method, when we call `highlander.PrintInfo` we're actually executing
    `Car`'s method (not `CarWithSpare`).
  prefs: []
  type: TYPE_NORMAL
- en: In order to print the actual number of tires our highlander has, we must manually
    delegate the call by executing `highlander.Tires` directly from within our `fmt.Printf`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do we have other options? Yes. We can override the `PrintInfo` method. In other
    words, we can define a `PrintInfo` method for our `CarWithSpare` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we call `accord.PrintInfo()` again? We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So, Go allows us to:'
  prefs: []
  type: TYPE_NORMAL
- en: implicitly call an embedded object's method (if not defined)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: manually delegate to call our object's method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: override an embedded object's method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What about method overloading?
  prefs: []
  type: TYPE_NORMAL
- en: 'Not allowed. If we were to attempt to create another `PrintInfo` method with
    a different argument signature, Go would throw a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c69cfca1-25fd-4055-91dd-7b326f92724b.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the decorator pattern in the next chapter, we'll see how we can extend
    functionality without modifying the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Open / close principle in functional programming
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Similar to our preceding Go example where we added a new method (`PrintInfo`)
    to our base type (`Car`), pure functional programming languages also add new functions
    over existing data types without having to recompile existing code and while retaining
    static type safety.
  prefs: []
  type: TYPE_NORMAL
- en: The *expression problem* also known as the *extensibility problem* addresses
    a software language's ability to add new methods and types to a program in a type
    safe manner. For details, see **Feature Oriented Software Development** (**FOSD**)
    Program Cubes where a base program (in a family of related programs called a **software
    product line**) ([http://softwareproductlines.com/](http://softwareproductlines.com/)) 
    is incrementally augmented with features to produce a complex program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how programs can be built by composing models from
    features and then transforming those models into executables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bce0ef89-a861-4daf-b06f-d0e8e97fe10d.png)'
  prefs: []
  type: TYPE_IMG
- en: The FOSD methodology advocates that complex systems can be built by adding features
    incrementally where the domain models are functions and constants and the programs,
    which are represented as expressions, can be generated to perform specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: FantasyLand JavaScript specification
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `FantasyLand` project specifies interoperability of common algebraic structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbf62a17-f972-4807-9f34-e4d2be56fee9.png)'
  prefs: []
  type: TYPE_IMG
- en: Each data type in the hierarchical diagram is called an algebraic data type
    because each consists of algebra, that is, a set of values, a set of operators
    that it is closed under, and the rules it must obey.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a simple example, the Setoid.
  prefs: []
  type: TYPE_NORMAL
- en: Setoid algebra
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following are the Setoid rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name of rule** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Reflexivity | `a.equals(a) === true ` |'
  prefs: []
  type: TYPE_TB
- en: '| Symmetry | `a.equals(b) === b.equals(a) ` |'
  prefs: []
  type: TYPE_TB
- en: '| Transitivity | if `a.equals(b)` and `b.equals(c)`, then `a.equals(c)` |'
  prefs: []
  type: TYPE_TB
- en: '|  | If `b` is not the same `Ord`, behavior of `lte` is unspecified (returning
    false is recommended).`lte` must return a Boolean (`true` or `false`). |'
  prefs: []
  type: TYPE_TB
- en: The values used in the rules are `a`, `b`, and `c`. A value which has an `Ord`
    must provide an `lte` method. The equals method is this algebra's operator and
    it takes one argument.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. That's all there is to it!
  prefs: []
  type: TYPE_NORMAL
- en: Ord algebra
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here''re the `Ord` rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name of rule** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Totality | `a.lte(b)` or `b.lte(a)` |'
  prefs: []
  type: TYPE_TB
- en: '| Anti-symmetry | If `a.lte(b)` and `b.lte(a)`, then `a.equals(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| Transitivity | If `a.lte(b)` and `b.lte(c)`, then `a.lte(c)` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `b` must be a value of the same `Ord` as `a`. If `b` is not the same Setoid,
    then the behavior of equals is unspecified (returning false is recommended). The
    `equals` variable must return a Boolean (`true` or `false`). |'
  prefs: []
  type: TYPE_TB
- en: The values used in the rules are `a`, `b` and `c`. A value which has a Setoid
    must provide an `lte` method. The `lte` method is this algebra's operator and
    it takes one argument.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding diagram, we see that an `Ord` is a Setoid, so the `Ord` has
    an `Equals` operator and the `Ord` must obey the same rules that a Setoid does,
    as well as its own rules.
  prefs: []
  type: TYPE_NORMAL
- en: Later in our book, we'll explore Haskell's type class hierarchy and look at
    the Functor, Monoid, and Monad algebras.
  prefs: []
  type: TYPE_NORMAL
- en: The expression problem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Different languages solve the expression problem in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Open classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multimethods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coproducts of functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object algebras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem they solve is the same as what we looked at with our `CarWithSpare`
    example; It's all about how to add new functions over existing data types without
    having to recompile existing code and while retaining static type safety.
  prefs: []
  type: TYPE_NORMAL
- en: Go has rudimentary support for the expression problem. Type classes, object
    algebras, and so on. are not part of Go's standard library, but there's nothing
    stopping us from building any of the aforementioned solutions. Here's a great
    start: [https://github.com/SimonRichardson/wishful](https://github.com/SimonRichardson/wishful).
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In OOP terms, the *Liskov Substitution Principle* says that objects of the same
    type or subtype should be substituted and can be replaced by the other, without
    affecting the caller. In other words, when we implement an interface, our class
    should implement all the methods defined in the interface and satisfy all interface
    requirements. And in even fewer words, *satisfy** interface contracts*.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will enforce that our methods have the correct signatures. The
    LSP goes a bit further and demands that our implementation should also have the
    same invariant, postconditions, and other properties stated or implied by the
    documentation of the superclass or interface.
  prefs: []
  type: TYPE_NORMAL
- en: This OOP method stinks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is what a method contract looks like in the OOP world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b55bae-d5da-4f4f-9c28-704136cc2e91.png)'
  prefs: []
  type: TYPE_IMG
- en: Our method `m` is passed an `a`, does some processing and returns `b`. An exception
    can occur, which may or may not be caught and handled and errors can be returned.
    Additionally, in order for the method to properly satisfy its contract, it's up
    to us to read the documentation (which of course will always be completely accurate
    and up-to-date.... not!) in hopes that we cover all the preconditions, invariant,
    and postconditions.
  prefs: []
  type: TYPE_NORMAL
- en: An **invariant** is something that must be always be true for the life of the
    method. For example, if our class has a duration member variable, that value must
    always be a positive float. Another example could be that our internal latitude
    and longitude values must always be in the northern hemisphere. We could go so
    far as to write invariance validator private methods to ensure our invariant are
    in compliance with their range of acceptable values.
  prefs: []
  type: TYPE_NORMAL
- en: A **precondition** is something that must be true at the time our method is
    called. For example, before we execute our `consummateMarriage` method we should
    ensure that our chosen `wouldBeSpouse` is not already married to another; Otherwise,
    we'd likely be in violation of our state's anti-polygamy laws. We would likely
    do our checking by executing another `verifyPersonIsSingle` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s not forget the **postconditions**. An example might be: After executing
    our `consummateMarriage` method we should ensure that the person with whom we
    consummate is actually the same person on our marriage certificate. Marrying the
    wrong person could cause all sorts of problems.'
  prefs: []
  type: TYPE_NORMAL
- en: The last issue to deal with is *side effects*. A side effect is what happens
    when our method changes something other than the **b** (or the error) that it
    outputs. For example, if our postcondition check caused a credit card charge from
    a private investigation firm, that charge would be a side effect.
  prefs: []
  type: TYPE_NORMAL
- en: Our FP function smells like roses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is what our function contract looks like in the FP world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8c89004-3ce4-4874-a7d3-1c6f8bf1a063.png)'
  prefs: []
  type: TYPE_IMG
- en: See the difference? We can almost smell the difference! Hey, wait a minute!
    (An OOP programmer might be thinking...)
  prefs: []
  type: TYPE_NORMAL
- en: This pure function is missing some stuff! This is an unfair comparison!
  prefs: []
  type: TYPE_NORMAL
- en: That's right. It's not fair, but it's real.
  prefs: []
  type: TYPE_NORMAL
- en: And what makes it real is our inputs type.
  prefs: []
  type: TYPE_NORMAL
- en: In FP, contracts don't lie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s look an example of some imperative code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What is our contract in the preceding code?
  prefs: []
  type: TYPE_NORMAL
- en: The contract is our method's signature: `func (n Dividend) Divide(divisor int)
    int`
  prefs: []
  type: TYPE_NORMAL
- en: What three questions must our contract answer?
  prefs: []
  type: TYPE_NORMAL
- en: What does our contract expect?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: It expects the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Dividend.Val` to be populated with an `int`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The divisor to be an `int`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does our contract guarantee?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: It promises to return an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the contract maintain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Not applicable in this simple case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when we run the preceding code?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5038ec59-b333-44ea-b460-d7b21aad6d94.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We get a runtime panic! Did our contract hold true, or did it lie to us?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbe891bd-f5ad-4179-bf03-b790f2864753.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In pure FP, we don't rely on lowly types like int, char, or even string. We
    leverage the full power of an amazing type class system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a pure FP language like Haskell, we can define a `PostiveInt` type. So,
    instead of writing a method to validated that an input parameter is positive,
    we define a type named `PostiveInt` that guarantees that only positive integers
    will be input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In FP terms, LSP says, *Contracts don't lie*;
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1918b05d-8512-4ff6-8a1e-24409f2f2c1d.png)'
  prefs: []
  type: TYPE_IMG
- en: In FP, we don't have to rely on our test suite to verify that our application
    properly enforces it requirements. In FP, assuming we have designed our software
    properly, if it compiles then it is correct. We let our type system enforce our
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In an OOP courting relationship, the input (candidate spouse) is only verified
    to be Female. When we later discover that she is not the right type of woman,
    that is, she's already married, that would render the marriage contract invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what happens when we don''t properly type check our input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3faef2ce-0e74-4a8d-ac69-6bbd2f383021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the picture when we use pure FP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7221c37a-6cd4-4cdc-9b63-b1783c0334d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Looks simple, but where are the external interactions like in-laws that can
    lead to divorce? What about children? Aren't they what we might call side-effects
    of a marriage?
  prefs: []
  type: TYPE_NORMAL
- en: 'Monads provide a way for our couple to interact with the external world; To
    handle possibly harmful influences and generate beautiful side effects. It looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/388f97d1-8e42-4bc1-800d-eaab913cdd74.png)'
  prefs: []
  type: TYPE_IMG
- en: The trick to Monads is that all external interactions are contained (in the
    box). We'll cover Monads in depth in our last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This book is about learning *functional* programming in Go. Hence, we will embrace
    the full meaning of the term *functional.* Functional does not only mean *pure.* If
    we're using functions, we're doing functional programming. Go is a multi-paradigm
    language that does not force us to be completely pure or completely imperative.
    The vast majority of Go code these days is imperative... take the standard libraries
    as an example. There is a time and a place for implementing pure functional programming
    techniques. The more we learn about all aspects of Go's functional capabilities,
    and pure functional programming concepts, the better equipped we will be to prudently
    apply the proper style of coding to meet our application development requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the LSP at work with a duck typing example.
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Go does not have inheritance or subtypes, but we have interfaces. Functions
    that implement the methods of an interface satisfy the interface contract implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Go supports what's called **duck typing**. If it walks like a duck and quacks
    like a duck, then it's a duck. In other words, if we have a Go struct with methods
    that implement the Duck interface, that is, if it has the `Walk()` and `Quack()`
    methods, then for all intents and purposes, our struct is a duck.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented languages, such as Java, we'd be tempted to design our ducks
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: What can go wrong with inheritance?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We are told that ducks can walk and quack. So we implement those behaviors
    in our parent class, namely `Duck`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8043e18-a4e1-416a-99e9-0f5f89fae01a.png)![](img/77ddb2f7-0c9e-41a0-841c-725d1269d4b5.png)'
  prefs: []
  type: TYPE_IMG
- en: We start out with `Mallard` and `BlueBilled` ducks. We are able to reuse the
    `walk()` and `quack()` methods via inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we hear that ducks can fly. So we implement the fly behavior in our `Duck`
    class and all the child classes inherit this new behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66326981-6c3b-4519-8e8a-bf44d140669b.png)'
  prefs: []
  type: TYPE_IMG
- en: All is well until we add `Pekins` ducks to our flock.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem that we did not account for in our original design is that most
    domestically bred ducks cannot fly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1035156e-db0e-485e-b1a2-cd2fc956fd05.png)![](img/28bc566a-6b96-490f-8641-8b909a4c9c82.png)'
  prefs: []
  type: TYPE_IMG
- en: The good news for us is that this sort of a design flaw is not even a possibility
    in Go!
  prefs: []
  type: TYPE_NORMAL
- en: The way we model behavior in Go is by using interfaces (Go does not support
    inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation principle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is better to have a lot of single purpose-specific interfaces than one general
    purpose interface. Our APIs should not accept references to structures that it
    does not need, and conversely, our client implementations should not depend on
    code that it does not use.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see this soon in our Viva La Duck code example in the form of separate
    `EatBehavior` and `StrokeBehavior` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: When we strictly apply  the integration segregation principle we end up with
    interfaces with a single method. Such objects represent data with behavior, but
    it can also be modeled as behavior with data, which is what closures are in FP.
  prefs: []
  type: TYPE_NORMAL
- en: This is another area where it would be nice if Go supported Generics. Why create
    boiler plate code to handle slices of `Int` types, `Customers`, or `AvailableWomen`
    when a single enumeration of `T` would work (with less code)?
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **dependency inversion principle** (**DIP**) states that we should depend
    upon abstractions, not concretions. DIP is about removing hardwired dependencies
    from our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code violates DIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `MyOtherFunction` function is not quite as bad as the `MyFunction` function,
    but both implementations couple our implementation with a type and an interface
    of another package.
  prefs: []
  type: TYPE_NORMAL
- en: In general, good software design relies on high cohesion, where we write functions
    that do one thing and do it well and are loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: In pure functional programming, dependency injection is accomplished by passing
    partially applied functions around. Some call it the *hollywood principle*, as
    in, *Don't call us, we'll call you*. In JavaScript, this is frequently accomplished
    using callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is a subtle difference between callbacks and continuations.
    Callback functions may be called multiple times in the flow of an application
    and each time they return a result and processing continues. When a function calls
    another function as the last thing it does then the second function is called
    a continuation of the first.
  prefs: []
  type: TYPE_NORMAL
- en: The big reveal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A monad chains continuations.
  prefs: []
  type: TYPE_NORMAL
- en: Recall the monad from the hierarchy diagram of *Fantasy Land* algebras earlier
    in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: We'll talk a lot more about Monads in the last unit of our book, but for now
    let's take a sneak peak at the big picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier we saw composition of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef811db8-5f67-4b7b-a928-1dc30db9cbfe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s actually a problem because that''s not a Monoid. A Monoid looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/407d6776-83f1-4461-b0c3-3a57e09c632b.png)'
  prefs: []
  type: TYPE_IMG
- en: And that's the big reveal. Monads are purple!
  prefs: []
  type: TYPE_NORMAL
- en: Ha. Gotcha!
  prefs: []
  type: TYPE_NORMAL
- en: Besides the color, what can you see that's different between the monadic function
    and the ones above it?
  prefs: []
  type: TYPE_NORMAL
- en: What about the **a** going in and the **a** coming out? That means that if a
    Monoid accepts a parameter of type **A** (by convention, a lower case **a** variable
    is a value of type A), then it will spit out another **a** value.
  prefs: []
  type: TYPE_NORMAL
- en: Guess what that's called? When our function returns the same type that it's
    fed? We call that an *endomorphism* where *en* means *same* and *morphism* means
    *function*; So, it changes from an **a** to an **a**. Simple.
  prefs: []
  type: TYPE_NORMAL
- en: What about the *chain* word used in the *a monad chains continuations* statement?
  prefs: []
  type: TYPE_NORMAL
- en: How about a nice monoidal purple chain of functions?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b5e9082-3668-4085-b455-ccc7c63013fe.png)'
  prefs: []
  type: TYPE_IMG
- en: What else do we know about this purple monoid chain?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d74237cb-add8-4d04-b161-a28429f5e04a.png)'
  prefs: []
  type: TYPE_IMG
- en: If all functions are monids then we can combine them in any order (associativity
    rule).
  prefs: []
  type: TYPE_NORMAL
- en: Great, but what can we do with a Monoid chain? Can we run the processes in parallel?
  prefs: []
  type: TYPE_NORMAL
- en: Run in parallel? Well, that depends on what we're dealing with. Many things
    can run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, yes but in practice we'll need to deal with the same considerations
    other Map/Reduce solutions such as Hadoop must deal with.
  prefs: []
  type: TYPE_NORMAL
- en: MapReduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**MapReduce** is a technique that splits big datasets into many smaller ones.
    Each small dataset is separately, but simultaneously processed on different servers.
    The results are then gathered and aggregated to produce a final result.'
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a lot of web servers and we want to determine the top requested
    pages across all of them. We can analyze web server access logs to find all the
    requested URLs, count them, and sort the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the good use cases for MapReduce:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering statistics from servers, for example, top 10 users, top 10 requested
    URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute the frequencies of all keywords found in your data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the use cases not good for MapReduce:'
  prefs: []
  type: TYPE_NORMAL
- en: Jobs that require shared state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding individual records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MapReduce example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose we have an Apache web server access log files with entries that look
    like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What if we are interested in knowing the top 5 most accessed JSON files?
  prefs: []
  type: TYPE_NORMAL
- en: 'We could perform a MapReduce directly from the terminal using standard Unix
    string processing commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That works great for a few thousand lines. If we type `time` in front of that
    last command we get something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: But what if each server has millions of lines of code and we have a lot of servers?
  prefs: []
  type: TYPE_NORMAL
- en: Time for MapReduce!
  prefs: []
  type: TYPE_NORMAL
- en: 'On each server we can perform our mapping; Starting log file entries as input
    and resulting in a set of key value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae767c19-be83-409f-883e-8490b2595472.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we take each intermediate result from each server and feed them into
    our `reduce` function which then spits out the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d6ed4e7-cfdc-45d2-88b8-b811c23bac9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our top 5 most requested JSON files might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'What can we glean from this example? It looks like good candidates for MapReduce
    include use cases where:'
  prefs: []
  type: TYPE_NORMAL
- en: We have so much data that running it all sequentially on one server would take
    too long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our output, from the `map` phase, consists of a list of key, value pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can run each `map` or `reduce` function in isolation, knowing that the output
    of our function relies only on its input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But what else is going on here that might not be readily apparent?
  prefs: []
  type: TYPE_NORMAL
- en: What else makes this process of Map/Reduce work?
  prefs: []
  type: TYPE_NORMAL
- en: 'What FP patterns are lurking in the shadows? (Hint: We''ve already seen it
    and it has to do with data types.)'
  prefs: []
  type: TYPE_NORMAL
- en: What else can Monads do?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Monads can be used to clearly convey our business logic and manage our applications
    processing flows and more.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68aa7767-20aa-4a2f-8f40-89b44386c2af.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You know what I''m talking about. Consider the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Those `if err != nil`  blocks litter our code and obscure our code''s original
    intent. If this is our happy path code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what it looks like after we add error checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Guess what our FP code would look like after including error handling?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How can this be? No inline error checking? We'll cover this topic in [Chapter
    9](../Text/Ch09.xhtml), *Functors, Monoids, and Generics*.
  prefs: []
  type: TYPE_NORMAL
- en: Viva La Duck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next code example will illustrate several of the SOLID design principles
    applied to our Go implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In our Viva La Duck application, our duck must visit a number of ponds looking
    for bugs to eat. To keep things simple, we'll assume that each stroke will require
    the duck to eat one bug. Each time the duck paddles its feet (one stroke), the
    duck's supply of strokes is decreased by one.
  prefs: []
  type: TYPE_NORMAL
- en: We're not concerned with how the duck moves from pond to pond, but rather the
    number of strokes the duck must make to traverse the length of the pond. If a
    pond has bugs to eat, they will be found on the other side of the pond. If the
    duck runs out of energy, it dies.
  prefs: []
  type: TYPE_NORMAL
- en: Our program is a self-contained runnable Go source file. Its package name is
    `main` and it has a `main()` function. We'll use the `DASHES` constant later when
    we print the statistics indicating what the duck encountered at each pond.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Pond` struct contains the state of each pond, that is, the number of bugs
    it supplies for the duck to eat and how many strokes are required to cross the
    pond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: One of the first things we should do is define our system's behaviors in the
    form of simple interfaces. We should think about how we can embed our interfaces
    into a larger set of interfaces as we compose our system's behavior patterns. It
    makes sense to categorize a thing by its abilities because a thing is defined
    by its actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a book about functional programming, now would be a good time
    to mention that a major benefit of using interfaces is that they allow us to group
    our application''s functions in order to model real-life behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Each interface (`StrokeBehavior` and `EatBehavior`) represents a fine-grained,
    well-defined behavior. Breaking apart our system into small parts will make our
    application more flexible and more easily composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By declaring small, single purpose interfaces, we are now free to embed them
    in new, more feature-rich interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grouping interfaces is a common pattern we can find in the Go standard library.
    For example, in the `httputil` package, we find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type writeFlusher interface {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    io.Writer`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    http.Flusher`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define our duck. Our duck is stateless and has no fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We define two methods for our duck. The receiver, `Duck`, must be defined in
    the same package as our method, `Stroke`. Since we are only using a main package,
    that's not a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modeling our system after the real world, we define a `Foot` struct and a `PaddleFoot`
    method for that foot. Each time our duck paddles its foot, we''ll decrement our
    duck''s `strokeSupply` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we define a `Bill` type and its `EatBug` method that increments
    our duck''s `strokeSupply` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For every stroke, our duck will paddle its foot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Stroke` method will return an error if the duck runs out of energy and
    gets stuck in the middle of a pond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define our duck''s eating behavior. When our duck reaches the end of
    the pond, it gets to eat all the pond''s bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `SwimAndEat` method's signature is slightly different than that of `Eat`
    and `Stroke` methods. Notice the differences?
  prefs: []
  type: TYPE_NORMAL
- en: All three methods have a `Duck` as their receiver, but the `SwimAndEat` method
    defines the variable `d`. That's because we need to reference the `Stroke` and
    `Eat` methods within the `SwimAndEat` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, they all take an interface as their first parameter, but `SwimAndEat`
    takes a composed set of interfaces, namely `StrokeAndEatBehaviors`, which it uses
    polymorphically for both `Stroke` and `Eat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Pass by value or reference?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's the rule of thumb--if you want to share a state, then pass by reference,
    that is, use a pointer type; otherwise, pass by value. Since we need to update
    our duck's `strokeSupply` type in this `Stroke` method, we pass it as an `int`
    pointer (`*int`). So, pass a pointer parameter only when absolutely necessary.
    We should begin to code defensively, assuming that someone may try to run our
    code concurrently. When we pass our parameters by value, it's safe for concurrent
    use. When we pass by reference, we may need to add `sync.mutex` or some channels
    to coordinate concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our duck builds its energy back by eating more bugs that it gets from the pond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Since we are designing our software application to model the real world, things
    such as duck feet and duck bills are natural candidates for struct names to represent
    real-life objects. Feet are used to paddle and duck bills are used to eat bugs.
    Each paddle, that is, `stroke`, reduces our duck's supply of possible strokes.
    Each bug is worth one stroke.
  prefs: []
  type: TYPE_NORMAL
- en: 'We tell our duck''s foot to paddle. As long as the duck has energy, that is,
    it''s `strokeSupply` type is greater than zero, the duck will obey. However, if `strokeSupply`
    is zero, then our duck will be stranded in the middle of the pond before it gets
    to its next supply of bugs to eat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are passing a pointer to our supply of strokes. This means that
    our application is maintaining a state. We know that pure functional programming
    does not permit variable mutations. That''s okay because this chapter is about
    good software design using Go. Pure functional programming in Go is covered in
    [Chapter 1](../Text/Ch01.xhtml), *Pure Functional Programming in Go*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: For every pond that our duck encounters, it must swim and eat bugs to survive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our duck''s `SwimAndEat` method requires both `StrokeBehavior` and `EatBehavior`,
    we pass the `SurvivalEatBehaviors` interface set as its first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the duck's `Stroke` method takes `StrokeBehavior`, not `StrokeEatBehavior`!
    How is this possible? This is part of the magic of type embedding.
  prefs: []
  type: TYPE_NORMAL
- en: Type embedding with Go interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go allows us to declare a type inside another type. In our `SurvivalBehaviors`
    interface, we have declared two fields of type interface. Through inner type promotion,
    the Go compiler performs interface conversions and the inner interface becomes
    part of the outer interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `d.Stroke` function takes a `SurvivalBehaviors` type as though it received
    `StrokeBehavior`, and the `d.Eat` function takes a `SurvivalBehaviors` type as
    if it received `EatBehavior`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the outer type, `SurvivalBehaviors`, now implements the interface
    of both `StrokeBehavior` and `EatBehavior`.
  prefs: []
  type: TYPE_NORMAL
- en: Interface embedding to add minor features
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here''s another example of using interface embedding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: By embedding  `net.Conn` in our `BytesReadConn` we are able to override its
    `Read` method not only perform the `Conn.Read` operation, but also to count the
    number of bytes read.
  prefs: []
  type: TYPE_NORMAL
- en: There's an ELO song that's ringing in my head now.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d409a5b-5a74-46ce-89fa-cdd3259201bf.png)'
  prefs: []
  type: TYPE_IMG
- en: A Go error handling idiom
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There''s yet another common Go pattern at play in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Errors should be handled once and as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Some consider this as an antipattern that litters code with `if err != nil`
    blocks. We'll overlook that sentiment, for now, in favor of its simplicity and
    pragmatism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll define a `Capabilities` struct that embeds both behavior interfaces
    and all the important strokes fields. The `Capabilities` type defines what the
    duck can do. It has a number of strokes that it can use to cross each pond and
    two behaviors--one that increases its stroke count and the other that reduces
    the count but helps it to get close to its next source of food:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In Go, any method or field of an embedded/inner interface is accessible to the
    outer interface. Note that we're not saying parent or child, as that might imply
    inheritances. What we have is called inner type promotion, not inheritance. As
    long as an inner field or method name begins with a capital letter, it will be
    accessible to the outer object.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to run our program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, it's time to provide the duck with its starting resources and a list of
    ponds to swim in and see whether our duck survives to live another day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume our duck has five bugs in its belly, which is worth five strokes
    (we made our ponds and bugs very small to simplify our model):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Our duck''s first set of ponds will consist of two ponds. Each supplies only
    one bug. The first pond requires three strokes to reach the other side. The second
    pond requires two strokes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The call to the duck's `SwimAndEat` method uses the address of its capabilities
    because we want to share the duck's `Capabilities` object as our duck moves from
    one set of ponds to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of each day, after the duck has crossed each pond and eaten the
    bugs it finds, we display the duck''s statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the first day, the duck crossed two ponds and has two strokes
    in reserve to start a new day.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next day, our duck has only one pond to swim. Our duck has two bugs in
    its belly. There''re two bugs in this pond. Let''s see whether our duck makes
    it to the other side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, our duck did not have enough strokes to cross the pond. Bummer!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5d3a692-3c9e-4e87-b266-f0e6098cf409.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The moral of our story is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Model applications in meaningful (like real world) ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start by creating a set of behaviors as single responsibility interface types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compose simple interface types into larger, coherent sets of behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure each function accepts only the types of behaviors it requires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't be a duck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we saw how to use bad design using inheritance in Java and
    contrasted that solution to using composition in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Gang of Four**''s (**GoF**) epic book, *Design Patterns: Elements of
    Reusable Object-Oriented Software*, discussed design patterns that addressed design
    flaws in the object oriented languages like Java. For example, in the *Putting
    Reuse Mechanisms to Work* section, the GoF book states, *Favor object composition
    over class inheritance*.'
  prefs: []
  type: TYPE_NORMAL
- en: This design principle is not even applicable to Go. Go does not support inheritance.
    No extra thought or work is required for Go developers. Go promotes composition
    out-of-the-box.
  prefs: []
  type: TYPE_NORMAL
- en: '"These compositional techniques are what give Go its flavor, which is profoundly
    different from the flavor of C++ or Java programs."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Rob Pike'
  prefs: []
  type: TYPE_NORMAL
- en: Composition is a software design pattern we should use to build better APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by breaking our system into small parts: single responsibility interfaces.
    We can then put the pieces back together again. When we architect our APIs using
    composition, our applications have a better chance to grow and adapt to the requirements
    that may change over time. Our applications become easier to reason about and
    maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll persist in our pursuit of good design and will focus
    on the decorator pattern. We'll study Go's `Reader` and `Writer` interfaces and
    see why *less is more*. We'll implement channels in order to control the life
    cycle of a concurrent program and much more.
  prefs: []
  type: TYPE_NORMAL
