- en: The Python Automation Framework – Ansible Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous two chapters incrementally introduced different ways to interact
    with network devices. In [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml),
    *Low-Level Network Device Interactions*, we discussed Pexpect and Paramiko libraries
    that manage an interactive session to control the interactions. In [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml),
    *APIs and Intent-Driven Networking*, we started to think of our network in terms
    of API and intent. We looked at various APIs that contain a well-defined command
    structure and provide a structured way of getting feedback from the device. As
    we moved from [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml), *Low-Level
    Network Device Interactions*, to [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml),
    *APIs and Intent-Driven Networking*, we began to think about our intent for the
    network and gradually expressed our network in terms of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s expand upon the idea of translating our intention into network requirements.
    If you have worked on network designs, chances are the most challenging part of
    the process is not the different pieces of network equipment, but rather qualifying
    and translating business requirements into the actual network design. Your network
    design needs to solve business problems. For example, you might be working within
    a larger infrastructure team that needs to accommodate a thriving online e-commerce
    site that experiences slow site response times during peak hours. How do you determine
    if the network is the problem? If the slow response on the website was indeed
    due to network congestion, which part of the network should you upgrade? Can the
    rest of the system take advantage of the bigger speed and feed? The following
    diagram is an illustration of a simple process of the steps that we might go through
    when trying to translate our business requirements into a network design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/864b0e75-a6f0-4e3b-9115-d969d38f5605.png)Business logic to network
    deployment'
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, network automation is not just about faster configuration. It
    should also be about solving business problems, and accurately and reliably translating
    our intention into device behavior. These are the goals that we should keep in
    mind as we march on the network automation journey. In this chapter, we will start
    to look at a Python-based framework called **Ansible** that allows us to declare
    our intention for the network and abstract even more from the API and CLI.
  prefs: []
  type: TYPE_NORMAL
- en: A more declarative framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You woke up one morning in a cold sweat from a nightmare you had about a potential
    network security breach. You realized that your network contains valuable digital
    assets that should be protected. You have been doing your job as a network administrator,
    so it is pretty secure, but you want to put more security measures around your
    network devices just to be sure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, you break the objective down into two actionable items:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgrading the devices to the latest version of the software, which requires:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading the image to the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instructing the device to boot from the new image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proceeding to reboot the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying that the device is running with the new software image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configuring the appropriate access control list on the networking devices,
    which includes the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing the access list on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the access list on the interface, which in most cases is under the
    interface configuration section so that it can be applied to the interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Being an automation-focused network engineer, you want to write scripts to reliably
    configure the devices and receive feedback from the operations. You begin to research
    the necessary commands and APIs for each of the steps, validate them in the lab,
    and finally deploy them in production. Having done a fair amount of work for OS
    upgrade and ACL deployment, you hope the scripts are transferable to the next
    generation of devices. Wouldn't it be nice if there was a tool that could shorten
    this design-develop-deployment cycle?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter and in [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml), *The
    Python Automation Framework – Beyond Basics*, we will work with an open source
    automation tool called **Ansible**. It is a framework that can simplify the process
    of going from business logic to network commands. It can configure systems, deploy
    software, and orchestrate a combination of tasks. Ansible is written in Python
    and has emerged as one of the leading automation tools supported by network equipment
    vendors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A quick Ansible example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Cisco modules and examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Juniper modules and examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Arista modules and examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing this book, Ansible release 2.5 is compatible with Python
    2.6 and 2.7, with Python 3 support recently coming out of the technical review.
    Just like Python, many of the useful features of Ansible come from the community-driven
    extension modules. Even with Ansible core module supportability with Python 3,
    many of the extension modules and production deployments are still in Python 2
    mode. It will take some time to bring all the extension modules up from Python
    2 to Python 3\. Due to this reason, for the rest of this book, we will use Python
    2.7 with Ansible 2.2.
  prefs: []
  type: TYPE_NORMAL
- en: Why Ansible 2.2? Ansible 2.5, released in March 2018, offers many new network
    module features with a new connection method, syntax, and best practices. Given
    its relatively new features, most of the production deployment is still pre-2.5
    release. However, in this chapter, you will also find sections dedicated to Ansible
    2.5 examples for those who want to take advantage of the new syntax and features.
  prefs: []
  type: TYPE_NORMAL
- en: For the latest information on Ansible Python 3 support, check out [http://docs.ansible.com/ansible/python_3_support.html](http://docs.ansible.com/ansible/python_3_support.html).
  prefs: []
  type: TYPE_NORMAL
- en: As one can tell from the previous chapters, I am a believer in learning by examples.
    Just like the underlying Python code for Ansible, the syntax for Ansible constructs
    are easy enough to understand, even if you have not worked with Ansible before.
    If you have some experience with YAML or Jinja2, you will quickly draw the correlation
    between the syntax and the intended procedure. Let's take a look at an example
    first.
  prefs: []
  type: TYPE_NORMAL
- en: A quick Ansible example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with other automation tools, Ansible started out by managing servers before
    expanding its ability to manage networking equipment. For the most part, the modules
    and what Ansible refers to as the playbook are similar between server modules
    and network modules with subtle differences. In this chapter, we will look at
    a server task example first and draw comparisons later on with network modules.
  prefs: []
  type: TYPE_NORMAL
- en: The control node installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's clarify the terminology we will use in the context of Ansible.
    We will refer to the virtual machine with Ansible installed as the control machine,
    and the machines being managed as the target machines or managed nodes. Ansible
    can be installed on most of the Unix systems, with the only dependency of Python
    2.6 or 2.7\. Currently, the Windows operating system is not officially supported
    as the control machine. Windows hosts can still be managed by Ansible, as they
    are just not supported as the control machine.
  prefs: []
  type: TYPE_NORMAL
- en: As Windows 10 starts to adopt the Windows Subsystem for Linux, Ansible might
    soon be ready to run on Windows as well. For more information, please check the
    Ansible documentation for Windows ([https://docs.ansible.com/ansible/2.4/intro_windows.html](https://docs.ansible.com/ansible/2.4/intro_windows.html)).
  prefs: []
  type: TYPE_NORMAL
- en: On the managed node requirements, you may notice some documentation mentioning
    that Python 2.4 or later is a requirement. This is true for managing target nodes
    with operating systems such as Linux, but obviously not all network equipment
    supports Python. We will see how this requirement is bypassed for networking modules
    by local execution on the control node.
  prefs: []
  type: TYPE_NORMAL
- en: For Windows, Ansible modules are implemented in PowerShell. Windows modules
    in the core and extra repository live in a Windows/subdirectory if you would like
    to take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be installing Ansible on our Ubuntu virtual machine. For instructions
    on installation on other operating systems, check out the installation documentation
    ([http://docs.ansible.com/ansible/intro_installation.html](http://docs.ansible.com/ansible/intro_installation.html)).
    In the following code block, you will see the steps for installing the software
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can also use `pip` to install Ansible: `pip install ansible`. My personal
    preference is to use the operating system's package management system, such as
    Apt on Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now do a quick verification as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see how we can run different versions of Ansible on the same control
    node. This is a useful feature to adopt if you'd like to try out the latest development
    features without permanent installation. We can also use this method if we intend
    on running Ansible on a control node for which we do not have root permissions.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw from the output, at the time of writing this book, the latest release
    is 2.6.1\. Feel free to use this version, but given the relatively new release,
    we will focus on Ansible version 2.2 in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Running different versions of Ansible from source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can run Ansible from a source code checkout (we will look at Git as a version
    control mechanism in [Chapter 11](85c09606-4a40-46f3-82b8-0b20550fd64d.xhtml),
    *Working with Git*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To run different versions, we can simply use `git checkout` for the different
    branch or tag and perform the environment setup again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the Git commands seem a bit strange to you, we will cover Git in more detail
    in [Chapter 11](85c09606-4a40-46f3-82b8-0b20550fd64d.xhtml), *Working with Git*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are at the version you need, such as Ansible 2.2, we can run the update
    for the core modules for that version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the lab topology we will use in this chapter and [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml),
    *The Python Automation Framework – Beyond Basics*.
  prefs: []
  type: TYPE_NORMAL
- en: Lab setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter and in [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml),
    *The Python Automation Framework – Beyond Basics*, our lab will have an Ubuntu
    16.04 control node machine with Ansible installed. This control machine will have
    reachability for the management network for our VIRL devices, which consist of
    IOSv and NX-OSv devices. We will also have a separate Ubuntu VM for our playbook
    example when the target machine is a host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9f1dbd4a-6866-43af-ab4c-ef765483d7c4.png)Lab topology'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to see our first Ansible playbook example.
  prefs: []
  type: TYPE_NORMAL
- en: Your first Ansible playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first playbook will be used between the control node and a remote Ubuntu
    host. We will take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the control node can use key-based authorization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an inventory file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a playbook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute and test it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The public key authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing to do is copy your SSH public key from your control machine
    to the target machine. A full public key infrastructure tutorial is outside the
    scope of this book, but here is a quick walkthrough on the control node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about PKI at [https://en.wikipedia.org/wiki/Public_key_infrastructure](https://en.wikipedia.org/wiki/Public_key_infrastructure).
  prefs: []
  type: TYPE_NORMAL
- en: Because we are using key-based authentication, we can turn off password-based
    authentication on the remote node and be more secure. You will now be able to
    `ssh` from the control node to the remote node using the private key without being
    prompted for a password.
  prefs: []
  type: TYPE_NORMAL
- en: Can you automate the initial public key copying? It is possible, but is highly
    dependent on your use case, regulation, and environment. It is comparable to the
    initial console setup for network gears to establish initial IP reachability.
    Do you automate this? Why or why not?
  prefs: []
  type: TYPE_NORMAL
- en: The inventory file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We do not need Ansible if we have no remote target to manage, right? Everything
    starts with the fact that we need to perform some task on a remote host. In Ansible,
    the way we specify the potential remote target is with an inventory file. We can
    have this inventory file as the `/etc/ansible/hosts` file or use the `-i` option
    to specify the file during playbook runtime. Personally, I prefer to have this
    file in the same directory where my playbook is and use the `-i` option.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, this file can be named anything you like as long as it is in a
    valid format. However, the convention is to name this file `hosts`. You can potentially
    save yourself and your colleagues some headaches in the future by following this
    convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inventory file is a simple, plaintext INI-style ([https://en.wikipedia.org/wiki/INI_file](https://en.wikipedia.org/wiki/INI_file))
    file that states your target. By default, the target can either be a DNS FQDN
    or an IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the command-line option to test Ansible and the `hosts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By default, Ansible assumes that the same user executing the playbook exists
    on the remote host. For example, I am executing the playbook as `echou` locally;
    the same user also exists on my remote host. If you want to execute as a different
    user, you can use the `-u` option when executing, that is, `-u REMOTE_USER`.
  prefs: []
  type: TYPE_NORMAL
- en: The previous line in the example reads in the host file as the inventory file
    and executes the `ping` module on the host called `192.168.199.170`. Ping ([http://docs.ansible.com/ansible/ping_module.html](http://docs.ansible.com/ansible/ping_module.html))
    is a trivial test module that connects to the remote host, verifies a usable Python
    installation, and returns the output `pong` upon success.
  prefs: []
  type: TYPE_NORMAL
- en: You may take a look at the ever-expanding module list ([http://docs.ansible.com/ansible/list_of_all_modules.html](http://docs.ansible.com/ansible/list_of_all_modules.html))
    if you have any questions about the use of existing modules that were shipped
    with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get a host key error, it is typically because the host key is not in
    the `known_hosts` file, and is typically under `~/.ssh/known_hosts`. You can either
    SSH to the host and answer `yes` when adding the host, or you can disable this
    by checking on `/etc/ansible/ansible.cfg` or `~/.ansible.cfg` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have validated the inventory file and Ansible package, we can make
    our first playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Our first playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playbooks are Ansible's blueprint to describe what you would like to do to the
    hosts using modules. This is where we will be spending the majority of our time
    as operators when working with Ansible. If you are building a tree house, the
    playbook will be your manual, the modules will be your tools, while the inventory
    will be the components that you will be working on when using the tools.
  prefs: []
  type: TYPE_NORMAL
- en: The playbook is designed to be human readable, and is in YAML format. We will
    look at the common syntax used in the Ansible architecture section. For now, our
    focus is to run an example playbook to get the look and feel of Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, YAML was said to mean Yet Another Markup Language, but now, [http://yaml.org/](http://yaml.org/) has
    repurposed the acronym to be YAML ain't markup language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this simple 6-line playbook, `df_playbook.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In a playbook, there can be one or more plays. In this case, we have one play
    (lines two to six). In any play, we can have one or more tasks. In our example
    play, we have just one task (lines four to six). The `name` field specifies the
    purpose of the task in a human readable format and the `shell` module was used.
    The module takes one argument of `df`. The `shell` module reads in the command
    in the argument and executes it on the remote host. In this case, we execute the
    `df` command to check the disk usage and copy the output to a file named `df_temp.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can execute the playbook via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you log into the managed host (`192.168.199.170`, for me), you will see that
    the `df_temp.txt` file contains the output of the `df` command. Neat, huh?
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that there were actually two tasks executed in our output,
    even though we only specified one task in the playbook; the setup module is automatically
    added by default. It is executed by Ansible to gather information about the remote
    host, which can be used later on in the playbook. For example, one of the facts
    that the setup module gathers is the operating system. What is the purpose of
    gathering facts about the remote target? You can use this information as a conditional
    for additional tasks in the same playbook. For example, the playbook can contain
    additional tasks to install packages. It can do this specifically to use `apt`
    for Debian-based hosts and `yum` for Red Hat-based hosts, based on the operation
    system facts that were gathered in the setup module.
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious about the output of a setup module, you can find out what
    information Ansible gathers via `$ ansible -i hosts <host> -m setup`.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath the hood, there are actually a few things that have happened for
    our simple task. The control node copies the Python module to the remote host,
    executes the module, copies the module output to a temporary file, then captures
    the output and deletes the temporary file. For now, we can probably safely ignore
    these underlying details until we need them.
  prefs: []
  type: TYPE_NORMAL
- en: It is important that we fully understand the simple process that we have just
    gone through because we will be referring back to these elements later in this
    chapter. I purposely chose a server example to be presented here, because this
    will make more sense as we dive into the networking modules when we need to deviate
    from them (remember that we mentioned the Python interpreter is most likely not
    on the network gear).
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on executing your first Ansible playbook! We will look more
    into the Ansible architecture, but for now let's take a look at why Ansible is
    a good fit for network management. Remember that Ansible modules are written in
    Python? That is one advantage for a Pythonic network engineer, right?
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many infrastructure automation frameworks besides Ansible—namely Chef,
    Puppet, and SaltStack. Each framework offers its own unique features and models;
    there is no one right framework that fits all the organizations. In this section,
    I would like to list some of the advantages of Ansible over other frameworks and
    why I think this is a good tool for network automation.
  prefs: []
  type: TYPE_NORMAL
- en: I am listing the advantages of Ansible without comparing them to other frameworks.
    Other frameworks might adopt some of the same philosophy or certain aspects of
    Ansible, but rarely do they contain all of the features that I will be mentioning.
    I believe it is the combination of all the following features and philosophy that
    makes Ansible ideal for network automation.
  prefs: []
  type: TYPE_NORMAL
- en: Agentless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike some of its peers, Ansible does not require a strict master-client model.
    No software or agent needs to be installed on the client that communicates back
    to the server. Outside of the Python interpreter, which many platforms have by
    default, there is no additional software needed.
  prefs: []
  type: TYPE_NORMAL
- en: For network automation modules, instead of relying on remote host agents, Ansible
    uses SSH or API calls to push the required changes to the remote host. This further
    reduces the need for the Python interpreter. This is huge for network device management,
    as network vendors are typically reluctant to put third-party software on their
    platforms. SSH, on the other hand, already exists on the network equipment. This
    mentality has changed a bit in the last few years, but overall SSH is the common
    denominator for all network equipment while configuration management agent support
    is not. As you will remember from [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml), *Low-Level
    Network Device Interacti**ons*, newer network devices also provide an API layer,
    which can also be leveraged by Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Because there is no agent on the remote host, Ansible uses a push model to push
    the changes to the device, as opposed to the pull model where the agent pulls
    the information from the master server. The push model, in my opinion, is more
    deterministic as everything originates from the control machine. In a pull model,
    the timing of the `pull` might vary from client to client, and therefore results
    in change timing variance.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the importance of being agentless cannot be stressed enough when it comes
    to working with the existing network equipment. This is usually one of the major
    reasons network operators and vendors embrace Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to Wikipedia, idempotence is the property of certain operations in
    mathematics and computer science that can be applied multiple times without changing
    the result beyond the initial application ([https://en.wikipedia.org/wiki/Idempotence](https://en.wikipedia.org/wiki/Idempotence)).
    In more common terms, it means that running the same procedure over and over again
    does not change the system after the first time. Ansible aims to be idempotent,
    which is good for network operations that require a certain order of operations.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of idempotence is best compared to the Pexpect and Paramiko scripts
    that we have written. Remember that these scripts were written to push out commands
    as if an engineer was sitting at the terminal. If you were to execute the script
    10 times, the script will make changes 10 times. If we write the same task via
    the Ansible playbook, the existing device configuration will be checked first,
    and the playbook will only execute if the changes do not exist. If we execute
    the playbook 10 times, the change will only be applied during the first run, with
    the next 9 runs suppressing the configuration change.
  prefs: []
  type: TYPE_NORMAL
- en: Being idempotent means we can repeatedly execute the playbook without worrying
    that there will be unnecessary changes made. This is important as we need to automatically
    check for state consistency without any extra overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Simple and extensible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is written in Python and uses YAML for the playbook language, both of
    which are considered relatively easy to learn. Remember the Cisco IOS syntax?
    This is a domain-specific language that is only applicable when you are managing
    Cisco IOS devices or other similarly structured equipment; it is not a general
    purpose language beyond its limited scope. Luckily, unlike some other automation
    tools, there is no extra domain-specific language or DSL to learn for Ansible
    because YAML and Python are both widely used as general purpose languages.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the previous example, even if you have not seen YAML before,
    it is easy to accurately guess what the playbook is trying to do. Ansible also
    uses Jinja2 as a template engine, which is a common tool used by Python web frameworks
    such as Django and Flask, so the knowledge is transferable.
  prefs: []
  type: TYPE_NORMAL
- en: I cannot stress enough the extensibility of Ansible. As illustrated by the preceding
    example, Ansible starts out with automating server (primarily Linux) workloads
    in mind. It then branches out to manage Windows machines with PowerShell. As more
    and more people in the industry started to adapt Ansible, the network became a
    topic that started to get more attention. The right people and team were hired
    at Ansible, network professionals started to get involved, and customers started
    to demand vendors for support. Starting with Ansible 2.0, network automation has
    become a first-class citizen alongside server management. The ecosystem is alive
    and well, with continuous improvement in each of the releases.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the Python community, the Ansible community is friendly, and the attitude
    is inclusive of new members and ideas. I have first-hand experience of being a
    noob and trying to make sense of contribution procedures and wishing to write
    modules to be merged upstream. I can testify to the fact that I felt welcomed
    and respected for my opinions at all times.
  prefs: []
  type: TYPE_NORMAL
- en: The simplicity and extensibility really speak well for future proofing. The
    technology world is evolving fast, and we are constantly trying to adapt to it.
    Wouldn't it be great to learn a technology once and continue to use it, regardless
    of the latest trend? Obviously, nobody has a crystal ball to accurately predict
    the future, but Ansible's track record speaks well for future technology adaptation.
  prefs: []
  type: TYPE_NORMAL
- en: Network vendor support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's face it, we don't live in a vacuum. There is a running joke in the industry
    that the OSI layer should include a layer 8 (money) and 9 (politics). Every day,
    we need to work with network equipment made by various vendors.
  prefs: []
  type: TYPE_NORMAL
- en: Take API integration as an example. We saw the difference between the Pexpect
    and API approach in previous chapters. API clearly has an upper hand in terms
    of network automation. However, the API interface does not come cheap. Each vendor
    needs to invest time, money, and engineering resources to make the integration
    happen. The willingness for the vendor to support a technology matters greatly
    in our world. Luckily, all the major vendors support Ansible, as clearly indicated
    by the ever increasingly available network modules ([http://docs.ansible.com/ansible/list_of_network_modules.html](http://docs.ansible.com/ansible/list_of_network_modules.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Why do vendors support Ansible more than other automation tools? Being agentless
    certainly helps, since having SSH as the only dependency greatly lowers the bar
    of entry. Engineers who have been on the vendor side know that the feature request
    process is usually months long and many hurdles have to be jumped through. Any
    time a new feature is added, it means more time spent on regression testing, compatibility
    checking, integration reviews, and many more. Lowering the bar of entry is usually
    the first step in getting vendor support.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that Ansible is based on Python, a language liked by many networking
    professionals, is another great propeller for vendor support. For vendors such
    as Juniper and Arista who already made investments in PyEZ and Pyeapi, they can
    easily leverage the existing Python modules and quickly integrate their features
    into Ansible. As you will see in [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml), *The
    Python Automation Framework – Beyond Basics*, we can use our existing Python knowledge
    to easily write our own modules.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible already had a large number of community-driven modules before it focused
    on networking. The contribution process is somewhat baked and established, or
    as baked as an open source project can be. The core Ansible team is familiar with
    working with the community for submission and contribution.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for the increased network vendor support also has to do with
    Ansible's ability to give vendors the ability to express their own strength in
    the module context. We will see in the coming section that, besides SSH, the Ansible
    module can also be executed locally and communicate with these devices by using
    API. This ensures that vendors can express their latest and greatest features
    as soon as they make them available through the API. In terms of network professionals,
    this means that you can use the cutting-edge features to select the vendors when
    you are using Ansible as an automation platform.
  prefs: []
  type: TYPE_NORMAL
- en: We have spent a relatively large portion of space discussing vendor support
    because I feel that this is often an overlooked part in the Ansible story. Having
    vendors willing to put their weight behind the tool means you, the network engineer,
    can sleep at night knowing that the next big thing in networking will have a high
    chance of Ansible support, and you are not locked into your current vendor as
    your network needs to grow.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Ansible architecture consists of playbooks, plays, and tasks. Take a look
    at `df_playbook.yml` that we used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5d5fb374-caea-4662-ad0b-27dffe364640.png)Ansible playbook'
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole file is called a playbook, which contains one or more plays. Each
    play can consist of one or more tasks. In our simple example, we only have one
    play, which contains a single task. In this section, we will take a look at the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**YAML**: This format is extensively used in Ansible to express playbooks and
    variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inventory**: The inventory is where you can specify and group hosts in your
    infrastructure. You can also optionally specify host and group variables in the
    inventory file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variables**: Each of the network devices is different. It has a different
    hostname, IP, neighbor relations, and so on. Variables allow for a standard set
    of plays while still accommodating these differences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates**: Templates are nothing new in networking. In fact, you are probably
    using one without thinking of it as a template. What do we typically do when we
    need to provision a new device or replace an RMA (return merchandise authorization)?
    We copy the old configuration over and replace the differences such as the hostname
    and the loopback IP addresses. Ansible standardizes the template formatting with
    Jinja2, which we will dive deeper into later on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml), *The Python Automation
    Framework – Beyond Basics*, we will cover some more advanced topics such as conditionals,
    loops, blocks, handlers, playbook roles, and how they can be included with network
    management.
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'YAML is the syntax used for Ansible playbooks and some other files. The official
    YAML documentation contains the full specifications of the syntax. Here is a compact
    version as it pertains to the most common usage for Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: A YAML file starts with three dashes (`---`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whitespace indentation is used to denote structures when they are lined up,
    just like Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments begin with the hash (`#`) sign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List members are denoted by a leading hyphen (`-`), with one member per line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists can also be denoted via square brackets (`[]`), with elements separated
    by a comma (`,`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dictionaries are denoted by key: value pairs, with a colon for separation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries can be denoted by curly braces, with elements separated by a comma
    (`,`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings can be unquoted, but can also be enclosed in double or single quotes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, YAML maps well into JSON and Python datatypes. If I were to
    rewrite `df_playbook.yml` into `df_playbook.json`, this is what it would look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is obviously not a valid playbook, but serves as an aid in helping to
    understand the YAML formats while using the JSON format as a comparison. Most
    of the time, comments (`#`), lists (`-`), and dictionaries (key: value) are what
    you will see in a playbook.'
  prefs: []
  type: TYPE_NORMAL
- en: Inventories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Ansible looks at the `/etc/ansible/hosts` file for hosts specified
    in your playbook. As mentioned previously, I find it more expressive to specify
    the host file via the `-i` option. This is what we have been doing up to this
    point. To expand on our previous example, we can write our inventory host file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have guessed, the square bracket headings specify group names, so
    later on in the playbook we can point to this group. For example, in `cisco_1.yml`
    and `cisco_2.yml`, I can act on all of the hosts specified under the `nexus` group
    to the group name of `nexus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A host can exist in more than one group. The group can also be nested as `children`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the datacenter group includes both the `cisco` and
    `arista` members.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss variables in the next section. However, you can optionally specify
    variables belonging to the host and group in the inventory file as well. In our
    first inventory file example, [`nexus:vars`] specifies variables for the whole
    nexus group. The `ansible_host` variable declares variables for each of the hosts
    on the same line.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the inventory file, check out the official documentation
    ([http://docs.ansible.com/ansible/intro_inventory.html](http://docs.ansible.com/ansible/intro_inventory.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed variables a bit in the previous section. Because our managed nodes
    are not exactly alike, we need to accommodate the differences via variables. Variable
    names should be letters, numbers, and underscores, and should always start with
    a letter. Variables are commonly defined in three locations:'
  prefs: []
  type: TYPE_NORMAL
- en: The playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inventory file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate files to be included in files and roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example of defining variables in a playbook, `cisco_1.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can see the `cli` variable declared under the `vars` section, which is being
    used in the task of `nxos_snmp_contact`.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the `nxso_snmp_contact` module, check out the online
    documentation ([http://docs.ansible.com/ansible/nxos_snmp_contact_module.html](http://docs.ansible.com/ansible/nxos_snmp_contact_module.html)).
  prefs: []
  type: TYPE_NORMAL
- en: To reference a variable, you can use the Jinja2 templating system convention
    of a double curly bracket. You don't need to put quotes around the curly bracket
    unless you are starting a value with it. I typically find it easier to remember
    and put a quote around the variable value regardless.
  prefs: []
  type: TYPE_NORMAL
- en: You may have also noticed the `{{ inventory_hostname }}` reference, which is
    not declared in the playbook. It is one of the default variables that Ansible
    provides for you automatically, and it is sometimes referred to as the magic variable.
  prefs: []
  type: TYPE_NORMAL
- en: There are not many magic variables, and you can find the list in the documentation
    ([http://docs.ansible.com/ansible/playbooks_variables.html#magic-variables-and-how-to-access-information-about-other-hosts](http://docs.ansible.com/ansible/playbooks_variables.html#magic-variables-and-how-to-access-information-about-other-hosts))).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have declared variables in an inventory file in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the variables in the inventory file instead of declaring them in the
    playbook, let''s add the group variables for `[nexus_by_name]` in the host file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the playbook to match what we can see here in `cisco_2.yml`, to
    reference the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in this example, we are referring to the `nexus_by_name` group in
    the inventory file, the `ansible_host` host variable, and the `username` and `password`
    group variables. This is a good way of hiding the username and password in a write-protected
    file and publish the playbook without the fear of exposing your sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: To see more examples of variables, check out the Ansible documentation ([http://docs.ansible.com/ansible/playbooks_variables.html](http://docs.ansible.com/ansible/playbooks_variables.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To access complex variable data that''s provided in a nested data structure,
    you can use two different notations. Noted in the `nxos_snmp_contact` task, we
    registered the output in a variable and displayed it using the debug module. You
    will see something like the following during playbook execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to access the nested data, we can use the following notation, as specified
    in `cisco_3.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You will receive just the value indicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we mentioned variables can also be stored in a separate file. To see
    how we can use variables in a role or included file, we should get a few more
    examples under our belt, because they are a bit complicated to start with. We
    will see more examples of roles in [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml),
    *The Python Automation Framework – Beyond Basics*.
  prefs: []
  type: TYPE_NORMAL
- en: Templates with Jinja2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we used variables with the Jinja2 syntax of `{{ variable
    }}`. While you can do a lot of complex things in Jinja2, luckily, we only need
    some of the basic things to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 ([http://jinja.pocoo.org/](http://jinja.pocoo.org/)) is a full-featured,
    powerful template engine that originated in the Python community. It is widely
    used in Python web frameworks such as Django and Flask.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, it is enough to just keep in mind that Ansible utilizes Jinja2 as
    the template engine. We will revisit the topics of Jinja2 filters, tests, and
    lookups as the situations call for them. You can find more information on the
    Ansible Jinja2 template here: [http://docs.ansible.com/ansible/playbooks_templating.html](http://docs.ansible.com/ansible/playbooks_templating.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible networking modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible was originally made for managing nodes with full operating systems
    such as Linux and Windows before it was extended to support network equipment.
    You may have already noticed the subtle differences in playbooks that we have
    used so far for network devices, such as the lines of `gather_facts: false` and
    `connection: local`; we will take a closer look at the differences in the following
    sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Local connections and facts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible modules are Python code that's executed on the remote host by default.
    Because of the fact that most network equipment does not expose Python directly,
    or they simply do not contain Python, we are almost always executing the playbook
    locally. This means that the playbook is interpreted locally first and commands
    or configurations are pushed out later on as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the remote host facts were gathered via the setup module, which
    was added by default. Since we are executing the playbook locally, the setup module
    will gather the facts on the localhost instead of the remote host. This is certainly
    not needed, therefore when the connection is set to local, we can reduce this
    unnecessary step by setting the fact gathering to false.
  prefs: []
  type: TYPE_NORMAL
- en: Because network modules are executed locally, for those modules that offer a
    backup option, the files are backed up locally on the control node as well.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important changes in Ansible 2.5 was the introduction of different
    communication protocols ([https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#multiple-communication-protocols](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#multiple-communication-protocols)).
    The connection method now includes `network_cli`, `netconf`, `httpapi`, and `local`.
    If the network device uses CLI over SSH, you indicate the connection method as
    `network_cli` in one of the device variables. However, due to the fact that this
    is a relatively recent change, you might still see the connection stated as local
    in many of the existing playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Provider arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen from [Chapter 2](d1720d17-6ae3-4886-89e3-f9ded2c88706.xhtml),
    *Low-Level Network Device Interactions,* and [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml),
    *APIs and Intent-Driven Networking*, network equipment can be connected via both
    SSH or API, depending on the platform and software release. All core networking
    modules implement a `provider` argument, which is a collection of arguments used
    to define how to connect to the network device. Some modules only support `cli`
    while some support other values, for example, Arista EAPI and Cisco NXAPI. This
    is where Ansible's "let the vendor shine" philosophy is demonstrated. The module
    will have documentation on which transport method they support.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Ansible 2.5, the recommended way to specify the transport method
    is by using the `connection` variable. You will start to see the provider parameter
    being gradually phased out from future Ansible releases. Using the `ios_command`
    module as an example, [https://docs.ansible.com/ansible/latest/modules/ios_command_module.html#ios-command-module](https://docs.ansible.com/ansible/latest/modules/ios_command_module.html#ios-command-module),
    the provider parameter still works, but is being labeled as deprecated. We will
    see an example of this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the basic arguments supported by the `provider` transport are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host`: This defines the remote host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: This defines the port to connect to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: This is the username to be authenticated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`: This is the password to be authenticated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transport`: This is the type of transport for the connection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authorize`: This enables privilege escalation for devices that require it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auth_pass`: This defines the privilege escalation password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, not all arguments need to be specified. For example, for our
    previous playbooks, our user is always at the admin privilege when logged in,
    therefore we do not need to specify the `authorize` or the `auth_pass` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'These arguments are just variables, so they follow the same rules for variable
    precedence. For example, if I change `cisco_3.yml` to `cisco_4.yml` and observe
    the following precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The username and password defined on the task level will override the username
    and password at the playbook level. I will receive the following error when trying
    to connect because the user does not exist on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The Ansible Cisco example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cisco's support in Ansible is categorized by the operating systems IOS, IOS-XR,
    and NX-OS. We have already seen a number of NX-OS examples, so in this section
    let's try to manage IOS-based devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our host file will consist of two hosts, `R1` and `R2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Our playbook, `cisco_5.yml`, will use the `ios_command` module to execute arbitrary
    `show commands`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is what we would expect as the `show version` and `show run` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'I wanted to point out a few things illustrated by this example:'
  prefs: []
  type: TYPE_NORMAL
- en: The playbook between NXOS and IOS is largely identical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax `nxos_snmp_contact` and `ios_command` modules follow the same pattern,
    with the only difference being the argument for the modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IOS version of the devices are pretty old with no understanding of API,
    but the modules still have the same look and feel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from the preceding example, once we have the basic syntax down
    for the playbooks, the subtle difference relies on the different modules for the
    task we would like to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible 2.5 connection example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have briefly talked about the addition of network connection changes in Ansible
    playbooks, starting with version 2.5\. Along with the changes, Ansible also released
    a network best practices document, [https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html).
    Let's build an example based on the best practices guide. For our topology, we
    will reuse the topology in [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml),
    *Low-Level Network Device Interactions*, with two IOSv devices. Since there are
    multiple files involved in this example, the files are grouped into a subdirectory
    named `ansible_2-5_example`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our inventory file is reduced to the group and the name of the hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a `host_vars` directory with two files. Each corresponds to
    the name specified in the inventory file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable file for the hosts contains what was previously included in the
    CLI variable. The additional variable of `ansible_connection` specifies `network_cli`
    as the transport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our playbook will use the `ios_config` module with the `backup` option enabled.
    Notice the use of the `when` condition in this example so that if there are other
    hosts with a different operating system, this task will not be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When the playbook is run, a new backup folder will be created with the configuration
    backed up for each of the hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This example illustrates the `network_connection` variable and the recommended
    structure based on network best practices. We will look at offloading variables
    into the `host_vars` directory and conditionals in [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml),
    *The Python Automation Framework – Beyond Basics*. This structure can also be
    used for the Juniper and Arista examples in this chapter. For the different devices,
    we will just use different values for `network_connection`.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible Juniper example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Ansible Juniper module requires the Juniper PyEZ package and NETCONF. If
    you have been following the API example in [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml),
    *APIs and Intent-Driven Networking*, you are good to go. If not, refer back to
    that section for installation instructions as well as some test script to make
    sure PyEZ works. The Python package called `jxmlease` is also required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the host file, we will specify the device and connection variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In our Juniper playbook, we will use the `junos_facts` module to gather basic
    facts for the device. This module is equivalent to the setup module and will come
    in handy if we need to take action depending on the returned value. Note the different
    value of transport and port in the example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, you will receive this output from the `Juniper` device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The Ansible Arista example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final playbook example we will look at will be the Arista command module.
    At this point, we are quite familiar with our playbook syntax and structure. The
    Arista device can be configured to use transport using `cli` or `eapi`, so, in
    this example, we will use `cli`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the host file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The playbook is also similar to what we have seen previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will show the standard output as we would expect from the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a grand tour of the open source automation framework
    Ansible. Unlike Pexpect-based and API-driven network automation scripts, Ansible
    provides a higher layer of abstraction called the playbook to automate our network
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible was originally constructed to manage servers and was later extended
    to network devices; therefore we took a look at a server example. Then, we compared
    and contrasted the differences when it came to network management playbooks. Later,
    we looked at the example playbooks for Cisco IOS, Juniper JUNOS, and Arista EOS
    devices. We also looked at the best practices recommended by Ansible if you are
    using Ansible version 2.5 and later.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml), *The Python Automation
    Framework – Beyond Basics*, we will leverage the knowledge we gained in this chapter
    and start to look at some of the more advanced features of Ansible.
  prefs: []
  type: TYPE_NORMAL
