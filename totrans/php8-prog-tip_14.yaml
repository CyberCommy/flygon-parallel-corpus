- en: '*Chapter 11*: Migrating Existing PHP Apps to PHP 8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, you have been warned of potential code breaks. Unfortunately,
    there are not really any good tools available that can scan your existing code
    and check for potential code breaks. In this chapter, we take you through the
    development of a set of classes that form the basis of a PHP 8 **backward-compatible**
    (**BC**) break scanner. In addition, you learn the recommended process to migrate
    an existing customer PHP application to PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: After reading through this chapter and carefully studying the examples, you
    are much better equipped to handle a PHP 8 migration. With knowledge of the overall
    migration procedure, you gain confidence and are able to perform PHP 8 migrations
    with a minimal number of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding development, staging, and production environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to spot BC breaks before a migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing the migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and troubleshooting the migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An x86_64-based desktop PC or laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 **gigabyte** (**GB**) free disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB of RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 500 **kilobits per second** (**Kbps**) or faster internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, you will need to install the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features*, for more information on Docker and Docker
    Compose installation, as well as how to build the Docker container used to demonstrate
    the code explained in this book. In this book, we refer to the directory in which
    you restored the sample code for this book as `/repo`.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter is located at [https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices).
    We can now begin our discussion by having a look at environments used as part
    of the overall migration process.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding development, staging, and production environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ultimate goal for a website update is to move the updated application code
    from development to production in as seamless a manner as possible. This movement
    of application code is referred to as **deployment**. Movement, in this context,
    involves copying application code and configuration files from one **environment**
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the details of migrating an application to PHP 8, let's first
    have a look at what these environments are. Gaining an understanding of what form
    the different environments might take is critical to your role as a developer.
    With this understanding, you are in a better position to deploy your code to production
    with a minimal amount of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the word *environment* to describe a combination of software stacks that
    include the operating system, web server, database server, and PHP installation.
    In the past, the environment equated to a *server*. In this modern age, however,
    the term *server* is deceptive in that it implies a physical computer in a metal
    box sitting on a rack in some unseen server room. Today, this is more likely not
    going to be the case, given the abundance of cloud service providers and highly
    performant virtualization technologies (for example, Docker). Accordingly, when
    we use the term *environment*, understand this to mean either a physical or virtual
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Environments are generally classified into three distinct categories: **development**,
    **staging**, and **production**. Some organizations also provide a separate **testing**
    environment. Let''s first have a look at what is common across all environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Common components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to note that what goes into all environments is driven by what
    is in the production environment. The production environment is the final destination
    of your application code. Accordingly, all other environments should match the
    operating system, database, web server, and PHP installation as closely as possible.
    Thus, for example, if the production environment enables the PHP OPCache extension,
    all other environments must enable this extension as well.
  prefs: []
  type: TYPE_NORMAL
- en: All environments, including the production environment, need to have an operating
    system and PHP installation at a minimum. Depending on the needs of your application,
    it's also quite common to have a web server and database server installed. The
    type and version of the web and database server should match that of the production
    environment as closely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, the closer your development environment matches that of the
    production environment, the less chance there is of a bug cropping up after deployment.
  prefs: []
  type: TYPE_NORMAL
- en: We now look at what goes into a development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Development environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The development environment is where you initially develop and test your code.
    It is unique in that it has the tools needed for application maintenance and development.
    This would include housing a source code repository (for example, Git), as well
    as various scripts needed to start, stop, and reset the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Often the development environment will have scripts to trigger an automated
    deployment procedure. Such scripts could take the place of **commit hooks**, designed
    to activate when you issue a commit to your source code repository. One example
    of this is **Git Hooks**, script files that can be placed in the `.git/hooks`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on Git Hooks, have a look at the documentation here: [https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks).'
  prefs: []
  type: TYPE_NORMAL
- en: The traditional development environment consisted of a personal computer with
    a database server, web server, and PHP. This conventional paradigm fails to take
    into account the variations that might be present in the target production environment.
    If you have 12 customers that you work with regularly, for example, it's highly
    unlikely that all 12 customers have exactly the same OS, database server, web
    server, and version of PHP! The *best practice* is to model the production environment
    as closely as possible in the form of a virtual machine or Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: The code editor or **IDE** (**Integrated Development Environment**) is thus
    not located inside the development environment. Rather, you perform code creation
    and editing outside of the development environment. You would then push your changes
    locally either by directly copying files into the virtual development environment
    via a shared directory, or by committing changes to the source code repository,
    and then pulling the changes from inside the development environment virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: It's also appropriate to perform unit testing in the development environment.
    Developing unit tests will not only give you greater assurance that your code
    works in production, but is also a great way to spot bugs in the early stages
    of application development. And, of course, you need to do as much debugging as
    possible in the local environment! Catching and fixing a bug in development generally
    takes a tenth of the time you might spend fixing a bug found in production!
  prefs: []
  type: TYPE_NORMAL
- en: Let's now examine the staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: Staging environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's quite common for large application development projects to have multiple
    developers all working on the same code base. In this situation, using version
    control repositories is critical. The *staging* environment is where all of the
    developers upload their code after development environment testing and debugging
    phases are complete.
  prefs: []
  type: TYPE_NORMAL
- en: The staging environment must be an *exact copy* of the production environment.
    You can visualize the staging environment as the last step on an assembly line
    in a car plant. This is where all of the various pieces coming from one or more
    development environments are fit into place. The staging environment is a prototype
    of how production should appear.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that often the staging server has direct internet access;
    however, it's usually located in a secure area that requires a password before
    you can gain access.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's have a look at the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Production environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The production environment is often maintained and hosted by the client directly.
    This environment is also referred to as the **live environment**. To make an analogy
    to a Bollywood production, if the development environment is practice, the staging
    environment is the dress rehearsal, and the production environment is the live
    show (perhaps minus the singing and dancing!).
  prefs: []
  type: TYPE_NORMAL
- en: The production environment has direct internet access but is protected by a
    firewall, and is often further protected by an intrusion detection and prevention
    system (for example, [https://snort.org/](https://snort.org/)). In addition, the
    production environment may be hidden behind a reverse proxy configuration that
    runs on an internet-facing web server. Otherwise, at least theoretically, the
    production environment should be an *exact clone* of the staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have an idea about the environments through which the application
    code moves on its way from development to production, let''s have a look at a
    critical first step in a PHP 8 migration: spotting potential BC code breaks.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to spot BC breaks before a migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, you should go into the PHP 8 migration with an action plan in hand.
    A critical part of this action plan includes getting an idea of how many potential
    BC breaks exist in your current code base. In this section, we show you how to
    develop a BC break sniffer that automates the process of looking through hundreds
    of code files for potential BC breaks.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll step back and review what we've learned so far about BC issues
    that might arise in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Gaining an overview of BC breaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You already know, having read the previous chapters in this book, that potential
    code breaks originate from several sources. Let''s briefly summarize the general
    trends that might lead to code failure after a migration. Please note that we
    do not cover these topics in this chapter as these are the topics that have all
    been covered in earlier chapters in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Resource-to-object migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum versions for supporting OS libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Iterator` to `IteratorAggregate` migration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Magic method signature enforcement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of the changes can be detected by adding a simple callback based upon `preg_match()`
    or `strpos()`. Usage changes are much more difficult to detect as at a glance
    there's no way for an automated break scanner to detect the result of usage without
    making extensive use of `eval()`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at how a break scan configuration file might appear.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a BC break scan configuration file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A configuration file allows us to develop a set of search patterns independently
    of the BC break scanner class. Using this approach, the BC break scanner class
    defines the actual logic used to conduct the search whereas the configuration
    file provides a list of specific conditions along with a warning and suggested
    remedial actions.
  prefs: []
  type: TYPE_NORMAL
- en: Quite a few potential code breaks can be detected by simply looking for the
    presence of the functions that have been removed in PHP 8\. For this purpose,
    a simple `strpos()` search will suffice. On the other hand, a more complex search
    might require that we develop a series of callbacks. Let's first have a look at
    how configuration might be developed based on a simple `strpos()` search.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a simple strpos() search configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the case of a simple `strpos()` search, all we need to do is to provide
    an array of key/value pairs, where the key is the name of the removed function,
    and the value is its suggested replacement. The search logic in the BC break scanner
    class can then do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will cover the full BC break scanner class implementation in the next section.
    For now, we just focus on the configuration file. Here''s how the first few `strpos()`
    search entries might appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, some PHP 8 backward incompatibilities might prove beyond the
    abilities of a simple `strpos()` search. We now turn our attention toward detecting
    potential breaks caused by the PHP 8 resource-to-object migration.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting BC breaks associated with is_resource()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B16992_07_Final_JC_ePub.xhtml#_idTextAnchor162), *Avoiding
    Traps When Using PHP 8 Extensions*, in the *PHP 8 extension resource to object
    migration* section, you learned that there is a general trend in PHP away from
    resources and toward objects. As you may recall, this trend in and of itself does
    not pose any threat of a BC break. However, if, in confirming that the connection
    has been made, your code uses `is_resource()`, there is a potential for a BC break.
  prefs: []
  type: TYPE_NORMAL
- en: In order to account for this BC break potential, our BC break scan configuration
    file needs to list any of the functions that formerly produced a resource but
    now produce an object. We then need to add a method in the BC break scan class
    (discussed next) that makes use of this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the potential configuration key of affected functions might appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the break scan class, all we need to do is to first confirm that `is_resource()`
    is called, and then check to see if any of the functions listed under the `BreakScan::KEY_RESOURCE`
    array are present.
  prefs: []
  type: TYPE_NORMAL
- en: We now turn out attention to **magic method signature** violations.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting magic method signature violations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHP 8 strictly enforces magic method signatures. If your classes use loose definitions
    where you do not perform method signature data typing, and if you do not define
    a return value data type for magic methods, you are safe from a potential code
    break. On the other hand, if your magic method signatures do contain data types,
    and those data types do not match the strictly defined set enforced in PHP 8,
    you have a potential code break on your hands!
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, we need to create a set of regular expressions needed to detect
    magic method signature violations. In addition, our configuration should include
    the correct signature. In this manner, if a violation is detected, we can present
    the correct signature in the resulting message, speeding up the update process.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how a magic method signature configuration might appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You might notice that we included an extra option, `types`. This is included
    in order to automatically generate a regular expression. The code that does this
    is not shown. If you are interested, have a look at `/path/to/repo/ch11/php7_build_magic_signature_regex.php`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how you might handle complex break detection where a simple
    `strpos()` search is not sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing complex BC break detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the case where a simple `strpos()` search proves insufficient, we can develop
    another set of key/value pairs where the value is a callback. As an example, take
    the potential BC break where a class defines a `__destruct()` method, but also
    uses `die()` or `exit()` in the `__construct()` method. In PHP 8 it's possible
    the `__destruct()` method might not get called under these circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such a situation, a simple `strpos()` search is insufficient. Instead, we
    must develop logic that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Checks to see if a `__destruct()` method is defined. If so, no need to continue
    further as there is no danger of a break in PHP 8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks to see if `die()` or `exit()` is used in the `__construct()` method.
    If so, issue a warning of a potential BC break.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our BC break scan configuration array, the callback takes the form of an
    anonymous function. It accepts the file contents as an argument. We then assign
    the callback to an array configuration key and include the warning message to
    be delivered if the callback returns `TRUE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In our BC break scanner class (discussed next), the logic needed to invoke
    the callbacks might appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the requirements to detect additional potential BC breaks are beyond the
    capabilities of a callback, we would then define a separate method directly inside
    the BC break scan class.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it's possible to develop a configuration array that supports
    not only simple `strpos()` searches, but also searches of greater complexity using
    an array of callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of what would go into a configuration array, it's
    time to define the main class that performs the break scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a BC break scan class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `BreakScan` class is oriented toward a single file. In this class, we define
    methods that utilize the various break scan configuration just covered. If we
    need to scan multiple files, the calling program produces a list of files and
    passes them to `BreakScan` one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BreakScan` class can be broken down into two main parts: methods that
    define infrastructure, and methods that define how to conduct given scans. The
    latter is primarily dictated by the structure of the configuration file. For each
    configuration file section, we''ll need a `BreakScan` class method.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the infrastructural methods first.
  prefs: []
  type: TYPE_NORMAL
- en: Defining BreakScan class infrastructural methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we have a look at the initial part of the `BreakScan` class.
    We also cover methods that perform infrastructure-related activities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set up the class infrastructure, placing it in the `/repo/src/Php8/Migration`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a set of class constants to render messages indicating the
    nature of any given post-scan failure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also define a set of constants that represent configuration array keys.
    We do this to maintain consistency between key definitions in the configuration
    file and calling program (discussed later):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then initialize key properties, representing the configuration, the contents
    of the file to be scanned, and any messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__construct()` method accepts our break scan configuration file as an
    argument, and cycles through all of the keys to ensure they exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a method that reads in the contents of the file to be scanned.
    Note that we remove carriage returns (`"\r"`) and linefeeds (`"\n"`) in order
    to make scanning via regular expression easier to process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the callbacks need a way to extract just the class name, or just the
    namespace. For that purpose, we define the static `getKeyValue()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This method looks for the keyword (for example, `class`). It then finds whatever
    follows the keyword up to the delimiter (for example, `'';''`). So, if you want
    to get the class name, you would execute the following: `$name = BreakScan::geyKeyValue($contents,''class'','';'')`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a way to retrieve and reset `$this->messages`. Here are the two
    methods to do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a method that runs all scans (covered in the next section).
    This method also collects the number of potential BC breaks detected and reports
    back the total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have an idea of how the basic `BreakScan` class infrastructure
    might appear, let's have a look at the individual scan methods.
  prefs: []
  type: TYPE_NORMAL
- en: Examining individual scan methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The four individual scan methods correspond directly to the top-level keys in
    the break scan configuration file. Each method is expected to accumulate messages
    about potential BC breaks in `$this->messages`. In addition, each method is expected
    to return an integer representing the total number of potential BC breaks detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now examine these methods in order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method we examine is `scanRemovedFunctions()`. In this method, we
    search for the function name followed either directly by an open parenthesis,
    `''(''`, or by a space and open parenthesis, `'' (''`. If the function is found,
    we increment `$found`, and add the appropriate warning and suggested replacement
    to `$this-> messages`. If no potential breaks are found, we add a success message
    and return `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The main problem with this approach is that if the function is not preceded
    by a space, its use would not be detected. However, if we do not include the leading
    space in the search, we could end up with a false positive. For example, without
    the leading space, every single instance of `foreach()` would trigger a warning
    by the break scanner when looking for `each()`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we have a look at a method that scans for `is_resource()` usage. If a
    reference is located, this method runs through the list of functions that no longer
    produce a resource. If both `is_resource()` and one of these methods is located,
    a potential BC break is flagged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have a look at what''s required to go through our list of callbacks.
    As you recall, we need to employ callbacks in situations where a simple `strpos()`
    is insufficient. Accordingly, we first collect all the callback subkeys and loop
    through each one in turn. If there is no bottom-level key *callback*, we throw
    an `Exception`. Otherwise, we run the callback, supplying `$this->contents` as
    an argument. If any potential BC breaks are found, we add the appropriate error
    message, and increment `$found`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we turn to by far the most complex method, which scans for invalid
    magic method signatures. The primary problem is that the method signatures vary
    widely, thus we need to build separate regular expressions to properly test validity.
    The regular expressions are stored in the BC break configuration file. If a magic
    method is detected, we retrieve its correct signature and add that to `$this->messages`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we check to see if there are any magic methods by looking for anything
    that matches `function __`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the array of matches is not empty, we loop through the set of matches and
    assign to `$key` the magic method name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If the configuration key matching this presumed magic method is not set, we
    assume it''s either not a magic method, or is a method not in the configuration
    file, and thus nothing to worry about. Otherwise, if a key is present, we extract
    a substring representing the method call that is assigned to `$sub`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We then pull the regular expression from the configuration and match it against
    the substring. The pattern represents a proper signature for that particular magic
    method. If `preg_match()` returns `FALSE`, we know the actual signature is incorrect
    and flag it as a potential BC break. We retrieve and store the warning message
    and increment `$found`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our examination of the `BreakScan` class. Now we turn our attention
    to defining the calling program needed to run the scans programmed into the `BreakScan`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Building a BreakScan class calling program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main job of the program that calls the `BreakScan` class is to accept a
    path argument and to recursively build a list of PHP files located in that path.
    We then loop through the list, extracting the contents of each file in turn, and
    run BC break scans. At the end, we present a report that can be either sparse
    or verbose, depending on the verbosity level selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind that both the `BreakScan` class and the calling program we are
    about to discuss are designed to run under PHP 7\. The reason we do not use PHP
    8 is because we assume that a developer would wish to run the BC break scanner
    *before* they do a PHP 8 update:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by configuring the autoloader and getting the path and verbosity levels
    either from the command line (`$argv`) or from the URL (`$_GET`). In addition,
    we present an option to write the results to a CSV file and accept as a parameter
    the name of such a file. You might note that we also perform a degree of input
    sanitization, although theoretically the BC break scanner will only be used on
    a development server, directly by a developer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We next confirm the path. If it''s not found, we exit and display usage information
    (`$usage` is not shown):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We then grab the BC break configuration file and create a `BreakScan` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To build a list of files we use a `RecursiveDirectoryIterator`, wrapped inside
    a `RecursiveIteratorIterator`, starting from the given path. This list is then
    filtered by `FilterIterator`, limiting the scan to PHP files only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If the developer chooses the CSV option, an `SplFileObject` instance is created.
    At the same time, we write out an array of headers. Further, we define an anonymous
    function that writes to the CSV file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We launch the scan by looping through the list of files presented by the `FilterIterator`
    instance. As we are scanning file by file, on each pass `$found` is zeroed out.
    We do maintain `$total`, however, to give a total count of potential BC breaks
    at the end. You might also note that we distinguish files from directories. If
    the directory changes, its name is displayed as a header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `SplFileObject::isDir()` to determine if the item in the file list is
    a directory. If so, we continue with the next item on the list. We then push the
    file contents into `$scanner` and run all scans. Messages are then retrieved in
    the form of a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a `switch()` block to take action based on the display level represented
    by `$show`. Level `0` only shows files where potential BC breaks are found. Level
    `1` shows that plus messages. Level `2` shows all possible output, including success
    messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we accumulate the totals and display the final results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have an idea how the calling might appear, let's have a look at
    the results of a test scan.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning application files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For demonstration purposes, in the source code associated with this book, we
    have included an older version of **phpLdapAdmin**. You can find the source code
    at `/path/to/repo/sample_data/phpldapadmin-1.2.3`. For this demonstration, we
    opened a shell into the PHP 7 container and ran the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a partial result from running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output, although `functions.php` passed the `scanMagicSignatures`
    and `scanIsResource` scans, this code file used three functions that have been
    removed in PHP 8: `__autoload()`, `create_function()`, and `each()`. You''ll also
    note that this file uses the `@` symbol to suppress errors, which is no longer
    effective in PHP 8.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you specified the CSV file option, you can open it in any spreadsheet program.
    Here''s how it appears in Libre Office Calc:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – CSV file open in Libre Office Calc'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.1_B16562.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – CSV file open in Libre Office Calc
  prefs: []
  type: TYPE_NORMAL
- en: You now have an idea of how to create an automated procedure to detect potential
    BC breaks. Please bear in mind that the code is far from perfect and doesn't cover
    every single possible code break. For that, you must rely upon your own judgment
    after having carefully reviewed the material in this book.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to turn our attention to the actual migration itself.
  prefs: []
  type: TYPE_NORMAL
- en: Performing the migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performing the actual migration from your current version to PHP version 8 is
    much like the process of deploying a new set of features to an existing application.
    If possible, you might consider running two websites in parallel until such time
    as you are confident the new version works as expected. Many organizations run
    the staging environment in parallel with the production environment for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we present a **twelve-step guide** to perform a successful
    migration. Although we are focused on migrating to PHP 8, these twelve steps can
    apply to any PHP update you may wish to perform. Understanding and following these
    steps carefully is critical to the success of your production website. Included
    in the twelve steps are plenty of places where you can revert to an earlier version
    if you encounter problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into details, here is a general overview of a twelve-step migration
    process going from an older version of PHP to PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: Carefully review the appropriate migration guide located in the PHP documentation
    appendices. In our case, we choose *Migrating from PHP 7.4x to PHP 8.0x*. ([https://www.php.net/manual/en/appendices.php](https://www.php.net/manual/en/appendices.php)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your current code works on the current version of PHP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back up the database (if any), all source code, and any associated files and
    assets (for example, CSS, JavaScript, or graphics images).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new branch for the soon-to-be-updated application code in your version
    control software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scan for BC breaks (possibly using the `BreakScan` class discussed in the previous
    section).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update any incompatible code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 5* and *6* as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload your source code to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the source code in a virtual environment updated to PHP 8 that closely
    simulates the production server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the virtualized simulation is not successful, return to *step 5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the staging server (or equivalent virtual environment) to PHP 8, making
    sure you can switch back to the old version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run every test you can imagine. If not successful, switch back to the master
    branch and return to *step 5*. If successful, clone the staging environment to
    production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now look at each step in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Review the migration guide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With every major release of PHP, the PHP core team posts a **migration guide**.
    The guide we are mainly concerned with in this book is *Migrating from PHP 7.4.x
    to PHP 8.0.x*, located at [https://www.php.net/manual/en/migration80.php](https://www.php.net/manual/en/migration80.php).
    This migration guide is broken down into four sections:'
  prefs: []
  type: TYPE_NORMAL
- en: New Features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backward Incompatible Changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated Features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other Changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are migrating to PHP 8.0 from a version other than PHP 7.4, you should
    also review all of the past migration guides from your current PHP version, up
    to PHP 8\. We'll now have a look at other recommended steps in the migration process.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Make sure the current code works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you start to make changes to the current code base to ensure it works
    in PHP 8, it's absolutely critical for you to make sure it's working. If the code
    isn't working now, it surely will not work once you migrate to PHP 8! Run any
    unit tests along with any **black-box tests** to ensure the code is functioning
    correctly in the current version of PHP.
  prefs: []
  type: TYPE_NORMAL
- en: If you make any changes to the current code before migration, be sure these
    changes are reflected in the main branch (often called the **master branch**)
    of your version control software.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Back up everything
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to back up everything. This includes the database, source code,
    JavaScript, CSS, images, and so forth. Also, please do not forget to back up important
    configuration files such as the `php.ini` file, the webserver configuration, and
    any other configuration file associated with PHP and web communications.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – Create a version control branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this step, you should create a new branch in your version control system
    and check out that branch. In the main branch, you should only have code that
    currently works.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how such a command might work using Git:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first command shown creates a branch called `php8_migration`. The second
    command causes `git` to switch to the new branch. In the process, all of your
    existing code gets ported to the new branch. The main branch is now safe and preserved
    from any changes made while in the new branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on version control using Git, have a look here: [https://git-scm.com/](https://git-scm.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – Scan for BC breaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it's time to put the `BreakScan` class to good use. Run the calling program
    and supply as arguments the starting directory path for your project as well as
    a verbosity level (`0`, `1`, or `2`). You can also specify a CSV file as a third
    option, as shown earlier in *Figure 11.1*.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 – Fix incompatibilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this step, knowing where the breaks reside, you can proceed to fix the incompatibilities.
    You should be able to do so in such a way that the code continues to run in the
    current version of PHP but can also run in PHP 8\. As we've pointed out consistently
    throughout this book, BC breaks, for the most part, stem from bad coding practices.
    By fixing the incompatibilities, you improve your code at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Step 7 – Repeat steps 5 and 6 as needed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a famous line, repeated in many Hollywood movies, where the doctor says
    to the anxious patient, *take two aspirin and call me in the morning*. The same
    advice applies to the process of addressing BC breaks. You must be patient, and
    continue to fix and scan, fix and scan. Keep on doing this until the scan reveals
    no more potential BC breaks.
  prefs: []
  type: TYPE_NORMAL
- en: Step 8 – Commit changes to the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you are relatively confident there are no further BC breaks, it's time
    to commit changes to the new PHP 8 migration branch you created in your version
    control software. Go ahead and push the changes at this point. You are then in
    a position to retrieve the updated code from this branch once you've sorted out
    the PHP update on the production server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember this important point: your current working code is safely stored in
    the main branch. You are only saving to the PHP 8 migration branch at this stage,
    so you can always switch back.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 9 – Test in a simulated virtual environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think of this step as a dress rehearsal for the real thing. In this step, you
    create a virtual environment (for example, using a Docker container) that most
    closely simulates the production server. In this virtual environment, you then
    install PHP 8\. Once the virtual environment has been created, you can open a
    command shell into it, and download your source code from the PHP 8 migration
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: You can then run unit tests, and any other tests you deem necessary in order
    to test the updated code. Hopefully, this is where you'll trap any additional
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Step 10 – Return to step 5 if the test is unsuccessful
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the unit tests, black-box tests, or other testing performed in the virtual
    environment show that your application code fails, you must return to *step 5*.
    To proceed to the live production site in the face of certain failure would be
    extremely ill-advised!
  prefs: []
  type: TYPE_NORMAL
- en: Step 11 – Install PHP 8 on the staging environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to install PHP 8 in the staging environment. As you might recall
    from our discussion in the first part of this chapter, the traditional flow is
    from the development environment, to staging, and then on to production. Once
    all testing has been completed on the staging environment, you can then clone
    staging to production.
  prefs: []
  type: TYPE_NORMAL
- en: PHP installation is well documented on the main [php.net](http://php.net) website,
    so there is no need for further detail here. Instead, in this section we give
    you a light overview of PHP installation, with a focus on the ability to switch
    between PHP 8 and your current PHP version.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For information on installing PHP in various environments, consult this documentation
    page: [https://www.php.net/manual/en/install.php](https://www.php.net/manual/en/install.php).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of illustration, we choose to discuss PHP 8 installation on
    two of the main branches of Linux: Debian/Ubuntu and Red Hat/CentOS/Fedora. Let''s
    start with Debian/Ubuntu Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing PHP 8 on Debian/Ubuntu Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to install PHP 8 is via the available set of pre-compiled binaries.
    Newer PHP versions tend to be made available much later than their release date,
    and PHP 8 is no exception. In this case, it's recommended that you resort to using
    a (**Personal Package Archive(PPA**). The PPA hosted at [https://launchpad.net/~ondrej](https://launchpad.net/~ondrej)
    is the most extensive and widely used.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to simulate the following steps on your own computer, run an Ubuntu
    Docker image with PHP 7.4 pre-installed using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In order to install PHP 8 on Debian or Ubuntu Linux, open a command shell onto
    the production server (or demo container), and, as the *root* user, proceed as
    follows. Alternatively, if *root* user access isn't available, preface each command
    shown with `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command shell, to install PHP 8, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update and upgrade the current set of packages using the **apt** utility. Any
    package manager can be used; however, we show the use of `apt` to maintain consistency
    between the installation steps covered here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `Ondrej PPA` repository to your `apt` sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Install PHP 8\. This installs only the PHP 8 core and basic extensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to scan the repository for additional extensions
    and use `apt` to install them as needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Do a PHP version check to ensure you''re now running PHP 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the version check output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a basic idea of how a PHP 8 installation might proceed, let's
    have a look at how to switch between the current version and PHP 8\. For the purposes
    of illustration, we assume that PHP 7.4 is the current PHP version prior to the
    PHP 8 installation.
  prefs: []
  type: TYPE_NORMAL
- en: Switching between PHP versions in Debian and Ubuntu Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you check to see where PHP is located, you will note that PHP 7.4, the earlier
    version, still exists following the PHP 8 installation. You can use `whereis php`
    for this purpose. The output on our simulation Docker Ubuntu container appears
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we now have both the 7.4 and 8.0 versions of PHP installed.
    To switch between the two, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You are then presented with an option screen allowing you to choose which PHP
    version should be active. Here is how the output screen appears on the Ubuntu
    Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: After switching, you can execute `php --version` again to confirm that the other
    version of PHP is active.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now turn our attention to PHP 8 installation on Red Hat Linux and its
    derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PHP 8 on Red Hat, CentOS, or Fedora Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHP installation on Red Hat, CentOS, or Fedora Linux follows a sequence of commands
    that are similar to the Debian/Ubuntu installation procedure. The main difference
    is that you would most likely use a combination of `dnf` and `yum` to install
    the pre-compiled PHP binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you care to follow along with the installation we outline in this section,
    you can use a Fedora Docker container with PHP 7.4 already installed. Here is
    the command to run the simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Much like the PPA environment described in the previous section, in the Red
    Hat world, the **Remi's RPM Repository** project ([http://rpms.remirepo.net/](http://rpms.remirepo.net/))
    provides pre-compiled binaries in **Red Hat Package Management** (**RPM**) format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install PHP 8 on Red Hat, CentOS, or Fedora, open a command shell onto the
    production server (or demo environment) and, as the *root* user, and proceed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, it''s a good idea to confirm the OS version and release you''re
    using. For that purpose, the `uname` command is used, along with a simple `cat`
    command to view the release (stored as a text file in the `/etc` directory):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Before getting started, be sure to update `dnf` and install the configuration
    manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You would then add Remi''s repository to your package sources, using the version
    number you prefer in place of `NN`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you can confirm the versions of PHP installed using `dnf module
    list`. We also use `grep` to limit the list of modules shown to PHP only. The
    `[e]` designation indicates *enabled*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check the current version of PHP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we reset the PHP module, and install PHP 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Another quick PHP version check shows us that we are now using PHP 8 instead
    of PHP 7:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To switch back to the earlier version of PHP, proceed as follows, where `X.Y`
    is the version you plan to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This completes the PHP installation instructions for Red Hat, CentOS, or Fedora.
    For this demonstration, we only showed you the PHP command-line installation.
    If you plan to use PHP with a web server, you also need to install either the
    appropriate PHP web server package, and/or install the PHP-FPM (FastCGI Processing
    Module) package.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at the last step.
  prefs: []
  type: TYPE_NORMAL
- en: Step 12 – Test and clone the staging environment to production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last step, you download the source code from your PHP 8 migration branch
    onto the staging environment and run every imaginable test to make sure everything's
    working. Once you are assured of success, you then clone the staging environment
    onto the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using virtualization, the clone procedure might simply involve creating
    an identical Docker container or virtual disk file. Otherwise, if actual hardware
    is involved, you will probably end up cloning the hard drive, or whatever method
    is appropriate for your setup.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of how to perform the migration. Let's now have
    a look at testing and troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and troubleshooting the migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an ideal world, the migration troubleshooting will take place on the staging
    server, or simulated virtual environment, well before the actual move to production.
    However, as the seasoned developer well knows, we need to hope for the best, but
    prepare for the worst! In this section, we cover additional aspects of testing
    and troubleshooting that can be easily overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this section, you can exit the temporary shell if you were
    following the Debian/Ubuntu or the Red Hat/CentOS/Fedora installation process.
    Return to the Docker container used for this course and open a command shell into
    the PHP 8 container. Please refer to the *Technical requirements* section of [*Chapter
    1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013), *Introducing New PHP 8 OOP
    Features*, for more information on how to do this if you are unsure.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and troubleshooting tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are too many fine testing and troubleshooting tools available to document
    here, so we focus on a few open source tools to help with testing and troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Xdebug
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Xdebug** is a tool that provides diagnostics, profiling, tracing, and step-debugging,
    among other features. It''s a PHP extension, and is thus able to give you detailed
    information in case you run into problems that you cannot easily solve. The main
    website is [https://xdebug.org/](https://xdebug.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the Xdebug extension, you can install it just as you would any other
    PHP extension: using the `pecl` command, or by downloading and compiling the source
    code from [https://pecl.php.net/package/xdebug](https://pecl.php.net/package/xdebug).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the following `/etc/php.ini` settings should be set, at a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 11.2* shows the output using the `xdebug_info()` command called from
    `/repo/ch11/php8_xdebug.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – xdebug_info() output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.2_B16562.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – xdebug_info() output
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at another tool that checks your application from an outside
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Using Apache JMeter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An extremely useful open source tool for testing web applications is **Apache
    JMeter** ([https://jmeter.apache.org/](https://jmeter.apache.org/)). It allows
    you to develop a series of test plans that simulate requests from a browser. You
    can simulate hundreds of user requests, each with their own cookies and session.
    Although mainly designed for HTTP or HTTPS, it's also capable of a dozen other
    protocols as well. In addition to an excellent graphical UI, it also has a command-line
    mode that makes it possible to incorporate JMeter in an automated deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: Installation is quite simple, involving a single download from [https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi).
    You must have the **Java Virtual Machine** (**JVM**) installed before JMeter will
    run. Test plan execution is beyond the scope of this book, but the documentation
    is quite extensive. Also, please bear in mind that JMeter is designed to be run
    from a client, not on the server. Accordingly, if you wish to test the website
    in the Docker container for this book, you'll need to install Apache JMeter on
    your local computer, and then build a test plan that points to the Docker container.
    Normally the IP address for the PHP 8 container is `172.16.0.88`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.3* shows the opening screen for Apache JMeter running on a local
    computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Apache JMeter'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.3_B16562.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Apache JMeter
  prefs: []
  type: TYPE_NORMAL
- en: From this screen you can develop one or more test plans, indicating the URL(s)
    to access, simulate `GET` and `POST` requests, set the number of users, and so
    forth.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you encounter this error while trying to run `jmeter`: `Can''t load library:
    /usr/lib/jvm/java-11-openjdk-amd64/lib/ libawt_xawt.so`, try installing *OpenJDK
    8*. You can then use the techniques mentioned in the earlier section to switch
    between versions of Java.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at potential issues with Composer following a PHP 8 upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Handling issues with Composer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One common issue developers face after the migration to PHP 8 has concluded
    is with third-party software. In this section, we discuss potential issues surrounding
    the use of the popular *Composer* package manager for PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first issue you might encounter has to do with versions of Composer itself.
    In the year 2020, Composer version 2 was released. Not all of the 300,000+ packages
    residing on the main packaging website ([https://packagist.org/](https://packagist.org/))
    have been updated to version 2, however. Accordingly, in order to install a given
    package, you might find yourself having to switch between Composer 2 and Composer
    1\. The latest releases of each version are available here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version 1: [https://getcomposer.org/download/latest-1.x/composer.phar](https://getcomposer.org/download/latest-1.x/composer.phar)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Version 2: [https://getcomposer.org/download/latest-2.x/composer.phar](https://getcomposer.org/download/latest-2.x/composer.phar)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another, more serious, issue has to do with platform requirements of the various
    Composer packages you might be using. Each package has its own `composer.json`
    file, with its own requirements. In many cases, the package provider might add
    a PHP version requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that while most Composer packages now work on PHP 7, the requirements
    were specified in such a manner as to exclude PHP 8\. After a PHP 8 update, when
    you use Composer to update your third-party packages, an error occurs and the
    update fails. Ironically, most PHP 7 packages will also work on PHP 8!
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we install a Composer project called `laminas-api-tools`. At
    the time of writing, although the package itself is ready for PHP 8, a number
    of its dependent packages are not. When running the command to install the API
    tools, the following error is encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The core problem, highlighted in the last portion of the output just shown,
    is that one of the dependent packages requires PHP `^7.0`. In the `composer.json`
    file, this indicates a range of versions from PHP 7.0 through to and including
    PHP 8.0\. In this particular example, the Docker container used runs PHP 8.1,
    so we have a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, in such cases, we are confident that if this package runs in PHP
    8.0, it should also run in PHP 8.1\. Accordingly, all we need to do is to add
    the `--ignore-platform-reqs` flag. When we retry the installation, as you can
    see from the following output, it is successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the output just shown, no platform requirement errors appear and we are able
    to continue working with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now turn our attention to unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Working with unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit testing using **PHPUnit** is a critical factor in the process of ensuring
    that an application will run after a new feature has been added, or after a PHP
    update. Most developers create a set of unit tests to at least perform the bare
    minimum required to prove that an application performs as expected. Tests are
    methods in a class that extends `PHPUnit\Framework\TestCase`. The core of the
    test is what is referred to as an **assertion**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Instructions on how to create and run tests are beyond the scope of this book.
    However, you can go through the excellent documentation with plenty of examples
    at the main PHPUnit website: [https://phpunit.de/](https://phpunit.de/).'
  prefs: []
  type: TYPE_NORMAL
- en: The problem you might encounter after a PHP migration is that **PHPUnit** ([https://phpunit.de/](https://phpunit.de/))
    itself might fail! The reason for this is because PHPUnit has a new release each
    year that corresponds to the version of PHP that is current for that year. The
    older versions of PHPUnit are based upon what versions of PHP are officially supported.
    Accordingly, it's entirely possible that the version of PHPUnit currently installed
    for your application is an older version that doesn't support PHP 8\. The simplest
    solution is to use Composer to perform an update.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the possible problem, let''s assume that the testing directory
    for an application currently includes PHP unit 5\. If we run a test in the Docker
    container that runs PHP 7.1, everything works as expected. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we run the same version but in the Docker container that''s running
    PHP 8, the results are quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, PHPUnit itself reports an error. The simple
    solution, of course, is that after a PHP 8 upgrade, you also need to re-run Composer
    and update all third-party packages you use along with your application.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of testing and troubleshooting. You now have an
    idea of what additional tools can be brought to bear to assist you in testing
    and troubleshooting. Please note, however, that this is by no means a comprehensive
    list of all testing and troubleshooting tools. There are many many more, some
    free and open source, others that offer a free trial period, and still more that
    are only available by purchase.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how the term *environment* is used rather than
    *server* because many websites these days use virtualized services. You then learned
    about three distinct environments used during the deployment phase: development,
    staging, and production.'
  prefs: []
  type: TYPE_NORMAL
- en: An automated tool that is able to scan your application code for potential code
    breaks was introduced next. As you learned in that section, a break-scanning application
    might consist of a configuration file that addresses removed functionality, changes
    to method signatures, functions that no longer produce resources, and a set of
    callbacks for complex usage detection, a scanning class, and a calling program
    that gathers filenames.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you were shown a typical twelve-step PHP 8 migration procedure that ensures
    a greater chance of success when you are finally ready to upgrade the production
    environment. Each step is designed to spot potential code breaks, with fallback
    procedures in case something goes wrong. You also learned how to install PHP 8
    on two common platforms as well as how to easily revert to the older version.
    Finally, you learned about a number of free open source tools that can assist
    in testing and troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, after carefully reading this chapter and studying the examples,
    you are now in a position to not only use existing testing and troubleshooting
    tools, but now have an idea of how to develop your own scanning tool that greatly
    reduces the risk of a potential code break after a PHP 8 migration. You also now
    have an excellent idea what is involved in a migration to PHP 8, and can carry
    out smoother transitions without fear of failure. Your new ability to anticipate
    and fix migration problems will ease any anxiety you might otherwise have experienced.
    You can also look forward to having happy and satisfied customers.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter introduces you to new and exciting trends in PHP programming
    that can improve performance even further.
  prefs: []
  type: TYPE_NORMAL
