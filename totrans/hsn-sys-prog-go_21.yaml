- en: Using CGO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to CGO, a Go runtime for the C language. It
    makes it possible to call C code from Go applications, and since C has a plethora
    of libraries available, this means that they can be leveraged in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using CGO from C and Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding type differences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, it requires the GCC compiler to be installed in your machine.
    This can easily be done on your Unix machine using the package manager. For Ubuntu,
    the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to CGO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CGO is the tool that makes it possible to run C code in a Go application. This
    feature has been around since Go reached version 1.0 in 2009 and allowed us to
    use existing C libraries when there were fewer packages available outside the
    standard library than today.
  prefs: []
  type: TYPE_NORMAL
- en: The C code is accessed through the `C` pseudo package, and it is accessed and
    called using the package name followed by the identifier, for instance, `C.print`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `import` declaration is preceded by a series of special comments, which
    specify what C source file the application should import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement can also be a multiline comment, which can contain more `include`
    directives, like the one from the example earlier, and even actual C code directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is important to avoid blank lines between the C comment and the `import`
    statement, otherwise the libraries and the code will be imported by CGO in the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Calling C code from Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use existing C code, made by us or by someone else, we need to call C from
    Go. Let''s perform a quick, complete example, where we are printing a string to
    the standard output using just C functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We are importing two C core libraries here, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stdio.h `: This contains the input and output methods. We are using `printf`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stdlib.h`: This contains general functions, including memory management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Looking at the preceding code, we notice that the variable that we are printing
    is not a normal Go `string`, but rather, it is obtained by the `C.CString` function that
    takes a string and returns a slice of `char`, because that''s how strings are
    treated in C. The function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The second thing we can observe is that we are deferring a call to `C.free`, passing
    the `s` variable that we defined, but converted to a different type. This function
    call is essential since the language is not garbage collected and, in order to
    free the memory used, the application needs to specifically call the C `free`
    function. This function receives a generic pointer, which is represented by the `unsafe.Pointer` type in
    Go. According to the Go documentation, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A pointer value of any type can be converted into a Pointer."'
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what we are doing, because the type of the string variable is
    the `*C.char` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Go code from C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just saw how to call C code from a Go application using the C package and
    the `import` statement. Now, we will see how to call Go code from C, which requires
    the use of another special statement called `export`. This is a comment that needs
    to be placed in the line above the function we want to export, followed by the
    name of that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The Go function needs to be declared as external in the C code. This will allow
    the C code to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this functionality by creating a Go app that exports a function,
    which is used by a C function. This gets called inside the Go `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding example that we have the `goAdd` function, which
    is exported to C with the `export` statement . The export name matches the name
    of the function, and there are no blank lines between the comment and the function.
  prefs: []
  type: TYPE_NORMAL
- en: We can notice that the types used in the signature of the exported function are
    not regular Go integers, but `C.int` variables. We will see how the C and Go systems
    differ in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The C and Go type systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to pass data around between C and Go, we need to pass the correct types
    by executing the right conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Strings and byte slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `string` type, which is a basic type in Go, does not exist in C. It has
    the `char` type, which represents a character, similar to Go's `rune` type, and
    strings are represented by an array of the `char` type, which is terminated with
    a `\0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The language makes it possible to declare character arrays directly as an array
    or as a string. The second declaration does not end the `0` value in order to
    end the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We already saw how to convert a Go string to a C character array using the
    following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function will allocate the string in the heap so that it will be the application's
    responsibility to free such memory using the `C.free` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to convert a slice of bytes to a C character pointer named `*char`,
    we can use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As it happens, for `C.CString`, the application allocates the data in the heap
    and leaves the responsibilities of freeing it to the Go application.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between these two functions is that the first produces `char[]` ,
    while the other creates `*char`. These two types are the equivalent of the Go
    `string` and `[]byte`, since the bytes of the first type cannot be changed, while
    the one from the second type can.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a series of functions that are used to convert the C types back to
    Go ones. As far as strings are concerned, there are two functions: `C.GoString`
    creates a string from the entire array, and `C.GoStringN` enables the creation
    of a string using an explicit length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To transform the C `*char` back to Go `[]byte`, there is a single function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `C.CBytes` function to modify a slice of bytes using C and convert
    it back to a Go slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Executing this application will show that when converting the byte slice, `b1`,
    to the C type as the `c1` variable, it will change address. The C slice returned
    by the C function, `c2`, will have the same address as `c1` because it is the
    same slice. When converted back to Go again and assigned to `b2`, it will have
    another address that is different from the initial Go byte slice, `b1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve the same result using the C string function. Let''s use the
    same C code from the previous example and change the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that when transferring the Go string and bytes values
    to C, the values are copied. As a consequence, the C code is not capable of editing
    them directly, but will edit the copy, leaving the original Go value intact.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C, the types of integers available have a number of similarities with Go,
    since there are signed and unsigned versions of each integer type in both languages,
    but they differ in terms of name and byte size. The C `sizeof` function makes
    it possible to check the size for each of these types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of integer types that are available in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signed types**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** | **Range** |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | 1 byte | [-128, +127] |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | 2 or 4 bytes | see `short` and `long` |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | 2 bytes | [-32 768, +32 767] |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | 4 bytes | [-2 147 483 648, +2 147 483 647] |'
  prefs: []
  type: TYPE_TB
- en: '| `long long` | 8 bytes | [-9 223 372 036 854 775 808, +9 223 372 036 854 775
    807] |'
  prefs: []
  type: TYPE_TB
- en: '**Unsigned types**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** | **Range** |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned `char` | 1 byte | [0, +255] |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned `int` | 2 or 4 bytes | see unsigned `short` or unsigned `long` |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned `short` | 2 bytes | [0, +65 535] |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned `long` | 4 bytes | [0, +4 294 967 295] |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned `long long` | 8 bytes | [0, +18 446 744 073 709 551 615 ] |'
  prefs: []
  type: TYPE_TB
- en: The size of `int` in `C` depends on the architecture—it used to be 2 bytes with
    16-bit processors, but with modern processors (32- and 64-bit), it's 4 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we move from the realm of Go to the realm of C, and vice versa, we lose
    all variable overflow information. The compiler will not warn us when we try to
    fit an integer variable into another one that does not have an adequate size.
    We can see this with a brief example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the value of `a` is a certain number, but the `short` and `long`
    variables do not have sufficient bytes, so they will have different values. The
    conversion shows that only the last bytes are taken from the variable when converting,
    and the other bytes are discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a useful list of C types and comparable Go types, as well as how to
    use them in Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **C type** | **Go Type** | **CGO type** |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | `int8` | `C.char` |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `int16` | `C.short` |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `int32, rune` | `C.long` |'
  prefs: []
  type: TYPE_TB
- en: '| `long long` | `int64` | `C.longlong` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `int` | `C.int` |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned `char` | `uint8, byte` | `C.uchar` |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned `short` | `uint16` | `C.ushort` |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned `long` | `uint32` | `C.ulong` |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned `long long` | `uint64` | `C.ulonglong` |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned `int` | `uint` | `C.uint` |'
  prefs: []
  type: TYPE_TB
- en: You can use this table as a reference when performing conversions and avoid
    errors derived from using the wrong type, since there are no overflow warnings
    when using CGO.
  prefs: []
  type: TYPE_NORMAL
- en: Float types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C, the `float` types are very similar to the Go ones:'
  prefs: []
  type: TYPE_NORMAL
- en: C offers `float`, which is 32 bit, and `double`, which is 64 bit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go has `float32` and `float64`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can cause rounding errors when converting from a 64-bit value to a 32-bit
    one, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows how the `math.Pi` value goes from `3.141592653589793`
    to `3.1415927`, causing an error of about `1/10⁷`.
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now see how it is possible to edit a Go variable from C using the `unsafe`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Editing a byte slice directly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It also possible to edit a Go byte slice directly using a dirty trick. From
    Go''s perspective, a slice is a trio of values:'
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to the first element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of slice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The capacity of the slice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In C, a byte slice is just a series of bytes, and a string is a character slice
    that ends with a `\0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the `unsafe` package to pass the pointer to the first element of
    the slice, we will be able to edit the existing byte slice directly without executing
    copies and transformations. We can see how to execute this conversion in the following
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The conversion is executed using the expression `(*C.char)(unsafe.Pointer(&b1[0]))`,
    which does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes the pointer to element zero for the slice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converts it into an unsafe pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converts the `byte` pointer into a `C.char` pointer, which shares the memory
    representation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `unsafe` package, we can also convert a numeric variable pointer to
    its C counterpart. This allows us to edit it directly in the C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example does exactly that; it halves the value of `a` in a C function,
    without copying and assigning the new value in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Working with slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go slices and C slices differ in one fundamental aspect—the Go version embeds
    both length and capacity, while in C, all we have is a pointer to the first element.
    This means that in C, length and capacity must be stored somewhere else, such
    as in another variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following Go function, which calculates the mean of a series
    of `float64` numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to have a similar function in C, we need to pass a pointer together
    with its length. This will avoid errors such as segmentation fault, which happens
    when an application tries to gain access to memory that has not been assigned
    to it. If the memory is still assigned to the application, the result is that
    it provides access to a memory area with an unknown value, causing unpredictable
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try this function using a Go wrapper that takes a slice and also passes
    the length to the C function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify what happens, we can also create a similar function that passes a
    length that is not correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When using this function, we will see that the application should not raise
    any segmentation fault error, but the result obtained will be different. This
    is because the second one will add a series of extra values to the mean calculation,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Working with structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After seeing how slices work, we will know how to handle complex data in C and
    Go using structures. For this, let's see the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Structures in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go structures use a technique called alignment, which consists of adding one
    or more bytes to data structures to make it fit into memory addresses better. Consider
    the following data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With 64-bit architecture calling `unsafe.Sizeof` on this structure, this will
    give us an unexpected result. What we are expecting is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 16 bytes from the string; 8 for the pointer to the first element, and 8 for
    the length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 byte for the Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 24 for the slice; 8 for the address, 8 for the length, and 8 for capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The total should be 41, but the function returns 48\. This happens because
    the compiler inserts extra bytes after the Boolean, to reach 8 bytes (64 bits)
    and optimize the operation for the CPU. The structure could be represented in
    memory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a7ca5c0-ffa9-472b-b28e-a18b81ac3a39.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the Boolean variable takes 1 bit, and that there are 7 extra
    bits added by the compiler. This is very helpful because it avoids the other variables
    that are store, half in one memory slot and half in another. This would require
    two reads and two writes per operation, with a significant drop in performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'If two or more fields are small enough to fit in one slot of 64 bits, they
    will be stored sequentially. We can see this with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure translates into the following memory representation on a 64-bit
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9aae8af8-9a10-4da7-99a2-37ef32281030.png)'
  prefs: []
  type: TYPE_IMG
- en: We can clearly see that both the Boolean variables, the `rune` and the `byte`,
    are in the same memory address, and a byte of padding is added to align the last
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Manual padding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go makes it possible to specify padding in structs manually using the blank
    identifier for fields. Take the following data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will have the following representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32a0f046-89da-45ac-9778-843da54b6b14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the blank identifier to specify padding manually and to optimize
    the data structure for a 64-bit architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow the application to store each `int32` in its own memory location
    because the blank fields will be acting as padding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e7bfe3d-cac4-411a-b7d5-a2ba6a158b94.png)'
  prefs: []
  type: TYPE_IMG
- en: Structures in C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structures in C share the same concept of alignment that Go uses, but they are
    always aligned using 4-byte padding. Unlike Go, it is possible to avoid padding
    entirely, which helps to save space by reducing memory usage. Let's find out more
    about this in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Unpacked structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each struct we define will be unpacked unless otherwise specified. We can define
    a structure in C as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it and populate it with values directly from our Go code without
    any issues arising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This small test will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that there is an extra blank field that is used for padding because
    the last field is 10 bytes, which is 2 bytes short of being a multiple of 4 (that
    is, 12 bytes).
  prefs: []
  type: TYPE_NORMAL
- en: Packed structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can define a packed struct in C using the `pragma pack` directive. We can
    pack the structure from before as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to use the C structure in our Go code, we will obtain a compile error,
    if using fields `c` and `d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to print the structure as we did for the unpacked version, we will
    see the reason why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from the output that the `c` and `d` fields, both of 4 bytes, are
    replaced by one empty field of 8 bytes that Go cannot access. Consequently, we
    cannot populate the structure from Go, but we can access this field in the C part
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow us to return a structure with the correct values. We can print
    it and see that the `_` field contains both the values of `c` and `d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the data, we need to create a Go structure that can host it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to read the raw bytes from the C structure and unpack it manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `C.GoBytes` function, which works for any pointer (not just bytes)
    and specifies the size of the struct we defined, which is stored in the constant, `C.sizeof_myStruct`.
    We can then proceed to read each field in order using the `binary.Read` function
    with **Little-Endian** (**LE**) encoding.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the resulting structure contains all the data in the correct
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: CGO recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now seen how to use CGO with integers, floating pointers, slices, and
    structures. This is a very powerful tool that facilitates the use of a lot of
    the existing C code in our Go applications. As we did for reflection in the previous
    chapter, we are now going to talk about the less obvious downsides of CGO.
  prefs: []
  type: TYPE_NORMAL
- en: Compilation and speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of Go''s trademarks is blazingly fast compilation times. When using CGO,
    the amount of work involved in the compilation is much higher, and involves more
    than just passing all the `.go` files to the Go compiler. The compilation process
    goes more or less as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: CGO needs to create C to Go and Go to C stubs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `make` command needs to be called to compile all the C source files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the files are combined in a `.o` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system's linker needs to verify that all the references between Go and C
    are valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this process goes smoothly, you can launch your application, but if you encounter
    any issues, you will need to check the errors between C and Go, which is not as
    easy as debugging a pure Go application.
  prefs: []
  type: TYPE_NORMAL
- en: Another drawback is that not every operating system comes with a `make` command
    out of the box. The C part may require some extra flags to compile correctly,
    and that cannot be handled by `go install` or `go build`. You will need to create
    a compilation script for your application, such as a `makefile` script.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While discussing how to let C and Go talk to one another, we saw that for each
    type, there is a conversion operation that needs to be executed. This can be straightforward,
    as it happens, for numbers, but a little bit more complex for strings, bytes,
    or slices, and even more when we talk about structures. These operations are not
    cost-free, both in terms of memory usage and performance. This will not be a problem
    for many applications, but if you're trying to achieve high performance, it could
    be your bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: The C code is not aware of what's happening in its Go counterpart. When it needs
    to be invoked, Go needs to pass the information about its stack to C in a format
    that is suitable for it. When the C code finishes its execution, the information
    about the stack state and the variables used needs to be transferred back from
    C to Go.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency from C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using CGO, you face the same problem that other languages face when creating
    bindings or wrappers to C code. You are completely dependent on it.
  prefs: []
  type: TYPE_NORMAL
- en: The Go application has to handle the way C uses memory and other resources,
    while the C application is not aware of what Go is doing and is not using any
    kind of concurrency, neither goroutines nor threads.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, C code is hard to debug, maintain, and replace if you're
    not a C developer. This way, sometimes it is better to write a library from the
    ground up, instead of relying on the existing C implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A very good example of this is `go-git` ([https://github.com/src-d/go-git](https://github.com/src-d/go-git)),
    which implements the Git protocol functionality in pure Go by imitating the existing
    C library, [libgit2](https://libgit2.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we saw a very powerful tool in the Go arsenal: CGO. This allows
    a Go application to run C code, which, in turn, can invoke Go functions. We saw
    that it requires a special `import` statement, `import "C"`, which is a pseudo
    package that contains all the C code available to Go. To export Go code and make
    it available to C, there is a special comment, `//export`, which makes the Go
    function available in the C namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: We saw that the C and Go type systems are very similar for some things, but
    very different for others. We saw that strings and byte arrays can be converted
    to C types, and vice versa. Integers in C and Go are also pretty similar, the
    main difference being the `int` type. In C, this is 4 bytes, while in Go, it is
    4 or 8 bytes, depending on the architecture. Floats are also pretty similar, with
    a 4- and 8-bit version in both C and Go, which just have different names.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to edit a numeric Go variable or a byte slice directly, without
    creating a copy. This is possible using the `unsafe.Pointer` function to force
    a casting that wouldn't otherwise be allowed. Slices in C are just pointers to
    the first element, and the length of the slice needs to be stored in another variable.
    That's why we created Go functions that take the slice and pass both parameters
    to their C counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Before talking about data structures, we must mention what alignment is, how
    Go achieves it, and how C alignment differs from that of Go. Data structures in
    CGO use alignment, and are pretty straightforward to use. If they are not packed,
    we can pass them around and extract values very easily. If the structure is packed
    instead, we cannot access some of its fields and we need a workaround to manually execute
    a conversion to Go.
  prefs: []
  type: TYPE_NORMAL
- en: The final topic focused on the downsides of CGO, from its slower building time
    to its drop in performance because of the conversion that is required, and how
    the application is going to end up being more difficult to maintain because of
    the C code.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this Go journey so far, and that it will help you to write
    modern, concurrent, and efficient applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is CGO?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you call C code from Go?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you use Go code in C?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What difference in data types is there between Go and C?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you edit Go values inside C code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main problem with packed data structures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main downfalls of CGO?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
