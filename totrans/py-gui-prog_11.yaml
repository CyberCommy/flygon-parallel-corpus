- en: Connecting to the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It seems that nearly every application needs to talk to the outside world sooner
    or later, and your `ABQ data entry` application is no exception. You've received
    some new feature requests that will require some interactions with remote servers
    and services. First, the quality assurance division is doing a study of how local
    weather conditions are impacting the environmental data in each lab; they've requested
    a way to download and store local weather data in the database on demand. The
    second request is from your boss, who is still required to upload daily CSV files
    to the central corporate servers. She would like this process streamlined and
    available at a mouse click.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to web services and downloading data using `urllib`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing more complex HTTP interactions using the `requests` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and uploading to FTP services using `ftplib`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP using urllib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time you open a website in your browser, you're using the **Hyper Text
    Transfer Protocol, or HTTP**. HTTP was created over 25 years ago as a way for
    web browsers to download HTML documents, but has evolved into one of the most
    popular client-server communication protocols for any number of purposes. Not
    only can we use it to move everything from plain text to streaming video across
    the Internet, but applications can also use it to transfer data, initiate remote
    procedures, or distribute computing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic HTTP transaction includes a client and a server, which function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**: The client creates a request.The request specifies an operation
    called a **method**. The most common methods are `GET`, for retrieving data, and
    `POST`, for submitting data. The request has a URL, which specifies the host,
    port, and path to which the request is being made, and headers which include metadata
    like the data-type or authorization tokens.  Finally, it has a payload, which
    may contain serialized data in key-value pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server**: The server receives the request and returns a response. The response
    has a header containing metadata such as the status code or content-type of the
    response. It also has a payload containing the actual content of the response,
    such as HTML, XML, JSON, or binary data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a web browser, these operations take place in the background, but our application
    will deal directly with request and response objects in order to talk to remote
    HTTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: Basic downloading with urllib.request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `urllib.request` module is a Python module for generating HTTP requests.
    It contains a number of functions and classes for generating HTTP requests, the
    most basic of which is the `urlopen()` function. The `urlopen()` function can
    create a `GET` or `POST` request and send it to a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore how `urllib` works; open a Python shell and execute the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `urlopen()` function takes, at a minimum, a URL string. By default, it makes
    a `GET` request to the URL and returns an object that wraps the response received
    from the server. This `response` object exposes metadata or content received from
    the server, which we can use in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much of the response''s metadata is found in the header, which we can extract
    using `getheader()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Responses have a status, indicating the error conditions encountered (if any)
    during the request process; the status has both a number and a text explanation,
    called `reason`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extract both from our `response` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, a `200` status means the transaction was a success. Client-side
    errors, such as sending a bad URL or incorrect permissions, are indicated by statuses
    in the 400s, while server-side problems are indicated by statuses in the 500s.
  prefs: []
  type: TYPE_NORMAL
- en: 'The payload of the `response` object can be retrieved using an interface similar
    to a file handle as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Just like a file handle, the response can only be read once, using the `read()`
    method; unlike a file handle, it can't be "rewound" using `seek()`, so it's important
    to save the response data in another variable if it needs to be accessed more
    than once. The output of `response.read()` is a bytes object, which should be
    cast or decoded into an appropriate object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have a `utf-8` string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the `GET` requests, `urlopen()` can also generate `POST` requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we include a `data` argument as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `data` value needs to be a URL-encoded bytes object. The URL-encoded data
    string consists of key-value pairs separated by ampersand (`&`) symbols, with
    certain reserved characters encoded to URL-safe alternatives (for example, the
    space character is `%20`, or sometimes just `+`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A string like this can be created by hand, but it''s easier to use the `urlencode`
    function provided by the `urllib.parse` module. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `data` argument must be bytes, not a string, so `encode()` must be called
    on the URL-encoded string before `urlopen` will accept it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try downloading the weather data needed for our application. The site
    we'll be using is `http://weather.gov`, which provides weather data within the
    United States. The actual URL we'll be downloading is [http://w1.weather.gov/xml/current_obs/STATION.xml](http://w1.weather.gov/xml/current_obs/STATION.xml),
    where `STATION` is replaced by the call-sign of the local weather station. In
    the case of ABQ, we'll be using KBMG, located in Bloomington, Indiana.
  prefs: []
  type: TYPE_NORMAL
- en: The QA team wants you to record the temperature (in degrees Celsius), relative
    humidity, air pressure (in millibars), and sky conditions (a string, like overcast
    or fair). They also need the date and time at which the weather was observed by
    the station.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a download function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to be creating several functions that access network resources
    for our application. These functions won''t be tied to any particular class, so
    we''ll just put them in their own file called `network.py`. Let''s take a look
    at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `network.py` in the `abq_data_entry` module directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s open `network.py` and start our weather download function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our function will take a `station` string as an argument, in case we need to
    change that later or if someone wants to use this application at a different facility.
    The function begins by building the URL for the weather data and requests it using
    `urlopen()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming things went okay, we just need to parse out this `response` data and
    put it into a form the `Application` class can pass to the database model. To
    determine how we''ll handle the response, let''s go back to the Python shell and
    examine the data in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As the URL indicated, the payload of the response is an XML document, most
    of which we won''t need. After some searching, though, we can find the fields
    we''re after as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Good, the data we need is there, so we just need to extract it from the XML
    string into a format our application can use. Let's take a moment to learn about
    parsing XML data.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing XML weather data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python standard library contains an `xml` package, which consists of several
    submodules for parsing or creating XML data. The `xml.etree.ElementTree` submodule
    is a simple, lightweight parser that should meet our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import `ElementTree` into our `network.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, back at the end of our function, we''ll parse the XML data in our `response` object
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `fromstring()` method takes an XML string and returns an `Element` object.
    To get at the data we need, we'll need to understand what an `Element` object
    represents, and how to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: XML is a hierarchical representation of data; an element represents a node in
    this hierarchy. An element begins with a tag, which is a text string inside angle
    brackets. Each tag has a matching closing tag, which is just the tag with a forward-slash
    prepended to the tag name. Between the opening and closing tags, an element may
    have other child elements or it may have text. An element can also have attributes,
    which are key-value pairs placed inside the angle brackets of the opening tag,
    just after the tag name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example of XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is an (incomplete) XML description of the solar system. The root element
    has a tag of `<star_system>` with an attribute of `starname`. Under this root
    element, we have four `<planet>` elements and a `<dwarf_planet>` element, each
    of which contains a text node with the planet's name. Some of the planet nodes
    also have child `<moon>` nodes, each containing a text node with the moon's name.
  prefs: []
  type: TYPE_NORMAL
- en: Arguably, this data could have been structured differently; for example, planet
    names could have been in a child `<name>` node inside the planet elements, or
    listed as an attribute of the `<planet>` tag. While XML syntax is well-defined,
    the actual structure of an XML document is up to the creator, so fully parsing
    XML data requires a knowledge of the way the data is laid out in the document.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the XML weather data that we downloaded in the shell earlier,
    you'll notice it's a fairly shallow hierarchy. Under the `<current_observations>`
    node, there are a number of child elements whose tags represent specific data
    fields like temperature, humidity, windchill, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get at these child elements, `Element` offers us the following variety of
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Returns** |'
  prefs: []
  type: TYPE_TB
- en: '| `iter()` | An iterator of all child nodes (recursively) |'
  prefs: []
  type: TYPE_TB
- en: '| `find(tag)` | The first element matching the given tag |'
  prefs: []
  type: TYPE_TB
- en: '| `findall(tag)` | A list of elements matching the given tag |'
  prefs: []
  type: TYPE_TB
- en: '| `getchildren()` | A list of the immediate child nodes |'
  prefs: []
  type: TYPE_TB
- en: '| `iterfind(tag)` | An iterator of all child nodes matching the given tag (recursive)
    |'
  prefs: []
  type: TYPE_TB
- en: 'When we downloaded the XML data earlier, we identified five tags containing
    the data we want to extract from this document: `<observation_time_rfc822>`, `<weather>`,
    `<temp_c>`, `<relative_humidity>`, and `<pressure_mb>`. We''ll want our `get_local_weather()`
    function to return a Python `dict` containing each of these keys.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the next lines in the `network.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our first line extracts the raw XML from the response and parses it into an
    `Element` tree, returning the root node to `xmlroot`. Then, we've set up `dict`
    containing the tags we want to extract from our XML data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s get the values by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For each of our tag names, we're going to use the `find()` method to try to
    locate the element with a matching tag in `xmlroot`. This particular XML document
    does not use duplicate tags, so the first instance of any tag should be the only
    one. If the tag is matched, we'll get back an `Element` object; if not, we get
    back `None`, so we need to make sure `element` is not `None` before trying to
    access its `text` value.
  prefs: []
  type: TYPE_NORMAL
- en: To finish the function just return `weatherdata` .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test this function in the Python shell; from a command line, navigate
    to the `ABQ_Data_Entry` directory and start a Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You should get back a `dict` with the current weather conditions in Bloomington,
    Indiana. You can find the station codes for other cities inside the U.S. at [http://w1.weather.gov/xml/current_obs/](http://w1.weather.gov/xml/current_obs/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our weather function, we just need to build the table for storing
    the data and the interface for triggering the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing weather data storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To store our weather data, we'll start by creating a table in the ABQ database
    to hold the individual observation data, then build a `SQLModel` method to store
    data in it. We don't need to worry about writing code to retrieve data from it,
    since our laboratory's QA team has their own reporting tools which they'll use
    to access it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SQL table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `create_db.sql` file, and add a new `CREATE TABLE` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We're using the `TIMESTAMP` data type on the record as a primary key; there's
    no point in saving the same timestamped observation twice, so this makes an adequate
    key. The `(0)` size after the `TIMESTAMP` data type indicates how many decimal
    places we need for the seconds' measurement. Since these measurements are taken
    approximately hourly, and we only need one every four hours or so (when the lab
    checks are done), we don't need fractions of seconds in our timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we're saving the time zone; always store time zone data with timestamps
    when it's available! It may not seem necessary, especially when your application
    will be run in a workplace that will never change time zones, but there are many
    edge cases such as daylight-saving time changes where the lack of a time zone
    can create major problems.
  prefs: []
  type: TYPE_NORMAL
- en: Run this `CREATE` query in your database to build the table, and let's move
    on to creating our `SQLModel` method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the SQLModel.add_weather_data() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over in `models.py`, let's add a new method to the `SQLModel` class called `add_weather_data()`,
    which takes a data `dict` as its only argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start this method by writing an `INSERT` query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is a straightforward parameterized `INSERT` query using variable names
    that match the `dict` keys that the `get_local_weather()` function extracts from
    the XML data. We should only need to pass this query and the data `dict` into
    our `query()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There is one problem, however; if we get a duplicate timestamp, our query will
    fail due to a duplicate primary key. We could do another query to check first,
    but that would be slightly redundant, since PostgreSQL itself checks for duplicate
    keys before inserting a new row. When it detects such an error, `psycopg2` raises
    an `IntegrityError` exception, so we just need to catch this exception and, if
    it gets raised, do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll wrap our `query()` call in the `try...except` blocks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, our data entry staff can call this method as often as they wish, but it
    will only save a record when there is a fresh observation to save.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the SettingsModel class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before leaving `models.py`, we will need to add a new application setting to
    store the preferred weather station. Add a new entry in the `SettingsModel.variables`
    dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We won't add a GUI for this setting, since users won't need to update it. It'll
    be up to us, or the system admin at other lab sites, to make sure this is properly
    set on each workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the GUI elements for weather download
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Application` object now needs to connect the weather download method from
    `network.py` to the database method in `SQLModel` with an appropriate callback
    method that the main menu classes can call. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `application.py` and start a new method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that in an error scenario, `urlopen()` can raise any number of exceptions,
    depending on what went wrong with the HTTP transaction. There isn''t really anything
    the application can do to handle such exceptions other than inform the user and
    exit the method. Therefore, we''ll catch the generic `Exception` and display the
    text in `messagebox` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the event that `get_local_weather()` succeeds, we simply need to pass the
    data on to our model method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In addition to saving the data, we've notified the user in the status bar that
    the weather was updated and displayed the timestamp of the update.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the callback method done, let''s add it to our `callbacks` dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can now add a command item for the callback in the main menu. On Windows,
    functionality like this goes in the `Tools` menu, and since neither the Gnome
    nor macOS guidelines seem to indicate a more appropriate location, we''ll implement
    a `Tools` menu in the `LinxMainMenu` and `MacOsMainMenu` classes to hold this
    command, just to be consistent.  In `mainmenu.py`, starting in the generic menu
    class, add a new menu as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this same menu to the macOS and Linux menu classes, and add the command
    to the Windows main menu''s `tools_menu`. After updating the menus, you can run
    the application and try the new command from the `Tools` menu. If all went well,
    you should see an indication in the status bar as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/70ad36a4-d8f7-4fd2-ab4c-544dbb793be8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should also connect to the database with your PostgreSQL client and check
    that the table contains some weather data now by executing the following SQL command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'That SQL statement should return output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `datetime` | `temperature` | `rel[hum]` | `pressure` | `conditions` |'
  prefs: []
  type: TYPE_TB
- en: '| `2018-02-14 22:53:00-06` | `15.00` | `87.00` | `1014.00` | `Overcast` |'
  prefs: []
  type: TYPE_TB
- en: HTTP using requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've been asked to create a function in your program to upload a CSV extract
    of the daily data to ABQ's corporate web services, which uses an authenticated
    REST API. While `urllib` is easy enough to use for simple one-off `GET` and `POST`
    requests, complex interactions involving authentication tokens, file uploads,
    or REST services can be frustrating and complicated using `urllib` alone. To get
    this done, we'll turn to the `requests` library.
  prefs: []
  type: TYPE_NORMAL
- en: '**REST** stands for **REpresentational State Transfer**, and is the name used
    for web services built around advanced HTTP semantics. In addition to `GET` and
    `POST`, REST APIs use additional HTTP methods like `DELETE`, `PUT`, and `PATCH`,
    along with data formats like XML or JSON, to present an API with a complete range
    of interactions.'
  prefs: []
  type: TYPE_NORMAL
- en: The third-party `requests` library is highly recommended by the Python community
    for any serious work involving HTTP (even the `urllib` documentation recommends
    it). As you'll see, `requests` removes many of the rough edges and outdated assumptions
    left in `urllib`, and provides convenient classes and wrapper functions for more
    modern HTTP transactions. Complete documentation on `requests` can be found at
    [http://docs.python-requests.org](http://docs.python-requests.org), but the next
    section will cover most of what you need to know to use it effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `requests` package is written in pure Python, so installing it with `pip`
    requires no compiling or binary downloads. Simply type `pip install --user requests`
    in the terminal and it will be added to your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your Python shell, and let''s make some requests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`requests.request` requires, at minimum, an HTTP method and a URL. Just like
    `urlopen()`, it constructs the appropriate request packet, sends it to the URL,
    and returns an object representing the server''s response. Here, we''re making
    a `GET` request to this author''s website.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `request()` function, `requests` has shortcut functions that
    correspond to the most common HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the same request can be made as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `get()` method requires only the URL and performs a `GET` request. Likewise,
    the `post()`, `put()`, `patch()`, `delete()`, and `head()` functions send requests
    using the corresponding HTTP method. All of the request functions take additional
    optional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can send data with a `POST` request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, unlike `urlopen()`, we can use a Python dictionary directly as
    a `data` argument; `requests` does the job of converting it to the proper bytes
    object for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the more common arguments used with request functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Argument** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `params` | Like `data`, but added to the query string rather than the payload
    |'
  prefs: []
  type: TYPE_TB
- en: '| `json` | JSON data to include in the payload |'
  prefs: []
  type: TYPE_TB
- en: '| `headers` | A dictionary of header data to use for the request |'
  prefs: []
  type: TYPE_TB
- en: '| `files` | A dictionary of `{fieldnames: file objects}` to send as a multipart
    form data request |'
  prefs: []
  type: TYPE_TB
- en: '| `auth` | Username and password tuple to use for basic HTTP digest authentication
    |'
  prefs: []
  type: TYPE_TB
- en: The requests.session() fucntion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web services, particularly privately owned ones, are often password protected.
    Sometimes, this is done using the older HTTP digest authentication system, which
    we can address using the `auth` argument of the request functions. More commonly
    these days though, authentication involves posting credentials to a REST endpoint
    to obtain a session cookie or authentication token that is used to validate subsequent
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: An endpoint is simply a URL that corresponds to data or functionality exposed
    by the API. Data is sent to or retrieved from an endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The `requests` method makes all of this simple by providing the `Session` class.
    A `Session` object allows you to persist settings, cookies, and connections across
    multiple requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `Session` object, use the `requests.session()` factory function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call request methods like `get()`, `post()`, and others on our
    `Session` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Token and cookie handling like this happens in the background, without any explicit
    action from us. Cookies are stored in a `CookieJar` object stored as our `Session`
    object's `cookies` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also set values on our `Session` object that will persist across requests
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've set the user-agent string to `Mozilla`, which will be
    used for all requests made from this `Session` object. We can also set default
    URL parameters using the `params` property or callback functions using the `hooks`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: The response objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The response objects returned from these request functions are not the same
    as those returned by `urlopen()`; they contain all the same data, but in a slightly
    different (and generally more convenient) form.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the response headers are already translated into a Python `dict`
    for us, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Another difference is that `requests` does not automatically raise an exception
    on HTTP errors. However, the `.raise_for_status()` response method can be called
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this URL will give an HTTP `404` error, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the option of dealing with HTTP errors using exception handling
    or more traditional flow control logic.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing API upload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start implementing our upload function, we need to figure out what kind of
    requests we're going to send. We've been provided with some documentation from
    the corporate office that describes how to interact with the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation tells us the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: We first need to obtain an authentication token. We do this by submitting a
    `POST` request to the `/auth` endpoint. The parameters of the `POST` request should
    include `username` and `password`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the authentication token acquired, we'll need to submit our CSV file. The
    request is a `PUT` request sent to the `/upload` endpoint. The file is uploaded
    as multipart form data specified in a `file` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already know enough to implement our REST upload function using `requests`,
    but before we do, let's create a service that we can use to test our code against
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test HTTP service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing code that interoperates with an outside service can be frustrating.
    We're going to need to send a lot of bad or test data to the service while writing
    and debugging our code; we don't want to do so against a production service, and
    a "test mode" is not always available. Automated tests can use a `Mock` object
    to patch out network requests altogether, but during development, it's nice to
    be able to see what's actually going to be sent out to the web service.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement a very simple HTTP server that will accept our requests and
    print out information about what it receives. We can do this using the Python
    standard library's `http.server` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module documentation shows the following example of a basic HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The server class, `HTTPServer`, defines an object that listens for HTTP requests
    on the configured address and port. The handler class, `BaseHTTPRequestHandler`,
    defines an object that receives the actual request data and returns response data.
    We'll use this code as a starting point, so save it outside the `ABQ_Data_Entry`
    directory in a file called `sample_http_server.py`.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this code, you'll have a web service running on port `8000` on your
    local computer; however, if you make any requests to this service either using
    `requests`, a tool like `curl`, or just a web browser, you'll find it only returns
    an HTTP `501` (`unsupported method`) error. To make a server that works sufficiently,
    like our target API for testing purposes, we'll need to create our own handler
    class that can respond to the necessary HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we''ll create our own handler class called `TestHandler` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Our corporate API uses the `POST` method to receive login credentials, and the
    `PUT` method to receive files, so both of those need to work. To make an HTTP
    method work in a request handler, we need to implement a `do_VERB` method, where
    `VERB` is our HTTP method name in all uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for `PUT` and `POST`  add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This alone doesn't address the problem, because these methods need to result
    in our handler sending some kind of response. We don't need any particular response
    for our purposes; just something with a status of `200` (`OK`) will do fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since both methods need this, let''s add a third method we can call from the
    other two as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is about the most minimal response required to satisfy most HTTP clients:
    a status of `200` and a header with a valid `Content-type`. This won''t send any
    actual data back to the client, but will tell the client its request was received
    and successfully processed.'
  prefs: []
  type: TYPE_NORMAL
- en: Something else we'd like to do in our methods is print out any data that was
    sent, so we can make sure our client is sending the right data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll implement the following method that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The handler object's `headers` property is a `dict` object containing the request
    headers, which includes the number of bytes sent (`content-length`). Apart from
    printing that information, we can also use it to read the data sent. The handler's
    `rfile` property is a file-like object containing the data; its `read()` method
    requires a length argument to specify how much data should be read, so we use
    our extracted `content-length` value. The returned data is a `bytes` object, so
    we decode it to `utf-8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have these two methods, let''s update `do_POST()` and `do_PUT()`
    to call them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, each method will print out the length and data it receives to `POST` or
    `PUT` as well as any data. Run this script in a terminal window so you can monitor
    its output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open a shell and let''s test it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the web server terminal, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We could implement additional functionality, like actually checking credentials
    and returning an authentication token, but for now this server does enough to
    help us write and test our client code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our network function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our test service is up and running, let''s start working on the network
    function that will interact with the REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating a function in `network.py` that will take a path to
    the CSV file, the upload and authentication URLs, and a username and password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re going to have to deal with authentication tokens, the first thing
    we should do is create a session. We''ll call it `session` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the session, we post our username and password to the authentication
    endpoint like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `session` object will automatically store the token we receive if we're
    successful. In the event of a problem, we've called `raise_for_status()`, so that
    the function will abort and the calling code can handle any exceptions raised
    by network or data problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we haven''t raised an exception, we must be authenticated at this
    point and can now submit the file. This will be done with a `put()` call as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: To send a file, we have to actually open it and pass it into `put()` as a file
    handle; notice we open it in binary-read mode (`rb`). The `requests` documentation
    recommends this as it ensures the correct `content-length` value will be calculated
    for the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'After sending the request, we close the file and check again for a failed status
    before ending the function, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Updating application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can call our new function from `Application`, we need to implement
    a way to create a CSV extract of the daily data. This will be used by more than
    one function, so we''ll implement it separately from the function that calls the
    upload code. Follow along with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we''ll need a temporary location to store our generated CSV file. 
    The `tempfile` module includes functions to work with temporary files and directories;
    we''ll import `mkdtemp()`, which will give us a name for a platform-specific temporary
    directory.:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that `mdktemp()` doesn't actually create a directory; it merely provides
    an absolute path to a randomly named directory in the platform's preferred `temp`
    file location. We'll have to create the directory ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start our new `Application` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: After creating a temporary directory name, we've created an instance of our
    `CSVModel` class; even though we're no longer storing our data in the CSV files,
    we can still use the model to export a CSV file. We've passed the `Application`
    object's default filename, which is still set to `abq_data_record-CURRENTDATE.csv`,
    and also the temporary directory's path as `filepath`. Of course, our `CSVModel`
    doesn't currently take a `filepath`, but we'll fix that in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the CSV model, we''ll extract our records from the database
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Remember that our `SQLModel.get_all_records()` method returns a list of all
    records for the current day by default. If we don't happen to have any records
    for the day, it's probably best to stop right away and alert the user, rather
    than sending an empty CSV file to corporate, so we return `None` from the method
    if there are no records. Our calling code can test for a `None` return value and
    display the appropriate warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we need to do is iterate through the records and save each one to the
    CSV, then return the `CSVModel` object''s filename, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a way to create a CSV extract file, we can write the callback
    method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To begin, we created a CSV extract file and checked if it's `None`. If it is,
    we'll display an error message and exit the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can upload, we need to get a username and password from the user.
    Fortunately, we have the perfect class for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Our login dialog serves us well here. Unlike with our database login, we're
    not going to run this in an endless loop; if the password is wrong, the user can
    just rerun the command. Recall that `result` will be `None` if the user clicks
    Cancel, so we'll just exit the callback method in that case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can execute our network function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We're executing `upload_to_corporate_rest()` in a `try` block since there are
    a number of exceptions it might raise. We're passing in the upload and authentication
    URLs from our settings object; we haven't added those yet, so that will need to
    happen before we're done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s catch a few exceptions, starting with the `RequestException`. 
    This exception would happen if there were some problem with the data we were sending
    to the API, most likely a wrong username and password. We''ll attach the exception
    string to the message we show the user, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we''ll catch `ConnectionError`; this exception is going to be the result
    of a network problem, such as the internet connection at the lab being down, or
    the server not responding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Any other exception will just be displayed as `General Exception`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s wrap up the method with a success dialog as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s finish our changes to `Application` by adding this method to `callbacks` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Updating the models.py file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a couple of things to fix in the `models.py` file before we can test
    our new functionality.  We''ll go through these steps to address them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, our `CSVModel` class needs to be able to take `filepath`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If `filepath` is specified, we need to first make sure the directory exists.
    Since the `mkdtmp()` method called in the `Application` class does not actually
    create a temporary directory, we'll create it here. Once that's done, we'll join
    the `filepath` and `filename` values and store it in the `CSVModel` object's `filename`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other thing we need to do in `models.py` is add our new settings. Scroll
    down to the `SettingsModel` class, and add two more `variables` entries as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We won't be building a GUI to set these settings they'll need to be manually
    created in a user's configuration file, though for testing, we can use the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing to do is add the command to our main menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new entry to the `tools_menu` in each menu class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the application and let's try it out. To make it work, you'll need
    to have at least one data entry, and you'll need to start up the `sample_http_server.py`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all goes well, you should get a dialog like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/96de4996-9652-43f1-a4c6-a2d6bddc73de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Your server should also have printed some output to the terminal similar to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `POST` and `PUT` requests, as well as the raw text of the CSV file
    in the payload of `PUT`. We have successfully met the API requirements for this
    function.
  prefs: []
  type: TYPE_NORMAL
- en: FTP using ftplib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While HTTP and REST APIs are the current trend in client-server interactions,
    it''s not unusual for businesses to rely on older, time tested, and sometimes
    obsolete technology to implement data transfers. ABQ is no exception: in addition
    to the REST upload, you need to implement support for ABQ corporate''s legacy
    system that relies on FTP.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic concepts of FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**File Transfer Protocol**, or **FTP**, dates back to the early 1970s, predating
    HTTP by almost 20 years. Nevertheless, it''s still commonly used by many organizations
    to exchange large files over the internet. FTP is considered somewhat obsolete
    in many circles due in part to the fact that it transmits data and credentials
    in clear text, though SSL-encrypted variants of FTP are also available.'
  prefs: []
  type: TYPE_NORMAL
- en: Like HTTP, FTP clients send requests containing plain text commands similar
    to HTTP methods, and the FTP server returns a response packet containing header
    and payload information.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, however, many significant differences between the two protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: FTP is a **stateful connection**, meaning the client and server maintain a constant
    connection over the course of the session. In other words, FTP is more like a
    live telephone call, whereas HTTP is like two people having a dialog over voicemail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FTP requires a session to be authenticated before any other commands or data
    are sent, even for anonymous users. FTP servers also implement a more complex
    set of permissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FTP has separate modes for transferring text and binary data (the main difference
    being that text mode transfers automatically correct line endings and encoding
    for the receiving OS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FTP servers are less consistent in their implementation of commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a test FTP service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we implement our FTP upload functionality, it's helpful to have a test
    FTP service, just as we did with our test HTTP service. You can, of course, download
    any of a number of free FTP servers such as FileZilla, PureFTPD, ProFTPD, or others.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than going to the trouble of installing, configuring, and later removing
    an FTP service on your system just for testing one function of an application,
    we can instead build a rudimentary server in Python. The third-party `pyftpdlib`
    package offers us an easy way to implement a quick-and-dirty FTP server adequate
    for test needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `pyftpdlib` using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Just like our simple HTTP server, the FTP service consists of a *server* object
    and a *handler* object. It also needs an *authorizer* object to handle authentication
    and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start our `basic_ftp_server.py` file by importing those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure our authentication code works properly, let''s set up our `DummyAuthorizer`
    class with a test user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `perm` argument takes a string of characters, each of which represents a
    specific permission on the server. In this case, we have `e` (connect), `l` (list),
    `r` (read), and `w` (write new file). There are many other permissions available,
    all of which are off by default until granted, but this is sufficient for our
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s set up the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Notice we're not instantiating the handler, just aliasing the class. The server
    class will manage the creation of handler classes. We can, however, assign our
    `auth` object as the handler's `authorizer` class, so that any created handlers
    will use our authorizer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s set up and run the server portion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This is simply a matter of instantiating an `FTPServer` object with an address
    tuple and handler class, then calling the object's `server_forever()` method.
    The address tuple is in the form `(ip_address, port)`, so a tuple of `('127.0.0.1',
    2100)` means we'll be serving on our computer's loopback address on port `2100`.
    The default port for FTP is usually 21, but on most operating systems, starting
    a service that listens on a port under `1024` requires root or system-admin privileges.
    For simplicity's sake, we'll just use a higher port.
  prefs: []
  type: TYPE_NORMAL
- en: While it's possible to build production quality FTP servers with `pyftpdlib`,
    we haven't done that here. This script is adequate for testing, but please don't
    use it in production if you value security.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the FTP upload function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the test server is up and running, let's build our FTP upload function
    and the logic for the GUI. While the standard library doesn't contain an FTP server
    library, it does contain an FTP client library in the form of the `ftplib` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by importing `ftplib` into our `network.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: An FTP session can be created using the `ftplib.FTP` class. Because this is
    a stateful session, it needs to be closed after we're done; to make sure we do
    this, `FTP` can be used as a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start our function by connecting to the FTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `upload_to_corporate()` function takes the CSV filepath and the `FTP` host,
    port, user, and password, much like our `upload_to_corporate_rest()` function
    did. We begin by creating our `FTP` object and calling `FTP.connect()` and `FTP.login`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `connect()` takes the host and port that we're going to talk to and starts
    a session with the server. We aren't yet authenticated at this point, but we do
    have a connection going.
  prefs: []
  type: TYPE_NORMAL
- en: Then, `login()` takes a username and password and attempts to authenticate our
    session. If our credentials check out, we're logged in to the server and can begin
    sending more commands; if not, an `error_perm` exception is raised. However, our
    session is still alive until we close it, and we can send additional login attempts
    if we wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually upload a file, we use the `storbinary()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: To send the file, we have to open it in binary-read mode, then call `storbinary`
    (yes, it's "stor", not "store"—programmers in the 1970s had a thing about dropping
    letters from words).
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to `storbinary` is a valid FTP `STOR` command, usually `STOR
    filename`, where "filename" is what you want the uploaded data to be called on
    the server. It seems a little counter-intuitive to have to include the actual
    command string; presumably this must be specified in case the server uses slightly
    different commands or syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is the file object itself. This should be opened in binary
    mode since we're sending it as binary data. This may seem odd since the CSV file
    we're sending is essentially a plain text file, but sending it as binary data
    guarantees that the server won't change the file in any way during transit; this
    is nearly always what you want when transferring files, regardless of the nature
    of the data being exchanged.
  prefs: []
  type: TYPE_NORMAL
- en: This is all our network function needs to do for FTP upload. Although we only
    needed the `storbinary()` method for our program, it's worth noting a few other
    common `ftp` methods in case you find yourself having to work with an FTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Listing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three methods for listing files on an FTP server. The `mlsd()` method
    calls the `MLSD` command, which is typically the best and most complete output
    available. It can take an optional `path` argument, specifying the path to list
    (otherwise it lists the current directory), and a list of `facts` , such as "size",
    "type", or "perm", reflecting which data you'd like included with the filenames.
    The `mlsd()` command returns a generator object which can be iterated or cast
    to another sequence type.
  prefs: []
  type: TYPE_NORMAL
- en: '`MLSD` is a newer command and not always available, so there are two other
    methods available, `nlst()` and `dir()`, which correspond to the older `NLST`
    and `DIR` commands. Both methods accept an arbitrary number of arguments that
    will be appended verbatim to the command string sent to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Downloading files from an FTP server involves either one of the `retrbinary()`
    or `retrlines()` methods, depending on whether we wish to use binary or text mode
    (as mentioned before, you should probably always use binary). Like `storbinary`,
    each method takes a command string as its first argument, but in this case it
    should be a valid `RETR` command (usually "RETR filename" will suffice).
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is a callback function which will be called on every line
    (for `retrlines()`) or chunk (for `retrbinary()`). This callback can be used to
    store the downloaded data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value of each function is a result string containing some statistics
    about the download as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Deleting or renaming files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deleting and renaming files using `ftplib` is mercifully simple by comparison.
    The `delete()` method takes only a filename and attempts to delete the given file
    on the server. The `rename()` method takes only a source and destination, and
    attempts to rename the source to the destination name.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, the success of either method depends on the permissions granted to
    the login account used.
  prefs: []
  type: TYPE_NORMAL
- en: Adding FTP upload to the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our FTP upload function is ready to go, so let's add the necessary bits to the
    rest of our application to make it all work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding the FTP host and port to the `SettingsModel` in `models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Remember that our test FTP uses port `2100`, not the usual port `21`, so we'll
    make `2100` the default for now.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll move over to `application.py` and create the callback method that
    will create the CSV file and pass it to the FTP upload function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method in the `Application` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is create our CSV file, using the method we created for
    the `REST` upload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll ask the user for the FTP username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we''ll call our network function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We call the FTP upload function in a `try` block because there are several exceptions
    that can be raised by our FTP process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than catching them individually, we can catch `ftplib.all_errors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note that `ftplib.all_errors` is the base class for all exceptions defined in
    `ftplib`, which include, among other things, authentication errors, permission
    errors, and connectivity errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To end this method, we''ll show a success message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'With the callback method written, we need to add it to the `callbacks` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we need to do is to add our callback to the main menu classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over in `mainmenu.py`, add a new command to the `tools_menu` in each class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Launch the sample FTP server in a terminal, then run your application and try
    out the FTP upload. Remember to enter `test` for the username and password!
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a success dialog like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/42dfde62-fea5-4555-ae37-9f3fe4037b68.png)'
  prefs: []
  type: TYPE_IMG
- en: Likewise, there should be a new CSV file in whatever directory you ran the sample
    FTP server from.
  prefs: []
  type: TYPE_NORMAL
- en: 'The FTP server should have printed out some information like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Looks like our FTP upload works great!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reached out to the cloud using HTTP and FTP. You learned
    how to download data using `urllib` and parse XML using `ElementTree`. You also
    discovered the `requests` library and learned the basics of interacting with a
    REST API. Finally, we learned how to download and upload files to FTP using Python's
    `ftplib`.
  prefs: []
  type: TYPE_NORMAL
