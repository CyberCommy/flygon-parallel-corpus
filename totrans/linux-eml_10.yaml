- en: Chapter 10. Backing Up Your System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to recover from catastrophic loss of service in case of a major hardware
    or software malfunction, it is absolutely essential to have a backup. The backup
    is supposed to let you restore the software (or rather the software's configuration)
    and other data that you need to reestablish your service. This includes the users'
    mails, the system's mail queue, and their authentication data among other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will guide you through the steps necessary to safeguard your system
    from failure and, if failure occurs, how to recover from it. After reading through
    this chapter you will know:'
  prefs: []
  type: TYPE_NORMAL
- en: What backup options are available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What data we need to back up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The storage considerations for our backup media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to perform incremental and full backups for the mailboxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The steps required for a complete file system restore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to restore an individual e-mail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to backup our server configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up automated backup schedules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backup options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing the most appropriate backup option is always a trade-off. You have
    to juggle the cost of downtime to a business, the price and availability of backup
    media and hardware, the value of user data (in our case, users' e-mails), and
    the staffing costs to manage the backup operations.
  prefs: []
  type: TYPE_NORMAL
- en: For our small office e-mail server, we are going to present a simple but reliable
    solution, using tried and trusted techniques and tools employed by numerous administrators
    over many years.
  prefs: []
  type: TYPE_NORMAL
- en: Any backups we take need to be stored on backup media. The most convenient solution
    is to have a spare Linux machine, with a number of hard drives, networked to our
    e-mail server, preferably located in another building. Storing backups off site
    is essential if we want to protect ourselves from a catastrophic event such as
    fire.
  prefs: []
  type: TYPE_NORMAL
- en: If a remote server is not available, an alternative could be some hot-swappable
    external hard drives connected to the server, or even, in a pinch, a DVD burner.
    Magnetic tape drives are also an option, but often the cost of the tape drive
    and media is greater than the server. If removable media is the only option then
    don't leave the backups stacked on top of the server or in a desk drawer, move
    them to a safe off site location. It may be convenient to retain a local copy
    of the latest backup media on site to respond more quickly to urgent recovery
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: RAID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**RAID** is an acronym for a **Redundant Array** of **Inexpensive** (or **Independent**)**Disks**.
    By using multiple disks in a RAID setup, data is spread across the disks, but
    the array is viewed by the operating system as a single device. By replicating
    and dividing the data throughout the array, the tolerance to disk failure can
    be reduced significantly, increasing data reliability and possibly I/O performance.
    If a hard disk fails in the array, the old disk can be swapped out and replaced
    with a new disk. The RAID controller, either a hardware or software controller,
    then reconstructs the data. For more information on RAID and the various configuration
    options available, visit [http://en.wikipedia.org/wiki/RAID](http://en.wikipedia.org/wiki/RAID).'
  prefs: []
  type: TYPE_NORMAL
- en: However, RAID, by itself, is not a backup solution. A file or e-mail that has
    been deleted, whether accidentally or maliciously, cannot be recovered. RAID does
    not protect from user error or serious hardware failure such as a power surge
    that fries the server or even fire damage.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing data availability using RAID is a good thing, but is not an alternative
    to a proper backup and recovery strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Image backups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A disk image backup program will copy data from a hard disk, sector by sector
    with no regard to any files or structure on the disk. The backup is an exact image
    of the disk—the master boot record, partition tables, and all data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the event of a major hardware failure, the steps to restore a system are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace or repair failed hardware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Boot a Linux live CD containing the disk image restore program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the image of each disk from the backup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reboot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Superficially, this looks like an attractive and quick approach to restore service
    quickly and easily. However, there are number of problems inherent in using disk
    images for backup.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring a disk image to a new disk of a different size or geometry is often
    not possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new hardware will almost certainly be of a different configuration (motherboard,
    network card, disk controllers, and so on.), and the restored Linux kernel may
    not have the necessary drivers to boot successfully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk images are big. The image is the total size of the disk, not just the size
    of the data stored on it. The space requirements of multiple disk images soon
    adds up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recovery of an individual user file is quite cumbersome. The disk image would
    need to be restored to a spare disk, mounted on a running system and, once found,
    copied to the desired location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total system failures happen rarely and the perceived convenience and speed
    of an image restore is often outweighed by the flexibility of file system backups.
  prefs: []
  type: TYPE_NORMAL
- en: File system backups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike image backups, file system backups understand the structure of the file
    system and consequently the data on the hard disk. Therefore, only the allocated
    portions of the disk are copied and the free space is not copied. The backup is
    for all files in the file system rather than sector by sector.
  prefs: []
  type: TYPE_NORMAL
- en: Because file system backups are done this way, it means that it is possible
    to copy only the files that have changed since the last backup, resulting in smaller
    subsequent backup files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the event of a major hardware failure, the steps to restore a system are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace or repair failed hardware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the Linux distribution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the mail server applications in this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply any patches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restore application configuration data backups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restore user data backups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reboot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compared to image backups, this approach will take slightly longer and involves
    more steps, but does have a number of advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Replacement disks need not be of the same size or geometry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As long as your Linux distribution supports the new hardware, there are no compatibility
    issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backup file sizes are much smaller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restoration of individual files is much simpler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned before, major system failures are not that common. Although the
    steps to complete a full restore are a little more cumbersome than image backups,
    the advantages of smaller and faster backups along with the ease of selective
    restoration of user data are significant.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the likelihood of an unexpected disk failure, system tools are available
    to monitor the health of disk drives. For more information, visit [http://en.wikipedia.org/wiki/S.M.A.R.T.](http://en.wikipedia.org/wiki/S.M.A.R.T).
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc backups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: File system backups back up whole file systems only, not individual files or
    directories. Occasionally we may wish to take a copy of just a few files after
    a significant configuration change to one of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using standard Linux tools such as `tar` or `cp`, important changed files can
    be copied to a directory on a file system that is part of the normal backup schedule.
  prefs: []
  type: TYPE_NORMAL
- en: What to back up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The big question always associated with backups is, "What should we back up?"
  prefs: []
  type: TYPE_NORMAL
- en: There are many things that contribute to our final decision. Of course, we want
    to back up our server's configuration because it is essential to our server's
    functionality. But we also want to back up the users' data because it is a valuable
    asset to our business. Is there a company policy that says people may use e-mail
    for private communication? If there is, should we back up those messages as well?
  prefs: []
  type: TYPE_NORMAL
- en: We should only back up what we need to restore the system to a functional state.
    This saves space on the backup media and shortens the time required to perform
    a backup and restore if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: After all, the space on any backup media is limited and thus precious. It is
    more important to back up all the users' mails than to have a complete backup
    of the `/tmp` directory. Also, the less data we back up, the less time is required
    to perform the backup, thus returning our system's resources (CPU cycles, I/O
    bandwidth) more quickly to their main purpose—handling users' mails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is list of items we need to backup to get a working system:'
  prefs: []
  type: TYPE_NORMAL
- en: System inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed software that the services require
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users' credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users' mailboxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log files (for billing purposes and end user requests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postfix mail queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following sections describe each of these items discussed.
  prefs: []
  type: TYPE_NORMAL
- en: System inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the event of a partial or total hardware failure, it is useful to make a
    note of our current system layout. In most cases, replacement hardware will often
    be as good as, if not better, than our current setup. In order to restore our
    system, we will need to know how disks are partitioned and how the mount points
    organized. It would be difficult to restore our users' data onto a disk that is
    too small.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the output from following commands, we will have enough information to
    recreate our disk layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command prints out the partition table for each disk and saves the output
    to a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command appends the capacity and usage of each mount point to our file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `mount` command lists the current mount points, which we append to the file.
  prefs: []
  type: TYPE_NORMAL
- en: Additional information may be in the file `/etc/fstab`, which we will backup
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a list of installed software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to restore our installed software, we need to have a list of software
    currently installed.
  prefs: []
  type: TYPE_NORMAL
- en: In Debian, this is given by the following command. The `installed_software.txt`
    file contains the current state of which software on the system is installed/not
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With an RPM-based distribution, that would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In a Debian-based system, this file can later be used to install the same set
    of software.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the `dselect` utility, select `i` for `install` and then confirm the installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an RPM-based distribution, that would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The commands just discussed list only the software installed via a package manager.
    If you have installed software from source, then make a note of the application
    and version you installed.
  prefs: []
  type: TYPE_NORMAL
- en: System configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server will not perform its expected duties without these. As a minimum,
    the configuration files that need to be backed up are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/courier:` This directory holds Courier-IMAP''s configuration data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/postfix:` This directory holds Postfix''s configuration data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The directory tree `/etc` includes items such as network settings, routings,
    and much more, which we would otherwise need to memorize. It is recommended to
    backup the whole `/etc` tree.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have installed software from source with configuration files in non-standard
    locations, be sure to include those configuration files in your backup candidate
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Users cannot authenticate themselves using their username and password combination
    without this. The data that needs to be backed up depends on the way the authentication
    is done and would include three files`—/etc/passwd, /etc/shadow`, and `/etc/group`,
    along with a MySQL database (if the users' credentials are stored in that database).
  prefs: []
  type: TYPE_NORMAL
- en: The users' mailboxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is where the users' mails are stored. This includes the whole directory
    tree of `/home` and below. This is the bulk of our backup—vast amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: Log files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We should at least store the logs generated by Postfix and Courier. These will
    be needed to process user requests such as, "Where did my mail go?". If users
    are billed based on mail volume sent and/or received, we will definitely need
    a backup of Postfix's logs.
  prefs: []
  type: TYPE_NORMAL
- en: As Postfix's and Courier's logs are normally written by the system's `syslogd`
    daemon, we need to check the `/etc/syslog.conf` file to see where these logs go.
    Both programs log their messages with the `syslog` mail facility.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure complete coverage, it is wise to back up the whole directory tree
    of `/var/log`.
  prefs: []
  type: TYPE_NORMAL
- en: The mail queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may or may not make sense to back up the Postfix queue of a working system,
    depending on the situation.
  prefs: []
  type: TYPE_NORMAL
- en: With Postfix, e-mail messages hit the disk at least twice.
  prefs: []
  type: TYPE_NORMAL
- en: The first time that the e-mail messages hit your drive is when they are being
    accepted by Postfix; they are written to Postfix's `queue_directory` before delivery
    continues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More disk I/O may be generated by a virus scanner or a program that detects
    spam (for example, `clamav` and `spamassassin`).
  prefs: []
  type: TYPE_NORMAL
- en: If it's mail for local domains, our server is the final destination for these
    mails and their lifespan in the `queue_directory` is extremely short. They hit
    the queue, just to be delivered to the user's mailbox immediately afterwards.
    That's the second time they hit the disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If it''s mail that goes to other domains (because the server acts as a relay),
    then Postfix will immediately contact the recipient''s mail server and try to
    deliver the message there. Only in case of problems will the queue ever contain
    a significant number of e-mails not yet delivered. These problems are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `content_filter` **is slow or not operational:** For example, `clamsmtp`
    or any other product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote sites have problems:** Large free e-mail providers often have problems
    and thus may not be able to accept our e-mails immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both these cases, the deferred queue will fill up with mail that's still
    to be delivered and that should obviously be backed up in case of a failure. If
    the server is very busy, there may be quite a bit of deferred mail in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: The Postfix mail queue includes the directory tree `/var/spool/postfix` and
    below.
  prefs: []
  type: TYPE_NORMAL
- en: What not to back up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We do not need to back up all of the installed binaries as these can simply
    be reinstalled using the aforementioned "list of installed software". Of course
    this assumes that the installation media is available when we need to reconstruct
    our system. As security conscious administrators, we keep our system up-to-date
    by installing the vendors' patches. Over the course of time, the versions of the
    installed and subsequently patched software will differ significantly from the
    versions that came on the installation media. If these updates can be installed
    via the Internet (for example using Red Hat's up2date or Debian apt-get), we don't
    have to keep them on site.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up users' e-mail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using dump to backup the whole partition containing our mailboxes.
    The dump command copies files on a file system to a specified disk, tape, or other
    media.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the reasons for using it are:'
  prefs: []
  type: TYPE_NORMAL
- en: It is incredibly fast (in my tests, the network is the bottleneck)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is simple (one command suffices)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can run unattended (for example, as `cron` job)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not need any additional software to be installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not need a GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very mature having been around since AT&T UNIX Version 6, circa 1975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `restore` command performs the opposite of `dump`. A backup of a file system
    taken using `dump` can be restored as the complete file system or you can selectively
    restore certain files or directories.
  prefs: []
  type: TYPE_NORMAL
- en: Mail storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We recommend putting the mailboxes (`/home`) on a separate partition for many
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: File system maintenance can be performed independently from other parts of the
    system (simply unmount `/home`, perform an `fsck`, mount it again).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to put that partition on a separate disk or on a RAID, thus separating
    the users' I/O (on that partition) from the system's I/O (logs, mail queue, virus
    scanner).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most important of all:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `dump/restore`, we can dump whole partitions. (OK, that's not entirely
    true, but a `dump/restore` is done easily only with whole partitions.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overfull partition containing the mailboxes will not negatively influence
    the system's ability to write log files or other important system information.
    If all the data (logs, mailboxes, the system files) were on a single partition,
    filling this partition would cause logging to stop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both Courier and Postfix use the Maildir format for users' mailboxes. They store
    each piece of mail as a separate file allowing easy restore operations even for
    single mails.
  prefs: []
  type: TYPE_NORMAL
- en: Backup operations are very easy with the Maildir format.
  prefs: []
  type: TYPE_NORMAL
- en: '"Back up an e-mail" corresponds to "back up a file to the backup media".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Restore an e-mail" corresponds to "restore a file from the backup media".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Back up a mailbox" corresponds to "back up a Maildir and all its subdirectories
    to the backup media".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Restore a mailbox" corresponds to "restore a Maildir and all its subdirectories
    from the backup media".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are basically two approaches to backing up data. The simple method stores
    all data, whenever we perform a backup. This is called a full backup. Its advantage
    is the simplicity, and its main disadvantage is the sheer amount of data that
    needs to be stored on the backup media. This problem is addressed by the concept
    of the incremental backup. An incremental backup saves the changes only since
    the last incremental (or full) backup.
  prefs: []
  type: TYPE_NORMAL
- en: If the space on the backup media allows for a full backup everyday, we can do
    that for the sake of simplicity. That way we only need to look at the last intact
    backup to restore all the data.
  prefs: []
  type: TYPE_NORMAL
- en: Incremental backups are simple. The backup software needs to back up only those
    files and directories that have recently been created or changed since the last
    backup.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the space doesn''t allow for that simple solution, we could use this scheme
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform a full backup every week
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do six incremental backups, one each day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we need to restore from scratch, restore the last full backup, then restore
    up to six incremental backups. That way we lose at most one day of mail which
    is as close as we can get with a daily backup interval. Later we shall see more
    sophisticated incremental backup strategies to reduce the number of incremental
    restorations required after restoring a full dump.
  prefs: []
  type: TYPE_NORMAL
- en: For detailed information on `dump(8)` and `restore(8)` see the system manual
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: We shall now look at the actual task of backing up the mailboxes using the `dump`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Full dump
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're now about to perform a full backup of the partition containing our users'
    Maildirs. In this example, this partition will be `/dev/sdb1` (the first partition
    of our SATA disk). So, we will want to back up `/dev/sdb1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out which partition we need to back up on our system, we need to examine
    the output of the `mount` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `/home` is the partition of `/dev/sdb1`.
  prefs: []
  type: TYPE_NORMAL
- en: Our plan is to use the `dump` tool to create the backup for this partition.
    This backup data needs to go to our backup medium, which could be another disk,
    a tape or, in our case, a disk in the remote backup server.
  prefs: []
  type: TYPE_NORMAL
- en: There are various methods to get data across the network, one of them being
    `ssh`. It is a network protocol that facilitates secure communications between
    two devices.
  prefs: []
  type: TYPE_NORMAL
- en: To get our backup data across the network onto another disk in the backup server,
    we use the power of Linux to marry the `dump` program and `ssh` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The output of the `dump` program will be fed into `gzip` to compress the dump,
    then fed to `ssh`, which in turn spawns another program `dd` on the backup server
    to finally write that data onto its disk.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines of code give a full dump of the partition containing the
    mailboxes to a file on a remote system. We are assuming that the mailboxes are
    on the partition `/dev/sdb1` mounted as `/home`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As root, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The command looks complicated, so let''s break it down in each of the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dump -0 -u -b 1024 -f -` performs a level `0` (`full`) dump of the partition
    `/dev/sdb1` (which contains `/home` in our example) using a block size of `1024`
    (for maximum performance) and updates (`-u`) the file `/var/lib/dumpdates` after
    the dump had been successful. The `-u` option is important because it records
    the date and time of this dump, so subsequent incremental dumps can determine
    which files have been changed or created since the last dump. The output of the
    dump goes to a file (`-f`) specified as (`-`), which indicates `stdout`, the standard
    output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the `dump` data goes to standard output (`stdout`), we can pipe that output
    into `gzip` to compress the size of the dump. The `-c` option tells `gzip` to
    write the compressed output to `stdout`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compressed level 0 dump output is then piped to the `ssh` command, which
    makes a remote connection to the system `backup-host.domain.com` logging in as
    `user`. Once logged in, the remote system executes the `dd` command. We recommend
    the use of the key-based authentication scheme that `ssh` offers. This way, the
    backup can run unattended, as nobody has to enter the password needed to log in
    as `user` on `backup-host.domain.com`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the remote server, the final step is to write the output using the `dd` command.
    The output filename is specified by the `of` option to `dd`. The output filename
    has been constructed in such a way as to easily identify the file system, the
    date and time the dump was taken, the level of the dump, and the suffix `.gz`
    to indicate that this dump file has been compressed. The filename portion `$(date
    +%Y%m%d%H%M%S`) is a shell expansion performed on the local system (not the remote
    system) to output the current date and time in `YYYYMMDDHHMMSS` format. The final
    output filename will be something similar to `20090727115323.dump.0.gz`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on each of the commands, see the system manual pages for
    `dump, gzip, ssh, dd`, and `date`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Full dump](img/8648_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This next example will simply write the backup data to a directory no `stdout`
    wizardry this time!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code give a full dump of the partition containing the
    mailboxes to a file on a separate disk to hold the backups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is, of course, much faster and simpler than sending all the data across
    the network via `ssh` with the data encryption and decryption carried out during
    the transit (which takes a lot of time and CPU power), but if our server is burnt
    to cinders, a backup on a built-in hard drive won't help at all.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that `/backupdirectory/fulldump` can also be an NFS mount or an
    SMB mount. This would give you both, the advantage of a simple command line and
    an off site backup. So, make sure you do have an offsite backup. It's easy enough
    either way.
  prefs: []
  type: TYPE_NORMAL
- en: Incremental dumps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Incremental dumps are performed in exactly the same way as a full dump except
    that we change the level option from 0 to either 1, 2, or 3, and so on depending
    on how many changes we wish to back up. Remember, a level number above 0 tells
    dump to copy all files new or modified since the last dump of a lower level. This
    is best illustrated with some examples. For clarity, we shall be simply dumping
    to a file, but in practice we would normally use the same sequence of commands
    as discussed using `gzip, ssh, dd`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume our level 0 dump was taken on Sunday night. The first incremental
    dump (level 1, indicated by the `-1` option) is then taken on Monday night like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This saves everything that is new or has changed since the last full dump to
    `mon.dump.1`. This dump file will be much smaller than the previous full dump
    containing only the changes made on Monday. Assume, on the following day we repeat
    this level 1 dump
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The second incremental dump, `tue.dump.1`, will contain all the changes made
    on Monday and Tuesday because a level 1 dump will back up everything that has
    changed since the level 0 dump. In order to recover the system back to the latest
    backup, we would have to restore only Tuesday's backup. Therefore one might consider
    that the dump taken on Monday is now obsolete; however, should a user wish to
    recover a file created on a Monday and accidentally deleted on a Tuesday, our
    first backup is still required.
  prefs: []
  type: TYPE_NORMAL
- en: Repeatedly performing level 1 dumps allows for very quick recovery as only two
    dump files need to be restored, the level 0 dump and the latest level 1 dump.
    The downside is that each subsequent dump file grows in size and takes longer
    and longer to complete. This scheme is sometimes called differential backup.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to use additional dump levels to reduce the size of each backup
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following sequence of commands perform a number of incremental
    backups after our initial level 0 dump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, each day's dump file contains only the new and changed files
    since the previous dump. Each dump operation from Tuesday onwards will complete
    more quickly and result in smaller file sizes than in our previous example. However,
    recovery will take longer. To recover to the latest backup, we would need to restore
    our full dump, then restore each of the incremental dumps from Monday through
    Thursday in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying these examples on a small temporary file system might be a useful exercise
    in order to understand the interaction between different levels of dumps. Each
    dump file can be examined using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For the curious, the file `/var/lib/dumpdates` can also be examined after each
    dump to verify the date and level of each dump.
  prefs: []
  type: TYPE_NORMAL
- en: As was stated at the beginning of this chapter, everything is a trade-off, so
    choosing the appropriate backup strategy involves balancing media costs, personnel
    costs, and recovery time.
  prefs: []
  type: TYPE_NORMAL
- en: So far, all of our backups have been performed with the disks mounted, which
    makes verifying the backup impossible. The reason for this is that data we were
    just backing up is constantly in flux. Remember that each file represents an e-mail.
    Whenever a user gets new mail or deletes old mail, the state of the file system
    changes. Users constantly get mail, read mail, and delete mail, even when they're
    about to perform a backup.
  prefs: []
  type: TYPE_NORMAL
- en: The `restore` command does have the `-C` option to compare a dump with the original
    disk contents, but this is sensible only if the file system we are dumping is
    unmounted. In most cases, unmounting each file system is not practical and would
    interrupt service significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Using restore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the data that has been backed up will need to be restored before it can
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done in two ways, interactively or non interactively.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive restore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To restore data from a dump interactively, we need to copy the dump from our
    backup media onto our system or perform the selection of files to restore on the
    computer we stored the dump in. If we are extracting only a few files, this can
    be performed in a temporary directory and the resulting files can be moved to
    the correct location once the restore has been completed. For larger numbers of
    files, for example a whole user account, we can `cd` to the ultimate destination
    before starting the restore.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an interactive restore, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The`>` is the prompt of the interactive interface to restore. It is a spartan
    interface with limited commands available. It allows navigation through the dump
    as if we were on a live file system. Use `ls` and `cd` to show directory contents
    or change directories. Issue `?` to get a list of supported commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have found the data we want to restore, type either of the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`> add directoryname`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`> add filename`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This adds the particular `directoryname` and all data below it, or just the
    `filename` to the set of files that need to be restored. Repeat for additional
    files or directories.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are done with adding all the data that needs to be recovered, we issue
    the `extract` command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Interactive restore](img/8648_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The output shown in the previous screenshot relates to volume numbers on magnetic
    tape. A dump file may have been split over a multi-volume tape set, but when dealing
    with dump files on hard disk, choose volume `1`. We would normally select `n`
    to retain the current ownership and permissions of the working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the necessary files have been extracted, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Do this with the last full dump and each incremental dump in order, up to the
    last incremental dump available. This makes sure that we restore all changes since
    the last full backup.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the data we are restoring hasn't changed between two dumps, we will not find
    it in the second incremental dump at all.
  prefs: []
  type: TYPE_NORMAL
- en: Non-interactive restore across the network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The manual approach makes sense if we want to restore just a few mailboxes.
    If we want a complete recovery of all mailboxes, we need to use the non-interactive
    scheme. This doesn't need additional storage space on the target system, as the
    dump data is being piped across the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recreate the file system on our newly installed, freshly partitioned hard disk
    and mount it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `-j` option to `mke2fs` creates a ext3 journaling file system on `/dev/sdb1`
    and it's mounted as `/home`.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we need to recreate the data using the same file system you
    used when creating the backup!
  prefs: []
  type: TYPE_NORMAL
- en: Let the restore begin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Just like when we performed the backup across the network, we now do the same
    with the restore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous line executes the following command as the `user` on the `backup-host.domain.com`
    host, although this time with the `dd` command using the `if` option to read the
    compressed dump file and sending the output to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output is piped across the network and fed into `gunzip` to uncompress the
    file and ultimately piped to `restore -r -f -`. The `-r` option instructs restore
    to rebuild the whole file system from the dump file's contents to the original
    locations using the original permissions and ownerships. If you wish, you may
    use the `-v` option with `restore` for verbose output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is necessary to ensure we are located in the correct directory before issuing
    the `restore` command, otherwise serious damage may occur to an existing file
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from the restore will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The warning about the existence of `lost+found` is normal and can be safely
    ignored.
  prefs: []
  type: TYPE_NORMAL
- en: This operation should then be repeated for each incremental dump file that is
    required to return the system to the required state. If we restore the incremental
    dumps in the wrong order, we will get the error "Incremental tape too low" or
    "Incremental tape too high". Once we have received one of these errors, we cannot
    complete the full restore and must restart the restoration from the level 0 dump.
  prefs: []
  type: TYPE_NORMAL
- en: When using the `-r` option to the restore command, it will create the file `restoresymtable`.
    This is a checkpoint file that the restore command uses when we are restoring
    multiple dumps as an aid to help the next `restore` command determine which directories
    or files need updating, creating, or deleting.
  prefs: []
  type: TYPE_NORMAL
- en: Once the file system has been completely restored and verified, we should remove
    the `restoresymtable` file. If this file is included in the next dump, the old
    `restoresymtable` file could end up overwriting the one that is being created
    at that time and prevent additional dumps from being restored.
  prefs: []
  type: TYPE_NORMAL
- en: As the final step, perform a level 0 `dump` of the newly restored file system.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up configurations and logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two approaches to the backup of configuration data and important log
    files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Store the data on our backup media:** Using this method, we will back up
    directly to our backup server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add the data to our backup schedule:** This approach will include the necessary
    files as a part of our user data backup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either case is equally valid and is really a matter of personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, earlier we made a list of the important parts of the system
    that require backup. These were:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Important part of the system | Example command |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| System inventory | `disk_layout.txt` |'
  prefs: []
  type: TYPE_TB
- en: '| List of installed software | `installed_software.txt` |'
  prefs: []
  type: TYPE_TB
- en: '| System configuration files | `/etc` |'
  prefs: []
  type: TYPE_TB
- en: '| Authentication data | `/etc/password /etc/groups /etc/shadow` |'
  prefs: []
  type: TYPE_TB
- en: '| Log files | `/var/log` |'
  prefs: []
  type: TYPE_TB
- en: '| Mail queue | `/var/spool/postfix` |'
  prefs: []
  type: TYPE_TB
- en: As each system is different, you should ensure that the example commands given
    next cover all the necessary files.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring configurations and logs to backup media
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To keep it simple, we just use the `tar` tool to create an archive of the files
    and directories listed previously, and store it in the same directory as the full
    or incremental dumps on the backup server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, we can create the `tar` archive on the `/home` file system and
    have it backed up as part of our normal backup schedule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, we use the `tar` command with the options `c` to create an archive,
    `z` to compress, and `f` as the output archive name. Also note that we have restricted
    access to the `/home/config` directory as it contains archives with sensitive
    information that should be protected.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `tar`, please see the system manual pages.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring the configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Depending on the method used earlier, restoring our configuration and log files
    is relatively simple. We can either copy the required archive from the backup
    server or use the archive directly from `/home/config`. In either case, untarring
    the archive is performed using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have created and moved into a temporary directory before expanding
    the archive. If our current directory was `/` when we executed the `tar` command,
    we would have overwritten all the files in `/etc, /var/log`, and `/var/spool/postfix`
    with potentially undesirable results.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have untarred the archive, we can compare and copy the files we
    need to restore.
  prefs: []
  type: TYPE_NORMAL
- en: Automating backups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to back up our system, we need to put in place an
    automated procedure to remove the drudgery of manually invoking `dump` at regular
    intervals.
  prefs: []
  type: TYPE_NORMAL
- en: The manual pages for dump do provide some guidance on how often to back up and
    at which level to reduce restoration time.
  prefs: []
  type: TYPE_NORMAL
- en: '*In the event of a catastrophic disk event, the time required to restore all
    the necessary backup tapes or files to disk can be kept to a minimum by staggering
    the incremental dumps. An efficient method of staggering incremental dumps to
    minimize the number of tapes follows:*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Always start with a level 0 backup. This should be done at set intervals,
    say once a month or once every two months, and on a set of fresh tapes that is
    saved forever*.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*After a level 0, dumps of active file systems are taken on a daily basis,
    using a modified Tower of Hanoi algorithm, with this sequence of dump levels:
    3 2 5 4 7 6 9 8 9 9 . . . For the daily dumps, it should be possible to use a
    fixed number of tapes for each day, used on a weekly basis. Each week, a level
    1 dump is taken, and the daily Hanoi sequence repeats beginning with 3\. For weekly
    dumps, another fixed set of tapes per dumped file system is used, also on a cyclical
    basis*.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*After several months or so, the daily and weekly tapes should get rotated
    out of the dump cycle and fresh tapes brought in*.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This sequence of dumps looks rather bizarre and needs a little more explanation.
    Working through the process will illustrate how we minimize the size of dumps
    taken and reduce the number required to restore.
  prefs: []
  type: TYPE_NORMAL
- en: Once the level 3 dump is taken, restoration is only a matter of restoring the
    dumps 0 and 3\. After the second day, the level 2 dump will back up everything
    changed since the last dump at a lower level, that is, level 0\. This renders
    the level 3 dump ineffective. The level 5 dump then backs up the changes since
    the level 2 dump. As the sequence progresses using higher and lower levels to
    skip days, previous dumps become ineffective and are no longer required to complete
    a full restore. Each of the dumps should still be retained, in case we need to
    restore individual files deleted by accident at some later time.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the week, a level 1 dump is performed rendering all the previous
    weeks' dump levels obsolete, and the sequence restarts until the end of the month
    when a new level 0 dump is taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table illustrates which dump levels are taken for each day and
    the number of restorations required to recover the data to the latest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Day of month | Dump level | Restore levels required |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2, 9, 16, 23, 30 | 3 | 0, 1*, 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 3, 10, 17, 24, 31 | 2 | 0, 1*, 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 4, 11, 18, 25 | 5 | 0, 1*, 2, 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 5, 12, 19, 26 | 4 | 0, 1*, 2, 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 6, 13, 20, 27 | 7 | 0, 1*, 2, 4, 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 7, 14, 21, 28 | 6 | 0, 1*, 2, 4, 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 8, 15, 22, 29 | 1 | 0,1 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the first week, the level 1 dumps (marked with *) are not required during
    the restoration process. From the eighth day, the level 1 dump is always required.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the table, even at the end of a month only a few dumps are
    required to restore our data, rather than several dozen when creating incremental
    daily dumps.
  prefs: []
  type: TYPE_NORMAL
- en: With our monthly backup schedule, a simple script and the addition of some entries
    to `cron` will complete the automated backup process.
  prefs: []
  type: TYPE_NORMAL
- en: Backup script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following example bash script will archive our system configuration and
    log files, and dump the requested file system to a remote backup server. This
    is only a sample script and should be modified to suit your needs. Any error checking
    and logging has been omitted for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The script expects 3 parameters the name of the dump, the partition to be dumped,
    and the dump level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The previous script archives `/etc` each time it runs. You may wish to move
    these commands to a separate script to perform this task weekly or even monthly.
    This is particularly important if the script will be used to dump other file systems
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Old dump files from previous months are not removed by the script and could
    fill up our backup server preventing future backups. It is prudent to put procedures
    in place to either remove or archive old dump files depending on the organization's
    data retention policy.
  prefs: []
  type: TYPE_NORMAL
- en: Adding crontab entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running our backup script automatically each night is just a matter of using
    the entries from our backup schedule table and executing the script to dump the
    correct partition. The following example `crontab` entries execute our script
    each night at 02:10 to dump `/home`. On the first of each month, a level 0 dump
    is performed and then a weekly level 1 dump is performed every seven days after
    that. The other entries implement the modified "Towers of Hanoi" algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once our automated backup procedure has been put in place, we need to keep an
    eye out for any errors and verify the integrity of the dump files on the remote
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying restoration procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even with the best planning in the world, things go wrong and always at the
    most inconvenient moment.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a proactive approach to disaster recovery with good planning and practice
    will highlight any problems at an early stage before it is too late. Verifying
    the integrity of system backups is only really possible by restoring them and
    checking that the restored system is fully operational.
  prefs: []
  type: TYPE_NORMAL
- en: You should ask yourself questions such as, "What actions are necessary if the
    remote server fails?" Do you repair the backup server first or switch to another
    server to reduce the size of the window without backups? If the mail server fails,
    are you familiar with the restoration procedures? Is replacement hardware available
    at short notice, for example, on a Sunday?
  prefs: []
  type: TYPE_NORMAL
- en: There are many horror stories of administrators diligently taking backups only
    to find that when required the backups are useless because of a tape drive error
    or a minor syntax error in the backup script that overwrites valid dump files
    with bad data.
  prefs: []
  type: TYPE_NORMAL
- en: Invent scenarios for yourself and practice a full bare metal restore on spare
    hardware, or the recovery of an individual users' e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that your restoration procedures work will give you the confidence
    that you can recover from data loss.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described how to back up e-mail and the mail server configuration.
    We started off with an introduction to what you should consider worth backing
    up and ended with a sophisticated solution using automated full and incremental
    backups.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we described the process using the `dump` command, and how to
    take copies of our data. We used the `restore` command to recover a complete file
    system and selective files.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter guides you through the process of backing up and restoring your
    server's precious data. It shows why to back up, what data to back up, the different
    backup and restore methods, and a procedure to take automatic daily backups.
  prefs: []
  type: TYPE_NORMAL
- en: After implementing all the procedures we have shown you in this chapter, you
    will sleep a lot better and, in any case, your users will love the range and functionality
    your system can offer.
  prefs: []
  type: TYPE_NORMAL
