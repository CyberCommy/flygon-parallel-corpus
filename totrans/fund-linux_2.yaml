- en: The Linux Command Line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce you to the most fundamental concepts when
    starting to work with the Linux command line. It is a very powerful and efficient
    tool with which you can execute the various actions that you'll generally require
    when using Linux. A plethora of shortcuts and tricks will help you to navigate
    the command line more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll walk you through the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Shell globbing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting and piping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `grep`, `sed`, and `awk` commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating files and folders in a Linux system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn how to run Linux command-line programs and what
    the basic structure of the command line is. You will also learn what program options
    and arguments are and why they are important for customizing your commands.
  prefs: []
  type: TYPE_NORMAL
- en: When we say the Linux command line, what we really mean is the **shell**. It's
    important to know that the shell is not the same as a terminal emulator. A Terminal
    is a screen or window that lets you access a Linux server's input and output.
    A shell is just a program that runs on the server as does any other command and
    which awaits, interprets, processes, executes, and responds to commands typed
    in by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open up a new terminal emulator and log in to your CentOS 7 server by
    using SSH, as we learned in the [Chapter 1](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml),
    *Introduction to Linux*. Log in using your normal user account, which you set
    up during installation, because, as we have said before, never work with the root
    user unless you have to. In my example, the username is `olip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3973123b-3647-47cd-963a-91fd8ea28937.png)'
  prefs: []
  type: TYPE_IMG
- en: After successfully logging in to your server, an important program has been
    started automatically, which is called the shell, and which have been using this
    whole time. In fact, when we talk about the Linux Terminal, what we are really
    speaking of is the shell. There exist several shell variants; on CentOS 7 we are
    using **Bash**, or the **Bourne Again Shell**, by default. When the shell is started,
    the first thing you will notice is the line ending with the dollar sign ($), which
    is called the shell prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, it gives us some useful information: the login username and
    the current directory we''re on. The tilde is a special character and it means
    home directory, which is the default directory when logging in. After the shell
    prompt comes the cursor, which is the underscore character, and this is where
    the user can type in the text that then gets processed and executed by the shell.
    But user input will only get processed and executed by the shell when the input
    has been ended with the *Enter* key. If you make any type of mistake, just hit
    the backspace key to delete the last character. The first useful command we will
    learn in this chapter is how to log out of the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Linux Terminal, this command logs out the current user and goes back
    to the login screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Linux Terminal and type the `logout` command and after that press the
    *Enter* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, if you perform the same operation while using an SSH connection, it
    has the same effect as the `exit` command that we learned about in the previous
    chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's try to log in again to the CentOS server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s try out a simple command; type `date` and press the *Enter* key. This
    is a command that prints out the current date-time value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/997fd978-1da6-461b-a240-4087ce52aff9.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, if the shell has finished executing a specific command and is
    ready to accept new input by the user, a new shell prompt will appear in a new
    line marking its readiness. Now, type `cal` and press *Enter*. This command prints
    out a nice table view of the current month.
  prefs: []
  type: TYPE_NORMAL
- en: If the first character of any command types is prepended in the shell with the
    hash key, the command will not be executed when pressing the *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: A typical Linux system such as CentOS 7 contains hundreds of different commands
    included in the default installation. If you could only type in the pure commands
    and nothing more, our work in the shell would be very limited and static and you
    would not be able to work properly at all. So, we need a way to customize our
    commands or change the default behavior during execution, feeding them further
    information. But how can we do that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the power of command-line options and arguments. First, we need to discuss
    the general structure of a command in the shell, which in its most simple form
    is `COMMANDNAME OPTIONS ARGUMENTS`. The command name is the name of the command
    to be started. Be careful, in Linux command names are case sensitive. Type `whoami`
    and then press *Enter*. This command will print out the name of the current user
    working in the shell. As Linux is case sensitive, this command cannot be started
    using uppercase letters, such as each version refers to a different command. Here,
    we will also see why the shell is such a useful program. It not only listens and
    interprets commands, but it also shows you helpful error messages when something
    goes wrong, such as a command cannot be found in the system. Normally, on Linux
    all standard Bash script commands are written in lowercase. To get a list of some
    of the available commands, type `ls /bin`. Now, let''s move on to one of the most
    fundamental commands available in the shell. Type `ls` and press the *Enter* key.
    This command lists files in a directory. If no further information is given, it
    prints out all the visible files in the directory that we are currently in at
    the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df3b85c2-095a-4ffe-97cb-0be15e3cad29.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a shell command can also contain options and arguments that
    are appended to the command name and separated from it using spaces. This means
    if you want to provide at least one option or argument, then we need at least
    one space after the command name. First, let's talk about command-line options.
    Their aim is to influence the behavior of a command. They are also called **switches**
    or **flags**. There is no obligatory standard, but normally any single-character
    command-line option starts with a single dash, whereas longer option names have
    two dash symbols. Also, if you want to provide multiple single-character command-line
    options, for most standard Linux commands you can just write them in series. It
    is good to know that single-character command-line options are often abbreviations
    describing their meaning: `-d` could stand for directory, `-x` for exclude, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know that the `ls` command without any further options gives us
    a list of all the files in the current directory. If you type `ls -a` and press
    *Enter*, you just run your first command with the command-line option. The `a`
    switch stands for all and this influences the default behavior `ls` by giving
    you a list of all files, including the hidden ones, which in Linux start with
    the leading dash in the current directory. Now, let''s type `ls -alth` and press
    the *Enter* key to see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7794f997-1e4a-49d5-b10a-3d1e7ef60280.png)'
  prefs: []
  type: TYPE_IMG
- en: This influences the command's default behavior even more by using the `-a` flag
    that we just discussed, and also using the `-l` switch, which stands for **list**,
    and it prints all the files in a list format, including more detailed information,
    such as the creation date. The `-t` switch stands for **time** and it sorts the
    file list by modification date with the newest entries appearing first, and `-h`
    stands for **human readable** and it will print out the file size in a more readable
    form using **MB** instead of bytes for the file size.
  prefs: []
  type: TYPE_NORMAL
- en: Often, command-line options can have arguments bound to them. In addition to
    options, we have command-line arguments, which are also called **parameters**.
    This is any dynamic or free-text piece of information that is not an option, and
    which gets fed into the command when it starts. Typical examples are filenames
    or directories that the command wants to process during execution. Arguments are
    also divided by *spaces*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `echo Hello` and press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5263ce5-9a0b-4a9f-b0c1-1a1565fec613.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous command, `Hello` is an argument for the `echo` command and
    not an option. The `echo` command is one of the most fundamental shell commands.
    It just prints the arguments given to it back to the command line. As we will
    see, this is ideal for testing shell features such as **globbing**, which we will
    learn more about later in this section. Now let''s type `ls -al /boot /var` in
    the Terminal and press *Enter* to see a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f8ccccd-1e52-4272-afeb-d3155c28a548.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, for the first time we used command-line options and arguments.
    The command `ls` is executed with the `a` and `l` options, and the arguments are
    `/boot` and `/var`. This will print out all the files, including hidden ones,
    in a detailed list view in the `/boot` and `/var` directories. As mentioned before,
    oftentimes arguments are bound to specific options, for example, the `tar` command,
    which we will discuss later. When you need to process an input file, you have
    to specify directly after the `-f` option and nowhere else or, in short, the input
    file argument is bound to the `-f` option. This approach is incorrect and will
    produce errors.
  prefs: []
  type: TYPE_NORMAL
- en: File globbing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how shell expansion works and how we can use
    file globbing to make our lives easier when using commands that deal with a lot
    of input files. We will discuss all existing and available shell globbing character
    classes and show you important use cases and examples for each of them. When working
    with commands that use file or directory names as arguments, such as the `ls`
    command, it is very helpful to learn about file and directory globbing. These
    are special characters typed in the shell that behave differently than regular
    characters. All globbing characters are going to be replaced by the shell with
    a list of files matching the characters' pattern right before any command can
    use them as parameters. It's a notation to simplify working with files, especially
    when dealing with a large number of files that you need to type and process. Using
    file globbing can save you a lot of time, by not doing repetitive work, because
    multiple files can be addressed by a single-character. The concept of replacing
    such special characters with a group list of files by the shell is also called
    **shell expansion**. There are several globbing characters available and we can
    use them to create very sophisticated file list selections.
  prefs: []
  type: TYPE_NORMAL
- en: Globbing characters are the wildcard, the question mark, the exclamation mark,
    the square brackets, and the dash. Although they look and behave very similarly,
    shell globbing and regular expressions are not the same, and both concepts are
    not interchangeable. This means you cannot apply regular expressions for globbing
    files and vice versa. We will learn more about regular expressions in an upcoming
    section in this chapter. The most important globbing character is the wildcard
    character. It will match any number of any character filename available in a specific
    directory, with one exception, it does not match files beginning with a dot, which
    you may have already noticed when looking at hidden files in Linux. What happens
    if you use the wildcard character with a file beginning with a dot and press *Enter*?
    Let's look at an example. As we showed before, we can use the `echo` command to
    print out random text in the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first change to a different directory. Type `cd /etc` and press *Enter*.
    Now, type `echo *` and press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1dc0322-b8d6-41ba-8e8c-ae951eb1e8f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous command, in the first step, the shell replaces the wildcard
    character with a list of files in the current directory and prints them separated
    by whitespace that follows the rule, and then shows all files and directories
    that contain any character, but it doesn''t show files that start with a dot.
    Using `echo` is the perfect way to test whether your globbing patterns match exactly
    what you want before applying them as real command-line arguments. You can mix
    the wildcard character with any other static character to make a file filter more
    stringent. Type `echo pa*` and press *Enter*. This will match all files starting
    with a lowercase `p` followed by `a`, followed by any other character. Or type
    `echo *.d` and press *Enter*. This example finds all files that have the `.d` filename
    extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3edc1a0f-159c-4235-9b08-eb72bf4c4b43.png)'
  prefs: []
  type: TYPE_IMG
- en: You can even define a more stringent pattern, for example, by typing `echo li*.conf`
    and pressing *Enter*. This globbing pattern will match all files in your current
    directory starting with a lowercase `l`, followed by `i`, followed by any other
    character, but only those that have a `.conf` filename extension. We can use file
    globbing with any command that accepts an option list of files as arguments, such
    as the `ls` command.
  prefs: []
  type: TYPE_NORMAL
- en: For example, using the globbing pattern, `li *.conf`, as a command-line argument
    for the `ls` command, gives us a detailed list of all the files matched by this
    pattern. Again, it's important to understand that we are not feeding the globbing
    pattern into the `ls` command and `ls` is not expanding files internally during
    the execution of the program. The truth is that a shell in the first step expands
    the wildcard character to a list of files and then feeds this list as arguments
    to the `ls` command.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `ls -d` option to not show directory content, which it does
    by default; this is because shell globbing doesn't differentiate between files
    and directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `ls -d rc?.d` in the Terminal. This will get you a list of all the files
    that have only a random character as the third character. Next, type in the `ls
    -d krb5.conf??` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7c97ed5-ae3a-47ee-bf3a-1ec2eb4c6d25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the question mark can also be used multiple times. This will
    get all files that have two random characters at the extension and only these
    files. The final globbing characters that we will learn about are the square brackets,
    which define ranges of allowed characters at a specific position, for example,
    type `ls -l sub[ug]id`. This will expand to a list of all the files starting with
    `sub` and having either `u` or `g` as the fourth character, followed by the word
    `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dce98d6-f011-4606-99a5-9e0e4e1effdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we will learn next, we can mix the brackets with other globbing characters.
    Type the following `ls` command argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This expands to a list of all the mail programs in the `bin` directory with
    and without capitalization. We will learn more about the `bin` directory later.
    You can also use numbers for ranges; type the `ls -d rc[01234].d` command in the
    Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91788f1c-35a5-43be-9bcb-aaa224664a62.png)'
  prefs: []
  type: TYPE_IMG
- en: In our example, this would be expanded to `rc0.d`, `rc1.d`, and so on. If you
    have consecutive ranges of numbers or letters, as in the last example, you can
    also use the minus symbol to shorten your globbing expression even more. For example,
    type `ls /bin/m[a-z] [a-z]`. This would give us all the three-letter command names
    in the `bin` directory starting with `m`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another helpful globbing character, which is the exclamation mark,
    and it can be used in brackets to define something that must not be in expansion
    results, for example, `ls -d rc[!256].d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/485cd3dd-c149-4cfb-b3fc-1700138933a5.png)'
  prefs: []
  type: TYPE_IMG
- en: This says that we don't want to expand files that have a `2`, `5`, or `6` as
    the third character. This also works for consecutive ranges within brackets, for
    example, `ls -d rc[!3-6].d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already learned three things about hidden files in Linux. They start
    with a dot in the filename, the wildcard globbing character ignores them, and
    `ls`, by default, doesn''t show them; therefore, they''re named hidden. To show
    all hidden files in your home directory, we use the `-a` option with the `ls`
    command. You see that there are several hidden files in your home directory, for
    example, the `.bashrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/873ee66e-2631-4a6b-909f-71cd386f56a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But there are also two other special files in your directory with the name
    [`.`] and [`..`], we will learn what these two special files are later on this
    chapter. What do you need to type if you want to display only the hidden files
    in the current directory without those two dot files? With all the knowledge you
    now have, this should be easy to accomplish, and the next line should now make
    sense to you. So, type `ls .[!.]*`. But this will also list directory contents.
    To not list directory contents, use the `ls -d` flag, so the command will be `ls
    -d .[!.]*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40f6e6de-d304-4168-ba3d-de3df85e21d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this section, we discussed everything there is to know about Linux shell
    globbing. Remember, the wildcard character matches every filename character in
    any position. It''s very important that there is one exception to this rule: it
    does not match filenames starting with a dot, which are called hidden files in
    Linux. The question mark does the same, but only in a single position; it also
    doesn''t match filenames with the leading dot. The brackets match specific characters
    in a single position defined between the brackets. When having consecutive permitted
    characters, you can also use the dash symbol. To match everything except a set
    of characters at a specific position, use the exclamation mark in brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: Quoting commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learned in the previous section, the shell has a list of special characters
    that have a special meaning in the shell and trigger some functionality, such
    as using the wildcard character as filenames. But there are even more special
    characters than the ones we showed you before. If you want to work with such special
    characters, for example, using filenames that contain question mark symbols, which
    are valid filenames, you have a problem, as the shell always first tries to apply
    special actions to special characters, so they will not work as normal filename
    characters. The solution here is to disable all special meanings of such characters
    using various approaches, such as quoting, so that we can treat them as any other
    normal literal character. As you now know, in the Linux Bash shell, there are
    some special characters, such as `* # [ ] . ~ ! $ { } < > | ? & - / , "` which
    have special meaning to the shell and get treated differently than normal characters.
    But what if you want to use a filename or directory as an argument that has one
    such special character in its name? Also, how do you treat filenames with spaces
    in the name, which can also be seen as special characters?'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a file in your directory called `My private Documents.txt`,
    how can you use it as a command-line argument? If you use it with the `ls` command,
    since the space is the command-line argument delimiter, the shell is not able
    to see it as one distinct file. Rather, it thinks you provided three different
    files called `My`, `private`, and `Documents.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a27557b4-d315-4bc3-a904-ec2d1f82c080.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, what happens if you want to use a file containing special characters
    such as the exclamation mark, for example, if you''ve got a file called `!super!file!.txt`,
    which is a valid filename in Linux? If we try to use this filename as a command-line
    argument parameter, it cannot find the file by this name because it contains special
    characters that are treated in a different way by the shell. Or what happens if
    you want to `echo` some text with more than one whitespace between the words?
    As we have learned, the space is also a special shell character that delimits
    command-line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d5efe93-75b1-4979-a3a8-c157d1b5f47f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the examples just shown, we need to find a way to disable shell expansion
    and to stop the shell from processing special characters. There are two easy ways
    to disable shell expansion in arguments, and these are quoting and escaping. Putting
    special characters and space into single quotes will prevent shell expansion and
    treat all possible chars, including the special ones, as normal alphanumeric characters.
    In single quotes, nothing ever gets shell expanded; for most special characters,
    this also works in double quotes with a few exceptions to this rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, two examples work, but others don''t and they
    get special treatment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bbdb7b6-ba43-4bd5-aa7e-292f3ef3694c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, as shown in previous screenshot, the dollar sign stays special as well,
    and this is often used if you need to shell expand environment variables while
    quoting. As said before, single quotes will disable all special characters. You
    can do the same by using the backslash key, which, in the shell, is also called
    the **escape character **and which does almost exactly the same as quotes, but
    will only disable shell expansion and every special meaning for the next, and
    only the next, immediate character after the backslash key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbb41cd7-c4ec-4108-adc7-56267743bd0e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it's basically the same. Often, the escape character is used
    to create clear multi-line command-line calls by escaping or disabling the new
    line character in each line. Another use case for the backslash character is to
    use it when working with arguments such as files starting with the dash, as this
    often confuses the shell because it interprets any dash symbol as an option.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to create an empty file named `-dashy.txt`, this will
    not work, as the command line is confused and thinks the filename is a list of
    single-character options. Here, we can use the escape character to get rid of
    the special meaning of the dash symbol. For arguments starting with the dash,
    some commands, such as `ls` or `touch`, also have another great feature, the double
    dash, which marks the end of the option list. So, to treat your dashy file as
    an argument instead of an option, we can also type the `nano -dashy.txt` or `touch
    '-dashy.txt'` command.
  prefs: []
  type: TYPE_NORMAL
- en: As you have learned, there exists a number of special characters in the shell
    that have a special meaning, for example, the shell globbing characters or the
    exclamation mark. What if you want to use these characters, not to shell expand
    the list of files, but in a filename or other literal command argument? You need
    to disable them. Using single quotes will disable all special characters and is
    the preferred way when working in the shell; it works for almost all everyday
    quoting use cases. When using double quotes, most special characters get disabled,
    but not all, such as the shell expansion of environment variables. So, this approach
    is very useful for text creation that contains normal characters and values of
    environment variables. The backslash or escaping character will disable any special
    meaning of the following character only.
  prefs: []
  type: TYPE_NORMAL
- en: Getting help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start teaching you how to get help using the various forms of
    documentation available for Linux commands, we first have to learn how to read
    the default command syntax documentation. Most of the provided standard shell
    commands in Linux follow a uniform format describing their usage. Afterward, we
    will show you how to get help.
  prefs: []
  type: TYPE_NORMAL
- en: When working with the Linux command line, getting help and looking up information
    and documentation is very important because the command line can be very complex
    and nobody knows and can remember everything. On every Linux system, there are
    several ways available to get help, depending on the kind of level of information
    you need to know. In this section, we will tap into the different sources of documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In a previous section, you already learned the general structure of Bash shell
    commands and everything you need to know about command options and parameters
    in general, but oftentimes this is not enough. For a lot of shell commands, the
    specific structure of options and arguments are very complex. A post can be bound
    to a specific position, and some of them can be mandatory or optional. Also, options
    and arguments can be interdependent. In Linux, a description of a command's command-line
    format, including arguments and options, is called **command usage** or **syntax
    of a command**. Learning to read a command's usage is one of the most essential
    skills that a Linux beginner needs to learn when starting. The standard way to
    describe command usage in Linux is the command name, square brackets that contain
    text, dots, and text, for example, `CommandName [XXX]... TEXT`. Square brackets
    mean that the content within is optional. Three dots mean that the expression
    right before the dots can be repeated multiple times or only once. Any word without
    square brackets is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, the general syntax for the `ls` command, which you already
    know how to work with. From the official `ls` manual, it can be read as `ls [OPTION]...
    [FILE]...`; this means that the command to list files has the following usage.
    It starts with the `ls` command name, everything else is in brackets, so all the
    options and arguments are optional, which means you can also execute `ls` without
    providing any further information, just by pressing the *Enter* key. But you can
    also provide multiple options or only one. Also, we can see that the arguments
    are of the `FILE` type, which means a file or directory is needed here at this
    position. You can also provide multiple files or directories, or only one or zero,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/254bdc69-e724-4e5b-a1ce-877a01332fd6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As another example, the `copy` command can be run by using the `cp` command
    name followed by zero or multiple options. The syntax of the `cp` command is `cp
    [OPTION]... SOURCE... DEST_DIR`. You can completely skip option, but at least
    one or more source directory and exactly one destination directory are mandatory
    and denoted by the three dots, and you cannot run the command without them. For
    example, running just `cp` without at least two arguments produces the following
    error. Correct usage would be with all options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1054ecf2-c917-41b4-841b-6e4bfcdb8b17.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know how to read any standard command syntax or usage, how can we
    actually get help? As we said before, there are several ways available, which
    are command help options, man pages, and full program documentation. Normally,
    all of these three types of help are installed together with the command line
    or program, so it's a very good habit to first try to get help for shell commands
    locally on the same machine where the commands live. This is usually the most
    accurate, reliable, and up-to-date information for every command and should be
    favored before doing internet research or using documentation from another computer
    with a different Linux version or system.
  prefs: []
  type: TYPE_NORMAL
- en: Often internet solutions found in blogs or forums are too unspecific or plain
    wrong for your specific Linux installation, and should always be used with caution.
    Don't ever blindly copy and paste command snippets from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Command parameters, options, and features can change over time depending on
    the version and implementation, and they can be very dangerous if applied incorrectly.
    There are hundreds of commands available on Linux and every one of them has a
    different syntax. No one can memorize everything, so first let's start with the
    easiest and fastest way to get quick help for any standard Linux program that
    you already know the name of. In fact, most programs do have a special command-line
    switch that prints out a quick summary of the usage of its options and arguments
    on screen, which in most cases is all you need to know. However, the help or usage
    flag is not standardized on Linux and some commands don't even have this flag
    at all, but most tool developers follow the rule to use the one-character flag
    `-h`, or the long option flag `--help`.
  prefs: []
  type: TYPE_NORMAL
- en: Not all shell commands have a help option, especially those very easy ones.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you need more help, you can check out the commands manual, which is
    often called **man pages** by Linux users. Most programs have such documentation.
    For the next few examples, you need to install some additional software using
    your root account's password, which you set up during installation. Man pages
    use lesser navigation, which we will talk about later when we learn how to view
    text files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to navigate the manual of any command in
    the Linux Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Terminal and type `man cp` for the `copy` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the *Page Up* and *Page Down* keys to scroll the document up and down, and
    slash (*/)* can be used to search text; put any keywords after the slash to search
    for, and then press *Enter*. For example, `/backup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *End* key to search for the next entry in the man page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To quit the search option, use the *Esc* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using lowercase *g*, you can scroll to the top of the page, whereas uppercase
    *G* scrolls to the bottom of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can press lowercase *q* to quit the man page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you go back to the top of the page, the man page of the `cp` command is
    divided into different topics and headings, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a16d1618-56c7-43fa-ad49-b81e6ee9cf5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Most standard Linux commands follow this type of structure. Also, you can see
    here that some commands can have different usage formats depending on the options
    and arguments given. Now, quit using the *q* key. The `man` command has a very
    useful option, type `man -k` and put any definition of interests as an argument
    afterward. This will search all man pages installed on your system for a certain
    keyword. For example, this is very useful if you forgot a specific command name
    or need general help with the topic or command to use or where to look first.
    If you type the `man -k copy` command, this will print out all the man pages for
    the commands that have something to do with copying:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad0c03ec-3196-4227-9505-5a66403941ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While using the `-k` flag, you also see that the search result writes some
    numbers in the brackets after the man name; these are man page sections, which
    is another very useful concept we need to know. A Linux shell definition, such
    as `printf`, can describe more than only a command-line program, and man pages
    not only describe command-line tools. In our example, `printf` is not only a command-line
    tool that can be started by the shell user, but also the name for a library function
    in the programming language C, which is used by this system. `man` now defines
    a system of section numbers for the type a specific man name is from. Typing `man
    man` will display the manual documentation for the `man` command, and search for
    the keyboard sections, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1609794-341f-41c7-b07b-b02aa13663cb.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the previous screenshot, the man page of the man command has
    nine sections. The first one is the most important one for us in this section,
    as we are most likely the shell command users. But, as you can see, the third
    section is a library call. Type `man printf`, which prints the usage of the `printf`
    command. On the other hand, if you type `man 3 printf`, it will print the Linux
    programmers' manual for the C language.
  prefs: []
  type: TYPE_NORMAL
- en: Let's jump to the eighth section, which is the manual for the `xfs_copy` command
    written for the system administrators. Besides manual pages, a lot of commands
    that can be installed on Linux or that come right out of the box with the system,
    do have additional and advanced documentation available in a specific folder location
    in the filesystem on your hard disk. For some programs, additional documentation
    can also be installed using a special installation package, as we will learn later
    in this section. Sometimes, this additional documentation contains precious usage
    examples on how to use the program; information about the internal algorithms
    or approaches used; change log and license information; author contact information;
    history; a list of errors or limitations; or sample configuration files, which
    we will talk about later.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get stuck with the manual or it is just not enough for you, try to check
    out if a documentation folder exists for your command of interest in your CentOS
    7 standard documentation path. Type, for example, the `postfix` documentation
    folder lives in. This is a good example. If you go into the directory, you will
    find a lot of additional documentation in text file format. Refer to the following
    screenshot for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/353c36f2-8d79-4fe1-a1d8-8766fee5dd81.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the less program to read the files. Use the same keyboard shortcuts to navigate
    the files as with the man pages, for example, type *q* to exit.
  prefs: []
  type: TYPE_NORMAL
- en: If you need more or advanced documentation, look into the `/usr/share/doc` folder
    and see if there's something available for you.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Linux shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to work in the shell efficiently. We will
    introduce some important practices and techniques that will improve your productivity
    and make you a faster shell command hacker. This can make you a happier person
    because, eventually, you will be able to advance to feeling very comfortable working
    in the shell. Please note, in this section, we will show you a lot of keyboard
    shortcuts. Learning keyboard shortcuts is like learning any other craft, you begin
    slowly and gradually, because learning too many new skills at once can leave you
    overwhelmed and make you forget more quickly than learning in smaller chunks.
    My tip is to start by learning the first three to four command editing shortcuts
    and then incorporate more from day to day or week to week. We will start with
    the command editing shortcuts. Now, if you don't know any command editing shortcuts
    at all, let's recap what you probably know so far on how to type and edit text
    in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The first shortcut for moving the position of the cursor is that you can use
    the left and the right arrow keys, which are helpful to edit the text you wrote
    to insert or delete characters at a specific position. But if this were all that
    one could do in the shell, working in the shell would be very inefficient, because
    single-character cursor movement is very slow. Also, every time a command gets
    executed with a typo or the command needs to be rerun with a small difference,
    such as changing one option, the complete command needs to be retyped from beginning
    to end.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be a lot more efficient, let''s introduce some very important command editing
    shortcuts for your everyday work with Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: To move the cursor to the end of the line, use *Ctrl* + *E*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To go back to the beginning, press *Ctrl* + *A*, *Ctrl* + *E*, *Ctrl* + *A* respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To move the cursor to the next word, which is defined by a space or special
    characters such as dot, semicolon, or point, use *Ctrl* and the right arrow key
    to move forward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To move backward one word, use the left arrow key while holding the *Ctrl* key.
    You can also use *meta* + *F* and *meta* + *B* to do the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On most systems, like any normal PC keyboard, there is no meta key, so the meta
    key is mapped to the *Esc* or *Alt* key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the *Alt* key in some terminal emulators such as the Xfce4 Terminal is
    reserved for menu accessibility. So, you first have to disable the *Alt* key as
    a menu shortcut in the preferences before you can use it as a shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: To toggle between the current position and the beginning of the line, press *Ctrl*
    + *XX* twice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *K* to delete the text from the cursor to the end of the command
    line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To delete the text from the cursor to the start of the command line, press *Ctrl*
    + *U*. Use *Alt* + *D* to delete to the end of the word.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the command editing keyboard shortcuts we just discussed here are only
    the most important and efficient ones for your everyday daily use, and there are
    many, many more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get a full list of all of the Bash keyboard shortcuts, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Type `man bash` and then search for the section commands for moving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this man page, search for `Killing`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this man page, the *C* key is the *Ctrl* key, the *M* key is the meta key,
    and the dash means to combine or press and hold two keys, as we have shown you
    using the *Ctrl* + *A* shortcut earlier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `C-k` stands for **kill-line**, which kills the text from the point
    to the end of the line. *Alt* + *T* is used to swap words, `M-u` to make words
    uppercase, and `M-l` to make words lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the command completion shortcuts. The most important command
    completion shortcut is the *Tab* key on your keyboard. It tries to guess and autocomplete
    the command you are about to type. It is very useful and speeds up typing commands
    tremendously, but don't overdo it when using this key, it can only print the full
    unique command name if there are no alternatives available. Type `pass` and press
    the *Tab* key; it will autocomplete the name `passwd` as there are no other programs
    with this full name available. Type `pa` and press the *Tab* key; this will give
    you several results as no unique name can be found. Type `yp` and press the *Tab*
    key; this will autocomplete to a long name as this is the only `variant` available.
    The *Tab* short key autocompletes commands by default; to autocomplete other things,
    such as filenames, use the *Alt* + */* key. More can be found in the corresponding
    section in the Bash man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at to the command recall shortcuts. The Linux shell has a
    very nice feature available, which is the `history` command. This is a system
    for storing and retrieving all the commands typed into the shell. By default,
    on a CentOS 7 system, the last thousand commands are stored. This number can also
    be changed. The command-line history is a very useful feature to save time, by
    not doing repetitive typing, or to see how a specific command has been executed
    some time ago. To print out the current history, type `history` and press *Enter*.
    If you want to re-execute a command from this list use the exclamation mark and
    the corresponding number. Two exclamation marks run the last command from the
    history. Another exclamation mark notation can be used to extract specific arguments
    from history commands. This will extract the third argument from the `history`
    command, `166`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a19d06c-e425-49dd-8361-beb6320793cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another very useful history feature is to recall the last command:'
  prefs: []
  type: TYPE_NORMAL
- en: To go through the previous history commands you executed, press the Up arrow
    key on your keyboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To go back to the next history commands, use the Down arrow key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To search through the history for a command, press *Ctrl* + *R* and then enter
    the search keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To cycle through the results, press *Ctrl* + *R* again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run a specific command that you have found, press the *Enter* key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To quickly insert the last argument of the previous command, use *Alt* + dot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another very useful feature is to shell expand a line manually without actually
    having to execute the line, which can be useful to find out errors and boxes.
    This can be done using *Ctrl* + *Alt* + *E*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we need to know how to work with programs and processes. First, we will
    discuss how to abort any running program. This is important if you need to quit
    a command because it is unresponsive or you've made a mistake and want to stop
    it. For example, let's type the `cat` command, which will just run forever. Let's
    ignore what this command is doing at the moment. This leaves the shell unresponsive
    because `cat` never finishes running in the forefront of our shell and runs forever.
    To get back to the shell prompt so we can type in new commands and work again,
    we need to exit the command while it is running. To do so in the shell, we can
    use a special key combination that exits the current foreground process. Press
    *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very important key shortcut and it should be memorized: *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also suspend a program, which is like pausing its processing and putting
    it into the background so you can work in the shell again. This can be done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Press *Ctrl* + *Z*. If you later want to continue the program running in the
    foreground, type `fg` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also put it in the background using the `bg` command while it is suspended.
    Now the program runs in the background and you can work in the foreground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The easiest way to exit this program running in the background is to put it
    into the foreground and then use *Ctrl* + *C* to abort it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next very useful command is to press *Ctrl* + *L*, which clears the screen
    and has the same effect as the `clear` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The very last useful command we will learn here is to press *Ctrl* + *D*, which
    closes the Bash shell. This is similar to typing the `exit` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding standard streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn why every command can use three standard streams
    for accessing its input and output. Also, you will learn how to work with those
    input and output streams and how to use redirection. Finally, we will learn how
    to use pipes and why they are so important. One philosophy of the Linux operating
    system is that every command has exactly one functionality in the system, nothing
    more, and nothing less. For example, there's one command to list files, another
    to sort text, and one to print the file's content, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, one of the most important features of the shell is to connect different
    commands to create custom tailored solutions and tools for all kinds of problems
    and workflows. But before we can show you how to concatenate different commands
    together to build something powerful, we first need to know how a command uses
    its input and output and what input and output redirection is. Most Linux commands
    follow a similar pattern when processing data. Most of the commands we are using
    do get some kind of input, for example, they read the content of a file and then
    they process this information, and afterward almost all of them do output some
    kind of results on the computer screen. Because every command uses some kind of
    input and returns some kind of output on Linux, three standard channels are defined
    and are available for every command. They are used for communication between the
    operating system and the command during execution. They are called **standard
    input** or `stdin`, **standard output** or `stdout`, and **standard error** or
    `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: Normal program output goes to the `stdout` channel, while `stderr` is also an
    output stream and it can be used for showing and processing any kind of error
    messages occurring while a command is executing. These are also called **standard
    streams**. They are called streams because the data is flowing continuously through
    a specific channel and gets processed or generated consecutively by the command,
    although they have an open end, which means the command working with them cannot
    predict when this flow of data will stop or finish. Now, we can change the `stdin`
    and `stdout` locations using certain files; this is called **redirection**.
  prefs: []
  type: TYPE_NORMAL
- en: Here, in this section, we will also explain the concept of pipes, which is one
    of the most fundamental concepts and major features of the Linux shell, and how
    to work with them. For example, if you type `ls /var/lib/system/`, the result
    random-seed will be printed to the screen because it is defined as an `stdout`
    device by default for every Linux command. But if you type `cat /var/log/messages`,
    an error message is printed to the same screen as both `stdout` and `stderr` are
    connected to the same output device, the screen.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, your physical input and output devices, such as your keyboard or screen,
    like any other hardware devices, are abstracted and represented by special system
    files. All of these special files reside in a system directory called `/dev`,
    which is also called the **system devices directory**. But what can we do with
    a system like that? Its beauty is that we can redirect the input and output of
    a command to another location other than the default keyboard and screen source
    or destinations, which also must be of the filetype. This is also very useful
    to separate `stdout` and `stderr` to two different locations, which especially
    helps to keep the overview of a command running if it produces a lot of output.
  prefs: []
  type: TYPE_NORMAL
- en: For output channel redirection, we use the greater than sign (*>*), for input
    redirection we use the smaller than sign (*<*). To address a specific channel,
    such as `stdin`, `stdout`, and `stderr`, we use the corresponding numbers `0`,
    `1`, and `2`. When using output redirection, the `stdout` channel is expected,
    so we don't have to write it explicitly. For 99% of all cases you only redirect
    `stdout` and `stderr`, so let's focus on those examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To redirect the `stdout` stream output of a command to a file, use the greater
    than sign. As said before, the `stdout` channel is expected, so the last command
    can also be typed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `card` command to print out the content of the file that we just created
    with the redirection to `stdout`. To redirect the `stderr` channel, use number
    `2` as the standard stream descriptor. The following screenshot shows the output
    of the previous commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b04e011-9e42-422d-9fa8-43cc7e64a47e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the error message has been redirected to a file. To redirect
    `stdout` and `stderr` to two different files, type the commands shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a3bd9a4-0228-48af-9ca0-c832a49f06f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another notation, using the *ampersand* char allows the redirecting of one
    channel another one. To redirect `stderr` to the `stdout` channel, type the commands
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5754adbc-5759-4200-8c37-19fcac394707.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes, you are only interested in one output stream, therefore a special
    device file exists in any Linux system, which is called the `null` device, and
    it consumes and vanishes any kind of streaming data that gets redirected to it
    into the void. If you don''t want any output at all for any command, for example,
    you can use the command shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11f2e005-80c4-41aa-a86b-3a34ca25356a.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, to redirect `stdin`, you use the smaller than sign [`<`]. For example,
    this can be very useful because some of the available shell commands can directly
    read a file's content as `stdin`, such as the `grep` command, which we will learn
    about later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss pipes. Besides redirecting a command's default input and
    output streams, `stdin`, `stdout`, and `stderr`, to files, we can also use the
    concept of shell pipes to get one command output as the input for another command.
    There are no limits to this system and it's very easy to build multi-command chains
    to answer very complex questions for you. As mentioned previously, this shell
    feature lets you create very powerful command pipelines and workflows for creating
    custom tailored solutions for all kinds of Linux command-line work, and to answer
    very complex questions for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'To chain commands together, which means to use `stdout` from the first command
    as `stdin` to the next command, we use the vertical bar symbol [`|`] on our keyboard,
    which in Linux is called the **pipe** symbol. For example, if you''ve got a very
    long directory content list that you want to read without scrolling through the
    Terminal window forever, you can use the pipe to output the directory content
    from the `ls` command, not on the screen, but directly as input for the file viewer,
    as we learned before. Often, pipes are used to avoid intermediate result files
    and are more efficient without them. The use cases for this are endless, for example,
    if we got a file with unsorted names of people in it, we could sort them using
    `cat names.txt | sort`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06f54597-854a-4347-bc93-2c6b62fa8f2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also get a list of all the unique names in this file. We will use the
    unique command to do so, which only works on a sorted list. So, we need to sort
    using `cat names.text | sort | uniq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/729cab59-0336-4c7a-a106-a3cd9c908b25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also count the number of unique lines using the word count command-line
    tool using `cat names.text | sort | uniq | wc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef883ce1-f0bb-4d18-ba83-41772fec0efe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are quite a few unique names in this file. The sky''s the limit when
    it comes to pipe examples, and there are just too many examples. Ideally, this
    should be run with the `root` user account. Please ignore the errors. The following
    screenshot shows the core summary of the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72686415-4aae-4ceb-ac5d-9819e377693e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, another useful pipe command is to print out the used files in a directory.
    If you are using a Windows system, you may know of a utility called ZIP, which
    compresses files. On Linux, you can do something very similar, but here we need
    two tools to work together. For compression, we use the `gzip` tool. Because `gzip`
    can only work on single files, we first need to create an archive that will concatenate
    multiple files to a single file. For archiving, we use the `tar` command. So,
    to create a compressed archive of your home directory in the `/tmp` directory,
    first create an archive of your home directory using the `tar` command: `tar -cv
    /home/olip/ | gzip`. The archive will be output to the `stdout` stream, so we
    pipe it into the `gzip` command as `stdin`. As gzip itself outputs the compressed
    file to `stdout`, we will redirect it to a file. The result of the compression
    versus the uncompressed data amount is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fd858d0-e6f0-4260-bf40-0183ec1aa613.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A lot more piping examples will be shown throughout this book. If you redirect
    `stdout` or `stderr` into a file, normally the file will be erased if it already
    exists, or a new file will be created before any content is written to it. So
    as not to delete a file, but append the content instead, use the greater than
    sign. For example, to create a new output file, execute the command shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47b8f3be-2e24-459d-a657-e025a89885db.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, to append the string, `Hello World`, to the output file, we will use the
    greater than sign. This will not delete the file's content when we start to redirect
    content to it. Instead, it will append the content to the end of the file. As
    said before, pipes are one of the most important concepts of the shell and it
    is so much fun working with them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce the wonderful art of regular expressions.
    You will learn what they are and why they are so powerful. There are a lot of
    different regular expression characters available, and here we will introduce
    the most important ones. Afterward, you will learn how to apply regular expressions
    with the `grep` command to find, extract, and filter useful information out of
    text files. **Regular expressions**, or **regexps** for short, are a very powerful
    concept used to search through text using special patterns, describing the structure
    of the search term instead of a constant string of characters, which is also called
    **literal text search** in this context. Using regular expressions can save you
    a lot of time, by not doing repetitive work, and Linux system administrators use
    them quite heavily in their everyday work.
  prefs: []
  type: TYPE_NORMAL
- en: In the *File globbing* section, we learned a very similar concept when we used
    globbing characters to find patterns to address multiple filenames with some special
    characters. Regular expressions are an even more powerful tool; they contain a
    very broad set of all kinds of special characters for matching even the most complex
    text fragments completely or partially. In the Linux shell, we use regular expressions
    not for shell expansion or to group filenames, but rather to work on the content
    of text files or strings of text lines to parse and analyze their content or extract
    text features out of it. As said before, regular expressions are a very complex
    topic and we can only give you an overview here. Please note that there are several
    styles of regular expressions available, such as Perl regular expressions. In
    our examples, we'll use the POSIX, basic, and extended regular expressions, as
    used by most of the shell tools, such as `greb`, `sed`, and `awk`. There are a
    lot of different regular expression characters available, which are also called
    **meta characters**.
  prefs: []
  type: TYPE_NORMAL
- en: As some of these meta characters are extended POSIX characters, we need to start
    our regular expression processing commands in the extended mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the extended expressions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`n` is used to match the end of the line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t` matches space at the top.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caret `^` symbol matches the beginning of the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dollar `$` symbol matches the end of the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[x]` is very similar to globbing brackets, which you have learned about before.
    This describes classes of characters to match within the brackets at a specific
    position. You can also define ranges of characters here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[^x]` matches all characters that are not defined in the brackets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parentheses are used for grouping; this will save the text within the parentheses
    for further referencing afterward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` for number is used for back referencing. This will get number *n* of the
    reference extracted from the parenthesis, which we showed you before.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a|b` means that at this position *a* or *b* are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x*` means to match zero or multiple occurrences of an *x* character at this
    position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y+` means to match one or more multiple occurrences of an *y* character at
    this position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dot means to match any character at a specific position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's also very important to know that a lot of tools working with regular expressions,
    such as `sed` and `awk`, expect that the regular expressions are surrounded by
    slashes. Also, the scripting language Perl has adopted this style. In other tools
    such as `grep`, you don't need to use the slash notation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first experiment with our new regular expression concept using the command
    `grep`. We start grep in the extended mode using the `egrep` command-line tool.
    Instead of running the command `egrep`, you can also run the command `grep` with
    the capital `-E` option, which has the same effect. `grep` is a command that goes
    through a text file or input stream, line by line, and tries to match the search
    pattern argument given to it to every line. If a specific line matches the pattern,
    it will print out the complete line. This is very useful for all kinds of text
    extraction, and `grep` is one of the most important command-line tools available
    on Linux. In fact, I cannot remember a day working in the shell when I did not
    use it at all. Oftentimes, `grep` is used as a filter as part of a greater pipe
    command workflow to reduce huge output text that you want to process further.
  prefs: []
  type: TYPE_NORMAL
- en: First things first, as said before, we will use the POSIX `regex`. There exists
    a lot of different regular expression terms, too many to memorize, so every time
    you need to look up the syntax, type `man 7 regex`. In this manual, you will find
    everything you need to know about regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start extracting various information out of files. We will start by using
    the `grep` command without a regular expression, but rather searching for simple
    text literals, `grep root /etc/passwd`. This returns all lines in the `passwd`
    file that contain the word `root`. Any line in the output gives us information
    that groups the `root` user it belongs to. As you can see, grep goes through the
    complete file and finds all lines that contain the string `root` at any position.
    A very useful `grep` option is `-i`. This can be used to ignore case sensitiveness
    for the search term. For example, execute `grep -I root /etc/services`. This will
    find all occurrences of the word `root`, while ignoring the case. This will find
    all the other case permutations of the word `root` as well. When working with
    regular expressions as arguments for commands such as `grep`, `sed`, or `awk`,
    it is recommended to quote your meta characters with *single quotes*. This is
    because some of the regular expression characters are the same characters as the
    shell globbing characters, such as the wildcard character, and this would be bad.
    Shell expansion always takes place before any argument gets fed into any command,
    so using the correct command without a disabled wild card character would search
    for a string containing all the filenames in the specific file that you want to
    search for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, always put your regular expression meta characters in single quotes.
    Also, if you want to search for a literal special character in the file that is
    the same as the regular expression meta character, you need to escape the character,
    which is similar to what we learned in the *File globbing* section using the backslash
    key. The following screenshot illustrates one example for every meta character
    mentioned at the start of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42eee779-0e46-4aed-92b0-61cbec2cfdf6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The dollar sign matches at the end of the line, so this will print out all
    the files ending with data in the services file. Similarly, we use the caret `^`
    symbol to match at the beginning of the line. The following command here matches
    all the lines starting with the word `day`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f06d6723-c123-4b1a-9b61-c158f5d503cb.png)'
  prefs: []
  type: TYPE_IMG
- en: A bracket expression is a list of characters enclosed in square brackets. It
    normally matches any single-character from the list at a specific position. You
    can also define ranges in square brackets using the dash symbol similar to the
    ones we have shown in the *File globbing* section. If the list in the brackets
    begins with the caret symbol, it matches any single-character not from the rest
    of this list. Normal brackets can be used to save a reference of the match within
    it. To back reference, we use `/number` of the bracket expression so that the
    regular expression matches all the lines starting with the first letter, for example,
    `egrep 't(ac)1*s' /etc/services`. The pipe symbol stands for *or*, so the next
    expression matches all the lines containing either **domain** or **gopher**. Dot
    matches any character at a specific position. Plus means to match zero or multiple
    occurrences of the character before, so that this regular expression matches all
    the lines containing `at-`, but not at the end of the line. The star meta character
    matches one or more occurrences of the character before, so that the `egrep 'aa+'
    /etc/services` expression here matches all the lines that contain at least two
    `aa` or more. The plus character matches one or multiple occurrences of the character
    before, so that this regular expression here matches all the lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'As said before, the dot matches every character at a specific position, so
    that the regular expression matches all the lines containing exactly the number
    of characters corresponding to the number of dots in the expression. `grep` has
    a lot of useful options, for example, `-v` reverses the search match, which means
    print all the lines that do not contain the search pattern at all. I often use
    this option to remove all empty lines and command lines in a lot of configuration
    files that start with the hashtag in shell script files. For example, execute
    the command shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43c20227-c279-46f3-a1f7-9f1422d30d33.png)'
  prefs: []
  type: TYPE_IMG
- en: The manual contains a lot of command lines that start with the hashtag and empty
    lines. To filter out all these un-needed lines, use the `grep -v` option. Another
    useful feature is the `grep -o` option, which only prints the matched pattern
    and not a complete line. So, for example, `egrep 'netbios-...' /etc/services`
    prints out the full line, while the `-o` option only prints the pure NetBIOS name
    from the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Working with sed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn about the `sed` command, the powerful stream
    editor. We will give you a brief introduction on how `sed` works and we''ll be
    showing you the substitution mode for automatically replacing text and files,
    which is one of the most important modes available. Next, we will learn about
    the `sed` command. Let''s first examine its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`sed` stands for **stream editor** and this command can edit files automatically
    without any user interaction. It processes input files on a line-by-line basis.
    Oftentimes, `sed` is used in shell scripts to transform any command''s output
    to a desired form for further processing. Most everyday use cases for `sed` follow
    a similar pattern, which, in its most simple form, is first used with a regular
    expression or other pattern to define which lines to change in an input file or
    stream, and then provide a rule on how to change or transform the matched line.
    Similar to the `grep` command, always use single quotes when working with `sed`,
    unless you need to work with environment variables within the `sed` expressions,
    then you should use double quotes instead. Normally `sed` reads from `stdin`,
    processes the stream internally, and outputs the transformed version of the text
    to `stdout`. So, it''s ideally being used in a `pipe` command, therefore it is
    often part of pipelines. `sed` can be used for a lot of different use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: A very easy example using address ranges would be the `d` option, to delete,
    which also helps you understand how `sed` does its processing on input and output
    streams. So again, `cat /etc/services | sed '20,50 d'` pipes the `etc/services`
    file stream using `cat` into `sed`. `sed` processes the input stream line by line,
    and, here, all the lines that are not between line number 20 to 50 get handled
    directly over to the `stdout` channel, while lines number 20 to 50 get suppressed
    completely. You can also use regular expressions with the `d` option. Remember
    to put any regular expressions in slashes when working with `sed`. The `sed` command
    ignores all the lines starting with the hash symbol, but it prints out all the
    others to `stdout`. There are a lot of different options and modes that can work,
    but there are too many to mention here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important usage for `sed` is definitely the substitution mode, which
    can be used to automate file or text editing without any user interaction. Its
    general syntax is: `sed ''s/search_for_text/replace_with_text/'' FILENAME`. This
    will search for the pattern between the first slashes, which can be a regular
    or literal expression, in the file filename, and if and only if this pattern matches
    the text somewhere in the line in this file, will it be replaced by the text to
    be found between the other slash. This only works for the first occurrence in
    the file. If you need to replace all occurrences of the search text in the file,
    you have to use the `g` option at the end of the slash expression. For example,
    to replace the word `root` in the `passwd` file with the word `King_of_the_Jungle`,
    for every occurrence, execute the command shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a46e9cd-26af-4ed3-a86b-9dc62120a57c.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are searching for anything that contains slashes, you can escape the
    regular substitution usage using a different pattern delimiter, because otherwise
    you would need to escape the slash character that you want to search for or replace,
    which can look very complicated and unstructured. This can also be written as
    `sed 's:XX:YY:g' FILENAME`, or any other character of your choice. So for example,
    if you want to replace single slashes with double slashes in a file, instead of
    using `sed 's//////g' FILENAME`, it's cleaner to use `sed 's:/://:g' FILENAME`,
    or `sed 's#/#//#g' FILENAME`. Using the substitution mode without any `sed` option
    will always print the transformed text to `stdout`. Sometimes, it is useful to
    directly change the text in the input file. This can be done using the `sed -i`
    option, or inline option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will work on a copy of the `passwd` file to show
    you how to do in-place editing. In order to do so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a copy of the `passwd` file in the `/tmp` directory, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/140e3682-1a00-4c39-acce-e0199bc574f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's first show all the lines containing the word `root`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, replace the word `root` in the file with random text on `stdout` only.
    Execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to in-place edit the file, use the `-i` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The file has been permanently changed. Please take care when using this option,
    because if you have not tested your substitution before and you have made a mistake,
    you cannot revert your changes. It is better to create a backup copy of the original
    file before applying in-place editing, which you can do using the `sed -i` option,
    for example, `sed -i.bak ''s/root/RULER_OF_THE_WORLD/g'' /tmp/test-passwd`. If
    you write a new extension such as `.bak` behind the `-i` option, it will create
    a backup copy with the extension `bak` before applying the regular expression
    to the original file. When working with these regular expressions in the substitution
    mode, the grouping and back referencing feature that we showed you before makes
    substitutions very powerful, because this gives you real control of the changes
    needed to be made for your input text, for example, the `passwd` file contains
    colons as field delimiters, one colon to separate one field. Using sed when back
    referencing, we can replace one colon with four:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd6696d5-77cc-4f47-b11a-8b0eb26bafee.png)'
  prefs: []
  type: TYPE_IMG
- en: POSIX extended regular expressions as used by `grep`, `sed`, and `awk` also
    define a number of very useful special character classes in brackets, which can
    be very useful in pattern matching. The general syntax is `grep '[:digit:], [:space:],
    [:blank:]'`. The digit bracket character class matches all digits at a specific
    position. Space matches all the spaces, and blank matches all the whitespaces,
    such as the *Tab* space, and blank matches all the whitespaces. To match all the
    lines containing digits in the `etc/passwd` file, use `grep '[[:digit:]]' /etc/passwd`.
    For a list of all special character classes, use the `man 7 regex` manual.
  prefs: []
  type: TYPE_NORMAL
- en: Working with awk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will show you what the command `awk` is all about and why
    it can be important for us. We will also show you how to use it for text file
    manipulation and processing. `awk` is another very important tool for text processing
    and manipulation. It can be used as a complete scripting language to work on text
    files or streams. It contains some very powerful programming constructs, including
    variables: *if...else*, *while*, *do while* and *for* loops; arrays; functions;
    and mathematical operations. `awk` also works on a line-by-line basis, as `sed`
    does. One of the key features of `awk` and the main difference to `sed` is that
    it splits input lines into fields automatically. But how does it work and why
    is it so helpful?'
  prefs: []
  type: TYPE_NORMAL
- en: '`awk` enables you to create rule and action pairs, and, for each record that
    matches this rule or condition, the action will fire. The rules are also called
    **patterns** and are fairly powerful and can use **extended regular expressions**.
    The language for the actions is similar to the programming language C. Using the `awk`
    symbol paradigm to find a pattern in the input and then applying some kind of
    action often reduces complex and tedious data manipulation tasks to just a few
    lines of code, or even one-liners. `awk` also lets you create and execute powerful
    `awk` script files for automating challenging text transformation tasks but, in
    this section, we will only focus on using `awk` options and arguments on the command
    line. Please note that, as `awk` is a complete scripting language with a lot of
    features and options, we can only show you the most important use cases and examples
    here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the basic structure of any `awk` command: `awk [pattern] { action }...INPUTFILE`.
    It''s important to note that the actions must be surrounded by curly brackets.
    This can also be read as: go through the input file line by line and try to apply
    the pattern to each line. If, and only if, the pattern matches or the rule can
    be applied to the line and is true, the action between the curly brackets will
    be performed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to learn and understand the `awk` tool is to use it without
    any rule or pattern and just define a simple action. Without giving it a pattern,
    the action will be applied to any line of input. As said before, `awk` completely
    splits each input line into fields so we can directly access those fields in the
    action argument using the following notation. As always, actions and patterns
    should be put into single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print out field `1` of all the lines of the `etc/networks` file.
    As you can see, the action must be surrounded by curly brackets. `$number` is
    the number of the field and `$0` is the complete line. As you will probably know
    now, `awk` splits on every whitespace position by default. You can use the `-f`
    option to change the field separator. For example, to split the `passwd` file
    correctly, which has colons as field separator, you would specify the field separator
    `-f` using colon. This will print out field one of the `etc/passwd` file and the
    username: `awk -F: ''{ print $1 }'' /etc/passwd`. You can also use the awk `printf`
    function, which prints out the text formatted, as you may know from other programming
    languages: `awk -F: ''{ print "user: %stgroup: %sn", S1, S3 }'' /etc/passwd`.
    The `%s` will be substituted by the field numbers. `t` makes a *Tab* character
    and `n` makes a new line character.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to test some patterns. As we've said before, if you define a
    pattern or rule that can also be an extended regular expression, it will be applied
    through every input line and only for those matching the rule will the action
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will print out field one of all the lines, and only the
    lines, starting with small `t` in the `etc/services` file. Here we will pipe it
    into the `head` command to reduce the output to only the first 10 lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a70171b9-8dff-44d3-af97-5cdd635d5fd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Please remember to put any regular expressions into slashes when working with
    the `awk` command. One of the greatest features of awk is that the pattern can
    also be more than a simple regular expression. For example, you can also use string
    and mathematical comparison operators here. This will help you answer very complex
    text manipulation questions with just a few tiny expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc95c7e7-31df-4995-a9b3-17085cc0422c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous example, `awk` only outputs lines from users in the `etc/passwd`
    file, which have a group ID greater than `500`. The greater than sign is the operator.
    There are lots of other operators available, but there are too many to mention
    here. For example, to match a regular expression, use `awk ''$1 ~ /netrjs/ {print
    $0}'' /etc/services`. The tilde is the regular expression match operator. To match
    string literals, use the equal sign twice instead, `awk ''$1 == "netrjs-4" {print
    $0}'' /etc/services`. To get a list of all the awk operators, search for operators
    in the man page. Also, `awk` has two special patterns, which are called **BEGIN**
    and **END**. As any other pattern, you can define an action for the begin and
    for the end pattern, and this will fire only once, at the beginning or at the
    end of the file. We can use this to print out the total number of bytes in a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fafc9ee2-d1d3-422c-92db-9bf188441ca1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This `awk` command works this way: first it uses a variable called `SUM` that
    acts like a container for our number counting. The `+=` is a mathematical operator
    that adds field number `5` to our container `SUM`, so that this action counts
    the number of total bytes from the single byte number in field `5` on each line.
    Also, on each line we print out the whole line content, and, once we reach the
    end of the file, the end pattern will fired, which will print out the content
    of our `SUM` variable, which holds the total number of bytes in this directory.
    As you just saw, we can define custom variables to hold values that we want to
    have and work with. There are also a number of predefined variable names available
    in awk, which contain very useful information. For example, the `NR` variable
    name contains the current line number. This can be useful in the following `awk`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will prepend the line number to each line of the output using the `NR`
    variable, which contains the current line number in each line. For a list of all
    the special awk built-in variables, use the manual and search for variables.
  prefs: []
  type: TYPE_NORMAL
- en: awk contains a number of very useful predefined functions to use, such as the
    `print` or `printf` functions that we already know from the action statements.
    To execute more than one function in one action block you can use the semicolon.
    For example, awk contains a number of very useful string manipulation functions,
    such as the `toupper (argument)` function. Functions in awk work like functions
    in most other programming languages. You call it using the function name and then,
    in brackets, you add the argument or arguments. For example, we use this with
    the `print` and `printf` function in the awk action. For example, in awk there
    exists a string function called `toupper`, which converts every string argument
    to uppercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a complete `awk` command-line example that uses the `toupper`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5addac74-524f-4f61-b729-45e5bfd8e3eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This prints out the first field in the `passwd` file normally, and then again
    with all letters in uppercase. Our final example will show you how to execute
    more than one expression or function in one action statement using the semicolon
    as an expression delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91e0abde-a7b5-4de3-be0e-d2bfdbd88dec.png)'
  prefs: []
  type: TYPE_IMG
- en: Also, you can see here that you can assign the return value of any function
    to a variable name, and then reference this variable name later, so that this
    example is very similar to the example before by first printing out the uppercase
    version, and then the normal lowercase version, and then the normal field value
    version. For all the available awk functions, we use the manual and search for
    functions, numeric functions, string functions, time functions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the Linux filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to navigate the Linux filesystem. You will
    also learn how the Linux filesystem is structured. If we print out the folder
    structure of the top-level directories beneath the root directory by executing
    the `tree -d -L 1 /` command, you will see a list of strange-sounding directory
    names. These directory names are the same on any Linux distribution and they follow
    a standard called the **filesystem hierarchy standard** (**FHS**). Each of these
    standard directories in the Linux filesystem has a specific purpose, and the user
    can expect certain files in certain locations, and it also means that a program
    can predict where the files are located, and it also means that any program working
    with those system directories can predict where the files are located. The following
    are the directories:'
  prefs: []
  type: TYPE_NORMAL
- en: The `/` slash is the primary hierarchy root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/bin` contains essential commands needed for the system, for example, so that
    a user can work in recovery mode of the system when something breaks or, for example,
    executables needed when a user boots into recovery mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/boot` contains files needed for booting, such as the kernel files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev` contains the device files of the system, for example `/dev/null`, which
    we have used before. This directory is very important and you will use it a lot
    when you are working as a system administrator. It contains the system-wide configuration
    files of all your applications that you have installed on your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home` contains the user''s home directories, as we have learned in this section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib` contains the libraries essential for the binaries in `/bin` and `/sbin`,
    as we will see next. `/lib64` contains alternate format essential libraries for
    the 64-bit architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/media` contains the mount points for removable media such as CD-ROMs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mnt` contains temporarily mounted filesystems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/opt` contains optional application software packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc` contains the virtual filesystem providing process and kernel information
    as files, for example, this is where all the environment variables of the current
    sessions are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/root` contains the home directory for the `root` user. The root user''s home
    directory is not in `/home`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/run` contains runtime variable data; this is information about the running
    system since last boot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sbin` contains essential system binaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/srv` contains all the data that should be served by the system, for example,
    data and scripts for web servers or data offered by FTP servers that are running
    as services on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sys` contains information about the devices connected to the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp` contains temporary files. Every user has full access to this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr` contains the majority of all the user utilities and applications, for
    example, all the applications installed by a user go in here. It''s also called
    a **secondary hierarchy** for read-only user data; because it has a similar structure
    as the root directories, top-level directories. For example, you also have a `/usr/bin`
    directory, a /`usr/lib` directory, a `/usr/sbin` directory, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var` directory is for all the files that are expected to continually change
    during normal operation of the system, for example, log files, spool files, and
    temporary email files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's introduce the concept of Linux home directories. Every user known
    to a Linux system has their own private place in the filesystem, where they can
    manage their own data and have full access to everything, for example, creating
    directories or new files, deleting things, or changing permissions. For security
    reasons, most places in the Linux filesystem, with a few exceptions, such as the
    system `/tmp` directory, are restricted in one way or the other, and normally
    a logged-in user does not have full access to it only the `root` user has full
    access to everything. Every logged in user has the property of a current directory,
    which is the directory you're currently at. When a user logs in to the Linux system,
    their specific home directory will be set as the current directory by default,
    so they will start in this directory.
  prefs: []
  type: TYPE_NORMAL
- en: To display the name of your current directory, which means where you are at
    the moment, type `pwd`, and then press the *Enter* key. pwd stands for **print
    working directory**. This is a very useful command because when you are browsing
    directories, it is easy to get lost. A directory is a concept to structure data.
    Often, it is used to categorize all files belonging to the same project or of
    the same type, such as all configuration files. As you can see, the output of
    the `pwd` command contains a string containing slash symbols that are used to
    separate directory names, and this is also called the **directory separator symbol**.
    The leftmost slash has a special name and it is also called **root directory**.
    The last directory name of the current directory can also be seen at the shell
    prompt. In a Linux filesystem, every directory can have files in it and can contain
    further directories that are then called subdirectories. These subdirectories
    can also include files and folders and so on. The directory containing a subdirectory
    is also called the parent directory, while the subdirectory is called the **child
    directory**. Here, in our example, the home directory is the parent of the `olip`
    directory, which is also called the child directory. These type of files and folders
    can be visualized using a tree-like structure, and also this can be called a hierarchical
    filesystem because every directory in this structure has a specific position and
    some are higher in the hierarchy and others are lower. The highest directory is
    the `/` directory, or `root` directory. We need to remember to visualize this
    hierarchical tree structure. We can use the `tree` command, which we need to install,
    because it is not available in the standard installation. To install it, use your
    `root` password that you set up during installation.
  prefs: []
  type: TYPE_NORMAL
- en: After installing, you can use the `tree` command to get a first overview of
    your system. At the top level we have the `/` directory, which is the highest
    directory in the tree. Directly beneath it we have a number of system directories.
    When we customize the `tree` command to show us two levels of directories in the
    tree by executing `tree -d -L 2 / | less`, we can see where the home directory
    in the tree is and how we can get to it from the root directory, which is the
    parent of all the other directories. Now, to create a new directory in your home
    directory, you can use the `mkdir` command. The `mkdir` command takes the name
    of the folder you want to create as an argument. To remove an empty directory,
    use the `mrdir` command. To create a new empty file, use the `touch` command.
    To remove a file, use the `rm` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s recreate the folder and the filename again. To change to a directory,
    you can use the `cd` command, which stands for **change directory**. The change
    directory command will change your current directory to the new directory, which
    you used as an argument for the `cd` command. Use `pwd` to test this again. The
    following screenshot illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a6673ed-e287-4ee1-b983-90c48f5d9f2a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Linux, when we say to go to a directory, what we really mean is to make
    another directory our current one by using the `cd` command. As mentioned before,
    every directory contains two special shorthand links that you can''t change and
    you can''t remove, the `.` and the `..`, which is the name of the directory we
    are currently in. Every directory contains the name `..`, which is the name of
    the unique parent directory of the directory in which we are currently in. Also,
    every subdirectory contains exactly one parent directory, while one parent directory
    can contain multiple subdirectories. These dots are very useful for traveling
    through directories fast. To go back to the preceding directory, which in our
    case is the home directory, we can use the `..` notation. To create a subdirectory
    in a subdirectory in a subdirectory, we can use the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/488b4c86-b24f-4c5d-b8dc-7122f94ed5d0.png)'
  prefs: []
  type: TYPE_IMG
- en: To view the folder structure that we have just created, we can use the `pwd`
    command again. To go up one directory level, we can use `cd..`. To go back down,
    use `cd FolderD`. Now, to go up two levels of directories, you can use the folder
    separator slash symbol-`cd ../ ../`. To go back two levels in our subdirectory
    structure, we can also use the folder separator slash symbol as well. When traversing
    directories there are always many ways to do this. To go back to the home directory
    quickly, we can use several different ways. To go back to the home directory first,
    you can use some shortcuts. As we have mentioned before, the tilde symbol stands
    for the home directory, so we can easily go back to the home directory `cd ~`.
    The tilde symbol works from everywhere, so you can go back to your home directory
    from any directory you are at. Also, a very helpful shortcut is `cd -`, which
    lets you toggle between the current directory and the directory you were at before.
  prefs: []
  type: TYPE_NORMAL
- en: There even exists a shorter way to go back to your home directory from every
    location, using only the `cd` command without any arguments. Another way to go
    to your home directory from every location is to use the path outputted from the
    `pwd` command directly. In order to delete a directory structure that contains
    subdirectories or files, you cannot use the `rmdir` command. To delete a directory
    subtree that contains files and directories, instead, we need to use the `rm -rf`
    option, but please use it with caution as this will delete everything without
    asking, which is completely irreversible.
  prefs: []
  type: TYPE_NORMAL
- en: To recreate the same subdirectory structure, as we showed you before in a much
    simpler form we can use the directory separator symbol with the `mkdir -p` option.
    So far, all our operations and actions on files and folders, such as `ls`, `mkdir`,
    or `mrdir`, were always in relation to the current directory, which means the
    description on how to go to the directory or file of choice was always in relation
    to the current directory. For example, we used commands to work with files and
    directories that are within our current directory. For referencing files and folders
    outside of our current directory, we use the `..` and a slash directory separator.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to work on files and directories in the same directory, we just
    need the name of the resource. If we want to access a resource outside of our
    current directory, we can do this using the directory separator and the `..` notation
    to travel to the right file or directory. Now, let''s again execute the `pwd`
    command. The output of the `pwd` command is called **absolute** or **full path**.
    An absolute path is easily recognized from the leading forward slash, which is
    called the root directory, as you now know. The slash symbol means that you start
    at the top-level directory, or root directory, and continue down. An absolute
    path is literally a path of names throughout the hierarchy. A pathname specifies
    and describes how to traverse or navigate the hierarchical directory names in
    the filesystem to reach some destination object starting from the highest root
    directory, which can be a file or directory. The full path always contains complete
    information on how to go from the root directory to any destination in the filesystem.
    In other words, to go to the current directory, which is called `/home/olip/FolderA`,
    you have to traverse, from the `/root` directory, to the `home` directory, to
    the `olip` directory, and to the `FolderA` directory. To visualize this in a tree-like
    structure, use the `tree` command with the subdirectory **L 3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e2770f4-c1a2-495b-9fcc-06529fc4a948.png)'
  prefs: []
  type: TYPE_IMG
- en: It's important to remember that the absolute path works from everywhere. A relative
    path doesn't have a preceding slash. Using a relative path, for example, changing
    to `FolderA`, is always dependent on where you are at the moment in the filesystem.
    So, `cd FolderA` only works in your current position. If you re-execute the command
    somewhere else, it doesn't work. When using any Linux command that works with
    files or directories, you always have the option to either use a local path relative
    to your current directory, or to use the full and absolute path relative to the
    root directory. Oftentimes, the relative path is faster to use and often it is
    also convenient to change to the directory of the files you want to work with
    directly. But the absolute path is important for scripts or if a command needs
    to work from every directory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started off with an introduction to the command line, file
    globbing, and quoting commands. We progressed towards practical execution by working
    with the shell, standard streams, and regular expressions. We also covered functionalities
    of `sed`, `awk`, and the Linux filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover concepts pertaining to files.
  prefs: []
  type: TYPE_NORMAL
