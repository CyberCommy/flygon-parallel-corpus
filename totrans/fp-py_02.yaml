- en: Chapter 2. Introducing Some Functional Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the features of functional programming are already first-class parts
    of Python. Our goal in writing functional Python is to shift our focus away from
    imperative (procedural or object-oriented) techniques to the maximum extent possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at each of the following functional programming topics:'
  prefs: []
  type: TYPE_NORMAL
- en: First-class and higher-order functions, which are also known as pure functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable Data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strict and non-strict evaluation. We can also call this eager vs. lazy evaluation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion instead of an explicit loop state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional type systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should reiterate some concepts from the first chapter. Firstly, that purely
    functional programming avoids the complexities of explicit state maintained via
    variable assignment. Secondly, that Python is not a purely functional language.
  prefs: []
  type: TYPE_NORMAL
- en: We don't offer a rigorous definition of functional programming. Instead, we'll
    locate some common features that are indisputably important. We'll steer clear
    of the blurry edges.
  prefs: []
  type: TYPE_NORMAL
- en: First-class functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is often succinct and expressive. One way to achieve
    this is by providing functions as arguments and return values for other functions.
    We'll look at numerous examples of manipulating functions.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, functions must be first-class objects in the runtime environment.
    In programming languages such as C, a function is not a runtime object. In Python,
    however, functions are objects that are created (usually) by the `def` statements
    and can be manipulated by other Python functions. We can also create a function
    as a callable object or by assigning `lambda` to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how a function definition creates an object with attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We've created an object, `example`, that is of class `function()`. This object
    has numerous attributes. The `__code__` object associated with the function object
    has attributes of its own. The implementation details aren't important. What is
    important is that functions are first-class objects, and can be manipulated just
    like all other objects. We previously displayed the values of two of the many
    attributes of a function object.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be expressive, a function used in a functional programming design will be
    free from the confusion created by side effects. Using pure functions can also
    allow some optimizations by changing evaluation order. The big win, however, stems
    from pure functions being conceptually simpler and much easier to test.
  prefs: []
  type: TYPE_NORMAL
- en: To write a pure function in Python, we have to write local-only code. This means
    we have to avoid the `global` statements. We need to look closely at any use of
    `nonlocal`; while it is a side effect in another scope, it's confined to a `nested`
    function definition. This is an easy standard to meet. Pure functions are a common
    feature of Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: There isn't a trivial way to guarantee a Python function is free from side effects.
    It is easy to carelessly break the pure function rule. If we ever want to worry
    about our ability to follow this rule, we could write a function that uses the
    `dis` module to scan a given function's `__code__.co_code` compiled code for global
    references. It could report on use of internal closures, and the `__code__.co_freevars`
    `tuple` method as well. This is a rather complex solution to a rare problem; we
    won't pursue it further.
  prefs: []
  type: TYPE_NORMAL
- en: A Python `lambda` is a pure function. While this isn't a highly recommended
    style, it's certainly possible to create pure functions via `lambda` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a function created by assigning `lambda` to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We created a pure function using `lambda` and assigned this to the variable
    `mersenne`. This is a callable object with a single argument value that returns
    a single value. Because lambda's can't have assignment statements, they're always
    pure functions and suitable for functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can achieve expressive, succinct programs using higher-order functions. These
    are functions that accept a function as an argument or return a function as a
    value. We can use higher-order functions as a way to create composite functions
    from simpler functions.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the Python `max()` function. We can provide a function as an argument
    and modify how the `max()` function behaves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some data we might want to process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the `max()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The default behavior is to simply compare each `tuple` in the sequence. This
    will return the `tuple` with the largest value on position 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `max()` function is a higher-order function, we can provide another
    function as an argument. In this case, we''ll use `lambda` as the function; this
    is used by the `max()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `max()` function applies the supplied `lambda` and returns
    the tuple with the largest value in position 1.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides a rich collection of higher-order functions. We'll see examples
    of each of Python's higher-order functions in later chapters, primarily in [Chapter
    5](ch05.html "Chapter 5. Higher-order Functions"), *Higher-order Functions.* We'll
    also see how we can easily write our own higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we're not using variables to track the state of a computation, our focus
    needs to stay on immutable objects. We can make extensive use of `tuples` and
    `namedtuples` to provide more complex data structures that are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of immutable objects is not foreign to Python. There can be a performance
    advantage to using immutable `tuples` instead of more complex mutable objects.
    In some cases, the benefits come from rethinking the algorithm to avoid the costs
    of object mutation.
  prefs: []
  type: TYPE_NORMAL
- en: We will avoid class definitions (almost) entirely. It can seem like it's anathema
    to avoid objects in an **Object**-**Oriented** **Programming** (**OOP**) language.
    Functional programming simply doesn't need stateful objects. We'll see this throughout
    this book. There are reasons for defining `callable` objects; it is a tidy way
    to provide `namespace` for closely-related functions, and it supports a pleasant
    level of configurability.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at a common design pattern that works well with immutable objects:
    the `wrapper()` function. A list of tuples is a fairly common data structure.
    We will often process this list of tuples in one of the two following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using** **Higher-order Functions**: As shown earlier, we provided `lambda`
    as an argument to the `max()` function: `max(year_cheese, key=lambda yc: yc[1])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the Wrap-Process-Unwrap pattern**: In a functional context, we should
    call this the `unwrap(process(wrap(structure)))` pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, look at the following command snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This fits the three-part pattern, although it might not be obvious how well
    it fits.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we wrap, using `map(lambda yc: (yc[1],yc), year_cheese)`. This will
    transform each item into a two tuple with a key followed by the original item.
    In this example, the comparison key is merely `yc[1]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, do the processing using the `max()` function. Since each piece of data
    has been simplified to a two tuple with position zero used for comparison, we
    don't really need the higher-order function feature of the `max()` function. The
    default behavior of the `max()` function is exactly what we require.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we unwrap using the subscript `[1]`. This will pick the second element
    of the two tuple selected by the `max()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of `wrap` and `unwrap` is so common that some languages have special
    functions with names like `fst()` and `snd()` that we can use as a function prefix
    instead of a syntactic suffix of `[0]` or `[1]`. We can use this idea to modify
    our wrap-process-unwrap example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We defined a `snd()` function to pick the second item from a `tuple`. This provides
    us with an easier-to-read version of `unwrap(process(wrap()))`. We used `map(lambda...
    , year_cheese)` to `wrap` our raw data items. We used `max()` function as the
    processing and, finally, the `snd()` function to extract the second item from
    the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](ch13.html "Chapter 13. Conditional Expressions and the Operator
    Module"), *Conditional Expressions and the Operator Module*, we'll look at some
    alternatives to `lambda` functions like `fst()` and `snd()`.
  prefs: []
  type: TYPE_NORMAL
- en: Strict and non-strict evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming's efficiency stems, in part, from being able to defer
    a computation until it's required. The idea of lazy or non-strict evaluation is
    very helpful. It's so helpful that Python already offers this feature.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the logical expression operators `and`, `or`, and `if-then-else`
    are all non-strict. We sometimes call them *short-circuit* operators because they
    don't need to evaluate all arguments to determine the resulting value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command snippet shows the `and` operator''s non-strict feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When we execute the preceding command snippet, the left-hand side of the `and`
    operator is equivalent to `False`; the right-hand side is not evaluated. When
    the left-hand side is equivalent to `True`, the right-hand side is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Other parts of Python are strict. Outside the logical operators, an expression
    is evaluated eagerly from left-to-right. A sequence of statement lines is also
    evaluated strictly in order. `Literal` lists and `tuples` require eager evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: When a class is created, the method functions are defined in a strict order.
    In the case of a class definition, the method functions are collected into a dictionary
    (by default) and order is not maintained after they're created. If we provide
    two methods with the same name, the second one is retained because of the strict
    evaluation order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s generator expressions and generator functions, however, are lazy.
    These expressions don''t create all possible results immediately. It''s difficult
    to see this without explicitly logging the details of a calculation. Here is an
    example of the version of the `range()` function that has the side effect of showing
    the numbers it creates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If this function were eager, it would create all 1,024 numbers. Since it's lazy,
    it only creates numbers as requested.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The older Python 2 `range()` function was eager and created an actual list of
    object with all of the requested numbers. Python 2 has an `xrange()` function
    that is lazy and matches the semantics of the Python 3 `range()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this noisy `numbers()` function in a way that will show lazy evaluation.
    We''ll write a function that evaluates some, but not all, of the values from this
    iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sum_to()` function will not evaluate the entire result of the `numbers()`
    function. It will break after only consuming a few values from the `numbers()`
    function. We can see this consumption of values in the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we'll see later, Python generator functions have some properties that make
    them a little awkward for simple functional programming. Specifically, a generator
    can only be used once in Python. We have to be cautious how we use the lazy Python
    generator expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion instead of a explicit loop state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programs don't rely on `loops` and the associated overhead of tracking
    the state of loops. Instead, functional programs try to rely on the much simpler
    approach of recursive functions. In some languages, the programs are written as
    recursions, but **Tail**-**Call** **Optimization** (**TCO**) by the compiler changes
    them to `loops`. We'll introduce some recursion here and examine it closely in
    [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"), *Recursions and
    Reductions*.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at a simple iteration to test a number for being prime. A prime number
    is a natural number, evenly divisible by only 1 and itself. We can create a naïve
    and poorly performing algorithm to determine if a number has any factors between
    two and the number. This algorithm has the advantage of simplicity; it works acceptably
    for solving **Project Euler** problems. Read up on **Miller**-**Rabin** primality
    tests for a much better algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the term `coprime` to mean that two numbers have only 1 as their common
    factor. The numbers 2 and 3, for example, are `coprime`. The numbers 6 and 9,
    however, are not `coprime` because they have 3 as a common factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to know if a number, *n*, is prime, we actually ask this: is the
    number *n* `coprime` to all prime numbers, *p*, such that ![Recursion instead
    of a explicit loop state](graphics/B03652_02_03.jpg). We can simplify this using
    all integers, *p*, such that ![Recursion instead of a explicit loop state](graphics/B03652_02_05.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it helps to formalize this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recursion instead of a explicit loop state](graphics/B03652_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The expression could look as follows in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A more direct conversion from mathematical formalism to Python would use `all(n%p
    != 0... )` but that requires strict evaluation of all values of *p*. The *not
    any* version can terminate early if a `True` value is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple expression has a `for` loop inside it: it''s not a pure example
    of stateless functional programming. We can reframe this into a function that
    works with a collection of values. We can ask whether the number, *n*, is `coprime`
    within any value in the range ![Recursion instead of a explicit loop state](graphics/B03652_02_07.jpg)?".
    This uses the symbols, `[)`, to show a half-open interval: the lower values are
    included, and the upper value is not included. This is typical behavior of the
    Python `range()` function. We will also restrict ourselves to the domain of natural
    numbers. The square root values, for example, are implicitly truncated to `integers`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of the definition of prime as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recursion instead of a explicit loop state](graphics/B03652_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When defining a recursive function over a simple range of values, the base
    case can be an empty range. A nonempty range is handled recursively by processing
    one value combined with a range that''s narrower by one value. We might formalize
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recursion instead of a explicit loop state](graphics/B03652_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This version is relatively easy to confirm by examining the two cases, which
    are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the range is empty, ![Recursion instead of a explicit loop state](graphics/B03652_02_12.jpg),
    we evaluate something like:![Recursion instead of a explicit loop state](graphics/B03652_02_14.jpg).
    The range contains no values, so the return is a trivial `True`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the range is not empty, we ask something like ![Recursion instead of a explicit
    loop state](graphics/B03652_02_16.jpg). This decomposes into ![Recursion instead
    of a explicit loop state](graphics/B03652_02_18.jpg). For this example, we can
    see that the first clause is `True`, and we'll evaluate the second clause recursively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an exercise for the reader: this recursion can be redefined to count down
    instead of up, using `[a,b-1)` in the second case.'
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, some folks like to think of the empty interval as *a* ≥ *b*,
    not *a*=*b*. This is needless, since *a* is incremented by 1 and we can easily
    guarantee that *a*≤*b*, initially. There's no way for *a* to somehow leap past
    *b* by some error in the function; we don't need to over-specify the rules for
    an empty interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a Python code snippet that implements this definition of prime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This shows a recursive definition of an `isprime()` function. The half-open
    interval ![Recursion instead of a explicit loop state](graphics/B03652_02_07.jpg)
    is reduced to just the low-end argument, *a*, which is renamed `coprime` in this
    function to clarify its purpose. The base case is implemented as `n < coprime*coprime`;
    the range of values from `coprime` to `1+math.sqrt(n)` would be empty.
  prefs: []
  type: TYPE_NORMAL
- en: The non-strict `and` operation is implemented by splitting it out into a separate
    `if` statement, `if n % coprime == 0`. The `return` statement is the recursive
    call with a different `coprime` test value.
  prefs: []
  type: TYPE_NORMAL
- en: Because the recursion is the tail end of the function, this is an example of
    **Tail recursion**.
  prefs: []
  type: TYPE_NORMAL
- en: This function is embedded in a function that establishes the boundary condition
    that *n* is an odd number greater than 2\. There's no point in testing any even
    number for being prime, since 2 is the only even prime.
  prefs: []
  type: TYPE_NORMAL
- en: What's important in this example is that the two cases of this recursive function
    are quite simple to design. Making the range of values an explicit argument to
    the internal `isprime()` function allows us to call the function recursively with
    argument values that reflect a steadily shrinking interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is often extremely succinct and very expressive, we have to be a
    little cautious about using recursion in Python. There are two problems that arise.
    They are stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Python imposes a recursion limit to detect recursive functions with improperly
    defined base cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python does have a compiler to do Tail-Call Optimization (TCO)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default recursion limit is 1,000, which is adequate for many algorithms.
    It's possible to change this with the `sys.setrecursionlimit()` function. It's
    not wise to raise this arbitrarily since it might lead to exceeding the OS memory
    limitations and crashing the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: If we try a recursive `isprimer()` function on a number over 1,000,000, we'll
    run foul of the recursion limit. If we used a somehow smarter `isprimer()` function
    that only checked prime factors instead of all factors, we'd be stopped at the
    1,000th prime number, 7,919, limiting our prime testing to numbers below 62,710,561.
  prefs: []
  type: TYPE_NORMAL
- en: Some functional programming languages can optimize simple recursive functions
    such as our `isprimer()` function. An optimizing compiler can transform the recursive
    evaluation of the `isprimer(n, coprime+1)` method into a low-overhead `loop`.
    The optimization tends to make a hash of call stacks; debugging optimized programs
    becomes difficult. Python doesn't perform this optimization. Performance and memory
    are sacrificed for clarity and simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, when we use a generator expression instead of a recursive function,
    we essentially do the tail-call optimization manually. We don't rely on a compiler
    for some functional language to do this optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is TCO done as a generator expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This function includes many of the functional programming principles, but it
    uses a generator expression instead of a pure recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll often optimize a purely recursive function to use an explicit `for` `loop`
    in a generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is slow for large primes. For composite numbers, the function
    often returns a value quickly. If used on a value such as ![Recursion instead
    of a explicit loop state](graphics/B03652_02_21.jpg), it will take a few minutes
    to show that this is prime. Clearly, the slowness comes from checking 1,518,500,249
    individual candidate factors.
  prefs: []
  type: TYPE_NORMAL
- en: Functional type systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some functional programming languages such as **Haskell** and **Scala** are
    statically compiled, and depend on declared types for functions and their arguments.
    In order to provide the kind of flexibility Python already has, these languages
    have sophisticated type matching rules so that a generic function can be written,
    which works for a variety of related types.
  prefs: []
  type: TYPE_NORMAL
- en: In Object-Oriented Python, we often use the class inheritance hierarchy instead
    of sophisticated function type matching. We rely on Python to dispatch an operator
    to a proper method based on simple name matching rules.
  prefs: []
  type: TYPE_NORMAL
- en: Since Python already has the desired levels of flexibility, the type matching
    rules for a compiled functional language aren't relevant. Indeed, we could argue
    that the sophisticated type matching is a workaround imposed by static compilation.
    Python doesn't need this workaround because it's a dynamic language.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we might have to resort to using `isinstance(a, tuple)` to detect
    if an argument value is `tuple` or an individual value. This will be as rare in
    functional programs as it is in Object-Oriented Programs.
  prefs: []
  type: TYPE_NORMAL
- en: Familiar territory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the ideas that emerge from the previous list of topics is that most functional
    programming is already present in Python. Indeed, most functional programming
    is already a very typical and common part of Object-Oriented Programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a very specific example, a fluent **Application Program Interface** (**API**)
    is a very clear example of functional programming. If we take time to create a
    class with `return self()` in each method function, we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can just as easily write several closely-related functions that work as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've switched the syntax from traditional object-oriented suffix notation to
    a more functional prefix notation. Python uses both notations freely, often using
    a prefix version of a special method name. For example, the `len()` function is
    generally implemented by the class.`__len__()` special method.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the implementation of the class shown above might involve a highly
    stateful object. Even then, a small change in viewpoint might reveal a functional
    approach that can lead to more succinct or more expressive programming.
  prefs: []
  type: TYPE_NORMAL
- en: The point is not that imperative programming is broken in some way, or that
    functional programming offers such a vastly superior technology. The point is
    that functional programming leads to a change in viewpoint that can—in many cases—be
    very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Saving some advanced concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will set some more advanced concepts aside for consideration in later chapters.
    These concepts are part of the implementation of a purely functional language.
    Since Python isn't purely functional, our hybrid approach won't require deep consideration
    of these topics.
  prefs: []
  type: TYPE_NORMAL
- en: We will identify these up-front for the benefit of folks who already know a
    functional language such as Haskell and are learning Python. The underlying concerns
    are present in all programming languages but we'll tackle them differently in
    Python. In many cases, we can and will drop into imperative programming rather
    than use a strictly functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Referential** **transparency**: When looking at lazy evaluation and the various
    kinds of optimization that are possible in a compiled language, the idea of multiple
    routes to the same object is important. In Python, this isn''t as important because
    there aren''t any relevant compile-time optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Currying**: The type systems will employ currying to reduce multiple-argument
    functions to single-argument functions. We''ll look at currying in some depth
    in [Chapter 11](ch11.html "Chapter 11. Decorator Design Techniques"), *Decorator
    Design Techniques*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monads**: These are purely functional constructs that allow us to structure
    a sequential pipeline of processing in a flexible way. In some cases, we''ll resort
    to imperative Python to achieve the same end. We''ll also leverage the elegant
    `PyMonad` library for this. We''ll defer this to [Chapter 14](ch14.html "Chapter 14. The
    PyMonad Library"), *The PyMonad Library*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've identified a number of features that characterize the
    functional programming paradigm. We started with first-class and higher-order
    functions. The idea is that a function can be an argument to a function or the
    result of a function. When functions become the object of additional programming,
    we can write some extremely flexible and generic algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of immutable data is sometimes odd in an imperative and object-oriented
    programming language such as Python. When we start to focus on functional programming,
    however, we see a number of ways that state changes can be confusing or unhelpful.
    Using immutable objects can be a helpful simplification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python focuses on strict evaluation: all sub-expressions are evaluated from
    left-to-right through the statement. Python, however, does perform some non-strict
    evaluation. The `or`, `and`, and `if-else` logical operators are non-strict: all
    subexpressions are not necessarily evaluated. Similarly, a generator function
    is also non-strict. We can also call this eager vs. lazy. Python is generally
    eager but we can leverage generator functions to create lazy evaluation.'
  prefs: []
  type: TYPE_NORMAL
- en: While functional programming relies on recursion instead of explicit `loop`
    state, Python imposes some limitations here. Because of the stack limitation and
    the lack of an optimizing compiler, we're forced to manually optimize recursive
    functions. We'll return to this topic in [Chapter 6](ch06.html "Chapter 6. Recursions
    and Reductions"), *Recursions and Reductions*.
  prefs: []
  type: TYPE_NORMAL
- en: Although many functional languages have sophisticated type systems, we'll rely
    on Python's dynamic type resolution. In some cases, it means we'll have to write
    manual coercion among types. It might also mean that we'll have to create class
    definitions to handle very complex situations. For the most part, however, Python's
    built-in rules will work very elegantly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at the core concepts of pure functions and how
    these fit with Python's built-in data structures. Given this foundation, we can
    look at higher-order functions available in Python and how we can define our own
    higher-order functions.
  prefs: []
  type: TYPE_NORMAL
