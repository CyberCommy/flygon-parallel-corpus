- en: Implementing Properties and Events in Our Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have had the opportunity to take a bird's eye overview of what components
    are in the new Angular ecosystem, what their role is, how they behave, and what
    tools are required to start building our own components to represent widgets and
    pieces of functionality. In addition, TypeScript turns out to be the perfect companion
    for this endeavor, so we seem to have everything that we need to further explore
    the possibilities that Angular brings to the game with regards to creating interactive
    components that expose properties and emit events.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Discover all the syntactic possibilities at our disposal to bind content in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: our templates
  prefs: []
  type: TYPE_NORMAL
- en: Create public APIs for our components so that we can benefit from their properties
    and event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how to implement data binding in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the complexity of CSS management with view encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A better template syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml), *Creating Our Very
    First Component in Angular*, we saw how to embed HTML templates in our components,
    but we didn't even scratch the surface of template development for Angular. As
    we will see later in this book, template implementation is tightly coupled with
    the principles of Shadow DOM design and it brings out a lot of syntactic sugar
    to ease the task of binding properties and events in our views in a declarative
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, Angular components may expose a public API that allows them to
    communicate with other components or containers. This API may encompass input
    properties, which we use to feed the component with data. It also may expose output
    properties we can bind event listeners to, thereby getting prompt information
    about changes in the state of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the way Angular solves the problem of injecting data in
    and out of our components through quick and easy examples. Please focus on the
    philosophy behind these properties. We will have a chance to see them in action
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Data bindings with input properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's revisit the timer component functionality that we already saw in [Chapter
    1](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml),
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating Our Very First Component in Angular*, and let''s imagine that we
    want our component to have a configurable attribute so that we can increase or
    decrease the countdown time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Please note the attribute wrapped between brackets. This informs Angular that
    this is an input property. The class that models the `timer` component will contain
    a setter function for the `seconds` property, which will react to changes in that
    value by updating its own countdown duration. We can inject a data variable or
    an actual hardcoded value, in which case we will have to wrap it around single
    quotes within the double quotes should such a value be a text string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we will see this syntax while injecting data into our component''s
    custom properties, while at other times we will use this very bracket syntax to
    make native HTML attributes reactive to component fields, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Some extra syntactic sugar when binding expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Angular team has made some shortcuts available for performing common transformations
    in our component directives and DOM elements, such as tweaking attributes and
    class names or applying styles. Here, we have some examples of great time-savers
    when declaratively defining bindings in our properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, `div` will enable the hidden attribute should the`isHidden`expression
    evaluate to `true`. Besides Boolean values, we can bind any other data type, such
    as a string value. In the second case, the `is-valid` class name will be injected
    in the class attribute if the `isValid` expression evaluates to `true`. In our
    third example, `div` will feature a style attribute that shows off a `width` property
    meant to be set with the value of the `myWidth` expressions in pixels. You can
    find more examples of this syntactic sugar in the Angular cheat sheet ([https://angular.io/guide/cheatsheet](https://angular.io/cheatsheet))
    available at the official Angular site.
  prefs: []
  type: TYPE_NORMAL
- en: Event binding with output properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine we want our timer component to notify us when the countdown
    is finished so that we can perform other actions outside the realm of the component.
    We can achieve such functionality with an output property like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note the attribute wrapped between braces. This informs Angular that such an
    attribute is, in fact, an output property that will trigger the event handler
    we bind to it. In this case, we will want to create an `onCountownCompleted` event
    handler on the container object that wraps this component.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, the camel case is not a coincidence. It is a naming convention applied
    to all output and input property names in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will find output properties mapped to interaction events that we already
    know, such as `click`, `mouseover`, `mouseout`, `focus`, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Input and output properties in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to grasp the concepts detailed in the earlier sections is by practice.
    In the first chapter, we learned how to build an application from scratch by using
    either Webpack or Angular-CLI to set up the project. As Angular-CLI is considered
    the standard way of setting up the project, let''s use just that and scaffold
    ourselves a new project by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have a fully working project that we can easily serve up by
    typing `ng serve`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly remind ourselves of the anatomy of an Angular project so we
    know what to do with all the new constructs we are about to create. The following
    files are of extra interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.ts`: This file bootstraps our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app/app.module.ts`: This file declares our root module, any new constructs
    will have to be added to the declarations property of this module or you will
    need to add a dedicated module for those future constructs. It is generally recommended
    to have a dedicated module for new constructs we have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous bullet list, we mentioned the concept *root module*. We mentioned
    this concept to remind ourselves of Angular modules in general. An Angular module
    holds a bunch of constructs that belong together. You will recognize an Angular
    module by using the `@NgModule`decorator; the module itself is just a plain class.
    The `@NgModule` decorator takes an object literal as input and it is within this
    object literal that we register everything that belongs to the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in the preceding bullet list, it is considered good practice to
    add a dedicated module for our new constructs, so let''s do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we are leaving the `declarations`property array empty. Once we
    have declared our component, we will add it to that array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This module doesn''t belong to the application just yet, but it will need to
    be registered with the root module. Open up the `app.module.ts` file and add the
    newly created module to the `import` array, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s strip down the timer example that we saw in [Chapter 1](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml),
    *Creating Our Very First Component in Angular*, and discuss a simpler example.
    Let''s have a look at the `TimerComponent` file and replace its contents with
    the following component class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Great! We have just defined a simple but highly effective countdown timer component
    that will count down to 0 from 25 seconds (do you see the `seconds` field up there?
    TypeScript supports the initialisation of members upon declaring them). A simple `setInterval()` loop
    executes a custom private function named `tick()` that decreases the value of
    seconds until it reaches zero, in which case we just clear the interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, now we just need to embed this component somewhere, so let''s create
    another component with no functionality other than acting as an HTML wrapper host
    for the previous component. Create this new component right after the `CountdownTimerComponent` class
    in the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As promised earlier, we will also add our newly created components to the `declarations` array
    of the module it belongs to, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The reason for doing this in the first place is to ensure that these components
    are made available for one another, as is the case with `CountdownTimerComponent`being
    used inside the template of `TimerComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Components in Angular are basically directives with a view template. We can
    also find directives with no view, which basically add new functionalities to
    their host element, or they just act as custom elements without a UI that wraps
    other elements. Alternatively, they simply provide further functionalities to
    other components by means of their API.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore directives in detail in the next chapter and also throughout
    the book. You must be wondering why we have created this host or parent `TimerComponent ` component
    with no implementation. Soon, we will flesh it out with some more features, but
    for now let's use it as a proof of concept for how to initiate a component tree.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up custom values declaratively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will probably agree on the fact that having the functionality of setting
    up custom countdown timers would be nice, right? Input properties turn out to
    be an excellent way to achieve this. In order to leverage this functionality,
    we will have to tweak the `import` statement at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You might have already noticed that we are no longer initializing the `seconds`field,
    and it is now decorated with a property decorator (as we saw in [Chapter 3](9b3ddd80-6ddf-43e5-92d7-a9260c11ff6d.xhtml),
    *Introducing TypeScript*). We have just started to define the API of our component.
  prefs: []
  type: TYPE_NORMAL
- en: Property naming is case sensitive. The convention enforced by Angular is to
    apply camel case to component input and, as we will see shortly, output properties
    alike.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we just need to add the desired property in our container component''s
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we have not updated the `TimerComponent` at all. We only updated
    its `CountdownComponent` child component. However, its brand new API becomes available
    to any component that eventually includes it in its own template as a child component,
    so we can set up its properties declaratively right from the template, or even
    bind a value imperatively from a property located in the `TimerComponent` controller
    class if we wish.
  prefs: []
  type: TYPE_NORMAL
- en: When flagging a class property with `@Input()`, we can configure the name we
    want this property to have upon instantiating the component in the HTML. To do
    so, we just need to introduce our name of choice in the decorator signature, like
    this: `@Input('name_of_the_property')`. In any event, this practice is discouraged
    since exposing property names in the component API distinct from the ones defined
    in its controller class can only lead to confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating between components through custom events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our child component is being configured by its parent component, how
  prefs: []
  type: TYPE_NORMAL
- en: can we achieve communication from the child to the parent? This is where custom
    events come to the rescue! In order to create proper event bindings, we just need to
    configure an output property in our component and attach an event handler function
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to trigger custom events, we will need to bring `EventEmitter` to
    the party, along with the `@Output` decorator, whose functionality is exactly
    the opposite to what we learned regarding the `@Input` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`EventEmitter` is the built-in event bus of Angular. In a nutshell, the `EventEmitter` class
    provides support for emitting `Observable` data and subscribing `Observer` consumers
    to data changes. Its simple interface, which basically encompass two methods, `emit()` and `subscribe()`,
    can therefore be used to trigger custom events and listen to events as well, both
    synchronously and asynchronously. We will discuss Observables in more detail in
    [Chapter 7](113fea8a-41c0-4884-95ad-ac95ee0c4c65.xhtml), *Asynchronous Data Services
    with Angular*. For the time being, we can get away with the idea that we will
    be using the `EventEmitter` API to spawn events that listener methods in the components
    hosting our event-emitting component can observe and attach event handlers to.
    These events acquire visibility outside the scope of the component through any
    of its properties annotated with the `@Input()` decorator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an actual implementation that follows up from the
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A new property named `complete` is conveniently annotated with the`EventEmitter` type
    and initialized on the spot. Later on, we will access its emit method to spawn
    a custom event as soon as the countdown ends. The `emit()` method needs one mandatory
    parameter of any type, so we can send a data value to the event subscribers (or
    null if not required).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to set up our host component so that it will listen to this
    complete event or output property and subscribe an event handler to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Why `complete`and not `onComplete`? Angular provides support for an alternative
    syntax named canonical form for both input and output properties. In the case
    of input properties, a property represented as `[seconds]`could be represented
    as `bind-seconds`, without the need for brackets. With regards to output properties,
    these can be represented as `on-complete` instead of `(complete)`. That is why
    we never prefix output property names with an `on` prefix, since that would occur
    on output properties such as`on-complete`   in case we eventually decide to favor
    the canonical syntax form in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have learned to use input data with our component. The data would live in
    the container and the component would be rendered inside of the container template.
    This means the component could suddenly gain access to the container''s data by
    us typing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And on the component side, the code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve also learned about output, that is, how to communicate back from component
    to container. To make this happen, we added another property on the component
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And on the component side, we would instead use a decorator called `Output`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And to actively invoke that bonded method, we would type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Then next thing coming up is to learn how to pass data from component to container.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting data through custom events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to emit custom events from our component API, why don't
    we take a step further and send data signals beyond the scope of the component?
    We already discussed that the `emit()` event of the `EventEmitter<T>` class accepts
    in its signature any given data of the type represented by the `T` annotation.
    Let's extend our example to notify the progress of the countdown. Why would we
    ever want to do this? Basically, our component displays onscreen a visual countdown,
    but we might want to watch the countdown progress programmatically in order to
    take action once the countdown is finished or reaches a certain point.
  prefs: []
  type: TYPE_NORMAL
- en: Let's update our timer component with another output property that matches
  prefs: []
  type: TYPE_NORMAL
- en: the original and emits a custom event on each iteration of the `seconds` property,
  prefs: []
  type: TYPE_NORMAL
- en: 'as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s rebuild our host component''s template to reflect the actual progress
    of the countdown. We already do so by displaying the countdown, but that is a
    feature handled internally by the `CountdownTimerComponent`. Now, we will keep
    track of the countdown outside this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We took advantage of this round of changes to formalize the timeout value as
    a property of the host component. This allows us to bind new values to that property
    in our custom event handlers, as we did in the preceding example. Rather than
    binding an event handler method to the (`progress`) handler, we refer to the`$event` reserved
    variable. It is a pointer to the payload of the `progress output` property that
    reflects the value we pass to the`emit()` function when executing `this.progress.emit(this.seconds)`.
    In short, `$event` is the value assumed by `this.seconds` inside`CountdownTimerComponent`.
    By assigning such a value to the `timeout` class property within the template,
    we are also updating the binding expressed in the paragraph we just inserted into
    the template. This paragraph will only become visible when `timeout` is lower
    than `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What we saw in this section was how we could send data from the component to
    the container. There are essentially two ways of doing that:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign `$event` to the container property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke the container method with `$event` as the function parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first version is what we demonstrated, that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With the component invoking it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The second version is a small rewrite of the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We would invoke it the same way in the component, but the difference would
    be that we need to declare a container method, `onProgress`, so the `timeout`
    property gets set that way instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Local references in templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have previously seen how we can bind data to our templates using data interpolation
    with the double curly braces syntax. Besides this, we will quite often spot named
    identifiers prefixed by a hash symbol (`#`) in the elements belonging to our components
    or even regular HTML controls. These reference identifiers, namely local names,
    are used to refer to the components flagged with them in our template views and
    then access them programmatically. They can also be used by components to refer
    to other elements in the virtual DOM and access its properties.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we saw how we could subscribe to the countdown progress
    through the `progress` event. But what if we could inspect the component in depth,
    or at least its public properties and methods, and read the value that the `seconds`
    property takes on each tick interval without having to listen to the `progress`
    event? Well, setting a local reference on the component itself will open the door to
    its public façade.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s flag the instance of our `CountdownTimerComponent` in the `TimerComponent`
    template with a local reference named`#counter`. From that very moment, we will
    be able to directly access the component''s public properties, such as `seconds`,
    and even bind it in other locations of the template. This way, we do not even
    need to rely on the `progress` event emitter or the `timeout` class field, and
    we can even manipulate the value of such properties. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Alternative syntax for input and output properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the `@Input()` and `@Output()` decorators, there is an alternative syntax
    where we can define `input` and `output` properties in our components by means
    of the`@Component` decorator. Its metadata implementation provides support for
    both features through the `inputs` and `outputs` property names, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CountdownTimerComponent` API could therefore be implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: All in all, this syntax is discouraged and has been included here for reference
    purposes only. In the first place, we duplicate code by defining the names of
    our API endpoints in two places at the same time, increasing the risk of errors
    when refactoring code. It is also a common convention to keep the decorator implementations
    as lean as possible in order to improve readability.
  prefs: []
  type: TYPE_NORMAL
- en: I strongly suggest that you stick to the `@Input` and `@Output` decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our template from our component class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The component metadata also supports several settings that contribute to easy
    template management and configuration. On the other hand, Angular takes advantage
    of the CSS encapsulation functionalities of web components.
  prefs: []
  type: TYPE_NORMAL
- en: Internal and external templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our applications grow in size and complexity, chances are that our templates
    will grow as well, hosting other components and bigger chunks of HTML code. Embedding
    all this code in our component class definitions will become a cumbersome and
    unpleasant task and it will also be quite prone to errors. In order to prevent
    this from happening, we can leverage the `templateUrl` property, pointing to a
    standalone HTML file that contains our component HTML markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our previous example, we can refactor the `@Component` decorator of
    our `TimerComponent` class to point to an external HTML file containing our template.
    Create a new file named `timer.component.html` in the workspace where our `timer.component.ts`
    file lives and populate it with the same HTML we configured in our`TimerComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can polish our `@Component` decorator to point to that file instead
    of defining the HTML inside the decorator metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: External templates follow a certain convention in Angular, enforced by the most
    popular Angular coding style guide out there, which is to share the same filename
    as the component they belong to, including any filename prefix or suffix we might
    append to the component filename. We will see this when exploring component naming
    conventions in [Chapter 6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml), *Building
    an Application with Angular Components*. This way, it is easier to recognize,
    or even search with your IDE's search built-in fuzzy finder tool, which HTML file
    is in fact the template of a specific component.
  prefs: []
  type: TYPE_NORMAL
- en: What is the threshold for creating standalone templates rather than keeping
    the template markup inside the component? It depends on the complexity and size
    of the template. Common sense will be your best advisor in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating CSS styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to better encapsulate our code and make it more reusable, we can define
    CSS styling within our components. These internal style sheets are a good way
    to make our components more shareable and maintainable. There are three different
    ways of defining CSS styling for our components.
  prefs: []
  type: TYPE_NORMAL
- en: The styles property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can define `styles` for our HTML elements and class names through the `styles` property
    in the component decorator, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This property will take an array of strings, each containing CSS rules, and
    apply them to the template markup by embedding those rules at the head of the
    document as soon as we bootstrap our application. We can either inline the styling
    rules in a single line, or take advantage of ES2015 template strings to indent
    the code and make it more readable, as depicted in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: The styleUrls property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like `styles`, `styleUrls` will accept an array of strings, although each
    one will represent a link to an external style sheet though. This property can
    be used alongside the `styles` property as well, defining different sets of rules
    where required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Inline style sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also attach the styling rules to the template itself, no matter whether
    it''s an inline template or a template served through the `templateUrl` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Managing view encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the preceding sections (`styles`, `styleUrls`, and inline style sheets)
    will be governed by the usual rules of CSS specificity ([https://developer.mozilla.org/en/docs/Web/CSS/Specificity](https://developer.mozilla.org/en/docs/Web/CSS/Specificity)).
    CSS management and specificity becomes a breeze on browsers that support Shadow
    DOM, thanks to scoped styling. CSS styles apply to the elements contained in the
    component, but they do not spread beyond its boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, Angular will embed these style sheets at the head of the document,
    so they might affect other elements of our application. In order to prevent this
    from happening, we can set up different levels of view encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, encapsulation is the way Angular needs to manage CSS scoping
    within the component for both shadow DOM-compliant browsers and those that do
    not support it. For all this, we leverage the `ViewEncapsulation enum`, which
    can take any of these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Emulated**: This is the default option, and it basically entails an emulation
    of native scoping in Shadow DOM, through sandboxing the CSS rules under a specific
    selector that points to our component. This option is preferred to ensure that
    our component styles will not be affected by other existing libraries on our site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Native**: Use the native Shadow DOM encapsulation mechanism of the renderer,
    and it only works on browsers that support Shadow DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**None**: Template or style encapsulation is not provided. The styles will
    be injected as is into the document''s header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s check out an actual example. First, import the `ViewEncapsulation enum`
    into the script, and then create an encapsulation property with the emulated value.
    Then, let''s create a style rule for our countdown text so any `<h1> (!)` tag
    is rendered in dark red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, click on the browser's dev tools inspector and check the generated HTML
    to discover how Angular injected the CSS inside the page `<head>` block. The just
    injected style sheet has been sandboxed to ensure that the global CSS rule we
    defined at the component setup in a very non-specific way for all `<h1>` elements
    only applies to matching elements scoped by the `CountdownTimerComponent` component
    exclusively.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you try out different values and see how the CSS code is injected
    into the document. You will immediately notice the different grades of isolation
    that each variation provides.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter guided us through the options available in Angular for creating
    powerful APIs for our components, so we can provide high levels of interoperability
    between components, configuring its properties by assigning either static values
    or managed bindings. We also saw how a component can act as a host component for
    another child component, instantiating the former's custom element in its own
    template, setting the ground up for larger component trees in our applications.
    Output parameters give the layer of interactivity we need by turning our components
    into event emitters so they can properly communicate in an agnostic fashion with
    any parent component that might eventually host them. Template references paved
    the way to create references in our custom elements that we can use as accessors
    to their properties and methods from within the template in a declarative fashion.
    We also discussed how we could isolate the component's HTML template in an external
    file in order to ease its future maintainability and how to do the same with any
    style sheet we wanted to bind to the component, in case we do not want to bundle
    the component styles inline. An overview of the built-in features for handling
    view encapsulation in Angular gave us some additional insights on how we can benefit
    from Shadow DOM's CSS scoping on a per-component basis and how we can polyfill
    it when not supported.
  prefs: []
  type: TYPE_NORMAL
- en: We still have much more to learn regarding template management in Angular, mostly
    with regards to the two concepts that you will use extensively along your journey
    with Angular. I am referring to Directives and Pipes, which we will cover extensively
    in [Chapter 5](3df2cad2-baa6-4076-a6ab-d84247af7817.xhtml), *Enhancing Our Components
    with Pipes and Directives*.
  prefs: []
  type: TYPE_NORMAL
