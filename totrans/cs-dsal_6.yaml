- en: Exploring Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you got to know trees. However, did you know that such
    data structures also belong to graphs? But what is a graph and how you can use
    it in your applications? You can find answers to these and many other questions
    in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, the basic information about graphs will be presented, including
    an explanation of nodes and edges. Moreover, you will see the difference between
    directed and undirected edges, as well as between weighted and unweighted ones.
    As graphs are data structures that are commonly used in practice, you will also
    see some applications, such as for storing the data of friends in social media
    or finding a road in a city. Then, the topic of graph representation will be covered,
    namely using an adjacency list and matrix.
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, you will learn how to implement a graph in the
    C# language. This task involves the declaration of a few classes, such as regarding
    nodes and edges. The whole necessary code will be described in detail in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you will also have a chance to read the description of two modes of
    graph traversal, namely depth-first and breadth-first search. For both of them,
    the C# code and a detailed description will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: The next part will present the subject of minimum spanning trees, as well as
    two algorithms for their creation, namely Kruskal's and Prim's. Such algorithms
    will be presented as textual description, C#-based code snippets, as well as easy-to-understand
    illustrations. Moreover, the example real-world application will be provided.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting graph-related problem is the coloring of nodes, which will
    be taken into account in the following part of the chapter. At the end, the topic
    of finding the shortest path in a graph will be analyzed using Dijkstra's algorithm.
    Of course, the example real-world application will be shown as well, together
    with the C#-based implementation.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the topic of graphs involves many interesting problems and only
    some of them will be mentioned in the book. However, the chosen subjects are suitable
    for the presentation of various graph-related aspects in the context of C#-based
    implementation. Are you ready to dive into the topic of graphs? If so, start reading
    this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Concept of graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum spanning tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coloring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shortest path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concept of graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the question *what is a graph?* Broadly speaking, a graph
    is a data structure that consists of **nodes** (also called **vertices**) and
    **edges**. Each edge connects two nodes. A graph data structure does not require
    any specific rules regarding connections between nodes, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2f956e4-ed60-447e-961e-b32be6c7719d.png)'
  prefs: []
  type: TYPE_IMG
- en: The afore mentioned concept seems very simple, doesn't it? Let's try to analyze
    the preceding graph to eliminate any doubts. It contains nine nodes with numbers
    between **1** and **9** as values. Such nodes are connected by 11 edges, such
    as between nodes **2** and **4**. Moreover, a graph can contain **cycles**, for
    example, with nodes indicated by **2**, **3**, and **4**, as well as separate
    groups of nodes, which are not connected together. However, what about the topic
    of parent and child nodes, which you know from learning about trees? As there
    are no specific rules about connections in a graph, such concepts are not used
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: A graph can also contain **self-loops**. Each is an edge that connects a given
    node with itself. However, such a topic is out of the scope of this book and is
    not taken into account in examples shown in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Some more comments are necessary for edges in a graph. In the preceding diagram,
    you can see a graph where all nodes are connected with **undirected edges**, that
    is, **bidirectional edges**. They indicate that it is possible to travel between
    nodes in both directions, for example, from the node **2** to **3** and from the
    node **3** to **2**. Such edges are presented graphically as straight lines. When
    a graph contains undirected edges, it is an **undirected graph**.
  prefs: []
  type: TYPE_NORMAL
- en: However, what about a scenario when you need to indicate that traveling between
    nodes is possible only in one direction? In such a case, you can use **directed
    edges**, that is, **unidirectional edges**, which are presented graphically as
    straight lines with arrows indicating the direction of an edge. If a graph contains
    directed edges, it can be named a **directed graph**.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example directed graph is presented in the following diagram on the right,
    while an undirected one is shown on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78f53bad-97f1-4052-bb70-124a43cdfbf3.png)'
  prefs: []
  type: TYPE_IMG
- en: Just as a short explanation, the directed graph (shown on the right in the preceding
    diagram) contains eight nodes connected by 15 unidirectional edges. For example,
    they indicate that it is possible to travel between the node **1** and **2** in
    both directions, but it is allowed to travel from the node **1** to **3** only
    in one direction, so it is impossible to reach the node **1** from **3** directly.
  prefs: []
  type: TYPE_NORMAL
- en: The division between undirected and directed edges is not the only one. You
    can also specify **weights** (also referred to as **costs**) for particular edges
    to indicate the cost of traveling between nodes. Of course, such weights can be
    assigned to both undirected and directed edges. If weights are provided, an edge
    is named a **weighted edge** and the whole graph a **weighted graph**. Similarly,
    if no weights are provided, **unweighted edges** are used in a graph that can
    be called an **unweighted graph**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example weighted graphs with undirected (on the left) and directed (on
    the right) edges are presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a125b36-2efb-407e-8d60-b3cc03b89af7.png)'
  prefs: []
  type: TYPE_IMG
- en: The graphical presentation of a weighted edge only shows the addition of the
    weight of an edge next to the line. For example, the cost of traveling from the
    node **1** to **2**, as well as from the node **2** to **1**, is equal to **3**
    in the case of the undirected graph, shown on the left in the preceding diagram.
    The situation is a bit more complicated in the case of the directed graph (on
    the right). Here, you can travel from the node **1** to **2** with a cost equal
    to **9**, while traveling in the opposite direction (from the node **2** to **1**)
    is much cheaper and costs only **3**.
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the short introduction, you know some basic information about graphs,
    especially regarding nodes and various kinds of edges. However, why is the topic
    of graphs so important and why does it take up a whole chapter in this book? Could
    you use this data structure in your applications? The answer is obvious: yes!
    The graphs are commonly used while solving various algorithmic problems and have
    numerous real-world applications. Two examples are shown in the following diagrams.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s think about a structure of friends available in social
    media. Each user has many contacts, but they also have many friends, and so on.
    What data structure should you choose to store such data? The graph is one of
    the simplest answers. In such a scenario, the nodes represent contacts, while
    edges depict relationships between people. As an example, let''s take a look at
    the following diagram of an undirected and unweighted graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64331293-09c6-49c6-b1f7-979bf9cd68c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, **Jimmy Stewart** has five contacts, namely **John Smith**,
    **Andy Wood**, **Eric Green**, **Ashley Lopez**, and **Paula Scott**. In the meantime,
    **Paula Scott** has two other friends: **Marcin Jamro** and **Tommy Butler**.
    With the usage of a graph as a data structure, you can easily check whether two
    people are friends or whether they have a common contact.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common application of graphs involves the problem of searching for
    the shortest path. Let''s imagine a program that should find a path between two
    points in the city, taking into account the time necessary for driving particular
    roads. In such a case, you can use a graph to present a map of a city, where nodes
    depict intersections and edges represent roads. Of course, you should assign weights
    to edges to indicate the time necessary for driving a given road. The topic of
    searching the shortest path can be understood as finding the list of edges from
    the source to the target node, with the minimum total cost. The diagram of a city
    map, based on a graph, is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65f4d4d1-604d-461d-89d8-745660ef781e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the directed and weighted graph was chosen. The application
    of directed edges makes it possible to support both two-way and one-way roads,
    while weighted edges allow for specifying the time necessary to travel between
    two intersections.
  prefs: []
  type: TYPE_NORMAL
- en: Representation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know what a graph is and when it can be used, but how you can represent
    it in the memory of a computer? There are two popular approaches to solve this
    problem, namely using an **adjacency list** and an **adjacency matrix**. Both
    are described in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first approach requires you to extend the data of a node by specifying
    a list of its neighbors. Thus, you can easily get all neighbors of a given node
    just by iterating through the adjacency list of a given node. Such a solution
    is space-efficient, because you only store the data of adjacent edges. Let''s
    take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b5077b4-5ac8-4d23-b617-5de2c40cdb61.png)'
  prefs: []
  type: TYPE_IMG
- en: The example graph contains 8 nodes and 10 edges. For each node, a list of adjacent
    nodes (that is, neighbors) is created, as shown on the right-hand side of the
    diagram. For example, the node **1** has two neighbors, namely the nodes **2**
    and **3**, while the node **5** has four neighbors, namely the nodes **4**, **6**,
    **7**, and **8**. As you can see, the representation based on the adjacency list
    for an undirected and unweighted graph is really straightforward, as well as easy
    to use, understand, and implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, how does the adjacency list work in the case of a directed graph?
    The answer is obvious, because the list assigned to each node just shows adjacent
    nodes that can be reached from the given node. The example diagram is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9587b8b-ee85-43e5-a6e1-c72e45ee7320.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the node **3**. Here, the adjacency list contains only
    one element, that is, the node **4**. The node **1** is not included, because
    it cannot be reached directly from the node **3**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit more clarification may be necessary in the case of a weighted graph.
    In such a case, it is also necessary to store weights for particular edges. You
    can achieve this goal by extending data stored in the adjacency list, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c37de49-bcb7-4f69-9509-2832cb82e959.png)'
  prefs: []
  type: TYPE_IMG
- en: The adjacency list for the node **7** contains two elements, namely regarding
    an edge to the node **5** (with a weight equal to **4**) and to the node **8**
    (with a weight equal to **6**).
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another approach to graph representation involves the adjacency matrix, which
    uses the two-dimensional array to show which nodes are connected by edges. The
    matrix contains the same number of rows and columns, which is equal to the number
    of nodes. The main idea is to store information about a particular edge in an
    element at a given row and column in the matrix. The index of the row and the
    column depends on the nodes connected with the edge. For example, if you want
    to get information about an edge between nodes with indices 1 and 5, you should
    check the element in the row with an index equal to 1 and in the column with an
    index set to 5.
  prefs: []
  type: TYPE_NORMAL
- en: Such a solution provides you with a fast way of checking whether two particular
    nodes are connected by an edge. However, it may require you to store significantly
    more data than the adjacency list, especially if the graph does not contain many
    edges between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s analyze the basic scenario of an undirected and unweighted
    graph. In such a case, the adjacency matrix may store only Boolean values. The
    `true` value placed in the element at `i` row and `j` column indicates that there
    is a connection between a node with an index equal to `i` and the node with index
    `j`. If it sounds complicated, take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94179e3f-bede-42b6-b542-7b579cf89c08.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the adjacency matrix contains 64 elements (for eight rows and eight columns),
    because there are eight nodes in the graph. The values of many elements in the
    array are set to `false`, which is represented by missing indicators. The remaining
    are marked with crosses, representing `true` values. For example, such a value
    in the element at the fourth row and third column means that there is an edge
    between the node **4** and **3**, as shown in the preceding diagram of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: As the presented graph is undirected, the adjacency matrix is symmetric. If
    there is an edge between nodes `i` and `j`, there is also an edge between nodes
    `j` and `i`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example involves a directed and unweighted graph. In such a case,
    the same rules can be used, but the adjacency matrix does not need to be symmetric.
    Let''s take a look at the following diagram of the graph, presented together with
    the adjacency matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1c3511f-6e80-4aa4-8199-fbb7c4ed7a53.png)'
  prefs: []
  type: TYPE_IMG
- en: Within the shown adjacency matrix you can find data of 15 edges, represented
    by 15 elements with `true` values, indicated by crosses in the matrix. For example,
    the unidirectional edge from the node **5** to **4** is shown as the cross at
    the fifth row and fourth column.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both previous examples, you have learnt how to present an unweighted graph
    using an adjacency matrix. However, how you can store the data of the weighted
    graph, either undirected or directed? The answer is very simple—you just need
    to change the type of data stored in particular elements in the adjacency matrix
    from Boolean to numeric. Thus, you can specify the weight of edges, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ac401e9-75be-451b-b89b-1df9a325af0c.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram and the adjacency matrix are self-explanatory. However,
    to eliminate any doubt, let's take a look at the edge between the node **5** and
    **6** with the weight set to **2**. Such an edge is represented by the element
    at the fifth row and sixth column. The value of the element is equal to the cost
    of traveling between such nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have already got to know some basic information about graphs, including
    nodes, edges, and two methods of representation, namely using an adjacency list
    and matrix. However, how you can use such a data structure in your applications?
    In this section, you will learn how to implement a graph using the C# language.
    To make your understanding of the presented content easier, two examples are provided.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with, let''s take a look at the code of the generic class representing
    a single node in a graph. Such a class is named `Node` and its code is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The class contains four properties. As all of these elements perform important
    roles in the code snippets shown in this chapter, let''s analyze them in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The first property (`Index`) stores an index of a particular node in a collection
    of nodes in a graph to simplify the process of accessing a particular element.
    Thus, it is possible to easily get an instance of the `Node` class, representing
    a particular node, by using an index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next property is named `Data` and just stores some data in the node. It
    is worth mentioning that a type of such data is consistent with the type specified
    while creating an instance of the generic class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Neighbors` property represents the adjacency list for a particular node.
    Thus, it contains references to the `Node` instances representing adjacent nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last property is named `Weights` and stores weights assigned to adjacent
    edges. In the case of a weighted graph, the number of elements in the `Weights`
    list is the same as the number of neighbors (`Neighbors`). If a graph is unweighted,
    the `Weights` list is empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from the properties, the class contains the overridden `ToString` method,
    which returns the textual representation of the object. Here, the string in the
    format `"Node with index [index]: [data], neighbors: [count]"` is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: Edge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the short introduction to the topic of graphs, a graph consists
    of nodes and edges. As a node is represented by an instance of the `Node` class,
    the `Edge` generic class can be used to represent an edge. The suitable part of
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The class contains three properties, namely representing nodes adjacent to the
    edge (`From` and `To`), as well as the weight of the edge (`Weight`). Moreover,
    the `ToString` method is overridden to present some basic information about the
    edge.
  prefs: []
  type: TYPE_NORMAL
- en: Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next class is named `Graph` and represents a whole graph, with either directed
    or undirected edges, as well as either weighted or unweighted edges. The implementation
    consists of various fields and methods, which are described in details as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the basic version of the `Graph` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The class contains two fields indicating whether edges are directed (`_isDirected`)
    and weighted (`_isWeighted`). Moreover, the `Nodes` property is declared, which
    stores a list of nodes existing in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class also contains the constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, only values of the `_isDirected` and `_isWeighted` private fields are
    set, according to the values of parameters passed to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next interesting member of the `Graph` class is the indexer that takes
    two indices, namely indices of two nodes, to return an instance of the `Edge`
    generic class representing an edge between such nodes. The implementation is shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Within the indexer, you get instances of the `Node` class representing two nodes
    (`nodeFrom` and `nodeTo`), according to the indices. As you want to find an edge
    from the first node (`nodeFrom`) to the second one (`nodeTo`), you need to try
    to find the second node in the collection of neighbor nodes of the first node,
    using the `IndexOf` method. If such a connection does not exist, the `IndexOf`
    method returns a negative value and `null` is returned by the indexer. Otherwise,
    you create a new instance of the `Edge` class and set the values of its properties,
    including `From` and `To`. If the data regarding the weight of particular edges
    are provided, the value of the `Weight` property of the `Edge` class is set as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you know how to store the data of nodes in the graph, but how can you add
    a new node? To do so, the `AddNode` method is implemented, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Within this method, you create a new instance of the `Node` class and set a
    value of the `Data` property, according to the value of the parameter. Then, the
    newly-created instance is added to the `Nodes` collection, and the `UpdateIndices`
    method (described later) is called to update the indices of all nodes stored in
    the collection. At the end, the `Node` instance, representing the newly-added
    node, is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can remove the existing node as well. This operation is performed by the
    `RemoveNode` method, shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The method takes one parameter, namely an instance of the node that should be
    removed. First, you remove it from the collection of nodes. Then, you update the
    indices of the remaining nodes. At the end, you iterate through all nodes in the
    graph to remove all edges that are connected with the node that has been removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you already know, a graph consists of nodes and edges. Thus, the implementation
    of the `Graph` class should provide developers with the method for adding a new
    edge. Of course, it should support various variants of edges, either directed,
    undirected, weighted, or unweighted. The proposed implementation is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `AddEdge` method takes three parameters, namely two instances of the `Node`
    class representing nodes connected by the edge (`from` and `to`), as well as the
    weight of the connection (`weight`), which is set to `0` by default.
  prefs: []
  type: TYPE_NORMAL
- en: In the first line within the method, you add the `Node` instance representing
    the second node to the list of neighbor nodes of the first one. If the weighted
    graph is considered, a weight of the afore mentioned edge is added as well.
  prefs: []
  type: TYPE_NORMAL
- en: The following part of the code is taken into account only when the graph is
    undirected. In such a case, you need to automatically add an edge in the opposite
    direction. To do so, you add the `Node` instance representing the first node to
    the list of neighbor nodes of the second one. If the edges are weighted, a weight
    of the afore mentioned edge is added to the `Weights` list as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of removing an edge from the graph is supported by the `RemoveEdge`
    method. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The method takes two parameters, namely two nodes (`from` and `to`), between
    which there is an edge that should be removed. To start, you try to find the second
    node in the list of neighbor nodes of the first one. If it is found, you remove
    it. Of course, you should also remove the weight data, if the weighted graph is
    considered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last public method is named `GetEdges` and makes it possible to get a collection
    of all edges available in the graph. The proposed implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To start with, a new list of edges is initialized. Then, you iterate through
    all nodes in the graph, using the `foreach` loop. Within it, you use the `for`
    loop to create instances of the `Edge` class. The number of instances should be
    equal to the number of neighbors of the current node (the `from` variable in the
    `foreach` loop). In the `for` loop, the newly-created instance of the `Edge` class
    is configured by setting values of its properties, namely the first node (the
    `from` variable, that is, the current node from the `foreach` loop), the second
    node (to the currently-analyzed neighbor), and the weight. Then, the newly-created
    instance is added to the collection of edges, represented by the `edges` variable.
    At the end, the result is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'In various methods, you use the `UpdateIndices` method. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The method just iterates through all nodes in the graph and updates the values
    of the `Index` property to the consecutive number, starting from `0`. It is worth
    noting that the iteration is performed using the `ForEach` method, instead of
    `foreach` or a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to create a basic implementation of a graph. The next step
    is to apply it to represent some example graphs, as shown in the two following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Example – undirected and unweighted edges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to use the previous implementation to create the undirected and
    unweighted graph, according to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74eaa194-4d25-4862-bf52-87ab7b6bf942.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the graph contains 8 nodes and 10 edges. You can configure
    the example graph in the `Main` method in the `Program` class. The implementation
    starts with the following line of code, which initializes a new undirected graph
    (with `false` as the value of the first parameter) and an unweighted graph (with
    `false` as the value of the second parameter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you add the necessary nodes, and store references to them as new variables
    of the `Node<int>` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, you only need to add edges between nodes, according to the preceding
    diagram of the graph. The necessary code is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That's all! As you can see, configuration of a graph is very easy using the
    proposed implementation of this data structure. Now, let's proceed to a slightly
    more complex scenario with directed and weighted edges.
  prefs: []
  type: TYPE_NORMAL
- en: Example – directed and weighted edges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next example involves the directed and weighted graph, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37e3110d-10bd-43cf-8a81-fa6144a9e3de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The implementation is very similar to the one described in the previous section.
    However, some modifications are necessary. To start with, different values of
    the parameters of the constructor are used, namely `true` instead of `false` to
    indicate that a directed and weighted variant of edges is being considered. The
    suitable line of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The part regarding adding nodes is exactly the same as in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Some changes are easily visible in the lines of code regarding the addition
    of edges. Here, you specify directed edges together with their weights, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You have just completed the basic implementation of a graph, shown in two examples.
    So, let's proceed to another topic, namely traversing a graph.
  prefs: []
  type: TYPE_NORMAL
- en: Traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the useful operations performed on a graph is its **traversal**, that
    is, visiting all of the nodes in some particular order. Of course, the afore mentioned
    problem can be solved in various ways, such as using **depth-first search** (**DFS**)
    or **breadth-first search** (**BFS**) approaches. It is worth mentioning that
    the traversal topic is strictly connected with the task of searching for a given
    node in a graph.
  prefs: []
  type: TYPE_NORMAL
- en: Depth-first search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first graph traversal algorithm described in this chapter is named DFS.
    Its steps, in the context of the example graph, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1e3f5de-294d-47ce-b2fe-0bdd4a626522.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, it can be a bit difficult to understand how the DFS algorithm operates
    just by looking at the preceding diagram. For this reason, let's try to analyze
    its stages.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, you see the graph with eight nodes. The node **1** is marked
    with a gray background (indicating that the node has been already visited), as
    well as with a red border (indicating that it is the node that is currently being
    visited). Moreover, an important role in the algorithm is performed by the neighbor
    nodes (shown as circles with dashed borders) of the current one. When you know
    the roles of particular indicators, it is clear that in the first step, the node
    **1** is visited. It has two neighbors (the nodes **2** and **3**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the first neighbor (the node **2**) is taken into account and the same
    operations are performed, that is, the node is visited and the neighbors (the
    nodes **1** and **4**) are analyzed. As the node **1** has been already visited,
    it is skipped. In the next step (shown as **Step #3**), the first suitable neighbor
    of the node **2** is taken into account—the node **4**. It has two neighbors,
    namely the node **2** (already visited) and **8**. Next, the node **8** is visited
    (**Step #4**) and, according to the same rules, the node **5** (**Step #5**).
    It has four neighbors, namely the nodes **4** (already visited), **6**, **7**,
    and **8** (already visited). Thus, in the next step, the node **6** is taken into
    account (**Step #6**). As it has only one neighbor (the node **7**), it is visited
    next (**Step #7**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you check the neighbors of the node **7**, namely the nodes **5** and
    **8**. Both have already been visited, so you return to the node with an unvisited
    neighbor. In the example, the node **1** has one unvisited node, namely the node
    **3**. When it is visited (**Step #8**), all nodes are traversed and no further
    operations are necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this example, let''s try to create the implementation in the C# language.
    To start, the code of the `DFS` method (in the `Graph` class) is presented as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The important role is performed by the `isVisited` array. It has exactly the
    same number of elements as the number of nodes and stores values indicating whether
    a given node has already been visited. If so, the `true` value is stored, otherwise `false`.
    The list of traversed nodes is represented as a list in the `result` variable.
    What is more, another variant of the `DFS` method is called here, passing three
    parameters, namely a reference to the `isVisited` array, the first node to analyze,
    as well as the list for storing results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the afore mentioned variant of the `DFS` method is presented as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The shown implementation is very simple. At the beginning, the current node
    is added to the collection of traversed nodes and the element in the `isVisited`
    array is updated. Then, you use the `foreach` loop to iterate through all neighbors
    of the current node. For each of them, if it is not already visited, the `DFS`
    method is called recursively.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about DFS at [https://en.wikipedia.org/wiki/Depth-first_search](https://en.wikipedia.org/wiki/Depth-first_search).
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish, let''s take a look at the code that can be placed in the `Main`
    method in the `Program` class. Its main parts are presented in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you initialize a directed and weighted graph. To start traversing the
    graph, you just need to call the `DFS` method, which returns a list of `Node`
    instances. Then, you can easily iterate through elements of the list to print
    some basic information about each node. The result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That's all! As you can see, the algorithm tries to go as deep as possible and
    then goes back to find the next unvisited neighbor that can be traversed. However,
    the presented algorithm is not the only approach to the problem of graph traversal.
    In the next section, you will see another method, together with a basic example
    and its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-first search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learnt the DFS approach. Now you will see another
    solution, namely BFS. Its main aim is to first visit all neighbors of the current
    node and then proceed to the next level of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the previous description sounds a bit complicated, take a look at this diagram,
    which depicts the steps of the BFS algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3e3596a-13bc-4a71-907f-4ca85b345502.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The algorithm starts by visiting the node **1** (**Step #1**). It has two neighbors,
    namely the nodes **2** and **3**, which are visited next (**Step #2** and **Step** **#3**).
    As the node **1** does not have more neighbors, the neighbors of its first neighbor
    (the node **2**) are considered. As it has only one neighbor (the node **4**),
    it is visited in the next step. According to the same method, the remaining nodes
    are visited in this order: **8**, **5**, **6**, **7**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It sounds very simple, doesn''t it? Let''s take a look at the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BFS` public method is added to the `Graph` class and is used just to start
    the traversal of a graph. It calls the private `BFS` method, passing the first
    node as the parameter. Its code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The important role in the code is performed by the `isVisited` array, which
    stores Boolean values indicating whether particular nodes have been visited already.
    Such an array is initialized at the beginning of the `BFS` method, and the value
    of the element related to the current node is set to `true`, which indicates that
    the node has been visited.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the list for storing traversed nodes (`result`) and the queue for storing
    nodes that should be visited in the following iterations (`queue`) are created.
    Just after the initialization of the queue, the current node is added into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following operations are performed until the queue is empty: you get the
    first node from the queue (the `next` variable), add it to the collection of visited
    nodes, and iterate through the neighbors of the current node. For each of them,
    you check whether it has already been visited. If not, it is marked as visited
    by setting a proper value in the `isVisited` array, and the neighbor is added
    to the queue for analysis in one of the next iterations of the `while` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the BFS algorithm and its implementation
    at [https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/](https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, the list of the visited nodes is returned. If you want to test
    the described algorithm, you can place the following code in the `Main` method
    in the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The code initializes the graph, adds proper nodes and edges, and calls the
    `BFS` public method to traverse the graph according to the BFS algorithm. The
    last line is responsible for iterating through the result to present the data
    of the nodes in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You have just learnt two algorithms for traversing a graph, namely DFS and BFS.
    To make your understanding of such topics easier, this chapter contains detailed
    descriptions, diagrams, and examples. Now, let's proceed to the next section to
    get to know another important topic, namely a minimum spanning tree, which has
    many real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum spanning tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While talking about graphs, it is beneficial to introduce the subject of a
    **spanning tree**. What is it? A spanning tree is a subset of edges that connects
    all nodes in a graph without cycles. Of course, it is possible to have many spanning
    trees within the same graph. For example, let''s take a look at the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84d01292-80ee-4542-9afb-10e292ca0a0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the left-hand side is a spanning tree that consists of the following edges:
    (**1**, **2**), (**1**, **3**), (**3**, **4**), (**4**, **5**), (**5**, **6**),
    (**6**, **7**), and (**5**, **8**). The total weight is equal to 40\. On the right-hand
    side, another spanning tree is shown. Here, the following edges are taken into
    account: (**1**, **2**), (**1**, **3**), (**2**, **4**), (**4**, **8**), (**5**,
    **8**), (**5**, **6**), and (**6**, **7**). The total weight is equal to 31.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, neither of the preceding spanning trees is the **minimum spanning
    tree** (**MST**) of this graph. What does it mean that a spanning tree is *minimum*?
    The answer is really simple: it is a spanning tree with the minimum cost from
    all spanning trees available in the graph. You can get the MST by replacing the
    edge (**6**, **7**) with (**5**, **7**). Then, the cost is equal to 30\. It is
    also worth mentioning that the number of edges in a spanning tree is equal to
    the number of nodes minus one.'
  prefs: []
  type: TYPE_NORMAL
- en: Why is the topic of the MST so important? Let's imagine a scenario when you
    need to connect many buildings to a telecommunication cable. Of course, there
    are various possible connections, such as from one building to another, or using
    a hub. What is more, environmental conditions can have a serious impact on the
    cost of the investment due to the necessity of crossing a road or even a river.
    Your task is to successfully connect all buildings to the telecommunication cable
    with the lowest possible cost. How should you design the connections? To answer
    this question, you just need to create a graph, where nodes represent connectors
    and edges indicate possible connections. Then, you find the MST, and that's all!
  prefs: []
  type: TYPE_NORMAL
- en: The afore mentioned problem of connecting many buildings to the telecommunication
    cable is presented in the example at the end of the section regarding the MST.
  prefs: []
  type: TYPE_NORMAL
- en: The next question is how you can find the MST? There are various approaches
    to solve this problem, including the application of Kruskal's or Prim's algorithms,
    which are presented and explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Kruskal's algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the algorithms for finding the MST was discovered by Kruskal. Its operation
    is very simple to explain. The algorithm takes an edge with the minimum weight
    from the remaining ones and adds it to the MST, only if adding it does not create
    a cycle. The algorithm stops when all nodes are connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the diagram that presents the steps of finding the MST
    using **Kruskal''s algorithm**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5ee36e3-7ca4-425f-8907-e1830736b7bc.png)'
  prefs: []
  type: TYPE_IMG
- en: In the first step, the edge (**5**, **8**) is chosen, because it has the minimum
    weight, namely **1**. Then, the edges (**1**, **2**), (**2**, **4**), (**5**,
    **6**), (**1**, **3**), (**5**, **7**), and (**4**, **8**) are selected. It is
    worth noting that before taking the (**4**, **8**) edge, the (**6**, **7**) one
    is considered, due to lower weight. However, adding it to the MST will introduce
    a cycle formed by (**5**, **6**), (**6**, **7**), and (**5**, **7**) edges. For
    this reason, such an edge is ignored and the algorithm chooses the edge (**4**,
    **8**). At the end, the number of edges in the MST is 7\. The number of nodes
    is equal to **8**, so it means that the algorithm can stop operating and the MST
    is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation. It involves the `MinimumSpanningTreeKruskal`
    method, which should be added to the `Graph` class. The proposed code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The method does not take any parameters. To start, a list of edges is obtained
    by calling the `GetEdges` method. Then, the edges are sorted in ascending order
    by weight. Such a step is crucial, because you need to get an edge with the minimum
    cost in the following iterations of the algorithm. In the next line, a new queue
    is created and `Edge` instances are enqueued, using the constructor of the `Queue`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next block of code, an array with data of subsets is created. By default,
    each node is added to a separate subset. It is the reason why the number of elements
    in the `subsets` array is equal to the number of nodes. The subsets are used to
    check whether an addition of an edge to the MST causes the creation of a cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the list for storing edges from the MST is created (`result`). The most
    interesting part of code is the `while` loop, which iterates until the correct
    number of edges is found in the MST. Within the loop, you get the edge with the
    minimum weight, just by calling the `Dequeue` method on the `Queue` instance.
    Then, you check whether no cycles were introduced by adding the found edge to
    the MST. In such a case, the edge is added to the target list and the `Union`
    method is called to union two subsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'While analyzing the previous method, the `GetRoot` one is mentioned. Its aim
    is to update parents for subsets, as well as return the root node of the subset,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The last private method is named `Union` and performs the union operation (by
    a rank) of two sets. It takes three parameters, namely an array of `Subset` instances
    and two `Node` instances, representing root nodes for subsets on which the union
    operation should be performed. The suitable part of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code snippets, you can see the `Subset` class, but what does
    it look like? Let''s take a look at its declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The class contains properties representing the parent node (`Parent`), as well
    as the rank of the subset (`Rank`). The class has also overridden the `ToString`
    method, which presents some basic information about the subset in textual form.
  prefs: []
  type: TYPE_NORMAL
- en: The presented code is based on the implementation shown at [https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/](https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/).
    You can also find more information about Kruskal's algorithm there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the usage of the `MinimumSpanningTreeKruskal` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, you initialize an undirected and weighted graph, as well as add nodes
    and edges. Then, you call the `MinimumSpanningTreeKruskal` method to find the
    MST using Kruskal's algorithm. At the end, you use the `ForEach` method to write
    the data of each edge from the MST in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Prim's algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another solution to solve the problem of finding the MST is **Prim's algorithm**.
    It uses two sets of nodes which are disjointed, namely the nodes located in the
    MST and the nodes that are not placed there yet. In the following iterations,
    the algorithm finds an edge with the minimum weight that connects a node from
    the first group with a node from the second group. The node of the edge, which
    is not already in the MST, is added to this set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding description sounds quite simple, doesn''t it? Let''s see it in
    action by analyzing the diagram presenting the steps of finding the MST using
    Prim''s algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee23c538-4e24-4625-b17d-b734be8dabac.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the additional indicators added next to the nodes in the
    graph. They present the minimum weight necessary to reach such a node from any
    of its neighbors. By default, the starting node has such a value set to **0**,
    while all others are set to infinity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In **Step #2**, the starting node is added to the subset of nodes forming the
    MST and the distance to its neighbors is updated, namely **5** for reaching the
    node **3** and **3** for reaching the node **2**.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next step (that is **Step #3**), the node with the minimum cost is chosen.
    In this case, the node **2** is selected, because the cost is equal to **3**.
    Its competitor (namely the node **3**) has a cost equal to **5**. Next, you need
    to update the cost of reaching the neighbors of the current node, namely the node
    **4** with the cost set to **4**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chosen node is obviously the node **4**, because it does not exist
    in the MST set and has the lowest reaching cost (**Step #4**). In the same way,
    you choose the next edges in the following order: (**1**, **3**), (**4**, **8**),
    (**8**, **5**), (**5**, **6**), and (**5**, **7**). Now, all nodes are included
    in the MST and the algorithm can stop its operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this detailed description of the steps of the algorithm, let''s proceed
    to the C#-based implementation. The majority of operations are performed in the
    `MinimumSpanningTreePrim` method, which should be added to the `Graph` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `MinimumSpanningTreePrim` method does not take any parameters. It uses three
    auxiliary node-related arrays that assign additional data to the nodes of the
    graph. The first, namely `previous`, stores indices of the previous node, from
    which the given node can be reached. By default, values of all elements are equal
    to `0`, except the first one, which is set to `-1`. The `minWeight` array stores
    the minimum weight of the edge for accessing the given node. By default, all elements
    are set to the maximum value of the `int` type, while the value for the first
    element is set to `0`. The `isInMST` array indicates whether the given node is
    already in the MST. To start with, values of all elements should be set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting part of code is located in the `for` loop. Within it, the
    index of the node from the set of nodes not located in the MST, which can be reached
    with the minimum cost, is found. Such a task is performed by the `GetMinimumWeightIndex`
    method. Then, another `for` loop is used. Within it, you get an edge that connects
    nodes with the index `minWeightIndex` and `j`. You check whether the node is not
    already located in the MST and whether the cost of reaching the node is smaller
    than the previous minimum cost. If so, values of node-related elements in the
    `previous` and `minWeight` arrays are updated.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the code just prepares the final results. Here, you create
    a new instance of the list with the data of edges that form the MST. The `for`
    loop is used to get the data of the following edges and to add them to the `result`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'While analyzing the code, the `GetMinimumWeightIndex` private method is mentioned.
    Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `GetMinimumWeightIndex` method just finds an index of the node, which is
    not located in the MST and can be reached with the minimum cost. To do so, you
    use the `for` loop to iterate through all nodes. For each of them, you check whether
    the current node is not located in the MST and whether the cost of reaching it
    is smaller than the already-stored minimum value. If so, values of the `minValue`
    and `minIndex` variables are updated. At the end, the index is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The presented code is based on the implementation shown at [https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/](https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/).
    You can also find more information about Prim's algorithm there.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is more, the auxiliary `Fill` method is used. It just sets the values
    of all elements in the array to the value passed as the second parameter. The
    code of the method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the usage of the `MinimumSpanningTreePrim` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: First, you initialize an undirected and weighted graph, as well as add nodes
    and edges. Then, you call the `MinimumSpanningTreePrim` method to find the MST
    using Prim's algorithm. At the end, you use the `ForEach` method to write the
    data of each edge from the MST in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Example – telecommunication cable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the introduction to the topic of the MST, this problem has
    some important real-world applications, such as for creating a plan of connections
    between buildings to supply all of them with a telecommunication cable with the
    smallest cost. Of course, there are various possible connections, such as from
    one building to another or using a hub. What is more, environmental conditions
    can have serious impact on the cost of the investment due to the necessity of
    crossing a road or even a river. For example, let''s create the program that solves
    this problem in the context of the set of buildings, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0d94024-3527-415b-b829-0f7ab8e73b81.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the estate community consists of 12 buildings, including blocks
    of flats and kiosks located by the river. The buildings are located on two sides
    of a small river with only one bridge. Moreover, two roads exist. Of course, there
    are different costs of connections between various points, depending both on the
    distance and the environmental conditions. For example, the direct connection
    between two buildings (**B1** and **B2**) has a cost equal to **2**, while using
    the bridge (between **R1** and **R5**) involves a cost equal to **75**. If you
    need to cross the river without a bridge (between **R3** and **R6**), the cost
    is even higher and equal to **100**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your task is to find the MST. Within this example, you will apply both Kruskal''s
    and Prim''s algorithms to solve this problem. To start, let''s initialize the
    undirected and weighted graph, as well as add nodes and edges, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you just need to call the `MinimumSpanningTreeKruskal` method to use
    Kruskal''s algorithm to find the MST. When the results are obtained, you can easily
    present them in the console, together with the presentation of the total cost.
    The suitable part of code is shown in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The results presented in the console are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you visualize such results on the map, the following MST is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83e8b4f4-5b14-4e99-a011-47a7f5e4e48d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In a similar way, you can apply Prim''s algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The obtained results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: That's all! You have just completed the example relating to the real-world application
    of the MST. Are you ready to proceed to another graph-related subject, which is
    named coloring?
  prefs: []
  type: TYPE_NORMAL
- en: Coloring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of finding the MST is not the only graph-related problem. Among others, **node
    coloring** exists. Its aim is to assign colors (numbers) to all nodes to comply
    with the rule that there cannot be an edge between two nodes with the same color.
    Of course, the number of colors should be as low as possible. Such a problem has
    some real-world applications, such as for coloring a map, which is the topic of
    the example shown later.
  prefs: []
  type: TYPE_NORMAL
- en: Did you know that the nodes of each planar graph can be colored with no more
    than four colors? If you are interested in this topic, take a look at the **four-color
    theorem** ([http://mathworld.wolfram.com/Four-ColorTheorem.html](http://mathworld.wolfram.com/Four-ColorTheorem.html)).
    The implementation of the coloring algorithm shown in this chapter is simple and
    in some cases could use more colors than really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63167778-a260-403b-9e82-ff572d8b399f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first diagram (shown on the left) presents a graph that is colored using
    four colors: red (index equal to **0**), green (**1**), blue (**2**), and violet
    (**3**). As you can see, there are no nodes with the same colors connected by
    an edge. The graph shown on the right depicts the graph with two additional edges,
    namely (**2**, **6**) and (**2**, **5**). In such a case, the coloring has changed,
    but the number of colors remains the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is, how can you find colors for nodes to comply with the afore
    mentioned rule? Fortunately, the algorithm is very simple and its implementation
    is presented here. The code of the `Color` method, which should be added to the
    `Graph` class, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `Color` method uses two auxiliary node-related arrays. The first is named
    `colors` and stores indices of colors chosen for particular nodes. By default,
    values of all elements are set to `-1`, except the first one, which is set to
    `0`. It means that the color of the first node is automatically set to the first
    color (for example, red). The other auxiliary array (`availability`) stores information
    about the availability of particular colors.
  prefs: []
  type: TYPE_NORMAL
- en: The most crucial part of the code is the `for` loop. Within it, you reset the
    availability of colors by setting `true` as the value of all elements within the
    `availability` array. Then, you iterate through the neighbor nodes of the current
    node to read their colors and mark such colors as unavailable by setting `false`
    as a value of a particular element in the `availability` array. The last inner
    `for` loop just iterates through the `availability` array and finds the first
    available color for the current node.
  prefs: []
  type: TYPE_NORMAL
- en: The presented code is based on the implementation shown at [https://www.geeksforgeeks.org/graph-coloring-set-2-greedy-algorithm/](https://www.geeksforgeeks.org/graph-coloring-set-2-greedy-algorithm/).
    What is more, you can find more information about the coloring problem there.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is more, the auxiliary `Fill` method is used with exactly the same code,
    as explained in one of the previous examples. It just sets the values of all elements
    in the array to the value passed as the second parameter. The code of the method
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the usage of the `Color` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you create a new undirected and unweighted graph, add nodes and edges,
    and call the `Color` method to perform the node coloring. As a result, you receive
    an array with indices of colors for particular nodes. Then, you present the results
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: After this short introduction you are ready to proceed to the real-world application,
    namely for coloring the voivodeship map, which is presented next.
  prefs: []
  type: TYPE_NORMAL
- en: Example – voivodeship map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a program that represents the map of voivodeships in Poland as
    a graph, and color such areas so that two voivodeships with common borders do
    not have the same color. Of course, you should limit the number of colors.
  prefs: []
  type: TYPE_NORMAL
- en: To start, let's think about the graph representation. Here, nodes represent
    particular voivodeships, while edges represent common borders between voivodeships.
  prefs: []
  type: TYPE_NORMAL
- en: 'The map of Poland with the graph already colored is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/876d451d-6a0b-47e8-b31c-d49027b05301.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Your task is just to color nodes in the graph using the already-described algorithm.
    To do so, you create the undirected and unweighted graph, add nodes representing
    voivodeships, and add edges to indicate common borders. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `Color` method is called on the `Graph` instance and the color indices
    for particular nodes are returned. At the end, you just present the results in
    the console. The suitable part of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Part of the results is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You have just learnt how to color nodes in the graph! However, this is not the
    end of the interesting topics regarding graphs that are presented within this
    book. Now, let's proceed to searching for the shortest path in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Shortest path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A graph is a great data structure for storing the data of various maps, such
    as cities and the distances between them. For this reason, one of the obvious
    real-world applications of graphs is searching for the **shortest path** between
    two locations, which takes into account a specific cost, such as the distance,
    the necessary time, or even the amount of fuel required.
  prefs: []
  type: TYPE_NORMAL
- en: There are several approaches to the topic of searching for the shortest path
    in a graph. However, one of the common solutions is **Dijkstra's algorithm**,
    which makes it possible to calculate distance from a starting node to all nodes
    located in the graph. Then, you can easily get not only the cost of connection
    between two nodes, but also find nodes that are between the start and end nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra's algorithm uses two auxiliary node-related arrays, namely for storing
    an identifier of the previous node—the node from which the current node can be
    reached with the smallest overall cost, as well as the minimum distance (cost),
    which is necessary for accessing the current node. What is more, it uses the queue
    for storing nodes that should be checked. During the consecutive iterations, the
    algorithm updates the minimum distances to particular nodes in the graph. At the
    end, the auxiliary arrays contain the minimum distance (cost) to reach all the
    nodes from the chosen starting node, as well as information on how to reach each
    node using the shortest path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding to the example, let''s take a look at the following diagram
    presenting two various shortest paths found using Dijkstra''s algorithm. The left-hand
    side shows the path from the node **8** to **1**, while the right-hand side shows
    the path from the node **1** to **7**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d62b464-51f2-48f8-a815-63207ac35c59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is high time that you see some C# code, which can be used to implement Dijkstra''s
    algorithm. The main role is performed by the `GetShortestPathDijkstra` method,
    which should be added to the `Graph` class. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `GetShortestPathDijkstra` method takes two parameters, namely `source` and
    `target` nodes. To start, it creates two node-related auxiliary arrays for storing
    the indices of previous nodes, from which the given node can be reached with the
    smallest overall cost (`previous`), as well as for storing the current minimum
    distances to the given node (`distances`). By default, the values of all elements
    in the `previous` array are set to `-1`, while in the `distances` array they are
    set to the maximum value of the `int` type. Of course, the distance to the source
    node is set to `0`. Then, you create a new priority queue, and enqueue the data
    of all nodes. The priority of each element is equal to the current distance to
    such a node.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that the example uses the `OptimizedPriorityQueue` package
    from NuGet. More information about this package is available at [https://www.nuget.org/packages/OptimizedPriorityQueue](https://www.nuget.org/packages/OptimizedPriorityQueue)
    and in the *Priority queues* section in [Chapter 3](c0fd3ad7-ebfd-4df4-ae4a-fda9573a2b40.xhtml),
    *Stacks and Queues*.
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting part of the code is the `while` loop which is executed
    until the queue is empty. Within the `while` loop, you get the first node from
    the queue and iterate through all of its neighbors using the `for` loop. Inside
    such a loop, you calculate the distance to a neighbor by taking the sum of the
    distance to the current node and the weight of the edge. If the calculated distance
    is smaller than the currently-stored value, you update the values regarding the
    minimum distance to the given neighbor, as well as the index of the previous node,
    from which you can reach the neighbor. It is worth noting that the priority of
    the element in the queue should be updated as well.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining operations are used to resolve the path using the values stored
    in the `previous` array. To do so, you save indices of the following nodes (in
    the opposite direction) in the `indices` list. Then, you reverse it to achieve
    the order from the source node to the target one. At the end, you just create
    the list of edges to present the result in the form suitable for returning from
    the method.
  prefs: []
  type: TYPE_NORMAL
- en: The presented and described implementation is based on the pseudocode shown
    at [https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm).
    You can find some additional information about Dijkstra's algorithm there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the usage of the `GetShortestPathDijkstra` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you create a new directed and weighted graph, add nodes and edges, and
    call the `GetShortestPathDijkstra` method to search the shortest path between
    two nodes, namely between the nodes `1` and `5`. As a result, you receive a list
    of edges forming the shortest path. Then, you just iterate through all edges and
    present the results in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: After this short introduction, together with the simple example, let's proceed
    to the more advanced and interesting application related to game development.
    Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: Example – game map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last example shown in this chapter involves the application of Dijkstra's
    algorithm for finding the shortest path in a game map. Let's imagine that you
    have a board with various obstacles. For this reason, the player can use only
    part of the board to move. Your task is to find the shortest path between two
    places located on the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s represent the board as a two-dimensional array where a given
    position on the board can be available for movement or not. The suitable part
    of code should be added to the `Main` method in the `Program` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: To improve the readability of code, the map is represented as an array of `string`
    values. Each row is presented as text, with the number of characters equal to
    the number of columns. The value of each character indicates the availability
    of the point. If it is equal to `0`, the position is available. Otherwise, it
    is not. The `string`-based map representation should be then converted into the
    Boolean two-dimensional array. Such a task is performed by a few lines of code,
    as shown in the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is the creation of the graph, as well as adding the necessary
    nodes and edges. The suitable part of code is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: First, you initialize a new undirected and weighted graph. Then, you use two
    `for` loops to iterate through all places on the board. Within such loops, you
    check whether the given place is available. If so, you create a new node (`from`).
    Then, you check whether the node placed immediately above the current one is also
    available. If so, a suitable edge is added with the weight equal to `1`. In a
    similar way you check whether the node placed on the left of the current one is
    available and add an edge, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you just need to get the `Node` instances representing the source and the
    target nodes. You can do it by using the `Find` method and providing the textual
    representation of the node, such as `0-0` or `16-24`. Then, you just call the
    `GetShortestPathDijkstra` method. In this case, the algorithm will try to find
    the shortest path between the node in the first row and column and the node in
    the last row and column. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of code is related to the presentation of the map in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: To start, you set the proper encoding in the console to be able to present Unicode
    characters as well. Then, you use two `for` loops to iterate through all places
    on the board. Inside such loops, you choose a color that should be used to represent
    a point in the console, either green (the point is available) or red (unavailable).
    If the currently-analyzed point is a part of the shortest path, the color is changed
    to white. At the end, you just set a proper color and write the Unicode character
    representing a bullet. When the program execution exits both loops, the default
    console color is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, you will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/249c8656-1962-4bf7-abdf-4742c051434e.png)'
  prefs: []
  type: TYPE_IMG
- en: Great work! Now, let's proceed to a short summary to conclude the topics you
    have learnt about while reading the current chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have just completed the chapter related to one of the most important data
    structures available while developing applications, namely graphs. As you have
    learnt, a graph is a data structure that consists of nodes and edges. Each edge
    connects two nodes. What is more, there are various variants of edges in a graph,
    such as undirected and directed, as well as unweighted and weighted. All of them
    have been described and explained in detail, together with diagrams and code samples.
    Two methods of graph representation, namely using an adjacency list and an adjacency
    matrix, have been explained as well. Of course, you have also learnt how to implement
    a graph using the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: While talking about graphs, is also important to present some real-world applications,
    especially due to the common use of such a data structure. For example, the chapter
    contains the description of the structure of friends available in social media
    or the problem of searching for the shortest path in a city.
  prefs: []
  type: TYPE_NORMAL
- en: Among the topics in this chapter, you have got to know how to traverse a graph,
    that is, visit all of the nodes in some particular order. Two approaches have
    been presented, namely DFS and BFS. It is worth mentioning that the traversal
    topic can be also applied for searching for a given node in a graph.
  prefs: []
  type: TYPE_NORMAL
- en: In one of the other sections, the subject of a spanning tree, as well as a minimum
    spanning tree, was introduced. As a reminder, a spanning tree is a subset of edges
    that connects all nodes in a graph without cycles, while a MST is a spanning tree
    with the minimum cost from all spanning trees available in the graph. There are
    a few approaches to finding the MST, including the application of Kruskal's or
    Prim's algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learnt solutions for the next two popular graph-related problems.
    The first was the coloring of nodes, where you needed to assign colors (numbers)
    to all nodes to comply with the rule that there cannot be an edge between two
    nodes with the same color. Of course, the number of colors should have been as
    low as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The other problem was searching for the shortest path between two nodes, which
    took into account a specific cost, such as the distance, the necessary time, or
    even the amount of fuel required. There are several approaches to the topic of
    searching for the shortest path in a graph. However, one of the common solutions
    is Dijkstra's algorithm, which makes it possible to calculate the distance from
    a starting node to all nodes located in the graph. This topic has been presented
    and explained within this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is the high time to proceed to the overall summary to take a look at
    all of the data structures and algorithms that have been presented in the book
    so far. Let's turn the page and proceed to the last chapter!
  prefs: []
  type: TYPE_NORMAL
