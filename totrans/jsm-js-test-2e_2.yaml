- en: Chapter 2. Your First Spec
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about the basics, and we are going to guide you through how
    to write your first spec, think in test-first terms for development, and also
    show you all the available global Jasmine functions. By the end of the chapter,
    you should know how Jasmine works and be ready to start doing your first tests
    by yourself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The Investment Tracker application
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get you started, we need an example scenario: consider that you are developing
    an application to track investments in the stock market.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot of the form illustrates how a user might create a
    new investment on this application:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![The Investment Tracker application](graphics/B04138_02_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: This is a form to add investments
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'This form will allow the input of three values that define an investment:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: First, we will input **Symbol**, which represents which company (stock) the
    user is investing in
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we will input how many **Shares** the user has bought (or invested in)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will input how much the user has paid for each share (**Share price**)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are unfamiliar with how the stock market works, imagine you are shopping
    for groceries. To make a purchase, you must specify what you are buying, how many
    items you are buying, and how much you are going to pay. These concepts translate
    to an investment as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: A stock, which is defined by a symbol, such as `PETO`, can be understood to
    be a grocery type
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of shares is the quantity of items you have purchased
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The share price is the unit price of each item
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the user has added an investment, it must be listed along with their other
    investments, as shown in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![The Investment Tracker application](graphics/B04138_02_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: This is a form and list of investments
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to display how well their investments are going. Since the prices
    of the stocks fluctuate over time, the difference between the price the user has
    paid and the current price indicates whether it is a good (profit) or a bad (loss)
    investment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we can see that the user has two investments:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: One is in the `AOUE` stock, which is scoring a profit of `101.80%`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another is in the `PETO` stock, which is scoring a loss of `-42.34%`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a very simple application, and we will get a deeper understanding of
    its functionality as we go on with its development.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine basics and thinking in BDD
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the application presented previously, we can start writing acceptance
    criteria that define investment:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Given an investment, it should be of a stock
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given an investment, it should have the invested shares' quantity
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given an investment, it should have the share price paid
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given an investment, it should have a cost
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the standalone distribution downloaded in the previous chapter, the first
    thing we need to do is create a new spec file. This file can be created anywhere,
    but it is a good idea to stick to a convention, and Jasmine already has a good
    one: specs should be in the `/spec` folder. Create an `InvestmentSpec.js` file
    and add the following lines:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `describe` function is a global Jasmine function used to define test contexts.
    When used as the first call in a spec, it creates a new test suite (a collection
    of test cases). It accepts two parameters, which are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The name of the test suite—in this case, `Investment`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `function` that will contain all its specs
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, to translate the first acceptance criterion (given an investment, it
    should be of a stock) into a Jasmine spec (or test case), we are going to use
    another global Jasmine function called `it`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It also accepts two parameters, which are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The title of the spec—in this case, `should be of a stock`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that will contain the spec code
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run this spec, add it to the runner, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Execute the spec by opening the runner on the browser. The following output
    can be seen:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: This is the first spec's passing result on the browser
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: It might sound strange to have an empty spec passing, but in Jasmine, as with
    other test frameworks, a failed assertion is required to make the spec fail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: An **assertion** (or expectation) is a comparison between two values that must
    result in a boolean value. The assertion is only considered a success if the result
    of the comparison is true.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In Jasmine, assertions are written using the global Jasmine function `expect`,
    along with a **matcher** that indicates what comparison must be made with the
    values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the current spec (it is expected that the investment is of a stock),
    in Jasmine this translates to the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Add the preceding highlighted code to the `InvestmentSpec.js` file. The `expect`
    function takes only one parameter, which defines the **actual value**, or in other
    words, what is going to be tested—`investment.stock`—and expects the chaining
    call to a matcher function, which in this case is `toBe`. That defines the **expected
    value**, `stock`, and the comparison method to be performed (to be the same).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, Jasmine makes a comparison to check whether the actual value
    (`investment.stock`) and expected value (`stock`) are the same, and if they are
    not, the test fails.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'With the assertion written, the spec that previously passed has now failed,
    as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: This shows the first spec's failure results
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: This spec failed because, as the error message states, `investment is not defined`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea here is to do only what the error is indicating us to do, so although
    you might feel the urge to write something else, for now let''s just create this
    `investment` variable with an `Investment` instance in the `InvestmentSpec.js`
    file, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Don''t worry that the `Investment()` function doesn''t exist yet; the spec
    is about to ask for it on the next run, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Here the spec asks for an Investment class
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the error has changed to `Investment is not defined`. It now
    asks for the `Investment` function. So, create a new `Investment.js` file in the
    `src` folder and add it to the runner, as shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To define `Investment`, write the following constructor function in the `Investment.js`
    file inside the `src` folder:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This makes the error change. It now complains about the missing `stock` variable,
    as shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: This shows a missing stock error
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'One more time, we feed the code it is asking for into the `InvestmentSpec.js`
    file, as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The error changes again; this time it is about the missing `Stock` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_07.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: Here the spec asks for a Stock class
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in the `src` folder, name it `Stock.js`, and add it to the
    runner. Since the `Stock` function is going to be a dependency of `Investment`,
    we should add it just before `Investment.js`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Write the `Stock` constructor function to the `Stock.js` file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, the error is about the expectation, as shown in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: The expectation is undefined to be Stock
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this and complete this exercise, open the `Investment.js` file inside
    the `src` folder, and add the reference to the `stock` parameter:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the spec file, pass `stock` as a parameter to the `Investment` function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, you will have a passing spec:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: This shows an Investment spec that passes
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: This exercise was meticulously conducted to show how a developer works by feeding
    the spec with what it wants when doing test-first development.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The drive to write code must come from a spec that has failed. You must not
    write code unless its purpose is to fix a failed spec.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Setup and teardown
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three more acceptance criteria to be implemented. The next in the
    list is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '"Given an investment, it should have the invested shares'' quantity."'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing it should be as simple as the previous spec was. In the `InvestmentSpec.js`
    file inside the `spec` folder, you can translate this new criterion into a new
    spec called `should have the invested shares'' quantity`, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see that apart from having written the new spec, we have also changed
    the call to the `Investment` constructor to support the new `shares` parameter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we used an object as a single parameter in the constructor to simulate
    named parameters, a feature JavaScript doesn't have natively.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing this in the `Investment` function is pretty simple—instead of
    having multiple parameters on the function declaration, it has only one, which
    is expected to be an object. Then, the function probes each of its expected parameters
    from this object, making the proper assignments, as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code is now refactored. We can run the tests to see that only the new spec
    fails, as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Setup and teardown](graphics/B04138_02_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: This shows the failing shares spec
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, change the `Investment` constructor to make the assignment to
    the `shares` property, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, everything on your screen is green:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Setup and teardown](graphics/B04138_02_11.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: This shows the passing shares spec
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'But as you can see, the following code, which instantiates `Stock` and `Investment`,
    is duplicated on both specs:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To eliminate this duplication, Jasmine provides another global function called
    `beforeEach` that, as the name states, is executed once before each spec. So,
    for these two specs, it will run twice—once before each spec.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactor the previous specs by extracting the setup code using the `beforeEach`
    function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This looks much cleaner; we not only removed the code duplication, but also
    simplified the specs. They became much easier to read and maintain since their
    only responsibility now is to fulfill the expectation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: There is also a **teardown** function (`afterEach`) that sets the code to be
    executed after each spec. It is very useful in situations where a cleanup is required
    after each spec. We will see an example of its application in [Chapter 6](ch06.html
    "Chapter 6. Light Speed Unit Testing"), *Light Speed Unit Testing*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish the specification of `Investment`, add the remaining two specs to
    the `InvestmentSpec.js` file, inside the `spec` folder:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the specs to see them fail, as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Setup and teardown](graphics/B04138_02_12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: This shows the failing cost and price specs
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to fix them in the `Investment.js` file inside the `src`
    folder:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the specs for the last time to see them pass:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Setup and teardown](graphics/B04138_02_13.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: This shows all four Investment specs passing
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to always see a spec fail before writing the code to fix it;
    otherwise, how would you know that you really need to fix it? Imagine this as
    a way to test the test.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Nested describes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Nested describes** are useful when you want to describe similar behavior
    between specs. Suppose we want the following two new acceptance criteria:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Given an investment, when its stock share price valorizes, it should have a
    positive **return on investment** (**ROI**)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given an investment, when its stock share price valorizes, it should be a good
    investment
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both these criteria share the same behavior when the investment's stock share
    price valorizes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'To translate this into Jasmine, you can nest a call to the `describe` function
    inside the existing one in the `InvestmentSpec.js` file (I removed the rest of
    the code for the purpose of demonstration; it is still there):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It should behave just like the outer one, so you can add specs (`it`) and use
    the setup and teardown functions (`beforeEach`, `afterEach`).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Setup and teardown
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the setup and teardown functions, Jasmine respects the outer setup
    and teardown functions as well, so that they are run as expected. For each spec
    (`it`), the following actions are performed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine runs all setup functions (`beforeEach`) from the outside in
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jasmine runs a spec code (`it`)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jasmine runs all the teardown functions (`afterEach`) from the inside out
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we can add a setup function to this new `describe` function that changes
    the share price of the stock, so that it''s greater than the share price of the
    investment:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Coding a spec with shared behavior
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the shared behavior implemented, we can start coding the acceptance
    criteria described earlier. Each is, just as before, a call to the global Jasmine
    function `it`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After adding the missing functions to `Investment` in the `Investment.js` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can run the specs and see that they pass:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding a spec with shared behavior](graphics/B04138_02_14.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: This shows the nested describe specs pass
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Understanding matchers
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you've already seen plenty of usage examples for matchers and probably
    can feel how they work.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how to use the `toBe` and `toEqual` matchers. These are the two
    base built-in matchers available in Jasmine, but we can extend Jasmine by writing
    matchers of our own.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: So, to really understand how Jasmine matchers work, we need to create one ourselves.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Custom matchers
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider this expectation from the previous section:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Although it works, it is not very expressive. Imagine if we could instead rewrite
    it as:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This creates a much better relation with the acceptance criterion:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: So, here "should be a good investment" becomes "expect investment to be a good
    investment".
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Implementing it is quite simple. You do so by calling the `jasmine.addMatchers`
    function—ideally inside a setup step (`beforeEach`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Although you can put this new matcher definition inside the `InvestmentSpec.js`
    file, Jasmine already has a default place to add custom matchers, the `SpecHelper.js`
    file, inside the `spec` folder. If you are using Standalone Distribution, it already
    comes with a sample custom matcher; delete it and let's start from scratch.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The `addMatchers` function accepts a single parameter—an object where each
    attribute corresponds to a new matcher. So, to add the following new matcher,
    change the contents of the `SpecHelper.js` file to the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The function being defined here is not the matcher itself but a factory function
    to build the matcher. Its purpose, once called is to return an object containing
    a compare function, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `compare` function will contain the actual matcher implementation, and as
    can be observed by its signature, it receives both values being compared (the
    `actual` and `expected` values).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: For the given example, the `investment` object will be available in the `actual`
    argument.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Then, Jasmine expects, as the result of this `compare` function, an object with
    a `pass` attribute with a boolean value `true` to indicate that the expectation
    passes and `false` if the expectation fails.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following valid implementation of the `toBeAGoodInvestment`
    matcher:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By now, this matcher is ready to be used by the specs:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After the change, the specs should still pass. But what happens if a spec fails?
    What is the error message that Jasmine reports?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see it by deliberately breaking the `investment.isGood` implementation
    in the `Investment.js` file, in the `src` folder to always return `false`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When running the specs again, Jasmine generates an error message stating `Expected
    { stock: { sharePrice: 40 }, shares: 100, sharePrice: 20, cost: 2000 } to be a
    good investment`, as shown in the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom matchers](graphics/B04138_02_15.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: This is the custom matcher's message
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Jasmine does a great job generating this error message, but it also allows
    its customization via the `result.message` property of the object returned as
    the result of the matcher. Jasmine expects this property to be a string with the
    following error message:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the specs again and the error message should change:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom matchers](graphics/B04138_02_16.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: This is the custom matcher's custom message
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consider another acceptance criterion:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '"Given an investment, when its stock share price devalorizes, it should be
    a bad investment."'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to create a new custom matcher (`toBeABadInvestment`),
    Jasmine allows the negation of any matcher by chaining `not` before the matcher
    call. So, we can write that "a bad investment" is "not a good investment"
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement this new acceptance criterion in the `InvestmentSpec.js` file inside
    the `spec` folder by adding new and nested `describe` and `spec`, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But there is a catch! Let''s break the `investment` implementation in the `Investment.js`
    file code so that it is always a good investment, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After running the specs again, you can see that this new spec fails, but the
    error message, `Expected investment to be a good investment`, is wrong, as shown
    in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom matchers](graphics/B04138_02_17.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: This is the custom matcher's wrong custom negated message
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: That is the message that was hardcoded inside the matcher. To fix this, you
    need to make the message dynamic.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Jasmine only shows the message if the matcher fails, so the proper way of making
    this message dynamic is to consider what message is supposed to be shown when
    the given comparison is invalid:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This fixes the message, as shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom matchers](graphics/B04138_02_18.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: This shows the custom matcher's custom dynamic message
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Now this matcher can be used anywhere.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing in the chapter, change the `isGood` method back again to
    its correct implementation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'What this example lacked was a way to show how to pass an expected value to
    a matcher like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It turns out that a matcher can receive any number of expected values as parameters.
    So, for instance, the preceding matcher could be implemented in the `SpecHelper.js`
    file, inside the `spec` folder, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By implementing any matcher, check first whether there is one available that
    already does what you want.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: For more information, check the official documentation at the Jasmine website
    [http://jasmine.github.io/2.1/custom_matcher.html](http://jasmine.github.io/2.1/custom_matcher.html).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Built-in matchers
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jasmine comes with a bunch of default matchers covering the basis of value checking
    in the JavaScript language. To understand how they work and where to use them
    properly is a journey of how JavaScript handles type.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The toEqual built-in matcher
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `toEqual` matcher is probably the most commonly used matcher, and you should
    use it whenever you want to check equality between two values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'It works for all primitive values (number, string, and boolean) as well as
    any object (including arrays), as shown in the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The toBe built-in matcher
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `toBe` matcher has a very similar behavior to the `toEqual` matcher; in
    fact, it gives the same result while comparing primitive values, but the similarities
    stop there.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: While the `toEqual` matcher has a complex implementation (you should take a
    look at the Jasmine source code) that checks whether all attributes of an object
    and all elements of an array are the same, here it is a simple use of the **strict
    equals operator** (`===`).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with the strict equals operator, its main difference from
    the **equals operator** (`==`) is that the latter performs type coercion if the
    compared values aren't of the same type.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The strict equals operator always considers false any comparison between values
    of distinct types.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of how this matcher (and the strict equals operator)
    works:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is advised that you use the `toEqual` operator in most cases and resort to
    the `toBe` matcher only when you want to check whether two variables reference
    the same object.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The toBeTruthy and toBeFalsy matchers
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides its primitive boolean type, everything else in the JavaScript language
    also has an inherent boolean value, which is generally known to be either **truthy**
    or **falsy**.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily in JavaScript, there are only a few values that are identified as falsy,
    as shown in the following examples for the `toBeFalsy` matcher:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Everything else is considered truthy, as demonstrated by the following examples
    of the `toBeTruthy` matcher:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: But, if you want to check whether something is equal to an actual boolean value,
    it might be a better idea to use the `toEqual` matcher.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The toBeUndefined, toBeNull, and toBeNaN built-in matchers
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These matchers are pretty straightforward and should be used to check for `undefined`,
    `null`, and `NaN` values:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Both `toBeNull` and `toBeUndefined` can be written as `toBe(null)` and `toBe(undefined)`
    respectively, but that is not the case with `toBeNaN`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, the `NaN` value is not equal to any value, not even `NaN`. So,
    trying to compare it to itself is always `false`, as shown in the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As good practice, try to use these matchers instead of their `toBe` counterparts
    whenever possible.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The toBeDefined built-in matcher
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This matcher is useful if you want to check whether a variable is defined and
    you don''t care about its value, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Anything except `undefined` will pass under this matcher, even `null`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The toContain built-in matcher
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, it is desirable to check whether an array contains an element, or
    whether a string can be found inside another string. For these use cases, you
    can use the `toContain` matcher, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The toMatch built-in matcher
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although the `toContain` and `toEqual` matchers can be used in most string
    comparisons, sometimes the only way to assert whether a string value is correct
    is through a regular expression. For these cases, you can use the `toMatch` matcher
    along with a regular expression, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The matcher works by testing the actual value (`"My big matched string"`) against
    the expected regular expression (`/My(.+)string/`).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The toBeLessThan and toBeGreaterThan built-in matchers
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `toBeLessThan` and `toBeGreaterThan` matchers are simple and used to perform
    numeric comparisons—something that is best described by the following examples:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The toBeCloseTo built-in matcher
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is a special matcher used to compare floating-point numbers with a defined
    set of precision—something that is best explained by this example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first parameter is the number being compared, and the second is the precision
    in the number of decimal cases.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The toThrow built-in matcher
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Exceptions are a language's way of demonstrating when something goes wrong.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, while coding an API, you might decide to throw an exception
    when a parameter is passed incorrectly. So, how do you test this code?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine has the built-in `toThrow` matcher that can be used to verify that an
    exception has been thrown.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The way it works is a little bit different from the other matchers. Since the
    matcher has to run a piece of code and check whether it throws an exception, the
    matcher's **actual** value must be a function.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how it works:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When the test is run, the anonymous function is executed, and if it throws the
    `Some exception` exception, the test passes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to think in BDD and drive your code from your
    specs. You also became acquainted with the basic Jasmine global functions (`describe`,
    `it`, `beforeEach`, and `afterEach`) and have a good understanding of what is
    required to create a spec in Jasmine.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: You got familiar with Jasmine matchers and know how powerful they are in describing
    a spec intent. You even learned to create a matcher of your own.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be familiar with creating new specs and driving the development
    of your new application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经熟悉了创建新规范并推动新应用程序的开发。
- en: In the next chapter, we are going to take a look at how we can use the concepts
    learned in this chapter to start testing web applications, which are most commonly
    jQuery and HTML forms.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何利用本章学到的概念来开始测试Web应用程序，这些应用程序最常见的是jQuery和HTML表单。
