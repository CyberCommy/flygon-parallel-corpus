- en: Starting Mail Ape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll begin building Mail Ape, a mailing list manager that
    will let users start mailing lists, sign up for mailing lists, and then message
    people. Subscribers will have to confirm their subscription to a mailing list
    and be able to unsubscribe. This will help us to ensure that Mail Ape isn't used
    to serve spam to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will build the core Django functionality of Mail Ape:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll build models that describe Mail Ape, including `MailingList` and `Subscriber`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use Django's Class-Based Views to create web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use Django's built-in authentication functionality to let users log in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll make sure that only the owner of a `MailingList` model instance can email
    its subscribers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll create templates to generate the HTML to display the forms to subscribe
    and email to our users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll run Mail Ape locally using Django's built-in development server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this project is available online at [https://github.com/tomaratyn/MailApe](https://github.com/tomaratyn/MailApe).
  prefs: []
  type: TYPE_NORMAL
- en: Django follows the **Model View Template** (**MVT**) pattern to separate model,
    control, and presentation logic and encourage reusability. Models represent the
    data we'll store in the database. Views are responsible for handling a request
    and returning a response. Views should not have HTML. Templates are responsible
    for the body of a response and defining the HTML. This separation of responsibilities
    has proven to make it easy to write code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating the Mail Ape project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Mail Ape project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create the MailApe project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All the paths in this part of the book will be relative to this directory.
  prefs: []
  type: TYPE_NORMAL
- en: Listing our Python dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s create a `requirements.txt` file to track our Python dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know our requirements, we can install them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the following four libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Django`: Our favorite web app framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`psycopg2`: The Python PostgreSQL library; we''ll use PostgreSQL in both production
    and development'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-markdownify`: A library that makes it easy to render markdown in a
    Django template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-crsipy-forms`: A library that makes it easy to create Django forms
    in templates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Django installed, we can use the `django-admin` utility to create our project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Django project and apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Django project is composed of a configuration directory and one or more Django
    apps. The actual functionality of a project is encapsulated by the installed apps.
    By default, the configuration directory is named after the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'A web app is often composed of much more than just the Django code that is
    executed. We need configuration files, system dependencies, and documentation.
    To help future developers (including our future selves), we will strive to label
    each directory clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this approach, our directory structure is clear about the location of our
    Django code and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create the apps that will encapsulate our functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For each app, we should create a URLConf. A URLConf ensures that requests get
    routed to the right view. A URLConf is a list of paths, the view that serves the
    path, and the name for the path. One great thing about URLConfs is that they can
    include each other. When a Django project is created, it gets a root URLConf (ours
    is at `django/config/urls.py`). Since a URLConf may include other URLConfs, the
    name provides a vital way to reference a URL path to a view without knowing the
    full URL path to the view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our app's URLConfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a URLConf for the `mailinglist` app in `django/mailinglist/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `app_name` variable is used to scope the paths in case of name collisions.
    When resolving a pathname, we can prefix it with `mailinglist:` to ensure that
    it's from this app. As we build our views, we'll add `path` s to the `urlpatterns`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create another URLConf in the `user` app by creating `django/user/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now, let''s include them in the root ULRConf that''s located in `django/config/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The root URLConf is just like our app''s URLConfs. It has a list of `path()` objects.
    The `path()` objects in the root URLConfs usually don''t have views but `include()`
    other URLConfs. Let''s take a look at the two new functions here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path()`: This takes a string and either a view or the result of `include()`.
    Django will iterate over the `path()`s in a URLConf until it finds one that matches
    the path of a request. Django will then pass the request to that view or URLConf.
    If it''s a URLConf, then that list of `path()`s is checked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include()`: This takes a URLConf and a namespace name. A namespace isolates
    a URLConfs from each other so that we can prevent name collisions, ensuring that
    we can differentiate `appA:index` from `appB:index`. `include()` returns a tuple;
    the object at `admin.site.urls` has been already a correctly formatted tuple,
    so we don''t have to use `include()`. Generally, we always use `include()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Django can't find a `path()` object that matches a request's path, then it
    will return a 404 response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this URLConf is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Any request starting with `admin/` will be routed to the admin app's URLConf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any request starting with `mailinglist/` will be routed to the `mailinglist`
    app's URLConf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any request starting with `user/` will be routed to the `user` app's URLConf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing our project's apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s update `django/config/settings.py` to install our apps. We''ll change
    the `INSTALLED_APPS` setting as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our project and apps configured, let's create models for our
    `mailinglist` app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the mailinglist models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll create the models for our `mailinglist` app. Django
    provides a rich and powerful ORM that will let us define our models in Python
    without having to deal with the database directly. The ORM converts our Django
    classes, fields, and objects into relational database concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: A model class maps to a relational database table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A field maps to a relational database column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A model instance maps to a relational database row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each model also comes with a default manager available in the `objects` attribute.
    A manager provides a starting point for running queries on a model. One of the
    most important methods a manager has is `create()`. We can use `create()` to create
    an instance of the model in our database. A manager is also the starting point
    to get a `QuerySet` for our model.
  prefs: []
  type: TYPE_NORMAL
- en: A `QuerySet` represents a database query for models. `QuerySet`s are lazy and
    only execute when they're iterated or converted to a `bool`. A `QuerySet` API
    offers most the functionality of SQL without being tied a particular database.
    Two particularly useful methods are `QuerySet.filter()` and `QuerySet.exclude()`.
    `QuerySet.filter()` lets us filter the results of the `QuerySet` to only those
    matching the provided criteria. `QuerySet.exclude()` lets us exclude results that
    don't match the criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the first model, `MailingList`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MailingList model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `MailingList` model will represent a mailing list that one of our users
    has created. This will be an important model for our system because many other
    models will be referring to it. We can also anticipate that the `id` of a `MailingList` will
    have to be publicly exposed in order to relate subscribers back to it. To avoid
    letting users enumerate all the mailing lists in Mail Ape, we want to make sure
    that our `MailingList` IDs are nonsequential.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our `MailingList` model to `django/mailinglist/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at our `MailingList` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class MailingList(models.Model):`: All Django models must inherit from the
    `Model` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id = models.UUIDField`: This is the first time we''ve specified the `id` field
    for a model. Usually, we let Django provide one for us automatically. In this
    case, we wanted nonsequential IDs, so we used a field that provides **Universally
    Unique Identifiers** (**UUIDs**). Django will create the proper database field
    when we generate the migrations (refer to the *Creating database migrations* section).
    However, we have to generate the UUID in Python. To generate new UUIDs for each
    new model, we used the `default` argument and Python''s `uuid4` function. To tell
    Django that our `id` field is the primary key, we used the `primary_key` argument.
    We further passed `editable=False` to prevent changes to the `id` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name = models.CharField`: This will represent the mailing list''s name. A
    `CharField` will get converted to a `VARCHAR` column, so we must provide it with
    a `max_length` argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`owner = models.ForeignKey`: This is a foreign key to Django''s user model.
    In our case, we will use the default `django.contrib.auth.models.User` class.
    We follow the Django best practice of avoiding hardcoding this model. By referencing
    `settings.AUTH_USER_MODEL`, we don''t couple our app to the project too tightly.
    This encourages future reuse. The `on_delete=models.CASCADE` argument means that
    if a user is deleted, all their `MailingList` model instances will be deleted
    too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def __str__(self)`: This defines how to convert a mailing list to a `str`.
    Both Django and Python will use this when a `MailingList` needs to be printed
    out or displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def get_absolute_url(self)`: This is a common method on Django models. `get_absolute_url()`
    returns a URL path that represents the model. In our case, we return the management
    page for this mailing list. We don''t hardcode the path. Instead, we use `reverse()`
    to resolve the path at runtime by providing the name of the URL. We''ll look at
    named URLs in the *Creating the URLConf* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def user_can_use_mailing_list(self, user)`: This is a method we''ve added
    for our own convenience. It checks whether a user can use (meaning view-related
    items and/or send messages) to this mailing list. Django''s *Fat models* philosophy
    encourages placing code for decisions like this in models rather than in views.
    This gives us a central place for decisions, ensuring that you **Don''t Repeat
    Yourself** (**DRY**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have our `MailingList` model. Next, let's create a model to capture the
    mailing list's subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Subscriber model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create a `Subscriber` model. A `Subscriber` model can
    only belong to one `MailingList` and must confirm their subscription. Since we'll
    need to reference a subscriber for their confirm and unsubscribe pages, we'll
    want their `id` instance to also be nonsequential.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `Subscriber` model in `django/mailinglist/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Subscriber` model has some similarities to the `MailingList` model. The
    base class and `UUIDField` function the same. Let''s take a look at some of the
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`models.EmailField()`: This is a specialized `CharField` but does extra validation
    to ensure that the value is a valid email address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.BooleanField(default=False)`: This lets us store `True`/`False` values.
    We need to use to this to track whether a user really intends to subscribe to
    a mailing list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.ForeignKey(to=MailingList...)`: This lets us create a foreign key between
    `Subscriber` and `MailingList` model instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique_together`: This is an attribute of the `Meta` inner class of `Subscriber`.
    A `Meta` inner class lets us specify information on the table. For example, `unique_together`
    lets us add an additional unique constraint on a table. In this case, we prevent
    a user from signing up twice with the same email.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we can track `Subscriber` model instances, let's track the messages
    our users want to send to their `MailingList`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Message model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our users will want to send messages to their `Subscriber` model instances of
    `MailingList`. In order to know what to send to these subscribers, we will need
    to store the messages as a Django model.
  prefs: []
  type: TYPE_NORMAL
- en: A `Message` should belong to a `MailingList` and have a nonsequential `id`.
    We need to save the subject and body of these messages. We will also want to track
    when the sending began and completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `Message` model to `django/mailinglist/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the `Message` model is very similar to our preceding models in its base
    class and fields. We do see some new fields in this model. Let''s take a closer
    look at these new fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`models.TextField()`: This is used to store arbitrarily long character data.
    All major databases have a `TEXT` column type. This is useful to store the `body` attribute
    of our user''s `Message`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.DateTimeField(default=None, null=True)`: This is used to store date
    and time values. In Postgres, this becomes a `TIMESTAMP` column. The `null` argument
    tells Django that this column should be able to accept a `NULL` value. By default,
    all fields have a `NOT NULL` constraint on them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have our models. Let's create them in our database with database migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Using database migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Database migrations describe how to get a database to a particular state. In
    this section, we will do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a database migration for our `mailinglist` app models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the migration on a Postgres database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we make a change to our models, we can have Django generate the code for
    creating those tables, fields, and constraints. The migrations that Django generates
    are created using an API that is also available to Django developers. If we need
    to do a complicated migration, we can write a migration ourselves. Remember that
    a proper migration includes code for both applying and reverting a migration.
    If there's a problem, we want to have a way to undo our migration. When Django
    generates a migration, it always generates both migrations for us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by configuring Django to connect to our PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure Django to connect to our Postgres database, we will need to update
    the `DATABASES` setting in `django/config/settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You should not hardcode the password to a production database in your `settings.py` file.
    If you're connecting to a shared or online instance, set the username, password,
    and host using environment variables and access them using `os.getenv()`, like
    we did in our previous production deployment chapters ([Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml), *Deploying
    with Docker*, and [Chapter 9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml), *Deploying
    Answerly*).
  prefs: []
  type: TYPE_NORMAL
- en: Django cannot create a database and users by itself. We must do that ourselves.
    You can find a script for doing this in the code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create the migrations for models.
  prefs: []
  type: TYPE_NORMAL
- en: Creating database migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create our database migrations, we will use the `manage.py` script that
    Django put at the top of the Django project (`django/manage.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now that we have the migrations, we can run them on our local development
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Running database migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use `manage.py` to apply our database migrations to a running database.
    On the command line, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When we run `manage.py migrate` without providing an app, it will run all migrations
    on all installed Django apps. Our database now has the tables for the `mailinglist`
    app models and the `auth` app's models (including the `User` model).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our models and database set up, let's make sure that we can
    validate the user's input for these models using Django's forms API.
  prefs: []
  type: TYPE_NORMAL
- en: MailingList forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the common issues that developers have to solve is how to validate a
    user input. Django provides input validation through its forms API. The forms
    API can be used to describe an HTML form using an API very similar to the models
    API. If we want to create a form that describes a Django model, then the Django
    form's `ModelForm` offers us a shortcut. We only have to describe what we're changing
    from the default form representation for the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a Django form is instantiated, it can be provided with any of the three
    following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`: The raw input that the end users request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initial`: The known safe initial values that we may set for a form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instance`: The instance the form is describing, only on `ModelForm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a form has been provided `data`, then it is called a bound form. Bound forms
    can validate their `data` by calling `is_valid()`. A validated form's safe-to-use
    data is available under the `cleaned_data` dictionary (keyed on the field's name).
    Errors are available via the `errors` property, which returns a dictionary. A
    bound `ModelForm` can also create or update its model instance with the `save()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Even if none of the arguments are provided, a form is still able to print itself
    out as HTML, making our templates much simpler. This mechanism helps us achieve
    the goal of *dumb templates*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start creating our forms by creating the `SubscriberForm` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Subscriber form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important task Mail Ape must perform is to accept emails of a new `Subscriber` for
    a `MailingList`. Let's create a form to do that validation for us.
  prefs: []
  type: TYPE_NORMAL
- en: '`SubscriberForm` must be able to validate input as a valid email. We also want
    it to save our new `Subscriber` model instance and associate it with the proper
    `MailingList` model instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create that form in `django/mailinglist/forms.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at our `SubscriberForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class SubscriberForm(forms.ModelForm):`: This shows that our form is derived
    from `ModelForm`. `ModelForm` knows to check our inner `Meta` class for information
    on the model and fields that can be used as the basis of this form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mailing_list = forms.ModelChoiceField`: This tells our form to use our custom
    configured `ModelChoiceField` instead of the default that the forms API would
    use. By default, Django will show a `ModelChoiceField` that would render as a
    drop-down box. A user could use the dropdown to pick the associated model. In
    our case, we don''t want the user to be able to make that choice. When we show
    a rendered `SubscriberForm`, we want it be configured for a particular mailing
    list. To this end, we change the `widget` argument to be a `HiddenInput` class
    and mark the field as `disabled`. Our form needs to know the `MailingList` model
    instances that are valid for this form. We provide a `QuerySet` object that matches
    all `MailingList` model instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model = Subscriber`: This tells the form''s `Meta` inner class that this form
    is based on the `Subscriber` model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields = [''mailing_list'', ''email'', ]`: This tells the form to only include
    the following fields from the model in the form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's make a form for capturing the `Message`s that our users want to
    send to their `MailingList`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Message Form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our users will want to send `Message`s to their `MailingList`s. We'll provide
    a web page with a form where users can create these messages. Before we can create
    the page, let's create the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our `MessageForm` class to `django/mailinglist/forms.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed in the preceding code, `MessageForm` works just like
    `SubscriberFrom`. The only difference is that we've listed a different model and
    different fields in the `Meta` inner class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create the `MailingListForm` class, which we'll use to accept input
    for the name of the mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MailingList form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll create a `MailingListForm`, which will accept the name and owner
    of a mailing list. We will use the same `HiddenInput` and `disabled` field pattern
    as before but this time on the `owner` field. We want to make sure that a user
    can't change the owner of the mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our form to `django/mailinglist/forms.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `MailingListForm` is very similar to our previous forms, but introduces
    a new function, `get_user_model()`. We need to use `get_user_model()` because
    we don't want to couple ourselves to a particular user model, but we need access
    to that model's manager to get a `QuerySet`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our forms, we can create the views for our `mailinglist` Django
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating MailingList views and templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we created forms that we can use to collect and validate
    user input. In this section, we will create the views and templates that actually
    communicate with the user. A template defines the HTML of a document.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, a Django view is a function that accepts a request and returns
    a response. While we won't be using these **Function-Based Views** (**FBVs**)
    in this book, it's important to remember that all a view needs to do is meet those
    two responsibilities. If processing a view also causes another action to occur
    (for example, sending an email), then we should put that code in a service module
    rather than directly in the view.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the work that web developers face is repetitive (for example, processing
    a form, showing a particular model, listing all instances of that model, and so
    on). Django's battery included philosophy means that it includes tools to make
    these kinds of repetitive tasks easier.
  prefs: []
  type: TYPE_NORMAL
- en: Django makes common web developer tasks easier by offering a rich suite of **class-based
    views** (**CBVs**). CBVs use the principles of **Object-Oriented Programming**
    (**OOP**) to increase code reuse. Django comes with a rich suite of CBVs that
    makes it easy to process a form or show an HTML page for a model instance.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML view returns come from rendering a template. Templates in Django are
    generally written in Django's template language. Django can also support other
    template languages (for example, Jinja). Generally, each view is associated with
    a template.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating some resources many of our views will need.
  prefs: []
  type: TYPE_NORMAL
- en: Common resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create some common resources that our views and templates
    will need:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a base template, which all our other templates can extend. Using
    the same base template across all our pages will give Mail Ape a unifying look
    and feel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll create a `MailingListOwnerMixin` class, which will let us protect mailing
    lists messages from unauthorized access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by creating a base template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a base template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a base template for Mail Ape. This template will be used by all
    our pages to give our entire web app a consistent look.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Django template language** (**DTL**) lets us write our HTML (or other
    text-based format) and lets us use *tags*, *variables*, and *filters* to execute
    code to customize the HTML. Let''s take a closer look at those three concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*tags*: They are surrounded by `{% %}` and may (`{% block body%}{% endblock
    %}`) or may not (`{% url "myurl" %}`) contain a body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*variables*: They are surrounded by `{{ }}` and must be set in the template''s
    context (for example, `{{ mailinglist }}`). Though DTL variables are like Python
    variables, there are differences. The two most critical ones are around executables
    and dictionaries. Firstly, DTL does not have a syntax to pass arguments to an
    executable (you never have to use `{{foo(1)}}`). If  you reference a variable
    and it is callable (for example, a function), then the Django template language
    will call it and return the result (for example, `{{mailinglist.get_absolute_url}}`).
    Secondly, DTL doesn''t distinguish among object attributes, items in a list, and
    items in a dictionary. All three are accessed using a dot: `{{mailinglist.name}}`,
    `{{mylist.1}}`, and `{{mydict.mykey}}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*filters*: They follow a variable and modify its value (for example, `{{ mailinglist.name
    | upper}}` will return the mailing lists'' name in uppercase).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll take a look at examples of all three as we continue creating Mail Ape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a common templates directory—`django/templates`—and put our template
    in `django/templates/base.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In our base template, we will note examples of the following three tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{% url ... %}`: This returns the path to a view. This works just like the
    `reverse()` function we saw earlier but in a Django template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% if ... %} ... {% else %} ... {% endif %}`: This works just like a Python
    developer would expect. The `{% else %}` clause is optional. The Django template
    language also supports `{% elif ... %}` if we need to choose among multiple choices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% block ... %}`: This defines a block that a template, which extends `base.html`,
    can replace with its own content. We have two blocks, `body` and `title`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have a base template that our other templates can use by just providing
    body and title blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our template, we have to tell Django where to find it. Let's
    update `django/config/settings.py` to let Django know about our new `django/templates`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `django/config/settings.py`, find the line that starts with `Templates`.
    We will need to add our `templates` directory to the list under the `DIRS` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Django lets us avoid hardcoding the path to `django/templates` by calculating
    the path to `django` at runtime as `BASE_DIR`. This way, we can use the same setting
    across environments.
  prefs: []
  type: TYPE_NORMAL
- en: Another important setting we just saw was `APP_DIRS`. This setting tells Django
    to check each installed app for a `templates` directory when Django is looking
    for a template. It means that we don't have to update the `DIRS` key for each
    installed app and lets us isolate our templates under our apps (increasing reusability).
    Finally, it's important to remember that apps are searched in the order they appear
    in `INSTALLED_APPS`. If there's a template name collision (for example, two apps
    provide a template called `registration/login.html`), then the one listed first
    in `INSTALLED_APPS` will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's configure our project to use Bootstrap 4 when rendering forms in
    HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Django Crispy Forms to use Bootstrap 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our base template, we included the Bootstrap 4 css template. To make it easy
    to render a form and style it using Bootstrap 4, we will use a third-party Django
    app called Django Crispy Forms. However, we must configure Django Crispy Forms
    to tell it to use Bootstrap 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new setting to the bottom of `django/config/settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, Django Crispy Forms is configured to use Bootstrap 4 when rendering a form.
    We'll take a look at it later in this chapter, in sections covering rendering
    a form in a template.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create a mixin that ensures that only the owners of a mailing list
    can affect them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mixin to check whether a user can use the mailing list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django uses **class-based views** (**CBVs**) to make it easier to reuse code,
    simplifying repetitive tasks. One of the repetitive tasks we'll have to do in
    the `mailinglist` app is protect `MailingList` s and their related models from
    being tampered with by other users. We’ll create a mixin that provides protection.
  prefs: []
  type: TYPE_NORMAL
- en: A mixin is a class that provides a limited functionality that is meant to be
    used in conjunction with other classes. We've previously seen the `LoginRequired`
    mixin, which can be used in conjunction with a view class to protect a view from
    unauthenticated access. In this section, we will create a new mixin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `UserCanUseMailingList` mixin in a new file at `django/mailinglist/mixins.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our class defines a single method, `get_object(self, queryset=None)`. This method
    has the same signature as `SingleObjectMixin.get_object()`, which is used by many
    of Django's built-in CBVs (for example, `DetailView`). Our `get_object()` implementation
    doesn't do any work to retrieve an object. Instead, our `get_object` just checks
    the object that a parent retrieved to check whether it is, or has, a `MailingList`
    and confirms that the logged in user can use the mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: One surprising thing about a mixin is that it relies on a super class but doesn't
    inherit from one. In `get_object()`, we explicitly call `super()`, but `UserCanUseMailingList`
    doesn't have any base classes. Mixin classes aren't expected to be used by themselves.
    Instead, they will be used by classes, which subclass them *and* one or more other
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: We'll take a look at how this works in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating MailingList views and templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll take a look at the views that will process the user's requests and
    return responses that show a UI created from our templates.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a view to list of all our `MailingList`s.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MailingListListView view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a view that shows the mailing lists a user owns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `MailingListListView` in `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our view is derived from two views, `LoginRequiredMixin` and `ListView`. `LoginRequiredMixin`
    is a mixin that ensures that a request made by an unauthenticated user is redirected
    to a login view instead of being processed. To help the `ListView` know *what*
    to list, we will override the `get_queryset()` method and return a `QuerySet`
    that includes only the `MailingList` s owned by the currently logged in user.
    To display the result, `ListView` will try to render a template at `appname/modelname_list.html`.
    In our case, `ListView` will try to render `mailinglist/mailinglist_list.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create that template in `django/mailinglist/templates/mailinglist/mailinglist_list.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our template extends `base.html`. When a template extends another template,
    it can only put HTML into the `block`s that have been previously defined. We will
    also see a lot of new Django template tags. Let''s take a closer look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{% extends "base.html" %}`: This tells the Django template language which
    template that we''re extending.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% block title %}… {% endblock %}`: This tells Django that we''re providing
    new code that it should place in the extended template''s `title` block. The previous
    code in that block (if any) is replaced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% for mailinglist in mailinglist_list %} ... {% endfor %}`: This provides
    a for loop for each item in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% url … %}`: The `url` tag will produce a URL path for the named `path`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% url ... pk=...%}`: This works just like the preceding point, but, in some
    cases, a `path` may take arguments (for example, the primary key of the `MailingList`
    to display). We can specify these extra arguments in the `url` tag after the name
    of the `path`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have a view and template that work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step with any view is adding the app''s URLConf to it. Let''s update
    `django/mailinglist/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Given how we configured our root URLConf earlier, any request sent to `/mailinglist/`
    will be routed to our `MailingListListView`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add a view to create new `MailingList`s.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CreateMailingListView and template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a view to create mailing lists. When our view receives a `GET`
    request, the view will show our users a form for entering the name of the mailing
    list. When our view receives a `POST` request, the view will validate the form
    and either redisplay the form with errors or create the mailing list and redirect
    the user to the list's management page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the view now in `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`CreateMailingListView` is derived from two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginRequiredMixin` redirects requests that are not associated with a logged
    in user from being processed (we''ll configure this later in this chapter, in
    the *Creating the user app* section)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateView` knows how to work with the form indicated in `form_class` and
    render it using the template listed in `template_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateView` is the class that does most of the work here without us needing
    to provide almost any extra information. Processing a form, validating it, and
    saving it are always the same, and `CreateView` has the code to do it. If we need
    to change some of the behavior, we can override one for the hooks that `CreateView`
    provides, as we do with `get_initial()`.'
  prefs: []
  type: TYPE_NORMAL
- en: When `CreateView` instantiates our `MailingListForm`, `CreateView` calls its
    `get_initial()` method to get the `initial` data (if any) for the form. We use
    this hook to make sure that the form's owner is set to the logged in user's `id`.
    Remember that `MailingListForm` has its `owner` field disabled, so the form will
    ignore any data provided by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create the template for our `CreateView` in `django/mailinglist/templates/mailinglist/mailinglist_form.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our template extends `base.html`. When a template extends another template,
    it can only put HTML into the blocks that have been previously defined by the
    extended template(s). We also take a lot of new Django template tags. Let''s take
    a closer look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{% load crispy_forms_tags %}`: This tells Django to load a new template tag
    library. In this case, we will load `crispy_from_tags` from the Django Crispy
    Forms app that we have installed. This provides us with the `crispy` filter we''ll
    see later in this section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% csrf_token %}`: Any form that Django processes must have a valid CSRF token
    to prevent CSRF attacks (refer to [Chapter 3](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml),
    *Posters, Headshots, and Security*). The `csrf_token` tag returns a hidden input
    tag with the correct CSRF token. Remember that Django generally won''t process
    a POST request without a CSRF Token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{ form | crispy }}`: The `form` variable is a reference to the form instance
    that our view is processing and is passed into this template''s context by our
    `CreateView`. `crispy` is a filter provided by the `crispy_form_tags` tag library
    and will output the form using HTML tags and CSS classes used in Bootstrap 4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have a view and template that work together. The view is able to use
    the template to create a user interface to enter data into the form. The view
    is then able to process the form’s data and create a `MailingList` model from
    valid form data or redisplay the form if the data has a problem. The Django Crispy
    Forms library renders the form using the HTML and CSS from the Bootstrap 4 CSS
    Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add our view to the `mailinglist` app''s URLConf. In `django/mailinglist/urls.py`,
    let''s add a new `path()` object to the URLConf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Given how we configured our root URLConf earlier, any request sent to `/mailinglist/new`
    will be routed to our `CreatingMailingListView`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's make a view to delete a `MailingList`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the DeleteMailingListView view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users will want to delete `MailingList` s after they stop being useful. Let's
    create a view that will prompt the user for confirmation on a `GET` request and
    delete the `MailingList` on a `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add our view to `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at the classes that `DeleteMailingListView` is derived
    from:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginRequiredMixin`: This serves the same function as in the preceding code,
    ensuring that requests from an unauthenticated user aren''t processed. The user
    is just redirected to the login page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserCanUseMailingList`: This is the mixin we created in the preceding code.
    `DeleteView` uses the `get_object()` method to retrieve the model instance to
    be deleted. By mixing `UserCanUseMailingList` into the `DeleteMailingListView`
    class, we protect each user''s `MailingList`s from being deleted by unauthorized
    users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteView`: This is a Django view that knows how to render a confirmation
    template on a `GET` request and delete the related model on `POST`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order for Django's `DeleteView` to function properly, we will need to configure
    it properly. `DeleteView` knows which model to delete from its `model` attribute.
    `DeleteView` requires that we provide a `pk` argument when we route requests to
    it. To render the confirmation template, `DeleteView` will try to use `appname/modelname_confirm_delete.html`.
    In the case of `DeleteMailingListView`, the template will be `mailinglist/mailinglist_confirm_delete.html`.
    If the model is successfully deleted, then `DeleteView` will redirect to the `success_url` value.
    We've avoided hardcoding the `success_url` and instead used `reverse_lazy()` to
    refer to the URL by name. The `reverse_lazy()` function returns a value that won't
    resolve until it's used to create a `Response` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the template that `DeleteMailingListView` requires in `django/mailinglist/templates/mailinglist/mailinglist_confirm_delete.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this template, we don't use any forms because there isn't any input to validate.
    The form submission itself is the confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step will be adding our view to the `urlpatterns` list in `django/mailinglist/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This `path` looks different than the previous `path()` calls we've seen. In
    this `path`, we're including a named argument that will be parsed out of the path
    and passed to the view. We specify `path` named arguments using the `<converter:name>` format.
    A converter knows how to match a part of the path (for example, the `uuid` converter
    knows how to match a UUID; `int` knows how to match a number; `str` will match
    any non-empty string except `/`). The matched text is then passed to the view
    as a key word argument with the provided name. In our case, to route a request
    to `DeleteMailingListView`, it has to have a path like this: `/mailinglist/bce93fec-f9c6-4ea7-b1aa-348d3bed4257/delete`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can list, create, and delete `MailingList`s, let's create a view
    to manage its `Subscriber`s and `Message`s.
  prefs: []
  type: TYPE_NORMAL
- en: Creating MailingListDetailView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s create a view that will list all the `Subscriber`s and `Message`s related
    to a `MailingList`. We want also need a place to show our users the `MailingList`s
    subscription page link. Django can make it easy to create a view that represents
    a model instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `MailingListDetailView` in `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We're using the `LoginRequiredMixin` and `UserCanUseMailingList` the same way
    and for the same purpose as before. This time, we're using them with `DetailView`,
    which is one of the simplest views. It simply renders a template for an instance
    of the model it's been configured for. It retrieves the model instance by receiving
    a `pk` argument from `path` just like `DeleteView`. Also, we don't have to explicitly
    configure the template it will use because, by convention, it uses `appname/modelname_detail.html`.
    In our case, it will be `mailinglist/mailinglist_detail.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our template in `django/mailinglist/templates/mailinglist/mailinglist_detail.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code template introduces only one new item (the `yesno` filter),
    but really shows how all the tools of Django's template language come together.
  prefs: []
  type: TYPE_NORMAL
- en: The `yesno` filter takes a value and returns `yes` if the value evaluates to
    `True`, `no` if it evaluates to `False`, and `maybe` if it is `None`. In our case,
    we've passed an argument that tells `yesno` to return `confirmed` if `True` and
    `unconfirmed` if `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MailingListDetailView` class and template illustrate how Django lets us
    concisely complete a common web developer task: display a page for a row in a
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create a new `path()` object to our view in the `mailinglist` URLConf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's create views for our `Subscriber` model instances.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Subscriber views and templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we'll create views and templates to let users interact with
    our `Subscriber` model. One of the main differences between these views and the
    `MailingList` and `Message` views is that they will not need any mixins because
    they will be exposed publicly. Their main protection from tampering is that `Subscriber`s
    are identified by a UUID which has a large key space, meaning that tampering is
    unlikely.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with `SubscribeToMailingListView`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating SubscribeToMailingListView and template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a view to collect `Subscriber`s to `MailingList`s. Let''s create a
    `SubscribeToMailingListView` class with `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `SubscribeToMailingListView` is similar to `CreateMailingListView` but
    overrides a couple of new methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_success_url()`: This is called by `CreateView` to get a URL to redirect
    the user to the model that has been created. In `CreateMailingListView`, we didn''t
    need to override it because the default behavior uses the model''s `get_absolute_url`.
    We use the `reverse()` function resolve the path to the thank you page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_context_data()`: This lets us add new variables to the template''s context.
    In this case, we need access to the `MailingList` the user may subscribe to show
    the `MailingList`''s name. We use Django''s `get_object_or_404()` shortcut function
    to retrieve the `MailingList` by its ID or raise a 404 exception. We''ll have
    this view''s `path` parse the `mailinglist_id` out of our request''s path (refer
    to to the , at the end of this section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s create our template in `mailinglist/templates/mailinglist/subscriber_form.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This template doesn't introduce any tags but shows another example of how we
    can use Django's template language and the Django Crispy Forms API to quickly
    build a pretty HTML form. We extend `base.html`, as before, to give our page a
    consistent look and feel. `base.html` also provides the blocks we're going to
    put our content into. Outside of any block, we `{% load %}` the Django Crispy
    Forms tag library so that we can use the `crispy` filter on our form to generate
    the Bootstrap 4 compatible HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s make sure that Django knows how to route requests to our new view
    by adding a `path()` to `SubscribeToMailingListView` to the `mailinglist` app''s
    URLConf''s `urlpatterns` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this `path()`, we need to match the `uuid` parameter that we pass to our
    view as `mailinglist_pk`. This is the keyword argument that our `get_context_data()`
    method referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create a thank you page to thank users for subscribing to a mailing
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thank you for subscribing view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a user subscribes to a mailing list, we want to show them a *thank you*
    page. This page can be the same for all users who subscribe to the same mailing
    list since all it will show is the name of the mailing list (not the subscriber's
    email). To create this view, we're going to use the `DetailView` we've seen before
    but this time without any additional mixing (there's no information to protect
    here).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `ThankYouForSubscribingView` in `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Django does all the work for us in the `DetailView` as long as we provide a
    `model` attribute. The `DetailView` knows how to look up a model and then render
    a template for that model. We also provide a `template_name` attribute because
    the `mailinglist/mailinglist_detail.html` template (which `DetailView` would use
    by default) is already being used by `MailingListDetailView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our template in `django/mailinglist/templates/mailinglist/subscription_thankyou.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Our template just shows a thank you and the template name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add a `path()` to `ThankYouForSubscribingView` to the `mailinglist`
    app''s URLConf''s `urlpatterns` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Our `path` needs to match a UUID in order to route a request to `ThankYouForSubscribingView`.
    The UUID will be passed into the view as the keyword argument `pk`. This `pk`
    will be used by `DetailView` to find the correcting `MailingList`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will need to let a user confirm that they want to receive emails at
    this address.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a subscription confirmation view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To prevent spammers from abusing our service, we will need to send an email
    to our subscribers to confirm that they really want to subscribe to one of our
    users' mailing lists. We'll cover sending those emails, but we'll create the confirmation
    page now.
  prefs: []
  type: TYPE_NORMAL
- en: This confirmation page will behave a little strangely. Simply visiting the page
    will modify `Subscriber.confirmed` to `True`. This is standard for how mailing
    list confirmation pages work (we want to avoid creating extra work for our subscribers)
    but strange according to the HTTP spec, which says that `GET` requests should
    not modify a resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `ConfirmSubscriptionView` in `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`ConfirmSubscriptionView` is another `DetailView` since it shows a single model
    instance. In this case, we override the `get_object()` method in order to modify
    the object before returning it. Since `Subscriber`s are not required to be users
    of our system, we don''t need to use `LoginRequiredMixin`. Our view is protected
    from brute force enumeration because the key space of `Subscriber.id` is large
    and assigned non-sequentially.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create our template in `django/mailinglist/templates/mailinglist/confirm_subscription.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Our template uses the blocks defined in `base.html` to simply notify the user
    of their confirmed subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add a `path()` to `ConfirmSubscriptionView` to the `mailinglist`
    app''s URLConf''s `urlpatterns` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Our `confirm_subscription` path defines the path to match in order to route
    a request to our view. Our matching expression includes the requirement of a UUID,
    which will be passed to our `ConfirmSubscriptionView` as the keyword argument
    `pk`. The parent (`DetailView`) of `ConfirmSubscriptionView` will then use that
    to retrieve the correct `Subscriber`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's allow `Subscribers` to unsubscribe themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UnsubscribeView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Part of being an ethical mailing provider is letting our `Subscriber`s unsubscribe.
    Next, we'll create an `UnsubscribeView`, which will delete a `Subscriber` model
    instance after they've confirmed they definitely want to unsubscribe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our view to `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Our `UnsubscribeView` lets Django's built-in `DeleteView` implement to render
    the template and find and delete the correct `Subscriber`. `DeleteView` requires
    that it receive a `pk` for the `Subscriber` as a keyword argument parsed from
    the path (much like a `DetailView`). When the delete succeeds, we'll redirect
    the user to the subscription page with the `get_success_url()` method. When `get_success_url()`
    is executing, our `Subscriber` instance will already be deleted from the database,
    but a copy of the respective object will be available under `self.object`. We
    will use that still in memory (but not in the database) instance to get the `id` attribute
    of the related mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render the confirmation form, we will need to create a template in `django/mailinglist/templates/mailinglist/unsubscribe.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This template renders a `POST` form, which will act as confirmation of the desire
    of the `subscriber` to be unsubscribed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add a `path()` to `UnsubscribeView` to the `mailinglist` app''s
    URLConf''s `urlpatterns` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When dealing with views that derive from `DetailView` or `DeleteView`, it's
    vital to remember to name the path matcher `pk`.
  prefs: []
  type: TYPE_NORMAL
- en: Great, now, let's allow the user to start creating `Message`s that they will
    send to their `Subscriber`s.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Message Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We track the emails that our users want to send to their `Subscriber`s in the
    `Message` model. To make sure we have an accurate log of what users send to their
    `Subscribers`, we will restrict the operations available on `Message`s. Our users
    will only be able to create and view `Message`s. It doesn't make sense to support
    editing since an email that's been sent can't be modified. We also won't support
    deleting messages so that both we and the users have an accurate log of what was
    requested to be sent when.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with making a `CreateMessageView`!
  prefs: []
  type: TYPE_NORMAL
- en: Creating CreateMessageView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `CreateMessageView` is going to follow a pattern similar to the markdown
    forms that we created for Answerly. The user will get a form that they can submit
    to either save or preview. If the submit is a preview, then the form will render
    along with the preview of the rendered markdown of the `Message`. If the user
    chooses save, then they will create their new message.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're creating a new model instance, we will use Django's `CreateView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our view in `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Our view inherits from `CreateView` and `LoginRequiredMixin`. We use the `LoginRequiredMixin`
    to prevent unauthenticated users from sending messages to mailing lists. To prevent
    logged in but unauthorized users from sending messages, we will create a central `get_mailing_list()`
    method, which checks that the logged in user can use this mailing list. `get_mailing_list()`
    expects that the `mailinglist_pk` will be provided as a keyword argument to the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the `CreateMessageView` to see how this all works
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: '`form_class = MessageForm`: This is the form that we want `CreateView` to render,
    validate, and use to create our `Message` model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template_name = ''mailinglist/message_form.html''`: This is the template that
    we''ll create next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def get_success_url()`: After a `Message` is successfully created, we''ll
    redirect our users to the management page of the `MailingList`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def get_initial():`: Our `MessageForm` has its `mailing_list` field disabled
    so that users can''t try to surreptitiously create a `Message` for another user''s
    `MailingList`. Instead, we use our `get_mailing_list()` method to get the mailing
    list based on the `mailinglist_pk` argument. Using `get_mailing_list()`, we check
    whether the logged in user can use the `MailingList`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def get_context_data()`: This provides extra variables to the template''s
    context. We provide the `MailingList` as well as the save and preview constants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def form_valid()`: This defines the behavior if the form is valid. We override
    the default behavior of `CreateView` to check the `action` POST argument. `action`
    will tell us whether to render a preview of the `Message` or to let `CreateView`
    save a new `Message` model instance. If we''re previewing the message, then we
    pass an unsaved `Message` instance built by our form to the template''s context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s make our template in `django/mailinglist/templates/mailinglist/message_form.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This template loads the third party Django Markdownify tag library and the Django
    Crispy Forms tag library. The former gives us the `markdownify` filter and the
    latter gives us the `crispy` filter. The `markdownify` filter will convert the
    markdown text it receives into HTML. We previously used Django Markdownify in
    our Answerly project in part 2.
  prefs: []
  type: TYPE_NORMAL
- en: This template form has two submit buttons, one to save the form and one to preview
    the form. The preview block is only rendered if we pass in `message` to preview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our view and template, let''s add a `path()` to `CreateMessageView`
    in the `mailinglist` app''s URLConf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can create messages, let's make a view to view messages we've already
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Message DetailView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To let users view the `Message`s they have sent to their `Subscriber`s we need
    a `MessageDetailView`. This view will simply display a `Message` but should only
    let users who are logged in and can use the `Message`'s `MailingList` access the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our view in `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As the name implies, we're going to use the Django's `DetailView`. To provide
    the protection we need, we'll add Django's `LoginRequiredMixin` and our `UserCanUseMailingList`
    mixin. As we've seen before, we don't need to specify the name of the template
    because `DetailView` will assume it based on the name of the app and model. In
    our case, `DetailView` wants the template to be called `mailinglist/message_detail.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our template in `mailinglist/message_detail.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Our template extends `base.html` and shows the message in the `body` block.
    When showing the `Message.body`, we use the third party Django Markdownify tag
    library's `markdownify` filter to render any markdown text as HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add a `path()` to `MessageDetailView` to the `mailinglist`
    app''s URLConf''s `urlpatterns` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We've now completed our `mailinglist` app's models, views, and templates. We've
    even created a `UserCanUseMailingList` to let our views easily prevent unauthorized
    access to a `MailingList` or one of its related views.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll create a `user` app to encapsulate user registration and authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a `MailingList` in Mail Ape, the user needs to have an account and
    be logged in. In this section, we will write the code for our `user` Django app,
    which will encapsulate everything to do with a user. Remember that the Django
    app should be tightly scoped. We don't want to put this behavior in our `mailinglist`
    app, as these are two discrete concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Our `user` app is going to be very similar to the `user` app seen in MyMDB (Part
    1) and Answerly (Part 2). Due to this similarity, we will gloss over some topics.
    For a deeper examination of the topic, refer to [Chapter 2](7b88cc16-ca29-4aea-9895-7120422e8642.xhtml),
    *Adding Users to MyMDb*.
  prefs: []
  type: TYPE_NORMAL
- en: Django makes managing users and authentication easier with its built-in `auth`
    app (`django.contrib.auth`). The `auth` app offers a default user model, a `Form`
    for creating new users, as well as log in and log out views. This means that our
    `user` app only needs to fill in a few blanks before we have complete user management
    working locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a URLConf for our `user` app in `django/user/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Our URLConf is made up of three views:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginView.as_view()`: This is the `auth` app''s login view. The `auth` app
    provides a view for accepting credentials but doesn''t have a template. We''ll
    need to create a template with the name `registration/login.html`. By default,
    it will redirect a user to `settings.LOGIN_REDIRECT_URL` on login. We can also
    pass a `next` `GET` parameter to supersede the setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LogoutView.as_view()`: This is the auth app''s logout view. `LogoutView` is
    one of the few views that modifies state on a `GET` request, logging the user
    out. The view returns a redirect response. We can use `settings.LOGOUT_REDIRECT_URL`
    to configure where our user will be redirected to during log out. Again, we use
    the `GET` parameter `next` to customize this behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user.views.RegisterView.as_view()`: This is the user registration view we
    will write. Django provides us with a `UserCreationForm` but not a view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also need to add a few settings to make Django use our `user` view properly.
    Let''s update `django/config/settings.py` with some new settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'These three settings tell Django how to redirect the user in different authentication
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LOGIN_URL`: When an unauthenticated user tries to access a page that requires
    authentication, `LoginRequiredMixin` uses this setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOGIN_REDIRECT_URL`: When a user logs in, where should we redirect them to?
    Often, we redirect them to a profile page; in our case, the page that shows a
    list of `MailingList`s.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOGOUT_REDIRECT_URL`: When a user logs out, where should we redirect them
    to? In our case, the login page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now have two more tasks left:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the user registration view and template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by making the login template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make our login template in `django/user/templates/registration/login.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This form follows all the practices of our previous forms. We use `csrf_token`
    to protect against a CSRF attack. We use the `crsipy` filter to print the form
    using Bootstrap 4 style tags and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we didn't need to make a view to process our login requests because
    we're using the one that comes with `django.contrib.auth`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create a view and template to register new users.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user registration view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django doesn't come with a view for creating new users, but it does offer a
    form for capturing a new user's registration. We can combine the `UserCreationForm`
    with a `CreateView` to quickly create a `RegisterView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our view to `django/user/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple `CreateView`, like we've seen a few times in this chapter
    already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our template in `django/user/templates/user/register.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Again, the template follows the same pattern as our previous `CreateView` templates.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're ready to run Mail Ape locally.
  prefs: []
  type: TYPE_NORMAL
- en: Running Mail Ape locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django comes with a development server. This server is not suitable for production
    (or even staging) deployment, but is suitable for local development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the server using our Django project''s `manage.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We can now access our server on `http://127.0.0.1:8000`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our Mail Ape project. We created the Django project
    and started two Django apps. The `mailinglist` app contains our models, views,
    and templates for the mailing list code. The `user` app holds views and templates
    related to users. The `user` app is much simpler because it leverages Django's
    `django.contrib.auth` app.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll build an API so that users can integrate with Mail Ape easily.
  prefs: []
  type: TYPE_NORMAL
