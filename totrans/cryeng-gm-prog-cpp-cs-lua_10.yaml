- en: Chapter 10. Rendering Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CryENGINE renderer is most likely the most well-known part of the engine,
    providing highly complex graphical features with great performance on platforms
    such as PC, Xbox 360, and PlayStation 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basic workings of the renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing how each frame is rendered to the world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basics of shader authoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how it's possible to modify static objects at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying a material at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The renderer details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CryENGINE renderer is a modular system that allows the drawing of complex
    scenes, the handling of shaders, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to facilitate different platform architectures, there exist multiple
    renderers for CryENGINE, all implementing the **IRenderer** interface. We have
    listed a selection as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: 'DirectX: Used on Windows and Xbox'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PSGL: Used on PlayStation 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also most likely an **OpenGL** renderer in development, for use on
    platforms such as Linux and Mac OS X.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shaders in CryENGINE are written using a specialized language based on HLSL,
    called CryFX. The system is very similar to HLSL, but is specialized for core
    engine functionality such as material and shader parameters, `#include` macros,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that shader authoring was not enabled in the Free SDK at the time this
    book was written; however, this might change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Shader permutations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each time a material alters a shader generation parameter, a permutation of
    the base shader will be created. The engine also exposes functionality for exposing
    engine variables to shaders, to disable or tweak effects at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This is possible due to the CryFX language allowing the `#ifdef`, `#endif`,
    and `#include` blocks, allowing the engine to strip certain parts of the shader
    code out at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '![Shader permutations](img/5909_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shader cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since compiling shaders at runtime is not viable on all platforms, CryENGINE
    provides the shader caching system. This allows for the storage of a collection
    of precompiled shaders, sparing quite a bit of work for the end-user's device.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in the previous section, shaders can contain a huge amount of variations
    of themselves. Therefore, it is necessary to make sure that all required permutations
    have been compiled when setting up the cache.
  prefs: []
  type: TYPE_NORMAL
- en: PAK files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The renderer can load four `.pak` files from the `Engine` folder, containing
    shader definitions, source files, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '| Archive name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Shaders.pak` | Contains shader source files and `.ext` (definition) files.
    Shader source is commonly excluded from this archive when using precompiled shader
    cache. |'
  prefs: []
  type: TYPE_TB
- en: '| `ShadersBin.pak` | Contains binary parsed information of the shader source
    code. |'
  prefs: []
  type: TYPE_TB
- en: '| `ShaderCache.pak` | Contains all compiled shaders; used only when the shader
    cannot be found in the current level''s shader cache. |'
  prefs: []
  type: TYPE_TB
- en: '| `ShaderCacheStartup.pak` | Loaded during startup to speed up boot times;
    should only contain shaders that are required for the main menu. |'
  prefs: []
  type: TYPE_TB
- en: Render nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **IRenderNode** interface is provided in order to provide the Cry3DEngine
    system with a way to manage objects.
  prefs: []
  type: TYPE_NORMAL
- en: This allows for generating object visibility hierarchies (allowing an easy method
    of culling objects that are not currently seen) and rendering of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering breakdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rendering of games is divided into two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Pre update
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Post update
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pre update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The initial step in rendering each frame to the scene occurs in the `IGameFramework::PreUpdat`e
    function. Pre update is responsible for updating most game systems (such as flowgraph,
    view system, and more) and makes the initial call to `ISystem::RenderBegin`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PreUpdate` is most commonly called from `CGame::Update`, in the stock `CryGame.dll`.
    Always keep in mind that this process only applies to the Launcher application;
    the Editor handles game updates and rendering uniquely.'
  prefs: []
  type: TYPE_NORMAL
- en: RenderBegin signals the start of a new frame, and tells the renderer to set
    the new frame ID, clear buffers, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Post update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After updating the game systems, it's time to render the scene. This initial
    step is done via the `IGameFramework::PostUpdate` function.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to rendering, systems that are crucial to the new information retrieved
    from the game update done within and after `PreUpdate` must be updated. This includes
    flash UI, animation synching, and more.
  prefs: []
  type: TYPE_NORMAL
- en: After that is done, `PostUpdate` will call `ISystem::Render`, which in turn
    renders the world using the `I3DEngine::RenderWorld` function.
  prefs: []
  type: TYPE_NORMAL
- en: After rendering the world, the system will call functions such as `IFlashUI::Update`,
    and `PostUpdate` on all game objects, and more, finally ending in a call to `ISystem::RenderEnd`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Post update](img/5909_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rendering new viewports using render contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Render contexts are in essence wrappers for native window handles. On Windows,
    this allows you to specify a **HWND**, and then have the renderer draw directly
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: The very nature of render contexts is platform-specific, and is, therefore,
    not guaranteed to work the same from one rendering module (such as, D3D) to another
    (such as, OpenGL).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: Render contexts are currently only supported while running in Editor
    mode on Windows, which is used for rendering viewports in tool windows.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a new context with your window handle, call `IRenderer::CreateContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that contexts are automatically enabled on creation; call `IRenderer::MakeMainContextActive`
    to re-enable the main view.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When rendering a context, the first thing you need to do is activate it. This
    can be done by using `IRenderer::SetCurrentContext`. Once enabled, the renderer
    is aware of the window that it should be passing to DirectX.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you need to do is update the resolution of the context by using
    `IRenderer::ChangeViewport`. This instructs the renderer about the position and
    size of the area it should render.
  prefs: []
  type: TYPE_NORMAL
- en: After doing so, simply call the typical render functions such as `IRenderer::BeginFrame`
    (see the *Rendering breakdown* section), and then finish by making the main context
    active at the end, via `IRenderer::MakeMainContextActive`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the I3DEngine::RenderWorld function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases it might make sense to call `I3DEngine::RenderWorld` manually
    instead of relying on the game framework's update process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we''ll need to change the process a bit. To start, call `IRenderer::SetCurrentContext`
    followed by `IRenderer::MakeMainContextActive` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Good, now our context will be activated. But in order to actually render, we''ll
    need to fill up the void between. To start, we have to call `IRenderer::ChangeViewport`
    directly after `SetCurrentContext` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This sets the viewport to the coordinates of `0`, `0`, and our specified `width`
    and `height` variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the viewport size, you''ll want to configure your camera to the
    new resolution and call `IRenderer::SetCamera` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! The renderer is now aware of which camera it should use for rendering.
    We''ll also need to supply this to `I3DEngine::RenderWorld` later on. But first
    we have to clear the buffers in order to remove the previous frame with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is then followed by calling `IRenderer::RenderBegin` to indicate that
    it''s time to start rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all we have to do is render the scene between the `SetViewCamera` and `RenderEnd`
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Done! The world is now rendered based on our camera setup, and should be visible
    to you in the window set via `IRenderer::SetCurrentContext`.
  prefs: []
  type: TYPE_NORMAL
- en: I3DEngine::RenderWorld flags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The render flags determine how the world should be drawn. For example, we could
    exclude `SHDF_ALLOW_WATER` to completely avoid rendering water. The following
    table lists the available flags and their function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SHDF_ALLOWHDR` | If not set, HDR will not be used. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHDF_ZPASS` | Allows the Z-Pass. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHDF_ZPASS_ONLY` | Allows the Z-Pass, and no other passes. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHDF_DO_NOT_CLEAR_Z_BUFFER` | If set, the Z-buffer will never be cleared.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SHDF_ALLOWPOSTPROCESS` | If not set, all post-process effects will be ignored.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SHDF_ALLOW_AO` | If set, **Ambient Occlusion** will be used. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHDF_ALLOW_WATER` | If not set, all water will be ignored and not rendered.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SHDF_NOASYNC` | No asynchronous drawing. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHDF_NO_DRAWNEAR` | Excludes all rendering in the near plane. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHDF_STREAM_SYNC` | Enables synchronized texture streaming. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHDF_NO_DRAWCAUSTICS` | If set, no water caustics will be drawn. |'
  prefs: []
  type: TYPE_TB
- en: Shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a custom shader in CryENGINE is relatively easy, and can be done simply
    by copying an existing shader (`.cfx`) and its extension file (`.ext`). For the
    sake of this example, copy `Illum.ext` from `Engine/Shaders` and name it `MyShader.ext`.
    Then copy `Engine/Shaders/HWScripts/CryFX/Illum.cfx` and rename it to `MyShader.cfx`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that creating custom shaders should be thought out properly; if it is possible
    to simply use an existing shader, that would be the best option. This is due to
    the fact that CryENGINE is already reaching the viable limit of the number of
    shader permutations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As stated earlier in the chapter, custom shader authoring was not enabled in
    the CryENGINE Free SDK at the time this book was written.
  prefs: []
  type: TYPE_NORMAL
- en: The shader description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each shader needs to define a description, which sets its options. Options
    are set in the global `Script` variable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Texture slots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each material can specify the file path to a texture in a set of texture slots
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Texture slots](img/5909_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can access these texture slots via shaders by using a set of helpers (as
    follows), which can then be added to custom samplers that can then be loaded by
    using the `GetTexture2D` function.
  prefs: []
  type: TYPE_NORMAL
- en: '| Slot name | Helper name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Diffuse | $Diffuse |'
  prefs: []
  type: TYPE_TB
- en: '| Gloss (Specular) | $Gloss |'
  prefs: []
  type: TYPE_TB
- en: '| Bump |   |'
  prefs: []
  type: TYPE_TB
- en: '| Bump heightmap | $BumpHeight |'
  prefs: []
  type: TYPE_TB
- en: '| Environment | $Env |'
  prefs: []
  type: TYPE_TB
- en: '| Environment Cubemap | $EnvironmentCubeMap |'
  prefs: []
  type: TYPE_TB
- en: '| Detail | $Detail |'
  prefs: []
  type: TYPE_TB
- en: '| Opacity | $Opacity |'
  prefs: []
  type: TYPE_TB
- en: '| Decal | $DecalOverlay |'
  prefs: []
  type: TYPE_TB
- en: '| Subsurface | $Subsurface |'
  prefs: []
  type: TYPE_TB
- en: '| Custom | $CustomMap |'
  prefs: []
  type: TYPE_TB
- en: '| Custom Secondary | $CustomSecondaryMap |'
  prefs: []
  type: TYPE_TB
- en: Shader flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using the `#ifdef` and `#endif` preprocessor commands, it is possible to
    define areas of the code that can be removed prior to compilation or at runtime.
    This allows for the usage of a single übershader with multiple toggleable subeffects,
    such as Illum.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could check whether the user is running DX11 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Material flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Material flags are set via **Material Editor**, allowing each material to use
    different effects, such as Parallax Occlusion Mapping and Tessellation. The material
    flags are evaluated at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new material flag, open your shader''s `.ext` file and create a
    new property with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now when you restart the editor, your property should appear in the Material
    Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of possible property data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property data | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Defines the internal name of the property, and is what you should
    check for by using the `#ifdef` block. |'
  prefs: []
  type: TYPE_TB
- en: '| Mask | Unique mask used to identify your property. Should not conflict with
    that of other properties in your shader definition (`.ext`). |'
  prefs: []
  type: TYPE_TB
- en: '| Property | The public name of the property, displayed in the material editor.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Description | Public description for the property, shown when hovering over
    the property in the material editor. |'
  prefs: []
  type: TYPE_TB
- en: '| DependencySet | When the user modifies the value of the texture slot this
    property is set to, the material flag will be activated.This is most commonly
    used in combination with the Hidden flag. |'
  prefs: []
  type: TYPE_TB
- en: '| DependencyReset | When the user modifies the value of the texture slot this
    property is set to, the material flag will be cleared.Used to avoid conflicts
    with other material flags. |'
  prefs: []
  type: TYPE_TB
- en: '| Hidden | If set, the property will not be visible in the editor. |'
  prefs: []
  type: TYPE_TB
- en: Engine flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Engine flags are directly set by the engine, and contain information such as
    the currently supported shader model or the platform on which the engine is currently
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Runtime flags are defined by the `%_RT_` prefix, and can be set or unset by
    the engine at runtime. All available flags can be viewed in the `RunTime.ext`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Samplers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A sampler is a representation of a single texture of a specific texture type.
    By creating custom samplers, we can refer to specific textures from within the
    shader, for example, to load a texture containing pre-generated noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example for a pre-loaded sampler is as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can now refer to `mySampler` in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Using texture slots with samplers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases, it's preferred to have your sampler point to one of the texture
    slots defined in the material.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, simply replace the path of your texture with the name of your preferred
    texture slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When loaded, the texture will then be that which the material specified in the
    Diffuse slot.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a texture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a texture, we can learn how to get texture data in a shader.
    This is done by using the `GetTexture2D` function as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter specifies which sampler to use (in our case, the sampler
    we created previously), while the second specifies the texture coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating static objects at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we are going to learn how to modify a static mesh at runtime,
    allowing for the manipulation of render and physical meshes during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, firstly we need to obtain the `IStatObj` instance of our object.
    For example, if you''re modifying an entity, you can use `IEntity::GetStatObj`
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we passed `0` as the first parameter to `IEntity::GetStatObj`. This
    is done in order to get the object with the highest **Level of Detail** (**LOD**).
    This means that changes made to this static object will not be reflected in its
    other LODs.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a pointer to an interface holding the static object data for your
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now call `IStatObj::GetIndexedMesh` or `IStatObj::GetRenderMesh`. The
    latter is most likely the best place to start, as it is constructed from the optimized
    indexed mesh data as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We now have access to the `meshdesc` variable containing information about the
    mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we need to call `IStatObj::UpdateVertices` in order to carry over
    the changes we have made to the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that changing a static object will carry over the changes to all of
    the objects using it. Use the `IStatObj::Clone` method to create a copy of it
    prior to editing, allowing you to manipulate only one object in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying materials at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we're going to modify a material at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to `IStatObj`, we can also clone our material to avoid making changes
    to all of the objects using it currently. To do so, call `IMaterialManager::CloneMaterial`,
    which is accessible via `gEnv->p3DEngine->GetMaterialManager()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is obtain an instance of the material we want
    to edit. If we have an entity nearby, we can use `IEntity::GetMaterial` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `IEntity::GetMaterial` returns null if no custom material has been
    set. If this is the case, you might want to rely on a function such as `IStatObj::GetMaterial`.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that `IMaterial` instances can be used for multiple objects. This means
    that modifying an object's parameters can result in changes on objects other than
    that you retrieved the object from.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this, we can simply clone the material before modifying it via the
    `IMaterialManager::Clone` method as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we just have to apply the clone to the entity we retrieved the original
    instance from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can now move on to modifying the material's parameters, or parameters related
    to the shader that was assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: Material parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modifying the parameters of our material can be useful at times. This allows
    us to tweak per-material properties such as **Opacity**, **AlphaTest**, and **Diffuse
    Color** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Material parameters](img/5909_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To set or get material parameters, use `IMaterial::SetGetMaterialParamFloat`
    or `IMaterial::SetGetMaterialVec3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to see the alpha of our material, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The material should now draw alpha at half strength.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of available parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter name | Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"alpha"` | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| `"opacity"` | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| `"glow"` | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| `"shininess"` | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| `"diffuse"` | `Vec3` |'
  prefs: []
  type: TYPE_TB
- en: '| `"emissive"` | `Vec3` |'
  prefs: []
  type: TYPE_TB
- en: '| `"specular"` | `Vec3` |'
  prefs: []
  type: TYPE_TB
- en: Shader parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned earlier, each shader can expose a set of parameters that allow
    the material to tweak the behavior of the shader without affecting the shader
    globally.
  prefs: []
  type: TYPE_NORMAL
- en: '![Shader parameters](img/5909_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To modify the shader parameters of our material, we''ll first need to obtain
    the shader item linked to this material:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the shader item, we can access `IRenderShaderResources::GetParameters`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now modify the parameters contained within and call `IRenderShaderResources::SetShaderParams`
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Example – Dynamic alpha-test for vegetation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's put your knowledge to the test!
  prefs: []
  type: TYPE_NORMAL
- en: We have included a tree set up for use of the alpha test property with the sample
    (as shown in the following screenshot). When alpha test is increased, leaf loss
    is simulated.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example – Dynamic alpha-test for vegetation](img/5909_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To show this off, we're going to write a little snippet of code that modifies
    this at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new class, called `CTreeOfTime`. Either create a new game
    object extension, or derive one from the sample that we created in [Chapter 3](ch03.html
    "Chapter 3. Creating and Utilizing Custom Entities"), *Creating and Utilizing
    Custom Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, we''ll need to load our tree object on entity spawn as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our entity should now load the `Objects/nature/trees/ash/tree_ash_01.cgf` object
    into its first slot (Index 0) when it is spawned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll need to override the entities `Update` method in order to update
    the alpha-test property based on the current time of day. When you''re done, add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You should now have a time cycle during which your tree loses and regains its
    leaves. This is one of the many techniques that are possible by modifying materials
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example – Dynamic alpha-test for vegetation](img/5909_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how shaders are used by the engine, and have
    broken down the rendering process. You should now be aware of how you can use
    render contexts, manipulate static objects at runtime, and modify materials progammatically.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren't ready to move on to the next chapter on effects and sound just
    yet, why not take on a challenge? For example, you could create a custom object
    that is deformed when attacked.
  prefs: []
  type: TYPE_NORMAL
