- en: Publishing Docker Images Using ECR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker registries are a critical component of the Docker and container ecosystem,
    providing a universal mechanism to publish and distribute your container applications,
    both publicly and privately.
  prefs: []
  type: TYPE_NORMAL
- en: The ECR provides a fully-managed private Docker registry that features tight
    integration with the ECS components introduced in the previous chapter and other
    AWS services. ECR is highly scalable, secure, and offers tooling to integrate
    with the native Docker client that is used to build and publish Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create ECR repositories to store your
    Docker images, using a variety of mechanisms, including the AWS console, AWS CLI,
    and CloudFormation. Once you have established your first ECR repository, you will
    learn how to authenticate with ECR, pull Docker images stored in your repositories,
    and build and publish Docker images to ECR using the Docker client. To close out
    this chapter, you will learn how to deal with more advanced scenarios of using
    and managing ECR, including configuring cross-account access to allow Docker clients
    running in other AWS accounts access to your ECR repositories, and configuring
    lifecycle policies, which ensure orphaned Docker images are periodically cleaned
    up, reducing administrating effort and cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ECR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ECR repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging into ECR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing Docker images to ECR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulling Docker images from ECR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring lifecycle policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following lists the technical requirements to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker 18.06 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose 1.22 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU Make 3.82 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jq
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI 1.15.71 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Administrator access to an AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local AWS profile configured as per instructions in Chapter 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working Docker workflow for the sample application as configured in Chapter
    2 (see [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch2](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch2)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This GitHub URL contains the code samples used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch5](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch5).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2PKMLSP](http://bit.ly/2PKMLSP)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ECR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started creating and configuring ECR repositories, it is important
    to provide a brief introduction to the core concepts of ECR.
  prefs: []
  type: TYPE_NORMAL
- en: 'ECR is a fully-managed private Docker registry provided by AWS and offers tight
    integration with ECS and other AWS services. ECR consists of a number of components,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4472aae0-f99e-482d-a642-fad5cc753bfa.png)ECR architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'The core components of ECR include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repositories**: A repository stores all versions of images for a given Docker
    image. Each repository is configured with a name and URI, which is unique to your
    AWS account and region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permissions**: Each repository includes permissions that allow you to grant
    access for various ECR operations, such as pushing or pulling Docker images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lifecycle policy**: Each repository can be configured with an optional lifecycle
    policy, which can be used to clean up orphaned Docker images that have been superseded
    by newer versions, or remove older Docker images that you may no longer use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication service**: ECR includes an authentication service that includes
    a token service that can be used to authenticate your IAM credentials in exchange
    for a temporary authentication token compatible with the Docker client authentication
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s also important to consider the consumers of ECR. As shown in the previous
    diagram, these include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker clients in the same local AWS account as your repositories**: This
    would most commonly include ECS container instances running in ECS clusters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker clients in a different AWS account from your repositories**: This
    is a common scenario for larger organizations, and again would typically include
    ECS container instances running in ECS clusters in remote accounts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker clients used by AWS services**: Some AWS services can utilize your
    own Docker images published in ECR, such as the AWS CodeBuild service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing this book, ECR is only offered as a private registry
    - meaning if you want to publish public your Docker images publicly, then ECR
    is not the correct solution for you, at least in terms of publishing your public
    Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ECR repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a basic overview of ECR, let's get started creating your first
    ECR repository. Recall in earlier chapters, you were introduced to the sample
    **todobackend** application for this book, and you built a Docker image in your
    local environment. To be able to run containers on your ECS clusters based from
    this image, you need to publish this image to a Docker registry that your ECS
    container instances can access, and ECR is the perfect solution for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an ECR repository for the **todobackend** application, we will focus
    on the three popular methods to create and configure your repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating ECR repositories using the AWS Console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ECR repositories using the AWS CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ECR repositories using the AWS CloudFormation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ECR repositories using the AWS Console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating an ECR repository can be performed using the AWS Console by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main AWS console, select **Services** | **Elastic Container Service**
    within the Compute section, select **Repositories** from the left menu, and then
    click on the Get Started button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will be prompted to configure a name for your repository. A standard convention
    is to name your repositories in the `<organization>/<application>` format, which
    will result in a fully-qualified repository URI of `<registry>/<organization>/<application>`.
    In the following example, I am calling the repository `docker-in-aws/todobackend`,
    but you can name your image whatever you like. Once complete, click on Next step
    to continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b8a39b1e-b38f-4f4b-91d7-162b33f6f0ea.png)Configuring a Repository
    name'
  prefs: []
  type: TYPE_NORMAL
- en: Your ECR repository will now be created and instructions on how to log in to
    ECR and publish your Docker image will be provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating ECR repositories using the AWS CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an ECR repository can be performed using the AWS CLI by running the
    `aws ecr create-repository` command, however given you have already created your
    repository via the AWS console, let's see how you can check whether an ECR repository
    already exists and how to delete a repository using the AWS CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view a list of ECR repositories in your AWS account and local region, you
    can use the `aws ecr list-repositories` command, while to delete an ECR repository,
    you can use the `aws ecr delete-repository` command, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Describing and deleting an ECR Repository using the AWS CLI
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have deleted the repository you created earlier using the AWS
    console, you can re-create it, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating an ECR Repository using the AWS CLI
  prefs: []
  type: TYPE_NORMAL
- en: Creating ECR repositories using AWS CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CloudFormation supports the creation of ECR repositories via the `AWS::ECR::Repository`
    resource type, and at the time of writing, this allows you to manage ECR resource
    policies and lifecycle policies, which we will cover later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule of thumb, given the critical nature of ECR repositories as
    a distribution mechanism for your Docker images, I typically recommend the various
    ECR repositories for your account and region are defined in a single, shared CloudFormation
    stack dedicated solely to the creation and management of ECR repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'In keeping with this recommendation and for future chapters, let''s create
    a repository called **todobackend-aws** that you can use to store the various
    infrastructure configurations you will create and manage throughout this book. 
    I will leave you to create the corresponding repository on GitHub, after which
    you can configure your GitHub repository as a remote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now configure a CloudFormation template file called `ecr.yml` that
    defines a single ECR repository for the `todobackend` Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Defining an ECR Repository using the AWS CloudFormation
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous example, defining an ECR repository is very simple
    using CloudFormation and only requires the `RepositoryName` property to be defined,
    which, as you might expect, defines the name of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have deleted the current todobackend ECR repository, as demonstrated
    earlier, you can now use the `aws cloudformation deploy` command to create the
    todobackend repository using CloudFormation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating an ECR Repository using the AWS CloudFormation
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the stack deploys successfully, you can view the stack in the CloudFormation
    console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/355c6511-887a-4c48-a0d6-d563459b8ed9.png)ECR Repository CloudFormation
    stack'
  prefs: []
  type: TYPE_NORMAL
- en: If you now navigate back to the ECS console and select **Resources** from the
    left menu, you should see a single ECR repository called `docker-in-aws/todobackend`,
    as defined in your CloudFormation stack. If you click on the repository, you will
    be taken to the repository detail page, which provides you with the repository
    URI, a list of images published in the repository, ECR permissions, and lifecycle
    policy settings.
  prefs: []
  type: TYPE_NORMAL
- en: Logging into ECR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have created a repository for your Docker image, the next step is to
    build and publish your images to ECR. Before you can do this, you must authenticate
    with ECR, given at the time of writing ECR is a private service that does not
    support public access.
  prefs: []
  type: TYPE_NORMAL
- en: The instructions and commands for logging into ECR were displayed as part of
    the ECR repository wizard, however you can view these instructions any time by
    selecting an appropriate repository and clicking the **View Push Commands** button,
    which will display the various commands required to log in, build, and publish
    Docker images to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command displayed is the `aws ecr get-login` command, which will
    generate a `docker login` expression that includes temporary authentication token
    valid for logging into ECR for 12 hours (note the command output has been truncated
    in the interests of saving space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Generating login commands for ECR
  prefs: []
  type: TYPE_NORMAL
- en: The `--no-include-email` flag is required for Docker versions 17.06 and higher,
    as the `-e` Docker CLI email flag was deprecated from this release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can copy and paste the generated command output in the preceding
    example, a faster method is to automatically execute the output of the `aws ecr
    get-login` command using a bash command substitution by surrounding the command
    with `$(...)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Logging into ECR
  prefs: []
  type: TYPE_NORMAL
- en: Publishing Docker images to ECR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier chapters, you learned how to build and tag Docker images locally,
    using the todobackend sample application as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now extend this workflow to publish Docker images to ECR, which requires
    you to perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you are logged into ECR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build and tag your Docker image with the URI of your ECR repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push your Docker image to ECR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing Docker images using the Docker CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've already seen how to log into ECR, and building and tagging your Docker
    image is much the same as the local use case, except you need to specify the URI
    of your ECR repository when tagging the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates building the `todobackend` image, tagging
    the image with the URI of your new ECR repository (for the actual URI of your
    repository), and verifying the image name using the `docker images` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tagging an Image for ECR
  prefs: []
  type: TYPE_NORMAL
- en: Once you have built and tagged your image, you can push your image to ECR.
  prefs: []
  type: TYPE_NORMAL
- en: Note that to publish an image to ECR, you require various ECR permissions. Because
    you are using the admin role in your account, you automatically have all the required
    permissions. We will discuss ECR permissions in more detail later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because you have already logged into ECR, this is as simple as using the `docker
    push` command and referencing the name of your Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Pushing an image to ECR
  prefs: []
  type: TYPE_NORMAL
- en: If you now navigate to the todobackend repository in the ECS console, you should
    see your newly published image appear with the default `latest` tag, as shown
    in the following figure. Notice that when you compare the built size of the image
    (99 MB in my example) with the size of the image stored in ECR (34 MB in my example),
    you can see that ECR stores the image in a compressed format, which reduces storage
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of charges for using ECR, AWS charges for both data storage and data
    transfer out (that is, pulling a Docker image). See [https://aws.amazon.com/ecr/pricing/](https://aws.amazon.com/ecr/pricing/)
    for more details.![](assets/9cb36e30-9f49-412d-833c-93abf0e56183.png)Viewing ECR
    images
  prefs: []
  type: TYPE_NORMAL
- en: Publishing Docker images using Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier chapters, you learned how to use Docker Compose to help simplify
    the number of CLI commands required to test and build your Docker images. At the
    moment, Docker Compose is only building Docker images locally, but of course you
    now want to be able to publish your Docker images and leverage your Docker Compose
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Compose includes a service configuration property called `image`, which
    is commonly used to specify the image of a container that you would like to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Example Docker Compose file
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this is a very common usage pattern for Docker Compose, another configuration
    and set of behaviors exist if you combine both the `build` and `image` properties,
    as demonstrated here, for the `docker-compose.yml` file in the todobackend repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Todobackend Docker Compose file
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `image` and `build` properties are both specified
    for the `release` and `app` services. When these two properties are used together,
    Docker will still build the image from the referenced Dockerfile, but will tag
    the image with the value to specify for the `image` property.
  prefs: []
  type: TYPE_NORMAL
- en: You can apply multiple tags by creating new services that simply extend your
    release image and define a image property that includes the additional tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that for the `app` service we reference the environment variable `APP_VERSION`,
    which is intended to tag the image with the current application version that is
    defined within the Makefile at the root of the todobackend repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Replace the repository URI in the preceding examples with the appropriate URI
    generated for your own AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the tagging behavior when you combine the `image` and `build`
    properties, first delete the Docker image you created earlier in this chapter,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a Docker image
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now run the `docker-compose build release` command, once the command
    completes, Docker Compose will have built a new image tagged with your ECR repository
    URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Building a tagged image using Docker Compose
  prefs: []
  type: TYPE_NORMAL
- en: 'With your image built and tagged correctly, you can now execute the `docker-compose
    push` command, which can be used to push services defined in the Docker Compose
    file that include a `build` and `image` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Publishing images using Docker Compose
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the image associated with the service called `release`
    is pushed, given this is the service that you configured with the Docker image
    URI.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the publish workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, you learned how to automate testing and building a Docker
    image for the todobackend application, using a combination of Docker, Docker Compose,
    and Make.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now enhance this workflow to perform the following additional actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in and log out of ECR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish to ECR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve this, you will create new tasks in the Makefile of the todobackend
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Automating login and logout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example demonstrates adding a couple of new tasks called `login`
    and `logout`, which will perform these actions using the Docker client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Logging in and logging out of ECR
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `login` task uses a double dollar sign ($$), which is required
    as Make uses single dollar signs to define Make variables. When you specify a
    double dollar sign, Make will pass a single dollar sign to the shell, which in
    this case will ensure a bash command substitution is executed.
  prefs: []
  type: TYPE_NORMAL
- en: When logging out with the `logout` task, notice that you need to specify the
    Docker registry, otherwise the Docker client assumes the default public Docker
    Hub registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these tasks in place, you can now easily log out and log in of ECR using
    the `make logout` and `make login` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Running make logout and make login
  prefs: []
  type: TYPE_NORMAL
- en: Automating the publishing of Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To automate the publishing workflow, you can add a new task called `publish`
    to the Makefile, which simply calls the `docker-compose push` command for the
    tagged `release` and `app` services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Automating publishing to ECR
  prefs: []
  type: TYPE_NORMAL
- en: With this configuration in place, your Docker image will now be tagged with
    both the commit hash and latest tags, which you can then publish to ECR by simply
    running the `make publish` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now commit your changes and run the full Make workflow to test, build,
    and publish your Docker images, as demonstrated in the following example. Notice
    that an image tagged with the commit hash of `97e4abf` is published to ECR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Running the updated Make workflow
  prefs: []
  type: TYPE_NORMAL
- en: Pulling Docker images from ECR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have learned how to publish Docker images to ECR, let''s focus
    on how Docker clients running under a variety of scenarios can pull your Docker
    images from ECR. Recall from the introduction to ECR at the beginning of this
    chapter that a variety of scenarios exist for client access to ECR, and we will
    now focus on these scenarios in the context of ECS container instances as your
    Docker clients:'
  prefs: []
  type: TYPE_NORMAL
- en: ECS container instances running in the same account as your ECR repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECS container instances running in different accounts to your ECR repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS services that require access to your ECR repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECS container instance access to ECR from the same account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When your ECS container instances are running in the same account as your ECR
    repositories, the recommended method to enable the ECS agents running inside your
    ECS container instances to pull Docker images from ECR is to use IAM policies
    associated with the IAM instance role applied to EC2 instance that runs as an
    ECS container instance. You already saw this method in action in the previous
    chapter, where the ECS cluster wizard provided by AWS attached a managed policy,
    called `AmazonEC2ContainerServiceforEC2Role`, to the IAM instance role for ECS
    container instances in the cluster, and notice the following ECR permissions that
    are included in this policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: AmazonEC2ContainerServiceforEC2Role policy
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, you can see four ECR permissions are granted, which
    collectively permit the ECS agent to login to ECR and pull Docker images:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ecr:GetAuthorizationToken`: Permits retrieval of an authentication token that
    is valid for 12 hours and can be used to log in to ECR using the Docker CLI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ecr:BatchCheckLayerAvailability`: Checks the availability of multiple image
    layers in a given repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ecr:GetDownloadUrlForLayer`: Retrieves a pre-signed S3 download URL for a
    given layer in a Docker image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ecr:BatchGetImage`: Retries detailed information for Docker images in a given
    repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These permissions are sufficient to log into ECR and pull images, but notice
    that the `Resource` property in the previous example allows access to all repositories
    in your account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the security requirements of your organization, this broad access
    to all repositories may or may not be acceptable - if not, then you need to create
    custom IAM policies that restrict access to specific repositories, as demonstrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Granting ECR login and pull permissions to specific repositories
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, notice that the `ecr:GetAuthorizationToken` permission
    is still scoped to all resources, as you don't log into a specific ECR repository,
    rather you log into the ECR registry for your account in a given region. The other
    permissions required to pull Docker images however can be applied to individual
    repositories, and you can see that these permissions are only permitted to the
    ARN of your ECR repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you also wanted to grant push access to the ECR repository in
    the preceding example, additional ECR permissions would be required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Granting ECR push permissions to specific repositories
  prefs: []
  type: TYPE_NORMAL
- en: ECS container instance access to ECR from a different account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In larger organizations, it is very common for resources and users to be split
    across multiple accounts, and a common pattern is to have a central build account,
    where application artifacts, such as Docker images, are centrally stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates this scenario, where you may have several
    accounts running ECS container instances that need to pull Docker images that
    store in your central repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5cf82ce0-1580-4267-aa6d-c6bf66054e75.png)Multiple accounts requiring
    access to central ECR repositories'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you need to grant other accounts access to your ECR repositories, there
    are two configuration tasks that need to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure ECR *resource policies* in the account that hosts the repositories,
    which allow you to define policies that are scoped and applied to an individual
    ECR repository (this is the *resource*) and define *who* can access the repository
    (for example, AWS accounts) and *what* actions they can perform (for example,
    log in, push and/or pull images). This ability to define *who* can access a given
    repository is what allows for cross-account access to be enabled and controlled
    via resource policies. For example, in the preceding diagram, the repository is
    configured to permit access from accounts `333333444444` and `555555666666`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Administrators in the remote account need to assign permissions in the form
    of IAM policies to pull images from your ECR repositories. This is a form of delegated
    access, where the account hosting the ECR repositories trusts access from the
    remote account as long as access has been explicitly granted via an IAM policy.
    For example, in the preceding diagram, ECS container instances have an IAM policy
    assigned that permits them access to the myorg/app-a repository in account `111111222222`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring ECR resource policies using the AWS Console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can configure ECR resource policies via the ECS Console by opening the
    appropriate ECR repository, selecting the **Permissions** tab, and clicking **Add**
    to add a new set of permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4dc40247-49ee-463d-ab22-2800808bfd0d.png)Configuring ECR resource
    policies'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, notice that you can configure AWS account IDs as principals
    via the Principal setting, and then easily permit pull access by selecting the
    **Pull only actions** option. With this configuration, you are permitting potentially
    any entity associated with the remote account the ability to pull Docker images
    from this repository.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c0f530e0-0975-491a-8e31-390eedb7a484.png)Configuring ECR resource
    policies'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you attempt to save the configuration shown in the previous figure
    and the preceding figure, you will receive an error because I have used an invalid
    account. Assuming you did use a valid account ID and you saved the policy, the
    following policy document would be generated for the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Example ECR repository policy document
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ECR resource policies using the AWS CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can configure ECR resource policies via the AWS CLI by using the `aws ecr
    set-repository-policy` command, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Configuring ECR resource Policies via the AWS CLI
  prefs: []
  type: TYPE_NORMAL
- en: As demonstrated in the preceding example, you must specify the repository name
    using the `--repository-name` flag, and configure the repository policy as a JSON-formatted
    document using the `--policy-text` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ECR resource policies using AWS CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using AWS CloudFormation to define your ECR repositories, you can configure
    the `RepositoryPolicyText` property of the `AWS::ECR::Repository` resource you
    created in earlier example to define an ECR resource policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Configuring ECR resource policies using AWS CloudFormation
  prefs: []
  type: TYPE_NORMAL
- en: The policy text in the preceding example expresses the JSON policy you configured
    in earlier examples in a YAML format, and you can deploy the changes to your stack
    by running the `aws cloudformation deploy` command.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring IAM policies in remote accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the ECR resource policies in place configured either by the console, CLI,
    or CloudFormation, you can proceed to create IAM policies in the remote account(s)
    specified in your ECR resource policies. These policies are configured exactly
    how you would configure an IAM policy for local access in your account, and if
    required, you can refer to the ARN of the remote ECR repository if you wish to
    only grant access to this repository.
  prefs: []
  type: TYPE_NORMAL
- en: AWS service access to ECR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One final scenario we will discuss is the ability for AWS services to access
    your ECR images. An example of this is the AWS CodeBuild service, which performs
    automated continuous integration tasks using a container-based build agent. CodeBuild
    allows you to define your own custom build agents, and a common practice is to
    publish the image for these build agents in ECR. This means that the AWS CodeBuild
    service now requires access to ECR, and you can use ECR resource policies to achieve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example expands on the preceding example, adding the AWS CodeBuild
    service to the resource policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Configuring AWS service access to ECR repositories
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, notice that you can use the `Service` property within
    the `Principal` property to identify AWS services that that policy statement will
    be applied to. In later chapters, you will see an example of this in action when
    you create your own custom CodeBuild image that is published to ECR.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring lifecycle policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have followed along in this chapter, you will have published the todobackend
    image to your ECR repository several times, and chances are, you will have created
    what are known as *orphan images* in your ECR repository. In earlier chapters,
    we discussed orphaned images that were being created in your local Docker Engine,
    and defined these an image whose tag has been superseded by a newer image, effectively
    leaving the older images nameless and hence "orphaned."
  prefs: []
  type: TYPE_NORMAL
- en: 'If you browse to your ECR repository and select the Images tab in the ECS console,
    you may notice that you have a few images that no longer have a tag, which will
    be because you pushed several images with the `latest` tag, that have superseded
    the now-orphaned images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6396f20d-d78c-4511-ab1e-c3a676b92950.png)Orphaned ECR images'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, notice that your storage usage in ECR has now tripled,
    even though you only have one current `latest` image, which means you may also
    be paying triple the storage costs. Of course you can manually delete these images
    yourself, however this is prone to error and often will become a forgotten and
    neglected task.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, ECR supports a feature called *lifecycle policies*, which allows
    you to define a set of rules contained within a policy that manages the lifecycle
    of your Docker images. A standard use case for lifecycle policies that you should
    always apply to every repository you create is the periodic removal of orphaned
    images, so let's now see how you can create and apply such a policy.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring lifecycle policies using the AWS Console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When configuring lifecycle policies, because these policies may actually delete
    your Docker images, it is a good idea to always use the AWS console to initially
    test your policies, as the ECS console includes a feature that allows you to simulate
    what would happen if you were to apply a lifecycle policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure lifecycle policies using the AWS console, select the **Dry run
    of lifecycle rules** tab within your ECR repository and then click the **Add**
    button to create a new Dry run rules. This allows you to test your lifecycle policy
    rules without actually deleting any images in your ECR repository. Once you are
    satisfied your rules are behaving safely and as expected, you can convert them
    into actual lifecycle policies that will be applied to your repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b3d8f9fb-8e73-4b0a-9fca-b5e329a297df.png)ECR dry run rules'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now define a rule in the Add rule screen with the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule priority**: Determines the rule evaluation order when multiple rules
    are defined in a policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule description**: A human-readable description of the rule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Image status**: Defines which type of images the rule applies to. Note that
    you can only have a single rule that specifies **Untagged** images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Match criteria**: Defines the criteria as to when the rule should be applied.
    For example, you might configure the criteria to match untagged images that were
    pushed more than seven days since the last push to the ECR repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule action**: Defines the action that should be performed to images that
    match the rule. At the time of writing, only the **expire** action is supported,
    which will delete matching images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After clicking on the Save button, the new rule will be added to the **Dry run
    of lifecycle rules** tab. If you now click the **Save and perform dry run** button,
    any images that match your rule criteria will be displayed, which should include
    the orphaned images that were displayed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Now, depending on whether or not you have untagged images and how old they are
    in comparison to your last push to the repository, you may or may not see images
    that match your dry run rules. Regardless of the actual outcome, the key here
    is to ensure that whatever images were matched is what you expect, and that you
    are comfortable the dry run rules will not accidentally delete valid images that
    expect to be published and available.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are happy with the dry run rules, you can next click the **Apply as
    lifecycle policy** button, which will first display a dialog confirming the new
    rules, and once applied, if you navigate to the **Lifecycle policy** tab, you
    should see your lifecycle policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5b82b40f-e3f7-4792-aece-cc70583abb0a.png)ECR lifecycle policies'
  prefs: []
  type: TYPE_NORMAL
- en: To confirm your lifecycle policy is working, you can click on any policy rule
    and select **View History** from the **Actions** dropdown, which will display
    any actions that have been performed by ECR in relation to the policy rule.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring lifecycle policies using the AWS CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The AWS CLI supports a similar workflow to configuring ECR lifecycle policies
    via the AWS console, which is outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aws ecr start-lifecycle-policy-preview --repository-name <*name*> --lifecycle-policy-text
    <*json*>`: Starts a dry run of the lifecycle policy against the repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aws ecr get-lifecycle-policy-preview --repository-name <*name*>`: Obtains
    the status of the dry run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aws ecr put-lifecycle-policy --repository-name <*name*> --lifecycle-policy-text
    <*json*>`: Applies the lifecycle policy to the repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aws ecr get-lifecycle-policy --repository-name <*name*>`: Displays the current
    lifecycle policy applied to the repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aws ecr delete-lifecycle-policy --repository-name <*name*>`: Deletes the current
    lifecycle policy applied to the repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with the CLI, you need to specify lifecycle policies in a JSON
    format, which you can see an example of by clicking the View JSON action in the
    preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring lifecycle policies using AWS CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using AWS CloudFormation to define your ECR repositories, you can configure
    the `LifecyclePolicy` property of the `AWS::ECR::Repository` resource you created
    earlier, to define an ECR lifecycle policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Configuring ECR lifecycle policies using AWS CloudFormation
  prefs: []
  type: TYPE_NORMAL
- en: The policy text in the preceding example, expresses the JSON policy you configured
    in earlier examples as a JSON string - note the use of the pipe (`|`) YAML operator,
    which allows you to enter multiline text for improved readability.
  prefs: []
  type: TYPE_NORMAL
- en: With this configuration in place, you can apply the changes to your stack by
    running the `aws cloudformation deploy` command.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create and manage ECR repositories that
    you can use to store your Docker images securely and privately. After creating
    your first ECR repository, you learned how to authenticate to ECR using the AWS
    CLI and Docker client, and then successfully tagged and published your Docker
    image to ECR.
  prefs: []
  type: TYPE_NORMAL
- en: With your Docker image published, you then learned about the various scenarios
    for which Docker clients may need to access your repository, which included ECS
    container instance access from the same account as your ECR repository, ECS container
    instance from a different account as your ECR repository (that is, cross-account
    access), and finally granting access to AWS services such as CodeBuild. You created
    ECR resource policies, which are required when configuring cross-account access
    and when granting access to AWS services, and you learned that despite the creation
    of ECR resource policies in a central account that define remote accounts as trusted,
    you still need to create IAM policies in each remote account that explicitly grant
    access to your central account repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you created ECR lifecycle policy rules that allow you to automatically
    and periodically remove untagged (orphaned) Docker images, which helps to reduce
    your storage costs. In the next chapter, you will learn how to build and publish
    your own custom ECS container instance Amazon Machine Images (AMIs), using a popular
    open source tool called Packer.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What command do you execute to obtain an authentication token for ECR?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/False: ECR allows you to publish and distribute Docker images publicly'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which ECR feature should you configure if you notice you have a lot of untagged
    images in your repository?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/False: ECR stores Docker images in a compressed format'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/False: ECR resource policies are required for configuring access to ECR
    from ECS container instances in the same account'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/False: ECR resource policies are required for configuring access to ECR
    from ECS container instances in a remote account'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/False: ECR resource policies are required for configuring access to ECR
    from AWS CodeBuild'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/False: IAM policies are required for configuring access to ECR from ECS
    container instances in the same account'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/False: IAM policies are required for configuring access to ECR from ECS
    container instances in a remote account'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ECR user guide: [https://docs.aws.amazon.com/AmazonECR/latest/userguide/what-is-ecr.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/what-is-ecr.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ECR repository CloudFormation resource: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecr-repository.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecr-repository.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Identity-based vs resource-based policies: [https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_identity-vs-resource.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_identity-vs-resource.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resource-level permissions for ECR repositories : [https://docs.aws.amazon.com/AmazonECR/latest/userguide/ecr-supported-iam-actions-resources.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ecr-supported-iam-actions-resources.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lifecycle policies for ECR: [https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS ECR CLI reference: [https://docs.aws.amazon.com/cli/latest/reference/ecr/index.html#cli-aws-ecr](https://docs.aws.amazon.com/cli/latest/reference/ecr/index.html#cli-aws-ecr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
