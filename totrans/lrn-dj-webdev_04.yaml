- en: Chapter 4. Building an Application Like Twitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned about better ways to write our code. Keeping
    those points in mind, it is high time that we get started with real Django project
    development and learn about views, models, and templates.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of each section in this chapter will be about the basics and
    how things work in the particular subject it deals with. This will include proper
    practices, standard methods, and important terminology.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of each section will be the application of that concept in our
    mytweets Django application development. The first parts can be thought of as
    chapter descriptions of the subjects and the second parts as exercises in the
    form of our Django project, which is really going to be a unique learning experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A word about Django terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Basic Template Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Django's template structure of the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the basic bootstrap for the Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Main Page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to class-based views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django settings for our mytweets project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating user pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing an initial database schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User registration and account management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template for the Main Page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A word about Django terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django is an MVC framework. However, throughout the code, the controller is
    called **view**, and the view is called **template**. The view in Django is the
    component which retrieves and manipulates the data, whereas the template is the
    component that presents data to the user. For this reason, Django is sometimes
    called a **Model Template View** (**MTV**) framework. This different terminology
    neither changes the fact that Django is an MVC framework, nor does it affect how
    applications are developed, but keep the terminology in mind to avoid possible
    confusion if you have worked with other MVC frameworks in the past.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of this chapter as an in-depth tour of the main Django components.
    You will learn how to create dynamic pages using views, how to store and manage
    data in the database using models, and how to simplify page generation using templates.
  prefs: []
  type: TYPE_NORMAL
- en: While learning about these features, you will form a solid idea of how Django
    components work and interact with each other. Later chapters will explore these
    components more deeply, as we develop more features and add them to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a basic template application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our project is going to be a microblogging site, where there will be a public
    page for every user, which will have a timeline of the tweets they have posted.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that comes to mind after seeing the welcome page of the development
    server is to ask how we can change it. To create our own welcome page, we need
    to define an entry point to our application in the form of a URL and tell Django
    to call a particular Python function when a visitor accesses this URL. We will
    write this Python function ourselves and make it display our own welcome message.
  prefs: []
  type: TYPE_NORMAL
- en: This section basically is a redo of the configuration we did in the previous
    chapter, but the intent is to place all the instructions together here so that
    the project bootstrapping requires fewer page look-ups.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will set up the virtual environment for Django to work properly by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to activate the virtual environment now and set up all the environment
    variables so that all Python installs will be routed to this environment directory
    without affecting other settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Installing Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although you have already installed Django, we will do this again because Django
    will be managed by `virtualenv`, which can't be messed up by other projects or
    users (or yourself) working elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You may get an error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If so, create your virtualenv environment within a path without spaces. It is
    most likely that, in the path to the location where you have created your virtual
    environment, there exists a directory whose name contains a space, for example,
    `/home/ratan/folder name with space$virtualenv django_env`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If so, change the directory name to something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/home/ratan/folder_name_with_no_space$virtualenv django_env`'
  prefs: []
  type: TYPE_NORMAL
- en: We can proceed with the Django installation using the command `pip install django`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, before we move to create our Django application, we will make sure Git
    is installed. Use the following command to find out the version of Git that we
    have installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This confirms that we have Git installed. Of course you must be wondering whether
    we are going to use version control in this project. The answer is yes: as we
    go along, we will version-control most of the project files.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Django's template structure of the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will create the structure for the project, for example,
    creating a folder called `mytweets` for our project, installing the required package
    for our project, and so on. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the folder called `mytweets`, which we will be using as our
    project directory. In the current folder, we see two subfolders: `environment`
    and `mytweets`. The question right now is whether we are going to version control
    our environment folder. We are not, because those files are very specific to your
    current system. They are not going to help anyone to set up the same environment
    as ours. However, there is another way of doing this in Python: by using the `pip
    freeze` command. This actually takes a snapshot of all the current libraries installed
    in your Django application, and then you can save that list in a text file and
    version control it. Thus your fellow developer can download the same version of
    the libraries. That''s really a Pythonic way of doing it, isn''t it?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common method for you to install the new packages is by using the
    `pip` command. There are the three versions of the `pip install` command, they
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the default and installs the latest version of the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `==` parameter, you can install a specific version of the package.
    In this case, that is 1.0.4\. Use the following command to install the package
    with a version number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Use the above command when you are not sure of the package version you are going
    to install but have an idea that you need the minimum version of the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very easy to use the `pip` command to install the libraries. You can
    do this by just typing the following into the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to freeze the libraries from the current project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This command freezes the current libraries installed in the project along with
    the version number, if specified, and stores them in a file named `requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage of our project, `pip freeze` command will look something like
    this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To install these libraries back to your fresh environment along with the project,
    we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus we can proceed with initializing only our code directory as a Git repository
    and changing the current path to `$cd mytweets`. Execute the following command
    to build a Git repository in your project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run all commands on a Linux-based system for detailed directory listing
    we can see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is the `.git` folder, which, as by its naming convention (starting with
    a dot), is hidden from the normal listing of the directory, that is, the directory
    where all Git-related files such as branches, commits, logs, and so on are stored.
    Deleting that particular directory will make your directory Git-free (free of
    version control) and as normal as any other directory in your current system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add all our current files in the directory to the staging area by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command for our first commit of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first line (here, its master) says that we are in the master's branch and
    the others that follow are the files being committed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have set up the basic Django template and added it to our version
    control. The same thing can be verified with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Instructions on setting up the author and generating `SSH` keys for a remote
    repository push can be found at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://help.github.com/articles/set-up-git](https://help.github.com/articles/set-up-git)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://help.github.com/articles/generating-ssh-keys](https://help.github.com/articles/generating-ssh-keys)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the basic Twitter Bootstrap for the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As introduced in the previous chapter, bootstrap is the basic framework for
    the user interface design. We will proceed with the second method mentioned, that
    is, by manually downloading the bootstrap files and linking them in the static
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method we are skipping means that we are not going to execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Detailed documentation for this implementation can be found at [http://django-bootstrap3.readthedocs.org/](http://django-bootstrap3.readthedocs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The method that we will be following is that of downloading the bootstrap files
    and placing them in the static folder of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with bootstrap, we have to start by downloading the static files from
    the following official bootstrap web address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://getbootstrap.com/](http://getbootstrap.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you visit this link, you will find a download button. After clicking on
    **Download**, click on **Download Bootstrap**. This will give you the bootstrap
    resource files in zipped format. This downloaded file will have a name something
    like `bootstrap-3.2.0-dist.zip`. Extract the content of this zip file. After extraction,
    the folder `bootstrap-3.2.0-dist` will have a structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Application-specific static files are stored in the `static` subdirectory within
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Django will also look in any directories listed in the `STATICFILES_DIRS` setting.
    Let's update our project settings to specify a static file directory in the `settings.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update our project''s `setting.py` file as follows to use Twitter bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `static` variable will be the folder we will be keeping our bootstrap
    files in. We will create the `static` folder inside our current project directory
    and will copy all bootstrap's unzipped files to that folder.
  prefs: []
  type: TYPE_NORMAL
- en: For development purposes, we will keep most of the settings as there are, for
    example, the default database SQLite; we can later move this while deploying our
    test application to MySQL or any other database of our choice.
  prefs: []
  type: TYPE_NORMAL
- en: Now, before we actually use bootstrap in our projects, there are some underlying
    concepts we must know to understand bootstrap as a front-end framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bootstrap designs the web pages based on the grid system, and there are three
    main components of this grid, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Container**: A container is used for giving a base to the whole web page,
    that is, generally, all the components of the bootstrap will be direct or nested
    child objects of the container. In other words, containers provide the width constraints
    on responsive widths. When the screen resolution changes, it''s the container
    which is changing its width across the device screen. The rows and columns are
    percentage based so they get automatically modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The container also provides a padding to the contents from browser edges so
    that they do not touch the side of the view area. The default padding is 15 px.
    You never need another container inside a container. The following image shows
    the structure of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the basic Twitter Bootstrap for the application](img/image00284.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Row**: A row is placed inside the container and contains the column. The
    hierarchy is `container` | `row` | `column` for bootstrap''s basic design. The
    row also acts like a wrapper for the columns, so in situations where columns are
    getting weird due to their default float left property, keep them separately grouped
    so that this problem is not reflected outside the row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rows have 15 px of negative margin on each side, which pushes them out over
    the top of the container's 15 px padding. As a result, they are negated and the
    row touches the edge of the container, the negative margin is overlapped by padding.
    Thus, the row is not pushed by the container's padding. Never use a row outside
    a container.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the basic Twitter Bootstrap for the application](img/image00285.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Column**: Columns have a 15 px padding. This means that the columns actually
    touch the edge of the row, which is already touching the edge of the container
    because of the negation property with the container discussed in the previous
    paragraph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Columns again have the 15 px padding, so the content of the columns is placed
    15 px away from the view edge of a container.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we don't need a special first and last column with padding on the
    left and right. There is now a consistent 15 px gap across all columns.
  prefs: []
  type: TYPE_NORMAL
- en: Content inside the columns are pushed to the columns location and are also separated
    by 30 px of gutter between them. We can use rows inside the column for nested
    layouts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the basic Twitter Bootstrap for the application](img/image00286.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Never use a column outside of a row.
  prefs: []
  type: TYPE_NORMAL
- en: With these points in mind, we can go ahead and design our first layout.
  prefs: []
  type: TYPE_NORMAL
- en: URLs and views – creating the main page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A view in Django terminology is a regular Python function that responds to
    a page request by generating the corresponding page. To write our first Django
    view for the main page, we first need to create a Django application inside our
    project. You can think of an application as a container for views and data models.
    To create it, issue the following command within our `django_mytweets` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The syntax of application creation is very similar to that of project creation.
    We used the `startapp` command as the first parameter of the `python manage.py`
    command, and provided `tweets` as the name of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this command, Django will create a folder named `tweets` inside
    the project folder with these three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__.py`: This file tells Python that `tweets` is a Python package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views.py`: This file will contain our views'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.py`: This file will contain our data models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s create the main page view. We will first create a `template` folder
    inside the project to keep all the HTML files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a base HTML file inside it named `base.html` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Our directory structure will look something like this now (use the `tree` command
    if you are on Linux OS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to class-based views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Class-based views are the new way of defining views in Django. They do not replace
    function-based views. They are just an alternative way to implement views as Python
    objects instead of functions. There are two advantages they have over function-based
    views. With a class-based view, different HTTP requests can be mapped to a different
    function, as opposed to a function-based view where the branching takes place
    based on the `request.method` parameter. Object-oriented techniques can be used
    to reuse the code component, such as **mixins** (multiple inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: Although we will be using class-based views for our project, to understand the
    exact difference between the two, here we will present the code for both.
  prefs: []
  type: TYPE_NORMAL
- en: We will have to update the `url.py` file of our project so that the `base.html`
    file will be served if the user requests the website.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function-based view**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `view.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `urls.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the development server by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We will see a response saying **I am called from a get Request**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class-based view**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `views.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will also generate the same result on the browser after the development
    server is hit. We will be using class-based views throughout the project.
  prefs: []
  type: TYPE_NORMAL
- en: What we have rendered is just a string, which was kind of simple. We have created
    a `base.html` file in our template folder and will now move ahead with our class-based
    view and render our `base.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Django, there is more than one way to render our page. We can render our
    page using any of these three functions: `render()`, `render_to_response()`, or
    `direct_to_template()`. However, let us first see what the difference between
    them is and which one we should be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '`render_to_response(template[, dictionary][, context_instance][, mimetype])`:
    The `render_to_response` command is the standard render function, and to use `RequestContext`,
    we will have to specify `context_instance=RequestContext(request)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render(request, template[, dictionary][, context_instance][, content_type][,
    status][, current_app])`. This is the new shortcut for the `render_to_response`
    command and is available from version 1.3 of Django. This will automatically use
    `RequestContext`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`direct_to_template()`: This is a generic view. It automatically uses `RequestContext`
    and all its `context_processor` parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the `direct_to_template` command should be avoided as function-based
    generic views are deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: We will choose the second one, the `render()` function, for rendering our `base.html`
    template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is the inclusion of the template folder in our Django application
    (the template folder we have created with the base file named `base.html`). To
    include the template, we will update the `settings.py` file in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This defines the template directory and initializes the basic `TEMPLATE_LOADER`
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Django settings for the mytweets project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's update the `settings.py` file with the minimal settings that we need for
    our `mytweets` project. Before starting our mytweets application we will add many
    settings which we will see with the following changes. For more information on
    this file, visit [https://docs.djangoproject.com/en/1.6/topics/settings/](https://docs.djangoproject.com/en/1.6/topics/settings/).
  prefs: []
  type: TYPE_NORMAL
- en: For the full list of settings and their values, visit [https://docs.djangoproject.com/en/1.6/ref/settings/](https://docs.djangoproject.com/en/1.6/ref/settings/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `settings.py` file of our project with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we start our development server, our screen will look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Django settings for the mytweets project](img/image00287.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our `base.html` file, we have written `class="h1"` instead of `<h1></h1>`.
    This was knowingly done to check at runtime whether the bootstrap files are being
    loaded, that is, with the `Header 1` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, we haven''t passed any variables to the template,
    which is what roughly differentiates static pages and dynamic pages. Let''s get
    ahead and do that too. All we need is some changes in the `views.py` and `base.html`
    files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changes in the `views.py` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Changes in the `base.html` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We can see how simple it is. All we did is just create a map (called **dictionary**
    in Python) and assigned the `name` property to it as Django and added it in the
    `render()` function as a new parameter. It gets rendered to the base of the HTML
    and is easily called `{{name}}`. When it is rendered, it replaces itself with
    Django.
  prefs: []
  type: TYPE_NORMAL
- en: We will be committing all the changes we have made until now. Before we do that,
    let's create a `.gitignore` file. What this does is, whatever content there is
    in this file (or wildcard for the files that we have written inside the `.gitignore`
    file), it will prevent all of them from committing and will send them to the repository
    server.
  prefs: []
  type: TYPE_NORMAL
- en: How does it help? It helps in many important use cases. Suppose we don't want
    to put any local configuration files onto the production server. The `.gitignore`
    file can be a savior in such situations, as also in a case when `.py` files generate
    their `.pyc` files, which are compiled at runtime. We don't need those binary
    files on the server, as they will be separately generated each time the code changes.
  prefs: []
  type: TYPE_NORMAL
- en: On the Linux command line, just type the `$vim .gitignore` command in the root
    folder of the project directory and write `*.pyc`. Then, save and exit in the
    usual way.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we execute the `$git status` command, we will not see any file with
    the `.pyc` extension, which means that Git has ignored tracking files that end
    with the `.pyc` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the `$git status` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is quite clear, as it should be. We have previously committed the `settings.py`
    and `urls.py` files, and now we've made some changes in them and the mentioned
    untracked files are not even added to Git for tracking.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `git add .` command to add all the changes to the directory.
    However, to avoid any unwanted files being pushed to Git tracking, it is recommended
    that files be added one by one when we are in an advanced phase of development.
    For the current situation, adding files all in one go is fine. To add the required
    file to our project, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Commit the changes with proper messages, such as "*basic bootstrap template
    added*":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together – generating user pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered a lot of material, such as introduction to the concepts
    of views and templates. In the final section, we will write another view and make
    use of all the information that we have learned so far. This view will display
    a list of all the tweets that belong to a certain user.
  prefs: []
  type: TYPE_NORMAL
- en: Familiarization with the Django models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Models are the standard Python classes with some added features. They are subclasses
    of `django.db.models.Model`. In the background, an **Object-Relational Mapper**
    (**ORM**) gets bound with these classes and their objects. This makes them communicate
    with the underlying database. ORM is one of the important features of Django,
    without which we will end up writing our own queries (SQL, if its MySQL) to access
    the database content. Each attribute of a model is represented by a database field.
    Without its fields, a model will be just like an empty container, with no meaning
    whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: The following are Django's model attributes explained with their intended use.
    A complete list of fields can be found on the stranded documentation at [https://docs.djangoproject.com/en/dev/ref/models/fields/](https://docs.djangoproject.com/en/dev/ref/models/fields/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a partial table of these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Field type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `IntegerField` | An integer |'
  prefs: []
  type: TYPE_TB
- en: '| `TextField` | A large text field |'
  prefs: []
  type: TYPE_TB
- en: '| `DateTimeField` | A date-and-time field |'
  prefs: []
  type: TYPE_TB
- en: '| `EmailField` | An e-mail field with 75 characters maximum |'
  prefs: []
  type: TYPE_TB
- en: '| `URLField` | A URL field with 200 characters maximum |'
  prefs: []
  type: TYPE_TB
- en: '| `FileField` | A file-upload field |'
  prefs: []
  type: TYPE_TB
- en: Each model field takes a set of field-specific arguments. For example, if we
    want a field to be a `CharField` field, we must pass its `max_length` parameter
    as its argument, which is mapped to the field size in `varchar` to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the arguments that can be applied to all the field types
    (they are optional):'
  prefs: []
  type: TYPE_NORMAL
- en: '`null`: By default, it is set to `false`. When set to `true`, the associated
    field is allowed to have a value of `null` stored in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blank`: By default, it is set to `false`. When set to `true`, the associated
    field is allowed to have a value of `blank` stored in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The difference between the `null` and `blank` parameters is that the `null`
    parameter is mainly database-related, whereas the `blank` parameter is used for
    validating the field. In other words, if the attribute is set to `false`, the
    empty value (`blank`) for the attribute will not get saved.
  prefs: []
  type: TYPE_NORMAL
- en: '`choices`: This can be a list or a tuple and must be iterable. If this is in
    the form of a tuple, the first element is the value that will get stored to the
    database and the second value is used for display in widget-like forms or `ModelChoiceField`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`default`: Values that are assigned to the attribute every time an object of
    the class is instantiated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help_text`: Help text displayed in the form of a widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`primary_key`: If set to `True`, this field is made primary key for the model.
    If there is no primary key in the model, Django will create an integer field and
    mark that as the primary key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationships in models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three major types of relationships: many-to-one, many-to-many, and
    one-to-one.'
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-one relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Django, the `django.db.models.ForeignKey` parameter is used to define a model
    as a foreign key to another model's attribute, which results in a many-to-many
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is used as any other attribute of a model class, after including the class
    in which it is present. For example, if students study in a particular school,
    the relationship is that the school has many students but a student goes to only
    one school, making this a many-to-one relationship. Let''s take a look at the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: One-to-one relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One-to-one relationships are very similar to many-to-one relationships. The
    only difference is that reverse mapping results in a single object in the case
    of one-to-one as opposed to many-to-one relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `EntryDetail()` class has an attribute called
    `entry`, which is mapped one-to-one with the `Entry` model. This means that every
    `Entry` object has been mapped to the `EntryDetail` model.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name itself suggests, model attributes with many-to-many relationships
    provide access to both the models it's been pointed to (like backward one-to-many
    relationships). Attribute naming is the only significant difference between the
    two relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be clearer if we go through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: With the idea of attribute and primary relationships, we can now straightaway
    create our projects model, which we will soon be doing in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: If we are going to design the model for an application, we should break up the
    applications if it has too many models. If we have more than roughly 15 models
    in our application, we should think about the ways in which to break our application
    into smaller applications. This is because, with the existing 15-model application,
    we are probably doing way too many things. This doesn't go with the Django philosophy
    of an *app should do one thing and do it right*.
  prefs: []
  type: TYPE_NORMAL
- en: Models – designing an initial database schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Coming back to our project, we will need two models in the initial phase: the
    `user` model and the `tweet` model. The `user` model will be used for storing
    the basic user details of the users that have accounts in our project.'
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the `tweet` model, which will store data related to the tweet, such
    as the tweet text, the user who has created that tweet, and other important details
    such as the timestamps of the tweet posted, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To list the tweets of a user, it will be better if we create a separate user
    application specific to all the users of our project. Our user models will be
    created by extending Django's `AbstractBaseUser` user model class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing the actual `user` class in your Django source tree and/or copying and
    altering the `auth` module is never recommended.
  prefs: []
  type: TYPE_NORMAL
- en: This will be the first application of using a framework for web development
    instead of writing the whole authentication by ourselves, which is pretty common
    to all web development scenarios. Django comes with predefined libraries so that
    we don't have to reinvent the wheel. It comes with both authentication and authorization
    together and is called the authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: Django's user objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An additional configurable user model is shipped with Django 1.5, which is the
    easier method for storing user-specific data in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a user application and then import the Django''s default user
    model into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We will extend the Django user model according to our need in the current project
    by creating a custom `User()` class that inherits from the `AbstractBaseUser`
    class. Therefore, our `models.py` file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have created our custom `user` class for the project, we can add
    all the basic attributes to this `user` class that we would like to be in the
    user model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now `models.py` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the custom user model `email` field has a property
    `unique` that is set to `True`. This means that a user can only register once
    with the given e-mail address, the verification can be done on the registration
    page. You will see a `db_index` option also in the `username` attribute with value
    `True`, which will index the user table on the `username` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '`joined` is the `dateTimeField` parameter populated automatically when a new
    user profile is created; the `is_active` field is set to `True` by default when
    a new user account is created, and the `is_admin` field is initialized to `False`
    at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: One more field is needed to make this almost the same as the default Django
    user model, which is the `username` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `USERNAME_FIELD` field in the `models.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`USERNAME_FIELD` also works as the unique identifier for a user model in Django.
    We have mapped our `username` parameter with Django''s `username` field. This
    field must be unique (`unique=True`) in its definition, which our `username` field
    already is.'
  prefs: []
  type: TYPE_NORMAL
- en: The `__unicode__()` method is also added as the definition that displays a human-readable
    representation of our user model object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the final `models.py` file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after defining our user model, we can move ahead to design the tweet model.
    This is the same application that we created to check out the basic class-based
    view. We will add content to its `models.py` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The tweet model is designed as to be as simplistic as possible for the user.
    The `attribute` parameter is a foreign key to the `User` object we have already
    created. The `text` attribute is the tweet content and it will mostly consist
    of plain text. The `created_Date` attribute, which is automatically added to the
    database when the `tweet` object is uninitialized, stores the name of the country
    from where the tweet has actually been posted. In most cases, it will be the same
    as the user's country. The `is_active` flag is used to represent the tweet's current
    status, whether it's active and can be displayed or has been deleted by the user.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create the tables in the database for both the models we just created,
    `user_profile` and `tweet`. We will have to update the `INSTALLED_APPS` variable
    of your project's `settings.py` file to tell Django to include these two applications
    in the Django project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our updated `INSTALLED_APPS` variable will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You can see the last two entries we made to add our models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to create the database table for our project, we will run the command from
    our root project folder in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You just installed Django''s auth system, which means you don''t have any superusers
    defined. You can see the following on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As a result, our database has been populated with a table. There will appear
    a database file for our project called `db.sqlite3`.
  prefs: []
  type: TYPE_NORMAL
- en: As with Django 1.6, the administrator panel comes by default. All we need for
    our models to be available in Django's admin panel is to add the `admin.site.register`
    parameter with the model name as argument for both the applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, after addition of `admin.site.register(parameter)` to both the `admin.py`,
    that is, under `mytweets` and `user_profile` files will look as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `admin.py` file of the `tweet` application would look as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `admin.py` file of the `user_profile` application would look as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the server using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Then visit the URL `http://127.0.0.1:8000/admin`; it will ask for login information.
    As you may remember, we have created the default user at the time of running the
    `$python manage.py syncdb` command; use the same username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'After successful login, the admin dashboard looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Django''s user objects](img/image00288.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s play with the admin dashboard and create a `user` and a `tweet` object
    that we will be using next for home page views. To add a new user to the project
    just click on the **Add** button in front of the user model box as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Django''s user objects](img/image00289.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then fill up the details and save it. You will see a **"user successfully created"**
    message as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Django''s user objects](img/image00290.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will follow a similar process for creating a tweet. First go back to `http://127.0.0.1:8000/admin/`.
    Then, click on the **Add** button in front of the tweet box.
  prefs: []
  type: TYPE_NORMAL
- en: '![Django''s user objects](img/image00291.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Compose a new tweet by filling out the boxes and selecting the user from the
    dropdown. This user list is already populated as we have mapped the user to the
    user object. As we keep on adding users, the dropdown will get populated with
    all the user objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Django''s user objects](img/image00292.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, after composing the tweet, click on the **Save** button. You will
    see the same screen shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Django''s user objects](img/image00293.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you look closely, the administrator listing page says every tweet is a `tweet`
    object, which is not very human-friendly. It can easily be customized for this
    case. In fact, the same rule is applicable for all the model base representations
    in the Django admin view or wherever they are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code snippet in the `admin.py` file of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Our admin view will now show the exact text instead of writing tweet object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Django''s user objects](img/image00294.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every user in our project will have a profile with a unique URL in the following
    format: `http://127.0.0.1:8000/user/<username>`. Here, the `username` variable
    is the owner of the tweets that we want to see. This URL is different from the
    first URL we added earlier because this contains a dynamic portion, so we will
    have to employ the power of regular expressions in order to express this URL.
    Open the `urls.py` file and edit it so that the URL table looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The pattern here looks more complicated than the first one. The annotation `\w`
    means an alphanumeric character or the underscore. The `+` sign after it causes
    the regular expression to match one or more repetitions of what precedes the sign.
    So, in effect,`\w+` means any string that consists of alphanumeric characters
    and possibly the underscore. We have surrounded this portion of the regular expression
    with parentheses. This will cause Django to capture the string that matches this
    portion and pass it to the view.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing needs explaining before we see the view in action. The regular
    expression that we used will look a bit strange if you haven't used regular expressions
    before. It is a raw string that contains two characters, `^` and `$`. The annotation
    `r''` is the Python syntax for defining raw strings. If Python encounters such
    a raw string, backslashes and other escape sequences are retained in the string,
    rather than being interpreted in any way. In this syntax, backslashes are left
    in the string without change and escape sequences are not interpreted. This is
    useful while working with regular expressions because they often contain backslashes.
  prefs: []
  type: TYPE_NORMAL
- en: In regular expressions, `^` means the beginning of the string and `$` means
    the end of the string. So `^$` basically means a string that doesn't contain anything,
    that is, an empty string. Given that we are writing the view of the main page,
    the URL of the page is the root URL and it should indeed be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python documentation of the `re` module covers regular expressions in detail.
    I recommend reading it if you want a thorough treatment of regular expressions.
    You can find the documentation online at [http://docs.python.org/lib/module-re.html](http://docs.python.org/lib/module-re.html).
    Here is a table that summarizes regular expression syntax for those who want a
    quick refresher:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol /expression | Matched string |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `. (Dot)` | Any character |'
  prefs: []
  type: TYPE_TB
- en: '| `^ (Caret)` | Start of string |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of string |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | 0 or more repetitions |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | 1 or more repetitions |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | 0 or 1 repetitions |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | A &#124; B means A or B |'
  prefs: []
  type: TYPE_TB
- en: '| `[a-z]` | Any lowercase character |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Any alphanumeric character or _ |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | Any digit |'
  prefs: []
  type: TYPE_TB
- en: We will now be creating a `Profile()` class with `GET` functions in the `view.py`
    file of our tweet application. The important thing to learn here is how the `get()`
    function handles the dynamic parameter passed through the URL, which is the `username`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `view.py` of our tweet application would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Templates – creating a template for the Main Page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are almost done with the model creation for our project. We will now move
    ahead and create the view page.
  prefs: []
  type: TYPE_NORMAL
- en: The first page we are going to create is the basic page which will list out
    all the tweets posted by a user. This can be a so-called public profile page that
    can be accessed without any authentication.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have noticed, we have used a `profile.html` file in the `Profile`
    class of the `views.py` file, which belongs to our tweet application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `views.py` file of our project will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We will use the Bootstrap framework, which we have already imported in our `base.html`
    file, to design the `Profile.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: We will first restructure the `base.html` file which we created for our application.
    Now this `base.html` file will be used as a template or theme of our project.
    We will import this file across the project, which results in constant user interface
    across the project.
  prefs: []
  type: TYPE_NORMAL
- en: We will just remove the `div` tag we placed inside the block content from our
    `base.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: We also need jQuery, which is a JavaScript library for complete functioning
    of bootstrap. It can be downloaded from [http://jquery.com/download/](http://jquery.com/download/).
    For our current project, we will download the latest version of jQuery in production-ready
    phase. We will be adding it before bootstrap's JavaScript import.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `base.html` file should look like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case the block is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that, whichever template we are going to extend the `base.html`
    file, currently in the `profile.html` file, the content of the `profile.html`
    file will be rendered between these block quotes. To understand this better, consider
    this: you have a header (in some cases, navigation bar) and footer on every page
    and the page content changes depending upon the view. With the preceding template,
    we generally need to place the header code before the block content and footer
    content below the block content.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a header is much easier now as we have the advantage of frontend framework.
    We will first choose the layout of our project. For simplicity, we will divide
    the whole page into three sections. The first will be the header, which will be
    constant as we navigate throughout the project. The same will apply to the bottom
    of the page, which is our footer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Templates – creating a template for the Main Page](img/image00295.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To achieve the preceding layout, our bootstrap code will be built in this way:
    we will use bootstrap''s `navbar` for our header section as well as for the footer
    section. Then we will place the container `div` tag. Our updated code for the
    `base.html` file will be changed to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `navbar` parameter will start in the body, but before the container, so
    that it can wrap the whole container. We use Django block content to render the
    rows which we will define in the extended templates, in this case, the `profile.html`
    file. The footer section comes in last, which is after the `endblock` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will render the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Templates – creating a template for the Main Page](img/image00296.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that if you do not get the static file included, replace the `STATICFILES_DIRS`
    variable with the following in your `settings.p` `y` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The design for the profile page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Templates – creating a template for the Main Page](img/image00297.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This can easily be designed again with the help of a bootstrap component called
    `well`. The `well` or `wellbox` components are used with an element to give it
    an inset effect. The `profile.html` file will just extend the `base.html` file
    and only contain rows and further elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `profile.html` file of our project would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show the tweets of a user we pass via a parameter in the URL. The
    example we have taken is the user `ratancs`, who we created during the initial
    setup. You can see their tweets in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Templates – creating a template for the Main Page](img/image00298.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned the basic terminology related to our Django project, what we need
    to set up the basic template structure of our project, and how to set up the bootstrap
    for our tweet-like application. We also saw how MVC works here and the role of
    URL and views while creating the main page.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we introduced class-based views to generate user pages. We saw how models
    work in Django and how to design the database schema for the project. We also
    learned to build a user registration page, an account management page, and a template
    for the main page.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn to design the algorithm for building a hashtag model and the mechanism
    to use hashtags in your post in the following chapters.
  prefs: []
  type: TYPE_NORMAL
