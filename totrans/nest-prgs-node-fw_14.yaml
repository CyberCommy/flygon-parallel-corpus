- en: Chapter 14\. Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated testing is a critical part of software development. Even though it
    cannot (and it’s not intended) to replace manual testing and other quality assurance
    methods. Automated testing is a very valuable tool when used properly, to avoid
    regressions, bugs, or incorrect functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Software development is a tricky discipline: even though many developers try
    to isolate different parts of software, it’s often unavoidable that some pieces
    of the puzzle have effect on other pieces, be it intended or unintended.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the main goals of using automated testing is to detect the kind of errors
    in which new code might break previously working functionality. These tests are
    known as *regression tests,* and they make the most sense when triggered as part
    of the merging or deployment process, as a required step. This means that, if
    the automated tests fail, the merge or deployment will be interrupted, thus avoiding
    the introduction of new bugs to the main codebase or to productive environments.
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing also enables a developmental workflow known as *test driven
    development (TDD.)* When following a TDD approach, automated tests are written
    beforehand, as very specific cases that reflect the requirements. Once the new
    tests are written, the developer runs *all tests;* the new ones should fail, since
    no new code has been written yet. At that point it’s when the new code has to
    be written so that the new tests pass, while not breaking the old ones.
  prefs: []
  type: TYPE_NORMAL
- en: The test driven development approach, if done right, can improve the confidence
    in code quality and requirement compliance. They can also make refactoring or
    even full code migrations, less risky.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main types of automated tests we are going to cover in this book:
    unit tests and end-to-end tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name implies, each unit test cover one specific functionality. The most
    important principles when dealing with unit tests are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**isolation;** each component has to be tested without any other related components;
    it cannot be affected by side effects and, likewise, it cannot emit any side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**predictability;** each test has to yield the same results as long as the
    input doesn’t change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In many cases, complying with these two principles means *mocking* (i.e. simulating
    the functionality of) the component dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike Angular, Nest.js doesn’t have an “official” toolset for running tests;
    this means we are free to set up our own tooling for running automated tests when
    we work in Nest.js projects.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple tools in the JavaScript ecosystem focused on writing and
    running automated unit tests. The typical solutions involve using several different
    packages for one setup, because those packages used to be limited in their scope
    (one for test running, a second one for assertions, a third one for mocking, maybe
    even another one for code coverage reporting).
  prefs: []
  type: TYPE_NORMAL
- en: We will, however, be using [Jest](https://facebook.github.io/jest/), an “all-in-one”,
    “zero-configuration” testing solution from Facebook that has greatly decreased
    the amount of configuration effort needed for running automated tests. It also
    officially supports TypeScript so it’s a great match for Nest.js projects!
  prefs: []
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you would expect, Jest is distributed as an npm package. Let’s go and install
    it in our project. Run the following command from your command line or terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We are installing three different npm packages as development dependencies:
    Jest itself; `ts-jest` that allows us to use Jest with our TypeScript code; and
    the Jest typings for their valuable contribution to our IDE experience!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember how we mentioned that Jest is a “zero-configuration” testing solution?
    Well, this is what their homepage claims. Unfortunately, it’s not entirely true:
    we still need to define a little amount of configuration before we are able to
    run our tests. In our case, this is mostly because we are using TypeScript. On
    the other hand, the configuration we need to write is really not that much, so
    we can write it as a plain JSON object.'
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s create a new JSON file in our project’s root folder, which we will
    name `nest.json`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`/nest.json`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This small JSON file is setting up the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Established files with `.js`, `.ts` and `.json` as modules (i.e. code) of our
    app. You might think we would not need `.js` files, but the truth is that our
    code will not run without that extension, because of some of Jest’s own dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tells Jest to process files with a `.ts` extension using the `ts-jest` package
    (which was installed before from the command line).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specifies that our test files will be inside the `/src` folder, and will have
    either the `.test.ts` or the `.spec.ts` files extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instructs Jest to generate code coverage reports from any `.ts` file on the
    `/src` folder, while ignoring the `node_modules` and the `vendor` folder contents.
    Also, to generate coverage it reports in both `JSON` and `LCOV` formats.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, the last step before we can start writing tests will be to add a couple
    of new scripts to your `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The three new scripts will, respectively: run the tests once, run the tests
    in watch mode (they will run after each file save), and run the tests and generate
    the code coverage report (which will be output in a `coverage` folder).'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE:** Jest receives its configuration as a `jest` property in the `package.json`
    file. If you decide to do things that way, you will need to omit the `--config=jest.json`
    arguments on your npm scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our testing environment is ready. If we now run `npm test` in our project folder,
    we will most likely see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The tests have failed! Well, they actually haven’t; we just have not written
    any tests yet! Let’s write some now.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have read some more chapters of the book, you probably remember our
    blog entries and the code we wrote for them. Let’s take a look back to the `EntryController`.
    Depending on the chapters, the code looked something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`/src/modules/entry/entry.controller.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this controller is a dependency to `EntriesService`. Since we mentioned
    that each component has to be tested in *isolation*, we will need to mock any
    dependency it might have; in this case, the `EntriesService`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write a unit test for the controller’s `findAll()` method. We will be
    using a special Nest.js package called `@nestjs/testing`, which will alow us to
    wrap our service in a Nest.js module specially for the test.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it’s important to follow the convention and name the test file `entry.controller.spec.ts`,
    and place it next to the `entry.controller.ts` file, so it gets properly detected
    by Jest when we trigger a test run.
  prefs: []
  type: TYPE_NORMAL
- en: '**`/src/modules/entry/entry.controller.spec.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now take a close look at what the test code is achieving.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we are declaring a test suite on `describe('EntriesController',
    () => {`. We also declare a couple of variables, `entriesController` and `entriesSrv`,
    to hold both the tested controller itself, as well as the service the controller
    depends on.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it comes the `beforeEach` method. The code inside that method will be
    executed right before each of the following tests are run. In that code, we are
    instantiating a Nest.js module for each test. Note that this is a particular kind
    of module, since we are using the `.createTestingModule()` method from the `Test`
    class that comes from the `@nestjs/testing` package. So, let’s think about this
    module as a “mock module,” which will serve us for testing purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the fun part: we include the `EntriesController` as a controller
    in the testing module. We then proceed to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This substitutes the original `EntryService`, which is a dependency of our tested
    controller. This is for a mock version of the service, which is not even a class,
    since we don’t need it to be, but rather an object with a `findAll` method that
    takes no arguments and returns null.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the result of the two code lines above as an empty, dumb service
    that only repeats the methods we will need to use later, without any implementation
    inside.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `.compile()` method is the one that actually instantiates the module,
    so it gets bound to the `module` constant.
  prefs: []
  type: TYPE_NORMAL
- en: Once the module is properly instantiated, we can bind our previous `entriesController`
    and `entriesSrv` variables to the instances of the controller and the service
    inside the module. This is achieved with the `module.get` method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all this initial setup is done, we are good to start writing some actual
    tests. Let’s implement one that checks whether the `findAll()` method in our controller
    correctly returns an array of entries, even if we only have one entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `describe('findAll', () => {` line is the one that starts the actual test
    suite. We expect the resolved value of `entriesController.findAll()` to be an
    array. This is basically how we wrote the code in the first place, so it should
    work, right? Let’s run the tests with `npm test` and check the test output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It failed... Well, of course it failed! Remember the `beforeEach()` method?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We told Nest.js to exchange the original `findAll()` method in the service for
    another one that returns just `null`. We will need to tell Jest to mock that method
    with something that returns an array, so to check that when the `EntriesService`
    returns an array, the controller is in fact returning that result as an array
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In order to mock the `findAll()` method from the service, we are using two Jest
    methods. `spyOn()` takes an object and a method as arguments, and starts watching
    the method for its execution (in other words, sets up a *spy*). And `mockImplementationOnce()`,
    which as its name implies changes the implementation of the method when it’s next
    called (in this case, we change it to return an array of one empty object.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to run the test again with `npm test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The test is passing now, so you can be sure that the `findAll()` method on the
    controller will always behave itself and return an array, so that other code components
    that depend on this output being an array won’t break themselves.
  prefs: []
  type: TYPE_NORMAL
- en: If this test started to fail at some point in the future, it would mean that
    we had introduced a regression in our codebase. One of the great sides of automated
    testing is that we will be notified about this regression before it’s too late.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for equality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until this point, we are sure that `EntriesController.findAll()` returns
    an array. We can’t be sure that it’s not an array of empty objects, or an array
    of booleans, or just an empty array. In other words, we could rewrite the method
    to something like `findAll() { return []; }` and the test would still pass.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s improve our tests to check that the method really returns the output
    from the service, without messing things up.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We just kept most of the test file as it was before, although we did add a
    new test, the last one, in which:'
  prefs: []
  type: TYPE_NORMAL
- en: We set an array of one *not-empty* object (the `result` constant).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We mock the implementation of the service’s `findAll()` method once again to
    return that `result`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We check that the controller returns the `result` object exactly as the original
    when called. Note that we are using the Jest’s `.toEqual()` method which, unlike
    `.toBe()`, performs a deep equality comparison between both objects for all of
    their properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is what we get when we run `npm test` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Both our tests pass. We accomplished quite a lot already. Now that we have a
    solid foundation, extending our tests to cover as many test cases as possible
    will be an easy task.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we have only written a test for a controller. But testing services
    and the rest of the pieces of our Nest.js app works the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Covering our code in tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One critical aspect in code automation is code coverage reporting. Because,
    how do you know that your tests actually cover as many test cases as possible?
    Well, the answer is checking code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to be really confident in your tests as a regression detection systems,
    make sure that they cover as much functionality as possible. Let’s imagine we
    have a class with five methods and we only write tests for two of them. We would
    have roughly two-fifths of the code covered with tests, which means that we won’t
    have any insights about the other three-fifths, and about whether they still work
    as our codebase keeps on growing.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage engines analyze our code and tests together, and check the amount
    of lines, statements, and branches that are covered by the tests running in our
    suites, returning a percentage value.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in previous sections, Jest already includes code coverage reporting
    out of the box, you just need to activate it by passing a `--coverage` argument
    to the `jest` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a script in our `package.json` file that, when executed, will generate
    the coverage report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When running `npm run test:coverage` on the controller written before, you
    will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In order to have a better vision of the console output within this book, we
    will transform the console output to a proper table.
  prefs: []
  type: TYPE_NORMAL
- en: '| File | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| All files | 100 | 66.67 | 100 | 100 |  |'
  prefs: []
  type: TYPE_TB
- en: '| entry.controller.ts | 100 | 66.67 | 100 | 100 | 6 |'
  prefs: []
  type: TYPE_TB
- en: You can easily see we are covering 100% of our code lines in our tests. This
    makes sense since we wrote two tests for the only method in our controller.
  prefs: []
  type: TYPE_NORMAL
- en: Failing tests for low coverage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s imagine now that we work in a complex project with several developers
    working on the same base at the same time. Let’s imagine also that our workflow
    includes a Continuous Integration/Continuous Delivery pipeline, running on something
    like Travis CI, CircleCI, or even Jenkins. Our pipeline would likely include a
    step that runs our automated tests before merging or deploying, so that the pipeline
    will be interrupted if the tests fail.
  prefs: []
  type: TYPE_NORMAL
- en: All the imaginary developers working in this imaginary project will add (as
    well as refactor and delete, but those cases don’t really apply to this example)
    new functionality (i.e. *new code*) all the time, but they might forget about
    properly testing that code. What would happen then? The coverage percentage value
    of the project would go down.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to still be sure that we can rely on our tests as a regression detection
    mechanism, we need to be sure that the coverage never goes *too low*. What is
    too low? That really depends on multiple factors: the project and the stack it
    uses, the team, etc. However, it’ normally a good rule of thumb not letting the
    coverage value go down on each coding process iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, Jest allows you to specify a coverage threshold for tests: if the value
    goes below that threshold, the tests will return failed *even if they all passed*.
    This way, our CI/CD pipeline will refuse to merge or deploy our code.'
  prefs: []
  type: TYPE_NORMAL
- en: The coverage threshold has to be included in the Jest configuration object;
    in our case, it lives in the `jest.json` file in our project’s root folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Each number passed to each property of the object is a percentage value; below
    it, the tests will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate it, let’s run our controller tests with the coverage threshold
    set as above. `npm run test:coverage` returns this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the tests passed, yet the process failed with status 1 and
    returned an error. Also, Jest reported `"global" coverage threshold for branches
    (80%) not met: 66.67%`. We have successfully kept non-acceptable code coverage
    away from our main branch or productive environments.'
  prefs: []
  type: TYPE_NORMAL
- en: The following step could be now to implement a few end-to-end tests, along with
    our unit tests, to improve our system.
  prefs: []
  type: TYPE_NORMAL
- en: E2E testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While unit tests are isolated and independent by definition, end-to-end (or
    E2E) tests serve for, in a way, the opposite function: they intend to check the
    health of the system as a whole, and try to include as many components of the
    solution as possible. For this reason, in E2E tests we will focus on testing complete
    modules, rather than isolated components or controllers.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately, we can use Jest for E2E testing just like we did for unit testing.
    We will only need to install the `supertest` npm package to perform API requests
    and assert their result. Let’s install it by running `npm install --save-dev supertest`
    in your console.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will create a folder called `e2e` in our project’s root folder. This
    folder will hold all of our E2E test files, as well as the configuration file
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the next step: create a new `jest-e2e.json` file inside the
    `e2e` folder with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the new E2E configuration object is very similar to the one
    for unit tests; the main difference is the `testRegex` property, which now points
    to files in the `/e2e/` folder that have a `.e2e-test` or `e2e.spec` file extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step of the preparation will be to include an npm script in our `package.json`
    file to run the end-to-end tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Writing end-to-end tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way of writing E2E tests with Jest and Nest.js is also very similar to
    the one we used for unit tests: we create a testing module using the `@nestjs/testing`
    package, we override the implementation for the `EntriesService` to avoid the
    need for a database, and then we are ready to run our tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the code for the test. Create a new folder called `entries` inside
    the `e2e` folder, and then create a new file there called `entries.e2e-spec.ts`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s review what the code does:'
  prefs: []
  type: TYPE_NORMAL
- en: The `beforeAll` method creates a new testing module, imports the `EntriesModule`
    in it (the one we are going to test), and overrides the `EntriesService` implementation
    with the very simple `mockEntriesService` constant. Once that’s done, it uses
    the `.createNestApplication()` method to create an actual running app to make
    requests to, and then waits for it to be initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `'/GET entries'` test uses a supertest to perform a GET request to the `/entries`
    endpoint, and then asserts whether the status code of the response from that request
    was a `200` and the received body of the response matches the `mockEntriesService`
    constant value. If the test passes, it will mean that our API is correctly reacting
    to requests received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `afterAll` method ends the Nest.js app we created when all of the tests
    have run. This is important to avoid side effects when we run the tests the next
    time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have explored the importance of adding automated tests to
    our projects and what kind of benefits it brings.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we got started with the Jest testing framework, and we learned how to
    configure it in order to use it seamlessly with TypeScript and Nest.js
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we reviewed how to use the testing utilities that Nest.js provides for
    us, and learned how to write tests, both unit tests as well as end-to-end ones,
    and how to check the percentage of the code our tests are covering.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and last chapter we cover server-side rendering with Angular Universal.
  prefs: []
  type: TYPE_NORMAL
