- en: Chapter 13. CGL and LSB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will be presented with information about the last topic
    of the book, the **Carrier Grade Linux** (**CGL**) and **Linux Standard Base**
    (**LSB**) initiative and of course, a parallel with what there is integrated and
    supported related to those two standards into the Yocto Project. This will also
    be mentioned here and you will not only be able to find a little bit about these
    standards and their specifications, but also about the level of support that Yocto
    offers for them. I will also present some of the initiatives adjacent to CGL,
    such as **Automotive Grade Linux** and **Carrier Grade Virtualization**. They
    also constitute viable solutions that are available in a wide palette of applications.
  prefs: []
  type: TYPE_NORMAL
- en: In any Linux environment today, there is necessity for a common language for
    available Linux distributions. This common language would have not been achieved
    without defining actual specifications. A part of these specifications is also
    represented by the carrier grade alternative. It coexists with other specifications
    that are already presented in this book or in other similar books. Taking a look
    at the available specifications and standardizations only shows us how much the
    Linux ecosystem has evolved over time.
  prefs: []
  type: TYPE_NORMAL
- en: The latest report published by the guys working at the Linux Foundation shows
    how the development of the Linux kernel is actually done nowadays, what it's like
    to work on it, who is sponsoring it, what changes are being made to it, and how
    fast things are moving. The report is available at [https://www.linuxfoundation.org/publications/linux-foundation/who-writes-linux-2015](https://www.linuxfoundation.org/publications/linux-foundation/who-writes-linux-2015).
  prefs: []
  type: TYPE_NORMAL
- en: As depicted in the report, less than 20 percent of development on the kernel
    is done by individual developers. Most of the development is realized by companies,
    such as Intel, Red Hat, Linaro, Samsung, and others. This means that over 80 percent
    of the developers working at Linux kernel development are paid for their job.
    The fact that Linaro and Samsung are some of the companies with the most number
    of commits, only presents a favorable perception of the ARM processors in general,
    and Android in particular.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting piece of information is that more than half of the Linux
    kernel developers are at their first commit. This means that a really small number
    of developers are doing the vast majority of work. This dysfunction in the development
    of the Linux kernel process is being tried to be reduced by the Linux Foundation
    by offering various programs for students to make them more involved in the development
    process. Whether this is a success, only time will tell, but it is my opinion
    that they are doing the right thing and are moving in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: All of this information has been explained with regard to the Linux kernel,
    but parts of it are applicable for other open source components. The thing that
    I want to emphasize here is that the ARM support in Linux is much more mature
    than in architectures such as PowerPC or MIPS. This has started to not only be
    obvious, but is also an indication of the approach that the Intel x86 stage has
    taken. Until now, this approach was simply not disturbed by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: Linux Standard Base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LSB appeared to lower the costs of support offered by Linux platforms by reducing
    the differences between various available Linux distributions. It also helps with
    costs for porting applications. Every time a developer writes an application,
    they need to make sure that the source code produced on one Linux distribution
    will also be able to be executed on other distributions as well. They would also
    like to make sure that this remains possible over the years.
  prefs: []
  type: TYPE_NORMAL
- en: The LSB workgroup is a Linux Foundation project that tries to address these
    exact problems. For this purpose, LSB workgroup started working on a standard
    that could describe a set of APIs that a Linux distribution should support. With
    the standards defined, the workgroup also moved a few steps further and developed
    a set of tools and tests to measure the support levels. With this done, they were
    able to define certain sets of compliance and also detect the certain differences
    between various distributions.
  prefs: []
  type: TYPE_NORMAL
- en: The LSB was the first effort to be made in this direction by the Linux Foundation
    and became an umbrella for all the workgroups that have tried to provide standardization
    to various areas of the Linux platform. All these workgroups have the same roadmap
    and they deliver their corresponding set of specifications, software components,
    such as conformance tests, developments tools, and other available samples and
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Every software component developed by one of the workgroups that is available
    inside the Linux Standard Base is defined as a `lsb` module. All of these modules
    have a common format to facilitate easier integration between them. There are
    modules that are required and optional. The required ones are the ones that meet
    the acceptance criteria for LSB. The optional ones are still a work in progress
    and are, at the moment of specifications defining, not written in the acceptance
    criteria, but will be included in future versions of the LSB standard.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, workgroups that do not produce `lsb` modules. They have
    not worked on the standard either but instead, they have integrated various patches
    in projects, such as the Linux kernel or other packages and even documentation.
    These are not the workgroups that this section is referring to. This section only
    takes LSB-related workgroups into account.
  prefs: []
  type: TYPE_NORMAL
- en: From time to time, whenever a new specification document is released, a testing
    kit is also made available to vendors to test the kit's compliance to a particular
    version. The vendors could test their product compliance, which can be in the
    form of an application or a Linux distribution. The result of the testing kit
    is a certification that indicates that their product is LSB certified. For an
    application we, of course, have an **LSB Application Testkit**. There is also
    a similar one for a Linux distribution as well as others that are available for
    a variety of distributions.
  prefs: []
  type: TYPE_NORMAL
- en: For vendors who are interested in optional modules, these are not only available
    to help vendors prepare their future LSB compliance certification, but also to
    expose them to optional modules in order to get more vocal reviews and contributions
    from them. Also, the vendor's vote is related to the existence of these modules
    in future LSB specification documentations whose release is also important. The
    vendors could establish whether one optional module is eligible for future inclusions
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: The LSB workgroup is governed by the Steering Committee and is led by a Chairperson
    who is elected. These two entities represent the interests of the workgroup. The
    workgroup operates on a rough consensus model. This indicates the solution of
    the group regarding a particular problem, that is, a solution that is determined
    by the elected Chairperson. If the contributor does not consider their decision
    and does not meet the criteria required to reach a rough consensus, then the Steering
    committee is appealed.
  prefs: []
  type: TYPE_NORMAL
- en: All business that is specific to the LSB workgroup is carried out inside an
    open forum. It can include a mailing list, conference, wiki page, or even a face-to-face
    meeting; the activities are not closed for members of workgroups. Also, membership
    is not restricted and decisions are clearly documented because there is always
    a possibility of having a further discussion on a particular subject at a later
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are clearly defined roles in workgroups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Contributor**: This refers to actively involved individuals. They always
    have list with them available for the Chairperson, but any individual may request
    inclusion to the Contributors list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chairperson**: This refers to the representative Project leader. A person
    is elected to this position by Contributors and approved by the Steering Committee
    and the Linux Foundation board. Once elected, they are able to hold this position
    for two years. There is no limit to the number of times someone can be elected.
    Removal from this position can occur in case of a lack of confidence on behalf
    of the Steering Committee or the Linux Foundation board. After the position is
    vacant, a new election is carried out. During the vacancy period, the Steering
    Committee will assign an acting Chairperson.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Election Committee**: This refers to a committee of Contributors that are
    established by the Steering Committee for Chairperson election. It is responsible
    for selecting candidates for the position of Chairperson within at least 30 days
    before the Chairperson''s term expires or 10 days after the Chairperson''s position
    is vacant. It is responsible for conducting elections, which is done through electronic
    ballots. There is only one vote accepted from an individual; the votes are secret
    and only done by eligible members. The voting period is one week, and then the
    results are presented to the Steering Committee, which approves the votes and
    declares the winner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steering Committee**: It consists of representative workgroup stakeholders.
    They may be distribution vendors, OEMs, ISVs, upstream developers, and the Chairpersons
    of the LSB sub workgroups that come under the LSB charter. The committee is appointed
    by the Chairperson and depending on their involvement in workgroup activities,
    they can keep the position indefinitely. One member can be removed from the Steering
    Committee by three entities: the Chairperson, the other Steering Committee members,
    or by the Linux Foundation board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an image depicting a more detailed structure of the LSB workgroup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linux Standard Base](img/image00383.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The LSB is a fairly complex structure, as depicted in the preceding image, so
    more roles can be defined in a workgroup if necessary. The main focus of the workgroup
    remains its mission; for this to be achievable, new workgroups need to be promoted
    and nurtured. They require a certain level of independence, but also be accountable
    for the activities done in the LSB Chairperson. This mainly involves making sure
    that certain deadlines are met and that the project sticks to its roadmap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in the interaction process with the LSB deliverables should
    be establishing the exact LSB requirements that need to be met by a target system.
    The specifications are available as two components: architecture-dependent and
    architecture-independent, or as it is also called, a generic component. The architecture-dependent
    components contain three modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Architecture independent components contain five modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is, of course, another structure used to order them. Here, I am referring
    to the fact that some of these are mandatory and others are in a state of trial
    and testing. The first category is in order to have a distribution that is compliant
    with LSB standards, while the second category is not a strict requirement for
    having a compliant distribution that could represent future candidates for the
    next few versions of LSB.
  prefs: []
  type: TYPE_NORMAL
- en: The following image represents the key deliverable components of LSB. I hope
    it guides you through the components of this project as well as gathers the information
    that you need for future interaction with the various components of the LSB workgroup.
  prefs: []
  type: TYPE_NORMAL
- en: '![Linux Standard Base](img/image00384.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Depending on the interest of users, they can chose to either interact with the
    distribution development or the development of the components of an application.
    As clearly depicted in the preceding image, each of the two roads has its tools
    for the job. Before starting a job, make sure that you take a look at the website
    of the LSB Navigator and gather the required information. For users who are interested
    in a demonstration of LSB navigator, there is one available in the following link
    that also involves the interaction of Yocto. Make sure that you check it out and
    interact with it to get an idea of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LSB Navigator can be accessed at [http://www.linuxbase.org/navigator/commons/welcome.php](http://www.linuxbase.org/navigator/commons/welcome.php).
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that the interaction is already done and you are now interested
    in collaborating with this project. Of course, there are multiple methods to do
    this. Whether you are a developer or a software vendor, your feedback is always
    helpful for any project. Also, for developers who would like to contribute with
    code, there are multiple components and tools that could benefit from your help.
    That is not all. There are a lot of testing frameworks and testing infrastructures
    that always require improvements, so someone can contribute not only with code
    but also bug fixing and development or the testing of tools. Also, remember that
    your feedback is always appreciated.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving to the next section, I want to introduce one more thing. As depicted
    in the previous diagram, any activity that is executed by a developer, with regard
    to the components of the LSB workgroup, should be done after the LSB specifications
    are inspected and the appropriate version is selected. For example, in the CGL
    Specifications, there is an explicit requirement of at least LSB 3.0, as well
    as the required modules, that are indicated in the same requirement description.
    For developers who want more information about the required specification and
    its components, refer to [http://refspecs.linuxfoundation.org/lsb.shtml](http://refspecs.linuxfoundation.org/lsb.shtml).
    Make sure that you also inspect the progress made on the newly available LSB 5
    specifications, which passed the beta stage and, at the moment, is in its RC1
    state. More information about this is available at [https://www.linuxfoundation.org/collaborate/workgroups/lsb/lsb-50-rc1](https://www.linuxfoundation.org/collaborate/workgroups/lsb/lsb-50-rc1).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about the LSB is available at [http://www.linuxfoundation.org/collaborate/workgroups/lsb](http://www.linuxfoundation.org/collaborate/workgroups/lsb).
  prefs: []
  type: TYPE_NORMAL
- en: Carrier grade options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple options will be discussed in this section, and we'll start by defining
    the term *carrier grade*. This seems like the perfect start. So, what does this
    term mean in a telecommunications environment? It refers to a system, software,
    and even hardware components that are really reliable. Here, I am not referring
    only to the five-nines or six-nines that CGL provides because not all industries
    and scenarios require this kind of reliability. We are only going to refer to
    something that can be defined as reliable in the scope of a project. For a system,
    software, or hardware component to be defined as carrier grade, it should also
    prove itself as well tested along with all sorts of functionalities, such as high
    availability, fault tolerance, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: These five-nines and six-nines refer to the fact that a product is available
    99.999 or 99.9999 percent of the time. This translates per year in a downtime
    of around 5 minutes for five-nines and 30 seconds for six-nines requirements.
    Having explained this, I will move on and present the available options of carrier
    grade.
  prefs: []
  type: TYPE_NORMAL
- en: Carrier Grade Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is the first and oldest option available. It appeared as a necessity for
    the telecommunication industry in order to define a set of specifications, which
    in turn defined a set of standards for Linux-based operating systems. After implementations,
    this would make the system carrier grade capable.
  prefs: []
  type: TYPE_NORMAL
- en: The motivation behind the CGL is to present an open architecture as a possible
    solution or an alternative to the already available proprietary and closed source
    available solutions that were already available in telecommunication systems.
    The open architecture alternative is the best not only because it avoids a monolithically
    form, is not hard to maintain, scale, and develop, but also it offers the advantage
    of speed. It is faster and cheaper to have a system that is decoupled and makes
    its components accessible to a larger number of software or hardware engineers.
    All of these components would be able to serve the same purpose in the end.
  prefs: []
  type: TYPE_NORMAL
- en: The workgroup was initially started by the **Open Source Development Lab** (**OSDL**),
    which after its merger with Free Standards Group formed The Linux Foundation.
    Now all the work moved there together with the workgroup. The latest available
    release for CGL is 5.0 and it includes registered Linux distributions, such as
    Wind River, MontaVista, and Red Flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OSDL CGL workgroup has three categories of applications that CGL could
    fit into:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signalling server applications**: This includes products that provide control
    services for calls and services, such as routing, session control, and status.
    These products usually handle a large number of connections, around 10000 or 100000
    simultaneous ones, and also because that they have real-time requirements that
    require obtaining results from processes under a millisecond.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gateway applications**: These provide the bridging of technology and administrative
    domains. Besides the characteristics that have been mentioned already, these handle
    a large number of connections in a real-time environment over a not very large
    number of interfaces. These are also required to not lose frames or packages in
    the communication process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Management applications**: These usually provide billing operations, network
    management, and other traditional services. They does not have the same strong
    requirements for real-time operations, but instead, concentrate on fast database
    operations and other communication-oriented requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make sure that it is able to satisfy the preceding categories, the CGL workgroup
    focuses on two main activities. The first one involves communicating with all
    the preceding categories, the identification of their requirements, and the writing
    specifications that should be implemented by distribution vendors. The second
    one involves gathering and helping projects that meet the requirements defined
    in the specifications. As a conclusion to what I mentioned previously, CGL tries
    to represent not only the telecommunication industry representatives and Linux
    distributions, but also end users and service providers; it also provides carrier
    grade options for each one of these categories.
  prefs: []
  type: TYPE_NORMAL
- en: Each distribution vendor who wants to get the CGL certification offers its implementation
    as a template. It is filled with versions of packages, names, and other extra
    information. However, it does this without disclosing too much information about
    the implementation process; these packages have the possibility of being proprietary
    software. Also, the disclosed information is owned and maintained by the vendor.
    The CGL workgroup only displays the link offered by the vendor.
  prefs: []
  type: TYPE_NORMAL
- en: The specification document is now at version 5.0 and contains both requirements
    that are, in fact, mandatory for applications or optional and are related to the
    implementations made in the Linux distribution for a carrier grade certification.
    The mandatory ones are described by the P1 priority level and the optional ones
    are marked as P2\. The other elements are related to the gap aspect that represents
    a functionality, which is not implemented since an open source implementation
    is not available for it. The requirements are presented in the specification document
    to motivate distribution developers contribute to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As depicted in the following image and as emphasized in the information contained
    in the specification document, the CGL system should provide a large number of
    functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Carrier Grade Linux](img/image00385.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the requirement for number of functionalities is big, the workgroup decided
    to group them into various categories as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Availability**: It is relevant for single node availability and recovery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clustering**: It describes components that are useful in building a cluster
    from individual systems. The key target behind this is the high availability of
    the system and load balancing that could also bring some performance improvements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serviceability**: It covers the maintenance and servicing features of the
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: It describes features, such as real-time requirements and
    others, that could help the system attain better performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standards**: These are provided as references to various APIs, standards,
    and specifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware**: It presents various hardware-specific support that is necessary
    for a carrier grade operating system. Much of it comes from hardware vendors who
    are themselves involved in this process and the requirements from this section
    has been highly diminished in the latest CGL specification release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: It represents the relevant features needed to build a secure
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on CGL requirements, refer to [https://www.linuxfoundation.org/sites/main/files/CGL_5.0_Specification.pdf](https://www.linuxfoundation.org/sites/main/files/CGL_5.0_Specification.pdf).
    You can also refer to the CGL workgroup at [https://www.linuxfoundation.org/collaborate/workgroups/cgl](https://www.linuxfoundation.org/collaborate/workgroups/cgl).
  prefs: []
  type: TYPE_NORMAL
- en: Automotive Grade Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automotive Grade Linux is also a Linux Foundation workgroup. It is newly formed
    and tries to offer an open source solution that has automotive applications. Its
    primary focus is the In-Vehicle-Infotainment sector, but it includes telematics
    systems and instrument clusters. It efforts are based on open source components
    that are already available. These are suitable for its purposes and try to also
    enable rapid development, which is much needed in this industry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goals of the workgroup are:'
  prefs: []
  type: TYPE_NORMAL
- en: A transparent, collaborative, and open environment for involved elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Linux operating system stack that is focused on automotives and uses the open
    source community represented by exponents, such as developers, academic components,
    and companies as back support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A collective voice for interaction in the open source community released this
    time in the reverse form, from the AGL to the community.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An embedded Linux distribution used for fast prototyping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using projects, such as Tizen, as the reference distribution and having projects,
    such as Jaguar, Nissan, Land Rover, or Toyoto, this project is interesting enough
    to be followed closely. It has just been developed but has potential for improvements.
    For those of you interested in it, refer to [https://www.linuxfoundation.org/collaborate/workgroups/automotive-grade-linux](https://www.linuxfoundation.org/collaborate/workgroups/automotive-grade-linux).
    The project's wiki page is an interesting resource and can be consulted at [https://wiki.automotivelinux.org/](https://wiki.automotivelinux.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Carrier Grade Virtualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recent development of CGL made virtualization an interesting option for
    the carrier grade field because it involved a reduction in costs as well as transparency
    in leveraging multicore equipment that runs single-core designed applications.
    Virtualization options also needed to meet the same expectations as the other
    carrier grade systems.
  prefs: []
  type: TYPE_NORMAL
- en: Carrier Grade Virtualization has tried to become a vital component to be integrated
    in carrier grade platforms that are already available. This is done to preserve
    the attributes and performance of the system. It also tries to extend the appliance
    target and permits **Original Equipment Manufacturer** (**OEM**) to derive the
    benefits from the same support as the CGL. These benefits are in the form of well
    established targets.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization's application is more widespread, which can be seen ranging from
    the x86 architecture to ARM and DSP-based processors as well as a variety of domains.
    The examination of virtualization from a carrier grade point of view is the focus
    of this solution because, in this way, you can get a clearer perspective of the
    areas that require improvements. In this way, these can be identified and enhancements
    can also be applied as required. Unfortunately, this initiative has not been as
    exposed as some other ones, but is still a very good source of documentation and
    is available from virtualLogix at [http://www.linuxpundit.com/documents/CGV_WP_Final_FN.pdf](http://www.linuxpundit.com/documents/CGV_WP_Final_FN.pdf).
    I hope you enjoy its content.
  prefs: []
  type: TYPE_NORMAL
- en: Specific support for the Yocto Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Poky reference system, support is provided for the development of LSB
    and LSB compatible applications. Inside Poky, there is a special `poky-lsb.conf`
    distribution policy configuration that is defined in case a distribution is interested
    in developing applications that are LSB-compliant. This holds true when generating
    a Linux distribution that is LSB-compliant or at least prepares to take the LSB
    certification. The build steps required for a Linux distribution that prepares
    for an LSB certification will be presented here. In case you are interested in
    developing LSB-compliant applications, the process is simpler and will also be
    briefly presented here; however, it is in contrast to the former.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is simple: it only requires cloning the poky repository and
    the `meta-qt3` dependency layer because of the requirements of the LSB modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the build directory needs to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `conf/bblayers.conf` file, only the `meta-qt3` layer needs to be
    added. Inside the `conf/local.conf` file, the corresponding machine should be
    selected. I would suggest a capable platform, but using an emulated architecture,
    such as `qemuppc`, ought to be enough for such a demo if enough CPU power and
    memory is offered to it. Also, make sure that you change the `DISTRO` variable
    to `poky-lsb`. Having all these in place, the build process can start. The command
    necessary for this is is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After the resulting binaries are generated and booted on the selected machine,
    the user is able to either run all the tests using the `LSB_Test.sh` script, which
    also sets the LSB test framework environment, or run specific test suites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If various tests are not passing, the system needs to be reconfigured to ensure
    the required compatibility level. Inside `meta/recipes-extended/images`, besides
    the core`-image-lsb.bb` recipes, there are also two similar recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`core-image-lsb-sdk.bb`: It includes a `meta-toolchain` and the necessary libraries
    and development headers that are needed to generate an SDK for application development'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core-image-lsb-dev.bb`: It is suitable for development work on targets since
    it includes `dev-pkgs`, which exposes the necessary headers and libraries for
    image-specific packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the Yocto Project, is a layer defined as `meta-cgl`, which intends to
    be the stepping stone for the CGL initiative. It aggregates all the available
    and required packages defined by the CGL workgroup. This layer''s format tries
    to set the stage for the next implementations that will be made to support CGL
    on various machines. Inside the `meta-cgl` layer, there are two subdirectories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`meta-cgl-common`: It is the focus place of the activity and the subdirectory
    that offers support for machines available inside poky, such as `qemuarm`, `qemuppc`,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta-cgl-fsl-ppc`: It is a subdirectory that defines BSP-specific support.
    Such layers should be made available if the support for other machines is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As I've already mentioned, the `meta-cgl` layer is responsible for the CGL support.
    As mentioned previously, one of the requirements of CGL is to have LSB support
    and this support is available inside Poky. It is integrated inside this layer
    as a specific requirement. Another recommendation for the `meta-cg`l layer is
    to group all the available packages into package groups that define various categories.
    The available package groups are very generic, but all the available ones are
    integrated in a core one called `packagegroup-cgl.bb`.
  prefs: []
  type: TYPE_NORMAL
- en: The layer also exposes a CGL-compliant operating system image. This image tries
    to include various CGL-specific requirements for starters, and intends to grow
    by including all the requirements defined in the CGL specification document. Besides
    the resultant Linux operating system that will be compliant with the CGL requirements
    and is ready for the CGL certification, the layer also tries to define a CGL-specific
    testing framework. The task may seem similar to the one required for the LSB checking
    compliance, but I assure you it is not. It not only requires a CGL-specific language
    definition that has to be made according to the defined specifications, but also
    a number of tests definitions that should be in sync with what the language defines.
    Also, there are requirements that could be met with one package or the functionality
    of a package and these things should be gathered together and combined. There
    are various other scenarios that can be interpreted and answered correctly; this
    is a condition that makes the testing of CGL a hard task to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `meta-cgl` layer, there are recipes for the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cluster-glue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cluster-resource-agents`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`corosync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heartbeat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lksctp-tools`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`monit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ocfs2-tools`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openais`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pacemaker`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openipmi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides these recipes, there are also other ones that are necessary for various
    CGL requirements. The fact that the `meta-cgl` initiative is shown in the support
    it offers as described in the previous sections. It is not complete but it will
    be in time. It will also contain these packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`evlog`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mipv6-daemon-umip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`makedumpfile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these are necessary to offer a Linux-based operating system that has
    LSB support and CGL compliance. This will be carried out in time, and maybe by
    the time this book reaches your hands, the layer will be in its final format and
    be the standard for CGL compliance.
  prefs: []
  type: TYPE_NORMAL
- en: I will now start to explain a couple of packages that you might come across
    in the CGL environment. I will first start with the Heartbeat daemon, which provides
    communication and membership for cluster services. Having it in place will enable
    clients to determine the present state of the processes available on other machines
    and establish communication with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that the Heartbeat daemon is useful, it needs to be put together
    with a **Cluster Resource Manager** (**CRM**), which is the component responsible
    for starting and stopping various services to obtain a highly available Linux
    system. This CRM was called **Pacemaker** and it was unable to detect resource-level
    fails and was only able to interact with two nodes. In time, it evolved, and it
    now has better support and additional user interfaces available. Some of these
    services are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**crm shell**: It is a command-line interface realized by Dejan Muhamedagic
    to hide the XML configuration and help with interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The high availability web console**: It is an AJAX frontend'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heartbeat GUI**: It is an advanced XML editor that offers a lot of relevant
    information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux Cluster Management Console (LCMC)**: It started as **DRBD-Management
    Console** (**DRBD-MC**) and is a Java platform that is used for the management
    purposes of Pacemaker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pacemaker accepts three types of resource agents (a resource agent represents
    a standard interface between the cluster resources). The Resource Agents is a
    project that is also managed by Linux-HA. It is available and maintained by the
    guys at ClusterLabs. Depending on the type that is selected, it is able to perform
    operation, such as start/stop for a given resource, monitor, validation, and so
    on. The Resource Agents that are supported are:'
  prefs: []
  type: TYPE_NORMAL
- en: LSB Resource Agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OCF Resource Agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The legacy Heartbeat Resource Agent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster Glue** is a set of libraries, utilities, and tools used in conjuncture
    with Pacemaker/Heartbeat. It is the glue that basically puts everything together
    between the cluster resource manager (I am referring to Pacemaker) and the messaging
    layer (which could be Heartbeat). It is now managed as a separate component by
    the Linux-HA subproject, although it started as a component of Heartbeat. It has
    a number of interesting components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local Resource Manager (LRM)**: It acts as an interface between Pacemaker
    and the Resource Agent and is not cluster-aware. Its tasks include the processing
    of commands received from the CRM, passing them to the resource agent, and reporting
    these activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shoot The Other Node In The Head (STONITH)**: It is a mechanism used for
    the purpose of node fencing by making a node that is considered dead by a cluster
    so that it can be removed from it and prevent any interaction risks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hb_report**: It is an error reporting utility often used for bug fixing and
    isolation problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster Plumbing Library**: It is a low-level intercluster communication
    library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information related to Linux-HA the following link could be of help:
    [http://www.linux-ha.org/doc/users-guide/users-guide.html](http://www.linux-ha.org/doc/users-guide/users-guide.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next element is the Corosync cluster engine. It is a project derived from
    OpenAIS, which will be presented shortly. It is a Group Communication System with
    a set of features and implementations that try to offer high-availability support
    and is licensed under BSD. Its features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An availability manager for the restarting of an application in case of failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quorum system that notifies about the state of a quorum and whether it's been
    achieved or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A closed process group communication model with support for synchronization
    to replicate state machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A configuration and statistics database that resides in the memory. It provides
    the ability to receive, retrieve, set, and change various notifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we'll take a look at OpenAIS. It is the open implementation for **Application
    Interface Specification** (**AIS**) provided by **Service Availability Forum**
    (**SA** or **SA Forum** as it is also called). It represents an interface that
    provides high-availability support. The source code available in OpenAIS was refactored
    over time in OpenAIS and only remained SA Forum-specific APIs and in Corosync.
    It was also placed in all the core infrastructure components. OpenAIS is very
    similar to Heartbeat; it is, in fact, an alternative to it, which is industry
    standard-specific. It is also supported by Pacemaker.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about AIS can be found by referring to its Wikipedia page and
    the SA Forum web site at [http://www.saforum.org/page/16627~217404/Service-Availability-Forum-Application-Interface-Specification](http://www.saforum.org/page/16627~217404/Service-Availability-Forum-Application-Interface-Specification).
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `ocfs2-tools` package. It is a collection of utilities that enable
    the work to be done with the OCFS2 filesystem in the form of creating, debugging,
    repairing, or managing it. It includes tools that are very similar to the ones
    a Linux user is accustomed to, such as `mkfs.ocfs2`, `mount.ocfs2 fsck.ocfs2`,
    `tunefs.ocfs2`, and `debugfs.ocfs2`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oracle Cluster File System** (**OCFS**) was the first shared disk filesystem
    developed by Oracle and was released under GNU General Public License. It was
    not a POSIX compliant filesystem, but this changed when OCFS2 appeared and was
    integrated into the Linux kernel. In time, it became a distributed lock manager
    capable of providing both high availability and high performance. It is now used
    in a variety of places, such as virtualization, database clusters, and middleware,
    and appliances. These are some of its most notable features:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimized allocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REFLINKs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata checksums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexed directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended attributes per inode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User and group quotas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced security, such as SELinux and POSIX ACLs support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster-aware tools such as the ones mentioned previously and include mkfs,
    tunefs, fsck, mount, and debugfs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-built Clusterstack with a Distributed Lock Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Journaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable block and cluster size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffered, memory mapped, splice, direct, asynchronous I/Os
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture and endian neutral
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lksctp-tools` package is a Linux user space utility that includes a library
    and appropriate C language headers for the purpose of interaction with the SCTP
    interface. The Linux kernel has had support for SCTP since the 2.6 release, so
    the existence of the user space compatibility tools is no surprise for anyone.
    Lksctp offers access to the SCTP socket-based API. The implementation is made
    according to the IETF Internet draft available at [http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-15](http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-15).
    It provides a flexible and consistent method of developing socket-based applications
    that takes advantage of **Stream Control Transmission Protocol** (**SCTP**).
  prefs: []
  type: TYPE_NORMAL
- en: 'SCTP is a message-oriented transport protocol. As a transport layer protocol,
    it runs over IPv4 or Ipv6 implementations and besides the functionality of TCP,
    it also provides support for these features:'
  prefs: []
  type: TYPE_NORMAL
- en: Multistreaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message framing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multihoming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordered and unordered message delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security and authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These special features are necessary for industry carrier graded systems and
    are used in fields such as telephony signaling.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about SCTP is available at [http://www.ietf.org/rfc/rfc2960.txt](http://www.ietf.org/rfc/rfc2960.txt)
    and [http://www.ietf.org/rfc/rfc3286.txt](http://www.ietf.org/rfc/rfc3286.txt)
  prefs: []
  type: TYPE_NORMAL
- en: Now, I will change the pace a bit and explain **monit**, a very small yet powerful
    utility to monitor and manage the system. It is very useful in automatic maintenance
    and repairing Unix systems, such as BSD distribution, various Linux distributions,
    and other platforms that can include OS X. It can be used for a large variety
    of tasks ranging from file monitoring, changes in filesystems, and interaction
    with event processes if various thresholds were passed.
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to configure and control monit since all the configurations are based
    on a token-oriented syntax that is easy to grasp. Also, it offers a variety of
    logs and notifications about its activities. It also provides a web browser interface
    for easier access. So, having a general system resource manager, which is also
    easy to interact with, makes monit an option for a carrier graded Linux system.
    If you are interested in finding more about it, access the project's website at
    [http://mmonit.com/monit/](http://mmonit.com/monit/).
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenIPMI** is an implementation of **Intelligent Platform Management Interface**
    (**IPMI**) that tries to offers access to all the functionalities of IPMI and
    also offers abstractions for easier usage. It is comprised of two components:'
  prefs: []
  type: TYPE_NORMAL
- en: A kernel driver insertable in the Linux kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A library that offers the abstraction functionality of IPMI and also provides
    access to various services used by an operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPMI represents a set of computer interface specifications that try to reduce
    the total cost of ownership by offering an intelligent and autonomous system that
    is able to monitor and manage the capabilities of the host system. Here, we are
    referring to only about an operating system but also the firmware and CPU itself.
    The development of this intelligent interface was led by Intel and is now supported
    by an impressive number of companies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about IPMI, OpenIMPI, and other supported IPMI drivers and
    functionality are available at [http://openipmi.sourceforge.net/](http://openipmi.sourceforge.net/)
    and [http://www.intel.com/content/www/us/en/servers/ipmi/ipmi-home.html](http://www.intel.com/content/www/us/en/servers/ipmi/ipmi-home.html).
  prefs: []
  type: TYPE_NORMAL
- en: There are some of packages that also should be present in the `meta-cgl` layer,
    but at the time of writing this chapter, they were still not available there.
    I will start with `mipv6-daemon-umip`, which tries to provide data distribution
    for **Mobile Internet Protocol version 6** (**MIPv6**) daemons. **UMIP** is an
    open source Mobile IPv6 stack for Linux based on MIPL2 and maintains the latest
    kernel versions. The packages is a set of patches for MIPL2 by the **UniverSAl
    playGround** **for Ipv6** (**USAGI**) Project, which tries to offers industry
    ready quality for IPsec (for both IPv6 and IPv4 options) and IPv6 protocol stack
    implementations for the Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about UMIP is available at [http://umip.linux-ipv6.org/index.php?n=Main.Documentation](http://umip.linux-ipv6.org/index.php?n=Main.Documentation).
  prefs: []
  type: TYPE_NORMAL
- en: '**Makedumfile** is a tool that offers the possibility of compressing the size
    of dump files and can also exclude memory pages that are not required for analysis.
    For some of the Linux distributions, it comes along with a package called `kexec-tools`
    that can be installed in your distribution using RPM, the package manager supported
    by the carrier graded specifications. It is quite similar to commands, such as
    `gzip` or `split`. The fact that it receives input only from files an ELF format,
    makes it the first choice for `kdumps`.'
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting project is `evlog`, a **Linux Event Logging system** for
    Enterprise-class systems. It also is compliant with POSIX standards and provides
    logging for a variety of forms that range from `printk` to `syslog` as well as
    other kernel and user space functions. The output events are available in a POSIX-compliant
    format. It also offers support while selecting logs that match certain defined
    filters or even register a special event format. These can only be notified about
    when the registered event filter is met. Its features certainly make this package
    interesting and are available at [http://evlog.sourceforge.net/](http://evlog.sourceforge.net/).
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of other packages that could be included into the `meta-cgl`
    layer. Taking a look at the registered CGL distribution could help you understand
    the complexity of such a project. For easier access to this list, refer to [http://www.linuxfoundation.org/collaborate/workgroups/cgl/registered-distributions](http://www.linuxfoundation.org/collaborate/workgroups/cgl/registered-distributions)
    in order to simplify the search procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To interact with the `meta-cgl` layer, the first necessary step would be to
    make sure that all the interdependent layers are available. The latest information
    about how to build a carrier graded compatible Linux image is always available
    in the attached `README` file. I''ve also given you an example here for purpose
    of demonstrating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the build directory needs to be created and configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `conf/bblayers.conf` file, these are the layers that need to be
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `conf/local.conf` file, the corresponding machine should be selected.
    I would suggest `qemuppc`, as well as the `DISTRO` variable that can be changed
    to `poky-cgl. BBMASK` should be made available due to duplication of recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Having all these place, the build process can start. The necessary command
    for this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you have time to spend on this because the build could take a
    while, depending on the configuration of your host system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were presented with information about the specifications
    required for the Carrier Grade Linux and Linux Standard Base. Other options, such
    as Automotive Grade and Carrier Grade Virtualization, were also explained and
    in the end, support for the Yocto Project and a couple of demonstrations were
    shown to you to complete this learning process.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last chapter of this book and I hope you've enjoyed the journey.
    Also, I hope I was able to pass on some of the information I have acquired on
    to you. Since we're at the end of this book, I must admit that I have also learned
    and gathered new information in the process of writing the book. I hope that you
    catch the Yocto bug as well and are also able to add your contributions to the
    Yocto Project and the open source community in general. I am confident that from
    now on, the embedded world holds fewer secrets for you. Make sure you shed some
    light about this topic on others too!
  prefs: []
  type: TYPE_NORMAL
