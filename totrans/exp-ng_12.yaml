- en: Implementing Angular Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services play a vital role in any Angular application. We may design our own
    Angular services by taking full advantage of the many built-in services in Angular.
    In this chapter, we will discuss how to do both, so that you have an idea of how
    to create as well as manage Angular services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why use a service or factory?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing data from components using service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an asynchronous service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use a service or factory?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed One-way Data Binding, Two-way Data Binding, and data sharing
    between components. We may have very clear views defined and uncluttered components
    implemented, but the business logic and data fetching/storing logic has got to
    be there somewhere. Building great Angular apps comes from making the most out
    of the built-in services. The Angular framework includes services to help you
    with networking, caching, logging, promises, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our own services or factories helps to achieve reusability in code and
    enables us to share the application-specific logic across the application blocks,
    such as components, directives, and so on. Organizing the application-specific
    logic into services or factories leads to cleaner, better-defined components,
    and helps you to organize your project with more maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In AngularJS, we implement services or factories for this purpose. The services
    are invoked using a new keyword at runtime such as a constructor function. The
    following code snippet shows the AngularJS code of a service implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `MovieService` function can be injected into any controller that needs to
    fetch the list of movies from the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same feature can be implemented using a factory in Angular with additional
    capabilities. A factory is one type of design pattern that deals with creating
    objects. We can return new classes, functions, or closures from a factory. Similar
    to a service, a factory can also be injected into a controller. The following
    code snippet shows the AngularJS code of a factory implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Both a service and a factory can be injected into a controller, and the `getMovieList`
    function can be called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Though a factory is flexible, a service is the best choice to make the migration
    to ES6 easier. When using a service, a constructor function in ES5 can be smoothly
    replaced with ES6 classes during the migration process to ES6\. We can rewrite
    the `MovieService` service in ES6 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Services are user-defined classes that solve specific purposes, and can be
    injected into the component. Angular recommends that you have only view-specific
    codes in components that enrich the UI/UX in your Angular application. Components
    are the consumers of services where they serve as the source of application data
    and the library of business logic. Keeping the components clean and injecting
    the service enables us to test the components against a mock service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d92acc85-6515-4c4a-a88e-afef782f2756.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Application-specific or business logic functions, such as persisting application
    data, logging the errors, file storage, and so on, should be delegated to services,
    and the components should consume the respective services to deal with the appropriate
    business or application-specific logics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/25fc7ba0-69e9-40cd-bb64-6a8f875e116e.png)'
  prefs: []
  type: TYPE_IMG
- en: Let us create a simple service called `BookService` that deals with fetching
    the collection of books available in the source. The source may be data returned
    from a web API service or a JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us create a `Book` model to persist the domain object value. The
    code snippet of a `Book` class is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet shows a TypeScript class for `Book`, with properties
    such as `id`, `title`, `author`, and `publisher`. Now let us create a service
    named `BookService` that handles operations related to `Book`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first imported the `Book` model class. Then, we defined the `BookService`
    class with a `getBooks` method that returns the collection of books.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need a component to inject the `BookService` and consume. Let us create
    a `BookListComponent` that retrieves the list of books by calling a method, `getBooks`,
    from `BookService`. The following code snippet shows the `BookListComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we started with importing `Component` and `OnInit` from `@angular/core`
    and then we imported the `Book` model class and the `BookService` class. Then
    we annotated the `BookListComponent` class with the `@Component` attribute, along
    with the metadata information, such as the selector and template. The `BookListComponent`
    class is defined with a `books` variable of `Book` array and a constructor that
    is injected with `BookService`. Note that the `BookListComponent` implements the
    `OnInit` life cycle hook, and it calls the `getBooks` method from the `BookService`
    class by using the instance of the `BookService` that is injected into the constructor.
    The list of books returned by `getBooks` is assigned to the `books` variable of
    the `BookListComponent` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us create a root component, `AppComponent`. Pass the `BookListComponent`
    as a directive and `BookService` as a provider. The following is the code snippet
    of `AppComponent:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we started with importing `Component` from `@angular/core`, `BookListComponent`
    and `BookService`. Then we annotated the `AppComponent` with the `@Component`
    attribute, along with metadata such as the selector and template. Note that we
    have a special HTML tag `<book-list/>` in the template. Somewhere, we need to
    instruct Angular to initialize `BooklistComponent` and render the view accordingly.
    We also need to inform Angular that `AppComponent` is the root component by bootstrapping
    it. We can achieve this by creating an `entrypoint` for our Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `AppModule` and annotate it with `NgModule` (`app.module.ts`).
    This instructs the Angular module that this class is the `entrypoint` of the application.
    A code snippet of `AppModule` is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we started by importing `NgModule` from the Angular core. Then we imported
    the `BrowserModule` from the Angular platform browser, as our application runs
    on a web browser. Then we imported the application components, such as `AppComponent`
    which is a bootstrapped root component, and the `BooklistComponent`, imported
    and added in declarations. Not that the `AppModule` is decorated with `NgModule`,
    along with the metadata, such as imports, declarations, and bootstrap, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us create an `index.html` page with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have not referred any necessary libraries from `node_modules` as they
    will be loaded by Webpack. Webpack is a tool used to bundle resources and serve
    them from a server to a browser. Webpack is a recommended alternative to systemJS.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing data from components using services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the Angular application evolves, we keep introducing more components, and
    these components will be dealing with the core data of the application. As a result,
    we may end up writing repetitive code to access the data. However, we can avoid
    writing redundant code by introducing reusable data services. The component that
    is in need of the data can be injected with the data service, and that can be
    used to access the data. In this way, we can reuse logic, write less code, and
    have more separation in designing our components.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Angular `HttpModule`, which is shipped as an `npm` package.
    In order to use `HttpModule` in our application, we need to import `HttpModule`
    from `@Angular/http` and the HTTP service should be injected into the constructor
    of the controller or the application service.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application may share data between components. Consider a movie database
    application, where a `Movies` list or a single `Movie` object will be shared across
    the components. We need a service to serve the `Movies` list or a single `Movie`
    object as and when requested by any components.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us create a movie service using Angular CLI. Execute the following
    command in the command prompt to generate boilerplate code for `movie.service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the Angular CLI has created two files, namely `movie.service.ts` and
    `movie.service.spec.ts`. The boilerplate code of the `movie.service.ts` generated
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `MovieService` class is decorated with the `@Injectable` attribute
    to facilitate a Dependency Injection to instantiate and inject this service into
    any component that is in need of it. We made this `Injectable` function available
    by importing it from the Angular core.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we need to add the `getMovies` function to the `MovieService` generated.
    Introduce the `getMovies()` function to the `MovieService` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have given the return type as void for now, but we need to change
    it when we move on to further implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to introduce a domain model, `Movie`, to represent a movie across the
    application. Let us generate a boilerplate code for the `Movie` class using Angular
    CLI as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, this command has created two files, namely `movie.ts` and `movie.spec.ts`.
    Actually, while in domain mode, we may not write any test methods to assert it,
    so you can safely delete `movie.spec.ts`. The code snippet of the `movie.ts` generated
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us add a few properties to make it represent the characteristics of a movie.
    The code for that is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the domain model in place. Now let us update the return type of the
    `getMovies()` function in `MovieService` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code snippet of `MovieService` is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `getMovies()` function returns the collection of movies of type `Movie[]`.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have `MovieService` ready to be consumed. Let us consume it in a component.
    Using Angular CLI, we will create a component by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates four files, namely `movie.component.ts`, `movie.component.html`,
    `movie.component.css`, and `movie.component.spec.ts`. The code snippet of the
    `movie.component.ts` file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `MovieComponent` is decorated with the `@Component` decorator, along with
    the metadata, such as selector, `templateUrl`, and `styleUrls`. The `MovieService`
    will be hooked under the `ngOnInit` method. Let us proceed with modifying `MovieComponent`
    to consume `MovieService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first; we need to import `MovieService` to our component `MovieComponent`.
    This import statement provides a reference to `MovieService` in `MovieComponent`.
    But to consume `MovieService`, we need to create the instance of `MovieService`.
    How do we do it? In a standard way, we can instantiate `MovieService` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The code snippet of `MovieComponent` after importing `MovieService` and instantiating
    `MovieService` in the `OnInit` life cycle hook method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, when the `OnInit` event is fired, `MovieService` gets instantiated, and
    the collection of movies will be retrieved by calling the `getMovies()` function.
    The movies list will be assigned to the `movies` properties of `MovieComponent`
    for further consumption in the template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an asynchronous service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just created a service called `MovieService` that synchronously calls the
    `getMovies()` method to retrieve the collection of movies. As we are consuming
    an external source, such as a web API, to retrieve the collection of movies, our
    application has to wait until the server responds with the list of movies, as
    the `getMovies` function is synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: So we need to implement an asynchronous mechanism to retrieve the collection
    of movies. In such way, we can avoid making our application wait until the web
    API responds with the collection of movies. We can achieve this by using promises.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Promise?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Promise** is a sincere assurance that an action will be performed. It calls
    back a function when the server responds with the result. We request an asynchronous
    service with a callback function to perform some operation and the service calls
    our callback function with either the result or with the error. You can read more
    about promises in [Chapter 7](8eacfd6f-0cc3-49d5-9c85-f823dad66ad6.xhtml), *Asynchronous
    Programming Using Observables*.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Promise in a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us update the `getMovies` function in `MovieService` to return a resolved
    `Promise` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that we return the collection of movies as a resolved `Promise` from the
    `getMovies` function. Now we need to modify the code that assigns the collection
    of movies to the movies property in `MovieComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The existing code in `MovieComponent` assigns `Promise` to the `movies` property
    instead of the collection of movies, as the `getMovies` in `MovieService` returns
    the resolved `Promise` now. So let us modify the code of the `ngOnInit` event
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We provide our callback function to the `then` method of `Promise`, so the chain
    function `then` in `getMovies` has the command to assign the collection of movies
    returned from the web API to the property of `MovieComponent`, `this.movies`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the application will not wait until the `MovieService` returns the collection
    of movies. The `movies` property gets the list of movies assigned from the callback
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cool! This brings us to the end of the chapter. We learned about the importance
    and advantages of implementing services in our application. We also learned about
    how to consume services in components.
  prefs: []
  type: TYPE_NORMAL
- en: However, instantiating `MovieService` directly is a bad approach. Components
    need not know how to instantiate the services; their only purpose is to know how
    to consume the services. Services also enable the components to tightly couple
    with the type of `MovieServices` and their way of instantiating. This is unacceptable;
    the components should be loosely coupled as far as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss injecting services into components using
    Dependency Injections, which enable us to have loosely coupled components.
  prefs: []
  type: TYPE_NORMAL
