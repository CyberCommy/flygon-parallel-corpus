- en: Building Angular Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the whole of Angular is composed of several interrelated parts, it's virtually
    impossible to select one part of Angular as being more important than another.
    The removal of any one of these parts renders the whole compromised—maybe even
    useless. Having said that, if I had to pick one part that was really important,
    I'd pick components. There are several really cool things about components, such
    as how when we build components, we are basically also extending HTML, since we're
    creating custom HTML tags. Components are TypeScript classes, and as we'll see
    a bit later on in this chapter, the way we link our code to our custom HTML tag
    is via the `@Component` annotation. I'll also explain what annotations are later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick word on the terminology used from this point forward: I''ve used the
    word *parts* instead of the word *components* in order to avoid confusion, since
    the word *component*is an overloaded word—it has different meanings in different
    contexts. Additionally, I use the word *page* from a classical web application
    perspective, as opposed to the literal sense, when talking about a view (that
    is, a screen).'
  prefs: []
  type: TYPE_NORMAL
- en: Angular applications contain a single root component. However, when discussing
    an application's screens or views, it is necessary to mention other components
    that act as root components for that view. For example, the sign-up screen has
    a root component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a bullet point list of topics that we''re going to cover together:'
  prefs: []
  type: TYPE_NORMAL
- en: An Angular application as a tree of components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Component` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties of the `@Component` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content projection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Life cycle hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components that are needed to implement the three wireframes that are associated
    with this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular application architecture – a tree of components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Angular application is basically a tree of components. As we've learned in
    previous chapters, Angular is an SPA framework and thus has a single page to leverage
    for displaying its tree of components. We've seen that Angular has a single top-level
    component, called the root component, and depending on what we'd like our application
    to do in response to our user's actions, we have that root component load up other
    components. These other components (let's refer to them as *secondary root components*
    for now) in turn recursively render additional components. The way in which we've
    wired up our router in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*, is that we've mapped URLs to our *secondary root components—*one per
    *page*, which springs into view when our users click on the navigational (that
    is, menu) links.
  prefs: []
  type: TYPE_NORMAL
- en: What makes all this possible is that components are composable. This is to say
    that our components are made up of other components, and are thus nested. We can
    nest our components in an arbitrarily deep component hierarchy, hence the statement
    at the very beginning of this section, *An Angular application is basically a
    tree of components*.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular framework takes care of recursively loading and rendering our components
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Architecting an Angular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as is the case with most engineering projects, software projects also need
    to have a process for designing and architecting applications. The typical way
    to start is to break down whatever you're building into separate chunks of work.
    In Angular's vernacular, this means that we need to break down our application
    into separate components, each of which is responsible for certain things, such
    as displaying the result of a calculation, or accepting user input.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a list of components that we need to use (whether they are third-party
    components or custom components), we need to treat them as black boxes—or mathematical
    functions. Let me explain what I mean by this.
  prefs: []
  type: TYPE_NORMAL
- en: When I say we need to treat our components as black boxes, I'm suggesting that
    we should not let our mind be consumed with their implementation at this stage
    (that is, when we are simply listing them). We'll concern ourselves with building
    our components a little later in the chapter, but for now, treating them as black
    boxes is all we need to do.
  prefs: []
  type: TYPE_NORMAL
- en: When I say we need to treat our components as mathematical functions, I'm merely
    suggesting that we think about what the output is going to be, and what inputs
    are needed for the function (that is, our component). The inputs and outputs of
    our components make up their public interfaces. We'll be taking a closer look
    at component interfaces a bit later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking up your components into sub-components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The number of components in an application, or even per page, for that matter,
    varies greatly. It can range from just a few to several hundred—or maybe even
    more. However, there is a good rule of thumb for how far you should go in breaking
    up a component (such as a sub-component that is the top-level component for that
    specific page) into sub-components. If you keep component reusability in mind,
    all you need to ask yourself as you break down the component into sub-components
    is this: "Are there two or more parts to this component that I can reuse elsewhere?"
    If the answer is yes, you can probably benefit from breaking it down further.
    If the answer is no, then you''re done—no more breaking down of the component
    is necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a quick example, just to make this a bit less abstract. Assume
    that you have a listing of items on a page—one row per item—and the item is a
    component. Let's also assume that each item has a thumbnail image for whatever
    that item is. If the thumbnail can be used elsewhere, maybe on the checkout page,
    or on the item detail page, then that thumbnail should be its own component and
    a sub-component of the item component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zooming out a bit from the item listing example, and starting from the page
    view, you may take this approach to help you get started when planning your components:'
  prefs: []
  type: TYPE_NORMAL
- en: Your page header is a component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have a quick-links section on the right-hand side of your page, which
    would be another component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have your main content section, taking up the majority of your screen real
    estate, which would also be a component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your page footer is also a component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the preceding components, all of them are likely to be reusable, except
    for the main content section. You may desire your page header, and page footer,
    to be on every page within your application—and you may want to re-display the
    quick-links section on various pages. For these reasons, those components are
    probably fine as they are. No further breakdown is required. The reason you will
    want to break down your main content component is that it's not reusable because
    you're not likely to have two copies of the same page!
  prefs: []
  type: TYPE_NORMAL
- en: Component responsibilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular applications that are architected will have components that are not
    only reusable but have well-defined boundaries. This is to say that they have
    a separation of concerns. Each component does one thing and does it well. The
    components should be abstracted away from one another, and they should not know
    about each other's details (that is, implementation). The one thing that they
    should know about each other is how to communicate with each other. This is accomplished
    via their public interfaces, and we'll look at this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: For now, all you need to know is that when you plan your application's components,
    you should list their responsibilities. That is, write down what they will be
    doing. Astute readers will probably see the connection between the use case diagrams
    and the lists of component responsibilities, since components are how users will
    be interacting with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotations are a new feature of TypeScript. They are symbols, prefixed with
    the `@` sign, that we add to our code (that is, used to decorate our classes).
    Annotations can appear at the top of our class declaration, or at the top of our
    functions, or even on top of our class properties. What annotations do, generally
    speaking, is inject boilerplate code where they are attached (that is, our class,
    function, or properties). While we don't need annotations, since we can choose
    to write the boilerplate code ourselves, we're better off leveraging them because
    the boilerplate code shouldn't have to be written over and over again. Additionally,
    by using annotations instead of handwriting the boilerplate code, not only is
    the drudgery removed, but we don't have error-prone code to contend with. We'll see
    more annotations in various chapters of the book, but let's focus on the `@Component` and
    `@NgModule` decorators for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '@Component'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While annotations can appear at the top of our class declaration, or at the
    top of our functions, or even on top of our class properties, the `@Component`
    annotation will always appear at the top of our component's class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the `@Component` annotation to become available to us, we have
    to import it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at that line of code for just a moment. It is JavaScript—specifically,
    ES6\. If you recall from [Chapter 2](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml),
    *ECMAScript and TypeScript Crash Course*, the part of the curly braces of the
    statement is a new construct in ES6 called *destructuring*. Also, there is no
    explicit path to the `@angular/core` module. We leave it to the CLI and TypeScript
    compiler to figure out where the module is, and exactly how it should be loaded
    and made available to the code in our class.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of the @Component decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@Component` decorator provides us with a number of properties for the purposes
    of configuring our components. Let's take a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `selector` is a property of the `@Component` annotation, and its value
    (of type string) is what gives the name to our custom HTML tag. I like cars, so
    here''s an example `car` component in code, showing its annotation, selector,
    and class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When Angular sees our custom HTML tags, `<car></car>`, it creates an instance
    of our `CarComponent` and will replace our custom tags with some HTML that the
    browser actually understands. OK, but where in our component class do we add stuff
    to give our component something more than a ghostly aura? The next section is
    the answer (that is, the `template` property).
  prefs: []
  type: TYPE_NORMAL
- en: template and templateUrl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our poor little `car` component has no visible body just yet. This is because
    Angular needs to know what browser-friendly HTML to add when it renders our `car`
    component, and we just haven''t provided that for Angular yet. The way to provide
    that is to use the `template` property (of type string) to hold the HTML that
    Angular will render for us after it creates the instance of the `CarComponent`
    class (any time it sees our custom tags, `<car></car>`). Let''s rectify this by
    beefing up our preceding `@Component` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What would happen if our component required a lot of HTML? Well, this is why
    we have another property that we can use, `templateUrl`*.* The`templateUrl` property
    provides us with a way to externalize our component''s HTML from our component
    class and have it in a separate file. Your `template` property would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: styles and stylesUrls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `styles` property is used for what you expect it to be used for—to add
    styling to our component template. Just like the `template` property, the value
    is of type string. Also, because it''s easiest to read CSS when spaced over multiple
    lines, we''ll be using the back-tick character (new in ES6, and thus also available
    in TypeScript), which enables us to create what is known as *template literals*.
    Let''s add the `styles` parameter to our `CarComponent` class to see how this
    may look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That's all there is to the `styles` property. I bet you can guess what the `styleUrls`
    property does. Yup—it works just like the `templateUrl` property. It provides
    us with a way to externalize our component's CSS from our component class and
    having it in externalized style sheets. Note that I mentioned *files*, as in the
    plural of *file*. The `styleUrls` property takes a value of an array of strings
    (as opposed to being of type String as what the value of the `templateUrl` property
    is)—thus, we can pass multiple style sheets to it if we wanted to*.*
  prefs: []
  type: TYPE_NORMAL
- en: So, by using a combination of the template, `templateUrl`, styles, and `styleUrls`
    properties, we can encapsulate the HTML (that is, our component template), and
    the CSS we'd like to apply to our template, within our component class—thanks
    to the properties that the `@Component` annotation makes available to us. And
    thanks to the `selector` property, we can use custom HTML tags in our components'
    parent templates. Are you starting to get a good feel for how all these things
    fit together? If not, no worries—you soon will, when we start to implement our
    example application's views.
  prefs: []
  type: TYPE_NORMAL
- en: View encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: View encapsulation is something that is extremely convenient and very cool—as
    most things in Angular are—and is used to configure the scope of our CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when we create (or change) a CSS class, the style is applied throughout
    our application and is not confined to a specific page, component, and so on.
    Angular gives us a level of control over this by allowing us to encapsulate (that
    is, restrict, or contain) our styles to the components that contain the given
    style sheets/CSS. This is done through another property of the `@Component` annotation, named `encapsulation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set the encapsulation of our component''s styles to one of the following
    three possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewEncapsulation.Emulated`: This is the default value and the effect is that
    our styles will remain contained to just our component. They will not affect anything
    else on our page(s). However, our component will still inherit, or have access
    to, styles that are globally accessible to our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewEncapsulation.Native`: This is basically the same thing as `ViewEncapsulation.Emulated`,
    except that we are asking Angular to block, or shield, our component from any
    globally defined styles. The effect is that our component will be immune from
    any styles that are not assigned to our `@Component` annotation''s `styles` or
    `styleUrls` properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewEncapsulation.None`: This is the setting that we would use if we didn''t
    want to control the level of CSS isolation at all. In other words, if we wanted
    to let our component''s CSS affect other page assets, and also wanted our component
    to inherit globally defined CSS rulesets, this is the setting that we would use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is this cool or what? What a feature! If you think about it, this is one of
    the things that make code reuse, even between applications, not just within the
    same application, possible. If we want to guarantee that our component will look
    the same across Angular applications, regardless of any given application's styles,
    we can set our component's `encapsulation` property to `ViewEncapsulation.Native`
    and we're good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Module versus NgModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terminology is everything because it is easy to confuse things due to their
    semantics. This is especially true when the language/terms in the topics in question
    contain overloaded words—as with Angular as the topic. For instance, we've seen
    that we have to be pretty specific about what we mean by the words *component* and
    *page*. The same thing applies to the word *module,* and so I'd like to clear
    something up at this point before we continue on.
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen in [Chapter 2](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml), *ECMAScript
    and TypeScript Crash Course*, the notion of modules is new in ES6\. In JavaScript,
    when we talk about a module, we are usually referring to a code file that we can
    then import into the context of our executing script, making its encapsulated
    functions available to our script. An Angular module, or `NgModule`, is a module
    consisting of more than one file—hence, it's often referred to as a package. Because
    we treat this `NgModule`, or package, in much the same way as a JavaScript module—by
    importing it—we often think of them as being equivalent, but they are not.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter's focus is on components, but we will also take a look at constructing
    our own `NgModules` in [Chapter 11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml),
    *Dependency Injection and Services*, when we encapsulate our calls to our backend
    APIs in one cohesive package.
  prefs: []
  type: TYPE_NORMAL
- en: Before we leave our discussion on `NgModule`, deferring further discussion to
    a later chapter, I'd like to at least touch upon a couple of its parameters, since
    `@NgModule` is another annotation that I had mentioned existed.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of the @NgModule decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you take a look at the `app.module.ts` file in the example application that
    we started building in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*, you can see that there are four parameters in the `@NgModule` annotation
    on our `AppModule` class. Let''s take a quick look at these four and what we use
    them for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarations**: This is where we list the components and directives that
    we will need to package in this `NgModule`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Imports**: These make the exported declarations of other modules available
    to our `NgModule`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Providers**: This is where we list services and values so that they become
    known to **dependency injection** (**DI**). They are added to the root scope and
    are injected to other services or directives that have them as a dependency. We''re
    going to cover DI in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml),
    *Integrating Backend Data Services*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bootstrap**: This is where we list the component that we want Angular to
    Bootstrap upon application startup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can only be one `NgModule` in our application where we make use of the
    Bootstrap parameter—since the bootstrapping process starts with only one module.
  prefs: []
  type: TYPE_NORMAL
- en: Content projection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The notion of content projection provides component developers with a mechanism
    that can increase their reusability. In particular, I'm referring to the way in
    which their data is displayed (that is, rendered).
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that instead of trying to create a component that has properties
    for each possible way, its template can be altered (which is nearly impossible)
    so that the developers that consume the component can vary the values of these
    properties to customize how it's rendered. Content projection provides a way to
    accomplish this with much less ceremony.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism we use is a pair of `ng-content` tags, like this: `<ng-content></ng-content>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see this in practice in the Photo Listing page, but let me show you
    a contrived example for now. Let''s modify the template in our `CarComponent`
    to the following code snippet (adding the pair of `ng-content` tags):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What this does is to enable the CarComponent's parent component to project content
    into the CarComponent's template, thereby altering the template as desired. Let's
    assume that instead of just showing the maker of the car in regular text, within
    a set of `<p>` tags, we'd like to show the make of the car in a set of `<strong>`
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the parent component would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It would look like the preceding instead of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Again, this was a contrived example. Also, the whole point of Angular is to
    have dynamic data but we haven't done that here. For instance, we'd have the car
    question and answer data bound to elements within the component template, instead
    of having it hardcoded (to *What production car has the fastest acceleration time
    from 0 to 60?*, and *Tesla*, in this case.) However, our simplified hardcoded
    code illustrates the notion of content projection in the most straightforward
    way possible—by not dynamizing the data, as we'll be doing a bit later in the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting multiple sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to include more than a single pair of `ng-content` tags. However,
    since Angular will not be able to tell which projected content has replaced which
    set of `ng-content` tags, we need to label the `ng-content` tags in some fashion
    to disambiguate them from one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way to label, or mark, the `ng-content` tags so that the intended
    projected content replaces the desired set of `ng-content` tags is to identify
    the elements by class names. We label the tags by using an attribute of `ng-content`, named
    `select`. Let''s extend our contrived `CarComponent` example to see how this may
    look with two pairs of `ng-content` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what the parent component would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By using `ng-content` tags, and its `select` attribute, if you have multiple
    content projection targets, you can create components that are customizable by
    developers that consume them.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with almost everything that is alive, from the stars in our solar system
    to the flowers you may have bought to decorate your dining room table, Angular
    components also have a life cycle—the different stages, or phases, they go through
    from the moment they spring into existence to the moment they cease to exist.
  prefs: []
  type: TYPE_NORMAL
- en: We can hook into these different stages to run any code that we may want to
    have Angular run for us as our component moves through them. This is made possible
    because Angular provides us with special methods, one for each phase of the component
    life cycle, which Angular calls for us. All we have to do is provide the code
    that we want Angular to run—and the way we do that is to add functions, bearing
    the same name as the life cycle hooks, to our component class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a set of life cycle hooks for the component, and there''s also a set
    of life cycle hooks for its children (that is, child components). The following
    table enumerates the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Life cycle hook** | **Type** | **Invoked when...** |'
  prefs: []
  type: TYPE_TB
- en: '|  `constructor` |  Component | Angular creates a component as a result of
    `new` being called on a class. |'
  prefs: []
  type: TYPE_TB
- en: '|  `ngOnInit` |  Component | A component has been fully initialized. |'
  prefs: []
  type: TYPE_TB
- en: '|  `ngOnChanges` |  Component | A change has happened to an input property
    (called once per chance). |'
  prefs: []
  type: TYPE_TB
- en: '|  `ngOnDestroy` |  Component | Angular is about to destroy the component.
    |'
  prefs: []
  type: TYPE_TB
- en: '|  `ngAfterContentInit` |  Child | After content projection occurs for the
    component. |'
  prefs: []
  type: TYPE_TB
- en: '|  `ngAfterContentChecked` |  Child | Angular runs its change detection algorithm
    on the content. |'
  prefs: []
  type: TYPE_TB
- en: '|  `ngAfterViewInit` |  Child | A component''s view has been fully initialized.
    |'
  prefs: []
  type: TYPE_TB
- en: '|  `ngAfterViewChecked` |  Child | Angular runs its change detection algorithm
    on the view. |'
  prefs: []
  type: TYPE_TB
- en: Most common life cycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the preceding eight life cycle hooks, you''re most likely to use only
    three of them (in most cases). All three fall into the component type of life
    cycle hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngOnInit`: Our initialization logic for our component will go here. You may
    think that the constructor is the place to add the initialization logic, but `ngOnInit`
    is preferable because any binding of data via our interface (that is, input properties)
    will have been done. This isn''t the case with the constructor phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngOnChanges`: When we want to know what input properties have changed, and
    to what they were changed to, this is the place to look.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngOnDestroy`: This is where we insert our cleanup logic for our component
    (if we have any things we''d like to clean up—otherwise, we don''t use it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of how we hook into the `ngOnInit` life cycle hook (we''ll
    just write out some output to our console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Component interface – inputs and outputs, and the flow of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were to create a diagram of your components on a particular screen (that
    is, view/page), drawing arrows between them to indicate the flow of data, the
    arrows would point from one component's outputs to another component's inputs.
  prefs: []
  type: TYPE_NORMAL
- en: In code, as we'll see later in our implementations, the ways in which we bind
    outputs and inputs are in our component templates (that is, in the HTML). But
    to have binding in HTML, we need to create our components in code and we need
    to give them interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look at a concrete example—it'll show how a parent component
    could pass data to its child component. To demonstrate this, let's first create
    our two components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our `DadComponent`, which will be the parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our `SonComponent`, which will be the child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot going on in this little bit of code. I won''t describe what''s
    going on in the previous code blocks. Rather, I''d like for you to study it for
    a few minutes and see if you can figure out what''s going on. You should have
    enough information from previous chapters, along with with some basic knowledge
    of JavaScript/TypeScript, and an understanding of getters and setters (as many
    languages have). I know you can do it—give it a try. I''ll give you two hints:
    1) `@Input()` is a decorator, and in this case, it creates the public interface
    of `SonComponent`; 2) `DadComponent` will end up creating three instances of `SonComponent`.
    Two of the sons will know their own name, and unfortunately, one of the sons won''t
    know his name. What does he say? What are the names of the sons that do know their
    name? Can you see why three sons are created? Can you guess what would be written
    to the console, and how many times it would be written?'
  prefs: []
  type: TYPE_NORMAL
- en: We're going to see a lot of this pattern throughout our implementations, so
    don't worry if it looks strange, or seems a bit complicated, and you can't answer
    all of the questions I've asked. This stuff should become second nature to you
    after a while. And yes, I will be explaining our implementation code from now
    on—not in excruciating detail, but in enough detail for you to understand the
    material at hand. For now, I just wanted you to get a feel for what this passing
    of data via component interfaces looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation of the components for our three pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have enough knowledge to implement (that is, create in code) the components
    that we will need for the following three pages of our example application:'
  prefs: []
  type: TYPE_NORMAL
- en: Preview Listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Photo Listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview Photo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To generate those components, we will make use of the Angular CLI schematics.
    Run the following commands and we should expect the components and required files
    to be auto-generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the commands run successfully, we should see the output, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/21ffb974-aa8f-4b2c-aa74-aa5c58aa2b9e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can notice that the corresponding files have
    been generated for the component and the `app.module.ts` file has been updated
    with the latest components generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final project structure of our application with components generated so
    far is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ee18d776-dfb0-4d9a-8c20-fe27b2ef2770.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a lot of ground in this chapter. You may have not completely understood
    some of the code in the last section, and this is OK because you will get good
    at this stuff as we implement our pages for our example application together.
    Since this chapter was on components, I just wanted to show you the general structure
    for how to set up parent and child components, and how to pass data from the parent
    to the child via the child's public interface. However, you should now have a
    pretty good understanding of how an Angular application is just a tree of components.  What
    the rule of thumb is for breaking up your components into sub-components and what
    are annotations and decorators.
  prefs: []
  type: TYPE_NORMAL
- en: We also studied what the `@Component` annotation/decorator is, what it's properties
    are, and how to configure them. We then moved on to the `@NgModule` decorator
    is, and what some of its properties are, and what purpose they serve. We then
    studied what content projection is, and how to use it to allow other developers
    that consume your components to customize of their rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly we studied what life cycle hooks are, how to use them, and reasons why
    you'd want to use them. We then moved on to component interfaces are and how to
    create them. Finally, we studies the implementation of the components we need
    for our three pages (Preview Listing, Photo Listing, and Preview Photo)
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates,
    Directives, and Pipes*, we're going to zoom into the template portion of components,
    since that's where all the data binding and rendering take place—bringing our
    Angular application from a bunch of 0s and 1s to life on our screens.
  prefs: []
  type: TYPE_NORMAL
- en: Angular provides many tools, in the form of directives and pipes, for us to
    leverage, so we can tell it how to paint on our canvas. So, turn the page over
    and let's learn about how we can get Angular to start putting our component paint
    on our application canvas to bring our application to life—which is where we'll
    place our components onto our three pages (Preview Listing, Photo Listing, and
    Preview Photo).
  prefs: []
  type: TYPE_NORMAL
