- en: Chapter 4. Windows App Development with Code::Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, focus of our app development was on console based
    app. This is also known as text only app as console based apps can only display
    text and ASCII art. However, our focus in this chapter will be on app development
    for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Windows is one of the most widely used operating systems around the world. Code::Blocks
    can be used to develop apps for Windows, Linux, or Mac. Keeping in view the popularity
    of the Windows platform we shall restrict our focus to Windows platforms only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apps for Windows are also known as GUI (Graphical User Interface) based apps.
    User interaction with app is done by mouse and keyboard. Notepad app is an example
    of GUI based apps that come bundled with Windows operating system. The following
    screenshot displays the Notepad app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows App Development with Code::Blocks](img/3415OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Code::Blocks comes along with all the tools required for Windows app development.
    Let's develop an app and learn it.
  prefs: []
  type: TYPE_NORMAL
- en: First Windows app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following the tradition of Hello World app, we''ll create our first Windows
    app. To do so perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **File** | **New** | **Project…** menu option. Choose the **Win32 GUI
    project** option as in the following screenshot and click on the **Go** button:![First
    Windows app](img/3415OS_04_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button on the first page of wizard as shown in the following
    screenshot. Choose **Frame based** option and click on the **Next** button. Dialog
    based apps can't contain menu bar or a toolbar. So we are choosing Frame based
    app.![First Windows app](img/3415OS_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `App9` as project title and choose folder to create project. Now click
    on the **Next** button and then click on the **Finish** button to complete the
    wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace code inside the `main.cpp` file with following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now click on the build icon in compiler toolbar. Click on the run button in
    compiler toolbar. Our `App9` window will be similar to the following screenshot:![First
    Windows app](img/3415OS_04_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! We have successfully compiled our first app for Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's understand the code we have written for this app. We are including `windows.h`
    file in the beginning of code. This file must be included in all Windows app as
    it contains relevant function declarations for Windows. Subsequently we have a
    function called `WinMain()` and this is the **entry point** of a Windows app.
    An entry point is the first function that is called at app start up.
  prefs: []
  type: TYPE_NORMAL
- en: The `WinMain()` functions accepts four parameters—handle to the current instance,
    handle to the previous instance, command line string pointer, and show state of
    window that controls how a app should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: We are calling the `MessageBox()` function to display a message box. It accepts
    four parameters—handle to the parent window (`NULL` or no one in our case), message
    text, dialog box title, and a combination of flags that controls buttons and icons
    to be shown. In our case we have used a combination of `MB_OK` and `MB_ICONINFORMATION`,
    which instructs the `MessageBox()` function to display a **OK** button and an
    information icon respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'But why are we getting a console for a GUI app? Answer is that by default Code::Blocks
    creates debug target as a console app. We can confirm this by navigating to **Project**
    | **Properties…** menu option and then clicking on the **Build targets** tab.
    Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First Windows app](img/3415OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Advantage of this method is that debug output can be printed to that console
    for easier debugging. This can be disabled by changing app type to **GUI application**
    in the **Type:** combo box as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First Windows app](img/3415OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will stop launching that console window.
  prefs: []
  type: TYPE_NORMAL
- en: Windows App and Unicode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unicode is a standard to encode, store and represent text in World''s most
    languages. C++ `char` data type is 1 byte in size. It is only able to represent
    text available in English language. To enable Unicode support in a Windows app
    we have to use a special data type called `wchar_t`, which is 2 byte in size.
    Let''s say Hello World in the Hindi language. To do this we will replace previous
    `MessageBox()` code with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The Code::Blocks editor window will look similar to the following screenshot.
    Editor font size has been changed to 16 point in order to work with Devnagiri
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows App and Unicode](img/3415OS_04_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have decorated Hindi text with a `TEXT()` macro. This macro is used to translated
    a Unicode string to a `wchar_t*` when a `UNICODE` or `_UNICODE` pre-processor
    definition is defined. It returns a `char*` when Unicode support is not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Next we'll define following pre-processor defines. Go to **Project** | **Build
    options…** menu option. Then select `App9` in the tree on the left side and click
    on the **Compiler settings** and then **#defines** tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows App and Unicode](img/3415OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add `UNICODE` and `_UNICODE` to the text control and click on the **OK** button.
    Click on the build button and then click on the run button in compiler toolbar.
    Now `App9` will show Hello World in Hindi language, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows App and Unicode](img/3415OS_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Please note that we'll enable Unicode support in all subsequent apps.
  prefs: []
  type: TYPE_NORMAL
- en: Event driven Windows app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows apps are **event driven** apps. An event can be an external or internal
    input to an app. Event driven apps run a message loop, which parses incoming events
    and then calls appropriate functions corresponding to that event. Code::Blocks
    default code generated by **Win32 GUI project** wizard generates a boilerplate
    code of an event driven app.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand event driven programming we shall be using following
    example to learn and understand it. We shall be using native Win32 API for this
    example. Win32 API is the base of several toolkits. Thus we should have an understanding
    of it in order to understand other toolkits.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create another GUI app and name it `App10`. Replace wizard generated code
    with the following code. Also enable Unicode support as per the steps laid out
    in the previous example. As the code snippet is large we'll understand and paste
    it in editor window in several steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the header declaration, global variable declaration,
    and declaration of callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the following snippet we'll define the `WinMain()` function. We will define
    an object of `WNDCLASSEX` structure inside the `WinMain()` function. This structure
    takes several inputs. With `wincl.lpfnWndProc` we have assigned a callback function
    `WindowProcedure()` to the `wincl` object. This instructs app to call that function
    for event processing. Finally the `wincl` object will get registered with the
    `RegisterClassEx()` function. Once the object is registered successfully we create
    a window of that class using the `CreateWindowEx()` function.
  prefs: []
  type: TYPE_NORMAL
- en: We will display newly created window using the `ShowWindow()` function. After
    the window is displayed we will run an event processing loop using the `GetMessage()`
    function inside a `while` loop. All incoming events are then sent to the `WindowProcedure()`
    function by `DispatchMessage()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `WM_CREATE` event is sent out by Windows OS when a window is being created.
    We will then create a button using the `CreateWindow()` function.
  prefs: []
  type: TYPE_NORMAL
- en: We shall be processing button press by processing the `WM_COMMAND` event in
    the `WindowProcedure()` function. We will then display a message box whenever
    this button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we will be processing the `WM_DESTROY` event, which will be issued whenever
    window is being destroyed. A return value of `0` will be posted with the `PostQuitMessage()`
    function emitting a `WM_QUIT` event to the message queue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes our Windows app. Hit *F9* key (an alternative to clicking on
    the build and then run icon in build toolbar) to build and run this app. Following
    screenshot will be presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Event driven Windows app](img/3415OS_04_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Advantages of Win32 API:'
  prefs: []
  type: TYPE_NORMAL
- en: Produces smaller executable size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produces faster code due to less overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages of Win32 API:'
  prefs: []
  type: TYPE_NORMAL
- en: Requires longer development time due larger amount of code to be written
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimal set of GUI controls (for example, a text box, button, and so on) are
    available to developer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To solve this problem, GUI toolkit was developed. The GUI toolkit simplifies
    development process allowing reuse of code and a smaller code base. It also contains
    complex GUI control (for example, rich text control, HTML control, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: wxWidgets GUI toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A GUI toolkit is a set of header files and libraries that makes GUI development
    easier for developers. There are several GUI toolkits available in the market,
    few of them are stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft Foundation Class** (**MFC**): It is a set of classes that acts
    as a wrapper to Win32 api. This comes bundled with commercial versions of Visual
    Studio. MFC is proprietary and requires a Visual Studio license in order to use
    it. MFC app have native look and feel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt** (pronounced as "cute"): It is a Open source and cross-platform GUI toolkit
    developed by **Digia**. Qt is licensed under both commercial and GPL/LGPL license.
    It is available on wide range of platforms including Windows, Linux, Mac, and
    so on. Qt drawn GUI is a custom drawn UI and may differ from a standard app on
    a platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wxWidgets**: It is another open source and cross-platform GUI toolkit licensed
    under wxWindows license (based on LGPL but less restrictive). It''s generated
    UI has native look and feel as it uses platform standard UI elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll focus on wxWidgets toolkit in this book due to its simpler licensing model,
    native look and feel, and cross-platform development capability. A compiled copy
    of wxWidgets is also provided with the book. This book assumes that reader has
    extracted compiled wxWidgets to `Z:\wxWidgets` folder.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand similarities between Win32 API and wxWidgets we will
    recreate `App9` functionalities with wxWidgets.
  prefs: []
  type: TYPE_NORMAL
- en: Go to **File** | **New** | **Project…** menu option. Then choose the **wxWidgets
    project** wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next click on the **Go** button and then click on the **Next** button in the
    next window. Choose **wxWidgets 2.9.x (SVN Version)** option in the wizard page
    and click on the **Next** button, as shown in the following screenshot:![wxWidgets
    GUI toolkit](img/3415OS_04_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `App11` as the Project title and click on the **Next** button. Click on
    the **Next** button to skip Project details page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Frame Based** application type as shown in the following screenshot.
    Frame based apps are apps which can have menus, toolbars, and are suitable for
    large apps. Leave **Preferred GUI Builder** option to **None** as we'll be writing
    GUI code ourselves.![wxWidgets GUI toolkit](img/3415OS_04_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the following window `$(#wx`) is a global variable, which is pointing to
    wxWidgets installation directory. Alternatively full path to wxWidgets that is
    `Z:\wxWidgets` in our case may be entered here:![wxWidgets GUI toolkit](img/3415OS_04_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this global variable is undefined at this point following window will pop
    up. It will not pop up if the global variable has already been defined.![wxWidgets
    GUI toolkit](img/3415OS_04_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the text boxes as per the previous screenshot and click on the **Close**
    button. Then click on the **Next** button twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Enable unicode** option in the following screenshot to enable Unicode
    support and click on the **Next** button. Click on the **Finish** button in the
    next page to close this wizard. Wizard will generate necessary code and set up
    a project to develop app using the wxWidgets toolkit.![wxWidgets GUI toolkit](img/3415OS_04_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace code in the `App11Main.h` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: An `App11Frame` class has been derived from a `wxFrame` class. A `wxFrame` class
    represents a basic window. Member variable `m_btnClickMe` has been defined to
    create and store button and `idBtnClick` will store it's ID for event processing.
    We have placed a `DECLARE_EVENT_TABLE()` function macro to create boiler plate
    code for event handling related to this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next replace code in the `App11Main.cpp` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: An event table has been laid out using `BEGIN_EVENT_TABLE()` and `END_EVENT_TABLE()`
    macros. This defines relationship of callback functions with respective events.
    The `OnClickMe()` function has been connected to button press event. It will show
    a message whenever the **Click Me!** button is pressed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnClose()` function will be called when app closed. It calls a `Destroy()`
    function that initiates app shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now replace code in the `App11App.h` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding file we have derived a class `App11App` from `wxApp`. A virtual
    function `OnInit()` is implemented in this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next type the following code in the `App11App.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the implementation of `OnInit()` function an object named `frame` has been
    derived from the `App11Frame` class. Resource files are available only on Windows
    platform. Thus it has been enclosed within a pre-processor macro `__WXMSW__` and
    subsequently app is launched in line number `12`.
  prefs: []
  type: TYPE_NORMAL
- en: Leave code inside `resource.rc` file as it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hit *F9* button to compile and run. Following window will be launched. We find
    that our application is now working fine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![wxWidgets GUI toolkit](img/3415OS_04_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Earlier we mentioned about cross-platform development capability of wxWidgets.
    Let's put that capability into action. We'll compile `App11` source without any
    change on Linux platform. For this example, we are using **CentOS 6** Linux.
  prefs: []
  type: TYPE_NORMAL
- en: In order to compile on Linux platform, we'll use a `Makefile`. Remember we can
    also use the Code::Blocks wxWidgets project wizard to generate a project targeted
    at Linux platform. However in my opinion developers should be familiar with the
    `Make` tool.
  prefs: []
  type: TYPE_NORMAL
- en: Make is a build tool that can be used any number of source files to a binary
    based files on a set of rules inside a text file known as a `Makefile`. Make handles
    build dependencies efficiently and for a large project make will only compile
    relevant files, which has changed since last build. This saves time and also eliminates
    any human error in the entire build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Paste the following code into a file and save it with filename `Makefile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this file several variables are defined in first four lines. The `CPP` variable
    defines C++ compiler binary, `CXXFLAGS` stores necessary compiler flags for a
    `wxWidgets` project by running a script `wx-config`. The wxWidgets project provides
    a shell script known as `wx-config` that can be used determine compiler and linker
    flags.
  prefs: []
  type: TYPE_NORMAL
- en: '`LDFLAGS` stores necessary linker flags used for executable binary generation.
    `SOURCES` variable define the sources that are to be compiled. Do note that we
    are not using `resource.rc` file anymore as resource compiler doesn''t exist on
    Linux platform.'
  prefs: []
  type: TYPE_NORMAL
- en: '`App11:` line defines a make target `App11` which comprises two sub-targets
    `App11Main.o` and `App11App.o`. There is a shell command defined in the following
    line which indicates the command to be executed after all sub-targets are built
    successfully. Subsequently both these targets are also defined in a similar manner.'
  prefs: []
  type: TYPE_NORMAL
- en: 'clean: target executes a command to delete all object files and our executable
    binary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next issue the following command in Linux shell prompt to compile our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To run our app use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Following window will be displayed:![wxWidgets GUI toolkit](img/3415OS_04_44.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We find that our app now runs on Linux platform flawlessly. It behaves exactly
    as we wanted it to. We didn't make any changes to the code we wrote for Windows
    platform. But our GUI toolkit has internally mapped our code to appropriate functions
    for Linux platform. This gives an immense advantage to a developer as targeting
    multiple platforms becomes a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Rapid app development with wxSmith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned about app development for Windows platform in the last few sections.
    But all our code was hand-written. We also noticed that even for a simple GUI
    we have to write several lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: So, can we do something about it? How about automatic code generation of GUI
    codes? Sound interesting! Code::Blocks comes with a plugin, called **wxSmith**,
    which can generate C++ code (using wxWidgets toolkit) based on the user generated
    GUI inside a Visual editor. We'll learn this with another example.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new wxWidgets project. This time we'll name it something meaningful.
    In the following window enter project title as `MyNotePad`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the following page, select **wxSmith** as **Preferred GUI Builder**. This
    option configures wxWidgets project to use wxSmith GUI builder. Refer the following
    screenshot:![Rapid app development with wxSmith](img/3415OS_04_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the project generation is complete files following window will be displayed:![Rapid
    app development with wxSmith](img/Image1.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding window have the following three major components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **wxSmith** window: This window shows editable UI elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Resource** tree: This window gives an overall view of the project showing
    hierarchy of GUI elements of that particular project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Property** window: This window shows properties of currently selected
    object in wxSmith window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the `MyNotePadFrame` item shown in the following screenshot on the
    resource tree and then click on the **Title** property in the property window.
    Type `MyNotePad` in that text box. This will set title of our app to `MyNotePad`.![Rapid
    app development with wxSmith](img/3415OS_04_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we'll add a `wxTextCtrl` control to our app. This will add a text box to
    our app. Click on the `wxTextCtrl` control button on the toolbar below. Immediately
    the **MyNotePadFrame** window shown inside wxSmith window will be selected.![Rapid
    app development with wxSmith](img/3415OS_04_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on it and this text control will be added to that. The wxSmith window
    will look similar to the following screenshot:![Rapid app development with wxSmith](img/3415OS_04_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the property window change the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Text** property: It is an empty string. This property stores the text inside
    a text control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Var name** property: Change this to `TextCtrlNotePad`. This property will
    be used to name object of the `wxTextCtrl` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifier** property `ID_TEXTCTRL_NOTEPAD`: It will be assigned a unique
    integer and then will be used to assign it with an event handler and an event
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scroll down the property window and click on the **Style** property. Click on
    the **wxTE_MULTILINE** property to check it. This will enable text control show
    text in multiple lines.![Rapid app development with wxSmith](img/3415OS_04_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this next step, we'll edit menu bar. Double-click on the menu bar icon (shown
    in following screenshot):![Rapid app development with wxSmith](img/3415OS_04_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **MenuBar editor** window will pop up. Select the **Quit** menu option as
    in the following screenshot in the menu tree on the left side and then click on
    the **New** button:![Rapid app development with wxSmith](img/3415OS_04_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **^** button to move the new menu item above, **Quit** menu option.
    Four buttons shown in the following screenshot can be used to rearrange menu items
    in the menu tree:![Rapid app development with wxSmith](img/Image2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now select the new menu option in the menu tree and change the following properties
    on the right side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Id** property: Change this to `idFileOpen`. This property will be defined
    as a unique integer and will be used to assign it with an event handler and an
    event type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Label** property: Change this property to `&Open`. This text defines
    the menu label and `&O` text will define an accelerator key. This menu can now
    be selected and clicked by pressing *O* button whenever this menu option is visible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Accelerator** property: Change this one to `Ctrl+O`. This property defines
    a keyboard accelerator to this menu option. A keyboard accelerator is a unique
    combination of keystrokes that will generate a click event for this menu option
    irrespective of menu item''s visibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Help** property: Change this to `Opens a file...` text. This will display
    this text in the status bar whenever this option is selected by mouse cursor or
    keyboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Rapid app development with wxSmith](img/3415OS_04_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the **OK** button to close this window. We have now added a menu option
    to our existing menu bar. Before we add code to open a file with this menu option
    we need to add a file open save control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Dialogs** tab and then click on the **wxFileDialog** control
    button. This will add a standard file open and save dialog to the `MyNotePadFrame`
    class.![Rapid app development with wxSmith](img/3415OS_04_34.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the following properties in property window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Wildcard** to `*.txt`. This will set the filter text to files with `.txt`
    extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Var name** to `NotePadFileDialog`. This will be used to create an object
    of the `wxFileDialog` class that represents a standard open or save dialog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Rapid app development with wxSmith](img/3415OS_04_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we are set to add code to newly added menu option. Click on the **&Open**
    item in the resource tree and then click on the **{}** button in property window.
    Click on the dropdown box and choose the **-- Add new handler --** menu option
    as in the following screenshot:![Rapid app development with wxSmith](img/3415OS_04_36.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `OnFileOpen` text in the dialog box and then click on the **OK** button,
    as shown in the following screenshot:![Rapid app development with wxSmith](img/3415OS_04_37.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code editor window will be open. Add the following code to the `MyNotePadFrame::OnFileOpen()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's explain preceding code. We have defined couple of variables in the beginning.
    We are showing file open dialog using the `ShowModal()` function and result of
    this dialog will be stored inside the `result` variable. Next line checks that
    we have received a `wxID_OK` value, which indicates that user has selected a file.
  prefs: []
  type: TYPE_NORMAL
- en: We are opening a text file in using the `Open()` function with the filename
    received from dialog box. If file opening succeeds then we'll create a loop to
    read all lines one by one. The `fileContent` variable appends a line read from
    file and then appends a new line (`\r\n` on Windows) to this string. When we are
    done reading all lines opened text file is closed with the `Close()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we set text stored inside `fileContent` variable is stored to our main
    text control.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to include an extra header file in order to use the `wxTextFile`
    class. Add the following line after the `#include <wx/msgdlg.h>` line in the `MyNotePadMain.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to compile our little notepad app. Hit *F9* key to build and
    run it. Our app will look similar to the following screenshot:![Rapid app development
    with wxSmith](img/3415OS_04_38.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **File** | **Open** menu option and following dialog box will be opened:![Rapid
    app development with wxSmith](img/3415OS_04_39.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Open** button and the selected text file will now be opened by
    our app, as shown in the following screenshot:![Rapid app development with wxSmith](img/3415OS_04_40.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our app is now working! We wrote most of our GUI related code with the help
    of Code::Blocks. Only code that was manually written was the one we have inserted
    to open a text file. Code::Blocks offers an excellent cross-platform and rapid
    application development platform. We can develop a GUI app with Code::Blocks easily
    using this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned and developed our own notepad app in the previous section. However,
    our app was limited to opening a file. In this exercise we will extend our app
    to save a text file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a menu item `&Save` to file menu after `&Open` menu option, with `Ctrl+S`
    as keyboard accelerator, `idFileSave` as ID and `Saves a file...` as Help text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an event handler to this menu option and add event handler function `OnFileSave()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally add the following code to the `MyNotePadFrame::OnFileSave()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code is similar to the code we wrote for the `OnFileOpen()` function. We
    are using the `wxTextCtrl::FileSave()` function to save our file in line number
    `5`. Code in line number `6` ensures that an error message should be shown when
    a file can't be written.
  prefs: []
  type: TYPE_NORMAL
- en: I leave it to you to follow earlier steps and complete this exercise. You can
    refer accompanying MyNotePad app source code for this completed exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have learned app development for Windows using Win32 api
    and Code::Blocks. We then focused on GUI toolkit and developed our first app for
    Windows and Linux using wxWidgets toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Code::Blocks also has a rapid application development toolkit and we used it
    to develop our own Notepad app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll take one app and learn how to plan and develop it
    from scratch.
  prefs: []
  type: TYPE_NORMAL
