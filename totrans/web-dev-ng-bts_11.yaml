- en: Dependency Injection and Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to take a look at **dependency injection** (**DI**).
    While DI is not something that you have to program directly in Angular (since
    Angular takes care of all the DI plumbing for us), it still is something that
    is very useful to understand. This is because Angular makes heavy use of DI when
    managing its services, as well as any custom services that you are likely to write
    as you create your Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be looking at one of Angular's most important built-in services, its HTTP
    service, in the next chapter, [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml),
    *Integrating Backend Data Services*. Without the HTTP service, our applications
    would be super boring, since they would be unable to send data to, or receive
    data from, an outside source (including our own backend APIs). And so this chapter
    will serve us well in terms of helping us gain an understanding of how Angular
    injects services such as its HTTP service into our applications for us to use.
    Moreover, this topic is a perfect segue into the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the topics that we''re going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is DI?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What problem does it solve?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional advantages of using DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revealing the magic that Angular uses to make it all work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can guard against code minification (and why we need to)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a solid grasp on what this often misunderstood
    software design pattern is, and, more importantly, how it works. Dare I say, you
    may even start to feel more technically advanced than most of your peers. Many
    developers sometimes struggle to even define DI—because it does take some effort
    to wrap your mind around it.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let's get started and discover what DI is all about by
    *injecting* some more software design knowledge into our heads.
  prefs: []
  type: TYPE_NORMAL
- en: What is DI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cutting to the chase, DI is a specific case of the **Inversion of Control**
    (**IoC**) design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand this high-level definition of DI, or even IoC, we first
    need to quickly define design patterns. Design patterns are reusable solutions
    to common problems in software design. There are dozens of software design patterns,
    and they are typically categorized into the following three high-level categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, and in the interest of brevity, we can safely ignore the creational
    and structural categories of design patterns, since DI is a type of behavioural
    design pattern, and just before we take a look at the IoC design pattern (I know,
    there are a lot of definitions and concepts we need to know as prerequisites to
    truly appreciate what DI is), let's describe what behavioral design patterns are.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, behavioral design patterns concern themselves with how objects communicate
    with one another. One such pattern is known as the observer design pattern, which
    basically sets forth a way of how an object notifies its dependent objects of
    when its state changes.
  prefs: []
  type: TYPE_NORMAL
- en: Another behavioral design pattern is known as the publish-subscribe design pattern,
    which is a messaging pattern similar to the observer pattern, but a little fancier.
    Yet another behavioral design pattern is the template method. The purpose of this
    design pattern is to defer the exact implementation of an algorithm to a subclass.
    The overall idea behind all of these design patterns is the way they communicate
    (that is, message) with one another.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with a definition of what the template method is, we're getting much closer
    to what DI is all about, but just before we do, there is one last remaining design
    pattern that we need to define. You guessed it—the IoC design pattern. Remember,
    DI is a special case of the IoC pattern, and so we really do need to take a quick
    look at what it is.
  prefs: []
  type: TYPE_NORMAL
- en: IoC flips the typical flow of procedural, or imperative, code on its head. Instead
    of having a custom object's code control the flow of the program by instantiating
    another object and then calling one or more of the newly instantiated object's
    methods, it defers the instantiation to a framework—yes, a framework, not just
    another object—to do that instead. This will all make sense in a few moments.
    As an interesting tidbit, this is sometimes jokingly referred to as *Don't call
    us, we'll call you*.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to look at an example of this shortly so that it all makes sense.
    However, I need to define what I mean by a framework doing the instantiation of
    dependent objects. Don't you just love all the terms and concepts we need to know?
    (grinning). This framework is typically referred to as an IoC container. These
    containers are smart enough to be able to examine the custom code, figure out
    what other objects it depends on, instantiate those objects, and pass them into
    the custom object's constructor. This is opposed to the traditional way of having
    the instantiation of the object's dependencies happen within the custom object
    itself. Instead, the IoC container performs these duties for it. In a moment,
    I will tie this back to Angular and give you a couple of very important advantages
    that the IoC pattern provides, but we'll discuss it from the DI perspective—finally!
  prefs: []
  type: TYPE_NORMAL
- en: OK. Let's try to tie this all together and provide an example scenario, or use
    case. The Angular framework provides the functionality of an IoC container—among
    all the other things that it provides. Since Angular is a modular framework and
    encapsulates most of what it does in segregated services, it would make sense
    that its IoC capabilities are also encapsulated in one of its services—and, in
    fact, this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular service responsible for DI is its injector service—aptly named because
    it injects your custom class's dependencies into your class's constructor after
    instantiating them. Not only that, but it calls the custom method for you—back
    to what I had previously mentioned, *Don't call us, we'll call you*. All we need
    to do is to list the names of the dependencies in the constructor's signature
    for our custom class.
  prefs: []
  type: TYPE_NORMAL
- en: From this point forward, I will not mention IoC, because we're talking about
    DI—again,this is technically not IoC, but rather a special case of it. I only
    mention this because many developers use the terms IoC and DI synonymously.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s ask a couple of questions: Since DI is a design pattern, and design
    patterns solve common software design problems, what problems does DI solve? What
    are the advantages of DI? These are excellent questions, and I believe I can answer
    them in one fell swoop in the following two paragraphs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One problem that even object-oriented code has had for a very long time is
    that a class that depends on other classes (which is the whole point of object
    orientation—since we don''t want one class to do all of the work) had the code
    to instantiate these dependencies within itself, and, as a result, contained at
    least some of the logic intertwined within it as well. This is known as code that
    is tightly coupled. There are two problems with tightly coupled code: firstly,
    the implantation logic is typically encapsulated within the class—which is something
    we don''t want. We don''t want one object to know the inner workings of other
    objects. For instance—if we wanted to change the implementation of an algorithm
    in a dependent class, we''d likely also have to change our code in the class that
    calls it. Another problem that stems from this is that this code is difficult
    to test. The more tightly coupled our classes are, the harder it is to run our
    unit tests on them—and this problem has been around for as long as unit testing
    has.'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK. So how does DI solve these issues? We''ll get to a specific use case to
    make everything clearer in our minds, but let''s first describe a couple of the
    advantages that DI gives us. The first advantage of the principle of DI is that
    it forces us to write decoupled code. We do this by having the classes that we
    depend on (for their abstracted implementations) implement interfaces, and we
    do this so that all our calling class needs to do is to call the interface methods
    on these objects—not caring about the implementation details behind the underlying
    class methods. When we write code in this manner, we can swap out the class we
    depend on, which has a specific implementation, for another class that has another
    implementation—all without changing any of our calling code (since our code calls
    the interface methods that these classes implement). This is also sometimes referred
    to as coding by the interface. Here''s another interesting tidbit: this technique
    is also used in a style of programming known as aspect-oriented programming, or
    AOP for short.'
  prefs: []
  type: TYPE_NORMAL
- en: A very useful thing that we get for free by adhering to the DI design principal,
    is that we can very easily test our code—as opposed to not being able to test
    our code easily, or at all, as is the case when we have tightly coupled code.
    How do we do this? By writing stubs and/or mock classes—which also implement these
    very same interfaces that our calling class calls.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, there is an important difference between stubs and mocks. Stubs
    are dumb classes, which often just return a simple value (often hardcoded). Mock
    objects, on the other hand, typically have full implementations so that things
    such as edge cases can be tested—as well as to conduct database operations, or
    make RESTful API calls. Mocks can be used to do whatever your tests call for.
    So, stubs are dumb, while mocks are smart. What they have in common, however,
    is that they help us unit test our calling class's code by having the same object
    messaging pattern (that is, their methods are called via interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We're done with the theory part! Have you fallen asleep or are you still
    with me? Ah, you're awake—OK, good. With all that theory now out of the way, let's
    take a look at an example use case of where DI can be used for all the reasons
    mentioned previously—just so we can cement these concepts into our heads.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we're building an e-commerce application for an online store
    where we sell our homemade beer. Our application will need to have a shopping
    cart, and we'll also have to have at least one merchant account (which is a conduit,
    known as a payment processing gateway, so we can charge our customers' credit
    cards). In this hypothetical scenario, we have two merchant accounts—maybe because
    we'd like to keep one as a spare in case the primary merchant account increases
    their discount rates (that is, fees), thereby lowering our profits—but the point
    is, we have two merchant accounts.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to implementing the shopping cart, we want to be able to swap
    out one merchant account for another one—if we need to—without changing the code
    in our shopping cart class. The reason we don't want to change any code is that
    we may accidentally introduce bugs in our application (the online store), and
    this just wouldn't look good to customers. You may be saying—*Hey, I test my code—so
    bugs are fleshed out*—and if you said that, you fell right into the next benefit
    of using DI for our application, which is that we can easily test our application
    by writing test classes—remember our stubs and mocks? Yes—we write stubs and mocks
    so we can test our code. And again, thanks to DI, we don't have to change our
    shopping cart class to do so. We have our stubs and mocks implement the interfaces.
    And we would wrap the bank's APIs (that is, our merchant account classes—written
    by a third party) in a custom class that implements our interface—so that all
    these classes (that is, our stubs, mocks, and wrapped real bank objects) can be
    called in the exact same way.
  prefs: []
  type: TYPE_NORMAL
- en: Cool. So, as a bonus, let's take a quick look at how Angular knows what our
    class needs, and how it can call our class's constructor method for us. Well,
    it's not magic, but it is ingenious. However, Angular does need a little upfront
    help from us. When we create custom classes, for our application, we typically
    wrap them up as Angular services (we'll take a look at services in the next chapter,
    [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating Backend
    Data Services*). Angular requests that we register these services with it, and
    you'll see why we need to do this in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Angular's injector service scans our code, specifically, our class's constructor
    signature, and figures out its parameters. Because our parameters are services
    that we need for our class, it knows that the parameters are services. It then
    matches the text of the service name against the manifest of its own services,
    as well as any custom services that we wrote ourselves, and when a match is found,
    it instantiates that service object. The reason it can do this is that it knows
    its own services, and it knows what services we wrote because we had to register
    them with Angular.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing Angular does, once it has these instantiated service objects,
    is to call our class's constructor, passing the objects in as the arguments. That
    is the injection process that Angular's injector service does. One more time,
    say it with me: *Don't call us, we'll call you*. And just like that, the magic
    behind what Angular does has been explained away. Still, it's very cool and we
    should tip our hat to the Angular development team.
  prefs: []
  type: TYPE_NORMAL
- en: Generating services and interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have learned about DI and design patterns, in this section, we
    will learn to create our services. Angular CLI provides us with the fastest and
    easiest way to generate services inside our project. We will create a sample project
    called `LearningDIServices` by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating a new Angular project using the `ng` command, and we name the
    project `LearningDIServices`. Upon successful execution of the command, we should
    see the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0dc77003-59b5-4b85-b4c9-b2d981395a23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our project directory created, using the Angular CLI, we will
    generate a few services and interfaces. We will create a service called `Photos`.
    Run the following command and we should see the service added to our project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon successful execution, we should see the output shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fc60bcb9-dd04-46a4-9496-239097d1edfe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that there are two new files generated. One is the service file,
    and the other is the spec file, which is for writing the tests for the service.
    Let''s take a closer look at the files containing autogenerated code for the `photo.service.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that the `Injectable` class needs to be imported
    from the `angular/core` library. The `Injectable` class allows us to make the
    service inject in various component classes so that we can reuse the methods.
    Using the injectable decorator, we are explicitly mentioning that the service
    needs to be injected in the root. And finally, we are exporting our `PhotosService`
    class, which will contain the constructor method and other methods that we will
    create, specific to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the Angular components, there is no need to update `app.module.ts` file
    with an entry of the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous sections, we learned about the overview of interfaces. Now, let''s
    quickly learn how to generate use of the interfaces in our applications. Using
    Angular CLI, we can also quickly create interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, we have generated an interface named `photo` and,
    once the preceding command is executed successfully, we should see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f020b705-6285-4798-8da1-ca1a2ce25e9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a closer look at the interface files that are generated. The following
    is the default code generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see it''s empty intentionally. Since interfaces are used to define the
    entity or model classes, each interface created in the application will be unique
    and specific to each application. Now, if we want to create an interface for our
    photos, we will have to define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding sample code, we have created an interface for photos with some
    properties and their data types. This will allow us to create strictly typed objects
    for photos.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned to create Angular services and interfaces. Even
    if some of the concepts are not very clear, do not worry, my friend. We have an
    entire chapter dedicated to showing you how to generate and implement services
    in our applications. In the next chapter, we will learn how to implement and use
    them, and also integrate them into our components.
  prefs: []
  type: TYPE_NORMAL
- en: Guarding against code minification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one last thing that I would like to cover really quickly, and that
    is code minification and how we can guard against it. Code minification is the
    process of compressing our code by removing the whitespace, as well as replacing
    variable names with very short symbols. This is done when we compile our Angular
    application so that it becomes a smaller package that our users have to download
    (once we've deployed our application) to retrieve our application. But this does
    present a problem for us. It can wreck our day by changing the parameter names
    and then Angular can no longer match the names against the service manifest. Fortunately,
    there is an easy solution. If we add single quotes around our parameter names,
    we protect our code against code minification. How? Well, putting quotes around
    the service names turns them into literal strings, and the minification process
    does not compress or change strings—it leaves them intact. This is because literal
    strings have a meaning outside of syntax, and is not code. Minification just minifies
    code (that is, variable and function names, and whitespace). That's all you have
    to know about protecting your code from code minification.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now feel comfortable with what DI is, and what problem it solves.
    You should also be able to list a few of the advantages—thus being able to explain
    why DI is a good principle for us to follow in designing our applications. And
    you should also be comfortable in explaining away the seemingly magical feats
    that Angular performs in making everything work out of the box. And finally, you
    should also now know how to guard your DI code against code minification.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this DI knowledge, we can now continue our journey into discovering
    one of Angular's most useful services, its HTTP service, in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml),
    *Integrating Backend Data Services*. Once you complete the next chapter, you will
    be ready to write code to integrate your Angular application with virtually any
    RESTful API-compliant application and/or service that your application is authorized
    to talk to. That should sound exciting to you! If it does, turn the page and continue
    your journey to Angular enlightenment.
  prefs: []
  type: TYPE_NORMAL
