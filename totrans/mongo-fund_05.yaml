- en: 5\. Inserting, Updating, and Deleting Documents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 插入、更新和删除文档
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to the core operations in MongoDB, namely inserting,
    updating, and deleting documents in a collection. You will learn how to insert
    a single document or a batch of multiple documents into a MongoDB collection.
    You will add or autogenerate an `_id` field, replace existing documents, and update
    specific fields in the documents of an existing collection. Finally, you will
    learn how you can delete all or delete specific documents in a collection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了MongoDB中的核心操作，即在集合中插入、更新和删除文档。您将学习如何将单个文档或一批多个文档插入到MongoDB集合中。您将添加或自动生成一个`_id`字段，替换现有文档，并更新现有集合中文档的特定字段。最后，您将学习如何删除集合中的所有文档或特定文档。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In previous chapters, we covered various database commands and queries. We learned
    to prepare query conditions and use them to find or count the matching documents.
    We also learned to use various conditional operators, logical operators, and regular
    expressions on fields, nested fields, and arrays. In addition to these, we learned
    how to format, skip, limit, and sort the documents in the result set.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们涵盖了各种数据库命令和查询。我们学会了准备查询条件并使用它们来查找或计算匹配的文档。我们还学会了在字段、嵌套字段和数组上使用各种条件运算符、逻辑运算符和正则表达式。除此之外，我们还学会了如何格式化、跳过、限制和对结果集中的文档进行排序。
- en: 'Now that you know how to correctly find and represent the required documents
    from a collection, the next step is to learn how to modify the documents in the
    collection. When working on any database management system, you will be required
    to modify the underlying data. Consider this: you are managing our movies dataset
    and are often required to add new movies to the collection as they release. You
    will also be required to permanently remove some movies or remove incorrectly
    inserted movies from the database. Over a period of time, some movies may receive
    new awards, reviews, and ratings. In such cases, you will need to modify the details
    of existing movies.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何正确地从集合中找到并表示所需的文档，下一步是学习如何修改集合中的文档。在任何数据库管理系统上工作时，您都将需要修改底层数据。想象一下：您正在管理我们的电影数据集，并经常需要在电影上映时向集合中添加新电影。您还需要永久删除一些电影或从数据库中删除错误插入的电影。随着时间的推移，一些电影可能会获得新的奖项、评论和评分。在这种情况下，您将需要修改现有电影的详细信息。
- en: In this chapter, you will learn how to create, delete, and update documents
    in a collection. We will start by creating new collections, adding one or more
    documents to a collection, and consider the importance of the unique primary key.
    We will then cover deleting all or deleting specific documents from a collection,
    as well as various delete functions provided by MongoDB and their characteristics.
    Next, you will learn how to replace existing documents from a collection and understand
    how MongoDB keeps the primary key unchanged. You will also see how to use the
    replace operation to perform an update or insert, which is also called upsert.
    Finally, you will learn to modify documents. MongoDB provides various update functions
    and a wide range of update operators that can be used in specific requirements.
    We will cover all of these functions in depth and practice with the operators.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何在集合中创建、删除和更新文档。我们将首先创建新的集合，向集合中添加一个或多个文档，并考虑唯一主键的重要性。然后，我们将介绍如何从集合中删除所有或删除特定文档，以及MongoDB提供的各种删除函数及其特性。接下来，您将学习如何替换集合中的现有文档，并了解MongoDB如何保持主键不变。您还将了解如何使用替换操作执行更新或插入，也称为upsert。最后，您将学习如何修改文档。MongoDB提供了各种更新函数和广泛的更新运算符，可用于特定需求。我们将深入研究所有这些函数，并练习使用这些运算符。
- en: Inserting Documents
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入文档
- en: 'In this section, you will learn to insert new documents into a MongoDB collection.
    MongoDB collections provide a function named `insert()`, which is used to create
    a new document in a collection. The function is executed on the collection and
    takes the document to be inserted as an argument. The syntax of this function
    is shown in the next command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何向MongoDB集合中插入新文档。MongoDB集合提供了一个名为`insert()`的函数，用于在集合中创建新文档。该函数在集合上执行，并将要插入的文档作为参数。该函数的语法如下命令所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To see this in an example, open the mongo Shell, connect to the database cluster,
    and create a new database by using the `use CH05` command. You can give a different
    name to the database as per your preference. The database mentioned in this command
    will be created if it is not present earlier. In the following operation, we are
    inserting a movie with a `title` field and an `_id`, and the output is printed
    on the next line:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要在示例中查看此内容，请打开mongo Shell，连接到数据库集群，并使用`use CH05`命令创建一个新数据库。您可以根据自己的喜好给数据库取一个不同的名字。如果之前不存在该数据库，则该命令中提到的数据库将被创建。在以下操作中，我们正在插入一个带有`title`字段和`_id`的电影，并且输出将打印在下一行上：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we will be inserting, updating, and deleting a lot of documents
    in collections, and we do not want to corrupt the existing `sample_mflix` dataset.
    For this reason, we are creating a different database and using it throughout
    the chapter. Exercises and activities are focused on real-world scenarios and
    will therefore use the `sample_mflix` dataset.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在集合中插入、更新和删除大量文档，并且我们不希望损坏现有的`sample_mflix`数据集。因此，我们正在创建一个不同的数据库，并在整个章节中使用它。练习和活动侧重于真实场景，并因此将使用`sample_mflix`数据集。
- en: 'This mongo shell snippet shows the execution of the `insert` command and the
    result on the next line. The result (`WriteResult`) shows that one record was
    successfully inserted. First perform a `find()` query and confirm whether the
    record was created as we wanted:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个mongo shell片段显示了`insert`命令的执行和下一行的结果。结果（`WriteResult`）显示成功插入了一条记录。首先执行一个`find()`查询，确认记录是否按我们的要求创建：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding query and its output verify the correct insertion of our document.
    However, notice that the collection of `new_movies` was never present, nor did
    we create it. Where did the document go?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'To find that, you execute the `show collections` command on the shell. This
    command prints the names of all collections in the current database:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding snippet shows a new collection of `new_movies` is added to the
    database. This proves that, when a document `insert` command is executed, MongoDB
    will also create the given collection, if it does not exist already.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: When a new document is inserted, MongoDB does not validate the name of the collection.
    A typo in the collection name will result in the document being added to a completely
    new collection. Also, by default, MongoDB does not have any schema associated
    with a collection. Because of this, by giving an incorrect collection name, you
    may accidentally end up adding your document to any other existing collection,
    and MongoDB will not complain. This is why you should always be careful about
    the collection names in your `insert` commands.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Multiple Documents
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When multiple documents need to be inserted into a collection, you can call
    the `insert()` function that you saw in the previous section multiple times, as
    shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'MongoDB collections also provide the `insertMany()` function, which is a function
    specifically meant for inserting multiple documents into a collection. As shown
    in the syntax that follows, this function takes one argument of an array containing
    one or more documents to be inserted:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To use this function, create an array of all the documents to be inserted and
    then pass this array to the function. The array of the same four movies will look
    like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, you insert these four new movies into the collection:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding command uses `insertMany()` and passes an array of four movies
    to it. You can see the result in the following figure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Using insertMany() to pass an array of four movies'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Using insertMany() to pass an array of four movies'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The result in the preceding operation contains two things. The first field is
    `acknowledged` with the value of `true`. This confirms the write operation was
    successfully performed. The second field of the result lists down all the `IDs`
    of the inserted documents. To insert multiple documents, it is preferable to use
    the `insertMany()` function, because insertion happens as a single operation.
    On the other hand, the insertion of each document separately will be executed
    as a number of different database commands and will make the process slower.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: You can insert as many documents as you want using the function `insertMany()`.
    However, the batch size should not exceed 100,000\. On a mongo shell, if you try
    to insert more than 100,000 documents in a single batch, the query will fail.
    If you do the same thing using a programming language, the MongoDB driver will
    internally split a single operation into multiple batches of permissible sizes
    and perform the batch insert.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Duplicate Keys
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any database system, a primary key is always unique in the table. Similarly,
    in MongoDB collections, the value expressed by the `_id` field is a primary key,
    and so it must be unique. If you try to insert a document whose key is already
    present in the collection, you will get a *Duplicate Key Error*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous examples, we have already inserted a movie whose `_id` is `2`.
    Now we will try to duplicate the primary key in another `insert` operation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This `insert` operation inserts a dummy movie into the collection and explicitly
    mentions the `_id` field as `2`. When the command is executed, we get a duplicate
    key error with a detailed message, as can be seen in the following figure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Error message for the duplicate _id field'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: Error message for the duplicate _id field'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the operation of a bulk insert fails when one or more of the documents
    in the given array has a duplicate `_id`. For example, consider the following
    snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当给定数组中的一个或多个文档具有重复的`_id`时，批量插入操作将失败。例如，考虑以下代码片段：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, using the `insertMany()` operation, you will insert four different movies
    into your collection. However, the third movie has an `_id` of `2`, and we know
    that another movie with the same `_id` already exists. This leads to an error,
    as can be seen in the following figure:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用`insertMany()`操作，您将向集合中插入四部不同的电影。然而，第三部电影的`_id`为`2`，我们知道已经存在另一部具有相同`_id`的电影。这导致错误，如下图所示：
- en: '![Figure 5.3: Error message for the duplicate _id field'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3：重复_id字段的错误消息'
- en: '](img/B15507_05_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_03.jpg)'
- en: 'Figure 5.3: Error message for the duplicate _id field'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：重复_id字段的错误消息
- en: 'When you execute the command, it fails with a detailed error message. The error
    message clearly indicates that the value of `2` is duplicated in the `_id` field.
    However, the value of `nInserted` indicates that two documents have been inserted
    successfully. To confirm this, you will query the database and observe the output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行该命令时，它将失败并显示详细的错误消息。错误消息清楚地指出`_id`字段中的值`2`是重复的。然而，`nInserted`的值表明已成功插入了两个文档。为了确认这一点，您将查询数据库并观察输出：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the `find()` command and its output, shown in the previous snippet, we
    can conclude that the command failed while inserting the third document. However,
    the documents inserted before the third one will remain in the database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的`find()`命令及其输出中，我们可以得出结论，该命令在插入第三个文档时失败。然而，在第三个文档之前插入的文档将保留在数据库中。
- en: Inserting without _id
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有_id的插入
- en: So far, we have learned the basics of creating new documents in a collection.
    In all the examples we showed up till now, we explicitly added a primary key (`_id`
    field). However, in *Chapter 2*, *Documents and Data Types*, we learned that while
    creating a new document, MongoDB verifies the presence and uniqueness of a given
    primary key and, if the primary key is not already present, the database autogenerates
    it and adds it into the document.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了在集合中创建新文档的基础知识。在我们到目前为止展示的所有示例中，我们都明确添加了主键（`_id`字段）。然而，在*第2章*，*文档和数据类型*中，我们学到，在创建新文档时，MongoDB会验证给定主键的存在和唯一性，如果主键尚不存在，数据库会自动生成它并将其添加到文档中。
- en: 'The following is a snippet from the mongo shell where an `insert` command is
    executed. The `insert` command is trying to push a new movie into the collection,
    but the document does not have an `_id` field. The result on the very next line
    shows that the document is successfully created inside the collection:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是mongo shell中执行`insert`命令的代码片段。`insert`命令试图将新电影推送到集合中，但文档没有`_id`字段。下一行的结果显示，文档已成功创建在集合中：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, you query the newly inserted document and see if it has the `_id` field.
    To do so, query the collection using the value of the `title` field:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您查询新插入的文档，并查看它是否具有`_id`字段。为此，使用`title`字段的值查询集合：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the previous snippet, the result shows that the document exists in the collection
    and an autogenerated `_id` field is added to the document. As we learned in *Chapter
    2*, *Documents and Data Types*, the autogenerated primary is derived from the
    `ObjectId` constructor and it is globally unique. The same is true for bulk inserts.
    For instance, consider the following snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，结果显示文档存在于集合中，并且自动生成的`_id`字段已添加到文档中。正如我们在*第2章*，*文档和数据类型*中学到的，自动生成的主键来自`ObjectId`构造函数，它是全局唯一的。对于批量插入也是如此。例如，考虑以下代码片段：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, the `insertMany()` command is pushing four movies into the collection.
    Out of the four new documents, the third document does not have a primary key;
    however, the rest of the documents have respective primary keys. The result of
    this can be seen as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`insertMany()`命令将四部电影推送到集合中。在这四个新文档中，第三个文档没有主键；然而，其余的文档都有各自的主键。其结果如下所示：
- en: '![Figure 5.4: Inserting a movie without _id'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4：插入没有_id的电影'
- en: '](img/B15507_05_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_04.jpg)'
- en: 'Figure 5.4: Inserting a movie without _id'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：插入没有_id的电影
- en: The output of the query indicates the query was successful, and the `insertedIds`
    field shows that all documents except the third were inserted with the given keys
    and the third document has got an autogenerated primary key.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的输出表明查询成功，并且`insertedIds`字段显示除第三个文档外，所有文档都已使用给定的键插入，第三个文档获得了自动生成的主键。
- en: While working on datasets, our documents will have unique fields that can be
    used as primary keys. Primary keys are the ones that can uniquely identify a record.
    MongoDB's autogenerated keys are useful in terms of uniqueness, but they are meaningless
    in terms of the data the respective document represents. Also, these autogenerated
    keys are lengthy and thus tedious to type in or remember. Therefore, we should
    always try to use the primary keys that already exist in the datasets. For example,
    in a user's dataset, the `email_address` field is the best example of a primary
    key. However, in the case of movies, there is no field that can be unique. So,
    for the purpose of movies, we can use autogenerated primary keys.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据集时，我们的文档将具有可用作主键的唯一字段。主键是可以唯一标识记录的字段。MongoDB自动生成的键在唯一性方面很有用，但在表示相应文档的数据方面是无意义的。此外，这些自动生成的键很长，因此输入或记住它们很麻烦。因此，我们应该始终尝试使用数据集中已经存在的主键。例如，在用户数据集中，`email_address`字段是主键的最佳示例。然而，在电影的情况下，没有可以是唯一的字段。因此，对于电影，我们可以使用自动生成的主键。
- en: In this section, we covered how to create a single as well as multiple documents
    in a collection. During this, we learned that in MongoDB an `insert` command also
    creates the underlying collection if it does not exist. We also learned that the
    primary keys need to be unique in a collection, and if a new document does not
    have a primary key, MongoDB autogenerates and adds it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何在集合中创建单个文档和多个文档。在此过程中，我们了解到在MongoDB中，`insert`命令还会在不存在时创建底层集合。我们还了解到主键在集合中需要是唯一的，如果新文档没有主键，MongoDB会自动生成并添加它。
- en: Deleting Documents
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文档
- en: In this section, we will see how to remove the documents from a collection.
    To delete one or more documents from a collection, we have to use one of the various
    delete functions provided by MongoDB. Each of these functions has different behaviors
    and purposes. To delete documents from a collection, we have to use one of the
    delete functions and provide a query condition to specify which documents should
    be deleted. Let's take a look at this in detail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何从集合中删除文档。要从集合中删除一个或多个文档，我们必须使用MongoDB提供的各种删除函数之一。每个函数都有不同的行为和目的。要从集合中删除文档，我们必须使用其中一个删除函数，并提供一个查询条件来指定应删除哪些文档。让我们详细看一下。
- en: Deleting Using deleteOne()
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用deleteOne()删除
- en: As the name suggests, the function `deleteOne()` is used to delete a single
    document from a collection. It accepts a document representing a query condition.
    Upon successful execution, it returns a document containing the total number of
    documents deleted (represented by the field `deletedCount`) and whether the operation
    was confirmed (given by the field `acknowledged`). However, as the method deletes
    only one document, the value of `deletedCount` is always one. If the given query
    condition matches more than one document in the collection, only the first document
    will be deleted.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`deleteOne()`函数用于从集合中删除单个文档。它接受一个表示查询条件的文档。成功执行后，它返回一个包含删除的文档总数（由字段`deletedCount`表示）以及操作是否被确认（由字段`acknowledged`给出）的文档。然而，由于该方法只删除一个文档，`deletedCount`的值始终为1。如果给定的查询条件在集合中匹配多个文档，只有第一个文档将被删除。
- en: 'To see this, write a delete command using `deleteOne()` and see the results:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这一点，请使用`deleteOne()`编写一个删除命令并查看结果：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code snippet, you executed the `deleteOne()` command and passed
    a query condition of `{_id : 2}`. This means that you want to delete a document
    for which the value of `_id` is `2`. The output on the next line indicates that
    the deletion was successful.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码片段中，您执行了`deleteOne()`命令，并传递了一个查询条件`{_id: 2}`。这意味着您要删除`_id`值为`2`的文档。下一行的输出表明删除成功删除了。'
- en: 'Exercise 5.01: Deleting One of Many Matched Documents'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.01：删除多个匹配的文档中的一个
- en: 'In this exercise, you will use a query that matches more than one document
    and verify that only the first document is deleted when you do this. Perform the
    following steps to complete this exercise:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用一个匹配多个文档的查询，并验证当您这样做时只有第一个文档被删除。执行以下步骤完成这个练习：
- en: 'Use a regular expression in a query to match all movies where the `title` field
    starts with the word `movie`, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查询中使用正则表达式，匹配所有`title`字段以单词`movie`开头的电影，如下所示：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following snippet from the mongo shell shows that when you use the preceding
    query condition in a `find()` query, you get four movies:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: mongo shell中的以下片段显示，当您在`find()`查询中使用前面的查询条件时，您会得到四部电影：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use the same query condition with `deleteOne()` to match all movies with titles
    starting with the word `movie`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的查询条件和`deleteOne()`来匹配所有标题以单词`movie`开头的电影：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output in the second line here confirms that only one document is deleted successfully.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第二行输出确认只有一个文档成功删除。
- en: 'To find out which document is deleted, execute the same `find()` query on your collection:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找出哪个文档被删除了，请在您的集合上执行相同的`find()`查询：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding snippet confirms that, although all four documents matched the
    query condition, only the first document is deleted.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段证实，尽管所有四个文档都匹配了查询条件，但只有第一个文档被删除了。
- en: Deleting Multiple Documents Using deleteMany()
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用deleteMany()删除多个文档
- en: To delete multiple documents that match the given criteria, you can execute
    the `deleteOne()` function multiple times. However, in that case, each document
    will be deleted in a separate database command, which can slow down the performance.
    MongoDB collections provide the function `deleteMany()` to delete multiple documents
    in a single command.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除符合给定条件的多个文档，您可以多次执行`deleteOne()`函数。然而，在这种情况下，每个文档将在单独的数据库命令中被删除，这可能会降低性能。MongoDB集合提供了`deleteMany()`函数，可以在单个命令中删除多个文档。
- en: 'The `deleteMany()` function must be provided with a query condition, and all
    the documents that match the given query will be removed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteMany()`函数必须提供一个查询条件，所有匹配给定查询的文档将被删除：'
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `deleteMany()` command in the previous snippet uses the same regular expression
    used in the previous examples. The output in the next line indicates that all
    three movies whose titles start with the word "movie" are deleted.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个片段中的`deleteMany()`命令使用了前面示例中使用的相同的正则表达式。下一行的输出表明，所有标题以单词"movie"开头的三部电影都被删除了。
- en: The behavior of both of the delete functions, in terms of matching the documents
    to given query expressions, is similar to finding documents, as we saw in the
    previous chapter. Passing an empty query document is equivalent to not passing
    any filter, and thus, all the documents are matched.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配给定查询表达式的文档方面，这两个删除函数的行为与我们在上一章中看到的查找文档的行为类似。传递一个空的查询文档等同于不传递任何过滤器，因此所有文档都被匹配。
- en: 'In the following example, both of the commands have been given an empty query document:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，这两个命令都被给予了一个空的查询文档：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `deleteOne()` function will delete the document that is found first. However,
    the `deleteMany()` function will delete all the documents in the collection. In
    the same manner, the following queries perform a **null** check on a non-existent
    field. In MongoDB, a non-existent field is considered to be **null** and so the
    given condition will match all of the documents in the collection:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteOne()`函数将删除找到的第一个文档。但是，`deleteMany()`函数将删除集合中的所有文档。同样，以下查询对不存在的字段执行**null**检查。在MongoDB中，不存在的字段被视为**null**，因此给定条件将匹配集合中的所有文档：'
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike finding documents, delete operations are `write` operations, and they
    permanently change the state of the collection. Therefore, while writing query
    conditions, which include null checks, you should always ensure that there is
    no typo in the field name. An incorrect field name may lead to the removal of
    all documents from the collection.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与查找文档不同，删除操作是`write`操作，并且会永久改变集合的状态。因此，在编写查询条件时，包括空值检查，您应该始终确保字段名称没有拼写错误。不正确的字段名称可能导致从集合中删除所有文档。
- en: Deleting Using findOneAndDelete()
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用findOneAndDelete()进行删除
- en: 'Apart from the two delete methods we saw previously, there is another function
    named `findOneAndDelete()`, which, as the name indicates, finds and deletes one
    document from the collection. Although it behaves similarly to the `deleteOne()`
    function, it provides a few more options:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前看到的两种删除方法之外，还有另一个名为`findOneAndDelete()`的函数，正如其名称所示，它从集合中查找并删除一个文档。虽然它的行为类似于`deleteOne()`函数，但它提供了一些更多的选项：
- en: It finds one document and deletes it.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它找到一个文档并将其删除。
- en: If more than one document is found, only the first one will be deleted.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到多个文档，只有第一个会被删除。
- en: Once deleted, it returns the deleted document as a response.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦删除，它会将被删除的文档作为响应返回。
- en: In the case of multiple document matches, the `sort` option can be used to influence
    which document gets deleted.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个文档匹配的情况下，可以使用`sort`选项来影响哪个文档被删除。
- en: Projection can be used to include or exclude fields from the document in response.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投影可以用来在响应中包含或排除文档中的字段。
- en: 'Here, use `findOneAndDelete()` to delete a record and get the deleted document
    as a response:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用`findOneAndDelete()`来删除一条记录，并将删除的文档作为响应获取：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding snippet, the delete command finds a document by its `_id`.
    The response in the next line shows that the deleted document is returned in the
    response. This is a very useful feature. Firstly, because it clearly indicates
    which record was matched and deleted. Secondly, it allows you to further process
    the deleted record. In some cases, you may want to store the record in an archive
    collection, or you may want to inform some other system about this deletion. If
    the query matches multiple documents, only the first document gets deleted. However,
    you can use an option to sort the matched documents and control which document
    gets deleted, as can be seen in the following snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，删除命令通过其`_id`找到一个文档。下一行的响应显示了被删除的文档。这是一个非常有用的功能。首先，因为它清楚地指示了匹配和删除的记录。其次，它允许您进一步处理已删除的记录。在某些情况下，您可能希望将记录存储在归档集合中，或者您可能希望通知其他系统进行此删除。如果查询匹配多个文档，只有第一个文档会被删除。但是，您可以使用选项对匹配的文档进行排序并控制哪个文档被删除，如下面的片段所示：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using the preceding `insert` command, you have inserted five new documents
    into your collection. In the following snippet, you use the `findOneAndDelete()`
    command, which uses a regular expression to find those titles in the collection
    that start with the word `movie`. The query will match four documents; however,
    you will sort the `_id` field in descending order so that the document with the
    `_id` of 14 gets deleted:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上面的`insert`命令，您已经将五个新文档插入到您的集合中。在下面的片段中，您使用`findOneAndDelete()`命令，该命令使用正则表达式在集合中查找以单词`movie`开头的标题。查询将匹配四个文档；但是，您将按照降序排序`_id`字段，以便删除`_id`为14的文档：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This operation demonstrates how a sort option can influence which documents
    get deleted. Without providing the sort option, the document with an `_id` of
    11 will be deleted.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作演示了排序选项如何影响被删除的文档。如果不提供排序选项，将会删除`_id`为11的文档。
- en: 'As we have seen, this delete function always returns the deleted document in
    the response. We can also use the projection option to control the fields that
    are included or excluded in the document in response:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，这个删除函数总是在响应中返回被删除的文档。我们还可以使用投影选项来控制响应中包含或排除的字段：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this delete command, we are using the option of projection to include only
    the `title` field in the response. The output on the next line confirms the successful
    deletion and the document in response shows only the `title` field.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个删除命令中，我们使用了投影选项，只在响应中包含`title`字段。下一行的输出确认了成功的删除，并且响应中的文档只显示了`title`字段。
- en: 'Exercise 5.02: Deleting a Low-Rated Movie'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.02：删除评分低的电影
- en: The movie archives team in your organization is the team that ensures that most
    highly rated movies are present in the database. In order to improve the user
    experience, they want to frequently perform quality checks on the database and
    remove the movies with the lowest ratings. To measure quality, they want to consider
    IMDb ratings and the total number of votes because a higher number of votes means
    a more reliable rating.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您组织中的电影档案团队负责确保数据库中存在大多数评分最高的电影。为了改善用户体验，他们希望经常对数据库进行质量检查，并删除评分最低的电影。为了衡量质量，他们希望考虑IMDb评分和总投票数，因为投票数越高意味着评分更可靠。
- en: 'Based on this, they asked you to remove a movie with a high number of IMDb
    votes, a low average rating, and the least awards won from the list of low-rated
    movies. Your task for this exercise is to connect to the `sample_mflix` cluster
    and execute a delete command so that a movie with least awards won, an IMDb rating
    of less than 2, and more than 50,000 votes gets deleted. Then, record the `title`
    and `_id` of the deleted movie. The following steps will help you complete this
    exercise:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have to delete one movie, you can use either the `deleteOne()` or `findOneAndDelete()`
    function and prepare a query filter using the IMDb rating and votes. However,
    to ensure that the movie with the least awards gets deleted, you need to sort
    the films in ascending order of awards won and let the first movie in the resulting
    list be deleted. This means you will need to use `findOneAndDelete()`. First,
    open any text editor and start writing the query. Begin by writing the query filter.
    The first condition is to find movies with less than a two-point rating in IMDb:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The IMDb rating is a nested field; therefore, you will use the dot notation
    to access the field and then write the condition using the `$lt` operator.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the second condition says the total number of IMDb votes should be more
    than 50,000\. Add this condition to your query:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The second condition is expressed using the `$gt` operator.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, write a `findOneAndDelete()` function and add the preceding query into
    it:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding command will find movies with less than 2-star ratings and more
    than 50,000 votes and delete the first one. However, you also want to ensure that
    the movie with the least awards gets deleted.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete the movie with the least awards won, add a `sort` option:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This command sorts the filtered movies in ascending order of awards won.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a projection option to return only the `_id` and `title` field of
    the deleted movie:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding command has a projection option wherein the `title` field is explicitly
    included. This means that all the other fields will be excluded, while `_id` is
    included by default.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, open the mongo shell and connect to the Atlas cluster. Use the `sample_mflix`
    database and execute the preceding command. You should see the following output:![Figure
    5.5: Deleting the low-rated movie'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_05_05.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.5: Deleting the low-rated movie'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the preceding output, the command was executed successfully. The
    document returned in the response correctly includes the `_id` and `title` of
    the deleted movie.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you used one of the delete functions to correctly delete a
    specific record from the real-world collection of movies.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Replacing Documents
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how you can completely replace the documents
    in a collection.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you may want to replace an incorrectly inserted document in a collection.
    Or consider that, often, the data stored in documents is changed over time. Or,
    perhaps, to support your product's new requirements, you may want to alter the
    way your documents are structured or change the fields in your documents. In all
    such cases, you will need to replace the documents.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we used a new database of `CH05` which we will continue
    using in this section. In the same database, create a collection named `users`
    and insert a few users into it, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can see that the command is successful, and four users are added. Before
    going any further, quickly use the `find()` command to ensure no other documents
    are present in the collection except for the newly inserted ones:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the documents in the preceding snippet, each user has a unique ID, name,
    and email address. Now, suppose the user `Margaery Tyrell` gets married to `Joffrey
    Baratheon`, and she wishes to change her surname to her husband's. To accomplish
    this, you will have to change her name as well as her email.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'As per the requirement, the new record for `Margaery Tyrell` should look like
    this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To replace a single document in a collection, MongoDB provides the method `replaceOne()`,
    which accepts a query filter and a replacement document. The function finds the
    document that matches the criteria and replaces it with the provided document.
    The following example demonstrates this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, the first argument is the query filter to identify the document to be
    replaced, and the second argument is the new document. The output clearly indicates
    that the given query matched one document and one document was updated. The query
    filter need not always be the `_id` field. It can be any query that filters using
    any field or combination of multiple fields and operators. For example, the following
    replace command will have the same effect as the previous one, as long as there
    is only one user with the name of `Margaery Tyrell`. If there is more than one
    document that matches the query, then only the first one will be replaced:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: _id Fields Are Immutable
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous example, you will have noticed that there was no `_id` field
    in the replacement document. In that case, do you think MongoDB must have added
    and autogenerated a primary key field? Query the document and find out:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding output indicates that the `_id` of the original document is retained
    in the new document.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: This is because `_id` fields are immutable in MongoDB. Immutable fields are
    like normal fields; however, once assigned with a value, their value cannot be
    changed again. The `_id` field serves as a unique identifier of a document and
    so should not be changed as long as the document exists.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: It is similar to the user accounts you create on the various online portals,
    where your username is your unique identifier. You can change your password, or
    any other information in your profile, however, most portals won't allow you to
    change your username. Even if they allow you to modify your username, the old
    username cannot be assigned to anyone because there might be someone who still
    knows you by your old username.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'This was the theory of why the `_id` fields in MongoDB are immutable. However,
    try modifying the field and observe what happens:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, the replace command finds a document named `Margaery Baratheon`. In the
    replacement document, it also provides a new value for the `_id` field:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Error when _id is being modified'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_06.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.6: Error when _id is being modified'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you executed a replace command, as shown in the preceding snippet,
    where the replacement document now has an explicit `_id` field. The command failed
    with a very detailed error message. The preceding snapshot highlights the most
    important part of the error message, which indicates that the field is immutable.
    Hence, the update was rolled back, and no change happened to the record.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Upsert Using Replace
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, we learned that we can find an existing document in
    a collection and replace it with a new document. However, there will be times
    you want to replace an existing document with a new one and, if the document does
    not already exist, insert the new document. This operation is called an update
    (if found) or insert (if not found), which is further shortened to upsert. Upsert
    is a feature provided by many databases and MongoDB supports it as well.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Why Use Upsert?
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the simple scenarios that we have seen above, upsert sounds a bit unnecessary—especially
    when the same operation can be performed easily using two different commands.
    For example, we can first execute a replace command and check the results. The
    value of the matched count will tell whether the document is found in the collection.
    If the document is not found, we can then execute an `insert` command.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: However, in real-world scenarios, you will mostly be doing these operations
    in large numbers. Consider that your system receives daily updates from a user
    server, where the server sends you all the documents that were modified during
    the day. These daily updates might include records of the new users signed up
    with the server as well as changes to the existing users' profiles. On a large-scale
    system, performing a two-step update or insert operation for each of the records
    will be very time-consuming and error prone. However, having a dedicated command,
    you can simply prepare and execute an upsert command for each of the records you
    receive and let MongoDB do the update or insert.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实场景中，您大多数情况下会执行大量的这些操作。考虑到您的系统每天从用户服务器接收到更新，服务器会发送当天修改的所有文档。这些每日更新可能包括新用户在服务器上注册的记录，以及对现有用户配置文件的更改。在大规模系统上，为每条记录执行两步更新或插入操作将非常耗时且容易出错。然而，有了专门的命令，您可以简单地准备并执行每条记录的upsert命令，让MongoDB执行更新或插入。
- en: 'Consider the following records in the `users` collection:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`users`集合中的以下记录：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At the end of an episode, King Joffrey has been killed. As a result, `Margaery`
    wants to switch back to her old surname, and `Tommen Baratheon` becomes the new
    king. The update you receive from the user server contains the updated record
    for `Margaery` and the new record for `Tommen`, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在一集的结尾，乔佛里国王被杀害。因此，`Margaery`想要恢复她的旧姓，而`Tommen Baratheon`成为新国王。您从用户服务器接收到的更新包含了`Margaery`的更新记录和`Tommen`的新记录，如下所示：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the following commands, you pass an additional argument of `{upsert: true}`,
    which makes these commands upsert commands:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '在以下命令中，您传递了一个额外的参数`{upsert: true}`，这使这些命令成为upsert命令：'
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you execute the commands one after the other on a mongo shell, you see
    the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在mongo shell上依次执行这些命令时，您会看到以下输出：
- en: '![Figure 5.7: Output for the upsert operation'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7：upsert操作的输出'
- en: '](img/B15507_05_07.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_07.jpg)'
- en: 'Figure 5.7: Output for the upsert operation'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：upsert操作的输出
- en: The result of the first upsert indicates that there was a match found, and the
    document has been updated. However, the second one denotes the match was not found,
    and a new document was upserted with an autogenerated primary key.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个upsert的结果表明找到了匹配项，并且文档已被更新。然而，第二个表明未找到匹配项，并且使用自动生成的主键进行了新文档的upsert。
- en: Replacing Using findOneAndReplace()
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用findOneAndReplace()进行替换
- en: 'We have seen the `replaceOne()` function, which, after successful execution,
    returns the counts of matched and updated documents. MongoDB provides another
    operation, `findOneAndReplace()`, to perform the same operations. However, it
    provides more options. Its main features are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`replaceOne()`函数，成功执行后返回匹配和更新的文档计数。MongoDB提供了另一个操作`findOneAndReplace()`来执行相同的操作。但是，它提供了更多选项。其主要特点如下：
- en: As the name indicates, it finds one document and replaces it.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顾名思义，它找到一个文档并替换它。
- en: If more than one document is found matching the query, the first one will be replaced.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到多个与查询匹配的文档，第一个将被替换。
- en: A sort option can be used to influence which document gets replaced if more
    than one document is matched.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用排序选项来影响匹配多个文档时哪个文档被替换。
- en: By default, it returns the original document.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，它返回原始文档。
- en: 'If the option of `{returnNewDocument: true}` is set, the newly added document
    will be returned.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果设置了`{returnNewDocument: true}`选项，新添加的文档将被返回。'
- en: Field projection can be used to include only specific fields in the document
    returned in response.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段投影可用于在响应中只包含特定字段的文档。
- en: 'To see the `findOneAndReplace()` function in action, add five documents to
    a movie collection:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`findOneAndReplace()`函数的操作，请向电影集合添加五个文档：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, say that these five movies, all having the same `title`, were released
    and inserted in different calendar years. When these records were originally inserted,
    the field for the year of release wasn''t added. As a result, to find the latest
    movie with this `title`, you need to use the incremental `_id` field, where the
    movie with the largest `_id` value is the latest one. To make future find queries
    simpler, you have been instructed to find the document of the latest movie with
    this `title` and add a flag of `latest: true` to that document. So, when someone
    tries to find that movie, they can pass this additional filter to get the latest
    one in the response, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，假设这五部电影都具有相同的`title`，并且在不同的日历年份发布和插入。当这些记录最初插入时，发布年份的字段尚未添加。因此，要找到具有此`title`的最新电影，您需要使用递增的`_id`字段，其中具有最大`_id`值的电影是最新的。为了使未来的查找查询更简单，您已被指示找到具有此`title`的最新电影的文档，并向该文档添加`latest:
    true`标志。因此，当有人尝试查找该电影时，他们可以传递此附加过滤器以获取响应中的最新电影，如下所示：'
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the previous snippet, you found the document for a movie by its `title`
    and replaced it with another document that contains an additional field—that is,
    `latest : true`. Apart from that, the command used the option of `sort` so that
    the record with the largest value `_id` appears on top. The command also uses
    a projection option to include only the `title` field in the response. The output
    is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '在上面的片段中，您通过`title`找到了一部电影的文档，并用包含额外字段`latest: true`的另一个文档替换了它。除此��外，该命令使用了`sort`选项，以便具有最大值`_id`的记录出现在顶部。该命令还使用了投影选项，只在响应中包含`title`字段。输出如下：'
- en: '![Figure 5.8: Output for the findOneAndReplace command'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8：findOneAndReplace命令的输出'
- en: '](img/B15507_05_08.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_08.jpg)'
- en: 'Figure 5.8: Output for the findOneAndReplace command'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：findOneAndReplace命令的输出
- en: 'The preceding snapshot confirms that the operation is successful, and the `title`
    of the old document is included in the response. Alternatively, if you are required
    to get the updated document in the response, you can make use of the `returnNewDocument`
    flag in the command. Setting this flag to true will return the replaced document
    from the collection, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述快照确认了操作成功，并且旧文档的`title`包含在响应中。或者，如果需要在响应中获取更新后的文档，可以使用命令中的`returnNewDocument`标志。将此标志设置为true将从集合中返回替换后的文档，如下所示：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This replace command works similarly to the previous one, but the only difference
    is that it is using an additional option of `returnNewDocument`, which is set
    to `true`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个替换命令与之前的命令类似，唯一的区别是它使用了一个额外的`returnNewDocument`选项，该选项设置为`true`。
- en: '![Figure 5.9: Output after setting returnNewDocument to true'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9：设置returnNewDocument为true后的输出'
- en: '](img/B15507_05_09.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_09.jpg)'
- en: 'Figure 5.9: Output after setting returnNewDocument to true'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：设置returnNewDocument为true后的输出
- en: 'This output shows that having the `returnNewDocument` flag set to `true` returns
    the new document. Now, quickly query the database and see whether the replace
    command did actually work:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出显示，将`returnNewDocument`标志设置为`true`会返回新文档。现在，快速查询数据库，看看替换命令是否真的起作用：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The preceding output shows the latest record now has the desired flag.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示，最新的记录现在具有所需的标志。
- en: Replace versus Delete and Re-Insert
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换与删除和重新插入
- en: As we have seen in the previous sections, there are dedicated functions to find
    and replace documents in a collection. It is possible to replace a document using
    a combination of delete and insert, where you delete an existing document and
    insert a new one. This two-step operation of the delete and `insert` combination
    gives you the same results; let's see how.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的部分中所看到的，有专门的函数来查找和替换集合中的文档。可以使用删除和插入的组合来替换文档，其中您删除一个现有文档并插入一个新文档。删除和`insert`组合的这两步操作会给您相同的结果；让我们看看如何操作。
- en: To perform the two-step, replace operation using delete and `insert`, use the
    same example that you saw in the `findOneAndReplace()` section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用删除和`insert`进行两步替换操作，请使用在`findOneAndReplace()`部分中看到的相同示例。
- en: 'First, delete all the previously inserted or modified documents from the collection:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从集合中删除所有先前插入或修改的文档：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, insert the five documents again:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次插入这五个文档：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, find the document of the latest movie titled `Macbeth` and add the flag
    `"latest" : true` to it:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，找到标题为`Macbeth`的最新电影的文档，并为其添加标志`"latest" : true`：'
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This snippet shows two different commands. The first is a `findOneAndDelete()`
    command that finds a movie by its `title` and also uses the sort option so that
    only the movie with largest `_id` gets deleted. The result of the deletion operation,
    which is the deleted document, is stored in a variable of `deletedDocument`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段显示了两个不同的命令。第一个是`findOneAndDelete()`命令，它通过`title`找到一部电影，并使用排序选项，以便只删除具有最大`_id`的电影。删除操作的结果，即已删除的文档，存储在`deletedDocument`的变量中。
- en: 'The next command in the preceding snippet is an insert operation that re-inserts
    the same movie along with the flag `latest : true`. While doing so, it uses the
    `_id` value from the deleted document, so that the new record is inserted with
    the same primary key:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '上述片段中的下一个命令是一个插入操作，它重新插入了相同的电影，并使用了`latest : true`标志。在这样做的同时，它使用了已删除文档的`_id`值，以便新记录使用相同的主键进行插入：'
- en: '![Figure 5.10: Output for delete first and then insert'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.10：删除后插入的输出'
- en: '](img/B15507_05_10.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_10.jpg)'
- en: 'Figure 5.10: Output for delete first and then insert'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10：删除后插入的输出
- en: 'The preceding output indicates that you have executed both commands sequentially,
    and the response shows that one document was inserted successfully, which can
    be verified using the `find` operation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出表明您已经按顺序执行了两个命令，响应显示成功插入了一个文档，可以使用`find`操作进行验证：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The result of a `find` operation on the collection confirms that the two-step
    replacement operation worked perfectly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对集合进行`find`操作的结果确认了两步替换操作完美地起作用。
- en: Although the results are exactly the same, the two-step operation is more error
    prone. The two-step operation executes two totally different commands, one after
    the other. In the first command, your MongoDB client or your programming language's
    driver sends the `delete` command to the server. The server then validates and
    processes the command to remove the document. Then the deleted document is sent
    back to the client over the network. The client or driver then parses the returned
    result into the language-specific object. In our case, we are executing commands
    from a mongo shell, and so the results are parsed into the JSON format and stored
    in the variable `deleteDocument`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管结果完全相同，两步操作更容易出错。两步操作执行两个完全不同的命令，一个接着一个。在第一个命令中，您的MongoDB客户端或编程语言的驱动程序将`delete`命令发送到服务器。然后服务器验证和处理命令以删除文档。然后已删除的文档通过网络发送回客户端。客户端或驱动程序然后将返回的结果解析为特定于语言的对象。在我们的情况下，我们正在从mongo
    shell执行命令，因此结果被解析为JSON格式并存储在变量`deleteDocument`中。
- en: Next, your MongoDB client or the driver sends another command to insert the
    new document. The new document, which is in JSON format in our case, gets transformed
    into BSON and sent over the wire to the server. For the MongoDB server, this `insert`
    command is like any other fresh `insert` commands. The server performs the initial
    validation of the document, checks whether the `_id` field is present, and also
    validates the uniqueness of the value in the collection. If the document is found
    to be valid, the insert will happen.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您的MongoDB客户端或驱动程序发送另一个命令来插入新文档。新文档，在我们的情况下是JSON格式，被转换为BSON并通过网络发送到服务器。对于MongoDB服务器，这个`insert`命令就像任何其他新的`insert`命令一样。服务器对文档进行初始验证，检查`_id`字段是否存在，并验证集合中值的唯一性。如果文档被发现有效，插入将会发生。
- en: 'Now that you are familiar with the details of the two-step replace operation,
    consider the following potential shortfalls of using it over dedicated replace
    functions:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了两步替换操作的细节，请考虑在使用它时可能存在的以下潜在缺陷：
- en: First of all, in the delete and insert method, the data is transferred over
    the wire multiple times. This involves the drivers or clients to parse the data
    in multiple stages. This will slow down the overall performance.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在删除和插入方法中，数据会多次通过网络传输。这需要驱动程序或客户端在多个阶段解析数据。这将减慢整体性能。
- en: When multiple clients are constantly reading and writing to your collections,
    concurrency issues may arise. As an example, say you have successfully deleted
    a record and before you insert the new record, some other client accidentally
    inserts a different record with the same `_id`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当多个客户端不断读取和写入您的集合时，可能会出现并发问题。例如，假设您已成功删除了一条记录，在插入新记录之前，某个其他客户端意外地插入了一个具有相同`_id`的不同记录。
- en: Your database client or driver may lose its connection to the database in the
    middle of two operations. For example, the delete operation was successful but
    insertion could not happen. To avoid such issues, you will have to run your commands
    in a transaction so that the failure of one operation can revert the previously
    successful operations in the same transaction.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的数据库客户端或驱动程序可能在两个操作之间失去与数据库的连接。例如，删除操作成功，但插入无法进行。为了避免这种问题，您将不得不在事务中运行您的命令，以便一个操作的失败可以撤销同一事务中先前成功的操作。
- en: The dedicated replace functions, on the other hand, are effectively atomic and
    are therefore safe to use in concurrent environments. An atomic operation is the
    smallest unit of operation that cannot be divided further. For this reason, when
    an atomic operation is performed, it is executed in one go as a single unit. Thus,
    dedicated replace functions are safer as compared to the delete and insert combination.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，专用替换函数实际上是原子的，因此在并发环境中使用是安全的。原子操作是不能进一步分割的最小操作单位。因此，当执行原子操作时，它将作为单个单元一次性执行。因此，与删除和插入组合相比，专用替换函数更安全。
- en: The dedicated functions first find a document to be replaced and lock it. The
    lock is then released only after the operation is finished. Because of this, no
    other client or process is able to modify that particular document while it is
    locked. Also, the replace operation replaces only the rest of the fields in the
    documents, keeping `_id` untouched. There is no chance that other processes will
    be able to push a different document with the same `_id` value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 专用函数首先找到要替换的文档并锁定它。锁定只有在操作完成后才会释放。因此，在锁定文档时，没有其他客户端或进程能够修改该特定文档。此外，替换操作仅替换文档中其余的字段，保持`_id`不变。其他进程不可能能够推送具有相同`_id`值的不同文档。
- en: Thus, it is always preferable to use the specialty functions provided by MongoDB.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好始终使用MongoDB提供的专用函数。
- en: Modify Fields
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改字段
- en: In the previous sections, we learned that we could replace any document in a
    MongoDB collection once it has been inserted. During the replace operation, a
    document in the database will be replaced with a completely new document while
    keeping the same primary key. The replacement operations are quite useful when
    it comes to rectifying errors and to incorporating data changes or updates. However,
    in most cases, updates will affect only one or a few fields of a document. Think
    about any movie record from the `sample_mflix` dataset, where most of its fields
    (such as the title, cast, directors, duration, and so on) may never change. However,
    over a period of time, the movie may receive new comments, new reviews, and ratings.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们学到了一旦插入，就可以替换MongoDB集合中的任何文档。在替换操作期间，数据库中的文档将被完全新的文档替换，同时保留相同的主键。替换操作在纠正错误和合并数据更改或更新时非常有用。然而，在大多数情况下，更新只会影响文档的一个或几个字段。想象一下`sample_mflix`数据集中的任何电影记录，其中大多数字段（如标题、演员、导演、时长等）可能永远不会改变。然而，随着时间的推移，电影可能会收到新的评论、新的评价和评分。
- en: The find and replace operation is very useful when all or most fields of a document
    are modified. But, using it to update only particular fields in the documents
    will not be easy. To do so, the replacement document you provide will need to
    have all the unchanged fields with their existing values and the changed fields
    with their new values. For a smaller document, this doesn't sound like a problem,
    but for large documents, like our movie records, the command will be bulky and
    error prone. We will see this with an example of a command that we will not execute
    on the database.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 查找和替换操作在所有或大多数文档字段被修改时非常有用。但是，使用它来更新文档中的特定字段将不容易。为此，您提供的替换文档将需要具有所有未更改字段及其现有值以及更改字段及其新值。对于较小的文档，这听起来不像是问题，但对于大型文档，比如我们的电影记录，命令将变得臃肿且容易出错。我们将通过一个我们不会在数据库上执行的命令的示例来看到这一点。
- en: 'Say a record of a movie was added to the database, but the value of the field
    `year` is incorrect. The following is an example of how the command will look
    if the replace operation is used to correct the value. In the first statement,
    we find the movie document and assign it to a variable. Next is the actual replace
    command where the replacement document with all of its fields needs to be provided.
    We use the variable `movie` that we assigned in the first line and refer to all
    of its unchanged fields. The last field in the replacement document is the field
    of `year` with the new value:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数据库中添加了一部电影的记录，但字段`year`的值不正确。以下是使用替换操作来更正该值的命令的示例。在第一条语句中，我们找到电影文档并将其分配给一个变量。接下来是实际的替换命令，其中需要提供具有所有字段的替换文档。我们使用在第一行中分配的变量`movie`，并引用其所有未更改的字段。替换文档中的最后一个字段是`year`字段，其具有新值：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The problem with the command is that it is too bulky, especially since we only
    want to update a single field. It re-enters all the fields, even if they are not
    changed, and there is a good possibility of a typo being introduced when we are
    re-assigning the unchanged field values. Moreover, this is a two-step operation
    and introduces concurrency problems that are hard to debug.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的问题在于它太庞大了，特别是因为我们只想要更新一个字段。它重新输入了所有字段，即使它们没有改变，而且在重新分配未更改的字段值时很可能会引入拼写错误。此外，这是一个两步操作，引入了难以调试的并发问题。
- en: To understand the concurrency problem, imagine that the find operation in the
    first statement is successful, and the next statement is a replace command that
    refers to all the unchanged fields from the existing documents; but before the
    second statement is executed, the actual document in the database was modified
    by some other client or thread. Once your statement is executed, the updates added
    by the other client will be lost forever.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解并发问题，想象一下第一条语句中的查找操作成功，下一条语句是一个替换命令，引用了现有文档中所有未更改的字段；但在第二条语句执行之前，数据库中的实际文档被其他客户端或线程修改了。一旦您的语句执行，其他客户端添加的更新将永远丢失。
- en: This is why the replace operation should only be used when all or most of the
    fields are being modified. To modify one or only a few fields of a document, MongoDB
    provides the `update` command. Let's explore this in the next section.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么替换操作应该仅在修改所有或大部分字段时使用。要修改文档的一个或只有几个字段，MongoDB提供了`update`命令。让我们在下一节中探讨这个问题。
- en: Updating a Document with updateOne()
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`updateOne()`更新文档
- en: 'To update the fields of a single document in a collection, we can use the function
    `updateOne()`. This function, which is provided by MongoDB collections, accepts
    a query condition to find the record to be updated, and a document that specifies
    the field-level update expressions. The third argument to the function is to provide
    miscellaneous options and is optional. The syntax of this function looks like
    this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新集合中单个文档的字段，我们可以使用`updateOne()`函数。这个函数由MongoDB集合提供，接受一个查询条件来找到要更新的记录，以及一个指定字段级更新表达式的文档。函数的第三个参数是提供杂项选项的，是可选的。这个函数的语法如下：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Like the replace commands, `updateOne()` cannot be used to update the `_id`
    field of a document because it is immutable. Once the update is performed, it
    returns a detailed result in the form of a document, which indicates how many
    records were matched and how many records were updated.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与替换命令一样，`updateOne()`不能用于更新文档的`_id`字段，因为它是不可变的。更新执行后，它以文档的形式返回详细结果，指示匹配了多少条记录以及更新了多少条记录。
- en: 'Before using this function, first delete all the previously inserted and modified
    records from the collection:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此功能之前，首先从集合中删除所有先前插入和修改的记录：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, use the following `insert` command to add four new records to the collection:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下`insert`命令向集合添加四条新记录：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Write and execute your first update command to change the field `year` for
    the movie `Macbeth`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 编写并执行第一个更新命令以更改电影`Macbeth`的`year`字段：
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding command, the first argument to the `updateOne()` function is
    the query condition, wherein you specify that the name of the movie should be
    `Macbeth`. The second argument is a document that specifies a new field of `year`
    and its value. Here, we are using a new operator, `$set`, to assign values to
    the fields provided in a document. In the upcoming sections, we will learn more
    about the `$set` operator and also a few other operators that are supported by
    all the update functions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，`updateOne()`函数的第一个参数是查询条件，其中您指定电影的名称应为`Macbeth`。第二个参数是一个指定`year`字段及其值的文档。在这里，我们使用了一个新的运算符`$set`，来为文档中提供的字段赋值。在接下来的章节中，我们将学习更多关于`$set`运算符以及所有更新函数支持的其他运算符。
- en: 'When the command is executed on a mongo shell, the output looks like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当在mongo shell上执行该命令时，输出如下：
- en: '[PRE54]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output is a document that denotes the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个表示以下内容的文档：
- en: '`"acknowledged" : true` indicates that the update was performed and confirmed.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"acknowledged" : true` 表示更新已执行并已确认。'
- en: '`"matchedCount" : 1` shows the number of documents found and chosen for the
    update (1 in this case.)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"matchedCount" : 1` 显示找到并选择进行更新的文档数量（在这种情况下为1）。'
- en: '`"modifiedCount" : 1` refers to the number of documents modified (1 in this
    case.)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"modifiedCount" : 1` 指的是修改的文档数量（在这种情况下为1）。'
- en: 'The following query and the output that follows confirm that the update command
    was executed correctly:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询和随后的输出确认了更新命令的正确执行：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the preceding record, the field `year` is correctly set to `2015`, which
    was previously `2014`. If we execute the same command again, no update will be
    performed as the value is already `2015`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述记录中，字段`year`正确设置为`2015`，之前是`2014`。如果我们再次执行相同的命令，由于值已经是`2015`，不会执行更新：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Figure 5.12* shows the output of executing the same update command again.
    The resulting document indicates that there was one document that was matched
    as eligible for the update; however, no document was updated.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.12*显示了再次执行相同更新命令的输出。结果文档表明有一个文档符合更新的条件，但是没有文档被更新。'
- en: Modifying More Than One Field
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改多个字段
- en: 'The `$set` operator that we used to update a field of a document can also be
    used to modify multiple fields of a document. As seen in the previous examples,
    `$set` is provided with a document that contains the update expression. Similarly,
    to modify more than one field, the update expression can contain more than one
    field and value pair. For example, consider this snippet:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来更新文档字段的`$set`运算符也可以用来修改文档的多个字段。如前面的例子所示，`$set`后面跟着包含更新表达式的文档。同样，要修改多个字段，更新表达式可以包含多个字段和值对。例如，考虑以下代码片段：
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding operation, the update expression `{"type": "movie", "num_mflix_comments":
    1}}` specifies two fields and their values. Out of these, the `num_mflix_comment`
    field does not exist in the respective movie. Execute the command on our movie
    collection and see the output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding figure shows that the operation was successful, and one record
    is modified as expected. Now, query the document and see if the fields are modified correctly:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The document from the collection indicates that the movie type has been modified
    correctly, and a new field named `num_mflix_comments` has been added with the
    given value. Thus, you have seen that `$set` can be used to update multiple fields
    in the same command, and if a field is new, it will be added to the document with
    the specified value.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the next section, it is important to know that, in an
    update operation, updating the same field multiple times is valid, irrespective
    of the field''s value. As seen in the previous output, the `year` field of the
    movie `Macbeth` is set to 2015\. Modify the same field multiple times in the same
    command:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding update command, which uses the `$set` operator, sets the year
    multiple times. The first two expressions set the field to its current value;
    however, the last two expressions have different values. Execute the command and
    observe the behavior:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As expected, the operation is valid, and one document is modified. Query the
    document from the collection and see the value of the `year` field:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding output, we prove that, when the same field is provided multiple
    times, the update happens from left to right. First, the `year` field (which was
    already 2015) is set to 2015 twice; then with the third expression, the year is
    set to 2016; and lastly, with the rightmost expression, it is set to 2017.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: In any valid scenario, you will hardly ever update a field twice in an update
    operation. However, even if you do so, perhaps accidentally, you now know the
    behavior, and this will help you in debugging.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Documents Matching a Condition
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name of the `updateOne()` function indicates, it always updates only
    one document in the collection. If the given query condition matches more than
    one document, only the first document will be modified:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The preceding operation finds documents where `type` is `movie` and sets the
    value of `flag` as `modified`. Remember, we have a total of three documents of
    type `movie` in our movie collection. When the command is executed on our collection,
    the result will look like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The result of the execution indicates that one document was matched and chosen
    for the update, and one document was actually modified. Thus, it proves that even
    if there is more than one document that matches the given query condition, only
    one document is chosen and updated.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Upsert with updateOne()
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we learned in detail about the upsert operation. When
    upsert-based updates are executed, the document will be updated if it is found;
    however, if the document is not found, a new document is created inside the collection.
    Similar to the replace operations, `updateOne()` also supports upserts with an
    additional flag in the command. Consider the following snippet:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The preceding operation executes an update command on the movie `Sicario`,
    which does not exist in our collection. When the command is executed without any
    `upsert` flag, no update is performed:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output indicates that no document was matched, and no document was updated.
    Now, we will execute the same command with an `upsert` flag:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The preceding operation uses a third argument, which contains a document with
    the `upsert` flag set to `true`, which is false by default. The output can be
    seen here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Update a non-existing movie with the upsert flag'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_11.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.11: Update a non-existing movie with the upsert flag'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the output of executing the command is slightly different this time. It
    indicates that no document was matched, and no document was updated. However,
    `"upsertedId" : ObjectId("5e…")` indicates that one document was inserted with
    an autogenerated primary key.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，执行命令的输出这次略有不同。它指示没有匹配的文档，也没有更新的文档。然而，`"upsertedId" : ObjectId("5e…")`表明插入了一个带有自动生成的主键的文档。'
- en: 'The following query finds the document using the autogenerated primary key.
    When you execute this query on your shell, you will have to use the `ObjectId`
    that was generated in the previous command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询使用自动生成的主键找到文档。当您在shell上执行此查询时，您将需要使用在上一个命令中生成的`ObjectId`：
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When we query the collection with the newly created primary key value, we get
    the newly inserted record.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用新创建的主键值查询集合时，我们得到了新插入的记录。
- en: One thing to notice here is that the new document has two fields, out of which
    the field `year` was part of the update expression; however, `title` was part
    of the query condition. When MongoDB creates a new document as part of an `upsert`
    operation, it combines fields from the update expressions as well as query conditions.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，新文档有两个字段，其中字段`year`是更新表达式的一部分；然而，`title`是查询条件的一部分。当MongoDB创建新文档作为`upsert`操作的一部分时，它会合并更新表达式和查询条件中的字段。
- en: Updating a Document with findOneAndUpdate()
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用findOneAndUpdate()更新文档
- en: 'We have seen the function `updateOne()`, which modifies one document from a
    collection. MongoDB also provides the `findOneAndUpdate()` function, which is
    capable of doing everything that `updateOne()` does with a few additional features,
    which we''ll explore now. The syntax of this function is the same as `updateOne()`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`updateOne()`函数，它修改了集合中的一个文档。MongoDB还提供了`findOneAndUpdate()`函数，它能够做到`updateOne()`所做的一切，并且还有一些额外的功能，我们现在将探讨。这个函数的语法与`updateOne()`相同：
- en: '[PRE69]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`findOneAndUpdate()` needs at least two arguments where the first one is a
    query condition to find the document to be modified and the second one is the
    update expression. By default, it returns the old document in the response. In
    some scenarios, getting back the old document is really useful, especially when
    it needs to be archived somewhere. However, by passing a flag as an argument,
    the behavior of the function can be changed to return the new document in the
    response. Consider the following example.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOneAndUpdate()`至少需要两个参数，第一个是用于找到要修改的文档的查询条件，第二个是更新表达式。默认情况下，它在响应中返回旧文档。在某些情况下，获取旧文档真的很有用，特别是当需要将其存档时。然而，通过传递一个标志作为参数，函数的行为可以更改为在响应中返回新文档。考虑以下示例。'
- en: 'The record for the movie `Macbeth` in our collection has only one comment,
    given by the field `num_mflix_comments`. Modify the count of these comments using
    the update command as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们集合中电影`Macbeth`的记录只有一个评论，由字段`num_mflix_comments`给出。使用以下更新命令修改这些评论的计数：
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The preceding command finds a movie by its `title` and sets `num_mflix_comments`
    to the value of 10\. We can see that it looks pretty similar to the `updateOne()`
    commands, and the effects on the collection will be exactly the same. However,
    the only difference we will see here is the response, as can be seen in the following
    figure:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令通过`title`找到电影，并将`num_mflix_comments`设置为10的值。我们可以看到它看起来与`updateOne()`命令非常相似，对集合的影响也完全相同。然而，我们在这里看到的唯一区别是响应，如下图所示：
- en: '![Figure 5.12: Update using fineOneAndUpdate()'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.12：使用fineOneAndUpdate()进行更新'
- en: '](img/B15507_05_12.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_12.jpg)'
- en: 'Figure 5.12: Update using fineOneAndUpdate()'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：使用fineOneAndUpdate()进行更新
- en: 'The output shows that the `findOneAndUpdate()` function did not return the
    query stats, such as how many records were matched and how many records were modified.
    Instead, it returns the document in its old state. Now query and verify whether
    the update was successful:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示`findOneAndUpdate()`函数没有返回查询统计信息，比如匹配了多少记录，修改了多少记录。相反，它返回了文档的旧状态。现在查询并验证更新是否成功：
- en: '[PRE71]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The query and its output here confirm that the number of comments is modified
    to its new value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的查询及其输出确认了评论数量已经修改为新值。
- en: Returning a New Document in Response
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回响应中的新文档
- en: 'So far, we have used the function with two arguments where the first is the
    query condition and the second is the update expression. However, the function
    also supports an optional third argument, which is used to provide miscellaneous
    options to the commands. Out of these options, the `returnNewDocument` can be
    used to control which document should be returned in the response. By default,
    the value of this flag is set to false, which is why we get the old document without
    passing the options. However, setting this flag to true, we get back the modified
    or new document in the response. For example, consider the following snippet:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了两个参数的函数，第一个是查询条件，第二个是更新表达式。然而，该函数还支持一个可选的第三个参数，用于向命令提供杂项选项。在这些选项中，`returnNewDocument`可以用于控制响应中应返回哪个文档。默认情况下，此标志的值设置为false，因此我们在不传递选项的情况下得到了旧文档。然而，将此标志设置为true，我们将在响应中得到修改后的或新文档。例如，考虑以下代码片段：
- en: '[PRE72]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The preceding operation sets the comments count to 15 and also passes the flag
    of `returnNewDocument` set to true. The output can be seen as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作将评论计数设置为15，并将`returnNewDocument`标志设置为true。输出如下所示：
- en: '![Figure 5.13: findOneAndUpdate() with the returnNewDocument flag'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.13：带有returnNewDocument标志的findOneAndUpdate()'
- en: '](img/B15507_05_13.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_13.jpg)'
- en: 'Figure 5.13: findOneAndUpdate() with the returnNewDocument flag'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：带有returnNewDocument标志的findOneAndUpdate()
- en: The output shows that by setting the flag `returnNewDocument` to `true`, the
    response shows the modified document, which also confirms that the count of comments
    has been modified correctly.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，通过将标志`returnNewDocument`设置为`true`，响应显示了修改后的文档，这也确认了评论数量已经正确修改。
- en: 'With the optional third argument to the function, we can also provide an expression
    to limit the number of fields returned in the documents (also called a projection
    expression). The projection expression can be used for both cases—that is, returning
    an old or new document as a response:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The preceding update command finds the movie by `title` and sets the count
    of comments to 20\. As the third argument, it passes two options to the command.
    The first option is the projection expression, which includes only `num_mflix_comments`
    in the response and excludes the `_id` explicitly. By using the second operation,
    the function will return the modified document. The output can be seen here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: findOneAndUpdate() with projection'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_14.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.14: findOneAndUpdate() with projection'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the projection expression has excluded the `_id` and included
    only the `num_mflix_comments` field, as expected.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Sorting to Find a Document
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have covered two update functions, and both are capable of updating
    a single document at a time. If more than one document is matched by the given
    query condition, the first document will be chosen for modification. This behavior
    is common between both functions. However, the `findOneAndUpdate()` function provides
    an additional option to sort the matching documents in a specific order. Using
    the sort option, you can influence which document is selected for the modification.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The sort option is specified as a field under the optional third argument of
    the `findOneAndUpdate()` function. The value of the sort field must be a document
    containing valid sort expressions. We will now see an example of using the sort
    option in an update command.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.15* shows that our collection has four records, which are of the
    movie type. Each one has a sequential `_id` field where the record inserted latest
    has the largest value in the sequence:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: A collection having four records'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_15.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.15: A collection having four records'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a command that will use the same filter of `{"type" : "movie"}` and put
    the flag `"latest" : true` to the last inserted record:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The update command in the preceding snippet sets the `latest` flag to true.
    The query condition finds a document with a `type` of `movie`. The options argument
    sets a flag to return the modified document in the response and also specifies
    a sort expression to sort documents by descending order of the primary key:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: Update one record by sorting matched documents'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_16.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.16: Update one record by sorting matched documents'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'The response to the update command, as shown in *Figure 5.16*, indicates that
    the record with `_id : 4` has the latest flag. This is due to the specified sort
    option, which ordered the matching records so that the largest IDs will appear
    first. The function picked up the first record and modified it.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.03: Updating the IMDb and Tomatometer Rating'
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your movie database has records of a large number of worldwide movies along
    with their details. Your product owners want you to keep the database updated
    with the most recent changes. People still love to watch some of the timeless
    classic movies and rate them or post their reviews, so the ratings of some of
    the popular movies, which were released a few decades ago, keep changing on a
    daily basis. Your organization has decided to incorporate rating updates for all
    movies irrespective of their release date. As a proof of concept, they have chosen
    *The Godfather*, one of the all-time great movies, and asked you to update it
    with the latest IMDb and Tomatometer ratings. If your product team is happy with
    the update, they will sign off on receiving regular updates from these platforms.
    Your task is to write and execute an update operation to update these ratings.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the latest IMDb and Tomatometer viewer ratings of the movie:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '**IMDb rating**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Rating: 9.2 and Votes: 1,565,120'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**Tomatometer viewer rating**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Rating: 4.76, number of reviews: 733, 777, meter 98'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the database to find the current values of these ratings:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This query finds and prints the IMDb and Tomatometer viewer rating of the movie
    `The Godfather`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17: Ratings of the movie The Godfather'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_17.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.17: Ratings of the movie The Godfather'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: The output shows the current ratings from the `sample_mflix` database.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'Open any text editor and write a `findOneAndUpdate()` command along with a
    query parameter:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, use the `$set` operator to set the IMDb fields. As the IMDb rating is
    still the same, you will only update the field `votes` field. To refer to the
    nested field of `votes`, use the dot notation:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, add another update expression for Tomatometer ratings. For the Tomatometer
    viewer rating, you only need to update the fields of `rating` and `numReviews`.
    As these are two separate fields, add two separate update expressions to the `$set`
    operator. As these fields are nested within a nested object, use dot notation
    two times:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now that your update query is complete, add the flag to return the modified
    document in response along with projection on specific fields:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Open the mongo shell and connect to the Atlas `sample_mflix` database. Copy
    the previous command and execute it:![Figure 5.18: Updated ratings'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_05_18.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.18: Updated ratings'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The previous output shows that the respective fields have been updated correctly.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have practiced using `findOneAndUpdate()` and `$set` to
    update the values of nested fields. Next, we will learn to update multiple documents
    using `updateMany()`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Updating Multiple Documents with updateMany()
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous sections, we learned to find one document and modify or update
    its fields. Many times though, you will want to perform the same update operation
    on multiple documents in a collection. MongoDB provides the `updateMany()` function,
    which updates multiple documents at a time. Similar to `updateOne()`, the `updateMany()`
    function takes two mandatory arguments. The first argument is the query condition,
    and the second is the update expression. The third argument, which is optional,
    is used to provide miscellaneous options. Upon execution, this function updates
    all the documents that match the given query condition. The syntax of the function
    looks like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We will write and execute an update operation on our movie collection. Consider
    that our movie collection has four movies that were released in 2015\. Add a field
    named `languages` to these movies, as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This update operation uses two arguments. The first is to find all the movies
    that were released in 2015\. The second argument is an update expression, which
    uses the `$set` operator, to add a new field named `languages`. The value of the
    `languages` field is an array containing English as the only language. The output
    can be seen here:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The output indicates that the operation was successful, and, like the `updateOne()`
    function, a similar document is returned in the response. The response indicates
    that the query condition matched a total of four documents, and all were modified.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we learned about modifying fields of one or more documents
    in MongoDB collections. We have covered three update functions, out of which `updateOne()`
    and `findOneAndUpdate()` are used to update one document in a collection while
    `updateMany()` is used to update multiple documents in a collection. The following
    are a few important points about the update operations and are applicable to all
    three functions:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: None of the update functions allows you to change the `_id` field.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the fields in a document is always maintained, except when the
    update includes renaming a field. However, the `_id` field will always appear
    first. (We will cover renaming fields in the next section).
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update operations are atomic on a single document. A document cannot be modified
    until another process has finished updating it.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the update functions support upsert. To execute an upsert command, `upsert
    : true` needs to be passed as an option.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will cover various update operators and their usages.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Update Operators
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to facilitate different types of update commands, MongoDB provides
    various update operators or update modifiers such as set, multiply, increment,
    and more. In the previous sections, we used the operator `$set`, which is one
    of the update operators provided by MongoDB. In this section, we will learn some
    of the most commonly used operators and examples. Before we go through the operators,
    we will discuss their syntax. The following code snippet shows the basic syntax
    of an update expression that uses an update operator:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As per the preceding syntax, an operator can be assigned a document containing
    one or more pairs of field and value. The operator is then applied to each field
    using the respective value. An update expression like the previous one is useful
    when all the given fields need to be updated with the same operator. You may also
    want to update different fields of a document using different operators. For such
    cases, an update expression can contain multiple update operators, each separated
    by a comma.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The preceding snippet shows the syntax for using multiple operators in the same
    update expression. In an update operation, each of these operators will be executed
    in sequence.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through each of the update operators in detail now.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Set ($set)
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already seen, the `$set` operator is used to set the values of fields
    in a document. It is the most commonly used operator, as it can be easily used
    to set values of any type of field or add new fields in a document. The operator
    takes a document that contains pairs of field names and their new values. If the
    given field is not already present, it will be created.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Increment ($inc)
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The increment operator `($inc`) is used to increment the value of a numeric
    field by a specific number. The operator accepts a document containing pairs of
    a field name and a number. Given a positive number, the value of the field will
    be incremented and if a negative number is provided, the value will be decremented.
    It is obvious but worth mentioning that the `$inc` operator can only be used with
    numeric fields; if attempted for non-numeric fields, the operation fails with
    an error.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, in our collection, the document for a `Macbeth` movie looks as shown
    here:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, write an update using the `$inc` operator on two fields, out of which
    one exists in the document and the other does not:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The preceding update operation finds a movie by its `title`, increments the
    `num_mflix_comments` field by 3 and a non-existent field called `rating` by `1.5`.
    It also sets `returnNewDocument` to `true`, so that the updated record will be
    returned in the response. You can see the output in the following screenshot:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19: Incrementing the number of comments and the rating score'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_19.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.19: Incrementing the number of comments and the rating score'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the update command was successful. The field of `num_mflix_comments` is
    correctly incremented by 3 and `rating` (which was a nonexistent field) is now
    added to the document with a specified value. We will see an example of decrementing
    the field values:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The preceding command uses the `$inc` operator on two fields and provides negative numbers:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: Decrementing the number of comments and rating score'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_20.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.20: Decrementing the number of comments and rating score'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 5.20*, the negative increments lead to the response. The
    `rating`, which was 1.5, is now reduced by 0.2 and `num_mflix_comments` is reduced
    to 21.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Multiply ($mul)
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The multiplication `($mul`) operator is used to multiply the value of a numeric
    field by the given number. The operator accepts a document containing pairs of
    field names and numbers and can only be used on numeric fields. For example, consider
    the following snippet:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The preceding update operation finds a movie by its `title`, uses `$mul` to
    multiply the value of the field of `rating` by 2, and adds an option to return
    the modified document in the response. You can see this as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: Doubling the rating score'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_21.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.21: Doubling the rating score'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shows the value of the field `rating` is multiplied by 2\. When
    using a non-existent field with `$mul`, we should always remember that no matter
    what multiplier we provide, the field will be created and always set to zero.
    This is because, with a multiplication operation, the value of a nonexistent numeric
    field is assumed to be zero. Thus, using any multiplier on zero results in zero:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This update operation multiplies a nonexistent field `box_office_collection`
    by a given value:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22: Multiplying the value of a non-existing field'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_22.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.22: Multiplying the value of a non-existing field'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The output in *Figure 5.22* proves that irrespective of the provided value,
    the nonexistent field of `box_office_collection` has been added with a value of zero.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Rename ($rename)
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As suggested by the name, the `$rename` operator is used to rename fields. The
    operator accepts a document containing pairs of field names and their new names.
    If the field is not already present in the document, the operator ignores it and
    does nothing. The provided field and its new name must be different. If they're
    the same, the operation fails with an error. If a document already contains a
    field with the provided new name, the existing field will be removed.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'To try various scenarios of the `$rename` operator, first, insert a field named
    `imdb_rating` for `Macbeth`. The following update operation sets the new field
    and the output shows that the field is correctly added:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, rename the field `num_mflix_comments` to `comments` and rename the field
    `imdb_rating` to `rating`, as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The update operation uses the `$rename` operator and passes a document containing
    two pairs of field names and new names. Note that the second field name and new
    name combination is trying to rename the field of `imdb_rating` to `rating`; however,
    the record already has a field with the name of `rating`. The output can be seen
    as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: Renaming fields'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_23.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.23: Renaming fields'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shows that the rename operation was successful. As stated above,
    the original field of `rating` is removed and the `imdb_rating` field is now renamed
    to `rating`. Using this operator, a field can also be moved to and from nested
    documents. To do so, you have to use a dot notation, like this:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here, the update operation is renaming the `rating` field. However, the new
    name contains a dot notation:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: Renaming nested fields'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_24.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.24: Renaming nested fields'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Because of the dot notation, the field `rating` has been moved under the nested
    document `imdb`. Similarly, a field can be moved from a nested document to the
    root or to any other nested document.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Current Date ($currentDate)
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operator `$currentDate` is used to set the value of a given field as the
    current date or timestamp. If the field is not present already, it will be created
    with the current date or timestamp value. Providing a field name with a value
    of `true` will insert the current date as a `Date`. Alternatively, a `$type` operator
    can be used to explicitly specify the value as a `date` or `timestamp`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The preceding `findOneAndUpdate` operation sets three fields using the `$currentDate`
    operator. The field `created_date` has a value of true, which defaults to a `Date`
    type. The other two fields use a dot notation and explicit `$type` declaration.
    The output can be seen in the following figure:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25: Setting the current date and timestamp'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_25.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.25: Setting the current date and timestamp'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the field `created_date` has a value of the `Date` type. A new
    field, `last_updated`, has been added and has a nested document. Under the nested
    document, another field has been initialized as a `Date` type and the other as `Timestamp`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Removing Fields ($unset)
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `$unset` operator removes given fields from a document. The operator accepts
    a document containing pairs of field names and values and removes all the given
    fields from the matched document. As the provided fields are being removed, their
    specified values have no impact. For instance, consider the following snippet:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Execute an update operation using the `$unset` operator to remove unwanted
    fields:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The preceding update operation removes four fields from the document. As stated
    previously, it doesn''t matter whether and what value is provided to the field
    while it is being removed. Here, you are trying to remove multiple fields and
    providing them with different values, and you will observe that their values have
    no impact. The first field, `created_date`, is provided with a value of an empty
    string. The next two fields have some dummy values, and the field `imdb` has a
    null value. The last field, `flag`, is also provided with an empty string. Out
    of these five fields, `imdb` and `last_updated` are nested fields. You will now
    execute the operation and observe the output, as follows:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26: Removing multiple fields'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_26.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.26: Removing multiple fields'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: The output indicates that all five fields are correctly removed from the document.
    The operation and the response prove that the values specified for the fields
    have no impact on field removal. Also, specifying a field with a value of a nested
    object removes the respective object and contained fields.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Setting When Inserted ($setOnInsert)
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operator `$setOnInsert` is similar to `$set`; however, it only sets the
    given fields when an insert happens during an `upsert` operation. It has no impact
    when the `upsert` operation results in the update of existing documents. To understand
    this better, consider the following snippet:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here, the upsert operation finds and updates the *Macbeth* movie record. It
    renames a field with a new name and also uses `$setOnInsert` on the field `created_time`,
    which is initialized to the current **Date**. As the movie is already present
    in the collection, this operation will result in an update:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27: Using $setOnInsert with upsert on an existing document'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_27.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.27: Using $setOnInsert with upsert on an existing document'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shows that `$setOnInsert` did not change the document, however,
    the field `comment` is now renamed to `num_mflix_comments`. Also, the field `created_time`
    is not added because the upsert operation was used to update an existing document.
    Now try an example of an insert using the upsert operation:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The only difference between this snippet and the previous one is that this
    operation finds a movie named `Spy`, which is not present in our collection. Because
    of the upsert, the operation will result in adding a document to the collection.
    The output can be seen in the following figure:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28: Using $setOnInsert with upsert on a new document'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_28.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.28: Using $setOnInsert with upsert on a new document'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, a new movie record has been created along with the field `created_time`.
    With the preceding example and the output, we have seen that the `$setOnInsert`
    operator sets a field only when a record is inserted as part of an upsert operation.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.01: Updating Comments for Movies'
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the users of your database have complained that their comments on a
    movie are not found on the website. Your customer support team did some investigating
    and found that there is a total of three comments incorrectly posted on a movie
    that actually belong to some other movie. The IDs of the incorrect comments are
    as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The following `find` query returns those three comments:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Execute the preceding query on the MongoDB Atlas `sample_mflix` database and
    the output should look as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29: Incorrect comments'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_29.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.29: Incorrect comments'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: All three comments above are posted against a 2009 movie, `Sherlock Holmes`
    (`ObjectId("573a13bcf29313caabd57db6")`), however, they belong to a 2014 movie,
    `50 First Dates` (`ObjectId("573a13abf29313caabd25582")`).
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'Your task for this activity is to correct `movie_id` in all three comments
    as well as to update the `num_mflix_comments` fields of these movies, respectively.
    The following steps will help you complete this activity:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Update the `movie_id` field in all three documents.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the movie `Sherlock Holmes` by its ID and reduce the number of comments
    by 3.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command you used in *step 2* on the mongo shell and confirm the results.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the movie `50 First Dates` and increase the number of comments by 3.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command you used in *step 3* on the mongo shell and confirm the results.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor469).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with the creation of documents in a collection. We saw
    that, during an insert operation, MongoDB creates the underlying collection if
    it does not exist, and autogenerates an `_id` field if the document does not have
    one already. We then covered various functions provided by MongoDB to delete and
    replace one or more documents in a collection, as well as the concept of upsert,
    its benefits, its support in MongoDB, and how an upsert operation differs from
    delete and insert. Then we learned how to add, update, rename, or remove fields
    in MongoDB documents using various functions and operators.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will execute some complex update commands using the
    aggregation pipeline support that was added in MongoDB 4.2, and learn how to modify
    the elements in an array field.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
