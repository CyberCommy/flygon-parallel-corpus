- en: 5\. Inserting, Updating, and Deleting Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to the core operations in MongoDB, namely inserting,
    updating, and deleting documents in a collection. You will learn how to insert
    a single document or a batch of multiple documents into a MongoDB collection.
    You will add or autogenerate an `_id` field, replace existing documents, and update
    specific fields in the documents of an existing collection. Finally, you will
    learn how you can delete all or delete specific documents in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we covered various database commands and queries. We learned
    to prepare query conditions and use them to find or count the matching documents.
    We also learned to use various conditional operators, logical operators, and regular
    expressions on fields, nested fields, and arrays. In addition to these, we learned
    how to format, skip, limit, and sort the documents in the result set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to correctly find and represent the required documents
    from a collection, the next step is to learn how to modify the documents in the
    collection. When working on any database management system, you will be required
    to modify the underlying data. Consider this: you are managing our movies dataset
    and are often required to add new movies to the collection as they release. You
    will also be required to permanently remove some movies or remove incorrectly
    inserted movies from the database. Over a period of time, some movies may receive
    new awards, reviews, and ratings. In such cases, you will need to modify the details
    of existing movies.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create, delete, and update documents
    in a collection. We will start by creating new collections, adding one or more
    documents to a collection, and consider the importance of the unique primary key.
    We will then cover deleting all or deleting specific documents from a collection,
    as well as various delete functions provided by MongoDB and their characteristics.
    Next, you will learn how to replace existing documents from a collection and understand
    how MongoDB keeps the primary key unchanged. You will also see how to use the
    replace operation to perform an update or insert, which is also called upsert.
    Finally, you will learn to modify documents. MongoDB provides various update functions
    and a wide range of update operators that can be used in specific requirements.
    We will cover all of these functions in depth and practice with the operators.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn to insert new documents into a MongoDB collection.
    MongoDB collections provide a function named `insert()`, which is used to create
    a new document in a collection. The function is executed on the collection and
    takes the document to be inserted as an argument. The syntax of this function
    is shown in the next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To see this in an example, open the mongo Shell, connect to the database cluster,
    and create a new database by using the `use CH05` command. You can give a different
    name to the database as per your preference. The database mentioned in this command
    will be created if it is not present earlier. In the following operation, we are
    inserting a movie with a `title` field and an `_id`, and the output is printed
    on the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be inserting, updating, and deleting a lot of documents
    in collections, and we do not want to corrupt the existing `sample_mflix` dataset.
    For this reason, we are creating a different database and using it throughout
    the chapter. Exercises and activities are focused on real-world scenarios and
    will therefore use the `sample_mflix` dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'This mongo shell snippet shows the execution of the `insert` command and the
    result on the next line. The result (`WriteResult`) shows that one record was
    successfully inserted. First perform a `find()` query and confirm whether the
    record was created as we wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding query and its output verify the correct insertion of our document.
    However, notice that the collection of `new_movies` was never present, nor did
    we create it. Where did the document go?
  prefs: []
  type: TYPE_NORMAL
- en: 'To find that, you execute the `show collections` command on the shell. This
    command prints the names of all collections in the current database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows a new collection of `new_movies` is added to the
    database. This proves that, when a document `insert` command is executed, MongoDB
    will also create the given collection, if it does not exist already.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When a new document is inserted, MongoDB does not validate the name of the collection.
    A typo in the collection name will result in the document being added to a completely
    new collection. Also, by default, MongoDB does not have any schema associated
    with a collection. Because of this, by giving an incorrect collection name, you
    may accidentally end up adding your document to any other existing collection,
    and MongoDB will not complain. This is why you should always be careful about
    the collection names in your `insert` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Multiple Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When multiple documents need to be inserted into a collection, you can call
    the `insert()` function that you saw in the previous section multiple times, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'MongoDB collections also provide the `insertMany()` function, which is a function
    specifically meant for inserting multiple documents into a collection. As shown
    in the syntax that follows, this function takes one argument of an array containing
    one or more documents to be inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this function, create an array of all the documents to be inserted and
    then pass this array to the function. The array of the same four movies will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you insert these four new movies into the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command uses `insertMany()` and passes an array of four movies
    to it. You can see the result in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Using insertMany() to pass an array of four movies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Using insertMany() to pass an array of four movies'
  prefs: []
  type: TYPE_NORMAL
- en: The result in the preceding operation contains two things. The first field is
    `acknowledged` with the value of `true`. This confirms the write operation was
    successfully performed. The second field of the result lists down all the `IDs`
    of the inserted documents. To insert multiple documents, it is preferable to use
    the `insertMany()` function, because insertion happens as a single operation.
    On the other hand, the insertion of each document separately will be executed
    as a number of different database commands and will make the process slower.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can insert as many documents as you want using the function `insertMany()`.
    However, the batch size should not exceed 100,000\. On a mongo shell, if you try
    to insert more than 100,000 documents in a single batch, the query will fail.
    If you do the same thing using a programming language, the MongoDB driver will
    internally split a single operation into multiple batches of permissible sizes
    and perform the batch insert.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Duplicate Keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any database system, a primary key is always unique in the table. Similarly,
    in MongoDB collections, the value expressed by the `_id` field is a primary key,
    and so it must be unique. If you try to insert a document whose key is already
    present in the collection, you will get a *Duplicate Key Error*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous examples, we have already inserted a movie whose `_id` is `2`.
    Now we will try to duplicate the primary key in another `insert` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This `insert` operation inserts a dummy movie into the collection and explicitly
    mentions the `_id` field as `2`. When the command is executed, we get a duplicate
    key error with a detailed message, as can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Error message for the duplicate _id field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: Error message for the duplicate _id field'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the operation of a bulk insert fails when one or more of the documents
    in the given array has a duplicate `_id`. For example, consider the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, using the `insertMany()` operation, you will insert four different movies
    into your collection. However, the third movie has an `_id` of `2`, and we know
    that another movie with the same `_id` already exists. This leads to an error,
    as can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Error message for the duplicate _id field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.3: Error message for the duplicate _id field'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute the command, it fails with a detailed error message. The error
    message clearly indicates that the value of `2` is duplicated in the `_id` field.
    However, the value of `nInserted` indicates that two documents have been inserted
    successfully. To confirm this, you will query the database and observe the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From the `find()` command and its output, shown in the previous snippet, we
    can conclude that the command failed while inserting the third document. However,
    the documents inserted before the third one will remain in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting without _id
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have learned the basics of creating new documents in a collection.
    In all the examples we showed up till now, we explicitly added a primary key (`_id`
    field). However, in *Chapter 2*, *Documents and Data Types*, we learned that while
    creating a new document, MongoDB verifies the presence and uniqueness of a given
    primary key and, if the primary key is not already present, the database autogenerates
    it and adds it into the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a snippet from the mongo shell where an `insert` command is
    executed. The `insert` command is trying to push a new movie into the collection,
    but the document does not have an `_id` field. The result on the very next line
    shows that the document is successfully created inside the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you query the newly inserted document and see if it has the `_id` field.
    To do so, query the collection using the value of the `title` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous snippet, the result shows that the document exists in the collection
    and an autogenerated `_id` field is added to the document. As we learned in *Chapter
    2*, *Documents and Data Types*, the autogenerated primary is derived from the
    `ObjectId` constructor and it is globally unique. The same is true for bulk inserts.
    For instance, consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `insertMany()` command is pushing four movies into the collection.
    Out of the four new documents, the third document does not have a primary key;
    however, the rest of the documents have respective primary keys. The result of
    this can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Inserting a movie without _id'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.4: Inserting a movie without _id'
  prefs: []
  type: TYPE_NORMAL
- en: The output of the query indicates the query was successful, and the `insertedIds`
    field shows that all documents except the third were inserted with the given keys
    and the third document has got an autogenerated primary key.
  prefs: []
  type: TYPE_NORMAL
- en: While working on datasets, our documents will have unique fields that can be
    used as primary keys. Primary keys are the ones that can uniquely identify a record.
    MongoDB's autogenerated keys are useful in terms of uniqueness, but they are meaningless
    in terms of the data the respective document represents. Also, these autogenerated
    keys are lengthy and thus tedious to type in or remember. Therefore, we should
    always try to use the primary keys that already exist in the datasets. For example,
    in a user's dataset, the `email_address` field is the best example of a primary
    key. However, in the case of movies, there is no field that can be unique. So,
    for the purpose of movies, we can use autogenerated primary keys.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered how to create a single as well as multiple documents
    in a collection. During this, we learned that in MongoDB an `insert` command also
    creates the underlying collection if it does not exist. We also learned that the
    primary keys need to be unique in a collection, and if a new document does not
    have a primary key, MongoDB autogenerates and adds it.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to remove the documents from a collection.
    To delete one or more documents from a collection, we have to use one of the various
    delete functions provided by MongoDB. Each of these functions has different behaviors
    and purposes. To delete documents from a collection, we have to use one of the
    delete functions and provide a query condition to specify which documents should
    be deleted. Let's take a look at this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Using deleteOne()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, the function `deleteOne()` is used to delete a single
    document from a collection. It accepts a document representing a query condition.
    Upon successful execution, it returns a document containing the total number of
    documents deleted (represented by the field `deletedCount`) and whether the operation
    was confirmed (given by the field `acknowledged`). However, as the method deletes
    only one document, the value of `deletedCount` is always one. If the given query
    condition matches more than one document in the collection, only the first document
    will be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this, write a delete command using `deleteOne()` and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, you executed the `deleteOne()` command and passed
    a query condition of `{_id : 2}`. This means that you want to delete a document
    for which the value of `_id` is `2`. The output on the next line indicates that
    the deletion was successful.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.01: Deleting One of Many Matched Documents'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use a query that matches more than one document
    and verify that only the first document is deleted when you do this. Perform the
    following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a regular expression in a query to match all movies where the `title` field
    starts with the word `movie`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet from the mongo shell shows that when you use the preceding
    query condition in a `find()` query, you get four movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the same query condition with `deleteOne()` to match all movies with titles
    starting with the word `movie`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output in the second line here confirms that only one document is deleted successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out which document is deleted, execute the same `find()` query on your collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet confirms that, although all four documents matched the
    query condition, only the first document is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Multiple Documents Using deleteMany()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To delete multiple documents that match the given criteria, you can execute
    the `deleteOne()` function multiple times. However, in that case, each document
    will be deleted in a separate database command, which can slow down the performance.
    MongoDB collections provide the function `deleteMany()` to delete multiple documents
    in a single command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `deleteMany()` function must be provided with a query condition, and all
    the documents that match the given query will be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `deleteMany()` command in the previous snippet uses the same regular expression
    used in the previous examples. The output in the next line indicates that all
    three movies whose titles start with the word "movie" are deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of both of the delete functions, in terms of matching the documents
    to given query expressions, is similar to finding documents, as we saw in the
    previous chapter. Passing an empty query document is equivalent to not passing
    any filter, and thus, all the documents are matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, both of the commands have been given an empty query document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `deleteOne()` function will delete the document that is found first. However,
    the `deleteMany()` function will delete all the documents in the collection. In
    the same manner, the following queries perform a **null** check on a non-existent
    field. In MongoDB, a non-existent field is considered to be **null** and so the
    given condition will match all of the documents in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Unlike finding documents, delete operations are `write` operations, and they
    permanently change the state of the collection. Therefore, while writing query
    conditions, which include null checks, you should always ensure that there is
    no typo in the field name. An incorrect field name may lead to the removal of
    all documents from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Using findOneAndDelete()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the two delete methods we saw previously, there is another function
    named `findOneAndDelete()`, which, as the name indicates, finds and deletes one
    document from the collection. Although it behaves similarly to the `deleteOne()`
    function, it provides a few more options:'
  prefs: []
  type: TYPE_NORMAL
- en: It finds one document and deletes it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If more than one document is found, only the first one will be deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once deleted, it returns the deleted document as a response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of multiple document matches, the `sort` option can be used to influence
    which document gets deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projection can be used to include or exclude fields from the document in response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, use `findOneAndDelete()` to delete a record and get the deleted document
    as a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the delete command finds a document by its `_id`.
    The response in the next line shows that the deleted document is returned in the
    response. This is a very useful feature. Firstly, because it clearly indicates
    which record was matched and deleted. Secondly, it allows you to further process
    the deleted record. In some cases, you may want to store the record in an archive
    collection, or you may want to inform some other system about this deletion. If
    the query matches multiple documents, only the first document gets deleted. However,
    you can use an option to sort the matched documents and control which document
    gets deleted, as can be seen in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding `insert` command, you have inserted five new documents
    into your collection. In the following snippet, you use the `findOneAndDelete()`
    command, which uses a regular expression to find those titles in the collection
    that start with the word `movie`. The query will match four documents; however,
    you will sort the `_id` field in descending order so that the document with the
    `_id` of 14 gets deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This operation demonstrates how a sort option can influence which documents
    get deleted. Without providing the sort option, the document with an `_id` of
    11 will be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen, this delete function always returns the deleted document in
    the response. We can also use the projection option to control the fields that
    are included or excluded in the document in response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this delete command, we are using the option of projection to include only
    the `title` field in the response. The output on the next line confirms the successful
    deletion and the document in response shows only the `title` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.02: Deleting a Low-Rated Movie'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The movie archives team in your organization is the team that ensures that most
    highly rated movies are present in the database. In order to improve the user
    experience, they want to frequently perform quality checks on the database and
    remove the movies with the lowest ratings. To measure quality, they want to consider
    IMDb ratings and the total number of votes because a higher number of votes means
    a more reliable rating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this, they asked you to remove a movie with a high number of IMDb
    votes, a low average rating, and the least awards won from the list of low-rated
    movies. Your task for this exercise is to connect to the `sample_mflix` cluster
    and execute a delete command so that a movie with least awards won, an IMDb rating
    of less than 2, and more than 50,000 votes gets deleted. Then, record the `title`
    and `_id` of the deleted movie. The following steps will help you complete this
    exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have to delete one movie, you can use either the `deleteOne()` or `findOneAndDelete()`
    function and prepare a query filter using the IMDb rating and votes. However,
    to ensure that the movie with the least awards gets deleted, you need to sort
    the films in ascending order of awards won and let the first movie in the resulting
    list be deleted. This means you will need to use `findOneAndDelete()`. First,
    open any text editor and start writing the query. Begin by writing the query filter.
    The first condition is to find movies with less than a two-point rating in IMDb:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The IMDb rating is a nested field; therefore, you will use the dot notation
    to access the field and then write the condition using the `$lt` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the second condition says the total number of IMDb votes should be more
    than 50,000\. Add this condition to your query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The second condition is expressed using the `$gt` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, write a `findOneAndDelete()` function and add the preceding query into
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will find movies with less than 2-star ratings and more
    than 50,000 votes and delete the first one. However, you also want to ensure that
    the movie with the least awards gets deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete the movie with the least awards won, add a `sort` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This command sorts the filtered movies in ascending order of awards won.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a projection option to return only the `_id` and `title` field of
    the deleted movie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command has a projection option wherein the `title` field is explicitly
    included. This means that all the other fields will be excluded, while `_id` is
    included by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, open the mongo shell and connect to the Atlas cluster. Use the `sample_mflix`
    database and execute the preceding command. You should see the following output:![Figure
    5.5: Deleting the low-rated movie'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_05_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.5: Deleting the low-rated movie'
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the preceding output, the command was executed successfully. The
    document returned in the response correctly includes the `_id` and `title` of
    the deleted movie.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you used one of the delete functions to correctly delete a
    specific record from the real-world collection of movies.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how you can completely replace the documents
    in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you may want to replace an incorrectly inserted document in a collection.
    Or consider that, often, the data stored in documents is changed over time. Or,
    perhaps, to support your product's new requirements, you may want to alter the
    way your documents are structured or change the fields in your documents. In all
    such cases, you will need to replace the documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we used a new database of `CH05` which we will continue
    using in this section. In the same database, create a collection named `users`
    and insert a few users into it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the command is successful, and four users are added. Before
    going any further, quickly use the `find()` command to ensure no other documents
    are present in the collection except for the newly inserted ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the documents in the preceding snippet, each user has a unique ID, name,
    and email address. Now, suppose the user `Margaery Tyrell` gets married to `Joffrey
    Baratheon`, and she wishes to change her surname to her husband's. To accomplish
    this, you will have to change her name as well as her email.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per the requirement, the new record for `Margaery Tyrell` should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To replace a single document in a collection, MongoDB provides the method `replaceOne()`,
    which accepts a query filter and a replacement document. The function finds the
    document that matches the criteria and replaces it with the provided document.
    The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the first argument is the query filter to identify the document to be
    replaced, and the second argument is the new document. The output clearly indicates
    that the given query matched one document and one document was updated. The query
    filter need not always be the `_id` field. It can be any query that filters using
    any field or combination of multiple fields and operators. For example, the following
    replace command will have the same effect as the previous one, as long as there
    is only one user with the name of `Margaery Tyrell`. If there is more than one
    document that matches the query, then only the first one will be replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: _id Fields Are Immutable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous example, you will have noticed that there was no `_id` field
    in the replacement document. In that case, do you think MongoDB must have added
    and autogenerated a primary key field? Query the document and find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output indicates that the `_id` of the original document is retained
    in the new document.
  prefs: []
  type: TYPE_NORMAL
- en: This is because `_id` fields are immutable in MongoDB. Immutable fields are
    like normal fields; however, once assigned with a value, their value cannot be
    changed again. The `_id` field serves as a unique identifier of a document and
    so should not be changed as long as the document exists.
  prefs: []
  type: TYPE_NORMAL
- en: It is similar to the user accounts you create on the various online portals,
    where your username is your unique identifier. You can change your password, or
    any other information in your profile, however, most portals won't allow you to
    change your username. Even if they allow you to modify your username, the old
    username cannot be assigned to anyone because there might be someone who still
    knows you by your old username.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was the theory of why the `_id` fields in MongoDB are immutable. However,
    try modifying the field and observe what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the replace command finds a document named `Margaery Baratheon`. In the
    replacement document, it also provides a new value for the `_id` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Error when _id is being modified'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.6: Error when _id is being modified'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you executed a replace command, as shown in the preceding snippet,
    where the replacement document now has an explicit `_id` field. The command failed
    with a very detailed error message. The preceding snapshot highlights the most
    important part of the error message, which indicates that the field is immutable.
    Hence, the update was rolled back, and no change happened to the record.
  prefs: []
  type: TYPE_NORMAL
- en: Upsert Using Replace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, we learned that we can find an existing document in
    a collection and replace it with a new document. However, there will be times
    you want to replace an existing document with a new one and, if the document does
    not already exist, insert the new document. This operation is called an update
    (if found) or insert (if not found), which is further shortened to upsert. Upsert
    is a feature provided by many databases and MongoDB supports it as well.
  prefs: []
  type: TYPE_NORMAL
- en: Why Use Upsert?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the simple scenarios that we have seen above, upsert sounds a bit unnecessary—especially
    when the same operation can be performed easily using two different commands.
    For example, we can first execute a replace command and check the results. The
    value of the matched count will tell whether the document is found in the collection.
    If the document is not found, we can then execute an `insert` command.
  prefs: []
  type: TYPE_NORMAL
- en: However, in real-world scenarios, you will mostly be doing these operations
    in large numbers. Consider that your system receives daily updates from a user
    server, where the server sends you all the documents that were modified during
    the day. These daily updates might include records of the new users signed up
    with the server as well as changes to the existing users' profiles. On a large-scale
    system, performing a two-step update or insert operation for each of the records
    will be very time-consuming and error prone. However, having a dedicated command,
    you can simply prepare and execute an upsert command for each of the records you
    receive and let MongoDB do the update or insert.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following records in the `users` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of an episode, King Joffrey has been killed. As a result, `Margaery`
    wants to switch back to her old surname, and `Tommen Baratheon` becomes the new
    king. The update you receive from the user server contains the updated record
    for `Margaery` and the new record for `Tommen`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following commands, you pass an additional argument of `{upsert: true}`,
    which makes these commands upsert commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the commands one after the other on a mongo shell, you see
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Output for the upsert operation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.7: Output for the upsert operation'
  prefs: []
  type: TYPE_NORMAL
- en: The result of the first upsert indicates that there was a match found, and the
    document has been updated. However, the second one denotes the match was not found,
    and a new document was upserted with an autogenerated primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing Using findOneAndReplace()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen the `replaceOne()` function, which, after successful execution,
    returns the counts of matched and updated documents. MongoDB provides another
    operation, `findOneAndReplace()`, to perform the same operations. However, it
    provides more options. Its main features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As the name indicates, it finds one document and replaces it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If more than one document is found matching the query, the first one will be replaced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sort option can be used to influence which document gets replaced if more
    than one document is matched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, it returns the original document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the option of `{returnNewDocument: true}` is set, the newly added document
    will be returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field projection can be used to include only specific fields in the document
    returned in response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see the `findOneAndReplace()` function in action, add five documents to
    a movie collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, say that these five movies, all having the same `title`, were released
    and inserted in different calendar years. When these records were originally inserted,
    the field for the year of release wasn''t added. As a result, to find the latest
    movie with this `title`, you need to use the incremental `_id` field, where the
    movie with the largest `_id` value is the latest one. To make future find queries
    simpler, you have been instructed to find the document of the latest movie with
    this `title` and add a flag of `latest: true` to that document. So, when someone
    tries to find that movie, they can pass this additional filter to get the latest
    one in the response, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous snippet, you found the document for a movie by its `title`
    and replaced it with another document that contains an additional field—that is,
    `latest : true`. Apart from that, the command used the option of `sort` so that
    the record with the largest value `_id` appears on top. The command also uses
    a projection option to include only the `title` field in the response. The output
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: Output for the findOneAndReplace command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.8: Output for the findOneAndReplace command'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding snapshot confirms that the operation is successful, and the `title`
    of the old document is included in the response. Alternatively, if you are required
    to get the updated document in the response, you can make use of the `returnNewDocument`
    flag in the command. Setting this flag to true will return the replaced document
    from the collection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This replace command works similarly to the previous one, but the only difference
    is that it is using an additional option of `returnNewDocument`, which is set
    to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: Output after setting returnNewDocument to true'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.9: Output after setting returnNewDocument to true'
  prefs: []
  type: TYPE_NORMAL
- en: 'This output shows that having the `returnNewDocument` flag set to `true` returns
    the new document. Now, quickly query the database and see whether the replace
    command did actually work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows the latest record now has the desired flag.
  prefs: []
  type: TYPE_NORMAL
- en: Replace versus Delete and Re-Insert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen in the previous sections, there are dedicated functions to find
    and replace documents in a collection. It is possible to replace a document using
    a combination of delete and insert, where you delete an existing document and
    insert a new one. This two-step operation of the delete and `insert` combination
    gives you the same results; let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: To perform the two-step, replace operation using delete and `insert`, use the
    same example that you saw in the `findOneAndReplace()` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, delete all the previously inserted or modified documents from the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, insert the five documents again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, find the document of the latest movie titled `Macbeth` and add the flag
    `"latest" : true` to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This snippet shows two different commands. The first is a `findOneAndDelete()`
    command that finds a movie by its `title` and also uses the sort option so that
    only the movie with largest `_id` gets deleted. The result of the deletion operation,
    which is the deleted document, is stored in a variable of `deletedDocument`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command in the preceding snippet is an insert operation that re-inserts
    the same movie along with the flag `latest : true`. While doing so, it uses the
    `_id` value from the deleted document, so that the new record is inserted with
    the same primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Output for delete first and then insert'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: Output for delete first and then insert'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding output indicates that you have executed both commands sequentially,
    and the response shows that one document was inserted successfully, which can
    be verified using the `find` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The result of a `find` operation on the collection confirms that the two-step
    replacement operation worked perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: Although the results are exactly the same, the two-step operation is more error
    prone. The two-step operation executes two totally different commands, one after
    the other. In the first command, your MongoDB client or your programming language's
    driver sends the `delete` command to the server. The server then validates and
    processes the command to remove the document. Then the deleted document is sent
    back to the client over the network. The client or driver then parses the returned
    result into the language-specific object. In our case, we are executing commands
    from a mongo shell, and so the results are parsed into the JSON format and stored
    in the variable `deleteDocument`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, your MongoDB client or the driver sends another command to insert the
    new document. The new document, which is in JSON format in our case, gets transformed
    into BSON and sent over the wire to the server. For the MongoDB server, this `insert`
    command is like any other fresh `insert` commands. The server performs the initial
    validation of the document, checks whether the `_id` field is present, and also
    validates the uniqueness of the value in the collection. If the document is found
    to be valid, the insert will happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you are familiar with the details of the two-step replace operation,
    consider the following potential shortfalls of using it over dedicated replace
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, in the delete and insert method, the data is transferred over
    the wire multiple times. This involves the drivers or clients to parse the data
    in multiple stages. This will slow down the overall performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When multiple clients are constantly reading and writing to your collections,
    concurrency issues may arise. As an example, say you have successfully deleted
    a record and before you insert the new record, some other client accidentally
    inserts a different record with the same `_id`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your database client or driver may lose its connection to the database in the
    middle of two operations. For example, the delete operation was successful but
    insertion could not happen. To avoid such issues, you will have to run your commands
    in a transaction so that the failure of one operation can revert the previously
    successful operations in the same transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dedicated replace functions, on the other hand, are effectively atomic and
    are therefore safe to use in concurrent environments. An atomic operation is the
    smallest unit of operation that cannot be divided further. For this reason, when
    an atomic operation is performed, it is executed in one go as a single unit. Thus,
    dedicated replace functions are safer as compared to the delete and insert combination.
  prefs: []
  type: TYPE_NORMAL
- en: The dedicated functions first find a document to be replaced and lock it. The
    lock is then released only after the operation is finished. Because of this, no
    other client or process is able to modify that particular document while it is
    locked. Also, the replace operation replaces only the rest of the fields in the
    documents, keeping `_id` untouched. There is no chance that other processes will
    be able to push a different document with the same `_id` value.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it is always preferable to use the specialty functions provided by MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Modify Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned that we could replace any document in a
    MongoDB collection once it has been inserted. During the replace operation, a
    document in the database will be replaced with a completely new document while
    keeping the same primary key. The replacement operations are quite useful when
    it comes to rectifying errors and to incorporating data changes or updates. However,
    in most cases, updates will affect only one or a few fields of a document. Think
    about any movie record from the `sample_mflix` dataset, where most of its fields
    (such as the title, cast, directors, duration, and so on) may never change. However,
    over a period of time, the movie may receive new comments, new reviews, and ratings.
  prefs: []
  type: TYPE_NORMAL
- en: The find and replace operation is very useful when all or most fields of a document
    are modified. But, using it to update only particular fields in the documents
    will not be easy. To do so, the replacement document you provide will need to
    have all the unchanged fields with their existing values and the changed fields
    with their new values. For a smaller document, this doesn't sound like a problem,
    but for large documents, like our movie records, the command will be bulky and
    error prone. We will see this with an example of a command that we will not execute
    on the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say a record of a movie was added to the database, but the value of the field
    `year` is incorrect. The following is an example of how the command will look
    if the replace operation is used to correct the value. In the first statement,
    we find the movie document and assign it to a variable. Next is the actual replace
    command where the replacement document with all of its fields needs to be provided.
    We use the variable `movie` that we assigned in the first line and refer to all
    of its unchanged fields. The last field in the replacement document is the field
    of `year` with the new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The problem with the command is that it is too bulky, especially since we only
    want to update a single field. It re-enters all the fields, even if they are not
    changed, and there is a good possibility of a typo being introduced when we are
    re-assigning the unchanged field values. Moreover, this is a two-step operation
    and introduces concurrency problems that are hard to debug.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the concurrency problem, imagine that the find operation in the
    first statement is successful, and the next statement is a replace command that
    refers to all the unchanged fields from the existing documents; but before the
    second statement is executed, the actual document in the database was modified
    by some other client or thread. Once your statement is executed, the updates added
    by the other client will be lost forever.
  prefs: []
  type: TYPE_NORMAL
- en: This is why the replace operation should only be used when all or most of the
    fields are being modified. To modify one or only a few fields of a document, MongoDB
    provides the `update` command. Let's explore this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a Document with updateOne()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update the fields of a single document in a collection, we can use the function
    `updateOne()`. This function, which is provided by MongoDB collections, accepts
    a query condition to find the record to be updated, and a document that specifies
    the field-level update expressions. The third argument to the function is to provide
    miscellaneous options and is optional. The syntax of this function looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Like the replace commands, `updateOne()` cannot be used to update the `_id`
    field of a document because it is immutable. Once the update is performed, it
    returns a detailed result in the form of a document, which indicates how many
    records were matched and how many records were updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using this function, first delete all the previously inserted and modified
    records from the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use the following `insert` command to add four new records to the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Write and execute your first update command to change the field `year` for
    the movie `Macbeth`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, the first argument to the `updateOne()` function is
    the query condition, wherein you specify that the name of the movie should be
    `Macbeth`. The second argument is a document that specifies a new field of `year`
    and its value. Here, we are using a new operator, `$set`, to assign values to
    the fields provided in a document. In the upcoming sections, we will learn more
    about the `$set` operator and also a few other operators that are supported by
    all the update functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the command is executed on a mongo shell, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is a document that denotes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"acknowledged" : true` indicates that the update was performed and confirmed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"matchedCount" : 1` shows the number of documents found and chosen for the
    update (1 in this case.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"modifiedCount" : 1` refers to the number of documents modified (1 in this
    case.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following query and the output that follows confirm that the update command
    was executed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding record, the field `year` is correctly set to `2015`, which
    was previously `2014`. If we execute the same command again, no update will be
    performed as the value is already `2015`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.12* shows the output of executing the same update command again.
    The resulting document indicates that there was one document that was matched
    as eligible for the update; however, no document was updated.'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying More Than One Field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `$set` operator that we used to update a field of a document can also be
    used to modify multiple fields of a document. As seen in the previous examples,
    `$set` is provided with a document that contains the update expression. Similarly,
    to modify more than one field, the update expression can contain more than one
    field and value pair. For example, consider this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding operation, the update expression `{"type": "movie", "num_mflix_comments":
    1}}` specifies two fields and their values. Out of these, the `num_mflix_comment`
    field does not exist in the respective movie. Execute the command on our movie
    collection and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding figure shows that the operation was successful, and one record
    is modified as expected. Now, query the document and see if the fields are modified correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The document from the collection indicates that the movie type has been modified
    correctly, and a new field named `num_mflix_comments` has been added with the
    given value. Thus, you have seen that `$set` can be used to update multiple fields
    in the same command, and if a field is new, it will be added to the document with
    the specified value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the next section, it is important to know that, in an
    update operation, updating the same field multiple times is valid, irrespective
    of the field''s value. As seen in the previous output, the `year` field of the
    movie `Macbeth` is set to 2015\. Modify the same field multiple times in the same
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding update command, which uses the `$set` operator, sets the year
    multiple times. The first two expressions set the field to its current value;
    however, the last two expressions have different values. Execute the command and
    observe the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the operation is valid, and one document is modified. Query the
    document from the collection and see the value of the `year` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, we prove that, when the same field is provided multiple
    times, the update happens from left to right. First, the `year` field (which was
    already 2015) is set to 2015 twice; then with the third expression, the year is
    set to 2016; and lastly, with the rightmost expression, it is set to 2017.
  prefs: []
  type: TYPE_NORMAL
- en: In any valid scenario, you will hardly ever update a field twice in an update
    operation. However, even if you do so, perhaps accidentally, you now know the
    behavior, and this will help you in debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Documents Matching a Condition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name of the `updateOne()` function indicates, it always updates only
    one document in the collection. If the given query condition matches more than
    one document, only the first document will be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding operation finds documents where `type` is `movie` and sets the
    value of `flag` as `modified`. Remember, we have a total of three documents of
    type `movie` in our movie collection. When the command is executed on our collection,
    the result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The result of the execution indicates that one document was matched and chosen
    for the update, and one document was actually modified. Thus, it proves that even
    if there is more than one document that matches the given query condition, only
    one document is chosen and updated.
  prefs: []
  type: TYPE_NORMAL
- en: Upsert with updateOne()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we learned in detail about the upsert operation. When
    upsert-based updates are executed, the document will be updated if it is found;
    however, if the document is not found, a new document is created inside the collection.
    Similar to the replace operations, `updateOne()` also supports upserts with an
    additional flag in the command. Consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding operation executes an update command on the movie `Sicario`,
    which does not exist in our collection. When the command is executed without any
    `upsert` flag, no update is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output indicates that no document was matched, and no document was updated.
    Now, we will execute the same command with an `upsert` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding operation uses a third argument, which contains a document with
    the `upsert` flag set to `true`, which is false by default. The output can be
    seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Update a non-existing movie with the upsert flag'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.11: Update a non-existing movie with the upsert flag'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the output of executing the command is slightly different this time. It
    indicates that no document was matched, and no document was updated. However,
    `"upsertedId" : ObjectId("5e…")` indicates that one document was inserted with
    an autogenerated primary key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following query finds the document using the autogenerated primary key.
    When you execute this query on your shell, you will have to use the `ObjectId`
    that was generated in the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: When we query the collection with the newly created primary key value, we get
    the newly inserted record.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice here is that the new document has two fields, out of which
    the field `year` was part of the update expression; however, `title` was part
    of the query condition. When MongoDB creates a new document as part of an `upsert`
    operation, it combines fields from the update expressions as well as query conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a Document with findOneAndUpdate()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen the function `updateOne()`, which modifies one document from a
    collection. MongoDB also provides the `findOneAndUpdate()` function, which is
    capable of doing everything that `updateOne()` does with a few additional features,
    which we''ll explore now. The syntax of this function is the same as `updateOne()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`findOneAndUpdate()` needs at least two arguments where the first one is a
    query condition to find the document to be modified and the second one is the
    update expression. By default, it returns the old document in the response. In
    some scenarios, getting back the old document is really useful, especially when
    it needs to be archived somewhere. However, by passing a flag as an argument,
    the behavior of the function can be changed to return the new document in the
    response. Consider the following example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The record for the movie `Macbeth` in our collection has only one comment,
    given by the field `num_mflix_comments`. Modify the count of these comments using
    the update command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command finds a movie by its `title` and sets `num_mflix_comments`
    to the value of 10\. We can see that it looks pretty similar to the `updateOne()`
    commands, and the effects on the collection will be exactly the same. However,
    the only difference we will see here is the response, as can be seen in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Update using fineOneAndUpdate()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.12: Update using fineOneAndUpdate()'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shows that the `findOneAndUpdate()` function did not return the
    query stats, such as how many records were matched and how many records were modified.
    Instead, it returns the document in its old state. Now query and verify whether
    the update was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The query and its output here confirm that the number of comments is modified
    to its new value.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a New Document in Response
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have used the function with two arguments where the first is the
    query condition and the second is the update expression. However, the function
    also supports an optional third argument, which is used to provide miscellaneous
    options to the commands. Out of these options, the `returnNewDocument` can be
    used to control which document should be returned in the response. By default,
    the value of this flag is set to false, which is why we get the old document without
    passing the options. However, setting this flag to true, we get back the modified
    or new document in the response. For example, consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding operation sets the comments count to 15 and also passes the flag
    of `returnNewDocument` set to true. The output can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: findOneAndUpdate() with the returnNewDocument flag'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.13: findOneAndUpdate() with the returnNewDocument flag'
  prefs: []
  type: TYPE_NORMAL
- en: The output shows that by setting the flag `returnNewDocument` to `true`, the
    response shows the modified document, which also confirms that the count of comments
    has been modified correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the optional third argument to the function, we can also provide an expression
    to limit the number of fields returned in the documents (also called a projection
    expression). The projection expression can be used for both cases—that is, returning
    an old or new document as a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding update command finds the movie by `title` and sets the count
    of comments to 20\. As the third argument, it passes two options to the command.
    The first option is the projection expression, which includes only `num_mflix_comments`
    in the response and excludes the `_id` explicitly. By using the second operation,
    the function will return the modified document. The output can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: findOneAndUpdate() with projection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.14: findOneAndUpdate() with projection'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the projection expression has excluded the `_id` and included
    only the `num_mflix_comments` field, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting to Find a Document
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have covered two update functions, and both are capable of updating
    a single document at a time. If more than one document is matched by the given
    query condition, the first document will be chosen for modification. This behavior
    is common between both functions. However, the `findOneAndUpdate()` function provides
    an additional option to sort the matching documents in a specific order. Using
    the sort option, you can influence which document is selected for the modification.
  prefs: []
  type: TYPE_NORMAL
- en: The sort option is specified as a field under the optional third argument of
    the `findOneAndUpdate()` function. The value of the sort field must be a document
    containing valid sort expressions. We will now see an example of using the sort
    option in an update command.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.15* shows that our collection has four records, which are of the
    movie type. Each one has a sequential `_id` field where the record inserted latest
    has the largest value in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: A collection having four records'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.15: A collection having four records'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a command that will use the same filter of `{"type" : "movie"}` and put
    the flag `"latest" : true` to the last inserted record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The update command in the preceding snippet sets the `latest` flag to true.
    The query condition finds a document with a `type` of `movie`. The options argument
    sets a flag to return the modified document in the response and also specifies
    a sort expression to sort documents by descending order of the primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: Update one record by sorting matched documents'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.16: Update one record by sorting matched documents'
  prefs: []
  type: TYPE_NORMAL
- en: 'The response to the update command, as shown in *Figure 5.16*, indicates that
    the record with `_id : 4` has the latest flag. This is due to the specified sort
    option, which ordered the matching records so that the largest IDs will appear
    first. The function picked up the first record and modified it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.03: Updating the IMDb and Tomatometer Rating'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your movie database has records of a large number of worldwide movies along
    with their details. Your product owners want you to keep the database updated
    with the most recent changes. People still love to watch some of the timeless
    classic movies and rate them or post their reviews, so the ratings of some of
    the popular movies, which were released a few decades ago, keep changing on a
    daily basis. Your organization has decided to incorporate rating updates for all
    movies irrespective of their release date. As a proof of concept, they have chosen
    *The Godfather*, one of the all-time great movies, and asked you to update it
    with the latest IMDb and Tomatometer ratings. If your product team is happy with
    the update, they will sign off on receiving regular updates from these platforms.
    Your task is to write and execute an update operation to update these ratings.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the latest IMDb and Tomatometer viewer ratings of the movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IMDb rating**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rating: 9.2 and Votes: 1,565,120'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tomatometer viewer rating**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rating: 4.76, number of reviews: 733, 777, meter 98'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the database to find the current values of these ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This query finds and prints the IMDb and Tomatometer viewer rating of the movie
    `The Godfather`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17: Ratings of the movie The Godfather'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.17: Ratings of the movie The Godfather'
  prefs: []
  type: TYPE_NORMAL
- en: The output shows the current ratings from the `sample_mflix` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open any text editor and write a `findOneAndUpdate()` command along with a
    query parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use the `$set` operator to set the IMDb fields. As the IMDb rating is
    still the same, you will only update the field `votes` field. To refer to the
    nested field of `votes`, use the dot notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add another update expression for Tomatometer ratings. For the Tomatometer
    viewer rating, you only need to update the fields of `rating` and `numReviews`.
    As these are two separate fields, add two separate update expressions to the `$set`
    operator. As these fields are nested within a nested object, use dot notation
    two times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that your update query is complete, add the flag to return the modified
    document in response along with projection on specific fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the mongo shell and connect to the Atlas `sample_mflix` database. Copy
    the previous command and execute it:![Figure 5.18: Updated ratings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_05_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.18: Updated ratings'
  prefs: []
  type: TYPE_NORMAL
- en: The previous output shows that the respective fields have been updated correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have practiced using `findOneAndUpdate()` and `$set` to
    update the values of nested fields. Next, we will learn to update multiple documents
    using `updateMany()`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Multiple Documents with updateMany()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous sections, we learned to find one document and modify or update
    its fields. Many times though, you will want to perform the same update operation
    on multiple documents in a collection. MongoDB provides the `updateMany()` function,
    which updates multiple documents at a time. Similar to `updateOne()`, the `updateMany()`
    function takes two mandatory arguments. The first argument is the query condition,
    and the second is the update expression. The third argument, which is optional,
    is used to provide miscellaneous options. Upon execution, this function updates
    all the documents that match the given query condition. The syntax of the function
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We will write and execute an update operation on our movie collection. Consider
    that our movie collection has four movies that were released in 2015\. Add a field
    named `languages` to these movies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This update operation uses two arguments. The first is to find all the movies
    that were released in 2015\. The second argument is an update expression, which
    uses the `$set` operator, to add a new field named `languages`. The value of the
    `languages` field is an array containing English as the only language. The output
    can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The output indicates that the operation was successful, and, like the `updateOne()`
    function, a similar document is returned in the response. The response indicates
    that the query condition matched a total of four documents, and all were modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we learned about modifying fields of one or more documents
    in MongoDB collections. We have covered three update functions, out of which `updateOne()`
    and `findOneAndUpdate()` are used to update one document in a collection while
    `updateMany()` is used to update multiple documents in a collection. The following
    are a few important points about the update operations and are applicable to all
    three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: None of the update functions allows you to change the `_id` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the fields in a document is always maintained, except when the
    update includes renaming a field. However, the `_id` field will always appear
    first. (We will cover renaming fields in the next section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update operations are atomic on a single document. A document cannot be modified
    until another process has finished updating it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the update functions support upsert. To execute an upsert command, `upsert
    : true` needs to be passed as an option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will cover various update operators and their usages.
  prefs: []
  type: TYPE_NORMAL
- en: Update Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to facilitate different types of update commands, MongoDB provides
    various update operators or update modifiers such as set, multiply, increment,
    and more. In the previous sections, we used the operator `$set`, which is one
    of the update operators provided by MongoDB. In this section, we will learn some
    of the most commonly used operators and examples. Before we go through the operators,
    we will discuss their syntax. The following code snippet shows the basic syntax
    of an update expression that uses an update operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: As per the preceding syntax, an operator can be assigned a document containing
    one or more pairs of field and value. The operator is then applied to each field
    using the respective value. An update expression like the previous one is useful
    when all the given fields need to be updated with the same operator. You may also
    want to update different fields of a document using different operators. For such
    cases, an update expression can contain multiple update operators, each separated
    by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows the syntax for using multiple operators in the same
    update expression. In an update operation, each of these operators will be executed
    in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through each of the update operators in detail now.
  prefs: []
  type: TYPE_NORMAL
- en: Set ($set)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already seen, the `$set` operator is used to set the values of fields
    in a document. It is the most commonly used operator, as it can be easily used
    to set values of any type of field or add new fields in a document. The operator
    takes a document that contains pairs of field names and their new values. If the
    given field is not already present, it will be created.
  prefs: []
  type: TYPE_NORMAL
- en: Increment ($inc)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The increment operator `($inc`) is used to increment the value of a numeric
    field by a specific number. The operator accepts a document containing pairs of
    a field name and a number. Given a positive number, the value of the field will
    be incremented and if a negative number is provided, the value will be decremented.
    It is obvious but worth mentioning that the `$inc` operator can only be used with
    numeric fields; if attempted for non-numeric fields, the operation fails with
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, in our collection, the document for a `Macbeth` movie looks as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, write an update using the `$inc` operator on two fields, out of which
    one exists in the document and the other does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding update operation finds a movie by its `title`, increments the
    `num_mflix_comments` field by 3 and a non-existent field called `rating` by `1.5`.
    It also sets `returnNewDocument` to `true`, so that the updated record will be
    returned in the response. You can see the output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19: Incrementing the number of comments and the rating score'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.19: Incrementing the number of comments and the rating score'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the update command was successful. The field of `num_mflix_comments` is
    correctly incremented by 3 and `rating` (which was a nonexistent field) is now
    added to the document with a specified value. We will see an example of decrementing
    the field values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command uses the `$inc` operator on two fields and provides negative numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: Decrementing the number of comments and rating score'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.20: Decrementing the number of comments and rating score'
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 5.20*, the negative increments lead to the response. The
    `rating`, which was 1.5, is now reduced by 0.2 and `num_mflix_comments` is reduced
    to 21.
  prefs: []
  type: TYPE_NORMAL
- en: Multiply ($mul)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The multiplication `($mul`) operator is used to multiply the value of a numeric
    field by the given number. The operator accepts a document containing pairs of
    field names and numbers and can only be used on numeric fields. For example, consider
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding update operation finds a movie by its `title`, uses `$mul` to
    multiply the value of the field of `rating` by 2, and adds an option to return
    the modified document in the response. You can see this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: Doubling the rating score'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.21: Doubling the rating score'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shows the value of the field `rating` is multiplied by 2\. When
    using a non-existent field with `$mul`, we should always remember that no matter
    what multiplier we provide, the field will be created and always set to zero.
    This is because, with a multiplication operation, the value of a nonexistent numeric
    field is assumed to be zero. Thus, using any multiplier on zero results in zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This update operation multiplies a nonexistent field `box_office_collection`
    by a given value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22: Multiplying the value of a non-existing field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.22: Multiplying the value of a non-existing field'
  prefs: []
  type: TYPE_NORMAL
- en: The output in *Figure 5.22* proves that irrespective of the provided value,
    the nonexistent field of `box_office_collection` has been added with a value of zero.
  prefs: []
  type: TYPE_NORMAL
- en: Rename ($rename)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As suggested by the name, the `$rename` operator is used to rename fields. The
    operator accepts a document containing pairs of field names and their new names.
    If the field is not already present in the document, the operator ignores it and
    does nothing. The provided field and its new name must be different. If they're
    the same, the operation fails with an error. If a document already contains a
    field with the provided new name, the existing field will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try various scenarios of the `$rename` operator, first, insert a field named
    `imdb_rating` for `Macbeth`. The following update operation sets the new field
    and the output shows that the field is correctly added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, rename the field `num_mflix_comments` to `comments` and rename the field
    `imdb_rating` to `rating`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The update operation uses the `$rename` operator and passes a document containing
    two pairs of field names and new names. Note that the second field name and new
    name combination is trying to rename the field of `imdb_rating` to `rating`; however,
    the record already has a field with the name of `rating`. The output can be seen
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: Renaming fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.23: Renaming fields'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shows that the rename operation was successful. As stated above,
    the original field of `rating` is removed and the `imdb_rating` field is now renamed
    to `rating`. Using this operator, a field can also be moved to and from nested
    documents. To do so, you have to use a dot notation, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the update operation is renaming the `rating` field. However, the new
    name contains a dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: Renaming nested fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.24: Renaming nested fields'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the dot notation, the field `rating` has been moved under the nested
    document `imdb`. Similarly, a field can be moved from a nested document to the
    root or to any other nested document.
  prefs: []
  type: TYPE_NORMAL
- en: Current Date ($currentDate)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operator `$currentDate` is used to set the value of a given field as the
    current date or timestamp. If the field is not present already, it will be created
    with the current date or timestamp value. Providing a field name with a value
    of `true` will insert the current date as a `Date`. Alternatively, a `$type` operator
    can be used to explicitly specify the value as a `date` or `timestamp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `findOneAndUpdate` operation sets three fields using the `$currentDate`
    operator. The field `created_date` has a value of true, which defaults to a `Date`
    type. The other two fields use a dot notation and explicit `$type` declaration.
    The output can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25: Setting the current date and timestamp'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.25: Setting the current date and timestamp'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the field `created_date` has a value of the `Date` type. A new
    field, `last_updated`, has been added and has a nested document. Under the nested
    document, another field has been initialized as a `Date` type and the other as `Timestamp`.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Fields ($unset)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `$unset` operator removes given fields from a document. The operator accepts
    a document containing pairs of field names and values and removes all the given
    fields from the matched document. As the provided fields are being removed, their
    specified values have no impact. For instance, consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute an update operation using the `$unset` operator to remove unwanted
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding update operation removes four fields from the document. As stated
    previously, it doesn''t matter whether and what value is provided to the field
    while it is being removed. Here, you are trying to remove multiple fields and
    providing them with different values, and you will observe that their values have
    no impact. The first field, `created_date`, is provided with a value of an empty
    string. The next two fields have some dummy values, and the field `imdb` has a
    null value. The last field, `flag`, is also provided with an empty string. Out
    of these five fields, `imdb` and `last_updated` are nested fields. You will now
    execute the operation and observe the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26: Removing multiple fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.26: Removing multiple fields'
  prefs: []
  type: TYPE_NORMAL
- en: The output indicates that all five fields are correctly removed from the document.
    The operation and the response prove that the values specified for the fields
    have no impact on field removal. Also, specifying a field with a value of a nested
    object removes the respective object and contained fields.
  prefs: []
  type: TYPE_NORMAL
- en: Setting When Inserted ($setOnInsert)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operator `$setOnInsert` is similar to `$set`; however, it only sets the
    given fields when an insert happens during an `upsert` operation. It has no impact
    when the `upsert` operation results in the update of existing documents. To understand
    this better, consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the upsert operation finds and updates the *Macbeth* movie record. It
    renames a field with a new name and also uses `$setOnInsert` on the field `created_time`,
    which is initialized to the current **Date**. As the movie is already present
    in the collection, this operation will result in an update:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27: Using $setOnInsert with upsert on an existing document'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.27: Using $setOnInsert with upsert on an existing document'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shows that `$setOnInsert` did not change the document, however,
    the field `comment` is now renamed to `num_mflix_comments`. Also, the field `created_time`
    is not added because the upsert operation was used to update an existing document.
    Now try an example of an insert using the upsert operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference between this snippet and the previous one is that this
    operation finds a movie named `Spy`, which is not present in our collection. Because
    of the upsert, the operation will result in adding a document to the collection.
    The output can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28: Using $setOnInsert with upsert on a new document'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.28: Using $setOnInsert with upsert on a new document'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, a new movie record has been created along with the field `created_time`.
    With the preceding example and the output, we have seen that the `$setOnInsert`
    operator sets a field only when a record is inserted as part of an upsert operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.01: Updating Comments for Movies'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the users of your database have complained that their comments on a
    movie are not found on the website. Your customer support team did some investigating
    and found that there is a total of three comments incorrectly posted on a movie
    that actually belong to some other movie. The IDs of the incorrect comments are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `find` query returns those three comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the preceding query on the MongoDB Atlas `sample_mflix` database and
    the output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29: Incorrect comments'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_05_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.29: Incorrect comments'
  prefs: []
  type: TYPE_NORMAL
- en: All three comments above are posted against a 2009 movie, `Sherlock Holmes`
    (`ObjectId("573a13bcf29313caabd57db6")`), however, they belong to a 2014 movie,
    `50 First Dates` (`ObjectId("573a13abf29313caabd25582")`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Your task for this activity is to correct `movie_id` in all three comments
    as well as to update the `num_mflix_comments` fields of these movies, respectively.
    The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the `movie_id` field in all three documents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the movie `Sherlock Holmes` by its ID and reduce the number of comments
    by 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command you used in *step 2* on the mongo shell and confirm the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the movie `50 First Dates` and increase the number of comments by 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command you used in *step 3* on the mongo shell and confirm the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor469).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with the creation of documents in a collection. We saw
    that, during an insert operation, MongoDB creates the underlying collection if
    it does not exist, and autogenerates an `_id` field if the document does not have
    one already. We then covered various functions provided by MongoDB to delete and
    replace one or more documents in a collection, as well as the concept of upsert,
    its benefits, its support in MongoDB, and how an upsert operation differs from
    delete and insert. Then we learned how to add, update, rename, or remove fields
    in MongoDB documents using various functions and operators.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will execute some complex update commands using the
    aggregation pipeline support that was added in MongoDB 4.2, and learn how to modify
    the elements in an array field.
  prefs: []
  type: TYPE_NORMAL
