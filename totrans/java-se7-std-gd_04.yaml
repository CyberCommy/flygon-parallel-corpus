- en: Chapter 4. Using Arrays and Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter, when boiled down to its essence, is about data structures. Specifically,
    it is about arrays—the `java.util.Arrays` and `java.util.ArrayList` classes. An
    array is a region of memory that can be addressed using a single variable name.
    It provides an efficient technique for accessing data in a sequential or random
    fashion. The `Arrays` class provides support for arrays while the `ArrayList`
    class provides array-like behavior but is not fixed in size.
  prefs: []
  type: TYPE_NORMAL
- en: We are concerned with how to create and use these data structures. A common
    operation is the traversal of an array or collection. We will see that Java supports
    several approaches permitting us to move through the elements of an array or an
    `ArrayList` object. Common to both arrays and collections is the ability to use
    the for-each statement. Iterators provide an alternate approach for accessing
    collections such as the `ArrayList`, and will also be discussed.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by examining arrays in detail. This will include the creation
    and use of single and multidimensional arrays. Common array operations such as
    copying and sorting will be demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: As arrays are a simple data structure, most languages do not provide much support
    for operations on them. The `java.util.Arrays` class fills this void and supports
    important operations against arrays. These include copying, filling, and sorting
    the arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util` package contains a number of interfaces and classes that can
    make working with collections of data easier. In this chapter we will examine
    the use of iterators and the `ArrayList` class which are part of this package.
    Iterators provide a technique for traversing over collections which can be very
    useful. The `ArrayList` class is frequently used instead of arrays when the size
    of the collection may change. It provides a number of valuable methods for the
    modification of collections. We will also examine how to encapsulate a collection,
    such as the `ArrayList`, in another class.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array allows multiple values to be accessed using a single variable name.
    Each element of an array is of the same type. The element type can be a simple
    primitive data type or a reference to an object.
  prefs: []
  type: TYPE_NORMAL
- en: One-dimensional arrays are allocated to a contiguous region of memory. This
    means that the elements of the array can be accessed efficiently as they are adjacent
    to each other. Arrays use an integer index to access an element in the array.
    Indexes range from 0 to the length of the array minus one. We are able to access
    the elements of an array directly, in any order as needed by the application,
    without having to visit each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though Java supports multidimensional arrays, one-dimensional arrays are most
    commonly used. Arrays can be used for a variety of purposes including:'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of numbers representing ages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of employee names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of prices for an item in a store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main disadvantage of arrays is that they have a fixed size. This makes it
    more difficult and less efficient to add, remove, or resize any list or collection
    of data represented by an array.
  prefs: []
  type: TYPE_NORMAL
- en: Our discussion will begin with the coverage of one-dimensional and multidimensional
    arrays. This is followed by discussions of common array techniques such as traversing
    an array and copying arrays. In the first two sections, we will use simple "for
    loops" to traverse array elements. Alternative methods are covered in the *Traversing
    arrays* section.
  prefs: []
  type: TYPE_NORMAL
- en: One-dimensional arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A one-dimensional array is intended to represent a simple linear list. The
    following code snippet illustrates the declaration and use of a one-dimensional
    array. The array, `ages`, is declared in the first statement as an array of the
    `int` type. In the second statement, memory is allocated for the array using the
    `new` operator. In this example, the array consists of `5` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ages` array has `5` elements allocated to it. The first index of any array
    is 0\. The largest index of an array is its length - 1\. Thus, the last index
    of the array is 4\. A runtime exception will be generated if an index used is
    outside the legal range of values for an array. The array could have been declared
    and created using a single statement, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As an array name is a reference to an array, it is possible to assign a different
    array to the variable later in the program. We will demonstrate this later in
    the discussion.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array is an object that is allocated from an area of memory known as the
    **heap** . The heap and program stack were introduced in the *Stack and heap*
    section in [Chapter 2](ch02.html "Chapter 2. Java Data Types and Their Usage"),
    *Java Data Types and Their Usage*. In the following example, the first element
    of `ages` is assigned the value `35` and then displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays possess the `length` property that returns the number of elements in
    the array. When the next code sequence is executed, it will return `5`. Notice
    that `length` is not a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays are represented in Java as objects. In the previous example, `ages`
    is an object reference variable which references the array that has been allocated
    to the heap. This is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![One-dimensional arrays](img/7324_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, each element of the array was initialized to 0, by default,
    and then the first element was assigned a value of 35.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any attempt to use an index that is outside the bounds of the array will generate
    a `java.lang.ArrayIndexOutOfBoundsException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: The placement of array brackets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a second option with regards to the placement of brackets when declaring
    an array. We can also place the brackets after the name of the array, shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To the compiler, this is equivalent to the previous declaration. However, the
    placement of brackets with other uses of an array name is restricted. For example,
    we have to place the brackets after the array name when we are declaring or referencing
    elements of the array. If we attempt the following when declaring an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get a syntax error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, if we try to use the brackets before the array name when referencing
    an element of the array, such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following syntax error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is more common to see brackets used after the data type of the array. For
    example, most IDEs will at some point generate a `main` method. It frequently
    appears below with the brackets following the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, consider the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `arr1` and `arr2` are declared as arrays. This is a simpler way of declaring
    more than one array on a single line. However, it can be argued that the following
    is a better format as it is more explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be also argued that declaring more than one variable on a line is a
    bad form. The best way of declaring these two arrays is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Initializing arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The elements of an array are initialized to default values as shown in the
    following table. This table is duplicated from the *Initializing identifiers*
    section of [Chapter 2](ch02.html "Chapter 2. Java Data Types and Their Usage"),
    *Java Data Types and Their Usage*, for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Default value (for fields) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | ''\u0000'' |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | 0L |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | 0.0f |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | 0.0d |'
  prefs: []
  type: TYPE_TB
- en: '| `String` (or any object) | null |'
  prefs: []
  type: TYPE_TB
- en: In the previous example, we assigned a value of 35 to the first element of the
    array. This is a simple, yet tedious way of initializing the array to values other
    than the default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternate technique is to use a block statement to initialize the array.
    This is illustrated in the following example, where `ages` is initialized to five
    different values. It is not necessary to specify the array size when using the
    block statement to initialize an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A syntax error will be generated if you try to specify the size of the array,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The message will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we want to display the content of an array, there are several methods available.
    Here, we will use simple indexes and the `length` property. In the *Traversing
    arrays* section we will demonstrate other techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sequence shows the difference between using the `toString`
    method and a for loop to display an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the `toString` method does not return the contents of the
    array. Rather, it returns a strange representation of the array. We have no control
    over the string returned by the `toString` method. However, the for loop gives
    us what we expected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that arrays in Java always begin with an index of 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of hard coding the size of the array as `5`, as we did in an earlier
    example, a better approach is to use a constant. For example, the entire sequence
    could be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use named constants for array sizes. However, using the `length` attribute once
    the array is declared is preferred, as it is more maintainable should the array
    size change.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays of objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is important to keep a clear distinction between an object reference variable
    and the object itself. An array of objects uses a reference variable, such as
    the `names` variable declared below, which is a single memory location that contains
    a reference to an array object. Each element of the array is another reference
    which may reference a string. Initially, they are assigned a `null` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The allocation of memory for this example is illustrated in the following diagram.
    However, we did not include the indexes for the array in the diagram. We can assume
    that the top element is at index 0 and the last element is at index 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arrays of objects](img/7324_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When a string is assigned to an element of the array, the array element is
    modified to reference that string as illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram illustrates the modification of the reference at index
    2 so that it references the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arrays of objects](img/7324_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Be careful when using arrays that might contain null values. Consider the following
    code sequence where we display the contents of the `names` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Multidimensional arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many applications require the use of arrays with two or more dimensions. Tabular
    data with rows and columns or one that uses the x/y coordinate system are good
    candidates for representation using a two-dimensional array. Three or more higher
    dimensions are not as common, but a coordinate system using an x, y, and z value
    would use three dimensions. In this section, we will demonstrate multidimensional
    arrays using integers. However, the techniques are equally applicable to arrays
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of how a two-dimensional array is declared is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create an array with 2 rows and 3 columns depicted logically, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multidimensional arrays](img/7324_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the indexes start with a zero. We can initialize each element using
    a series of assignment statements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bit tedious, but it illustrates the placement of numbers into the
    array, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multidimensional arrays](img/7324_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Nested loops are useful for working with two-dimensional arrays. For example,
    to display the contents of such arrays, we will use a set of nested for loops
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we get the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Actually, Java does not support two-dimensional arrays in the strictest sense.
    In reality they are arrays of arrays. In languages such as C, two-dimensional
    arrays are stored in row-column order. This means that the two-dimensional array
    is mapped to a one-dimensional space where the first row is stored in the memory,
    followed by the second row and then the third and so forth. This is not applicable
    to Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, what we actually have is a one-dimensional array of references to
    a series of other one-dimensional arrays. For example, we could have created the
    same `grades` array as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The array is allocated in the memory, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multidimensional arrays](img/7324_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In a two-dimensional array, the rows do not necessarily have to be the same
    size. In the following code sequence, we create an array with different row lengths.
    Arrays of this type are called **ragged arrays** .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The memory allocation is similar to the previous example, except for the difference
    in array lengths, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multidimensional arrays](img/7324_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Array techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are numerous techniques for working with arrays. In this section, we
    will examine many of these, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Traversing arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will demonstrate variations to each technique as appropriate. Passing a variable
    number of arguments to a method is covered in [Chapter 6](ch06.html "Chapter 6. Classes,
    Constructors, and Methods"), *Classes, Constructors, and Methods*.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Traversing an array is the process of visiting each element of an array. This
    is frequently done starting with the first element and moving element by element
    until the end of the array is reached. However, it is also possible to move backwards
    or to skip elements. Here, we will focus on showing how we can traverse an array
    from beginning to end using two different techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Using simple for loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the for-each statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use the `ages` array, declared as follows, to illustrate how to traverse
    an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In each example, we will use this code to initialize each element of the array
    to 5.
  prefs: []
  type: TYPE_NORMAL
- en: Using simple loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Any simple loop can be used to traverse an array. Looping constructs are covered
    in more detail in [Chapter 5](ch05.html "Chapter 5. Looping Constructs"), *Looping
    Constructs*. Here, we will use a for loop and a while loop. First, ''let''s examine
    the for loop. In the following sequence, an integer variable starts at 0 and advances
    to the length of the array minus one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent while loop follows. Note the `i` variable is declared outside
    of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The for loop is generally preferable because we know the length of the array
    and it is simpler for these types of problems. For both examples, we used the
    `length` property of the array to control the loop. This is preferable to using
    a constant variable that may have been used to declare the array. Consider the
    following situation where we redefine the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The second for loop will not execute properly because we forgot to change the
    `SIZE` constant and may even throw an exception if the array is smaller than `SIZE`.
    If we had used the `length` property instead, there would not have been a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, that the for loop, as written, declares the variable `i` within the
    for loop. This restricts access to the variable to only those statements within
    the for loop. In the while loop example, we declared `i` outside of the loop making
    it accessible inside, and outside, of the while loop. We could have rewritten
    the for loop to use an external `i` variable. However, it is considered to be
    better form to restrict access to a variable to only those statements that need
    access. Thus, if it is only needed inside of the loop then the for loop provides
    a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using simple for statements can result in off-by-one errors (starting at the
    wrong beginning or ending index). For example, if the value used as the last index
    is larger than the size of the array minus one, then a `ArrayIndexOutOfBoundsException`
    exception will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Using the for-each statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The for-each statement provides a more convenient method of traversing an array
    if we do not need explicit access to each element''s index value. The for-each
    parentheses'' body consists of a data type, a variable name, colon, and then an
    array (or collection). The statement will iterate through the array starting with
    the first element and ending with the last. During each iteration the variable
    references that array element. The following illustrates the use of this statement
    with the `ages` array. During the first iteration, `number` references `ages[0]`.
    During the second iteration, `number` references `ages[1]`. This continues for-each
    element of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The for-each statement makes it easy to traverse an array. However, if we need
    to use the index of an array element, the statement does not provide access to
    its value. The traditional for loop is needed to access the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the differences between the use of the for loop
    and the for-each loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | for loop | for-each loop |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Provides access to the array element | ![Using the for-each statement](img/7324EN_04_10.jpg)
    | ![Using the for-each statement](img/7324EN_04_10.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| Provides access to the array index | ![Using the for-each statement](img/7324EN_04_10.jpg)
    | ![Using the for-each statement](img/7324EN_04_11.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| Uses logical expression to control loop | ![Using the for-each statement](img/7324EN_04_10.jpg)
    | ![Using the for-each statement](img/7324EN_04_11.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| Simplest | ![Using the for-each statement](img/7324EN_04_11.jpg) | ![Using
    the for-each statement](img/7324EN_04_10.jpg) |'
  prefs: []
  type: TYPE_TB
- en: Comparing arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an array variable is a reference variable, comparing array reference variables
    to determine equality will not always work. Here, we will examine several techniques
    for comparing arrays including:'
  prefs: []
  type: TYPE_NORMAL
- en: Element-by-element comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the equality operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `equals` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `deepEquals` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will demonstrate these techniques by comparing two integer arrays. Consider
    the following example where two arrays, `arr1` and `arr2`, are equivalent after
    we initialize them to contain the same data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows how memory is allocated for both arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing arrays](img/7324_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Element-by-element comparison
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This simple approach will compare the corresponding elements of each array
    to determine if the arrays are equal. It starts by assuming they are equal and
    assigns a `true` value to the `areEqual` variable. If any comparison is false,
    then the variable is assigned the value of `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When this sequence is executed, it will display `true`. This is not the best
    approach. Using indexes is an error prone and tedious approach.
  prefs: []
  type: TYPE_NORMAL
- en: Using the equality operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we try to compare the two arrays using the equality operator, we find that
    the result of the comparison will be `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is because we are comparing `arr1` and `arr2` which are array reference
    variables and not the arrays. The variables, `arr1` and `arr2`, reference different
    objects in memory. The contents of these two reference variables are different,
    therefore, when they are compared to each other they are not equal. They don't
    reference the same object.
  prefs: []
  type: TYPE_NORMAL
- en: Using the equals method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use the `equals` method with arrays as we can with other objects. In
    the following example, the output will be false even though they are equivalent.
    This is because the `equals` method, as applied to arrays, tests for object equivalency
    and not object value equivalency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Object equivalency refers to the comparison of two object reference variables.
    If these variables reference the same object, they are considered to be equivalent.
    Object value equivalency refers to the condition where two distinct objects are
    considered to be equivalent because their internal values are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Using the deepEquals method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To compare two arrays correctly we need to use the `Arrays` class' `equals`
    or `deepEquals` methods. The `equals` method performs a comparison using object
    identities. The `deepEquals` method performs a more in depth examination of the
    elements for value equivalency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following statement will display `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `deepEquals` method requires an array of objects. The two-dimensional `grades`
    array, used in the *Multidimensional arrays* section, satisfies the requirement
    as it is an array of arrays, that is, an array that references other arrays (which
    are objects).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create a second grade array, `grades2`, and populate it with the same
    values as `grades`, we can use these methods to test for equality. The creation
    and initialization of the `grades2` array follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The first three comparisons returned `false` because they did not adequately
    compare the two arrays. The fourth technique compared the arrays in depth and
    accurately determined their equivalency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes these techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Technique | Comment |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Element-by-element comparison | This will compare arrays properly, if implemented
    correctly. |'
  prefs: []
  type: TYPE_TB
- en: '| Using the equality operator | This only works properly if the two reference
    variables reference the same object. |'
  prefs: []
  type: TYPE_TB
- en: '| Using the array''s `equals` method | This only works properly if the two
    reference variables reference the same object. |'
  prefs: []
  type: TYPE_TB
- en: '| Using the `Array`''s class `equals` method | This will work for one-dimensional
    arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| Using the `Array`''s class `deepEquals` method | This performs a deeper comparison
    using the object''s `equals` method. |'
  prefs: []
  type: TYPE_TB
- en: Copying arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are times when we need to copy one array to another. In this section,
    we will examine various techniques to achieve this goal. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple element-by-element copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `System.arraycopy` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Arrays.copyOf` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Arrays.copyOfRange` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `clone` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will demonstrate the techniques using two one-dimensional arrays as declared
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We will initialize each element of `arr1` to its index with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this section's examples, the content of the destination array follows as
    a comment.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use the terms, **shallow copy** and **deep copy**. Shallow copy
    refers to when only the reference values are copied. After the copy operation,
    the original object has not been duplicated. In a deep copy, the reference to
    the object is not copied. Instead, a new copy of the object is created. We will
    see how some of the techniques illustrated here only perform a shallow copy which
    may not always be desirable.
  prefs: []
  type: TYPE_NORMAL
- en: Simple element-by-element copy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A simple technique is to use a for loop as illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple approach but you need to be careful to use the correct array
    indexes. This technique becomes more complicated with multidimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Using the System.arraycopy method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `System` class' `arraycopy` method will attempt to copy all, or part, of
    one array to another. The beginning position in each array is specified, along
    with the number of elements to copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy all of the elements of `arr1` to `arr2` we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters of this method are detailed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | The source array |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | The starting index in the source array |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | The destination array |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | The starting index in the destination array |'
  prefs: []
  type: TYPE_TB
- en: '| `5` | The number of elements to copy |'
  prefs: []
  type: TYPE_TB
- en: 'The next sequence copies the first three elements of `arr1` to the last three
    elements of `arr2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also copy part of one array to other positions within the same array.
    Here we copy the first two elements to the last two elements of the `arr1` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There are numerous opportunities for exceptions to occur when using this technique.
    If either array reference is null, a `NullPointerException` exception is thrown.
    If the array indexes are invalid, then we will get a `IndexOutOfBoundsException`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `arraycopy` method will copy the specified elements of the source array
    to the corresponding element of the destination array. There are two possible
    results depending on the data type of the array. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the array element type is a primitive data type, then the two arrays are
    effectively identical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the array element type is a reference, then both arrays will be identical
    but they will both reference the same objects. This is usually not the effect
    anticipated or desired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code sequence, an attempt is made to create an identical copy
    of the `StringBuilder` array, `arr3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `arr4` contains the same object reference variables used by `arr3`.
    The corresponding element of both arrays reference the same object. The creation
    of an identical array with references to distinct strings is achieved with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We created a new `StringBuilder` object for-each element of the destination
    array. This approach is necessary if a deep copy is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Arrays.copyOf method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Arrays` class'' `copyOf` method will create a new array based on an existing
    array. The first argument of the method specifies the original array. Its second
    argument specifies how many elements to copy. In the following example, we create
    a new array based on the first three elements of `arr1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The new array can be larger than the original array as illustrated with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The last five elements of `arr2` will be padded with zeros.
  prefs: []
  type: TYPE_NORMAL
- en: If the array is an array of objects, a copy of the original object is assigned
    to the new array.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Arrays.copyOfRange method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Arrays` class'' `copyOfRange` method will create a new array based on
    a sub-range of elements in an existing array. The first argument of the method
    specifies the original array. Its second argument specifies the beginning index
    and the last argument specifies the ending index exclusive. In the following example,
    we create a new array based on the last two elements of `arr1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the last argument is not a valid index for the `arr1` array. This
    works here because the last argument is exclusive. It does not include that element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, if we specify a value such as `8` in the next example, the new array
    is padded with zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Using the clone method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also use the `Object` class'' `clone` method to create a copy of an
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: However, this only makes a shallow copy of the original object. With an array
    of primitives such as the above integer array, this is not a problem. With an
    array of references to objects, both arrays will reference the same objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the copying techniques introduced in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Technique | Comment |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Simple element-by-element copy | Tedious but can implement either a shallow
    or deep copy |'
  prefs: []
  type: TYPE_TB
- en: '| Using the `System.arraycopy` method | Performs a shallow copy |'
  prefs: []
  type: TYPE_TB
- en: '| Using the `Arrays.copyOf` method | Performs a deep copy of the entire array
    |'
  prefs: []
  type: TYPE_TB
- en: '| Using the `Arrays.copyOfRange` method | Performs a deep copy of part of an
    array |'
  prefs: []
  type: TYPE_TB
- en: '| Using the `clone` method | Performs a shallow copy |'
  prefs: []
  type: TYPE_TB
- en: Passing arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage of passing an array to a method is that it allows us to perform
    the same operation against more than one array. To pass an array to a method,
    we use the array name in the method call and declare a reference to the passed
    array in the method. This is illustrated below with a call to the `displayArray`
    method. This method simply displays the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are "passing a reference" to the `arr2` array "by value". That
    is, if we want, we can read and write the elements of the `arr2` array in the
    method. However, if we modify the `arr` parameter, the original `arr2` variable
    is not modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the method in the following code that attempts to change what the
    `arr2` reference variable points to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute this code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `arr` was changed but the value of `arr2` was not changed. The
    following diagram should help clarify this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing arrays](img/7324_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using command-line arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a Java application executes, the first method that is executed is the `main`
    method. This method passes an argument, an array of `String` objects called `args`.
    These strings correspond to those provided on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The `length` property of a Java array will tell us how many command-line arguments
    were used. The first argument of the array will contain the first command-line
    parameter. The second will contain the second command-line parameter, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `CommandLineDemo` application illustrates the use of the `args`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider that the application is invoked with the following command-line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program would appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The Arrays class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `java.util.Arrays` class possesses several methods useful for working with
    arrays. Every method of the class is a static method which means that we do not
    have to create an instance of the `Arrays` class before we use its methods. The
    class is designed to work with arrays and perform common operations on arrays.
    The types of operations available include:'
  prefs: []
  type: TYPE_NORMAL
- en: Returning a `List` based on an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a binary search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making copies of an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the equality of two arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have seen the use of several of these techniques in earlier sections. Here
    we will demonstrate the use of the `asList` , `fill`, `toString` , and `deepToString`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following declarations. We will declare an integer array and then
    an array list. Two strings will be added to the `ArrayList` object. We will also
    create an array of mixed objects and an array of strings. The `ArrayList` class
    is discussed in more detail in the *ArrayList* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will fill the integer array with the number `5` using the `fill` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `asList` , `toString` , and `deepToString` methods are then used against
    these arrays, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `asList` method takes its array argument and returns a `java.util.List`
    object representing the array. If either the array or the list is modified, their
    corresponding elements are modified. This is demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `toString` method returns a string representation of the array. The `deepToString`
    method is intended to return a string representation of its array argument where
    the array is more complex. This was reflected in `arr2` which contains different
    objects including a list.
  prefs: []
  type: TYPE_NORMAL
- en: Key points to remember when using arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with arrays remember:'
  prefs: []
  type: TYPE_NORMAL
- en: Array indexes start at 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexes have to be integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array can hold primitive data types or objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays provide constant time random access which is an efficient way of accessing
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays provide good locality of reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays are more difficult to insert or remove elements than other data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An index to an invalid element is possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locality of reference refers to the idea that if one data item is accessed,
    it is likely that another nearby data item will also be accessed. This results
    in faster read and write operations and is an important concept in virtual operating
    systems. Accessing elements of an array can be faster than accessing elements
    of a linked list when the linked list is spread across the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when accessing elements of an array. If the array is not properly
    initialized, then the element being indexed may be invalid resulting in a run-time
    or logic error.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Collections Framework was introduced in Java 2 as a set of interfaces and
    classes that are superior to many of the interfaces and classes found in the earlier
    `java.util` package such as `Vector`, `Stack`, and `HashTable`. These interfaces
    and classes should always be used instead of the older ones whenever possible.
    Many of the Collection Framework interfaces and classes are summarized in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Interface | Class |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Set | `HashSet``TreeSet` |'
  prefs: []
  type: TYPE_TB
- en: '| List | `ArrayList``LinkedList` |'
  prefs: []
  type: TYPE_TB
- en: '| Map | `HashMap``TreeMap` |'
  prefs: []
  type: TYPE_TB
- en: The Collection Framework is covered in more detail at [http://java.sun.com/developer/onlineTraining/collections/Collection.html](http://java.sun.com/developer/onlineTraining/collections/Collection.html).
    Here, we will address the `ArrayList` class as it is a certification topic. It
    is recommended that the `ArrayList` class be used when a `List` is needed. As
    we will see, iterators are used with the `ArrayList` to support traversal of the
    list. We will start our discussion with coverage of this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iterators provide a means of traversing a set of data. It can be used with
    arrays and various classes in the Collection Framework. The `Iterator` interface
    supports the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`next`: This method returns the next element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasNext`: This method returns `true` if there are additional elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove`: This method removes the element from the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `remove` method is an optional `Iterator` method. If an attempt is made
    to use this method and the implementation of the interface does not support this
    method, then an `UnsupportedOperationException` exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ListIterator` interface , when available, is an alternative to the `Iterator`
    interface. It uses the same methods and provides additional capabilities including:'
  prefs: []
  type: TYPE_NORMAL
- en: Traversal of the list in either direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modification of its elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to the element's position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The methods of the `ListIterator` interface include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`next`: This method returns the next element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`previous`: This method returns the previous element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasNext`: This method returns `true` if there are additional elements that
    follow the current one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasPrevious`: This method returns `true` if there are additional elements
    that precede the current one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nextIndex`: This method returns the index of the next element to be returned
    by the `next` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`previousIndex`: This method returns the index of the previous element to be
    returned by the `previous` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add`: This method inserts an element into the list (optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove`: This method removes the element from the list (optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set`: This method replaces an element in the list (optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ArrayList
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ArrayList` class has several useful characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: It is flexible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grows as needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possesses many useful methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access is performed in constant time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertion/deletion is performed in linear time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be traversed with indexes, for-each loops, or iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArrayList` uses an array internally. When it needs to grow, elements are copied
    from the old array to the new array.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ArrayList` class is not synchronized. When an iterator is obtained for
    a `ArrayList` object, it is susceptible to possible simultaneous overwrites with
    loss of data if modified in a concurrent fashion. When multiple threads access
    the same object, it is possible that they may all write to the object at the same
    time, that is, concurrently. When this simultaneous overwrite occurs, a `ConcurrentModificationException`
    exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ArrayList
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ArrayList` class possesses the following three constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: A default constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One that accepts a `Collection` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One that accepts an initial capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The capacity of a `ArrayList` object refers to how many elements the list can
    hold. When more elements need to be added and the list is full, the size of the
    list will be automatically increased. The initial capacity of a `ArrayList` created
    with its default constructor is `10`. The following example creates two lists,
    one with a capacity of `10` and the second with a capacity of `20`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ArrayList` class supports generics. Here, a list of strings is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We will use `list3` in the examples that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several methods available for adding elements to an `ArrayList`.
    They can be placed into one of the following two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Appends one or more elements to the end of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserts one or more elements at a position within the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The simplest case is illustrated here where a string is added to the end of
    `creatures`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the print statement follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert an element at the index after the first element we use an index of
    1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the code will verify the actions, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addAll` method can also be used with `Collections`, as illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the `cuddles` being placed after the second element in
    the list, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The `addAll` method can also be used without an index argument. In this case,
    the new elements are added to the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To retrieve an element at a given position, use the `get` method. This method
    takes a single integer index value. In the following example, we retrieve the
    third element of the list. Assuming that the creatures list contains `[Mutant,
    Godzilla, Tribbles, Ewoks, Alien, Zombie]`, the following statement will retrieve
    `Tribbles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The index of an element can be obtained using the `indexOf` method as illustrated
    in the next code sequence. If the element does not exist, the method will return
    a -1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this code will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `indexOf` method will return the index of the first element found. The `lastIndexOf`
    method will return the index of the last element found in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The `toArray` method will return an array of the objects in the list. In this
    example, the `creatures` list is returned and assigned to the `complete` array.
    If the array is not large enough, as is the case here, a new array is created
    and returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: There is also a `subList` method that returns part of the list given the starting
    and ending indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing a ArrayList object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To traverse a `ArrayList` object we can use one of several approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: A simple for statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A for-each statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Iterator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ListIterator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use a for loop but it is more prone to error. The following code will
    display the list from the beginning to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the `size` method, which returns the number of elements in
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The for-each statement is the simplest approach, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iterator` method returns a `Iterator` object, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ListIterator` method returns a `ListIterator` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'All four of these techniques will produce the same output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add the following code to the end of the previous code sequence, we can
    traverse the list in reverse order, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Sorting a ArrayList object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While there are no specific methods in the `ArrayList` class for sorting, we
    can use the `Arrays` class'' `sort` method, as illustrated in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: An overloaded version of this method takes a `Comparator` object. This object
    determines how comparisons are made.
  prefs: []
  type: TYPE_NORMAL
- en: Other ArrayList methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can modify an element of a list using the `set` method. This method takes
    an index of the element to replace, and the new value. For example, to replace
    the first element of the creatures list with the string `Ghoul` we can use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The replacement is verified by the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We can remove all or some of the elements of a list. The `clear` method will
    remove all elements. The `remove` method removes a single element and the `removeAll`
    method removes all values in a given collection from the list. The following code
    sequence illustrates these methods. The `cuddles` `ArrayList` was defined in the
    *Adding elements* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'While `ArrayList` is a powerful class, arrays should still be used if:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a known number of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a small fixed upper bound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive data types are needed for efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No elements need to be inserted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulating collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using a collection within a class, hide the collection to prevent inadvertent
    modification of the collection. For example, if a class encapsulates an `ArrayList`
    of `Books`, then public methods should be provided to permit access to the collection.
    In the following example, a class called `Library` hides an `ArrayList` of `Book`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a good example of data encapsulation. However, be sure to not inadvertently
    expose private data. In the `getBook` method we returned a reference to the book.
    This reference allows the user to modify the book. If this modification should
    not be allowed, then a copy of the book can be returned instead, as shown below.
    This assumes that the `Book` class has a constructor that makes a new copy of
    a book based upon the constructor''s argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The same problem occurs with the `getBooks` method. It returns a reference
    to the private `books` reference variable of the `Library` class. This method
    can be replaced with the following implementation to ensure proper data encapsulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we examined the creation and use of arrays and instances of
    the `ArrayList` class. We also detailed the use of the `Arrays` class in support
    of various array operations.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays contain one or more dimensions and are treated as objects. Care must
    be taken while using arrays to avoid problems accessing their elements. Problems
    can be avoided with a good understanding of how arrays are allocated in memory
    and of how to perform various operations, such as copying and comparing arrays,
    on them. Arrays are useful when we need a list of a fixed size as it allows efficient
    access of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: The `Arrays` class provides a number of static methods that support arrays.
    For example, we can use the `Arrays` class to make copies of arrays, sort arrays,
    and fill arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The `ArrayList` class provides an alternate approach for dealing with lists
    of data. It provides numerous methods for manipulating a list and will grow as
    needed when new elements are added to the list. This is one of its primary advantages
    over arrays. As with most data structures, it is important to encapsulate information
    in a class to help reduce the complexity of software development.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about arrays, we're ready to look more carefully at the
    various looping constructs available in Java. We will examine these constructs
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Collections Framework introduced several new interfaces and classes to replace
    older versions in the `java.util` package. We examined the `ArrayList` class and
    its methods used to manipulate its elements. The `ArrayList` class is more flexible
    than an array and is particularly useful for inserting and removing elements.
  prefs: []
  type: TYPE_NORMAL
- en: Certification objectives covered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we covered the following certification objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Using one-dimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multidimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring and using `ArrayList`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following statements will compile without an error?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `int arr[];`
  prefs: []
  type: TYPE_NORMAL
- en: b. `int arr[5];`
  prefs: []
  type: TYPE_NORMAL
- en: c. `int arr[5] = {1,2,3,4,5};`
  prefs: []
  type: TYPE_NORMAL
- en: d. `int arr[] = {1,2,3,4,5};`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following declares an array that supports two rows and a variable
    number of columns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `int arr[][] = new int[2][3];`
  prefs: []
  type: TYPE_NORMAL
- en: b. `int arr[][] = new int[2][];`
  prefs: []
  type: TYPE_NORMAL
- en: c. `int arr[][] = new int[][];`
  prefs: []
  type: TYPE_NORMAL
- en: d. `int arr[][] = new int[][3];`
  prefs: []
  type: TYPE_NORMAL
- en: Given the following code, which of the following statements can be used to determine
    if `cat` can be found in the list?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: a. `list.contains("cat")`
  prefs: []
  type: TYPE_NORMAL
- en: b. `list.hasObject("cat")`
  prefs: []
  type: TYPE_NORMAL
- en: c. `list.indexOf("cat")`
  prefs: []
  type: TYPE_NORMAL
- en: d. `list.indexOf(1)`
  prefs: []
  type: TYPE_NORMAL
