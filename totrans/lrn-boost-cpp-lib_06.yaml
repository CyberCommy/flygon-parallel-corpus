- en: Chapter 6. Bimap and Multi-index Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Standard Library has ordered and unordered associative containers for storing
    objects and looking them up efficiently using some **key**. The key could be a
    text type, numeric type, or first-class objects. For ordered containers such as
    `std::set` and `std::map`, the keys must have a well-defined ordering relation
    that allows any set of keys to be sorted. For unordered containers, it must be
    possible to compute an integer hash value for each key, and additionally, determine
    whether any two keys are equivalent for some definition of equivalence. The key
    represents an index or criterion for lookup, and all the Standard Library associative
    containers support lookup using only a single criterion. In other words, you cannot
    efficiently look up objects using multiple, independent criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us suppose you have a type called `PersonEntry` to describe a person. The
    `PersonEntry` type has attributes like name, age, phone number, and so on. You
    would end up storing several objects of type `PersonEntry` in containers and at
    different times, you may need to look up `PersonEntry` objects using different
    attributes like name, age, phone number, and so on. While the Standard Library
    containers do an admirable job for a lot of common tasks involving collections,
    they cut a sorry figure when you want a data structure that stores data and searches
    them efficiently based on multiple criteria. Boost provides a small number of
    generic containers geared for this need, two of which we study in this chapter.
    The chapter is divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Containers for multi-criteria lookups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost Multi-index containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost Bimap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers for multi-criteria lookups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider a collection of objects of type `PersonEntry`, as defined in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An object of this type represents an entry in a telephone directory perhaps.
    How would you design a data structure that allows you to look up a person by name?
    We can use a `std::set` of `PersonEntry` objects for it, with an appropriate ordering
    relation defined for `PersonEntry`. Since we want to search by name, we should
    define the ordering relationship by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `std::set` stores only unique elements and any two `PersonEntry` objects
    with the same name would be considered duplicates. Since namesakes are common
    in real life, we should choose a container that allows duplicates, that is, `std::multiset`.
    We can then insert elements and look them up by name using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 6.1: Lookups using multimaps**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We create two `PersonEntry` objects of two people with the same name (lines
    13-15) and insert them into a `multiset` (lines 16-17). The objects are initialized
    using C++11's nifty uniform initializer syntax. We then look up the name `"Arindam
    Mukherjee"`. The correct way to do this in a `multiset` is to determine the range
    of matching elements. The `lower_bound` member function returns the iterator to
    the first matching element (lines 18-19). The `upper_bound` member function returns
    the iterator to the first element to follow the last matching element (lines 20-21).
    If there are no matching elements, both return the iterator to the first element
    that would follow a matching element if there was one. We then iterate over the
    range defined by [low, high) and print all matching elements. If you noticed,
    we constructed temporary `PersonEntry` objects to perform the lookups. Now, it
    is perfectly reasonable to want to do a reverse lookup, given a phone number,
    and find out who it belongs to. How can we do this with the preceding arrangement?
    We could always perform a linear search through the container, or we could use
    a separate container of references to the `PersonEntry` objects in a dictionary
    that stores objects ordered by phone number; neither method is particularly elegant
    or efficient. This is where the Boost Multi-index library steps in.
  prefs: []
  type: TYPE_NORMAL
- en: Boost Multi-index containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Boost Multi-index library actually provides a single generic container
    called `multi_index_container` to store your objects and options to specify one
    or more indexes, using which you may look up the objects. Each index will use
    a different criterion on potentially different fields of the object. The indexes
    are defined and specified as template parameters to the container and this does
    make the container declaration a little daunting. But, this ultimately makes the
    container implementation tighter with a lot of compile-time optimizations. Indeed,
    the hardest part of using these containers is really getting their declaration
    right; so let us deconstruct a declaration of such a container of `PersonEntry`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 6.2: Defining multi-index containers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we create a typedef for a `multi_index_container`
    of the `PersonEntry` objects (lines 9-10). We use a single index called `person_index`
    that we defined earlier (line 8). The `person_index` is the type of index that
    will be used for looking up objects in the container. It is defined as `ordered_non_unique<identity<PersonEntry>>`.
    This means that the index keeps the `PersonEntry` objects ordered by their defined
    ordering relationship and allows for duplicates (non-unique). This index provides
    the same semantics as `std::multiset<PersonEntry>`. Now, if we want to look up
    `PersonEntry` objects by telephone number, we would need to define additional
    indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 6.3: Defining multi-index containers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we define two index types: an index type `by_name` for looking up objects
    by the name field and a second index type `phone_index` for looking up by phone
    numbers (lines 9-12). We use the `member` template to indicate that we want an
    index based on a data member of `PersonEntry` called `name` or `phoneNumber` of
    type `std::string`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass a specialization of the `indexed_by` template to the `multi_index_container`
    template as an argument. All the indexes that we want to enable are listed as
    arguments of this specialization (lines 15-16). Let us now see these types in
    action. We assume that all the header files from the listing 6.3 are included
    and all the types defined in listing 6.3 are available in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 6.4: Using Boost Multi-index containers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a multi-index container of `PersonEntry` objects
    indexed by `name` and `phoneNumber` fields, as defined in listing 6.3\. We insert
    three `PersonEntry` objects (lines 8-10). We then perform a lookup by name on
    the container (lines 12-13). The container's behavior defaults to that of the
    first index, which is `by_name` (listing 6.3, lines 9-10). Thus, the call to the
    `find` method uses the first index (`by_name`) for the lookup. To look up by phone
    numbers, we need to get a reference to the second index. To do this, we use the
    `get` member template of `multi_index_container`, passing it `1`, which is the
    zero-based position of the `by_phone` index (line 15). We can then call methods
    on the returned index reference just like on `std::set` (lines 16-18). We can
    even iterate through the index using a range-based for-loop construct (line 21)
    or using actual iterators.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example both indexes are ordered, which requires that whichever
    element they are based on (`name` or `phoneNumber` fields) should define an ordering
    relationship. In this case, both fields are of type `std::string`, so the ordering
    relationship is well-defined. But if it is not available, we need to roll our
    own definition of ordering as an overloaded `operator<`. Alternatively, we can
    define a functor to perform the ordering comparisons between two elements of the
    type in question and pass its type as a trailing argument to the `member` template.
    The online documentation for Boost Multi-index has more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'If specifying numeric positions for index types seems less than ideal, you
    can use tags instead. This changes the declaration of the `by_phone` index a wee
    bit but makes for more readable code where it matters. Here is how to do it for
    the `phone_index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we define an empty struct called `phone_tag` just
    to act as a tag for a particular index (line 1). We then define the index type
    `by_phone`, as specialization of the `ordered_unique` template. The first parameter
    of the `ordered_unique` template specifies the tag to use for retrieving this
    index (`phone_tag`). The second template parameter to `ordered_unique` is `member<PersonEntry,
    std::string, &PersonEntry::phoneNumber>`; it specifies that the `phoneNumber`
    member of each `PersonEntry` object is to be used as the key for this index, and
    that it is of type `std::string` (lines 2-3). Finally, we access the index by
    calling the `get` member template of `phonedir`, but pass it the tag `phone_tag`
    rather than a numeric index (line 5).
  prefs: []
  type: TYPE_NORMAL
- en: Index types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ordered_unique` and `ordered_non_unique` indexes correspond to the semantics
    of `std::set` and `std::multiset` respectively. Using these indexes, you not only
    get logarithmic lookup and insertions, but can also perform an ordered traversal
    of the container's elements. If you do not care about ordered traversal, you can
    also use `hashed_unique` and `hashed_non_unique` indexes, which provide excellent
    insertion and lookup performance (constant expected time). Naturally, the hashed
    indexes do not require any ordering relationship to be defined on the elements
    but require a way to generate their hash values. This can be enabled using the
    techniques shown for unordered containers in listing 5.11.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it is important to get objects in the order of insertion and also
    perform lookups based on different criteria. To get objects in the order in which
    they were inserted, we need to use the `sequenced` index. Sequenced indexes do
    not take any arguments other than an optional tag. We can add the `sequenced<>`
    index to the `directory_t` type we defined in listing 6.3, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have passed a tag as a template argument to `sequenced` if we wanted
    to. If we also want a random access iterator to this sequence in insertion order,
    we may use the `random_access<>` index instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us suppose that you look up a `PersonEntry` by name using the `by_name`
    index and want to find out the position of the element in insertion order. Iterators
    are associated with an index and the iterator we have is associated with the `by_phone`
    index. Now you want an iterator to the same element on the `random_access` index
    as well. You can then compute the difference between that iterator and the beginning
    iterator of the `random_access` index to compute the ordinal position of the element.
    The general way to do this is to use the `project` member template of the `multi_index_container`,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 6.5: Using iterator projections**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We look up an element by name using the find member, which returns an iterator
    `it` to the element (line 21). We then get a reference to the random access index
    at index 2, using the `get` member template (line 22). Using the `project` member
    template of `phonedir`, we get the iterator corresponding to `it` in the `random_access`
    index (line 24). The returned iterator `rit` being a random access iterator, we
    compute the zero-based position of the element as the difference between `rit`
    and the begin iterator on `random_index`. If we had used a `sequenced<>` index
    in place of `random_access<>` (line 5), we would not be able to compute the position
    by computing the difference of the two iterators (line 26). Instead, we would
    need to use the `std::distance` Standard Library function to compute the offset
    between the beginning of the sequenced container and the looked up iterator. This
    would be of linear time complexity rather than constant.
  prefs: []
  type: TYPE_NORMAL
- en: Range lookups using lambda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes we want to find elements whose attributes fall in a certain range
    of values. Instead of using the `lower_bound` and `upper_bound` members of the
    `multi_index_container` and its indexes, we can perform range lookups using a
    more expressive syntax that uses Boost Lambda. Lambda expressions are discussed
    later in this book (see [Chapter 7](ch07.html "Chapter 7. Higher Order and Compile-time
    Programming"), *Higher Order and Compile-time Programming*), but you really do
    not need to understand any of it to follow the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 6.6: Expressive range lookup**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `multi_index_container` type called `directory_t` defined in listing
    6.3, which uses the indexes `by_name` and `by_phone`, we define a multi-index
    container of `PersonEntry` objects called `phonedir` (line 8) and insert four
    entries into it (lines 10-17). We then look for all entries with names lexically
    greater or equal to `"Ar"` and lexically less than `"D"`. To do this, we first
    get the appropriate index, the `by_name` index, which is the zeroth index or default
    index. We then call the `range` member function on this index, passing it the
    two criteria for determining the ends of the range using a lambda placeholder
    `_1` (`boost::lambda::_1`). Semantically, `std::string("Ar") <= _1` says we are
    looking for strings, which are lexically not smaller than `"Ar"`, and `std::string("D")
    > _1` says we are looking for strings that are lexically smaller than `"D"`. These
    two criteria together determine which elements fall in the range and which ones
    fall outside. Turns out, my two namesakes are in the range while their more famous
    friends are out. This program prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Insertions and updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can add new elements into the `multi_index_container` and erase them using
    the container interface or any of its indexes. How you add and erase elements
    via the index interfaces depends on the type of the index. How you add and erase
    them via the container's public interface is defined by the type of the first
    index of the container.
  prefs: []
  type: TYPE_NORMAL
- en: We already used the `insert` member function in previous examples to add a single
    element to `multi_index_containers`. We used the overload of `insert` that takes
    a single object and adds it to the container at the appropriate location. We may
    also use this method on an individual index of type `ordered_unique`, `ordered_non_unique`,
    `hashed_unique`, or `hashed_non_unique`. But on the `random_access` or `sequenced`
    indexes, and on containers that use such an index as their first index, a single
    argument overload of `insert` is not available. You may use `push_back` or `push_front`
    to add elements to the ends. You may also use an overload of `insert` that takes
    the iterator to the position to insert at as an additional argument. Likewise
    for `erase`, with `sequenced<>` and `random_access<>` indexes, you can only use
    overloads that specify the element to erase with an iterator; while with ordered
    and hashed indexes, you can actually use an overload that takes a value to look
    up and erases all matching elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also update values in a multi-index container using either the `replace`
    or the `modify` method. The following snippet illustrates these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 6.7: Inserts, erases and updates on multi-index containers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create a multi-index container of `PersonEntry` objects
    with three indexes: the default `random_access` index, an ordered non-unique index
    on the `name` field, and an ordered unique index on the `phoneNumber` field. We
    first use the public interface of the container to add a `PersonEntry` record
    using the `push_back` method (lines 19-20). We then access a reference to the
    phone index (line 21) and name index (line 24). We add a second record using the
    single argument `insert` overload on the phone index (line 22), and a third record
    using the same overload on the name index (lines 25-26). Next, we use the `push_front`
    method on the container to add a fourth record (lines 27-28), which puts this
    record at the front or beginning of the `random_access` index.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then call the single argument `erase` overload on the name index passing
    it the string to match against the `name` field (line 30). This erases the two
    matching records (inserted on lines 22-23 and 25-26). We then erase the record
    at the beginning of the container (line 31), which deletes the `"Ace Ventura"`
    record. The sole remaining record (line 32) is printed to the console (line 33)
    and this should print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next we use `push_back` to add another record for a person called `Tarzan` (line
    35-36). Interestingly, Mr. Tarzan has the same phone number as Dr. Dolittle. But
    because there is a unique index on the `phoneNumber` field, this insertion does
    not succeed and the container still retains the record of Dr. Dolittle (lines
    37, 38). We fix this by adding a new record for Tarzan with a unique phone number
    (lines 40-41), which succeeds (line 42).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we access the record for Tarzan, which would be the second record in insertion
    order, and create a copy of that object (line 44). We then change the `phoneNumber`
    field of the `tarzan` object to the same number as Dr. Dolittle's. We try to replace
    the object for Tarzan in the container with this modified object using the `replace`
    member function, but because the replacement violates the uniqueness constraint
    on the phone number, the `replace` method fails to update the record returning
    a Boolean false. We can also use the more efficient `modify` method instead of
    `replace`. We will not cover `modify` in this book; the online documentation is
    a good place to look for reference.
  prefs: []
  type: TYPE_NORMAL
- en: Each insertion updates all indexes and like the associative containers and `std::list`
    from the Standard Library, they do not invalidate any existing iterators, not
    even those generated from other indexes. Erase operations invalidate only iterators
    to the erased elements.
  prefs: []
  type: TYPE_NORMAL
- en: Boost Bimap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storing objects and looking them up using a key is a very common programming
    chore, and every language has some measure of support for it through native constructs
    or libraries in the form of dictionaries or lookup tables. In C++, the `std::map`
    and `std::multimap` containers (and their unordered variants) provide the lookup
    table abstraction. Traditionally, such libraries support lookups in one direction.
    Given a key you can look up a value and this is adequate for many cases. But sometimes,
    we also need a way to look up a key given a value, and the standard library associative
    containers are of little help in such cases; what we need there is the Boost Bimap
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Boost Bimap library provides bimaps or bidirectional map data structures
    that allow lookups using keys as well as values. Let us start with an example
    to get a feel of how it works. We will use a Boost bimap to store names of countries
    and territories, with their capitals:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 6.8: Using a bimap**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The type `bimap<string, string>` that will hold names of the countries and map
    them to the capitals is named `string_bimap_t` (line 8). We define a bimap of
    this type called `countryCapitals` (line 12), and add the names of five countries
    and their capitals using the `insert` adaptor from Boost Assign (lines 14-18).
  prefs: []
  type: TYPE_NORMAL
- en: 'A bimap defines a relation or mapping between values in two containers: a *left
    container* consisting of country names and a *right container* consisting of names
    of capital cities. We can get a *left view* of the bimap that maps the keys (country
    names) to values (capitals) and a *right view* that maps the values (capitals)
    to the keys (country names). These represent two alternative views of the bimap.
    We can access these two alternate views using the members `left` and `right` of
    the bimap (lines 20, 28). These two views have a very similar public interface
    as `std::map` or, to borrow a succinct description from the online documentation,
    they are *signature-compatible* with `std::map`.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, there is a one-to-one mapping between the set of countries and the set
    of capitals. We now try to insert an entry for Chile's second capital, Valparaiso
    (lines 37-38). It fails (lines 39-40) because, just like `std::map` and unlike
    `std::multimap`, the keys must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Now consider what happens if we try to insert a new entry into the bimap (lines
    42-43) for a new country `Norfolk Island` (a territory under Australia), whose
    capital `Kingston` shares its name with that of another country on the map (`Jamaica`).
    Unlike what would have happened in a `std::map`, the insertion fails and there
    is no change in the number of entries in the bimap (lines 44-45). In this case,
    the values too must be unique, which is not a constraint for `std::map`. But what
    if we actually want to represent a one-to-many or many-to-many kind of a relation
    using Boost Bimap? We will see the options we have in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Collection types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default behavior of Boost Bimap is one-to-one mapping, that is, unique
    keys and unique values. But, we can support one-to-many and many-to-many mappings
    by varying a couple of template parameters. To illustrate such use with an example,
    we use a map of given names to nicknames (listing 6.9). A given name can sometimes
    be associated with multiple nicknames and a nickname too can occasionally apply
    to multiple given names. So we would like to model a many-to-many relationship.
    To define a bimap that allows many-to-many relations, we have to choose a collection
    type for the left and right containers different from the default (which has set
    semantics). Since both names and nicknames can be non-unique, both the left and
    right containers should have the semantics of multisets instead. Boost Bimap provides
    collection type specifiers (refer to the following table), which can be used as
    template arguments to the `boost::bimap` template. Depending on the collection
    type, the semantics of the left or right view of the bimap also change. Here is
    a short table summarizing the available collection types, their semantics, and
    the corresponding views (based on the online documentation at [www.boost.org](http://www.boost.org)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Collection type | Semantics | View type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `set_of` | Ordered, unique. | map |'
  prefs: []
  type: TYPE_TB
- en: '| `multiset_of` | Ordered, non-unique. | multimap |'
  prefs: []
  type: TYPE_TB
- en: '| `unordered_set_of` | Hashed, unique. | unordered_map |'
  prefs: []
  type: TYPE_TB
- en: '| `unordered_multiset_of` | Hashed, non-unique. | unordered_multimap |'
  prefs: []
  type: TYPE_TB
- en: '| `unconstrained_set_of` | Unconstrained. | No view available |'
  prefs: []
  type: TYPE_TB
- en: '| `list_of` | Non-ordered, non-unique. | Linked list of key-value pairs |'
  prefs: []
  type: TYPE_TB
- en: '| `vector_of` | Non-ordered, non-unique, random access sequence. | Vector of
    key-value pairs |'
  prefs: []
  type: TYPE_TB
- en: 'Note that the collection types are defined in the `boost::bimaps` namespace
    and each collection type comes in its own header, which must be included separately.
    The following example shows you how to use collection types in conjunction with
    the `boost::bimap` template to define many-to-many relations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 6.9: Bimaps for many-to-many relations**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The specific bimap container type we need to use is `bimap<multiset_of<string>`,
    `multiset_of<string>>` (lines 10-11). Using `bimap<string, string>` would have
    given us a one-to-one mapping. If we wanted a one-to-many relation, we could have
    used `bimap<set_of<string>`, `multiset_of<string>>`, or simply `bimap<string,
    multiset_of<string>>` since `set_of` is the default collection type used when
    we do not specify one. Note that in the code, we use `boostbi` as an alias for
    the `boost::bimaps` namespace (line 8).
  prefs: []
  type: TYPE_NORMAL
- en: We define the `namesShortNames` bimap to hold the name and nickname entries
    (line 15).We add some entries, including a duplicate name `Robert` and a duplicate
    nickname `Ted` (lines 17-22). Using the `insert` member function of bimap, add
    one more duplicate name `William` (lines 25-26) and one more duplicate nickname
    `Chris` (lines 29-30); both insertions succeed.
  prefs: []
  type: TYPE_NORMAL
- en: We access the left view with names as keys and the right view with nicknames
    as keys, using the `left` and `right` members of bimap (lines 33, 45). Both the
    left and right views are signature compatible with `std::multimap`, and we perform
    lookups on them just as we would on `std::multimaps`. Thus, given a name, to find
    the first matching entry for it, we use the `lower_bound` member function (line
    35). To find the first entry lexically greater than the name, we use the `upper_bound`
    member function (line 37).We can iterate over the range of matching entries using
    the iterators returned by these two functions (line 39). In general, `lower_bound`
    returns the first element with name lexically equal or greater than the passed
    key; so if there are no matching elements, `lower_bound` and `upper_bound` return
    the same iterator. We can also use the `equal_range` function, which returns both
    the lower bound and upper bound iterators as an iterator pair (line 47).
  prefs: []
  type: TYPE_NORMAL
- en: If we did not care about ordered traversal of the maps, we could have used `unordered_set_of`
    or `unordered_multiset_of` collection types. Like with all unordered containers,
    the notion of equality of elements and a mechanism to compute the hash values
    of the elements must be available.
  prefs: []
  type: TYPE_NORMAL
- en: A container such as `std::map<T, U>`, has the same semantics as `bimap<T, unconstrained_set_of<U>>`.
    The `unconstrained_set_of` collection type does not provide a way to iterate through
    elements in it or look them up, and does not require the elements to be unique.
    While `bimap<T, multiset_of<U>>` allows non-unique values, it also supports looking
    up by values, something that `std::map` does not.
  prefs: []
  type: TYPE_NORMAL
- en: The `list_of` and `vector_of` collection types, like the `unconstrained_set_of`
    collection type, do not enforce either uniqueness or any structure that allows
    look up. However, they can be iterated through element by element, unlike `unconstrained_set_of`
    and thus, you can use a Standard Library algorithm like `std::find` to perform
    linear searches. `vector_of` provides random access. One can sort the entities
    it contains using its `sort` member function following which one could perform
    binary searches using `std::binary_search`.
  prefs: []
  type: TYPE_NORMAL
- en: More ways to use bimaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to make the use of bimaps more expressive. In this section,
    we explore a few of these.
  prefs: []
  type: TYPE_NORMAL
- en: Tagged access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of using `left` and `right` to access each of the two opposing views
    in the container, you may like to use a more descriptive name to access them.
    You can do this using tags or empty structures that are used as markers. This
    is very similar to how indexes in Boost''s multi-index containers are accessed
    by a tag instead of a numeric position. The following code snippet illustrates
    this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We define an empty struct for a tag for each view we want to access by name
    (lines 1-2). We then define the bimap container type, tagging the individual collections
    with our tags using the `tagged` template (lines 6, 8). We finally use the `by`
    member template to access the individual views. While the syntax for using tags
    is not the most straightforward, the expressiveness of accessing views using `by<tag>`
    can certainly make your code clearer and less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches on views can be written more succinctly using the `range` member function
    and Boost Lambda placeholders, just like we did with Boost Multi-index. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The call to the `range` member function of the `right` view returns a Boost.Range
    object called `range`, which is really a pair of iterators (lines 7-8). We extract
    the two individual iterators (line 10) and then run through the returned range,
    printing the nicknames and the full names (lines 10-11).With range-aware algorithms,
    we can simply pass the range object without bothering to extract iterators from
    them. If you want to constrain only one end of the range, you can use `boost::bimaps::unbounded`
    for the other end.
  prefs: []
  type: TYPE_NORMAL
- en: Projections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From an iterator on one view, you can get to an iterator on another view using
    the `project` member template or the `project_left`/`project_right` member functions.
    Let us suppose that given a name, you want to find out all other names that share
    the same nickname. Here is one way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We first obtain an iterator to a matching name by using the `find` member function
    on the `names` view (line 1).We then project this iterator to the nicknames view
    using the `project` member template. If we do not use tagged keys and values,
    we should use `project_left` and `project_right` member functions instead, depending
    on which view we want to project to. This returns an iterator to the same element
    on the nicknames view (line 2). Next, using the `range` member function, we find
    all entries whose nickname equals `i2->first` (lines 4-5). We then print the pairs
    of nicknames by looping through the iterator range returned by `range` (lines
    7-9).
  prefs: []
  type: TYPE_NORMAL
- en: There are several other useful features of Boost Bimap, including a view of
    the container as a collection of relations between pairs of elements and the ability
    to modify keys and values in a bimap, in-place. The online Bimap documentation
    on [www.boost.org](http://www.boost.org) is comprehensive and you should refer
    to it for more details on these features.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For multiple choice questions, choose all options that apply:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ordered_non_unique` index on Boost `multi_index_container` has the semantics
    of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `std::set`
  prefs: []
  type: TYPE_NORMAL
- en: b. `std::multiset`
  prefs: []
  type: TYPE_NORMAL
- en: c. `std::unordered_set`
  prefs: []
  type: TYPE_NORMAL
- en: d. `std::unordered_multiset`
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an element in a `multi_index_container` will only invalidate the iterator
    to the deleted element, irrespective of the index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. True
  prefs: []
  type: TYPE_NORMAL
- en: b. False
  prefs: []
  type: TYPE_NORMAL
- en: c. Depends on the type of index
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following bimap types has semantics equivalent to a `multimap<T,
    U>`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `bimap<T, multiset_of<U>>`
  prefs: []
  type: TYPE_NORMAL
- en: b. `bimap<multiset_of<T>, U>`
  prefs: []
  type: TYPE_NORMAL
- en: c. `bimap<multiset_of<T>, unconstrained_set_of<U>>`
  prefs: []
  type: TYPE_NORMAL
- en: d. `bimap<multiset_of<T>, multiset_if<U>>`
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on containers specialized for looking up objects
    based on multiple criteria. Specifically, we looked at Boost Bimap which is a
    bidirectional map object, whose keys and values can both be looked up efficiently.
    We also looked at Boost Multi-index containers, which are generic associative
    containers with multiple associated indexes, each assisting the efficient look
    up of an object on one criterion.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we change gears to look at functional composition and metaprogramming
    techniques that enable us to write powerful and expressive applications with excellent
    runtime performance.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multi-index modify method: [http://www.boost.org/doc/libs/release/libs/multi_index/doc/reference/ord_indices.html#modif](http://www.boost.org/doc/libs/release/libs/multi_index/doc/reference/ord_indices.html#modif)'
  prefs: []
  type: TYPE_NORMAL
