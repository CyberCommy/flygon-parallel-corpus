- en: Chapter 3. Audio Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to load and play audio files in FMOD. This
    time, we will explore some of the ways in which we can control the playback of
    those files. We will start with controlling the playback flow, by stopping the
    sound on demand, or seeking to different points in the audio file. Then we will
    cover how to modify the main properties of sound that were described in [Chapter
    1](ch01.html "Chapter 1. Audio Concepts"), *Audio Concepts*, such as volume and
    pitch. We will also see how FMOD lets us group sounds into categories, in order
    to control multiple sounds at once.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we will expand the audio manager from the previous
    chapter, and make it more flexible and appropriate for use in games. This extended
    audio manager will provide a distinction between songs and sound effects, and
    handle each of them differently. We will see how to implement a fade in/fade out
    effect using simple volume manipulation, and how to add a variation to sound effects
    with a bit of randomness. The audio manager will also expose individual volume
    control for each category, making it easy to control from a game's option screen.
  prefs: []
  type: TYPE_NORMAL
- en: The channel handle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us start with a quick reminder from last chapter. When we use the `playSound()`
    method and pass the address of an `FMOD::Channel` pointer to the fourth parameter,
    we get a channel handle in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Through this handle, we can control the sound in many ways. This handle remains
    valid while the sound has not finished playing, or until we explicitly stop the
    sound. If we try to perform an operation on the channel after the sound has stopped,
    nothing happens. Instead, the method we called returns an error stating that the
    channel handle is invalid, or already in use by another sound, if that is the
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Something that might be confusing is that this FMOD channel is not the same
    type we talked back in [Chapter 1](ch01.html "Chapter 1. Audio Concepts"), *Audio
    Concepts*, when we discussed multi-channel audio. This is simply the name FMOD
    gives to each of the slots it uses to play sounds simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the playback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know how to play audio files, but it is also important to know how
    to stop them from playing. This is particularly important for looping sounds,
    because otherwise they would keep repeating forever. Usually, all we have to do
    is call the `stop()` method on the channel handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When a sound stops playing—because it reached the end and it is not set to
    loop, or because we stopped it ourselves—its channel becomes free for other sounds
    to use. This means that once we stop a sound there is no way to resume it. If
    we need to stop a sound temporarily, and resume it at a later time, we need to
    use the `setPaused()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Most methods that start with `set` are accompanied by an equivalent `get` method,
    such as `getPaused()`, that we can use to check the current value of that property.
    The following is a function that uses both methods in conjunction with each other,
    to toggle the paused state of a channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common operation is to seek the sound to a different position in the
    file. This is done with the `setPosition()` method, which takes a number representing
    the position we want to seek to, and the units we are specifying that position
    in (milliseconds in the following example). This is useful if we want to make
    a sound start from the beginning after unpausing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if we have a looping sound, we can use the `setLoopCount()` method
    to control the number of times the sound should loop. The following example shows
    some of the possible parameters (with the default being `-1` to loop endlessly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Controlling the volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will see how to control some of the main properties of sound, starting
    with its volume. This is done with a simple call to the `setVolume()` method,
    which takes a value ranging from `0` (silence) to `1` (maximum volume):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the way we paused the sound earlier, we can also silence it temporarily
    by using the `setMute()` method. Once we unmute the sound, it continues playing
    at its previous volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the methods preciously mentioned modify all channels of the sound simultaneously.
    On a sound with multiple channels, we can modify the volume of each channel separately,
    using the `setInputChannelMix()` method. This works for any amount of channels,
    by taking an array of volume levels as the first parameter, and the number of
    channels as the second. The following is an example for a stereo sound that mutes
    the left channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Controlling the pitch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Controlling the pitch is not as straightforward as controlling the volume.
    We already know that modifying the frequency of a sound, changes its pitch and
    the channel handle actually has a `setFrequency()` method just for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, it does not work the way some of us might expect. For example, the
    middle C note on a piano has a frequency of approximately 261.626 Hz, so we might
    expect that setting the frequency to that value, would make the sound assume a
    pitch close to the middle C note, but this is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand this problem, let us first turn our attention to the
    `getFrequency()` method. If we call this method on a channel with its original
    frequency, what we get in return is actually the sampling rate of the sound. This
    means that any frequency values that we set must be relative to this value, or
    in other words, that any values above the original sampling rate of the sound
    will increase its pitch, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could choose frequency values arbitrarily to get the desired effect, but
    an easier way to deal with pitch is in musical terms. In musical theory, the difference
    between two pitches is called an interval, with two of the most basic types of
    intervals being the octave, which corresponds to the distance between two consecutive
    notes with the same name, and the semitone, which corresponds to the distance
    between any two adjacent notes. The following are a few simple rules; we can modify
    an existing frequency by any of these intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: Every time we multiply/divide a frequency by two we get a new frequency that
    sounds one octave higher/lower
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time we multiply/divide a frequency by two and a half we get new a frequency
    that sounds one semitone higher/lower
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make things easier, here are two helper methods that perform the previous
    calculations, given a frequency, and the number of octaves or semitones to change.
    Notice the use of the `pow()` function to apply the previous multiplications and
    divisions the necessary amount of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these helper methods, it becomes simple to modify the pitch of a sound
    in FMOD in a meaningful way. For example, to decrease the pitch of a sound by
    3 semitones, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that changing the frequency of the sound will also have the side effect
    of speeding it up or slowing it down. There is a way to change the pitch of a
    sound without affecting its speed in FMOD, but it requires using a DSP effect,
    which is outside the scope of this chapter. We will briefly cover DSP effects
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the panning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we can also control the panning of some sounds, as long as they are
    mono or stereo, and 2D (as the FMOD engine automatically positions 3D sounds).
    When these conditions are met, you can change the panning of the sound using the
    `setPan()` method, which takes any value from `-1` (completely on the left) to
    `1` (completely on the right):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Panning works by modifying the volume of each output to give the illusion of
    position. However, the way FMOD calculates these values is different between mono
    and stereo sounds.
  prefs: []
  type: TYPE_NORMAL
- en: For mono sounds, the volume of each speaker follows a constant power curve that
    starts at 0 percent on one side, and goes to 100 percent on the other side, with
    the center position being at around 71 percent. This technique results in a smoother
    transition from one side to the other than using regular linear interpolation
    with 50 percent in the middle (because of the way we perceive sound intensity).
  prefs: []
  type: TYPE_NORMAL
- en: 'Stereo sounds, on the other hand, use a simpler formula referred to as setting
    the balance of the sound. Using this approach, both outputs are already at 100
    percent in the center position, and panning to one side only decreases the volume
    of the opposite channel in a linear fashion. The following figure demonstrates
    both the approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the panning](img/9099OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Grouping channels together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another great feature of FMOD is that it lets us add different channels to
    a group and control them simultaneously. This is very useful for video games,
    where sound tends to fall into categories (such as background music, sound effects,
    or speech). To create a channel group we use the `createChannelGroup()` method
    of the system object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can easily add a channel to a group using the `setChannelGroup()` method
    of the channel object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to add a group as a child of another group, creating a
    hierarchy. This is done using the `addGroup()` method of the parent channel group
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a global channel group called the master channel group, where
    every channel is placed every time you play a sound. You can get a reference to
    the master channel group by calling the `getMasterChannelGroup()` method of the
    system object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A good way to organize sounds in our games is to create a channel group for
    each category of sounds, and add all channel groups to the master channel group.
    This way we have control over individual categories, but we also have a way to
    control all sounds at once.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling groups of channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most operations supported by channel groups are the same that we have seen already
    for individual channels. In particular, we can stop, pause, or mute all channels
    in a group, and control their volume and pitch. The syntax for these operations
    is the same as before, except for pitch, which is done through a `setPitch()`
    method, that instead of a frequency, takes any value between `0` and `10`, and
    multiplies it by the current frequency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: All of these changes propagate down the channel group hierarchy automatically,
    without overwriting the values stored inside the channels. The way these values
    are applied depends on the type of operation.
  prefs: []
  type: TYPE_NORMAL
- en: For operations such as pausing and muting, the values in the channel group override
    the values in the children. This means that if the channel group is paused, every
    channel will remain paused regardless of their real values. On the other hand,
    if the channel group is not paused, the individual values in the channels are
    considered.
  prefs: []
  type: TYPE_NORMAL
- en: For volume and pitch, the values in the channel group are multiplied by the
    values in the children. For example, a channel at 80 percent volume inside a channel
    group at 50 percent volume will play at 40 percent volume instead.
  prefs: []
  type: TYPE_NORMAL
- en: Project 2 – improving the audio manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, we will build on top of the simple audio manager developed
    in the last chapter, and make it more flexible and game oriented. This time, besides
    loading and playing sounds, we will also be able to stop them and control their
    volume, which is necessary in almost every game. Furthermore, we will divide all
    sounds into two categories, each with its own set of features and behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sound effects (SFXs)**: Sounds that are loaded into memory and do not loop.
    Multiple instances can be played at the same time. Their volume and pitch can
    be controlled directly, or randomized within a user-defined range, to add variation
    to the sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Songs**: Sounds that are streamed and set to loop. Only one song can be playing
    at any time. Transitions between songs are handled smoothly by the audio manager
    with volume fades.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each game has its own needs, so you might want to create more categories, such
    as one for speech or ambient tracks.
  prefs: []
  type: TYPE_NORMAL
- en: Class definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once again, let us start with a listing of the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The class contains quite a few more members than the `SimpleAudioManager` class,
    but the basis is the same. To summarize the differences, we now have public methods
    to load, play, stop, and control the volume of sound effects and songs separately.
    Then, in the private portion of the class, we have an enumeration with the types
    of categories, and arrays of channel groups, sound maps, and modes, containing
    enough entries for each of the categories. Finally, there are some variables required
    to handle transitions between songs.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization and destruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the constructor, besides initializing the sound system, we create one group
    channel for each sound category, and add them to the master channel group. We
    also initialize an array of modes describing how sounds in each category should
    be loaded. Finally, we seed the random number generator that will be used to play
    sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the destructor, we do the same thing as we did in the simple audio manager,
    but this time there are multiple sound maps to clear.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Loading songs and sound effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The loading portion of the manager is very similar to what we did in the last
    chapter. The public methods `LoadSFX()` and `LoadSong()` delegate their work to
    the private `Load()` method which does the actual loading process. The only difference
    is that the `Load()` method needs to use the correct sound map and mode from the
    arrays, based on the value of the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Playing and stopping sound effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sound effects are the easier of the two categories to play. The `PlaySFX()`
    method takes the path of the sound, and a pair of minimum and maximum volume and
    pitch values. Then it searches for the sound in the correct map, and plays it
    back like before, except that it sets the volume and pitch of the sound using
    random values generated within the selected ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code makes use of two helper methods, `ChangeSemitone()` which
    was already shown earlier in this chapter, and `RandomBetween()` which can be
    seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Stopping all sound effects from playing is trivial to implement, thanks to
    the channel groups. You would typically call this when changing between scenes
    or opening a menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Playing and stopping songs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Songs are a bit harder to handle because we only want one to be playing at
    all times and we want transitions between them to happen smoothly. FMOD does not
    provide a way to fade the volume between sounds automatically, so we have to implement
    this manually with `setVolume()` calls within the `Update()` method. First, we
    need to create some member variables to store some states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'From the top, we need the channel handle to update the volume of the song,
    the path of the current song to ensure that we do not play the same song again,
    and the path of the next song to start playing it after the previous one finishes
    fading out. We also need a variable to store if we are currently fading in or
    fading out. The `PlaySong()` method follows these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If we are trying to play a song that is already playing, nothing should happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are trying to play a song, but another song is already playing, we cannot
    start immediately. Instead, we instruct the manager to begin stopping the current
    song, and store the path of the song to play afterwards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If no song is playing, we can start the new song immediately, with its initial
    volume set to zero, and the manager set to the fade in state. The song must also
    be added to the correct channel group:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StopSongs()` method is significantly easier to implement, as it only needs
    to trigger a fade out if a song is playing, and clear any pending song request
    that was previously set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It is in the `Update()` method where all of the fading takes place. The process
    follows these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If a song is playing and we are fading in, increase the volume of the current
    song a bit. Once the volume reaches one, stop fading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a song is playing and we are fading out, decrease the volume of the current
    song a bit. Once the volume reaches zero, stop the song, and stop fading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If no song is playing, and there is a song set up to play next, start playing
    it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Controlling the master volume of each category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Controlling the master volume of each category is just a matter of calling
    the corresponding channel group method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to control the playback of a sound, how to
    control the volume, pitch, and panning of a sound, how to control multiple sounds
    at once using channel groups, and finally how to apply these features in practical
    situations, such as fading between songs, or applying random variations to sound
    effects.
  prefs: []
  type: TYPE_NORMAL
