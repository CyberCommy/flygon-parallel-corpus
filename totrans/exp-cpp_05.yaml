- en: Understanding and Designing Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates are a unique feature of C++ by which functions and classes have the
    ability to support generic data types – in other words, we can implement a function
    or class independent of a particular data type; for example, a client may request
    a `max()` function to handle different data types. Instead of implementing and
    maintaining many similar functions by using function overloading, we can just
    implement one `max()` and pass the data type as a parameter. Moreover, templates
    can work together with multiple inheritance and operator overloading to create
    powerful generic data structures and algorithms in C++ such as the **Standard
    Template Library** (**STL**). Additionally, templates can also be applied to compile-time
    computation, compile-time and runtime code optimization, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the syntax of function and class templates,
    their instantiations, and their specializations. Then, we will introduce *variadic*
    templates and their applications. Next, we will discuss template parameters and
    the corresponding arguments that are used for instantiating them. After that,
    we'll learn how to implement a type *trait* and how to use this type of information
    to optimize algorithms. Finally, we will present techniques that we can use to
    speed up programs when they're executed, which includes compile-time computation,
    compile-time code optimization, and static polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring function and class templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding variadic templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding template parameters and arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are traits?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template meta-programming and its applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Exploring function and class templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start this section by introducing the syntax of function templates and
    their instantiations, deductions, and specializations. Then, we will move on to
    class templates and look at similar concepts, as well as examples.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far,when we have defined a function or a class, we have had to provide input,
    output, and intermediate parameters. For example, let's say we have a function
    to performs the addition of two int type integers. How do we extend this so that
    it handles all the other basic data types, such as float, double, char, and so
    on? One way is to use function overloading by manually copying, pasting, and slightly
    modifying each function. Another way is to define a macro to do the addition operation.
    Both approaches have their own side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, what happens if we fix a bug or add a new feature for one type, and
    this update needs to be done for all the other overloading functions and classes
    later? Instead of using this silly copy-paste-and-replacement method, do we have
    a better way of handling this kind of situation?
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this is a generic problem that any computer language can face. Pioneered
    by the general-purpose functional programming **Meta Language** (**ML**) in 1973,
    ML permits writing common functions or types that differ only in the set of types
    that they operate on when used, thus reducing duplication. Later inspired by the
    parameterized modules provided in the **chartered life underwriter** (**CLU**)
    and the generics provided by Ada, C++ adopted the template concept, which allows
    functions and classes to operate with generic types. In other words, it allows
    a function or class to work on different data types without them needing to be
    rewritten.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, from an abstract point of view, C++ functions or class templates (such
    as cookie cutters) serve as a pattern for creating other similar functions or
    classes. The basic idea behind this is to create a function or class template
    without having to specify the exact type(s) of some or all variables. Instead,
    we define a function or class template using placeholder types, called **template
    type parameters**. Once we have a function or class template, we can automatically
    generate functions or classes by using an algorithm that has been implemented
    in other compilers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three kinds of templates in C++: *function* templates, *class* templates,
    and *variadic* templates. We''ll take a look at these next.'
  prefs: []
  type: TYPE_NORMAL
- en: Function templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function template defines how a family of functions can be generated. A family
    here means a group of functions that behave similarly. As shown in the following
    diagram, this includes two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a function template; that is, the rules on how to write it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template instantiation; that is, the rules that are used to generate functions
    from their template:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4ba0b575-0a51-403e-8a1f-1f3b03c37817.png)'
  prefs: []
  type: TYPE_IMG
- en: Function template format
  prefs: []
  type: TYPE_NORMAL
- en: In **part I** of the preceding diagram, we discuss the format that will be used
    to create a function template for generic types, but with respect to the **specialized
    template**, which we also refer to as the **primary template**. Then, in **part
    II**, we introduce the three ways to generate functions from the template. Lastly,
    the specialization *and* overloading subsection tells us how to customize the
    **primary template** (by changing its behavior) for special types.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to define function templates, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `identifier_i (i=1,…,n)` is the type or class parameter and `function_declaration`
    declares the function body part. The only difference in the preceding two declarations
    is the keywords –one uses `class` while the other uses `typename`, but both have
    the same meaning and behavior. Since a type (such as the basic types – int, float,
    double,enum, struct, union, and so on) is not a class, the `typename` keyword
    method was introduced to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the classic find maximum value function template, `app_max()`,
    can be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function template can work for many data types or classes, as long as there's
    a copy-constructible type where the *a>b *expression is valid. For user-defined
    classes, this means that the greater-than operator (>) must be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the function template and template function are different things.
    Function template refers to a kind of template that's used to generate functions
    by a compiler, so the compiler does not generate any object code for it. On the
    other hand,template function means an instance from a function template. Since
    it is a function, the corresponding object code is generated by the compiler. However, the
    latest C++ standard documents suggest avoiding using the imprecision term template
    function. Therefore, we will use function templates and member function templates
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we may potentially have an infinite number of types and classes, the
    concept of function templates not only saves space in the source code file but
    also makes code easier to read and maintain. However, compared to writing separate
    functions or classes for the different data types that are used in our applications,
    it does not produce smaller object code. For instance, consider a program using
    a float and int version of `app_max()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will generate two new functions in the object file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This process of creating a new definition of a function from a function template
    declaration is called **template instantiation**. During this instantiation process,
    the compiler determines the template arguments and generates actual functional
    code on demand for your application. Typically, there are three forms: *explicit*
    *instantiations*, *implicit instantiations*, and *template deductions*. In the
    next sections, let''s discuss each form.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit instantiations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot of very useful C++ function templates can be written and consumed without
    ever using explicit instantiation, but we will describe them here just so you
    know that they do exist if you ever need them. First, let''s have a look at the
    syntax of explicit instantiations before C++11\. There are two forms, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An explicit instantiation definition, also known as a **directive**, forces
    the instantiation of a function template for certain type(s), regardless of the
    template function that will be called in the **future**. The location of the explicit
    instantiations can be anywhere after the definition of the function template,
    and it is only allowed to appear once for a given argument list in the source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for explicit instantiation directives, since C++11, is as follows.
    Here, we can see that the `extern` keyword is added before the `template` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using the `extern` keyword prevents implicit instantiations of that function
    template (see the next section for more details).
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the previously declared `app_max()` function template, it can be
    explicitly instantiated using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be explicitly instantiated using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be done in a template argument deduced way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this can also be done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, there are some other rules for explicit instantiation. If you want
    to find out more, please refer to the *Further reading* section [10] for more
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit instantiations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a function is called, the definition of that function needs to exist.
    If this function has not been explicitly instantiated, an implicit instantiation
    approach is reached, in which the list of template arguments need to be either
    explicitly supplied or deduced from the context. `Part A` of the following program
    provides some examples of the implicit instantiation of `app_max()` in this catalog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The implicit instantiations of lines `A`, `B`, `C`, and `D` are `int app_max<int>(int,int)`,
    `float app_max<float>(float, float>)`, `int app_max<int>(int,int)`, and `double
    app_max<double>(double, double)`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Deduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you call a template function, the compiler needs to figure out the template
    arguments first, even if not every template argument is specified. Most of the
    time, it will deduce the missing template arguments from the function arguments.
    For example, in part B of the preceding function, when you call `app_max(5, 8)`
    in line `E`, the compiler deduces the template argument as an int type, `(int
    app_max<int>(int,int))`, because the input parameters, `5` and `8`, are integers.
    Similarly, line `F` will be deduced as a float type, that is, `float app_max<float>(float,float)`.
  prefs: []
  type: TYPE_NORMAL
- en: However, what happens if there is confusion during instantiation? For instance,
    in the commented out line for `G` of the previous program, depending on the compiler,
    it might call `app_max<double>(double, double), app_max<int>(int, int)`, or just
    give a compile error message. The best way to help the compiler deduce the type
    is to call the function template by giving a template argument explicitly. In
    this case, if we call `app_max<double>(5, 8.0)`, any confusion will be resolved.
  prefs: []
  type: TYPE_NORMAL
- en: From the compiler's point of view, there are several ways to do template argument
    deduction – deduction from a function call, deduction from a type, auto type deduction,
    and non-deduced contexts [4]. However, from a programmer's point of view, you
    should never write fancy code to ill-use the concept of function template deduction
    to confuse other programmers such as line G in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Specialization and overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Specialization allows us to customize the template code for a given set of template
    arguments. It allows us to define a special behavior for specific template arguments.
    A specialization is still a template; you still need an instantiation to get the
    real code (automatically by the compiler).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sample code, the primary function template, `T app_max(T a,
    T b)`, will return `a` or `b` based on the return of operator *a>b,* but we can
    specialize it for `T = std::string` so that we only compare the 0*-th* elements
    of `a` and `b`; that is, `a[0] >b[0]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a primary template first, and then it explicitly
    specializes `T` as `std::string`; that is, instead of comparing the values of
    `a` and `b`, we only care about `a[0]` and `b[0]` (the behavior of `app_max()`
    is specialized). In the test function, `line A` calls `app_max<int>(int,int)`
    and `line B` calls the specialized version because there is no ambiguity at the
    deduction time. If we uncomment lines `C` and `D`, the primary function template, `char*
    app_max<char > (char*, char*)`*,* will be called, since `char*` and `std::string`
    are different data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, specialization somewhat conflicts with function overload resolution:
    the compiler needs an algorithm to resolve this conflict by finding the right
    match among the template and overloading functions. The algorithm for selecting
    the right function involves the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform overload resolution among regular functions and non-specialized templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a non-specialized template is selected, check if a specialization exists
    that would be a better match for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, in the following code block, we''re declaring the primary (`line
    0`) and specialized function templates (`lines 1-4`), as well as the overload
    functions (`lines 5-6)` of `f()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`f()` will be called several times in the following code block. Based on the
    preceding two-step rule, we can show which function is chosen in the comments.
    We''ll explain the reason for doing this after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For `lines A` and `line B`, since `f()` defined in `lines 5` and `line 6` are
    regular functions, they have the highest priority to be chosen, so `f(i)` and
    `f(i,d)` will choose them, respectively. For `line C`, because the specialized
    template exists, the `f()` generated from `line 4` is a better match than what
    was created from `line 1`. For `line D`, since `c` is a `complex<double>` type,
    only the primary function template defined in `line 1` matches it. `Line E` will
    choose `f()` that was created by `line 2` because the two input variables are
    the same type. Finally, `lines F` and `line G` will pick up the functions created
    from the templates in lines `0` and `3`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Having learned about the functional templates, we will now move on to class
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: Class templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class template defines a family of classes, and it is often used to implement
    a container. For example, the C++ Standard Library contains many class templates,
    such as `std::vector`, `std::map`, `std::deque`, and so on. In *OpenCV*, `cv::Mat`
    is a very powerful class template and it can handle 1D, 2D, and 3D matrices or
    images with built-in data types such as `int8_t`, `uint8_t`, `int16_t`, `uint16_t`,
    `int32_t`, `uint32_t`, `float`, `double`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to function templates, as shown in the following diagram, the concept
    of class templates contains a template creation syntax, its specialization, and
    its implicit and explicit instantiations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f784eca-cdaf-490e-9514-942bf80883ac.png)'
  prefs: []
  type: TYPE_IMG
- en: In **part I** of the preceding diagram, with a certain syntax format, we can
    create a class template for generic types, also known as a primary template, and
    it can be customized for special types with different member functions and/or
    variables. Once we have a class template, in **part II**, the compiler will instantiate
    it to template classes either explicitly or implicitly based on the application's
    demand.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the syntax for creating a class template.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax for creating a class template is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`template_parameter-list` (see the link in *further reading* context [10]) is
    a non-empty comma-separated list of the template parameters, each of which is
    either a non-type parameter, a type parameter, a template parameter, or a parameter
    pack of any of those.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class-declaration` is the part that''s used to declare a class that contains
    a class name and its body in curly brackets. By doing so, the declared class name
    also becomes a template name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we can define a class template, `V`, so that it contains all kinds
    of 1D data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once we have this class template, the compiler can generate classes during the
    instantiation process. For the reason we mentioned in the *Function template*
    subsection, we will avoid using the imprecise term `template` class in this book.
    Instead, we will use the class template.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Considering the class template, `V`, we defined in the previous section, we''ll
    assume the following declarations appear later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the compiler will create three instances of the `V` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Similar to function template instantiation, there are two forms of class template
    instantiation – explicit instantiation and implicit instantiation. Let's take
    a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax for explicit instantiation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: An explicit instantiation definition forces instantiation of the class, struct,
    or union they refer to. In the C++0x standard, the implicit instantiation of a
    template specialization or its members is suppressed. Similar to the explicit
    instantiation of function templates, the location of this explicit instantiation
    can be anywhere after its template definition, and it is only permitted to be
    defined once in the entire program in one file.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, since C++11, an implicit instantiation step will be bypassed by an
    explicit instantiation declaration (extern template). This can be used to reduce
    compilation times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the template class, `V`, we can explicitly instantiate it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can do the following (since C++11):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will present us with an error message if we explicitly instantiate
    a function or class template but there is no corresponding definition in the program,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we defined a class template between lines A and
    B, and then we implemented its member function, `foo()`, from `lines C` to `line
    D`. Next, we explicitly instantiated it for the `int` type at `line E`. Since
    the code block between `lines F` and `line G` is commented out (which means that
    there is no corresponding definition of `foo()` for this explicit `int` type instantiation),
    we have a linkage error. To fix this, we need to replace `#if 0` with `#if 1`
    at `line F`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there are some additional restrictions for explicit instantiation
    declarations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static**: A static class member can be named, but a static function cannot
    be allowed in an explicit instantiation declaration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inline**: There is no effect for inline functions in explicit instantiation
    declarations, and inline functions are implicitly instantiated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class and its members**: It is no equivalent for explicitly instantiating
    a class and all its members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When referring to a template class, the compiler will only generate code from
    its template on-demand if it has not been explicitly instantiated or explicitly
    specialized. This is called **implicit instantiation**, and its syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For a non-pointer object, a template class is instantiated and its object is
    created, but only the member functions used by this object are generated. For
    a pointer object, unless a member is used in the program, it is not instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example, where we define a class template, `X` ,in the
    `ch4_5_class_template_implicit_inst.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it is included by the following four `cpp` files, which has `ain()` in
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In `ch4_5_class_template_implicit_inst_A.cpp`, the compiler will implicitly
    instantiate the `X<int>` and `X<float>` classes, and then create the `xi` and
    `xf` objects. But since `X::f()` and `X::g()` are not used, they are not instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at `ch4_5_class_template_implicit_inst_B.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, the compiler will implicitly instantiate the `X<int>` class, create the `xi` object,
    and then generate the `X<int>::f()` function, but not `X<int>::g()`. Similarly,
    it will instantiate the `X<float>` class, create the `xf` object, and generate
    the `X<float>::g()` function, but not `X<float>::f()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have `ch4_5_class_template_implicit_inst_C.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since `p_xi` and `p_xf` are pointer objects, there is no need to instantiate
    their corresponding template classes through the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have `ch4_5_class_template_implicit_inst_D.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will implicitly instantiate `X<int>` and `X<int>::f()`, but not `X<int>::g()`;
    similarly, for `X<float>`, `X<float>::f()` and `X<float>::g()` will be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Specialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to function specialization, the explicit specialization of a class template
    defines a different implementation for a primary template when a specific type
    is passed as a template parameter. However, it is still a class template and you
    need to get the real code by instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose that we have a `struct X` template that can store
    one element of any data type, and it has just one member function named `increase()`.
    But for the char type data, we want a different implementation of `increase()`
    and need to add a new member function called `toUpperCase()` to it. Therefore,
    we decide to declare a class template specialization for that type. We do this
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a primary class template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This step declares a primary class template in which its constructor initializes
    the `m` member variable and `increase()` adds one to `m` and returns its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to perform specialization for the char type data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This step creates a specialized (with respect to the primary class template)
    class template with an additional member function, `toUpperCase()`, for the char
    type data only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we run a test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have a `main()` function to test it. In line A, `x1` is an object
    that has been implicitly instantiated from the primary template, `X<T>`*.* Since
    the initial value of `x1.m` is `5`, `6` will be returned from `x1.increase()`.
    In `line B`, `x2` is an object instantiated from the specialization template, `X<char>`,
    and the value of `x2.m` is `b` when it is executed. After calling `x2.toUpperCase()`,
    `B` will be the return value.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this example can be found at `ch4_6_class_template_specialization.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, the syntax that''s used in the class template''s explicit specialization
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the empty template parameter list, `template <>`, is used to explicitly
    declare it as a template specialization and `<template argument list>` is the
    type parameter(s) to be specialized. For example, in `ex4_6_class_template_specialization.cpp`,
    we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<char>` after `X` identifies the type we are going to declare a template
    class specialization for.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when we do specializations for a template class, all its members
    – even those that are identical in the primary template – must be defined because
    there is no inheritance concept for the primary template during template specializations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll take a look at partial specialization. This is a general statement
    of explicit specialization. Compared to the format of explicit specialization,
    which only has a template argument list, both the template parameter list and
    argument list are required for a partial specialization. For a template instantiation,
    the partial specialization template will be selected by the compiler if a user's
    template argument list matches a subset of the template arguments. Then, a new
    class definition from the partial specialization template will be generated by
    the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, for the primary class template `A`, we can partially
    specialize it for const `T` in the argument list. Note that both of them have
    the same parameter list, which is `<typename T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, the primary class template `B` has two parameters:
    `<typename T1` and `typename T2 >`. We partially specialize it by `T1=int`, keeping
    `T2` unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the following example, we can see that the number of template parameters
    in a partial specialization does not have to match the parameter numbers that
    appeared in the original primary template. However, the number of template arguments
    (appearing after the class name in angle brackets) must match the number and type
    of the parameters in the primary template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Again, a class template partial specialization is still a class template. You
    must provide definitions for its member functions and number variables separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'To end this section, let''s summarize what we''ve learned so far. In the following
    table, you can see a comparison between function and class templates, their instantiation,
    and specialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Function Templates** | **Class Templates** | **Comments** |'
  prefs: []
  type: TYPE_TB
- en: '| Declaration | `template <class T1, class T2>``void f(T1 a, T2 b) { ... }`
    | `template <class T1, class T2>``class X { ... };` | The declaration defines
    a function/class template, `<class T1, class T2>` called template parameters.
    |'
  prefs: []
  type: TYPE_TB
- en: '| ExplicitInstantiation | `template void f <int, int >( int, int);`orextern
    template`void f <int, int >( int, int);`(since C++11) | `template class X<int,
    float>;`or`extern template class X<int,float>;`(since C++11) | After instantiation
    there are now functions/classes, but they are called template functions/classes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| ImplicitInstantiation | {...`f(3, 4.5);``f<char, float>(120, 3.14);`} | {...`X<int,float>
    obj;``X<char, char> *p;`} | When a function call or a class object/pointer is
    declared, if it has not been explicitly instantiated, the implicit instantiation
    approach used. |'
  prefs: []
  type: TYPE_TB
- en: '| Specialization | `template <>``void f<int,float>(int a, float b)``{ ... }`
    | `template <>``class X <int, float>{ ... };` | A fully customized version (no
    parameter list) of the primary template still needs to be instantiated. |'
  prefs: []
  type: TYPE_TB
- en: '| Partial Specialization | `template <class T>``void f<T,T>(T a, T b)``{ ...
    }` | `template <class T>``class X <T, T>{ ... };` | A partial customized version
    (has a parameter list) of the primary template still needs to be instantiated.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Five concepts need to be emphasized here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declaration**: We need to follow the syntax that''s used to define a function
    or class template. At this point, a function or class template by itself is not
    a type, a function, or any other entity. In other words, there are only template
    definitions in the source file and no code, which can be complied to an object
    file, is generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implicit Instantiation**: For any code to appear, a template must be instantiated.
    During this process, it becomes imperative to determine the template arguments
    so that the compiler can generate an actual function or class. In other words,
    they are compiled on-demand, which means that compiling the code of a template
    function or class does not happen until an instantiation with specific template
    arguments is given.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit Instantiation**: Tells the compiler to instantiate the template
    with the given types, regardless of whether they are used. Typically, it is used
    for providing libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Full Specialization****: This has no parameter list (fully customized);
    it only has an argument list. The most useful thing about template specialization
    is that you can create special templates for particular type arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partial Specialization**: This is similar to fully specialization, but is
    part parameter list (partially customized) and part argument list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding variadic templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to write function or class templates
    with a fixed number of type parameters. But since C++11, standard generic functions
    and class templates can accept a variable number of type parameters. This is called **variadic
    templates**, which is an extension of C++ in *Further reading* context [6]. We
    will learn about the syntax and usage of variadic templates by looking at examples.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a function or class template takes zero or more parameters, it can be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `<typename ... Args>` declares a parameter pack. Note that here, `Args`
    is not a keyword; you can use any valid variable names. The preceding class/function
    template can take any number of `typename` as its arguments need to be instantiated,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If a variadic template needs at least one type parameter, then the following
    definition is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can instantiate them by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created the `y1` and `y2` objects from the instantiations
    of the variadic class template, `Y`, with one and three template arguments, respectively.
    For the variadic function `goo` template, we instantiate it as two template functions
    with two and three template arguments, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is probably the simplest example that shows a variadic template
    being used to find the minimum values of any input argument list. This example
    is using the concept of recursion until it reaches `my_min(double n)` to exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `printf()` variadic function is probably one of the most useful and powerful
    functions in C or C++; however, it''s not type-safe. In the following code block,
    we''re adopting the classic type-safe `printf()` example to demonstrate the usefulness
    of variadic template. As always, first, we need to define a base function, `void
    printf_vt(const char *s)`, which ends the recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in its variadic template function, `printf_vt()`, whenever `%` is hit,
    the value is printed, and the rest is passed to its recursion until the base function
    is reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can test and compare it with the traditional `printf()` using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of the first line, we can see some ASCII characters from `printf()`
    because the corresponding variable type of `%s` should be a pointer to chars,
    but we give it a type of `std::string`. To fix this, we need to pass `s.c_str()`.
    However, with the variadic template version function, we do not have this issue.
    Moreover, we only need to provide `%`, which is even better – at least, it is
    for this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, this section briefly introduced variadic templates and their applications.
    Variadic templates provide the following benefits (since C++11):'
  prefs: []
  type: TYPE_NORMAL
- en: It is a lightweight extension to the template family.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It demonstrates the ability to implement numerous template libraries without
    the use of ugly templates and preprocessor macros. Thus, the implementation code
    is capable of being understood and debugged, and it saves compile time as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables type-safe implementations of `printf()` variadic functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will explore template parameters and arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring template parameters and arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned about function and class templates and their instantiations in previous
    two sections. We know that, when defining a template, its parameter list need
    to be given. While we instantiate it, the corresponding argument list must be
    provided. In this section, we will further study the classifications and details
    of these two lists.
  prefs: []
  type: TYPE_NORMAL
- en: Template parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall the following syntax, which is used to define a class/function template.
    There is a `<>` symbol after the `template` keyword, in which one or more template
    parameters must be given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A parameter inside the parameter list could be one of the following three types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Non-type template parameter`: Refers to the compile-time constant values,
    such as integers and pointers, that reference static entities. These are often
    referred to as non-type parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Type template parameter`: This refers to either built-in type names or user-defined
    classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Template template parameter`: This indicates the parameters are other templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll discuss these in more detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Non-type template parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax of the non-type template parameter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, `type` is one of the following types – integral type, enumeration, pointer
    to object or to function, `lvalue` reference to an object or to a function, pointer
    to member object or to member function, and `std::nullptr_t` (since C++11). Additionally,
    we may put arrays and/or function types in template declarations, but they are
    automatically replaced with data and/or function pointer(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a class template that uses a non-type template
    parameter, `int N`. In `main()`, we instantiate and create an object, `x`, and
    thus `x.a` has five elements with initial values of `1`. After setting its fourth
    element value as `10`, we print the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of a function template that uses `const char*`
    as a non-type template parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main()`, we successfully instantiate `foo()` with `str1` and `str2` since
    they are both compile-time constant values and have external linkages. Then, if
    we uncomment lines 3-5, the compiler will report error messages. The reasons for
    getting these compiler errors are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 3**: `str3` is not a const variable, so the value being pointed to by
    `str3` cannot be changed. However, the value of `str3` can be changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 4**: `str4` is not a valid template argument of the `const char*` type
    because it has no linkage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 5**: `str5` is not a valid template argument of the `const char*` type
    because it has no linkage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another of the most common usages of non-type parameters is the size of an array.
    If you want to find out more, please go to [https://stackoverflow.com/questions/33234979](https://stackoverflow.com/questions/33234979).
  prefs: []
  type: TYPE_NORMAL
- en: Type template parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax of the type template parameter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '**Note:**Here, we use the `typename` and `class` keywords interchangeably.
    Inside the body of the template declaration, the name of a type parameter is a
    `typedef-name`. When the template is instantiated, it aliases the type supplied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A type template parameter without the default:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A type template parameter with the default:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'A type template parameter pack:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This template parameter pack can accept zero or more template arguments, and
    it only works on C++11 onward.
  prefs: []
  type: TYPE_NORMAL
- en: Template template parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax of the template template parameter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**: In template template parameter declaration, only the `class` keyword
    can be used; `typename` is not allowed. In the body of the template declaration,
    the name of a parameter is a `template-name`, and we need arguments to instantiate
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose you have a function that acts as a stream output operator for
    a list of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, you can see that for sequence containers such as vectors,
    double end queues, and a multitude of map types, they are the same. Hence, using
    the concept of the template template parameter, it would be possible to have a
    single operator, `<<`, to rule them all. An example of this can be found in `exch4_tp_c.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the first part of the output for each call is the template function
    name in a `pretty` format, while the second part outputs the element values of
    each container.
  prefs: []
  type: TYPE_NORMAL
- en: Template arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To instantiate a template, all the template parameters must be replaced with
    their corresponding template arguments. The arguments are either explicitly provided,
    deduced from the initializer (for class templates), deduced from the context (for
    function templates), or defaulted. Since there are three categories of template
    parameters, we will have three corresponding template arguments as well. These
    are template non-type arguments, template type arguments, and template template
    arguments*.* Besides these, we will also discuss the default template arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Template non-type arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that non-type template parameters refer to compile-time constant values
    such as integers, pointers, and references to static entities. A non-type template
    argument provided in the template argument list must match with one of these values.
    Typically, non-type template arguments are used for class initialization or the
    class container's size specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Although a discussion of the detailed rules for each type (integral and arithmetic
    types, pointers to objects/functions/members, `lvalue` reference parameters, and
    so on) of non-type argument is beyond the scope of this book, the overall general
    rule is that the template non-type arguments should be converted into constant
    expressions of the corresponding template parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, in `part 1`, we defined three template structs with different
    non-type template parameters. Then, in `part 2`, we declared two overload functions
    and `struct Y`. Finally, in `part 3`, we looked at the correct way to instantiate
    them by different non-type arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Template type arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compared to the template non-type arguments, the rule of a template type argument
    (for a type template parameter) is simple and requires that it must be a `typeid`.
    Here, a `typeid` is a standard C++ operator that returns type identification information
    at runtime. It basically returns a `type_info` object that can be compared with
    other `type_info` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, in `part 1`, we defined three classes and function templates:
    the class template C with its type template parameter, two function templates
    with a type template parameter, and a non-type template parameter, respectively.
    In `part 2`, we have an incomplete `struct A` and an unnamed type, `struct B`.
    Finally, in `part 3`, we tested them. The outputs of the four `typeid()` in Ubuntu
    18.04 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'From x86 MSVC v19.24, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, since `A`, A*, `B`, and `int()` have typeids, the code segment
    from lines A to D is linked with the template type classes or functions. Only
    line E is instantiated from the non-type template parameter function template,
    that is, `f()`.
  prefs: []
  type: TYPE_NORMAL
- en: Template template arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a template template parameter, its corresponding template argument is the
    name of a class template or a template alias. While finding a template to match
    the template template argument, only primary class templates are considered.
  prefs: []
  type: TYPE_NORMAL
- en: Here, a primary template refers to the template that is being specialized. Even
    though their parameter lists might match, the compiler will not consider any partial
    specialization with that of the template template parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a template template argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're defining a primary class template, `X`, and its specialization,
    then a class template, `Y`, with a template template parameter. Next, we implicitly
    instantiate `Y` with template template argument `X` and create an object, `c`.
    Finally, `main()` outputs the names of the four `typeid()`, and the results are
    `int`, `char`, `char`, and `char`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Default template arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++, a function is called by passing arguments, and the arguments are used
    by the function. If, while invoking a function, the arguments are not passed,
    the default values are used. Similar to the function parameter default values,
    template parameters can have default arguments. When we define a template, we
    can set its default arguments, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'There are certain rules that need to be followed when we set the default arguments
    for template parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The declaration order matters – the declaration of the default template arguments
    must be on the top of the primary template declaration. For instance, in the preceding
    example, you cannot move the code at lines 3 and 4 after line 9.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If one parameter has a default argument, then all the parameters after it must
    also have default arguments. For example, the following code is incorrect:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot give the same parameter default arguments twice in the same scope.
    For example, you will get an error message if you use the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have discussed two lists: `template_parameter_list` and `template_argument_list`.
    These are used in function or class template creation and instantiation*,* respectively*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also learned about two other important rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we define a class or function template, we need to give its `template_parameter_list`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'When we instantiate them, we must provide the corresponding `argument_list`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter or argument types in these two lists can be classified into three
    categories, as shown in the following table. Note that although the top row is
    for class templates, these properties also apply to function templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **When defining a template****template** **<template_parameter_list> class
    X { ... }** | **When instantiating a template****class X<template_argument_list>
    x** |'
  prefs: []
  type: TYPE_TB
- en: '| non-type | An entity in this parameter list can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integral or enumeration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointer to object or pointer to function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lvalue` reference to an object or `lvalue` reference to a function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointer to member
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++11 std `::nullptr_t` C++11 ends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Non-type arguments in this list are expressions whose value can be determined
    at compile time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such arguments must be constant expressions, addresses of functions or objects
    with external linkage, or addresses of static class members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-type arguments are normally used to initialize a class or to specify the
    sizes of class members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| type | An entity in this parameter list can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Must start with typename or class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the body of the template declaration, the name of a type parameter is
    a `typedef-name`. When the template is instantiated, it aliases the type supplied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The type of argument must have a `typeid`*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cannot be a local type, a type with no linkage, an unnamed type, or a type
    compounded from any of these types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| template | An entity in this parameter list can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`template <parameter-list>` class name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template <parameter-list>` class ... name (optional) (since C++11)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| A template argument in this list is the name of a class template. |'
  prefs: []
  type: TYPE_TB
- en: In the upcoming section, we will explore how to implement traits in C++ and
    optimize algorithms using them.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic programming means writing code that works with any data type under certain
    requirements. It is the most efficient way of delivering reusable high-quality
    code in the software engineering industry. However, there are times in generic
    programming where being generic just isn't good enough. Whenever the differences
    between types are too complex, it is very hard for an efficient generic to optimize
    a common implement. For example, while implementing a sort function template,
    if we know the argument type is a linked list but not an array, a different strategy
    will be implemented to optimize the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Although template specialization is one approach to overcome this problem, it
    doesn't provide type-related information in a broad way. A type trait is a technique
    that's used to collect information about the type. With its help, we can make
    more intelligent decisions to develop high-quality optimized algorithms in generic
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will introduce how to implement a type trait, and then show
    you how to use type information to optimize algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Type trait implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand type traits, we'll look at the classic implementations of `boost::is_void`
    and `boost::is_pointer`.
  prefs: []
  type: TYPE_NORMAL
- en: boost::is_void
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s look at one of the simplest traits classes, the `is_void` trait,
    which was created by boost. It defines a generic template that''s used to implement
    the default behavior; that is, accept a void type, but anything else is void.
    Hence, we have `is_void::value = false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we fully specialize it for the void type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, we have a complete traits type that can be used to detect if any given
    type, `T`, `is_void` by checking the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's learn how to use partial specialization in `boost::is_pointer` traits.
  prefs: []
  type: TYPE_NORMAL
- en: boost::is_pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the `boost::avoid` traits, a primary class template is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it is partially specialized for all pointer types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a complete traits type that can be used to detect if any given
    type, `T`, `is_pointer` by checking the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the boost type traits feature has already been formally introduced to
    the C++ 11 Standard Library, we can show the usage of `std::is_void` and `std::is_pointer`
    without including the preceding source code in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sets the `boolalpha` format flag for the string stream at
    the beginning. By doing so, all the bool values are extracted by their text representation,
    which is either true or false. Then, we use several `std::cout` to print the values
    of `is_void<T>::value` and `is_pointer<T>::value`*.* The output of each value
    is displayed at the end of the corresponding commented-out line.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing algorithms using traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of talking about this topic in a generic abstract way, we will use
    a classic optimized copy example to show the usage of type traits. Consider the
    standard library algorithm known as `copy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, we can write a generic version of `copy()` for any iterator types,
    that is, `It1` and `It2` here. However, as explained by the authors of the boost
    library, there are some circumstances where the copy operation can be performed
    by `memcpy()`. We can use `memcpy()` if all of the following conditions are satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: Both types of iterator, `It1` and `It2`, are pointers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`It1` and `It2` must point to the same type, except for const and volatile
    qualifiers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trivial assignment operator must be provided by the type that `It1` points
    to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, the trivial assignment operator means that the type is either a scalar
    type or one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no user-defined assignment operator for the type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no reference type of data members inside the type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trivial assignment operators must be defined in all the base classes and data
    member objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, a scalar type includes an arithmetic type, enumeration type, pointer,
    pointer to member, or const- or volatile-qualified version of one of these types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the original implementation. It includes two parts
    – the copier class template and the user interface function, that is, `copy()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned in the comment lines, the preceding copier class template has
    two static function templates – one is the primary and the other is fully specialized.
    The primary does an element-by-element hard copy, while the full specialization
    one copies all the elements at once via `memcpy()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: To optimize the copy operation, the preceding user interface function defines
    two `remove_cv` template objects, `v1_t` and `v2_t`, and then evaluates whether
    `can_opt` is true. After that, the `do_copy()` template function is called. By
    using the test code posted in the boost utility library (`algo_opt_ examples.cpp`),
    we can see that there is a significant improvement in using the optimized implementation;
    that is, it could be 8 or 3 times faster for copying char or int types of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s conclude this section with the following highlights:'
  prefs: []
  type: TYPE_NORMAL
- en: A trait gives additional information other than just the type. It is implemented
    through template specializations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By convention, traits are always implemented as structs. The structs that are
    used to implement traits are known as trait classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bjarne Stroustrup said that we should think of a trait as a small object whose
    main purpose is to carry information that's used by another object or algorithm
    to determine policy or implementation details. *Further* *reading* context [4]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scott Meyers also summarized that we should use traits classes to gather information
    about types *Further reading* context [5].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits can help us implement generic algorithms in an efficient/optimized way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will explore template metaprogramming in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring template metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A programming technique in which computer programs have the ability to treat
    other programs as their data is known as **metaprogramming**. This means that
    a program can be designed to read, generate, analyze, or transform other programs,
    and even modify itself while running. One kind of metaprogramming is a compiler,
    which takes a text format program as an input language (C, Fortran, Java, and
    so on) and produces another binary machine code format program in an output language.
  prefs: []
  type: TYPE_NORMAL
- en: C++ **template metaprogramming** (**TMP**) means producing metaprograms in C++
    using templates. It has two components – a template must be defined, and a defined
    template must be instantiated. TMP is Turing-complete, which means it has the
    capability to compute anything that is computable, at least in principle. Also,
    because variables are all immutable (variables are constants) in TMP, recursion
    rather than iteration is used to process the elements of a set.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need TMP? Because it can speed up our programs during execution time!
    But since there is no free lunch in the optimization world, the prices we paid
    for TMP are longer compile-time and/or larger binary code sizes. Additionally,
    not every problem can be solved with TMP; it only works when we're computing something
    that is constant during compile time; for example, finding out all the primary
    numbers that are smaller than a constant integer, the factorial of a constant
    integer, unrolling a constant number of loops or iterations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a practical point of view, template metaprogramming has the ability to
    solve problems in the following three categories: compile-time computation, compile-time
    optimization, and replacing dynamic polymorphism with static polymorphism by avoiding
    virtual table lookup during runtime. In the following subsections, we will provide
    examples from each category to demonstrate how metaprogramming works.'
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time computation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, if the inputs and outputs of a task are known at compile-time, we
    can use template metaprogramming to do the computation during compilation and
    thus save any runtime overhead and the memory footprint. This is really useful
    in real-time intense CPU utilization projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the factorial function, which calculates `*n*!`. This
    is the product of all positive integers less than or equal to *n, *with 0!=1 by
    definition. Thanks to the concept of recursion, we can implement this using a
    simple function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`f1()` does the computation at runtime, while `f2()` can do it either at runtime
    or compile-time, depending on its usage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, by using a template with a non-type parameter, its specialization,
    and the recursion concept, the template metaprogramming version of this problem
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a class template with a non-type parameter, and like other
    const expressions, values of `const static uint32_t` or enumeration constants
    are evaluated at compile time. This compile-time evaluation constraint means only
    const variables make sense. Also, since we are working with classes only, static
    objects make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the compiler sees a new argument for a template, it creates a new instance
    of the template. For instance, when the compiler sees `fact<10>::value` and it
    tries to create an instance of `fact` with the argument as 10, it turns out that
    `fact<9>` must also be created. For `fact<9>`, it needs `fact<8>` and so on. Finally,
    the compiler uses `fact<0>::value` (which is 1), and the recursion during compile
    time terminates. This process can be seen in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that to be able to use templates in this way, we must provide a constant
    argument in template argument list. That''s why if you uncomment the last two
    lines of code, you will get a complaint from the compiler: `fact:template parameter
    n: m: a variable with non-static storage duration cannot be used as a non-type
    argument`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s end this subsection by briefly comparing the **constexpr functions**
    (**CF**) and TMP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Computation time**: CF executes at either compile-time or runtime, depending
    on its usage, but TMP only executes at compile time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Argument lists**: CF can only take values, but TMP can take both value and
    type parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control structure**: CF can use recursion, conditions, and loops, but TMP
    only uses recursion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile-time code optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the previous example can calculate the factorial of a constant integer
    at compile-time, we can use a runtime loop to unroll the dot-products of two -*n*
    vectors (where *n* is known at compile time). The benefit of a more traditional
    length-*n* vector is that unrolling the loops is feasible, which results in very
    optimized code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the traditional dot-product function template can be implemented
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '**Loop unrolling **means that if we can optimize the for loop inside the `dotp()` function
    as `a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4]`, then it will save
    more runtime computations. That is exactly what metaprogramming does in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the factorial metaprogramming example, in the `dotp<5, float>::result(
    a, b)` statement, the instantiation process recursively does the following computing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Since *N* is 5, it recursively calls the `dotp<n`, `float>::results()` template
    function four times until `dotp<1`, `float>::results()` is reached. The final
    expression that's evaluated by `dotp<5`, `float>::result( a, b)` is displayed
    in the last two lines of the preceding block.
  prefs: []
  type: TYPE_NORMAL
- en: Static polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism means multiple functions have the same name. Dynamic polymorphism
    allows users to determine the actual function method to be executed at runtime
    (see [chapter 3](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml), *Details of Object-Oriented
    Programming*, for more details*), *while *static* polymorphism means that the
    actual function to call (or, in general, the actual code to run) is known at compile
    time. By default, C++ matches a function call with the correct function definition
    at compile time by checking the types and/or the number of arguments. This process
    is also called **static binding** or **overloading***.* However, by using a virtual
    function, the compiler also does dynamic binding or overriding in runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following code, a virtual function, `alg()`, is defined
    in both base `class B` and derived `class D`. When we use the derived object pointer
    `p` as an instance pointer of the base class, the `p->alg()` function call will
    invoke the derived `alg()` defined in the derived class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in cases where the polymorphism behavior is invariant and can be determined
    at compile-time, the **Curiously Recurring Template Pattern** (**CRTP**) can be
    used to achieve static polymorphism, which imitates static polymorphism and resolves
    the binding at compile time. Thus, the program will get out of checking `virtual-lookup-table`
    at runtime. The following code implements the previous example in a static polymorphism
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In summary, the general idea of template metaprogramming is to let the compiler
    do some computation during compilation time. In this way, the runtime overhead
    can be resolved to a certain degree. The reason we can compute something during
    compilation time is that something is constant before runtime.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in further reading context [14],C++ TMP is a very powerful method
    for performing computational tasks at compilation time. The first approach is
    not easy, and we must be very careful regarding compile errors because the templates
    tree is unrolled. From a practical point of view, the boost **Metaprogramming
    Library** (**MPL**) is a good reference to start. It provides a compile-time TMP
    framework for algorithms, sequences, and metafunctions in a general-purpose way.
    Moreover, the new `std::variant` and `std::visit` features in C++17 can also be
    used for static polymorphism for scenarios where there are no related types sharing
    the inheritance kind of an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed generic programming-related topics in C++. Starting
    by reviewing C macros and function overloading, we introduced the development
    motivations of C++ templates. Then, we presented the syntax of class and function
    templates with a fixed number of parameters, as well as their specializations
    and instantiations. Since C++11, variadic templates are accepted by the standard
    generic function and class templates. Based on this, we further classified the
    template parameters and arguments into three categories: non-type template parameters/arguments,
    type template parameters/arguments, and template template parameters/arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about traits and template metaprogramming. As a byproduct of
    template specialization, traits classes can provide us with more information about
    types. With the help of type information, eventually, the optimizations of implementing
    generic algorithms become possible. Another application of class and/or function
    templates is to compute some constant tasks during compile time via recursion,
    which is called template metaprogramming. It has the ability to perform compile-time
    computation and/or optimization, as well as avoid virtual table lookup during
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should have a deep understanding of templates. You should be able to
    create your own function and class templates in applications, as well as practice
    using traits to optimize your algorithm and use template metaprogramming to do
    compile-time computation for additional optimization
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about memory and management-related topics,
    such as the concept of memory access, allocation and de-allocation techniques,
    and garbage collection basics. This is the most unique feature of C++, and thus
    it must be understood by every C++ developer.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the side effects of macros?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a class/function template? What is a template class/function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a template parameter list? What is a template argument list? Once we
    have a class template, we can instantiate it either explicitly or implicitly.
    In what kind of scenario is explicit instantiation necessary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does polymorphism mean in C++? What is the difference between function
    overloading and function overriding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are type traits? How do we implement a type trait?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ch4_5_class_template_implicit_inst_B.cpp` file, we said implicit instantiation
    generates the `X<int>` class, and then creates the `xi` object and generates the
    `X<int>::f()` function, but not `X<int>::g()`. How can you verify that `X<int>::g()`
    is not generated?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using template metaprogramming, solve the problem of *f(x,n) = x^n*, where *n*
    is a const and *x* is a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend  `ch4_17_loop_unrolling_metaprogramming.cpp` to values of n=10,100,10^3,10^4,10^6,
    ..., until you reach your system memory limits. Compare the compile time, object
    file size, and running CPU time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As referenced throughout this chapter, have a look at the following sources
    to find out more regarding what was covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Milner, R., Morris, L., Newey, M. (1975). *A Logic for Computable Functions
    with Reflexive and Polymorphic Types.* Proceedings of the Conference on Proving
    and Improving Programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.research.ed.ac.uk/portal/en/publications/a-logic-for-computable-functions-with-reflexive-and-polymorphic-types(9a69331e-b562-4061-8882-2a89a3c473bb).html](https://www.research.ed.ac.uk/portal/en/publications/a-logic-for-computable-functions-with-reflexive-and-polymorphic-types(9a69331e-b562-4061-8882-2a89a3c473bb).html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Curtis, Dorothy (2009-11-06). CLU home page.*Programming Methodology Group,
    Computer Science and Artificial Intelligence Laboratory. Massachusetts Institute
    of Technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.pmg.csail.mit.edu/CLU.html](http://www.pmg.csail.mit.edu/CLU.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Technical Corrigendum for Ada 2012*, published by ISO. Ada Resource Association.
    2016-01-29.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://www.adaic.org/2016/01/technical-corrigendum-for-ada-2012-published-by-iso/
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B. Stroustrup, *C++.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dl.acm.org/doi/10.5555/1074100.1074189](https://dl.acm.org/doi/10.5555/1074100.1074189)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*S. Meyers, Effective C++ 55 Specific Ways to Improve Your Programs and Designs
    (3rd Edition), Chapter 7.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.oreilly.com/library/view/effective-c-55/0321334876/](https://www.oreilly.com/library/view/effective-c-55/0321334876/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D. Gregor and J. Järvi (February 2008). *Variadic Templates for C++0x.*Journal
    of Object Technology. pp. 31–51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.jot.fm/issues/issue_2008_02/article2.pdf](http://www.jot.fm/issues/issue_2008_02/article2.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.boost.org/](https://www.boost.org/) for type traits, unit testing
    etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rzarg/templates.htm](https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rzarg/templates.htm) for
    generic templates discussions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://stackoverflow.com/questions/546669/c-code-analysis-tool](https://stackoverflow.com/questions/546669/c-code-analysis-tool) for
    code analysis tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.cppreference.com](https://en.cppreference.com) for template explicit
    instantiations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.cplusplus.com](http://www.cplusplus.com) for library references
    and usage examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.drdobbs.com/cpp/c-type-traits/184404270](http://www.drdobbs.com/cpp/c-type-traits/184404270) for
    type-traits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://accu.org/index.php/journals/424](https://accu.org/index.php/journals/424) for
    template metaprogramming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Template_metaprogramming](https://en.wikipedia.org/wiki/Template_metaprogramming) for
    template metaprogramming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'K. Czarnecki, U. W. Eisenecker, *Generative Programming: Methods, Tools, and
    Applications*, Chapter 10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'N. Josuttis; D. Gregor and D. Vandevoorde, *C++ Templates: The Complete Guide
    (2nd Edition)*, Addison-Wesley Professional 2017.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
