- en: Node Fundamentals â€“ Part 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start adding support for all the other commands inside of the notes application.
    We'll take a look at how we can create our `read` command. The `read` command
    will be responsible for fetching the body of an individual note. It will fetch
    all the notes and print them to the screen. Now, aside from all of that, we'll
    be looking at debugging broken apps, and we'll look at some new ES6 features.
    You'll learn how to use the built-in Node `debugger`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you will learn a little bit more about how we can configure yargs for
    the command-line interface applications. We'll learn how to set up the commands,
    their descriptions, and the arguments. We'll be able to set various properties
    on the arguments, for example, whether or not they're required, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will write the code for removing a note when someone uses
    that `remove` command, and they pass in the title of the note they want to remove.
    In the previous chapter, we already created some utility functions that help us
    with fetching and saving notes, so the code should actually be pretty simple.
  prefs: []
  type: TYPE_NORMAL
- en: Using the removeNote function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in the process is to fill out the `removeNote` function, which
    we defined in the previous chapters, and this will be your challenge. Let's remove
    `console.log` from the `removeNote` function in the `notes.js` file. You only
    need to write three lines of code to get this done.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the first line will fetch the notes, then the job will be to filter out
    the notes, removing the one with title of argument. That means we want to go through
    all of the notes in the notes array, and if any of them have a title that matches
    the title we want to remove, we want to get rid of them. And this can be done
    using the `notes.filter` function we used earlier. All we have to do is switch
    the equality statement in the `duplicateNotes` function from equals to not equals,
    and this code will do just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will go through the notes array. Every time it finds a note that doesn''t
    match the title it will keep it, which is what we want, and if it does find the
    title it will return `false` and remove it from the array. And then we will add
    the third line, which is to save the new notes array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code lines are the only three lines you need to fill out. Don't
    worry about returning anything from `removeNote` or filling out anything inside
    of `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will do for the `fetchNotes` line is to create a variable
    called `notes`, just like we did in `addNote` in the previous chapter, and we''ll
    set it equal to the return result from `fetchNotes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At this point our notes variable stores an array of all of the notes. The next
    thing we need to do is filter our notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is a note that has this title, we want to remove it. This will be
    done by creating a new variable, and I''ll call this one `filteredNotes`. Here
    we''ll set `filteredNotes` equal to the result that will come back from `notes.filter`,
    which we already used up previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We know that `notes.filter` takes a function as its one and only argument, and
    that function gets called with the individual item in the array. In this case
    it would be a `note`. And we can do this all on one line using the ES6 arrow syntax.
  prefs: []
  type: TYPE_NORMAL
- en: If we have only one statement, we don't need to open and close curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'That means right here we can return `true` if `note.title` does not equal the
    title that''s passed into the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will populate `filteredNotes` with all of the notes whose titles do not
    match the one passed in. If the title does match the title passed in, it will
    not be added to `filteredNotes` because of our filter function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do is to call `saveNotes`. Right here, we''ll call `saveNotes`
    passing in the new notes array which we have under the `filteredNotes` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If we were to pass in notes, it wouldn't work as expected; we're filtering the
    notes out but we're not actually saving those notes, so it will not get removed
    from the JSON. We need to pass `filteredNotes` as shown in the preceding code.
    And we can test these by saving the file and trying to remove one of our notes.
  prefs: []
  type: TYPE_NORMAL
- en: I'll try to remove `secret2` from the `notes-data.json` file. That means all
    we need to do is run the command, which we called `remove`, that is specified
    over in `app.js`, (refer to the following code image, and then it will call our
    function).
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll run Node with `app.js`, and we''ll pass in the `remove` command. The
    only argument we need to provide for remove is the title; there''s no need to
    provide the body. I''ll set this equal to `secret2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f7a91df7-d4f6-4f3d-9e94-4e38735a7722.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the screenshot, if I hit *enter* you can see we don't get any output.
    Although we do have the command remove printing, there is no message saying whether
    or not a note was removed, but we'll add that later in the section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we can check the data. And right here you can see `secret2` is nowhere
    in sight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0092e4b-009f-460a-9c51-7a4021d9a960.png)'
  prefs: []
  type: TYPE_IMG
- en: This means our remove method is indeed working as expected. It removed the note
    whose title matched and it kept all the notes whose title was not equal to `secret2`,
    exactly what we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: Printing a message of removing notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the next thing we'll do is print a message depending on whether or not
    a note was actually removed. That means `app.js`, which calls the `removeNote`
    function, will need to know whether or not a note was removed. And how do we figure
    that out? How can we possibly return that given the information we have in `notes.js
    removeNotes` function?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we can, because we have two really important pieces of information. We
    have the length of the original notes array and we have the length of the new
    notes array. If they're equal then we can assume that no note was removed. If
    they are not equal, we'll assume that a note was removed. And that is exactly
    what we'll do.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `removeNote` function returns `true`, that means a note was removed;
    if it returns `false`, that means a note was not removed. In the `removeNotes`
    function we can add return, as shown in the following code. We''ll check if `notes.length`
    does not equal `filteredNotes.length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If they're not equal it will return `true`, which is what we want because a
    note was removed. If they're equal it will return `false`, which is great.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, inside of `app.js` we can add a few lines in the `removeNote`, `else if`
    block to make the output for this command a little nicer. The first thing to do
    is to store that Boolean. I''ll make a variable called `noteRemoved` and we''ll
    set that equal to the return, result as shown in the following code, which will
    either be `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On the next line, we can create our message, and I'll do this all on one line
    using the ternary operator. Now, the ternary operator lets you specify a condition.
    In our case, we'll use a var message and it will be set equal to the condition
    `noteRemoved`, which will be `true` if a note was removed and `false` if it wasn't.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the ternary operator can be a little confusing, but it's really useful
    inside JavaScript and Node.js. The format for the ternary operator is first we
    add the condition, question mark, the truthy expression to run, colon, and then
    the falsy expression to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the condition, we''ll put a space with a question mark and a space; this
    is the statement that will run if it''s true. If the `noteRemoved` condition passes,
    what we want to do is set message equal to `Note was removed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if `noteRemoved` is `false`, we can specify that condition right after
    the colon in the previous statement. Here, if there is no note removed we''ll
    use the text `Note not found`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now with this in place, we can test out our message. The last thing to do is
    print the message to the screen using `console.log` passing in message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This lets us avoid `if` statements that make our `else-if` clause to remove
    unnecessarily complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back inside of Atom we can rerun the last command, and in this case no note
    will get removed because we already deleted it. And when I run it, you can see
    that `Note not found` prints to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ded0f16-d917-485a-9c5f-1c8231fe080a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now I''ll remove a note that does exist; in `notes-data.json` I have a note
    with a title of secret as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b9cded3-60d0-4eb4-a6ae-8b826e562995.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s rerun the command removing the `2` from the title in Terminal. When
    I run this command, you can see `Note was removed` prints to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb707253-3796-471f-a3a8-4b233cbf0a26.png)'
  prefs: []
  type: TYPE_IMG
- en: That is it for this section; we now have our `remove` command in place.
  prefs: []
  type: TYPE_NORMAL
- en: Reading note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will be responsible for filling out the rest of the `read`
    command. Now, the `read` command does have an else-if block to find in `app.js`
    where we call `getNote`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`getNote` is defined over inside `notes.js`, even though currently it just
    prints out some dummy text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What you'll need to do in this section is wire up both of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: First up, you will need to do something with the return value from `getNote`.
    Our `getNote` function will return the note object if it finds it. If it doesn't,
    it will return undefined just like we do for `addNote` discussed in the section
    *Adding and saving note*, in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you store that value, you''ll do some printing using `console.log`, similar
    to what we have here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, `Note created` will be something like `Note read` and `Note title
    taken` will be something like `Note not found`, but the general flow is going
    to be exactly the same. Now, once you have that wired up inside of `app.js`, you
    can move on to `notes.js`, filling out the function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the function inside of `notes.js` isn't going to be that complex. All you
    need to do is fetch the notes, like we've done in previous methods, then you're
    going to use `notes.filter`, which we explored to only return notes whose title
    matches the title passed in as the argument. Now, in our case this is either going
    to be zero notes, which means the note is not found, or it's going to be one note,
    which means we've found the note that the person wants to return.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we do need to return that note. It's important to remember the return
    value from `notes.filter` is always going to be an array, even if that array only
    has one item. What you're going to need to do is return the first item in the
    array. If that item doesn't exist that's fine, it'll return undefined, as we want.
    If it does exist, great, that means we found the note. This method only requires
    three lines of code, one for fetching, one for filtering, and the return statement.
    Now, once you have all that done we'll test it out.
  prefs: []
  type: TYPE_NORMAL
- en: Using the getNote function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s work on this method. Now, the first thing I''ll do is fill out, inside
    of `app.js`, a variable called note which is going to store the return value from
    `getNote`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this could be an individual note object or it could be undefined. In the
    next line, I can use an `if` statement to print the message if it exists, or if
    it does not exist. I''ll use `if` note, and I am going to attach an `else` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This `else` clause will be responsible for printing an error if the note is
    not found. Let''s get started with that first since it''s pretty simple, `console.log`,
    `Note not found`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `else` clause filled out we can fill out the if statement.
    For this, I''ll print a little message, `console.log (''Note found'')` will get
    the job done. Then we can move on to printing the actual note details, and we
    already have that code in place. We are going to add the hyphenated spacer, then
    we have our note title and our note body as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we're done with the inside of `app.js`, we can move into the `notes.js`
    file and fill out the `getNote` method because currently it doesn't do anything
    with the title that gets passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside notes, what you needed to do was fill out those three lines. The first
    one is going to be responsible for fetching the notes. We already have did that
    before with the `fetchNotes` function in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our notes in place we, can call `notes.filter`, returning
    all of the notes. I''ll make a variable called `filteredNotes`, setting it equal
    to `notes.filter`. Now, we know that the filter method takes a function, I''ll
    define an arrow function (`=>`) just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the arrow function (`=>`), we''ll get the individual note passed in,
    and we''ll return `true` when the note title, the title of the note we found in
    our JSON file, equals, using triple equals, title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return `true` when the note title matches and false if it doesn''t.
    Alternatively, we can use arrow functions, and we only have one line, as shown
    following, where we return something; we can cut out our condition, remove the
    curly braces, and simply paste that condition right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This has the exact same functionality, only it's a lot shorter and easier to
    look at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all of the data, all we need to do is return something, and
    we''ll return the first item in the `filteredNotes` array. Next, we''ll grab the
    first item, which is the index of zero, and then we just need to return it using
    the `return` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, there is a chance that `filteredNotes`, the first item, doesn't exist,
    and that's fine, it's going to return undefined, in which case our else clause
    will run, printing `Note not found`. If there is a note, great, that's the note
    we want to print, and over in `app.js` we do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Running the getNote function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have this in place we can test out this brand new functionality
    inside of Terminal by running our app using `node app.js`. I''ll use the `read`
    command, and I''ll pass in a title equal to some string that I know does not exist
    inside of a title in the `notes-data.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When I run the command, we get `Note not found`, as shown here, and this is
    exactly what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c71ca8b7-a372-46c2-b51c-7dd28adba3ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, if I do try to fetch a note where the title does exist, I would expect
    that note to come back.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the data file I have a note with a title of `to buy`; let''s try to fetch
    that one. I''ll use the up arrow key to populate the previous command and replace
    the title with `to space`, buy, and hit *enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d887e87f-d094-424d-ba57-b3b072bd79c4.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the previous code, you can see `Note found` prints to the screen,
    which is fantastic. Following `Note found` we have our spacers and following that
    we have the title, which is `to buy`, and the body, which is `food`, exactly as
    it appears inside of the data file. With this in place, we are done with the `read`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: The DRY principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, there is one more thing I want to tackle before we wrap up this section.
    Inside `app.js` we now have the same code in two places. We have the space or
    title body in the `add` command as well as in the `read` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When you find yourself copying and pasting code, it's probably best to break
    that out into a function that both locations call. This is the **DRY principle**,
    which stands for **Don't Repeat Yourself**.
  prefs: []
  type: TYPE_NORMAL
- en: Using the logNote function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our case, we are repeating ourselves. It would be best to break this out
    into a function that we can call from both places. In order to do this, all we're
    going to do is make a function in `notes.js` called `logNote`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in `notes.js`, down following the `removeNote` function, we can make that
    brand new function a variable called `logNote`. This is going to be a function
    that takes one argument. This argument will be the note object because we want
    to print both the title and the body. As shown here, we''ll expect the note to
    get passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, filling out the `logNote` function is going to be really simple, especially
    when you''re solving a DRY issue, because you can simply take the code that''s
    repeated, cut it out, and paste it right inside the `logNote` function. In this
    case the variable names line up already, so there is no need to change anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `logNote` function in place, we can change things over
    in `app.js`. In `app.js`, where we have removed the `console.log` statements we
    can call `notes.logNote`, passing in the note object just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can do the same thing in case of the `add` command `if` block. I can
    remove these three `console.log` statements and call `notes.logNote`, passing
    in note:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And now that we have this in place, we can rerun our program and hopefully what
    we see is the exact same functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do before we rerun the program is export the `logNote` function
    in `exports` module in `notes.js` file. `LogNote` is going to get exported and
    we''re using the ES6 syntax to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, I can now rerun the previous command from Terminal using
    up and hit *enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a352534b-7d91-439a-9d9d-720d176e03be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown, we get `Note found` printing to the screen, with the title and the
    body just like we had before. I''m also going to test out the `add` command to
    make sure that one''s working, `node app.js add`; we will use a title of things
    to do and a body of go to post office:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when I hit *enter,* we would expect the same log to print as it did before
    for the `add` command, and that''s exactly what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/058d88e4-cd1f-49f5-8362-7db4eeb504db.png)'
  prefs: []
  type: TYPE_IMG
- en: Note created prints, we get our spacer, and then we get our title and our body.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we're going to cover one of the most important topics in
    the book; which is debugging. Knowing how to properly debug programs is going
    to save you literally hundreds of hours over your Node.js career. Debugging can
    be really painful if you don't have the right tools, but once you know how it's
    done, it really isn't that bad and it can save you a ton of time.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to use the built-in `debugger`, which can look
    a little complex because it's run inside of the command line. That means that
    you have to use the command-line interface, which is not always the most pleasant
    thing to look at. In the next section, though, we are going to be installing a
    third-party tool that uses Chrome DevTools in order to debug your Node app. That
    one looks great because the Chrome DevTools are fantastic.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a program in debug mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before going ahead, we will learn that we do need to create a place to play
    around with debugging and that''s going to happen in a playground file, since
    the code we''re going to write is not going to be important to the `notes` app
    itself. Inside the notes app I''ll make a new file called `debugging.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51bbbdae-8ca8-4c1b-b0b4-0daaeafc6ccc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In `debugging.js` we''re going to start off with a basic example. We''re going
    to make an object called `person`, and on that object for the moment, we''re going
    to set one property name. Set it equal to your name, I''ll set mine equal to the
    string `Andrew` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up we''re going to set another property, but in the next line, `person.age`.
    I''ll set mine equal to my age, `25`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''re going to add another statement that changes the name, `person.name`
    equals something like `Mike`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''re going to `console.log` the `person` object, the code is going
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, we actually already have a form of debugging in this example, we have a
    `console.log` statement.
  prefs: []
  type: TYPE_NORMAL
- en: As you're going through the Node application development process, you may or
    may not have used `console.log` to debug your app. Maybe something's not working
    as expected and you want to figure out exactly what that variable has stored inside
    of it. For example, if you have a function that solves a math problem, maybe at
    one part in the function the equation is wrong and you're getting a different
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `console.log` can be a pretty great way to do that, but it''s super limited.
    We can view that by running it from Terminal, I''ll run the following command
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When I run the file, I do get my object printed out to the screen, which is
    great, but, as you know, if you want to debug something besides the `person` object
    you have to add another `console.log` statement in order to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have something like our `app.js` file, you want to see what command
    equals, then you want to see what `argv` equals, it could take a lot of time to
    add and remove those `console.log` statements. There is a better way to debug.
    This is using the Node `debugger`. Now, before we make any changes to the project,
    we'll take a look at how the `debugger` works inside of Terminal, and as I warned
    you in the beginning of the section, the built-in Node `debugger`, while it is
    effective, is a little ugly and hard to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, though, we are going to run the app much the same way, only this time
    we''re going to type `node inspect`. Node debug is going to run our app completely
    differently from the regular Node command. We''re running the same file in the
    playground folder, it''s called `debugging.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When you hit *enter,* you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00b9dba3-f0b8-4e20-97e1-ea166e26c153.png)'
  prefs: []
  type: TYPE_IMG
- en: In the output, we can ignore the first two lines. This essentially means that
    the `debugger` was set up correctly and it's able to listen to the app running
    in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have our very first line break in playground debugging on line one,
    and right following to it you can see line one with a little caret (`>`) next
    to it. When you first run your app in debug mode, it pauses before it executes
    the first statement. When we're paused on a line like line one, that means the
    line has not executed, so at this point in time we don't even have the `person`
    variable in place.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as you can see in the preceding code, we haven't returned to the command
    line, Node is still waiting for input, and there are a few different commands
    we can run. For example, we can run `n`, which is short for next. You can type
    `n`, hit *enter*, and this moves on to the next statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next statement we have, the statement on line one, was executed, so the
    `person` variable does exist. Then I can use `n` again to go to the next statement
    where we declare the `person.name` property, updating it from `Andrew` to `Mike`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd1bc5a0-09f8-4604-9e07-fbe212aaa564.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice, at this point, age does exist because that line has already been executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `n` command goes statement by statement through your entire program.
    If you realize that you don''t want to do that through the whole program, which
    could take a lot of time, you can use `c`. The `c` command is short for **Continue**,
    and that continues to the very end of the program. In the following code, you
    can see our `console.log` statement runs the name `Mike` and the age `25`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1f7b76d-2a2c-4f46-a283-1bcdffed3d5e.png)'
  prefs: []
  type: TYPE_IMG
- en: This is that's a quick example of how to use the `debug` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we actually didn't do any debugging, we just ran through the program since
    it is a little foreign in terms of writing these commands, such as next and continue,
    I decided to do a dry run once with no debugging. You can use *control* + *C*
    to quit the `debugger` and get returned back to Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: I'll use `clear` to clear all the output. Now that we have a basic idea about
    how we can execute the program in `debug` mode, let's take a look at how we can
    actually do some debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Working with debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''ll rerun the program using the up arrow key twice to return to the Node
    `debug` command. Then, I''ll run the program, and I''ll hit next twice, `n` and
    `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6e79c50-ec92-4604-aaf2-8bb7324a6c4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point in time, we are on line seven, that is where the line break currently
    is. From here we can do some debugging using a command called `repl`, which stands
    for **Read Evaluate Print Loop**. The `repl` command, in our case, brings you
    to an entirely separate area of the `debugger`. When you hit it you''re essentially
    in a Node console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a4f8fe0-3ae5-422b-b9e0-b3ef0373a2ee.png)'
  prefs: []
  type: TYPE_IMG
- en: You can run any Node commands, for example, I can use `console.log` to print
    something like `test`, and test prints up right there.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can make a variable `a` that is equal to `1` plus `3`, then I can reference
    `a` and I can see it''s equal to `4` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89f2647e-d2a2-4db7-8a4e-477af5da153a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'More importantly, we have access to the current program as it sits, meaning
    as it was before line seven was executed. We can use this to print out `person`,
    and as shown in the following code, you can see the person''s name is `Andrew`
    because line seven hasn''t executed and the age is `25`, exactly as it appears
    in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73c46dbd-05b6-4ae3-8090-36dfacb44a65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is where debugging gets really useful. Being able to look at the program
    paused at a certain point in time is going to make it really easy to spot errors.
    I could do anything I want, I could print out the `person` name property, and
    that prints `Andrew` to the screen, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68dc0572-b480-4158-8214-c1533e556951.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, once again, we still have this problem. I have to hit next through the
    program. When you have a really long program, there could literally be hundreds
    or thousands of statements that need to run before you get to the point you care
    about. Obviously that is not ideal, so we're going to look at a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quit `repl` using *control* + *C;* now we're back at the `debugger`.
  prefs: []
  type: TYPE_NORMAL
- en: From here we are going to make a quick change to our application in `debugging.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to pause line seven between the person age property update
    and the person name property update. In order to pause, what we''re going to do
    is run the statement `debugger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When you have a `debugger` statement exactly like previous, it tells the Node
    `debugger` to stop here, which means instead of using `n` (next) to go statement
    by statement, you can use `c` (continue), which is going to continue until either
    the program exits or it sees one of the `debugger` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, over in Terminal, we''re going to rerun the program exactly like we did
    before. This time around, instead of hitting `n` twice, we''re going to use `c`
    to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42867c70-090f-49a4-823b-47716d408af2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, when we first used `c`, it went to the end of the program, printing out
    our object. This time around it's going to continue until it finds that `debugger`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use `repl`, access anything we like, for example, `person.age`,
    shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b03b7fd5-465f-4b47-9ccb-62001d425672.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we're done debugging, we can quit and continue through the program. Again,
    we can use *control* + *C* to quit `repl` and the `debugger`.
  prefs: []
  type: TYPE_NORMAL
- en: All real debugging pretty much happens with the `debugger` keyword. You put
    it wherever you want on your program, you run the program in debug mode, eventually
    it gets to the `debugger` keyword and you do something. For example you explore
    some variable values, you run some functions, or you play around with a code to
    find the error. No one really uses `n` to print through the program, finding the
    line that causes the problem. That takes way too much time and it's just not realistic.
  prefs: []
  type: TYPE_NORMAL
- en: Using debugger inside the notes application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know a little bit about the `debugger`, I want you to use it inside
    our notes application. What we will do inside `notes.js` is add the `debugger`
    statement in `logNote` function as the first line of the function. Then I will
    run the program in debug mode, passing in some arguments that will cause `logNote`
    to run; for example, reading a note, after the note gets fetched, it's going to
    call `logNote`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, once we have the `debugger` keyword in the `logNote` function and run it
    in debug mode with those arguments, the program should stop at this point. Once
    the program starts in debug mode, we'll use `c` to continue, and it'll pause.
    Next, we'll print out the note object and make sure it looks okay. Then, we can
    quit `repl` and quit the `debugger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, first we are adding the `debugger` statement right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We can save the file, and now we can move into Terminal; there's no need to
    do anything else inside our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside Terminal we''re going to run our `app.js` file, `node debug app.js`,
    because we want to run the program in debug mode. Then we can pass in our arguments,
    let''s say the `read` command, and I''ll pass in a title, `"to buy"` as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case I have a note with the title `"to buy"`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ded8b7f-6a54-4650-bf20-17b3fc935866.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, when I run the preceding command, it''s going to pause before that first
    statement runs, this is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f428f4ee-0406-45d7-a64b-7c23b5076cc5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I can now use `c` to continue through the program. It''s going to run as many
    statements as it takes for either the program to end or for the `debugger` keyword
    to be found, and as shown in the following code, you can see the `debugger` was
    found and our program has stopped on line `49` of `notes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bce52bf9-81cc-4761-9e11-b4338313dd2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is exactly what we wanted to do. Now, from here, I''ll go into `repl`
    and print out note argument, and as shown in the following code, you can see we
    have the note with the title of `to buy` and the body `food`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a679110-e8c9-4d36-badb-46050c40e9d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, if there was an error in this statement, maybe the wrong thing was printing
    to the screen, this would give us a pretty good idea as to why. Whatever gets
    passed into the `note` is clearly being used inside of the `console.log` statements,
    so if there was an issue with what's printing, it's most likely an issue with
    what gets passed into the `logNote` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've printed the `note` variable, we can shut down `repl`, and we
    can use *control* + *C* or `quit` to quit the `debugger`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we're back at the regular Terminal and we have successfully completed the
    debugging inside the Node application. In the next section, we're going to look
    at a different way to do the same thing, a way with a much nicer graphic user
    interface that I find a lot easier to navigate and use.
  prefs: []
  type: TYPE_NORMAL
- en: Listing notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've made some awesome progress on debugging, let's go back to the
    commands for our app, because there is only one more to fill out (we have covered
    the `add`, `read`, and `remove` commands in the [Chapter 3](49575d61-4c77-46aa-89b2-6dc4a771e7a5.xhtml),
    *Node Fundamentals - Part 2*, and this chapter, respectively). It's the `list`
    command, and it's going to be really easy, there is nothing complex going on in
    the case of the `list` command.
  prefs: []
  type: TYPE_NORMAL
- en: Using the getAll function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get started, all we need to do is fill out the list notes function,
    which in this case we called `getAll`. The `getAll` function is responsible for
    returning every single note. That means it's going to return an array of objects,
    an array of all of our notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do that is to return `fetchNotes`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There's no need to filter, there's no need to manipulate the data, we just need
    to pass the data from `fetchNotes` back through `getAll`. Now that we have this
    in place, we can fill out the functionality over inside of `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to create a variable where we can store the notes, I was going to call
    it notes, but I probably shouldn''t because we already have a notes variable declared.
    I''ll create another variable, called `allNotes`, setting it equal to the return
    value from `getAll`, which we know because we just filled out returns all the
    notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now I can use `console.log` to print a little message and I'll use template
    strings so I can inject the actual number of notes that are going to be printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the template strings, I''ll add `Printing`, then the number of notes
    using the `$` (dollar) sign and the curly braces, `allNotes.length`: that''s the
    length of the array followed by notes with the `s` in parenthesis to handle both
    singular and plural cases, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: So, if there were six notes, it would say printing six notes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this in place, we have to go about the process of actually
    printing each note, which means we need to call `logNote` once for every item
    in the `allNotes` array. To do, this we'll use `forEach`, which is an array method
    similar to filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filter lets you manipulate the array by returning `true` or `false` to keep
    items or remove items; `forEach` simply calls a callback function once for each
    item in the array. In this case we can use it using `allNotes.forEach`, passing
    in a callback function. Now, that callback function will be an arrow function
    (`=>`) in our case, and it will get called with the `note` variable just like
    filter would have. And all we''ll call is `notes.logNote`, passing in the `note`
    argument, which is right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And now that we have this in place, we can actually simplify it by adding the
    `logNote` call, as shown in here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is the exact same functionality, only using the expression syntax. Now
    that we have our arrow function (`=>`) in place, we are calling `notes.logNote`
    once for each item in the all notes array. Let's save the `app.js` file and test
    this out over in Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test out the `list` command, all I''ll use is `node app.js` with
    the command `list`. There is no need to pass in any arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When I run this, I do get `Printing 3 note(s)` and then I get my `3 notes to
    buy`, `to buy from store`, and `things to do`, as shown in the following code
    output, which is fantastic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab9b2740-398f-477a-9b8b-1a8401174145.png)'
  prefs: []
  type: TYPE_IMG
- en: With this in place, all of our commands are now working. We can add notes, remove
    notes, read an individual note, and list all of the notes stored in our JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to the next section, I want to clean up some of the commands. Inside
    `app.js` and `notes.js`, we have some `console.log` statements that are printing
    out a few things we no longer need.
  prefs: []
  type: TYPE_NORMAL
- en: At the very top of `app.js`, I am going to remove the `console.log('Starting
    app.js')` statement, making the constant `fs` the first line.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll also remove the two statements: `console.log(''Command: '', command)`
    and `console.log(''Yargs'', argv)` that print the command and the `yargs` variable
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside `notes.js`, I will also remove the `console.log('Stating notes.js')`
    statement at the very top of that file, since it is no longer necessary, putting
    constant `fs` at the top.
  prefs: []
  type: TYPE_NORMAL
- en: 'It was definitely useful when we first started exploring different files, but
    now we have everything in place, there''s no need. If I rerun the `list` command,
    this time you can see it looks a lot cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12afaa90-605a-4d34-b941-7927063c13e9.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Printing three notes` is the very first line showing up. With this in place,
    we have done our commands.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we're going to take a slightly more in-depth look at how
    we can configure yargs. This is going to let us require certain arguments for
    our commands. So if someone tries to add a note without a title, we can warn the
    user and prevent the program from executing.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced yargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get into the advanced discussion of yargs, first, I want to pull
    up the yargs docs so that you at least know where the information about yargs
    is coming from. You can get it by Googling `npm yargs`. We''re going to go to
    the yargs package page on npm. This has the documentation for yargs, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfa2cc27-5a01-4c21-9ddc-2b1843466003.png)'
  prefs: []
  type: TYPE_IMG
- en: Now there is no table of contents for the yargs docs, which makes it kind of
    difficult to navigate. It starts off with some examples that don't go in any particular
    order, and then eventually it gets into a list of all the methods you have available,
    and that's what we're looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'So I''ll use *command* + *F* (*C**trl* + *F*) to search the page for methods,
    and as shown in the following screenshot, we get the methods header, which is
    the one we''re looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fa42d20-cec8-46da-b968-6145e2366008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you scroll down on the page, we start to see an alphabetical list of all
    the methods you have access to inside of yargs. We''re specifically looking for
    `.command`; this is the method we can use to configure all four of our commands:
    the `add`, `read`, `remove` and `list` notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71cf9523-6b2b-4693-b539-b1fd414e4d7e.png)'
  prefs: []
  type: TYPE_IMG
- en: We're going to specify which options they require, if any, and we can also set
    up things like descriptions and help functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Using chaining syntax on yargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now in order to get started, we need to make some changes inside of `app.js`.
    We're going to start with the `add` command (for more information, please refer
    to the *Adding and saving notes* section in the previous chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to add a few helpful pieces of information in `argv` function inside
    `app.js`, that will:'
  prefs: []
  type: TYPE_NORMAL
- en: Let yargs verify the `add` command is ran appropriately, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let the user know how the `add` command is meant to be executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we are going to be chaining property calls, which means right before I
    access `.argv` I want to call `.command`, and then I''ll call `.argv` on the return
    value from command as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now this chaining syntax probably looks familiar if you've used jQuery, a lot
    of different libraries are supported. Once we call `.command` on `yargs`, we're
    going to pass in three arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is the command name, exactly how the user is going to type it
    in Terminal, in our case it''s going to be `add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''re going to pass another string in, and this is going to be a description
    of what the command does. It is going to be some sort of English readable description
    that a user can read to figure out weather that''s the command that they want
    to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The next one is going to be an object. This is going to be the options object
    that lets us specify what arguments this command requires.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the .help command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now before we get into the options object, let''s add one more call right after
    command. We''re going to call `.help`, which is a method, so we''re going to call
    it as a function, and we don''t need to pass in any arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When we add on this help call, it sets up `yargs` to return some really useful
    information when someone runs the program. For example, I can run the `node app.js`
    command with the `help` flag. The `help` flag is added because we called that
    help method, and when I run the program, you can see all of the options we have
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/434e3ad6-3f72-41d2-aa07-ddd4ebd637e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding output, we have one command, `add Add a new note`,
    and a `help` option for the current command, `help`. And the same thing holds
    true if we run the `node app.js add` command with `help` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In this output, we can view all of the options and arguments for `add` command,
    which in this case happens to be none because we haven''t set those up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2796f89-aa32-4f6e-a12d-f9207cc314c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the options object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add options and arguments back inside Atom. In order to add properties,
    we''re going to update the options object, where the key is the property name,
    whether it''s title or body, and the value is another object that lets us specify
    how that property should work, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Adding the title
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the case of title, we would add the title on the left-hand side, and we
    would put our options object on the right-hand side. Inside the title, we''re
    going to configure three properties `describe`, `demand`, and `alias`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `describe` property will be set equal to a string, and this is going to
    describe what is supposed to be passed in for the title. In this case, we can
    just use `Title of note`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we configure `demand`. It is going to tell yarg whether or not this argument
    is required. `demand` is `false` by default, we''ll set it to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if someone tries to run the add command without the title, it''s going
    to fail, and we can prove this. We can save `app.js`, and in Terminal, we can
    rerun our previous command removing the `help` flag, and when I do that, you see
    we get a warning, `Missing required argument: title` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e05b38db-694f-4630-86cc-911998fa1eed.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that in the output the title argument, is `Title of note`, which is the
    describe string we used, and it's `required` on the right side, letting you know
    that you have to provide a title when you're calling that `add` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with `describe` and `demand` we are going to provide a third option,
    this is called `alias`. The `alias` lets you provide a shortcut so you don''t
    have to type `--title`; you can set the alias equal to a single character like
    `t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: When you have done that, you can now run the command in Terminal using the new
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our add command, `node app.js add`, instead of `--title`. We''re
    going to use `-t`, which is the flag version, and we can set that equal to whatever
    we like, for example, `flag title` will be the title, and `--body` will get set
    equal to `body` , as shown in the following code. Note that we haven''t set up
    the body argument yet so there is no `alias`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If I run this command, everything works as expected. The flag title shows up
    right where it should, even though we used the alias version which is the letter
    `t`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b0f18d6-ad36-4f2c-be7d-2d5c9acb91fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our title configured, we can do the exact same thing for the
    body. We''ll specify our options object and provide those three arguments: `describe`,
    `demand`, and `alias` for `body`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one is `describe` and that one''s pretty easy. `describe` is going
    to get set equal to a string, and in this case `Body of note` will get the job
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The next one will be `demand`, and to add a note we are going to need a `body`.
    So we''ll set `demand` equal to `true`, just like we do up previous for `title`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And last but not least is the `alias`. The `alias` is going to get set equal
    to a single letter, I''ll use the letter `b` for `body`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can now save `app.js` and inside Terminal, we can take
    a moment to rerun `node app.js add` with the `help` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this command, we should now see the body argument showing up, and
    you can even see it shows the flag version, as shown in the following output,
    the alias `-b` (`Body of note`), and it is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5df5b7cf-c0be-4e87-84d8-ac70849a6b55.png)'
  prefs: []
  type: TYPE_IMG
- en: Now I'll run `node app.js add` passing in two arguments `t`. I'll set that equal
    to `t`, and `b` setting it equal to `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I run the command, everything works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/0dbbc4ca-fc51-4bde-97c4-e6c8fdd70afc.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding output screenshot, a new note was created with a title
    of `t` and a body of `b`. With this in place, we've now successfully completed
    the setup for the `add` command. We have our `add` command title, a description,
    and the block that specifies the arguments for that command. Now we do have three
    more commands to `add` support for, so let's get started doing that.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support to the read and remove commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the next line, I''ll call `.command` again, passing in the command name.
    Let''s do the `list` command first because this one is really easy, no arguments
    are required. Then we''ll pass in the description for the `list` command, `List
    all notes`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll call command again. This time we''ll do the command for `read`.
    The `read` command reads an individual note, so for the description for the `read`
    command, we''ll use something like `Read a note`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `read` command does require the title argument. That means we are going
    to need to provide that options object. I''ll take `title` from `add` command,
    copy it, and paste it in the `read` command options object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As you probably just noticed, we have repeated code. The title configuration
    just got copied and pasted into multiple places. It would be pretty nice if this
    was DRY, if it was in one variable we could reference in both locations, in `add`
    and `read` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Will call command for `remove`, just following where we called the command
    for `read`. Now, the `remove` command will have a description. We''ll stick with
    something simple like `Remove a note`, and we will be providing an options object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I can add the options object identical to the `read` command. However,
    in that options object, I''ll set title equal to `titleOptions`, as shown here,
    to avoid the repetition of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Adding the titleOption and bodyOption variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now I don''t have the `titleOptions` object created yet so the code would currently
    fail, but this is the general idea. We want to create the `titleOptions` object
    once and reference it in all the locations we use it, for `add`, `read` and `remove`
    command. I can take `titleOptions`, and add it for `read` as well as for `add`
    command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, just previous the constant `argv`, I can create a constant called `titleOptions`,
    and I can set it equal to that object that we defined for `add` and `read` command
    earlier, which is `describe`, `demand`, and `alias`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We now have the `titleOptions` in place, and this will work as expected. We
    have the exact same functionality we did before, but we now have the `titleOptions`
    in a separate object, which follows the DRY principle we discussed in the *Reading
    note* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we could also do the same thing for body. It might seem like overkill
    since we''re only using it in only one location, but if we''re sticking to the
    pattern of breaking them out into variables, I''ll do it in the case of the body
    as well. Just following the `titleOptions` constant, I can create the constant
    `bodyOptions`, setting it equal to the options object we defined in the body,
    for `add` command in the previous subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we are now done. We have `add`, `read`, and `remove`, all
    with their arguments set up referencing the `titleObject` and `bodyObject` variables
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the remove command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test out the `remove` command in Terminal. I''ll list out my notes using
    `node app.js list`, so I can see which notes I have to remove:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/2bf4487f-5b7d-4d4f-a6eb-19ab2a0fd555.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ll `remove` the note with the title `t`, using the `node app.js remove`
    command and our flag `"t"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/4540ae80-2c61-4d84-a2cb-30b5a8fe6232.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll remove the note with the title `t`, and as shown previous, `Note was
    removed` prints to the screen. And if I use the up arrow key twice, I can list
    the notes out again, and you can see the note with the title `t` has indeed gone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b79cac11-3635-4122-a919-4a842125edeb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s remove one more note using the `node app.js remove` command. This time
    we''re going to use `--title`, which is the argument name, and the note we''re
    going to `remove` has the title flag title, as shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ccc0a26-890f-4448-935f-c49832287ed3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When I remove it, it says `Note was removed`, and if I rerun the `list` command,
    I can see that we have three notes left, the note was indeed removed , as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ab2a505-caa3-4651-8b78-1e9175c1d94e.png)'
  prefs: []
  type: TYPE_IMG
- en: And that is it for the notes application.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're going to learn the ins and outs of the arrow function.
    It's an ES6 feature, and we have taken a little look at it. Inside `notes.js`
    we used it in a few basic examples to create methods such as `fetchNotes` and
    `saveNotes`, and we also passed it into a few array methods like filter, and for
    each array, we used it as the callback function that gets called once for every
    item in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you try to swap out all of the functions in a program with arrow functions,
    it's most likely not going to work as expected because there are some differences
    between the two, and it's really important to know what those differences are,
    so you can make the decision to use a regular ES5 function or an ES6 arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the arrow function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The goal in this section is to give you the knowledge to make that choice,
    and we''ll kick things off by creating a new file in the playground folder called
    `arrow-function.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/731e0521-5df6-436a-856b-d3f92a53017c.png)'
  prefs: []
  type: TYPE_IMG
- en: Inside this file, we're going to play around with a few examples, going over
    some of the subtleties to the arrow function. Before we type anything inside of
    the file, I'll start up this file with `nodemon`, so every time we make a change
    it automatically refreshes over in Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, `nodemon` is the utility we installed in [Chapter 2](9e56dc82-3ad8-4376-81b7-27ba482bd4e2.xhtml),
    *Node Fundamentals - Part 1.* It was a global npm module. The `nodemon` is the
    command to run, and then we just pass in the file path like we would for any other
    Node command. As we''re going into the `playground` folder, and the file itself
    is called `arrow-function.js`, we''ll run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll run the file, and nothing prints to the screen, as shown in the following
    output, besides the `nodemon` logs because we have nothing in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1e3be5f-d576-45bd-a62a-b67383e2ccc7.png)'
  prefs: []
  type: TYPE_IMG
- en: To get started, in the `arrowfunction.js` file, we'll create a function called
    square, by making a variable called square and setting it equal to an arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: To make our arrow function (`=>`), we'll first provide the arguments inside
    parentheses. Since we'll be squaring a number, we just need one number, and I'll
    refer to that number as `x`. If I pass in 3, I should expect 9 back, and if I
    pass in 9, I would expect 81 back.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the arguments list, we have to put the arrow in arrow function (`=>`)
    by putting the equal sign and the greater than symbol together, creating our nice
    little arrow. From here we can provide, inside curly braces, all the statements
    we want to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we might create a variable called result, setting that equal to `x` times
    `x`, then we might return the result variable using the `return` keyword, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, obviously this can be done on one line, but the goal here is to illustrate
    that when you use the statement arrow function (`=>`), you can put as many lines
    as you want in between those curly braces. Let''s call a square, we''ll do that
    using `console.log` so we can print the result to the screen. I''ll call square;
    and we''ll call square with `9`, the square of `9` would be `81`, so we would
    expect `81` to print to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll save the arrow function (`=>`) file, and in Terminal, `81` shows up just
    as we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21b9f647-5348-4b3a-83a5-ab26497ff142.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the syntax we used in the previous example is the statement syntax for
    the arrow function (`=>`). We''ve also explored the expression syntax earlier,
    which lets you simplify your arrow functions when you return some expressions.
    In this case all we need to do is specify the expression we want to return. In
    our case that''s `x` times `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You don't need to explicitly add the `return` keyword. When you use an arrow
    function (`=>`) without your curly braces, it's implicitly provided for you. That
    means we can save the function as shown previous and the exact same result is
    going to print to the screen, `81` shows up.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the great advantages of arrow functions when you use them in
    cases like filter or for those which we did in the `notes.js` file. It lets you
    simplify your code keeping everything on one line and making your code a lot easier
    to maintain and scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there is one thing I want to note: when you have an arrow function (`=>`)
    that has just one argument, you can actually leave off the parentheses. If you
    have two or more arguments, or you have zero arguments, you are going to need
    to provide the parentheses, but if you just have one argument, you can reference
    it with no parentheses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I save the file in this state, `81` still prints to the screen; and this
    is great we have an even simpler version of our arrow function (`=>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4e2555c-6985-440b-aa58-d124742921da.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have a basic example down, I want to move on to a more complex example
    that's going to explore the nuances between regular functions and arrow functions.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the difference between regular and arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate the difference, I''ll make a variable called `user`, which will
    be an object. On this object we''ll specify one property, name. Set name equal
    to the string, your name, in this case I''ll set it equal to the string `Andrew`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can define a method on the `user` object. Right after name, with my
    comma at the end of the line, I''ll provide the method `sayHi`, setting it equal
    to an arrow function (`=>`) that doesn''t take any arguments. For the moment,
    we''ll keep the arrow function really simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'All we''ll do inside `sayHi` is use `console.log` to print to the screen, inside
    of template strings `Hi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re not using template strings yet, but we will later so I''ll use them
    here. Down following the user object, we can test out `sayHi` by calling it, `user.sayHi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: I'll call it then save the file, and we would expect that `Hi` prints to the
    screen because all our arrow function (`=>`) does is use `console.log` to print
    a static string. Nothing in this case will cause any problems; you'd be able to
    swap out a regular function for an arrow function (`=>`) without issue.
  prefs: []
  type: TYPE_NORMAL
- en: Now the first issue that will arise when you use arrow functions is the fact
    that arrow functions do not bind a `this` keyword. So if you are using `this`
    inside your function, it's not going to work when you swap it out for an arrow
    function (`=>`). Now, `this` binding; refers to the parent binding, in our case
    there is no parent, function so this would refer to the global `this` keyword.
    Now we have our `console.log` that does not use `this`, I'll swap it out for a
    case that does.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll put a period after `Hi`, and I''ll say I''m, followed by the name, which
    we would usually be able to access via `this.name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'If I try to run this code, it is not going to work as expected; we''re going
    to get `Hi` I''m undefined printing to the screen, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eea15eba-3a6d-405a-a3a1-b431034523b1.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to fix this, we'll look at an alternative syntax to arrow functions
    that's great when you're defining object literals, as we are in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'After `sayHi`, I''ll make a new method called `sayHiAlt` using a different
    ES6 feature. ES6 provides us a new way to make methods on objects; you provide
    the method name, `sayHiAlt`, then you go right to the parentheses skipping the
    colon. There''s also no need for the function keyword, even though it is a regular
    function it''s not an arrow function (`=>`). Then we move on to our curly braces
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside here I can have the exact same code we have in the `sayHi` function,
    but it is going to work as expected. It''s going to print `Hi. I''m Andrew`. I''ll
    call `sayHiAlt` down following instead of the regular `sayHi` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'And in Terminal, you can see `Hi. I''m Andrew`, prints to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/690bbd43-6d64-4e48-899b-331536c9c9ed.png)'
  prefs: []
  type: TYPE_IMG
- en: The `sayHiAlt` syntax is a syntax that you can use to solve `this` problem when
    you create functions on object literals. Now that we know that the `this` keyword
    does not get bound, let's explore one other quirk that arrow functions have, it
    also does not bind the arguments array.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the arguments array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular functions, like `sayHiAlt`, are going to have an arguments array that''s
    accessible inside of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s not an actual array, it''s more like an object with array; like
    properties, but the arguments object is indeed specified in a regular function.
    If I pass in one, two, and three and save the file, we''ll get that back when
    we log out arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `nodemon`, it''s taking a quick second to restart, and right here we
    have our object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4603b24b-4f41-4e9d-8a4d-cb511609093d.png)'
  prefs: []
  type: TYPE_IMG
- en: We have one, two, and three, we have the index for each as the property name,
    and this works because we're using a regular function. If we were to switch to
    the arrow function (`=>`) though, it is not going to work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll add `console.log(arguments)` inside of my arrow function (`=>`), and
    I''ll switch from calling `sayHiAlt` back to the original method `sayHi`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'When I save the file in `arrow-function.js`, we''ll get something a lot different
    from what we had before. What we''ll actually get is the global arguments variable,
    which is the arguments variable for that wrapper function we explored:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d461c97-44a0-4def-937b-aa71b6da1349.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous screenshot, we have things like the require function, definition,
    our modules object, and a couple of string paths to the file and to the current
    directory. These are obviously not what we're expecting, and that is another thing
    that you have to be aware of when you're using arrow functions; you're not going
    to get the `arguments` keyword, you're not going to get the `this` binding (defined
    in `sayHi` syntax) that you'd expect.
  prefs: []
  type: TYPE_NORMAL
- en: These problems mostly arise when you try to create methods on an object and
    use arrow functions. I would highly recommend that you switch to `sayHiAlt` syntax
    which we discussed, in those cases. You get a simplified syntax, but you also
    get the disk binding and you get your arguments variable as you'd expect.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were able to reuse the utility functions that we already
    made in previous chapters, making the process of filling out a remove note that
    much easier. Inside `app.js`, we worked on how the `removeNote` function is executed,
    if it was executed successfully, we print a message; if it didn't, we print a
    different message.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we were able to successfully fill out the `read` command and we also created
    a really cool utility function that we can take advantage of in multiple places.
    This keeps our code DRY and prevents us from having the same code in multiple
    places inside of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Then we discussed a quick introduction to debugging. Essentially, debugging
    is a process that lets you stop the program at any point in time and play around
    with the program as it exists at that moment. That means you can play around with
    variables that exist, or functions, or anything inside of Node. We learned more
    about yargs, its configuration, setting up commands, their description, and arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Last, you explored a little bit more about arrow functions, how they work, when
    to use them, and when not to use them. In general, if you don't need this keyword,
    or the arguments keyword you can use an arrow function without a problem, and
    I always prefer using arrow functions over regular functions when I can.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore asynchronous programming and how we can
    fetch data from third-party APIs. We'll use both regular functions and arrow functions
    a lot more, and you'll be able to see firsthand how to choose between one over
    the other.
  prefs: []
  type: TYPE_NORMAL
