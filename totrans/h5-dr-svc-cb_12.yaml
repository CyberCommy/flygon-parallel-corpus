- en: Chapter 12. Multimedia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Playing audio files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing video files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing controls for media elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding text to your video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding multimedia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting text to speech using HTML5 audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML5 adds two elements audio and video, which provide a functionality that
    was previously done with use of add-ons to the browsers. In most of the cases,
    we find players that are Flash-based but that is lately being changed. Most of
    the browsers now have a good support for the basic HTML5 media element related
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Customization options for the player were very limited and vendor specific.
    Most of the sites had and some still have their own custom players that were done
    in Flash, since it was the best way to do the job.
  prefs: []
  type: TYPE_NORMAL
- en: Flash by itself is not going to disappear all of a sudden, but having alternative
    that uses open standards always makes a compelling case on why not to use it.
    The same is happening in the web game industry, HTML5 is taking over Flash-based
    games market each day.
  prefs: []
  type: TYPE_NORMAL
- en: Playing audio files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The audio element enables a simple way to play audio files in the browser. Adoption
    of this element had many controversial discussions mostly due to the lack of common
    grounds for a format. Initially Ogg Vorbis ([http://www.vorbis.com/](http://www.vorbis.com/))
    was the format suggested in the W3C specification.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up-to-date information on browser support for different formats can be found
    on `www.caniuse.com`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at the element and some of the basic attributes
    that can be applied on it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to play an audio we need an actual audio file. You can pick one on
    your own or use the one that comes with the example. The file will be served from
    the music folder. We will use Mozart—Clarinet Concerto in A K. 622, II. Adagio
    by Jason Weinberger & the WCFSO available at the free music archive [http://freemusicarchive.org/music/Jason_Weinberger__the_WCFSO/Jason_Weinberger__the_Waterloo-Cedar_Falls_Symphony_Orchestra/](http://freemusicarchive.org/music/Jason_Weinberger__the_WCFSO/Jason_Weinberger__the_Waterloo-Cedar_Falls_Symphony_Orchestra/).
  prefs: []
  type: TYPE_NORMAL
- en: The file is of type `.mp3`, but for the purpose of this example, we also need
    a `.ogg` file. There are plenty of converters available both online and offline
    so we can use [http://media.io](http://media.io) for example. There is also a
    converted `song.ogg` file available in the example files if you don't want to
    go through the hassle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a HTML file that will contain an audio player:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The body section will contain the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A small text for attribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And that is it, you should have an audio player accessible in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The old way was to use `<object>` and `<embed>` with a lot of player specific
    parameters passed to the embedded `.swf` file, looking something like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The new way is fairly simple, we can add an audio element with the `src` attribute
    specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically play a file on the page without giving options to the
    user about stopping the music. In order to have a player rendered by the user
    agent we add the attribute controls. One other limitation we impose by setting
    the `src` attribute is that only that file will be played. You might be wondering
    why we would need multiple sources but the reasoning is simple. With the current
    state some browsers support certain format but others do not. If we want to have
    support in all modern browsers then we supply the option to have multiple sources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this was the rough state of the browser format support
    using Windows as operating system.
  prefs: []
  type: TYPE_NORMAL
- en: '| Browser/Feature | WAV | Opus | Ogg | MP3 | ACC |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Firefox 20 | Yes | Yes | Yes | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Chrome 26 | Yes | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| IE 9 | No | No | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Opera | Yes | No | Yes | No | No |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beside the standard web sites that provide browser support stats you can also
    use a test suite done by SoundCloud to check individual features at [http://areweplayingyet.org/](http://areweplayingyet.org/)
    or the source on [https://github.com/soundcloud/areweplayingyet](https://github.com/soundcloud/areweplayingyet).
  prefs: []
  type: TYPE_NORMAL
- en: 'The source element provides us to specify multiple alternative resources for
    any media element. By itself it has no meaning so it should be part of some media
    tag. We can have multiple source elements that have different `src`, type, and
    media attributes. For example, we could have the following element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In case you are not sure that any of the source you have provided can be used
    in the users browsers, you can attach `onerror` event listener on the `source`
    element. This handler could serve to execute a fallback.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are few other attributes that can be used on a media elements. Besides
    the global attributes the media specified ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `autoplay` attribute: It is a Boolean value attribute that defines if browser
    should start playing the instant it has a big enough portion of the media file.
    The default state for this element is to be missing, meaning that we don''t have
    auto play by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `preload` attribute: It gives a hint to the browsers that the source file
    should be downloaded even if the user has not yet click on play. The idea here
    is that we expect at some point in the future that the file will be played, being
    synonymous with setting the value to `auto`. The value can be also set to `none`
    which hints that the browsers should hold on preloading since we don''t expect
    the user to press the play button. There is also the option to have the value
    of metadata, which would mean only to load the metadata of the media file, like
    the length for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `muted` attribute: It is also a Boolean-based attribute the has default
    value of false meaning there will be sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `loop` attribute: It sets the audio to beginning once finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `controls` attribute: It simply adds player controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `mediagroup` attribute: It is used to group multiple media elements, for
    example, if we want to have same controls for two elements we can set them to
    use the same media group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `crossorigin` attribute: It can be specified to restrict the src attributes
    to conform with **Cross Origin Resource Sharing** (**CORS**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the other customization's and access from JavaScript will be part of
    the following recipes. If we use the element without the controls attribute set
    it is a good idea to set the CSS for the audio element to `display:none` in order
    to ensure it will not take page space.
  prefs: []
  type: TYPE_NORMAL
- en: Playing video files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to add native support for videos in the browsers, HTML5 introduced
    the video element. This is very similar to an audio element, and the same attributes
    apply since they both share common interface. There are few other attributes that
    are available only for the video element. Also the codecs for the source are mostly
    different, for video we have H.264/MPEG-4, VP8, VP9, and Theora.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will see how to use the built-in player by creating a simple
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTML5 specification on media elements can be found at [http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need a video file to play with our player, so you can pick one on your own.
    We have picked to use one of the videos available at [http://archive.org/details/animationandcartoons](http://archive.org/details/animationandcartoons).
  prefs: []
  type: TYPE_NORMAL
- en: The video is called "Boogie Woogie Bugle Boy" by "Walter Lantz Productions"
    and in 1941 it was nominated for Oscar.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Archive.org also known as Internet Archive is a non-profit digital library with
    a mission of "universal access to all knowledge". Beside being a book library
    it also hosts a variety of multimedia. One of the more famous sub projects is
    the wayback machine, [http://archive.org/web/web.php](http://archive.org/web/web.php),
    an archive of snapshots from states of a website in the past. There is also a
    sub project called [nasaimages.org](http://nasaimages.org) intended co make images
    and video from NASA closer to the public. The amount of data available at Internet
    archive is enormous making it a great source of information.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will use a poster image that will be shown before the video
    starts; the image is titled `poster.png`, and is part of the example source, but
    you may use any image you like.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We create a simple HTML that will contain the video element and have a source
    to our video:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The body section will contain the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And the attribution will contain the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After opening this we should have a running video player like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/9282OT_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The video element is very similar to an audio element and all the attributes
    from audio apply on a video element. The video specific attributes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Width` and `height`: They represent the width and height of the element. To
    control will re-size the video to fit into the size specified. The actual size
    of the video depends on the file being played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poster`: It is an attribute that enables us to provide a static image to display
    on the video element until the user decide to play the video.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By adding various combination of attributes to the video, we can make the user
    experience much better; in our code example the video will get centered since
    the width and height attributes do not match the real width and height of the
    video.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to play specific range of the video there is a built-in support
    for that as well. For example we may want to play our video from the 30th second
    to the 40th second. To do this in the URL of the `src` attributes, we append a
    hash (`#`) followed by the fragment definition as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Variables `starttime` and `endtime` are optional, and can have a number that
    specifies the number of seconds from the start or have `hours:minutes:seconds`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to play from the 80th second until the end of the video, the source
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Videos are often served encoded in some lossy compressed format since they are
    very large to be transmitted as raw format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about lossy compression on the following link [https://en.wikipedia.org/wiki/Lossy_compression](https://en.wikipedia.org/wiki/Lossy_compression).
    The main idea is that the size of the original video is significantly reduced
    by sacrificing certain level of information and quality.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft and Apple have license to use H.264, or more commonly known by the
    extension `.mp4` or `.m4v`. The codec has may different versions and combinations,
    additionally it is supported by YouTube and iTunes making it a very popular choice.
    Firefox and Chrome had plans to drop support for it since the format is proprietary
    and certain royalties must be paid, making it a very controversial choice. Firefox
    is planned to support the codec in the future but only when a third-party decoder
    is available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More on H.264 can be found on [http://en.wikipedia.org/wiki/H.264/MPEG-4_AVC](http://en.wikipedia.org/wiki/H.264/MPEG-4_AVC).
  prefs: []
  type: TYPE_NORMAL
- en: Ogg Theora comes from [Xiph.org](http://Xiph.org), the organization that provided
    the `.ogg` container and the Vorbis audio codec we used in the audio element recipe,
    among other contributions. This is supported by Firefox, Opera, and Chrome, but
    not on IE and Safari, at least not by default.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More on Ogg Theora can be found on [http://www.theora.org/](http://www.theora.org/).
  prefs: []
  type: TYPE_NORMAL
- en: WebM is supports Vorbis as audio codec and VP8 as video. VP8 is a codec developed
    by a company called On2 that got bought by Google. Additionally there is WebM
    is supported by Chrome, Opera, and Firefox natively, as for IE and Safari the
    user is required to download additional plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More on WebM, the format, tools, and documentation sounding it can be found
    on [http://www.webmproject.org/](http://www.webmproject.org/).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having multiple source is good but not always an option. We also want to have
    a fallback for older browsers and to do that we must depend on a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you referencing a video from third-party pay site such as YouTube or Vimeo,
    you can simply place an `iframe` of the embedded player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are also server JavaScript libraries that make the fallback process simple.
    One of them is [http://mediaelementjs.com/](http://mediaelementjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation is simple since we only include the `.js` and `.css` files
    as dependencies as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the player fallback player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The fallback player is just one of the many features that come with `mediaelement.js`;
    there are lot of options for mobile browsers as well as lot of simplification
    for the API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are interested into more details on possible conversion tool or the politics
    behind the codecs as well as detailed explanation of them, take a look at Mark
    Pilgram's book *Dive into HTML5*,it is available at [http://fortuito.us/diveintohtml5/video.html](http://fortuito.us/diveintohtml5/video.html).
  prefs: []
  type: TYPE_NORMAL
- en: There is also an interesting article titled "Video for everybody" on the topic
    of enabling video support on different browsers, [http://camendesign.com/code/video_for_everybody](http://camendesign.com/code/video_for_everybody).
  prefs: []
  type: TYPE_NORMAL
- en: Customizing controls for media elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Media elements, currently video and audio, can be controlled using JavaScript
    since the elements theme self contain useful methods and attributes. In this recipe,
    we will go through some of the most basic functionality and methods that can be
    applied on elements that have the `HTMLMediaElement` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Specification on the HTML5 media element can be found at [http://www.w3.org/TR/html5/embedded-content-0.html#htmlmediaelement](http://www.w3.org/TR/html5/embedded-content-0.html#htmlmediaelement).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we will also need a video file, so we can use the same one from
    the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by creating a JavaScript controller that will have very rudimentary
    functionality of a media player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our controller methods will accept a selector for a command and execute the
    command, we need the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now in a simple scenario we probably could just use the standard methods without
    adding another layer, but the idea here is that we can extend the functionally
    as we see fit since we have accessible element from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the HTML we shall have a similar version to the one in the playing videos
    recipe. We will have a few buttons that will use our video controller and additionally
    add a simple style. Let''s add the following to the head section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The body part will contain the control buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And we add the dependencies to our `example.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After that we should have a fully running video player.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With JavaScript we can access and manipulate the attributes of any media element.
    This option enable us to do many different types of customization on the standard
    elements. Most of these properties are defined in `HTMLMediaElement`; there we
    can read and write to the `currentTime`, `playbackRate`, `volume`, `muted`, `defaultMuted`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more comprehensive list `HTMLMediaElement` attributes and what is read
    only please refer to the specification available at [http://www.w3.org/TR/html5/embedded-content-0.html#media-elements](http://www.w3.org/TR/html5/embedded-content-0.html#media-elements).
  prefs: []
  type: TYPE_NORMAL
- en: 'By changing attributes we can make custom players but also various different
    visual updates. There are large amount of different events that get trigger by
    media elements. On the events we can attach event listeners and make updates depending
    on the state change. The following events get triggered: `loadstart`, `abort`,
    `canplay`, `canplaythrough`, `durationchange`, `emptied`, `ended`, `error`, `loadeddata`,
    `loadedmetadata`, `pause`, `play`, `playing`, `progress`, `ratechange`, `seeked`,
    `seeking`, `stalled`, `suspend`, `timeupdate`, `volumechange`, and `waiting`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name of the events are self-explanatory, if you are interested into more
    details about a specific event you can read up what they are intended for, in
    the documentation at [http://www.w3.org/TR/html5/embedded-content-0.html#mediaevents](http://www.w3.org/TR/html5/embedded-content-0.html#mediaevents).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example we could add a listener to the rate speed that will display
    the current rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And then add an output element in the HTML with a call to our newly added method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now the first time the video is played the rate change event get's triggered
    and the rate is set to `1`. Every consecutive rate change will trigger the same
    event.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: W3C has a a great demo on events triggered by media elements at [http://www.w3.org/2010/05/video/mediaevents.html](http://www.w3.org/2010/05/video/mediaevents.html).
  prefs: []
  type: TYPE_NORMAL
- en: One other interesting thing to note here is that `<audio>` element can be used
    on video files as well, but only the audio stream from the files will be played.
  prefs: []
  type: TYPE_NORMAL
- en: Adding text to your video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When displaying multilingual videos we often want to provide text for persons
    who speak other languages. This is a common practice for many conference talks
    as well as plenty of movies and TV shows. In order to enable external text track
    resources in the video the WebVTT ([http://dev.w3.org/html5/webvtt/](http://dev.w3.org/html5/webvtt/))
    standard was created.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For simplicity, we will use the same video together with the poster images,
    same as we used in the other examples. As for the other files we will create them
    ourselves. You can also pick other video on your own since the video itself will
    not be all that relevant.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start with the HTML, where we include the video element and additionally
    add track elements as well as simple `example.js`. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the body element we include :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript will only log the objects available to our video element. The
    idea here is to show that tracks can be accessed and manipulated by code. The
    script will contain the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the `.vtt` flies that we included for the tracks we will create them
    manually. The file `video.vtt` will contain the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As for `karaoke.vtt` it will contain the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After running the example we should have subtitles at the given ranges.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you construct the WebVTT file manually you can notice that it is easy to
    make a mistake. There is good validator available at [http://quuz.org/webvtt/](http://quuz.org/webvtt/)
    with the source code on [https://github.com/annevk/webvtt](https://github.com/annevk/webvtt).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Video has been available for quite some time now but adding subtitles was not
    an option. The track element enables us in a standard way to add information to
    our video. Tracks are not just used for subtitles, but can also be used for other
    kinds of timed cues.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The general definition for the word *cue* is that it represents a thing said
    or done that serves as a signal to an actor or other performer to enter or to
    begin their speech or performance.
  prefs: []
  type: TYPE_NORMAL
- en: Cues can contain other data formats like JSON, XML, or CSV. In our example we
    included a small JSON data snippet. This data can be useful in many different
    ways since it connected with a given portion of time, but subtitles are not the
    real use of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The track element can contain the following values for its `kind` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '**subtitles**: It is the transcription or translation for a given language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**captions**: It is very similar to subtitles but it may also include sound
    effects or other audio. The main intention of this type is use for cases where
    the audio is not available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**descriptions**: It is a text description of the video meant for use where
    the visual part is not available. For example, it can provide description for
    users who are blind or unable to follow the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**chapters**: This track can contain chapter titles for given periods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**metadata**: This is a track is very useful for storing meta data that can
    latter be used by a script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the kind attribute there is also the `src` attribute that is mandatory
    and shows the URL of the track source. The track element can also contain `srclang`
    containing the language tag of the timed track.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The language tax often has two-letter unique key for representation of the specific
    language. For more details you can take a look at [http://tools.ietf.org/html/bcp47](http://tools.ietf.org/html/bcp47).
  prefs: []
  type: TYPE_NORMAL
- en: There is also the attribute `default`, where if present on a track that is the
    track that will be shown by default.
  prefs: []
  type: TYPE_NORMAL
- en: Also we can use the `label` attribute that can have free text value specifying
    a unique label for the element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One clever use of the track element can be found on : [http://www.samdutton.net/mapTrack/](http://www.samdutton.net/mapTrack/).'
  prefs: []
  type: TYPE_NORMAL
- en: The WebVTT standard defines that the file needs to start with the string "WEBVTT".
    Following that we have the cue definitions, zero or more such elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each cue element has the following form :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `idstring` is an optional element but it is good idea to have it specified
    if we need to access the cue using a script. As for the `timestamp` we have a
    standard format where the hours are optional. The second `timestamp` must be greater
    than first one.
  prefs: []
  type: TYPE_NORMAL
- en: Text string is allowed to contain simple HTML formatting like `<b>`, `<i>`,
    and `<u>` elements. There is an option to add a `<c>` element that can be used
    for adding a CSS class for portions of the text, for example `<c.className>styled
    text </c>`. There is also an option to add a so called voice label `<v someLabel>
    the awesome text </v>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cue settings are optional as well and are appended after the time range.
    In this setting we can pick whether the text is shown horizontally of vertically.
    The settings are case sensitive so they must be in lowercase as shown in the examples.
    The following settings can be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '**vertical**: It is used with values `vertical:rl` where the `rl` stands for
    writing right to left and `vertical:lr` for left to right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**line**: This setting specifies where the text will be shown vertically or
    in the case where we have already used vertical, it specifies the horizontal position.
    The value is specified with percentage or a number where the positive value means
    top and negative bottom. For example, `line:0` and `line:0%` indicate top and
    `line:-1%` or `line:100%` indicate bottom.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**position**: It is a setting that specifies where the text will be shown horizontally,
    or if we have vertical property set it specifies where the text is shown vertically.
    It should have value between 0 to 100 percent. For example, it can be `position:100%`
    meaning right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**size**: It specifies the width/height of the text area in percentage depending
    on the additional vertical setting. For example, `size:100%` means the text area
    will be shown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**align**: It is a property that sets the aligning of text within the space
    of the area defined by the size setting. It can have the following values `align:start`,
    `align:middle`, and `align:end`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text string we can also add more detailed order of appearance of given
    words, in a sort of karaoke style. For example, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It states that before the 2 seconds we have some text and the active cue `And
    more` is between 2 to 3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: One other thing to note about the text string is that the it cannot contain
    the string `-->` string, ampersand &or the less than character `<` since they
    are reserved. But no worries there we can always used the escaped version, for
    example `&amp;` for ampersand.
  prefs: []
  type: TYPE_NORMAL
- en: These restrictions do not apply if we use the file for metadata track.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also have the option to style the text using CSS. As previously mentioned
    VTT files can contain tracks with `<c.someClass>` for a more fine-grained styling
    but in the general case we want to apply the style on the entire track. Applying
    style for all the cues can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: But you may alienate the users by making their subtitles in comic sans.
  prefs: []
  type: TYPE_NORMAL
- en: There are also selectors for the past cues `::cue:past{}` and `::cue:future{}`
    that can be useful for making a karaoke-like rendering. We also can use the `::cue(selector)`
    pseudo selector to target a node matching some criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Not all of the feature are fully available in the modern browsers, most compliment
    at the time of writing is Chrome so for the others it is a good idea to use a
    polyfill. One such library is [http://captionatorjs.com/](http://captionatorjs.com/)
    that adds support to all the modern browsers. Besides adding support for the WebVTT
    it also supports formats like `.sub`, `.srt` and YouTube's `.sbv`.
  prefs: []
  type: TYPE_NORMAL
- en: There is also one other format that was developed for the video tracks. The
    name is **Timed Text Markup Language** (**TTML**) 1.0 [http://www.w3.org/TR/ttaf1-dfxp/](http://www.w3.org/TR/ttaf1-dfxp/)
    and it is only supported by IE without having any plans to get support in other
    browsers at the time of writing. The standard is more complex and it is based
    on XML but as such it is lot more verbose.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding multimedia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Media element can cooperate and be combined with other elements. Various CSS
    properties can be applied to the elements and there are options to combine video
    with SVG. We can embed video in canvas element and apply processing on the rendered
    images.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will create a simple case where we embed a video inside canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we will need a video for our video element and an additional
    requirement is that the video has Cross-Origin Resource Sharing support or is
    located on our local server. The simplest way to make sure of this is to have
    a video with our locally running server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many videos with different formats available from NASA and ESA at
    [http://www.spacetelescope.org/videos/astro_bw/](http://www.spacetelescope.org/videos/astro_bw/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will render a video on a canvas element by performing following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First start with the HTML file where we add a video element and a canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our example of JavaScript code will attach event handler that will start rendering
    a gray-scaled version of the video on a canvas element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We should have a running example. One additional note here is that our original
    video should be in color in order to notice the difference.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The video element should be clear by this point as for the canvas, we will start
    with the restrictions. Drawing an image on canvas has a CORS restriction. This
    security constrain actually makes sense since we are reading data from the image
    and executing code depending on that. This could be exploited by some malicious
    source so for that reason the constraints are added.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `canvas.getContext('2d')` we get a drawing context where we can draw
    the current image from our video element. Upon drawing the image we can modify
    the individual pixels. This gives us the option to create filters on our video.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example we create a simple grayscale filter. The filter function `toGrayScale`
    iterates over the pixel data and since every three values represent the color
    for a pixel in RGB, we read their data and create an adjusted value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Following this we apply the adjusted value to all of the three values. The magic
    number are picked so that they would compensate for the red and blue values since
    the average human eye is bad at seeing them. We could have used the average value
    of the three values here with similar results.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are interested into other filters there is a great article on the subject
    on [http://www.html5rocks.com/en/tutorials/canvas/imagefilters/](http://www.html5rocks.com/en/tutorials/canvas/imagefilters/)
    where the filters apply on a image but the same rules apply on videos as well.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One other interesting demo worth looking at is the Cube-like video player, [http://html5playbook.appspot.com/#Cube](http://html5playbook.appspot.com/#Cube),
    that uses variety of different ways to create cool effects.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in processing and synthesizing audio in an HTML5 application
    there is a new high-level API at [http://www.w3.org/TR/webaudio/](http://www.w3.org/TR/webaudio/)
    that enables just that.
  prefs: []
  type: TYPE_NORMAL
- en: Converting text to speech using HTML5 audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we were to build a web-based navigation applications today, most of the components
    would already be available. There are Google maps or open street map components
    to display maps, as well as API services that provide driving directions.
  prefs: []
  type: TYPE_NORMAL
- en: But what about voice-based navigation guidance? Wouldn't that require another
    API service that converts text to speech?
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to HTML5 audio and Emscripten (a C to JavaScript compiler), we can now
    use a free text-to-speech engine called espeak that works fully in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In this example we're going to use espeak to generate text entered by the user
    on a simple page. Most of the work will consist of preparations—we will need to
    set up `espeak.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download the speak.js from ([http://github.com/html5-ds-book/speak-js](http://github.com/html5-ds-book/speak-js)).
    Click on the download zip button and download the archive to a newly created folder.
    Extract the archive in that folder—it should create a sub folder called `speak-js-master`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the page `index.html` containing a text input field and a `Speak` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `example.js` and add an on click action to the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'From the command line, install `http-server` if not already installed then
    start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Open [http://localhost:8080](http://localhost:8080) in your browser and test
    the demo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The engine that converts the text to speech is eSpeak ([http://espeak.sourceforge.net/](http://espeak.sourceforge.net/)).
    This engine is written in C, however, the only language natively supported by
    browsers is JavaScript. How can we use this engine in the browser?
  prefs: []
  type: TYPE_NORMAL
- en: Emscripten is a compiler designed to work around this limitation. It takes LLVM
    bytecode generated by a LLVM compiler from C or C++ source code and converts it
    to JavaScript. Emscripen utilizes a lot of modern JavaScript features such as
    typed arrays, and relies on the great performance of modern optimizing JavaScript
    JIT compilers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid blocking the browser, the speech generator is invoked from a web worker
    created in `speakClient.js`. The generated WAV data is passed back by the worker,
    converted to base64 encoding and passed as a data URL to a newly created audio
    element. This element in turn is appended to the #audio element on the page and
    playback is activated by calling the `play` method.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more..
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Espeak is licensed under the GNU GPL v3 license. As such, it might not be suitable
    for proprietary projects.
  prefs: []
  type: TYPE_NORMAL
- en: More information about Emscripten can be found on the Emscripten wiki at [https://github.com/kripken/emscripten/wiki](https://github.com/kripken/emscripten/wiki).
  prefs: []
  type: TYPE_NORMAL
