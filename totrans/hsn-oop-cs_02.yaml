- en: Hello OOP - Classes and Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) is something special. If you search
    the internet for books on OOP, you''ll find hundreds of books on this topic. But
    still this topic will never become stale as it is the most efficient and most
    commonly used programming methodology in the industry. With the increase in the
    demand for software developers, there has also been an increase in the demand
    for good learning content. Our approach in this book is to describe the concepts
    of OOP in the simplest way. Understanding the basics of OOP is a must for developers
    who want to work with C#, as C# is a fully OOP language. In this chapter, we will
    try to understand what OOP actually is and the most basic concepts of OOP that
    are essential to begin our programming journey. Before anything else, let''s first
    start by analyzing the meaning of the term **object-oriented programming**.'
  prefs: []
  type: TYPE_NORMAL
- en: The first word is **object**. According to the dictionary, an object is something
    that can be seen, felt, or touched; something that has physical existence in the
    real world. If an item is virtual, this means that it doesn't have any physical
    existence and is not considered an object. The second word is **oriented**, which
    indicates a direction or something to aim for. For example, when we say that we
    are oriented toward the building, we mean that we are facing towards it. The third
    word is **programming**. I believe I don't have to explain what programming is,
    but in case you are totally unaware of what programming is and are reading this
    book to learn, let me explain briefly what programming is. Programming is just giving
    instructions to the computer. As the computer doesn't speak our language, we humans
    have to give instructions to the computer in a language that the computer understands.
    We humans call these instructions **computer programs**, as we are guiding or
    instructing a computer to do a particular thing.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the definitions of those three keywords, if we put all these
    words together, we can understand the meaning of the phrase *object-oriented programming*.
    OOP means that we write our computer programs by keeping objects at the center
    of our thinking. OOP is neither a tool nor a programming language—it is just a
    concept. Some programming languages are designed to follow this concept. C# is
    one of the most popular object-oriented languages. There are other object-oriented
    languages, such as Java, C++, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In OOP, we try to think about our software components as small objects, and
    create relationships between them to solve a problem. You may have came across
    this approach with other programming concepts in the programming world, such as
    procedural programming, functional programming, and other kinds of programming.
    One of the most popular computer programming languages of all time—the C programming
    language—is a procedural programming language. F# is an example of a functional
    programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics of OOP:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes in OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general form of a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an object?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods in a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characteristics of OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes in OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In OOP, you derive objects from classes. In this section, we'll take a closer
    look at what a class actually is.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are one of the most important concepts in OOP. You can say they are
    the building blocks of OOP. A class can be described as the blueprint of an object.
  prefs: []
  type: TYPE_NORMAL
- en: A class is like a template or blueprint that tells us what properties and behaviors
    an instance of this class will have. In most circumstances, a class itself can't
    actually do anything—it is just used to create objects. Let's look at an example
    to demonstrate what I am saying. Let's say we have a `Human` class. Here, when
    we say `Human`, we don't mean any particular person, but we are referring to a
    human being in general. A human that has two hands, two legs, and a mouth, and
    which can also walk, talk, eat, and think. These properties and their behaviors
    are applicable to most human beings. I know that this is not the case for disabled
    people, but for now, we will assume our generic human is able—bodied, keeping
    our example simple. So when we see the aforementioned properties and behaviors
    in an object, we can easily categorize that object as a human object or person.
    This classification is called a class in OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the properties and behaviors of a `Human` class.
    There are hundreds of properties that you can list for a human, but for the sake
    of simplicity, we can say that the following are the properties of a human being:'
  prefs: []
  type: TYPE_NORMAL
- en: Height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Age
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can do the same for behavioral properties. There are hundreds of particular
    behaviors that a person can perform, but here we will only consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Walk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Talk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general form of a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a class in C#, you have to follow a particular syntax. The general
    form of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `class` phrase is a **reserved keyword** in C#, and it is used to tell
    the compiler that we want to create a class. To create a class, place the `class` keyword and
    then the name of the class after a space. The name of the class can be anything
    that starts with a character or an underscore. We can also include numbers in
    the class name, but not the first character of a class name. After the chosen
    name of the class, you have to put an opening curly brace, which denotes the start
    of the class body. You can add content in the class, such as properties and methods,
    and then finish the class with a closing curly brace, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are other keywords that can be used with classes to add more functionality,
    such as access modifiers, virtual methods, partial methods, and so on. Don't worry
    about these keywords or their uses, as we will discuss these later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s create our first class. Let''s imagine that we are developing some
    software for a bank. Our application should keep track of the bank''s customers
    and their bank accounts, and perform some basic actions on those bank accounts.
    As we are going to design our application using C#, we have to think of our application
    in an object-oriented way. Some objects that we will need for this application
    could be a customer object, a bank account object, and other objects. So, to make
    blueprints of these objects, we have to create a `Customer` class and a `BankAccount`
    class, as well as the other classes that we will need. Let''s first create the
    `Customer` class using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We started with the `class` keyword and then the name of the class, which is
    `Customer`. After that, we added the class body inside curly braces, `{}`. The variables
    that the class has are `firstName`, `lastName`, `phoneNumber`, and `emailAddress`.
    The class also has a method called `GetFullName()`, which uses the `firstName`
    and the `lastName` fields to prepare the full name and return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a `BankAccount` class using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we have followed a similar approach to create a class.
    We have used the `class` keyword and then the name of the `BankAccount` class .
    After the name, we started the class body with an opening curly brace and entered
    fields such as `bankAccountNumber`, `bankAccountOwnerName`, `amount`, and `openningDate`,
    followed by two methods, `Credit` and `Debit`. By placing a closing curly brace,
    we end the class body.
  prefs: []
  type: TYPE_NORMAL
- en: For now, don't get worried about keywords such as **public**; we will learn
    about these keywords later in the book when we talk about access specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Objects in OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know what a **class** is. Now let's look at what **object** refers to
    in OOP.
  prefs: []
  type: TYPE_NORMAL
- en: An object is an instance of a class. In other words, an object is an implementation
    of a class. For example, in our banking application, we have a `Customer` class,
    but that doesn't mean that we actually have a customer in our application. To
    create a customer, we have to create an object of the `Customer` class. Let's
    say that we have a customer called Mr. Jack Jones. For this customer, we have
    to create an object of the `Customer` class, where the name of the person is Jack
    Jones.
  prefs: []
  type: TYPE_NORMAL
- en: As Mr. Jones is our customer, this means that he also has an account in our
    bank. To create a bank account for Mr. Jones, we have to create an object of the `BankAccount` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to create objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C#, to create an object of a class, you have to use the `new` keyword. Let''s
    look at an example of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we started by writing `Customer`, which is the name of the class. This
    represents the type of the object. After that, we gave the name of the object,
    which in this case is `customer1`. You can give any name to that object. For example,
    if the customer is Mr. Jones, we could name the object `jackJones`. After the
    object name, we then inserted an equals sign (`=`), which means that we are assigning
    a value to the `customer1 `object. After that, we entered a keyword called `new`,
    which is a special keyword that tells the compiler to create a new object of the
    class that is given next to it. Here, we gave `Customer` again with `()` next
    to it. When we place `Customer()`, we are actually calling the constructor of
    that class. We will talk about constructors in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create `jackJones` by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Variables in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous code, you might have noticed that we created a few variables.
    A **variable** is something that varies, which means it is not constant. In programming,
    when we create a variable, the computer actually allocates a space in memory for
    it so that a value of the variable can be stored there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assign some values to the variables of the objects that we created in
    the previous section. We will first work with the `customer1` object, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are assigning values to the `customer1` object. The code instructs
    the computer to create a space in the memory and store the value in it. Later,
    whenever you access the variable, the computer will go to the memory location
    and find out the value of the variable. Now, if we write a statement that will
    print the value of the `firstName` variable with the additional string before
    it, it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Methods in a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s talk about another important topic—namely methods. A **method** is a
    piece of code that is written in the code file and can be reused. A method can
    hold many lines of code, which will be executed when it is called. Let''s take
    a look at the general form of a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the first thing in the method declaration is an `access-modifier`.
    This will set the access permission of the method. Then, we have the `return-type`
    of the method, which will hold the type that the method will return, such as `string`,
    `int`, `double`, or another type. After that, we have the `method-name` and then
    brackets, `()`, which indicate that it is a method. In the brackets, we have the `parameter-list`.
    This can either be empty or can contain one or more parameters. Finally, we have
    curly brackets, `{}`, which hold the method body. The code that the method will
    execute goes inside here.
  prefs: []
  type: TYPE_NORMAL
- en: Any code following this structure will be considered a method by the C# compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know what a method is, let''s take a look at an example, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code will create a method called `GetFullName`. This method takes two parameters,
    `firstName` and `lastName`, which are placed inside the parentheses. We can also
    see that we have to specify the types of those parameters. In this particular
    example, both the parameter types are `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, take a look at the method body, which is the section between the curly
    brackets, `{}`. We can see that the code returns `firstName + lastName`, which
    means that it is concatenating the two parameters, `firstName` and `lastName`,
    and returning the `string`. As we are planning to return a `string` from this
    method, we set the return type of the method to `string`. Another thing to notice
    is that the access type is set to `public` for this method, which means that any
    other class can access it.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor of a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In every class, there is a special type of method, called a **constructor**.
    You can create a constructor in a class and program it. If you don't create one
    yourself, the compiler will create a very simple constructor and use that instead.
    Let's take a look at what the constructor is and what it does.
  prefs: []
  type: TYPE_NORMAL
- en: A constructor is a method that gets triggered when an object of a class is created.
    A constructor is mainly used to set the prerequisites of the class. For example,
    if you are creating an object of the `Human` class, that human object must have
    a `date of birth`. Without a date of birth, no human would exist. You can set
    this requirement in the constructor. You can also configure the constructor to
    set the `date of birth` as today if no date of birth is given. This depends on
    the needs of your application. Another example could be a `bank account` object,
    for which you have to provide the bank account holder. No bank account can exist
    without an owner, so you can set this requirement in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the general form of a constructor, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that there is a difference between a constructor and a normal
    method, namely that a constructor doesn''t have a return type. This is because
    a constructor can''t return anything; it''s for initialization, not for any other
    type of action. Normally, the type of access is `public` for constructors, because
    otherwise no object can be instantiated. If you specifically want to prevent objects
    of a class from being instantiated, you can set the constructor as `private`.
    Let''s look at an example of a constructor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can see that we have a class called `BankAccount` and that
    it has a variable called `owner`. As we know, no bank account can exist without
    an owner, so we need to assign a value to the `owner` when an object is created.
    In order to create a `constructor`, we just make the access type of the constructor
    `public`, as we want objects to get instantiated. We can also take the name of
    the owner of the bank account as a parameter in the constructor and use it to
    assign the variable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you put parameters in the constructor, then, when initializing the object,
    the parameters need to be passed, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Another interesting thing is that you can have multiple constructors in a class.
    You might have one constructor that takes one argument and another that doesn''t
    take any arguments. Depending on the way in which you are initializing the object,
    the respective constructor will be called. Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can see that we have two constructors for the `BankAccount` class.
    If you pass a parameter when you create a `BankAccount` object, it will call the
    second constructor, which will set the value and create the object. If you don't
    pass a parameter while creating the object, the first constructor will be called.
    If you don't have either one of these constructors, this method of object creation
    won't be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t create a class, then the compiler creates an empty constructor
    for that class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Characteristics of OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OOP is one of the most important programming methodologies nowadays. The whole
    concept depends on four main ideas, which are known as the **pillars of OOP**.
    These four pillars are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The word **inheritance** means receiving or deriving something from something
    else. In real life, we might talk about a child inheriting a house from his or
    her parents. In that case, the child has the same power over the house that his
    parents had. This concept of inheritance is one of the pillars of OOP. In programming,
    when one class is derived from another class, this is called inheritance. This
    means that the derived class will have the same properties as the parent class.
    In programming terminology, the class from which another class is derived is called
    the **parent class**, while the classes that inherit from these are called **child
    classes**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we used inheritance. We have a parent class, called
    `Fruit`. This class holds the common properties that every fruit has: a `Name`
    and a `Color`. We can use this `Fruit` class for all fruits.'
  prefs: []
  type: TYPE_NORMAL
- en: If we create a new class, called `Apple`, this class can inherit the `Fruit`
    class because we know that an apple is a fruit. The properties of the `Fruit`
    class are also properties of the `Apple` class. If the `Apple` inherits the `Fruit`
    class, we don't need to write the same properties for the `Apple` class because
    it inherits these from the `Fruit` class.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Encapsulation** means hiding or covering. In C#, encapsulation is achieved
    by **access modifiers**. The access modifiers that are available in C# are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal protected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation is when you want to control other classes' access to a certain
    class. Let's say you have a `BankAccount` class. For security reasons, it isn't
    a good idea to make that class accessible to all classes. It's better to make
    it `Private` or use another kind of access specifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also limit access to the properties and variables of a class. For example,
    you might need to keep the `BankAccount` class `public` for some reason, but make
    the `AccountBalance` property `private` so that no other class can access this
    property except the `BankAccount` class. You can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Like variables and properties, you can also use access specifiers for methods.
    You can write `private` methods that are not needed by other classes, or that
    you don''t want to expose to other classes. Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `GetBalanceAfterTax` method is a method that will
    not be needed by other classes. We only want to provide the `AccountBalance` after
    tax, so we can make this method private.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is a very important part of OOP as it gives us control over code.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If something is abstract, it means that it doesn''t have an instance in reality
    but does exist as an idea or concept. In programming, we use this technique to
    organize our thoughts. This is one of the pillars of OOP. In C#, we have `abstract`
    classes, which implement the concept of abstraction. **Abstract classes** are
    classes that don''t have any instances, classes that implement the `abstract`
    class will implement the properties and methods of that `abstract` class. Let''s
    look at an example of an `abstract` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have an abstract class called `Vehicle`. It has
    one abstract method, called `GetNumberOfTyres()`. As it is an abstract method,
    this has to be overridden by the classes that implement the abstract class. Our `Bicycle`
    and `Car` classes implement the `Vehicle` abstract class, so they also override
    the abstract method `GetNumberOfTyres()`. If you take a look at the implementation
    of these methods in the two classes, you will see that the implementation is different,
    which is due to abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The word **polymorph** means many forms. To understand the concept of **polymorphism**
    properly, let's work with an example. Let's think about a person, such as Bill
    Gates. We all know that Bill Gates is a great software developer, businessman,
    philanthropist, and also a great human being. He is one individual, but he has
    different roles and performs different tasks. This is polymorphism. When Bill
    Gates was developing software, he was playing the role of a software developer.
    He was thinking about the code he was writing. Later, when he became the CEO of
    Microsoft, he started managing people and thinking about growing the business.
    He's the same person, but with different roles and different responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, there are two kind of polymorphism: **static polymorphism** and **dynamic
    polymorphism**. Static polymorphism is a kind of polymorphism where the role of
    a method is determined at compilation time, whereas, in dynamic polymorphism,
    the role of a method is determined at runtime. Examples of static polymorphism
    include **method overloading** and **operator overloading**. Let''s take a look
    at an example of method overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we have two methods with the same name, `AddNumbers`.
    Normally, we can't have two methods that have the same name; however, as the parameters
    of those methods are different, methods are allowed to have the same name by the
    compiler. Writing a method with the same name as another method, but with different
    parameters, is called method overloading. This is a kind of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like method overloading, **operator overloading** is also a static polymorphism.
    Let''s look at an example of operator overloading to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can see that the plus sign (`+`) is overloaded
    with another kind of calculation. So if you sum up two `MyCalc` objects, you will
    get an overloaded result instead of the normal sum, and this overloading happens
    at compile time, so it is static polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic polymorphism** refers to the use of the abstract class. When you
    write an abstract class, no instance can be created from that abstract class.
    When any other class uses or implements that abstract class, the class also has
    to implement the abstract methods of that abstract class. As different classes
    can implement the abstract class and can have different implementations of abstract
    methods, polymorphic behavior is achieved. In this case, we have methods with
    the same name but different implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers classes and objects, the most important building blocks
    of OOP. These are the two things that we should learn before jumping into any
    other topics in OOP. It is important to make sure that these concepts are clear
    in our minds before moving on to other ideas. In this chapter, we learned about
    what a class is and why it's needed in OOP. We also looked at how to create a
    class in C# and how to define an object. After that, we looked at the relationship
    between classes and objects and how to instantiate a class and use it. We also
    talked about variables and methods in a class. Lastly, we covered the four pillars
    of OOP. In the next chapter, we will learn more about inheritance and class hierarchy.
  prefs: []
  type: TYPE_NORMAL
