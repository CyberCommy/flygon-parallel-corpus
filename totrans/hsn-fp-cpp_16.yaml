- en: Immutability and Architecture - Event Sourcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event sourcing is an architectural pattern that takes advantage of immutability
    for storage. The fundamental idea of event sourcing is the following—instead of
    storing the current state of data, how about we store the events that modify the
    data? This idea may seem radical, but it's not new; in fact, you're already using
    tools based on this principle—source-control systems such as Git follow this architecture.
    We will explore this idea in more detail, including a discussion about its advantages
    and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How the concept of immutability can be applied to data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What event sourcing architecture looks like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What to take into account when deciding whether to use event sourcing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports C++ 17\. I used GCC 7.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: The code can be found on GitHub at [https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the  `Chapter13` folder. It includes and uses `doctest`, which is a single-header
    open source unit testing library. You can find it on its GitHub repository at [https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest).
  prefs: []
  type: TYPE_NORMAL
- en: Immutability and architecture – event sourcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until around 2010, the choice of data storage was quite limited. Whether your
    preferred choice was Oracle, MySQL, or PostgreSQL, you were pretty much bound
    to using a relational model for your data.
  prefs: []
  type: TYPE_NORMAL
- en: Then, suddenly, a plethora of new database engines popped up out of nowhere,
    with partial-to-no support for relational data. They were so different that they
    defied positive categorization, so the world ended up naming them based on what
    they didn't do—NoSQL databases. Indeed, their only commonality was that the support
    for SQL was little-to-none. The list of engines is long and changing, but at the
    time of writing, a few are prevalent—Redis, MongoDB, DynamoDb, Cassandra, and
    Couchbase, among others. Each of these engines has its own strengths and weaknesses,
    and the reason for their appearance is optimizing for various scenarios, usually
    in the context of cloud computing. For example, Cassandra is highly distributed,
    while MongoDB allows the easy storage of many types of data.
  prefs: []
  type: TYPE_NORMAL
- en: Around the same time I heard about NoSQL, I started hearing about a new architectural
    pattern called event sourcing. Event sourcing takes a radically different approach
    to data storage compared to the usual UI-server-RDBMS pattern. Instead of storing
    the current state of the system, the event sourcing pattern says—why don't we
    store the incremental changes to the system encoded as *domain events*?
  prefs: []
  type: TYPE_NORMAL
- en: 'The astute reader will notice two things about this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: It sounds like something that would come out of the **domain-driven design**
    (**DDD**) movement, and indeed it has. Domain events can be just another pattern
    that we use as part of our DDD approach to architecture and as part of the evolution
    of our domain models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea of storing incremental changes in a data store, although radical for
    business applications, is not new in software architecture. In fact, I have been
    using a tool that is based on this pattern throughout the writing of this book.
    You probably also used it to get the code samples. While using a more complex
    model for history than what we'll discuss for event sourcing, Git stores incremental
    changes alongside the current state of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git is not the only tool using this pattern. We have been using such tools in operations for
    data backup for years. Since a full backup can take a very long time, a good strategy
    mixes frequent incremental backups with infrequent full backups. However, the
    trick is that, when recovery is needed, we can apply the incremental backups one
    after another, leading to the same state as a full backup. It's a good trade-off
    between the time and storage used for backups on one side and the time needed
    to restore a backup on the other.
  prefs: []
  type: TYPE_NORMAL
- en: By this point, you may wonder what event sourcing has to do with NoSQL databases,
    other than being related to storage? While I can't prove it, I believe the two
    ideas came from the same current of thought surrounding programming in the 2010s—optimize
    development speed by removing technical obstacles and optimize systems for various
    web and cloud-based architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think for a moment about Twitter. In terms of data flow, Twitter has two
    main features—posting a message and seeing the messages other people have posted.
    If you don't immediately see the message that another user has posted, you won't
    even know about it, so high latency is allowed. However, we don't want to lose
    data so we need the user message to be stored as quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The standard way to implement something like this has been to save the message
    directly into a database upon request and return the updated feed on response.
    This allows us to see the message immediately, but it has a few disadvantages.
    First, it makes the database a bottleneck, because every posted message executes
    both an `INSERT` and a `SELECT` statement. Second, it requires more resources
    on the server, thus increasing costs for cloud-based servers.
  prefs: []
  type: TYPE_NORMAL
- en: What if we think differently? When you post a message, we just save an event
    into a fast event store and return it immediately. Upon a future request to update
    the feed, the event is taken into account and the updated feed is returned. The
    data store is not a bottleneck anymore and we've reduced the server load. However,
    we have added a new element in the system, the event store, which may cost a bit
    more, but it turns out that, at high scale, this can be less expensive and more
    responsive than the alternative. This is an example of event sourcing.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to solve this at the data engine level and separate the writes
    and reads as previously stated; however, we use a data store that is optimized
    for writing. The downside is that the data will be available for reading with
    a higher latency than before, but that's OK. At some point in the future, it becomes
    available and the message feed is updated. This is an example of using a NoSQL
    database instead of an RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: The 2010s were very interesting indeed, giving rise to a number of new ideas
    in software architecture and design while introducing functional programming into
    mainstream programming languages. Incidentally, they were also interesting for
    the release of the interconnected series of superhero movies from **Marvel Cinematic
    Universe** (**MCU**). There's no connection between the two, I just like the MCU!
    However, I have to stop fanboying (about the history of software design and MCU)
    and move on to another weird idea—taking immutability into data storage.
  prefs: []
  type: TYPE_NORMAL
- en: Taking immutability to architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen that immutability has a profound effect on code structure, and, therefore,
    on software design. We've also discussed, on multiple occasions, that I/O is fundamentally
    mutable. We're about to show that data storage is not necessarily mutable and
    that immutable data storage also has a profound effect on architecture.
  prefs: []
  type: TYPE_NORMAL
- en: How can data storage be immutable? After all, the whole reason for many software
    applications is to do CRUD—create, retrieve, update, and delete. The only operation
    that doesn't change data is retrieve, although, in some cases, retrieving data
    can have additional side effects such as analytics or logging.
  prefs: []
  type: TYPE_NORMAL
- en: However, remember that we face the same problem with data structures. A mutable
    data structure will change its structure when adding to an element or deleting
    from it. Yet, pure functional languages support immutable data structures.
  prefs: []
  type: TYPE_NORMAL
- en: An immutable data structure has the following property—adding or deleting items
    does not change the data structure. Instead, it returns a copy of the initial
    data structure plus the changes. To optimize memory, purely functional programming
    languages don't actually clone the data, they just make smart use of pointers
    to reuse the existing memory. However, for the programmer, it is as if the data
    structure has been completely cloned.
  prefs: []
  type: TYPE_NORMAL
- en: Consider applying the same idea to storage. Instead of changing the existing
    data, every write or delete creates a new version of the data with the applied
    changes, while leaving the previous version intact. Imagine the possibilities;
    we get the whole history of data changes and we can always recover them because
    we have a very recent version of the data.
  prefs: []
  type: TYPE_NORMAL
- en: That's not so easy though. Stored data tends to be large and duplicating it
    on every change will eat up huge storage space and become extremely slow in the
    process. The same optimization technique as for in-memory data doesn't work so
    well since stored data tends to be more complex and pointers aren't (yet?) as
    easy to manage for filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there's an alternative—store a version of data to begin with and
    just store a number of changes to the data. We could implement this in a relational
    database (the changes are just entities after all), but fortunately, we don't
    have to. To support this storage model, storage engines collectively called **event
    stores** have been implemented. They allow us to store events and get the latest
    version of data when we need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'How would such a system work? Well, we need to model the domain and domain
    events. Let''s do this for Twitter as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48cff6f2-742f-4b2e-82f6-cf016f2a3624.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we were using traditional data storage, we would just save the entities
    somehow, but we want to store events, so what we''ll have is a long list of incremental
    changes, conceptually looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Before we move on to see an example of implementation, we need to remember we're
    discussing software architecture, and no solution is perfect. Therefore, we have
    to stop and consider for a moment the trade-offs we're making when using event
    sourcing.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of event sourcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We wouldn't be talking about event sourcing if it didn't have advantages.
  prefs: []
  type: TYPE_NORMAL
- en: On a conceptual level, the domain model and domain events can be easily extracted
    from domain experts in very fast, lightweight sessions. Event storming is a facilitated
    session that allows us to design a complex system in hours, through collaboration
    between tech and domain experts. The knowledge created in this event is not to
    be underestimated; such common understanding is a strong basis for any collaboration
    across areas in a complex endeavor in knowledge work.
  prefs: []
  type: TYPE_NORMAL
- en: On a software design level, event sourcing reveals intent better than other
    code structures. Domain operations tend to hide inside entities; with event sourcing,
    the changes to the domain model are front and center to the architecture. We can
    actually search for all the changes that data can go through, and obtain a list—something
    that's difficult for other code structures.
  prefs: []
  type: TYPE_NORMAL
- en: On a coding level, event sourcing simplifies programming. While thinking in
    events may be difficult at first, it can quickly become second nature. This model
    allows us to write code that reflects the most important business features, thus
    leading to an easier understanding between programmers and product owners or clients.
    It also neatly encapsulates each type of change, thus simplifying our testing
    and code.
  prefs: []
  type: TYPE_NORMAL
- en: On a data-storage level, event sourcing allows us to see a list of changes made
    to the data, an extreme feat for other data-storage models. Incremental backups
    fit better in this model since it's fundamentally incremental. Recovery is built
    into the data storage, allowing us to start from any past materialized storage
    and apply all the events.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, event sourcing allows us to go back in time. If every event has an
    opposite event, which is usually quite easy to do, we can play the opposite events
    from the end to a certain timestamp, leading us to the exact data we had at that
    time.
  prefs: []
  type: TYPE_NORMAL
- en: On a performance level, event sourcing optimizes writing data, making it very
    useful for most applications that require fast writes but can deal with latency
    on reads (also known as **most web-based systems**).
  prefs: []
  type: TYPE_NORMAL
- en: But nothing comes for free, so what can go wrong?
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages and caveats of event sourcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all its advantages, event sourcing could become a prevalent way of architecting
    complex applications, but it has a few important drawbacks that you need to consider
    before jumping on the wagon.
  prefs: []
  type: TYPE_NORMAL
- en: Changing an event schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first issue comes from the core model of event sourcing—what if we need
    to change the structure of an event after we already have a bunch of data? For
    example, what if we need to add a timestamp to each of our events? Or what if
    we need to change our `PostMessage` event to include a field for visibility, which
    could be only receiver, only followers, or everyone?
  prefs: []
  type: TYPE_NORMAL
- en: This problem has solutions, but each comes with its own problems. One solution
    is to version the event schema and have multiple schemas side by side, which works
    but complicates the materialization. Another solution would be to use data migration
    scripts to change past events, but it breaks the concept of immutability and has
    to be done right. Another option is to never change an event schema, just add
    a new event type, but this can lead to confusion due to multiple deprecated event
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Delete past data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second issue is with privacy. The **General Data Protection Regulation**
    (**GDPR**) adopted recently in the **European Union** (**EU**), affecting many
    software systems around the world, gives a user the right to ask for the complete
    deletion of private data from a system. When using a normal database, this is
    relatively easy—just delete the records related to the user ID—but how do we do
    this in an event store?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by deleting all of the events related to a user. But can we do
    that? We may hit a problem if the events have a temporal relationship. Imagine,
    for example, the following scenario for collaboratively editing a document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s mark the events we need to delete if the user `alexboly` asks us to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Do you see the problem? Not only do we lose data from the document if we delete
    the highlighted events, but the indexes don't match anymore either! Applying the
    events in order to a blank document will, therefore, lead to errors or corrupted
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things we could do:'
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to delete the user's identity but preserve the data. While this
    could work in particular contexts, this solution depends on the outreach of the
    delete request. There's a special case where a user has added personal data (for
    example, an address, email address, or an ID number) into a document. If we delete
    the user's identity, but also need to delete the personal data, we will need to
    scan all events for the personal data and remove or replace it with the same number
    of blank characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another solution is to materialize the database, to delete the data, and to
    start from the new checkpoint with future events. This breaks one of the core
    ideas of event sourcing—the ability to reconstruct the data from an empty store—and
    it can prove difficult for systems that have many events or many deletions. It
    is possible though, with proper planning and structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third solution is to take advantage of the architecture and use a special
    event for `DeletePrivateData`. However, this event is different because it will
    have to change the event store rather than the data. While it fits with the architecture,
    it is risky and will require extensive testing, since it can break everything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fourth solution is to design the events so that they are not temporally coupled.
    In theory, this sounds good, but we have to admit it may not always be possible
    in practice. In the previous example, we needed some kind of position for the
    text, and I challenge you to find a way of specifying the position that is independent
    of existing text. Also consider that we would carry out this design effort in
    a rare situation, potentially making all events less comprehensible. If it's possible
    with minimal changes, great; but if not, you'll need to make a decision yourself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will look next at a simple example of implementation using event sourcing.
    We'll start with our Twitter example, and start writing some tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a user and check the event store for the right events,
    in pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a few things to compile this test. First, an event store that can store
    events, but how do we express an event that can be stored? We need some kind of
    data structure that can hold property names and values. The simplest one is a
    `map<string, string>` structure that will map the names of properties to their
    values. To see it in action, let''s create the event structure for `CreateUser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreateUser` event has a type, `CreateUser`, and needs a handle, for example, `alexboly`, and
    an `id` for the user. Let''s make it nicer and more explicit with `typedef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create our `EventStore`. Since it''s basically a list of events,
    let''s just use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now our test can use the `EventStore` and the `makeCreateUserEvent` function
    to check that, after calling `createUser`, the right event will be in event store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We only have to implement `createUser` now for this test to work. It is simple
    enough; call `makeCreateUserEvent` and add the result to `EventStore`. We need
    an `id`, but since we only have one element, for now, let''s use a hardcoded value
    of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The test passes; now we can execute events and they'll go to the event store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see now how the new user can post a message. We will need a second event
    type, `PostMessage`, and a similar code infrastructure. Let''s write the test.
    First, we need to create a user. Second, we need to create a message that is linked
    to the user through the `userId`. Here''s the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `makePostMessageEvent` function will just create an `Event` structure with
    all the required information. It also needs a type and `messageId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `postMessage` just adds the result of `makePostMessageEvent` into
    the `EventStore`. We need an ID once again, but we only have one message, so we
    can use the same ID, `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, now we have a user that can post a message, all through events. That's quite
    neat, and not as difficult as it may have seemed in the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation raises a few interesting questions though.
  prefs: []
  type: TYPE_NORMAL
- en: How do you retrieve data?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firstly, what if I want to search for a user by their handle or their `id`?
    That's a real use scenario on Twitter. If I mention another user in a message
    with `@alexboly`, a notification should be posted to the user with the handle
    `alexboly`. Also, I'd like to display all messages relevant to the user `@alexboly`
    on the timeline.
  prefs: []
  type: TYPE_NORMAL
- en: I have two options for this. The first option is to store just the events and
    run all of them whenever reading data. The second option is to maintain a domain
    store with the current values and query it like any other database. It's important
    to note that each or both of these stores may be in-memory for very fast access.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether the current values are cached or computed, we need a way
    to execute the events and obtain them. How do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a test to describe what we need. After running one or more events,
    we need to execute the events and get the current values, allowing us to retrieve
    them as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the test pass, we need a few things. First, a `User` domain object,
    which we''ll keep very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, a data store that has a list of `users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `play` mechanism. Let''s just use an ugly implementation for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowing higher-order functions, we can, of course, see that our `for` statement
    in the preceding snippet can be turned into a functional approach. In fact, we
    can filter all the events by the `CreateUser` type and then transform each event
    into an entity through a call to `transform`. First, let''s extract some smaller
    functions. We need one function that turns a `CreateUser` event into a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need another one that filters a list of events by type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now extract a `playEvents` function, which takes a list of events, filters
    it by type, and runs the transformation, obtaining a list of entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this function in our `EventStore` to both replace the treatment
    of `CreateUser` and generalize it to other events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We now have a way to retrieve data from our store based on events. Time to look
    at the next question.
  prefs: []
  type: TYPE_NORMAL
- en: What about referential integrity?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve seen that relationships between entities when using events are
    based on IDs, but what if we call an event using the wrong `id`? Look at the example
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'I see a few solutions to this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: The first solution is to run the event anyway. This will work if it doesn't
    create additional issues on display. On Twitter, if I see a message, I can navigate
    to the user who posted the message. In this case, the navigation would lead to
    an inexistent page. Is this a problem? I would argue that for something like Twitter,
    it's not such a big problem, as long as it doesn't happen very often, but you'll
    have to judge it in the context of your own product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second solution is to run the event without any checks, but run a repeated
    job that checks for referential issues and cleans them up (through events, of
    course). This method allows you to eventually clean up the data using event sourcing,
    without slowing down updates with integrity checks. Once again, you'll need to
    figure out whether this works in your context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third solution is to run integrity checks on each event run. While this
    ensures referential integrity, it will also slow everything down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The checks can run in two ways—either by checking the data store or checking
    the event store. For example, you could check that `DeleteUser` for ID `1` never
    occurred, or that it didn't occur after `CreateUser` (but you'll need the user
    handle for that).
  prefs: []
  type: TYPE_NORMAL
- en: Keep this in mind when choosing event sourcing for your application!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event sourcing is a method of immutable data storage, starting from a simple
    idea—instead of storing the current state of the world, what if we stored all
    the events that lead to the current state? The advantages of this approach are
    many and interesting—the ability to move forward and backward in time, built-in
    incremental backup, and thinking in a timeline rather than in a state. It also
    comes with a few caveats—deleting past data is very difficult, the event schema
    is difficult to change, and referential integrity tends to become looser. You
    also need to pay attention to possible errors and define policies for treating
    them in a structured and repeatable manner.
  prefs: []
  type: TYPE_NORMAL
- en: We've also seen how a simple event sourcing architecture can be implemented
    with the help of lambdas as events. We could also look at event sourcing for storing
    lambdas, since a stored event is basically a command pattern, and the simplest
    implementation of a command pattern is a lambda. The curious reader can try to
    serialize/deserialize the events into lambdas and see how it changes the design.
  prefs: []
  type: TYPE_NORMAL
- en: Like any architectural pattern, my advice is to carefully consider the trade-offs
    and to have answers to the most important challenges raised by the implementation.
    If you choose to try event sourcing, I also advise you to try a production-ready
    event store rather than building your own. The one we wrote in this chapter is
    useful for showcasing the core principles and challenges of event sourcing, but
    it's far from being ready to be used in production.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to move on to the future of functional programming in C++. In
    the next chapter, we will walk through the existing functional programming features
    in C++ 17, and look at the news about C++ 20.
  prefs: []
  type: TYPE_NORMAL
