- en: 2\. Working with Unreal Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on many of the basic concepts and features within Unreal
    Engine. You will be shown how to create a C++ project, how to perform some basic
    debugging, and how to work with character-specific animations.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll be able to create C++ template projects,
    be able to debug code within Visual Studio, understand the folder structure and
    the best practices involved, and finally, be able to set up character animations
    based on their states.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we went through the basics of the Epic Games Launcher,
    along with Unreal Editor fundamentals. We saw how to work with Objects and what
    Blueprints are on a basic level, in addition to exploring the First Person Template.
    In this chapter, we'll be building upon those fundamentals by exploring the Third
    Person Template and working with Input and Animations.
  prefs: []
  type: TYPE_NORMAL
- en: Game development can be done in a wide variety of languages, such as C, C++,
    Java, C#, and even Python. While each language has pros and cons, we will be using
    C++ throughout this book as it is the primary programming language used within
    the Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will get you up to speed on how to create a C++ project
    and basic level debugging in UE4\. It is very important to be able to debug code
    as it helps the developer while dealing with bugs. The tools provided come in
    very handy and are essential for any Unreal Engine developer.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we will get up close and personal with the core classes involved
    in creating games and experiences in Unreal Engine. You will explore Game Mode
    and the relevant class concepts, followed by an exercise to gain a hands-on understanding
    of this.
  prefs: []
  type: TYPE_NORMAL
- en: The final section in this chapter is all about animations. Almost every single
    game features animations, some to a very basic extent, but some to a very high
    level that includes captivating details which are key to the gameplaying experience.
    Unreal Engine offers several tools you can use to create and deal with animations,
    including the Animation Blueprint, which has complex graphs and a State Machine.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Setting Up a Blank C++ Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the start of every project, you might want to start with any of the templates
    provided by Epic (which contain ready-to-execute basic code) and build on top
    of that. Most/some of the time, you might need to set up a blank or an empty project
    that you can mold and sculpt to your requirements. We'll learn how to do that
    in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.01: Creating an Empty C++ Project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will learn how to create an empty C++ project from the
    template provided by Epic. This will serve as the foundation for many of your
    future C++ projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Unreal Engine 4.24 from the Epic Games Launcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Games` section and click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the `Blank` project template is selected and click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Blueprint` section dropdown and select `C++`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the project folder and project name are specified with an appropriate
    directory and name, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: When everything is set up, click on the `Create Project` button. In this case,
    our project directory is inside a folder called `UnrealProjects`, which is inside
    the `E` drive. The project name is set to `MyBlankProj` (it is recommended that
    you follow these names and project directories, but you can use your own if you
    wish to do so).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The project name cannot have any spaces in it. It is preferable to have an Unreal
    directory as close to the root of a drive as possible (to avoid running into issues
    such as the 256-character path limit when creating or importing assets into your
    project's working directory; for small projects, it may be fine, but for more
    large-scale projects, where the folder hierarchy may become too complex, this
    step is important).
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that after it's done generating code and creating the project
    files, the project will be opened, along with its Visual Studio solution (`.sln`)
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the Visual Studio solution configuration is set to Development Editor
    and that the solution platform is set to Win64 for Desktop development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Visual Studio deployment settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_02_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.1: Visual Studio deployment settings'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, we now know how to create an empty C++ project
    on UE4, along with its considerations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll be talking a bit about the folder structure, along
    with the most basic and most used folder structure format that's used by Unreal
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: Content Folder Structure in Unreal Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your project directory (`E:/UnrealProjects/MyBlankProj` *in our case*), you
    will observe a `Content` folder. This is the primary folder that your project
    uses for different types of assets and project-relevant data (including Blueprints).
    The C++ code goes into the `Source` folder in your project. Please note that the
    best practice is to create new C++ code files directly through the Unreal Editor
    as this simplifies the process and results in fewer errors.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different strategies you can use to organize the data inside
    your `Content` folder. The most basic and easy-to-understand is using folder names
    to depict the type of content inside. Therefore, a `Content` folder directory
    structure may resemble the example at [https://packt.live/3lCVFkR](https://packt.live/3lCVFkR).
    In this example, you can see that each file is categorically placed under the
    name of the folder representing its type on the first level, with the following
    levels further grouping it into meaningful folders.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All blueprints should prefix `BP` in their name (to differentiate them from
    the default blueprints used by Unreal Engine). The rest of the prefixes are optional
    (however, it is best practice to format them with the prefixes shown earlier).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be looking at the Visual Studio solution.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Visual Studio Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every C++ project in Unreal Engine has a Visual Studio solution. This, in turn,
    drives all the code and provides developers with the ability to set up execution
    logic and debug code in its running state.
  prefs: []
  type: TYPE_NORMAL
- en: Solution Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Visual Studio solution (.`sln`) file that's produced inside the project
    directory contains the entire project and any associated code that's been added
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the files present in Visual Studio. *Double-click* the
    .`sln` file to open it within Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: In `Solution Explorer`, you will see two projects called `Engine` and `Games`.
  prefs: []
  type: TYPE_NORMAL
- en: The Engine Project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the base level, Unreal Engine itself is a Visual Studio project and has its
    own solution file. This contains all the code and third-party integrations that
    work together in Unreal Engine. All the code within this project is called the
    "source" code.
  prefs: []
  type: TYPE_NORMAL
- en: The Engine project consists of the external dependencies, configurations, plugins,
    shaders, and source code of Unreal Engine that are currently being used for this
    project. You can, at any time, browse the `UE4 -> Source` folder to view any of
    the engine code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'As Unreal Engine is open source, Epic allows developers to both view and edit
    source code to suit their needs and requirements. However, you cannot edit the
    source code in the version of Unreal Engine that''s installed via the Epic Games
    Launcher. To be able to make and build changes in source code, you need to download
    the source version of Unreal Engine, which can be found via GitHub. You can use
    the following guide to download the Source Version of the Unreal Engine: [https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html](https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading, you can also refer to the following guide for compiling/building
    the newly downloaded engine: [https://docs.unrealengine.com/en-US/Programming/Development/BuildingUnrealEngine/index.html](https://docs.unrealengine.com/en-US/Programming/Development/BuildingUnrealEngine/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Game Project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Under the `Games` directory is the solution folder with the name of your project.
    Upon expansion, you''ll find a set of folders. You will be concerned with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Config Folder**: Carries all the configurations that have been set up for
    the project and the build (these can optionally have platform-specific (such as
    Windows, Android, iOS, Xbox, or PS) settings as well).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugins Folder**: This is an optional folder that''s created when you add
    any third-party plugin (downloaded from the Epic Marketplace or obtained through
    the internet). This folder will contain all of the source code of the plugins
    associated with this project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source Folder**: This is the primary folder we''re going to be working with.
    It will contain the Build Target files, as well as all the source code for the
    project. The following is a description of the default files in the source folder:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Target.cs` extension, and one build file that ends with `Build.cs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ProjectName code files (.cpp & .h)**: By default, these files are created
    for each project and contain the code that''s used to run the default game module
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ProjectNameGameModeBase code files (.cpp & .h)**: By default, an empty Project
    Game Mode Base is created. It''s not usually used in most cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ProjectName.uproject file**: Contains the descriptors used to provide basic
    information about the project and the list of plugins associated with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Code in Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio provides powerful debugging features with the help of breakpoints
    in code. It enables users to pause the game at a particular line of code so that
    the developer can see the current values of variables and step through the code
    and game in a controlled fashion (can proceed line by line, function by function,
    or so on).
  prefs: []
  type: TYPE_NORMAL
- en: This is useful when you have a lot of variables and code files in your game
    project, and you want to see the values of the variables being updated and used
    in a step-by-step fashion to debug the code, find out what issues there are, and
    solve them. Debugging is a fundamental process of any developer's work, and only
    after many continuous debugging, profiling, and optimization cycles does a project
    get polished enough for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've got the basic idea of the Visual Studio solution, we'll move
    on and cover a practical exercise on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.02: Debugging the Third Person Template Code'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you'll be creating a project using the Third Person Template
    of Unreal Engine and will debug the code from within Visual Studio. We'll be investigating
    the value of a variable called `BaseTurnRate` in the `Character` class of this
    template project. We'll see how the value updates as we move through the code,
    line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Unreal Engine from the Epic Games Launcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Games` section and click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Third Person` and click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select C++, set the project name to `ThirdPersonDebug`, and click the `Create
    Project` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, close Unreal Editor, go to the Visual Studio solution, and open the `ThirdPersonDebugCharacter.cpp`
    file:![Figure 2.2: ThirdPersonDebugCharacter.cpp file location'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.2: ThirdPersonDebugCharacter.cpp file location'
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* on the bar on the left-hand side of line `18`. A red dot icon
    should appear on it (*you can toggle it off by clicking on it again*):![Figure
    2.3: Collision capsule init code'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.3: Collision capsule init code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are getting the `capsule` component (explained further in *Chapter
    3*, *Character Class Components and Blueprint Setup*) of the character, which,
    by default, is the root component. Then, we are calling its `InitCapsuleSize`
    method, which takes in two parameters: the `InRadius` float and `InHalfHeight`
    float, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the solution configuration setting in VS is set to `Development Editor`
    and click on the `Local Windows Debugger` button:![Figure 2.4: Visual Studio build
    settings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.4: Visual Studio build settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait until you''re able to see the following window in the bottom-left corner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the window doesn't pop-up, you can open the window manually by opening `Autos`
    under `Debug` > `Windows` > `Autos`. Additionally, you may also use `locals`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: Visual Studio variable watch window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_02_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.5: Visual Studio variable watch window'
  prefs: []
  type: TYPE_NORMAL
- en: '`this` shows the object itself. The object contains variables and methods that
    it stores, and by expanding it, we''re able to see the state of the entire object
    and its variables at the current line of code execution.'
  prefs: []
  type: TYPE_NORMAL
- en: Expand `this`, then `ACharacter`, and then `CapsuleComponent`. Here, you can
    see the values for the `CapsuleHalfHeight = 88.0` and `CapsuleRadius = 34.0` variables.
    Next to line `18`, where the red dot initially was, you will see an arrow. This
    means that the code is at the end of line `17` and has not executed line `18`
    yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the `Step Into` button to go to the next line of code (*Shortcut: F11*).
    `Step Into` will move into code inside the function (if present) on the line.
    On the other hand, `Step Over` will just execute the current code and move to
    the next line. Since there is no function on the current line, `Step Into` will
    mimic the `Step Over` functionality.![Figure 2.6: Debug step into'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.6: Debug step into'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the arrow has moved to line `21` and that the variables have been
    updated. `CapsuleHalfHeight = 96.0` and `CapsuleRadius = 42.0` are highlighted
    in red. Also, notice that the `BaseTurnRate` variable is initialized to  `0.0`:![Figure
    2.7: BaseTurnRate initial value'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.7: BaseTurnRate initial value'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step in (*F11*) once again to go to line `22`. Now, the `BaseTurnRate` variable
    has a value of `45.0` and `BaseLookUpRate` is initialized to `0.0`, as shown in
    the following screenshot:![Figure 2.8: BaseTurnRate updated value'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.8: BaseTurnRate updated value'
  prefs: []
  type: TYPE_NORMAL
- en: Step in (*F11*) once again to go to line `27`. Now, the `BaseLookUpRate` variable
    has a value of `45.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, you are encouraged to step in and debug other sections of the code
    to not only familiarize yourself with the debugger but also to understand how
    the code works behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you've learned how to set up debug points in Visual
    Studio, as well as stop debugging at a point, and then continue line by line while
    watching an object and its variable's values. This is an important aspect for
    any developer, and many often use this tool to get rid of pesky bugs within code,
    especially when there's a lot of code flows and the number of variables is quite
    large.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'At any point, you can stop debugging, restart debugging, or continue with the
    rest of the code by using the following buttons on the top menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Debugging tools in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_02_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.9: Debugging tools in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll look at importing assets into an Unreal project.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the Required Assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreal Engine gives users the ability to import a wide range of file types for
    users to customize their projects. There are several import options that developers
    can tweak and play around with to match their required settings.
  prefs: []
  type: TYPE_NORMAL
- en: Some common file types that game developers often import are FBX for scenes,
    meshes, animations (exported from Maya and other similar software), movie files,
    images (mostly for the user interface), textures, sounds, data in CSV files, and
    fonts. These files may be obtained from the Epic Marketplace or any other means
    (such as the internet) and used within the project.
  prefs: []
  type: TYPE_NORMAL
- en: Assets can be imported by dragging and dropping them into the `Content` folder,
    or by clicking the `Import` button in the `Content Browser`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's tackle an exercise where we'll learn how to import FBX files and see
    how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.03: Importing a Character FBX File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This exercise will focus on importing a 3D model from an FBX file. FBX files
    are widely used to export and import 3D models, along with their materials, animations,
    and textures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the `SK_Mannequin.FBX`, `ThirdPersonIdle.FBX`, `ThirdPersonRun.FBX`
    and `ThirdPersonWalk.FBX` files from the `Chapter02` -> `Exercise2.03` -> `ExerciseFiles`
    directory, which can be found on GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExerciseFiles` directory can be found on GitHub at the following link:
    [https://packt.live/2IiqTzq](https://packt.live/2IiqTzq).'
  prefs: []
  type: TYPE_NORMAL
- en: Open the blank project we created in *Exercise 2.01*, *Creating an Empty C++
    Project*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Content Browser` interface of the project, click `Import`:![Figure
    2.10: Content Browser Import button'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.10: Content Browser Import button'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to the directory of the files we downloaded in *Step 1*, select `SK_Mannequin.FBX`,
    and click on the `Open` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the `Import Animations` button is `Import All` button. You may get
    a warning here stating that `There are no smoothing groups`. You can ignore this
    for now. With that, you have successfully imported a skeletal mesh from an FBX
    file. Now, we need to import its animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Import` button again, browse to the folder we created in *Step 1*,
    and select `ThirdPersonIdle.fbx`, `ThirdPersonRun.fbx`, and `ThirdPersonWalk.fbx`.
    Then click on the `Open` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure the skeleton is set to the one you imported in *Step 5* and click
    `Import All`:![Figure 2.11: Animation FBX Import Options'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.11: Animation FBX Import Options'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can see the three animations (`ThirdPersonIdle`, `ThirdPersonRun`,
    and `ThirdPersonWalk`) inside the `Content Browser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you *double-click* on `ThirdPersonIdle`, you''ll notice that the left arm
    is hanging down. This means that there''s a retargeting issue. When the animations
    are imported separately from the skeleton, the Unreal Engine internally maps all
    the bones from the animation to the skeleton but sometimes that results in a glitch.
    We''re now going to resolve this glitch.![Figure 2.12: ThirdPersonIdle UE4 mannequin
    animation glitch'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.12: ThirdPersonIdle UE4 mannequin animation glitch'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `SK_Mannequin` Skeletal Mesh and open the `Skeleton Tree` tab if not
    open previously.![Figure 2.13: SK_Mannequin Skeleton Tree tab select'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.13: SK_Mannequin Skeleton Tree tab select'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under `Options` enable the `Show Retargeting Options` checkbox.![Figure 2.14:
    Enabling retargeting options'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.14: Enabling retargeting options'
  prefs: []
  type: TYPE_NORMAL
- en: Now inside the skeleton tree, reduce the `spine_01`, `thigh_l` and `thigh_r`
    bones to enable better visibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now select the `spine_01`, `thigh_l` and `thigh_r` bones. *Right click* on them,
    and in the menu, click the `Recursively Set Translation Retargeting Skeleton`
    button. This will fix the bone translation issues we encountered before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Re-open the `ThirdPersonIdle` `Animation` to verify the hanging arm has been
    fixed.![Figure 2.15: Fixed ThirdPersonIdle Animation'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.15: Fixed ThirdPersonIdle Animation'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can locate the complete exercise code files on GitHub in the `Chapter02`
    -> `Exercise2.03` -> `Ex2.03-Completed.rar` directory by going to the following
    link: [https://packt.live/2U8AScR](https://packt.live/2U8AScR)'
  prefs: []
  type: TYPE_NORMAL
- en: After extracting the `.rar` file, *double-click* the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` on that prompt
    so that it can build the necessary intermediate files, after which it should open
    the project in Unreal Editor automatically.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you've understood how to import assets and, more
    specifically, imported an FBX skeletal mesh and animation data into your project.
    This is crucial for the workflows of many game developers as assets are the building
    blocks of the entire game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll be looking at the Unreal core classes for creating
    a game, how important they are for creating a game or experience, and how to use
    them inside a project.
  prefs: []
  type: TYPE_NORMAL
- en: The Unreal Game Mode Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a situation where you want to be able to pause your game. All the logic
    and implementation required to be able to pause the game will be placed inside
    a single class. This class will be responsible for handling the game flow when
    a player enters the game. The game flow can be any action or a set of actions
    occurring in the game. For example, game pause, play, and restart are considered
    simple game flow actions. Similarly, in the case of a multiplayer game, we require
    all the network-related gameplay logic to be placed together. This is exactly
    what the Game Mode class is there for.
  prefs: []
  type: TYPE_NORMAL
- en: Game Mode is a class that drives the game logic and imposes game-related rules
    on players. It essentially contains information about the current game being played,
    including gameplay variables and events, which are mentioned later on in this
    chapter. Game Mode can hold all the managers of the gameplay objects, it's a singleton
    class, and is directly accessible by any object or abstract class present in the game.
  prefs: []
  type: TYPE_NORMAL
- en: As with all the other classes, the Game Mode class can be extended in Blueprints
    or C++. This can be done to include extra functionality and logic that may be
    required to keep players updated about what's happening inside the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go over some example game logic that goes inside the Game Mode class:'
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the number of players that are allowed to enter the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the Spawn location and Player Controller logic of newly connected players
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of the Game Score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of the Game Win/Lose condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Game Over/Restart Game scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will look at the default classes provided by Game Mode.
  prefs: []
  type: TYPE_NORMAL
- en: Game Mode Default Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to itself, Game Mode uses several classes to implement game logic.
    It allows you to specify classes for its following defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Session Class**: Handles admin-level game flow such as login approval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game State Class**: Handles the state of the game so that clients can see
    what''s going on inside the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player Controller Class**: The main class used to possess and control a pawn.
    Can be thought of as a brain that decides what to do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player State Class**: Holds the current state of a player inside the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HUD Class**: Handles the user interface shown to the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default Pawn Class**: The main actor that the player controls. This is essentially
    the player character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultPawn` class, the Spectator Pawn Class specifies the pawn responsible
    for spectating the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replay Spectator Player Controller**: The Player Controller responsible for
    manipulating replay during playback, within the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server Stat Replicator Class**: Responsible for replicating server stat net
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can either use the default classes as is, or you can specify your own for
    custom implementation and behavior. These classes will work in conjunction with
    Game Mode and will automatically run without being placed inside the world.
  prefs: []
  type: TYPE_NORMAL
- en: Gameplay Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In terms of a multiplayer game, when many players enter the game, it becomes
    essential to handle logic to allow their entry into the game, maintain their state,
    as well as to allow them to view other players' states and handle their interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Game Mode provides you with several events that can be overridden to handle
    such multiplayer gameplay logic. The following events are especially useful for
    networking features and abilities (which they are mostly used for):'
  prefs: []
  type: TYPE_NORMAL
- en: '`On Post Log In`: This event is called after the player is logged into the
    game successfully. From this point onward, it is safe to call replicated logic
    (used for networking in multiplayer games) on the Player Controller class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Handle Starting New Player`: This event is called after the `On Post Log In`
    event and can be used to define what happens to the newly entered player. By default,
    it creates a pawn for the newly connected player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpawnDefaultPawnAtTransform`: This event triggers the actual pawn spawning
    within the game. Newly connected players can be spawned at particular transforms
    or at preset player start positions placed within the level (which can be added
    by Dragging and Dropping the Player Start from the Models Window into the World).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`On Logout`: This event is called when a player leaves the game or is destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`On Restart Player`: This event is called to respawn the player. Similar to
    `SpawnDefaultPawnAtTransform`, the player can be respawned at specific transforms
    or pre-specified locations (using the player start position).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Game Mode class is not replicated to any clients or joined players. Its
    scope is only limited to the server where it is spawned. Essentially, the client-server
    model dictates that the clients only act as inputs within the game that is being
    played on the server. Therefore, the gameplay logic should not exist for the clients,
    but only for the server.
  prefs: []
  type: TYPE_NORMAL
- en: GameModeBase versus GameMode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From version 4.14 onward, Epic introduced the `AGameModeBase` class, which acts
    as the parent class for all Game Mode classes. It is essentially a simplified
    version of the `AGameMode` class.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Game Mode class contains some additional functionality that is
    better suited for Multiplayer Shooter type games as it implements the Match State
    concept. By default, the Game Mode Base is included in new template-based projects.
  prefs: []
  type: TYPE_NORMAL
- en: Game Mode also contains a State Machine that handles and keeps track of the
    player's state.
  prefs: []
  type: TYPE_NORMAL
- en: Levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Levels, in gaming, are a section or a part of a game. Since many games are quite
    large, they are broken down into different levels. A level of interest is loaded
    into the game for the player to play, and then when they are done with that, another
    level may be loaded in (while the current one will be loaded out) so that the
    player can proceed. To complete a game, a player usually needs to complete a set
    of specific tasks to move on to the next level, eventually completing the game.
  prefs: []
  type: TYPE_NORMAL
- en: A Game Mode can be directly applied to the level. The level, upon loading, will
    use the assigned Game Mode class to handle all logic and gameplay for that particular
    level and override the game mode of the project for this level. This can be applied
    using the `World Settings` tab after opening a level.
  prefs: []
  type: TYPE_NORMAL
- en: A Level Blueprint is a blueprint that runs with the level, but cannot be accessed
    outside the scope of the level. Game Mode can be accessed in any blueprint (including
    the level blueprint) by the `Get Game Mode` node. This can later be cast to your
    Game Mode class, to obtain a reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A level can only have one Game Mode class assigned to it. However, a single
    Game Mode class can be assigned to multiple levels to imitate similar functionality
    and logic.
  prefs: []
  type: TYPE_NORMAL
- en: The Unreal Pawn Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Pawn` class, in Unreal, is the most basic class of actors that can be possessed
    (either by a player or AI). It also graphically represents the player/bot in the
    game. Code inside this class should have everything to do with the game entities,
    including interaction, movement, and ability logic. The player can still only
    possess a single pawn at any time in the game. Also, the player can *unpossess*
    one pawn and *possess* another pawn during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: The Default Pawn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unreal Engine gives developers a `DefaultPawn` class (which inherits from the
    base `Pawn` class). On top of the `Pawn` class, this class contains additional
    code that allows it to move within the world, as you would in the editor version
    of the game.
  prefs: []
  type: TYPE_NORMAL
- en: The Spectator Pawn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some games offer features to spectate games. Let's say you're waiting for a
    friend to finish their game before joining you, so you go ahead and spectate their
    game. This gives you the ability to observe the game the player is playing, through
    a camera that you can move around to get a view of the players or the game. Some
    games also offer spectate modes that can travel back in time, to show a particular
    action of the game that happened in the past or at any point in the game.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, this is a special type of pawn that provides sample functionality
    to spectate a game. It contains all the basic tools (such as the Spectator Pawn
    Movement component) required to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The Unreal Player Controller Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Player Controller class can be thought of as the player. It is essentially
    the *soul* of a pawn. A Player Controller takes input from the user and feeds
    it to the pawn and other classes for the player to interact with the game. However,
    you must take note of the following points while dealing with this class:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the pawn, there can only be one Player Controller that the player represents
    in a level. (Just like when you travel in an elevator. While inside one, you can
    only control that elevator, but you can then exit it and enter another elevator
    in order to control that one.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Player Controller persists throughout the game, but the pawn may not (for
    example, in a battle game, the player character may die and respawn, but the Player
    Controller would remain the same).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the temporary nature of the pawn and the permanent nature of the Player
    Controller, developers need to keep in mind which code should be added to which
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's understand this better through the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.04: Setting Up the Game Mode, Player Controller, and Pawn'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This exercise will use the blank project we created in *Exercise 2.01*, *Creating
    an Empty C++ Project*. We'll be adding our Game Mode, Player Controller, and `Pawn`
    class to the game and will be testing to see if our code works in Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project we created in *Exercise 2.01*, *Creating an Empty C++ Project*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* inside the `Content Browser` and select `Blueprint Class`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the `All Classes` section, find and select the `Game Mode` class:![Figure
    2.16: Selecting the Game Mode class'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.16: Selecting the Game Mode class'
  prefs: []
  type: TYPE_NORMAL
- en: Set its name to `BP_MyGameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *Steps 2-4* and select the `Pawn` class from under the `Common Classes`
    section, as shown in the preceding screenshot. Set the name of this class to `BP_MyPawn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat *Steps 2-4* and select the `Player Controller` class under the `Common
    Classes` section, as shown in the preceding screenshot. Set the name of this class
    to `BP_MyPC`:![Figure 2.17: Game Mode, Pawn, and Player Controller names'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.17: Game Mode, Pawn, and Player Controller names'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `BP_MyGameMode` and open the `Event Graph` tab:![Figure 2.18: Event Graph
    tab in Blueprint'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.18: Event Graph tab in Blueprint'
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* and drag from the white pin in the `Event BeginPlay` node and
    then release the *left mouse button* to gain an `Options` menu. Type `print` and
    select the `print` node highlighted in the list:![Figure 2.19: Print String node
    (Blueprint)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.19: Print String node (Blueprint)'
  prefs: []
  type: TYPE_NORMAL
- en: In the resultant `Print String` node that gets placed under the `In String`
    parameter, type `My Game Mode has started!`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, press the `Compile` and `Save` buttons on the top menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *Steps 7-10* for both the `BP_MyPawn` and `BP_MyPC` classes, setting
    the `In String` parameter to `My Pawn has started!` and `My PC has started!`,
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, open the `World Settings` tab, and under the `Game Mode` section,
    use the dropdown to set the `GameMode Override`, `Default Pawn Class`, and `Player
    Controller Class` options to our respective classes:![Figure 2.20: World Settings
    and Game Mode setup'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.20: World Settings and Game Mode setup'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click `Play` to play your game and see the three print statements on the top.
    This means that the current `GameMode Override`, `Default Pawn Class`, and `Player
    Controller Class` options have been set to your specified classes and are running
    their code:![Figure 2.21: Output prints'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.21: Output prints'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can locate the completed exercise code files on GitHub, in the `Chapter02`
    -> `Exercise2.04` -> `Ex2.04-Completed.rar` directory, at the following link:
    [https://packt.live/3k7nS1K](https://packt.live/3k7nS1K)'
  prefs: []
  type: TYPE_NORMAL
- en: After extracting the `.rar` file, *double-click* the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` on that prompt
    so that it can build the necessary intermediate files, after which it should open
    the project in Unreal Editor automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the basic classes and how they work in Unreal, in the next
    section, we will be looking at animations, what processes are involved, and how
    they complete them. We'll follow this with an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation is essential for adding life and richness to a game. Superb animations
    are one of the major factors that differentiate average games from the good and
    the great from the best. Visual fidelity is what keeps gamers excited and immersed
    in games, and hence animations are a core part of all games and experiences created
    in Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter seeks to cover animation basics. A more in-depth approach to animation
    will be taken in *Chapter 13*, *Blend Spaces 1D, Key Bindings, and State Machines*.
  prefs: []
  type: TYPE_NORMAL
- en: Animation Blueprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Animation Blueprint is a specific kind of blueprint that allows you to control
    the animation of a Skeletal Mesh. It provides users with a graph specifically
    for animation-related tasks. Here, you can define the logic for computing the
    poses of a skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A Skeletal Mesh is a skeleton-based mesh that has bones, all of which come together
    to give form to the mesh, whereas a Static Mesh (as the name suggests) is an un-animatable
    mesh. Skeletal Meshes are normally used for characters and life-like objects (for
    example, a player hero), whereas Static Meshes are used for basic or lifeless
    objects (for example, a wall).
  prefs: []
  type: TYPE_NORMAL
- en: 'Animation Blueprints provide two kinds of graphs: `EventGraph` and `AnimGraph`.'
  prefs: []
  type: TYPE_NORMAL
- en: Event Graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Event Graph within an Animation Blueprint provides setup events related
    to animations, as we learned in *Chapter 1*, *Unreal Engine Introduction*, that
    can be used for variable manipulation and logic. Event graphs are mostly used
    within Animation Blueprints to update Blend Space values, which, in turn, drive
    the animations within `AnimGraph`. The most common events that are used here are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blueprint Initialize Animation:** Used to initialize the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blueprint Update Animation:** This event is executed every frame, giving
    developers the ability to perform calculations and update its values as required:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.22: Animation Event Graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_02_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.22: Animation Event Graph'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see the default Event Graph. There are
    `Event Blueprint Update Animation` and `Try Get Pawn Owner` nodes here. You created
    new nodes and appended them to a graph to complete some meaningful tasks in *Exercise
    2.04*, *Setting Up the Game Mode, Player Controller, and Pawn*.
  prefs: []
  type: TYPE_NORMAL
- en: The Anim Graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Anim Graph is dedicated to and responsible for playing animations and outputting
    the final pose of the skeleton, on a per-frame basis. It provides developers with
    special nodes to execute different logic. For example, the Blend node takes in
    multiple inputs and is used to decide which input is currently being used in the
    execution. This decision is usually dependent on some external input (such as
    an alpha value).
  prefs: []
  type: TYPE_NORMAL
- en: The Anim Graph works by evaluating nodes by following the flow of execution
    between the exec pins on the nodes being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see a single `Output Pose` node on the
    graph. This is the final pose output of the animation that will be visible on
    the relevant Skeletal Mesh within the game. We will be using this in *Exercise
    2.05*, *Creating a Mannequin Animation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23: Animation AnimGraph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_02_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.23: Animation AnimGraph'
  prefs: []
  type: TYPE_NORMAL
- en: State Machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have already learned how animation nodes and logic can be set up, but one
    essential component is missing. Who decides when a particular animation or piece
    of logic should play or execute? This is where State Machines come into the picture.
    For example, a player may need to shift from crouching to a standing pose, so
    the animation needs to be updated. The code will call the Animation Blueprint,
    access the State Machine, and let it know that the state of the animation needs
    to be changed, resulting in a smooth animation transition.
  prefs: []
  type: TYPE_NORMAL
- en: A State Machine consists of states and rules that can be thought of as depicting
    the state of an animation. A State Machine can always be in one state at a particular
    time. A transition from one state to another is carried out when certain conditions
    (which are defined by rules) are met.
  prefs: []
  type: TYPE_NORMAL
- en: Transition Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each Transition Rule contains a Boolean node by the name of `Result`. If the
    Boolean is true, the transition can occur and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24: Transition Rules'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_02_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.24: Transition Rules'
  prefs: []
  type: TYPE_NORMAL
- en: Blend Spaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you're provided with a bunch of animations, you can create a State Machine
    and run those animations. However, a problem is presented when you need to transition
    from one animation to another. If you simply switch the animation, it will glitch
    since the new animation's starting pose might be different from the old animation's
    ending pose.
  prefs: []
  type: TYPE_NORMAL
- en: Blend Spaces are special assets used to interpolate between different animations
    based on their alpha values. This, in turn, removes the glitch issue and interpolates
    between the two animations, causing a swift and smooth change in animation.
  prefs: []
  type: TYPE_NORMAL
- en: Blend Spaces are created either in one dimension, known as a Blend Space 1D,
    or two dimensions, known as a Blend Space. These blend any number of animations
    based on one or two input(s), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.05: Creating a Mannequin Animation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you've gone through most of the concepts related to animations, we'll
    be diving in hands-on by adding some animation logic to the default mannequin.
    We'll be creating a Blend Space 1D, a State Machine, and Animation logic.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal here is to create a running animation of our characters and thus gain
    insight into how animations work, as well as the way they are bound to the actual
    character in a 3D world.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and extract all the contents of the `Chapter02` -> `Exercise2.05` ->
    `ExerciseFiles` directory, which can be found on GitHub. You can extract this
    to any directory you're comfortable with using on your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExerciseFiles` directory can be found on GitHub at the following link:
    [https://packt.live/32tIFGJ](https://packt.live/32tIFGJ).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Double-click* the `CharAnim.uproject` file to start the project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press `Play`. Use the keyboard's *W*, *A*, *S*, *D* keys to move and the *Spacebar*
    to jump. Notice that, currently, there are no animations on the mannequin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Content` folder, browse to `Content` -> `Mannequin` -> `Animations`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* the `Content` folder, and from the `Animation` section, select
    `Blend Space 1D`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `UE4_Mannequin_Skeleton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the newly created file to `BS_IdleRun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* `BS_IdleRun` to open it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the `Asset Details` tab, inside the `Axis Settings` section, expand the
    `Horizontal Axis` section and set `Name` to `Speed` and `Maximum Axis Value` to
    `375.0`:![Figure 2.25: Blend Space 1D Axis Settings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.25: Blend Space 1D Axis Settings'
  prefs: []
  type: TYPE_NORMAL
- en: Head down to the `Sample Interpolation` section and set `Target Weight Interpolation
    Speed Per Sec` to `5.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop the `ThirdPersonIdle`, `ThirdPersonWalk`, and `ThirdPersonRun`
    animations into the graph separately:![Figure 2.26: Blend Space previewer'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.26: Blend Space previewer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `Asset Details` tab, in `Blend Samples`, set the following variable values:![Figure
    2.27: Blend Samples'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.27: Blend Samples'
  prefs: []
  type: TYPE_NORMAL
- en: Click `Save` and close this `Asset`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* inside the `Content` folder, and from the `Animation` section,
    select `Animation Blueprint`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Target Skeleton` section, select `UE4_Mannequin_Skeleton` and then
    click the `OK` button:![Figure 2.28: Creating the Animation Blueprint asset'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.28: Creating the Animation Blueprint asset'
  prefs: []
  type: TYPE_NORMAL
- en: Name the file `Anim_Mannequin` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* the newly created `Anim_Mannequin` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the `Event Graph` tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `boolean` variable called `IsInAir?` by clicking the `+` icon in the
    variable section on the bottom left side. Be sure to assign the proper type:![Figure
    2.29: Adding variables'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.29: Adding variables'
  prefs: []
  type: TYPE_NORMAL
- en: Create a float variable called `Speed`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag off the `Try Get Pawn Owner` return value node and type in `Is Valid`.
    Select the bottom one:![Figure 2.30: Event Graph Is Valid node'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.30: Event Graph Is Valid node'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the `Exec` pin from the `Event Blueprint Update Animation` node to
    the `Is Valid` node:![Figure 2.31: Connecting nodes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.31: Connecting nodes'
  prefs: []
  type: TYPE_NORMAL
- en: From the `Try Get Pawn Owner` node, use the `Get Movement Component` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the node obtained in *Step 22*, get the `Is Falling` node and connect
    the Boolean return value to a set node for the `Is in Air?` Boolean. Connect the
    `SET` node exec pin with the `Is Valid` exec pin:![Figure 2.32: Is in Air Boolean
    setup'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.32: Is in Air Boolean setup'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `Try Get Pawn Owner` node, use the `Get Velocity` node, get its `VectorLength`,
    and connect the output to the `A Variable Set` node of `Speed`:![Figure 2.33:
    Speed Boolean setup'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.33: Speed Boolean setup'
  prefs: []
  type: TYPE_NORMAL
- en: Next, head to the `Anim Graph` tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* anywhere inside `AnimGraph`, type `state machine`, and click
    on `Add New State Machine`:![Figure 2.34: The Add New State Machine option'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.34: The Add New State Machine option'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the node is selected and then press *F2* to rename it `MannequinStateMachine`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the output pin of `MannequinStateMachine` to the input pin for the
    `Output Pose` node and click the compile button on the top bar:![Figure 2.35:
    Configuring the State Machine result in the Output Pose node'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.35: Configuring the State Machine result in the Output Pose node'
  prefs: []
  type: TYPE_NORMAL
- en: '*Double-click* the `MannequinstateMachine` node to enter the State Machine.
    You will see an `Entry` node. The state that will be connected to it will become
    the default state of the mannequin. In this exercise, this will be our `Idle Animation`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on an empty area inside the State Machine, and from the menu,
    select `Add State`. Press *F2* to rename it `Idle/Run`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag from the icon next to the `Entry` text, point it inside the `Idle/Run`
    node, and then release it to connect it:![Figure 2.36: Connecting Added State
    to Entry'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.36: Connecting Added State to Entry'
  prefs: []
  type: TYPE_NORMAL
- en: '*Double-click* on the `Idle/Run` state to open it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the `Asset Browser` menu in the bottom-right corner, select and drag the
    `BS_IdleRun` Animation onto the graph. Get the `Speed` variable from the `Variable`
    section on the left and connect it, as shown here:![Figure 2.37: Idle/Run state
    setup'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.37: Idle/Run state setup'
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to `MannequinStateMachine` by clicking on its breadcrumb in the top
    banner:![Figure 2.38: State Machine navigation breadcrumb'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.38: State Machine navigation breadcrumb'
  prefs: []
  type: TYPE_NORMAL
- en: From the `Asset Browser` menu, drag and drop the `ThirdPersonJump_Start` Animation
    into the graph. Rename it `Jump_Start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat *Step 35* for `ThirdPersonJump_Loop` and `ThirdPerson_Jump` and rename
    them `Jump_Loop` and `Jump_End`, respectively:![Figure 2.39: State setup'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.39: State setup'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Jump_Start` state. Click on the `Play ThirdPersonJump_Start` node.
    *Uncheck* `Loop Animation` in the `Settings` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Jump_Loop` state and click on the `Play ThirdPersonJump_Loop` node.
    Set `Play Rate` to `0.75`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Jump_End` state and click on the `Play ThirdPerson_Jump` node. *Uncheck*
    the `Loop Animation` Boolean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we can shift from `Idle/Run` to `Jump_Start`, drag from the `Idle/Run`
    state and drop it to the `Jump_Start` state. Similarly, `Jump_Start` leads to
    `Jump_Loop`, then to `Jump_End`, and finally back to `Idle/Run`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop the arrows to set up the State Machine, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.40: State connections'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_02_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.40: State connections'
  prefs: []
  type: TYPE_NORMAL
- en: '*Double-click* the `Idle/Run` to `Jump_Start` transition rule icon and connect
    the output of the `Is in Air?` variable to the result:![Figure 2.41: Idle/Run
    to Jump_Start transition rule setup'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.41: Idle/Run to Jump_Start transition rule setup'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Jump_Start` to `Jump_Loop` transition rule. Get the `Time Remaining
    (ratio)` node for `ThirdPersonJump_Start` and check whether it is less than `0.1`.
    Connect the resulting bool to the result:![Figure 2.42: Jump_Start to Jump_End
    transition rule setup'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.42: Jump_Start to Jump_End transition rule setup'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Jump_Loop` to `Jump_End` transition rule. Connect the output of the
    inverse of the `Is in Air?` variable to the result:![Figure 2.43: Jump_Loop to
    Jump_End transition rule setup'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.43: Jump_Loop to Jump_End transition rule setup'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Jump_End` to `Idle/Run` transition rule. Get the `Time Remaining
    (ratio)` node for `ThirdPerson_Jump` and check whether it is less than `0.1`.
    Connect the resulting bool to the result:![Figure 2.44: Jump_End to Idle/Run transition
    rule setup'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_44.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.44: Jump_End to Idle/Run transition rule setup'
  prefs: []
  type: TYPE_NORMAL
- en: Close the Animation Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Content` folder, browse to `Content` -> `ThirdPersonBP` -> `Blueprints
    folder` and open the `ThirdPersonCharacter` Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select `Mesh` in the `Components` tab:![Figure 2.45: Mesh component'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_45.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.45: Mesh component'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Details` tab, set `Anim Class` to the `Animation Blueprint` class that
    you created:![Figure 2.46: Specifying the Animation Blueprint in the Skeletal
    Mesh component'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_02_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.46: Specifying the Animation Blueprint in the Skeletal Mesh component'
  prefs: []
  type: TYPE_NORMAL
- en: Close the Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the game again and notice the animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following should be the output you achieve. As you can see, our character
    is running, and the running animation is being shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.47: Character running animation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_02_47.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.47: Character running animation'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete exercise code files on GitHub, in the `Chapter02`
    -> `Exercise2.05` -> `Ex2.05-Completed.rar` directory, at the following link:
    [https://packt.live/3kdIlSL](https://packt.live/3kdIlSL)'
  prefs: []
  type: TYPE_NORMAL
- en: After extracting the `.rar` file, *double-click* the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` on that prompt
    so that it can build the necessary intermediate files, after which it should open
    the project in Unreal Editor automatically.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you've understood how to create State Machines,
    a Blend Space 1D, the Animation Blueprint, and how to tie it all together with
    the Skeletal Mesh of a character. You've also worked on play rates, transitional
    speed and the transitional states, helping you understand how the world of animation
    intricately ties in together.
  prefs: []
  type: TYPE_NORMAL
- en: We kicked off this section by understanding how State Machines are used to represent
    and transition in-between Animation States. Next, we got to know how a Blend Space
    1D gives us blending in-between those transitions. All this is used by the Animation
    Blueprint to decide what the current animation of the character is. Now, let's
    combine all these concepts together in an activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.01: Linking Animations to a Character'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say, as an Unreal games developer, you've been provided with a character
    skeletal mesh and its animations, and you've been tasked with integrating them
    inside a project. In order to do that, in this activity, you'll be creating an
    Animation Blueprint, State Machines, and a Blend Space 1D of a new character.
    By completing this activity, you should be able to work with animations in Unreal
    Engine and link them to skeletal meshes.
  prefs: []
  type: TYPE_NORMAL
- en: The activity project folder contains a Third Person Template project, along
    with a new character, `Ganfault`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This character and its animations were downloaded from [mixamo.com](http://mixamo.com).
    These have been placed in the `Content` -> `Ganfault` folder on our GitHub repository:
    [https://packt.live/35eCGrk](https://packt.live/35eCGrk)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mixamo.com* is a website that sells 3D characters with animations and is sort
    of an asset marketplace only for 3D models. It also contains a library of free
    models, alongside the paid ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Blend Space 1D for the Walking/Running animation and to set up the
    Animation Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to `Content` -> `ThirdPersonBP` -> `Blueprints` and open the `ThirdPersonCharacter`
    Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Skeletal Mesh component on the left, and inside the `Details` tab
    on the right, replace the `SkeletalMesh` reference with `Ganfault`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, update the `Animations Blueprint` section of the skeletal mesh component
    with the Animation Blueprint you created for `Ganfault`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For the State Machine, implement only Idle/Run and Jump State.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve completed this activity, the Walk/Run and Jump animations should
    be working properly, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.48: Activity 2.01 expected output (Left: Run; Right: Jump)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_02_48.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.48: Activity 2.01 expected output (Left: Run; Right: Jump)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this activity, you now know how to navigate your way around Unreal
    Engine with regard to the project, debugging code, and working with Animations.
    You also understand State Machines, which represent transitions between the Animation
    States and the Blend Spaces 1D used in that transition. You are now able to add
    animation to 3D models based on gameplay events and inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize this chapter, we first learned how to create an empty project.
    Then, we learned about the folder structure and how to organize files in the project
    directory. After that, we looked at template-based projects. We also learned how
    to set breakpoints in code so that we can watch variable values and debug entire
    objects while the game is running, which would help us find and eradicate bugs
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Thereafter, we saw how Game Mode, Player Pawn, and Player Controller are relevant
    classes used in Unreal Engine for setting up game flows (the execution order of
    code), as well as how they are set up inside a project.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we transitioned toward animation basics and worked with State Machines,
    Blend Spaces 1D, and Animation Blueprints to make our character animate (walk/run
    and jump) within the game according to the keyboard input.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we became more familiar with the powerful tools in
    Unreal Engine that are essential to game development. Unreal's Game Mode and its
    default classes are required for making any kind of game or experience in Unreal
    Engine. Additionally, animations bring life to your character and help add layers
    of immersiveness inside your games. All game studios have animations, characters,
    and game logic since these are the core components that drive any game. These
    skills will help you numerous times throughout your game development journey.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about the `Character` class in Unreal Engine,
    its components, and how to extend the class for additional setup. You'll be working
    on various exercises, followed by an activity.
  prefs: []
  type: TYPE_NORMAL
