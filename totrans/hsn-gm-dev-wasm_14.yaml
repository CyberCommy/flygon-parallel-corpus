- en: UI and Mouse Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **user** **interface** (**UI**) defines the interaction between a computer
    program and the user. In our game, our interaction so far has been limited to
    a keyboard interface that controls our player's spaceship. When we wrote our particle
    system configuration apps, we used HTML to define a more robust user interface,
    which allowed us to input values to configure our particle system. From that user
    interface, our code had to interact with the WebAssembly code indirectly. That
    is a technique you could continue to use for games if you wanted to leverage HTML
    to define your user interface, but it has a few disadvantages. First of all, we
    may want user interface elements that overlay the content of our game. Going through
    the DOM for this kind of effect is not very efficient. It is also easier to have
    interactions between our UI and objects from within the game if the UI elements
    are rendered inside of the game engine. In addition, you may be developing your
    C/C++ code to be used for a platform as well as a web release. If this is the
    case, you may not want HTML to have much of a role in your user interface.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be implementing a few UI features inside our game.
    We will need to implement a `Button` class, which is one of the simplest and most
    common UI elements. We will also need to implement a separate screen and game
    state so that we can have a starting and an ending game screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to include several images and audio files in your build to make
    this project work. Make sure that you include the `/Chapter14/sprites/` and `/Chapter14/audio/`
    folders from this project''s GitHub repository. If you haven''t downloaded the
    GitHub project yet, you can get it online here: [https://github.com/PacktPublishing/Hands-On-Game-Development](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: UI requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting mouse input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The start game screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game over screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we will need to do when implementing our UI is to decide on
    some requirements. What exactly do we need for our user interface? The first part
    of that is deciding what game screens we need for our game. This is usually the
    kind of thing you do early in the game design process, but because I am writing
    a book about WebAssembly, I have saved this step for a later chapter. Deciding
    what screens your game needs usually involves a storyboard and a process by which
    you either talk through (if more than one person is working on the game) or think
    through the way a user will interact with your web page, as well as the game that
    is on that page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44bf0fc4-4b90-44ee-bf06-3d7e6882c67e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Storyboard example for our user interface'
  prefs: []
  type: TYPE_NORMAL
- en: 'You don''t have to draw a storyboard, but I find it useful when thinking through
    what I need for a game''s UI. It is even more useful when you need to relay that
    information to another team member or an artist. When thinking through what we
    need in this game for the preceding storyboard, I came up with the following list
    of requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game play screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Score text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game over screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You win message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You lose message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play again button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our game needs an opening screen for a few reasons. First of all, we don''t
    want the game to start as soon as the user loads up the web page. There are a
    lot of reasons the user may load up the web page and not start playing the instant
    the web page has completely loaded. If they are on a slow connection, they may
    turn away from the computer while the game is loading up and may not notice the
    second it loads. If they reached this page by clicking a link, they might not
    be prepared to start playing the instant the game loads. It is also good practice
    in general to have something the player must do to acknowledge they are ready
    before throwing them into gameplay. The opening screen should also include some
    instructions for basic gameplay. Arcade games have a long history of putting simple
    instructions on the cabinet to tell the player what they must do to play the game.
    Famously, the game Pong came with the instructions *Avoid missing ball for high
    score* printed on the cabinet. Unfortunately, we do not have an arcade cabinet
    to print our instructions on, so using the opening game screen is the next best
    thing. We will also need a button that will allow the user to begin playing the
    game when they click it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d514eacc-d959-427c-96d8-92bff06984f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: Opening screen image'
  prefs: []
  type: TYPE_NORMAL
- en: Play screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The play screen is the screen we have always had. It is the screen where the
    player moves their spaceship around, trying to destroy the enemy spaceship. We
    may not need to change how this screen works, but we will need to add transitions
    to and from this screen based on the game state. The game will need to transition
    to our play screen from the opening screen when the player clicks a button. The
    player will also need to transition from the screen to the game over screen if
    either of the ships are destroyed. This is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a9a73da-59ea-4d7f-9456-4c7faace707d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: The original screen is now the play screen'
  prefs: []
  type: TYPE_NORMAL
- en: Game over screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If one of the spaceships is destroyed, the game is over. If the player''s ship
    is destroyed, then the player loses the game. If the enemy ship is destroyed,
    then the player wins the game. The *game over screen* lets us know that the game
    is over and tells us if the player has won or lost. It also needs to provide a
    button that allows our player to play the game again if they would like to. The
    game over screen is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1ba8bf3-352c-4a1c-9774-b335856ee951.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Game over screen'
  prefs: []
  type: TYPE_NORMAL
- en: Mouse input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can implement a button, we need to learn how to use mouse input in
    SDL. The code we used to get the keyboard input is in our `main.cpp` file. Inside
    the `input` function, you will find a call to `SDL_PollEvent`, followed by a few
    different switch statements. The first switch statements check the `event.type`
    for `SDL_KEYDOWN`. The second switch checks `event.key.keysym.sym` to see which
    key we pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we are looking for mouse input, we need to use the same `SDL_PollEvent`
    function to retrieve our mouse events. The three mouse events we are concerned
    with are `SDL_MOUSEMOTION`, `SDL_MOUSEBUTTONDOWN`, and `SDL_MOUSEBUTTONUP`. Once
    we know the kind of mouse event we are dealing with, we can use `SDL_GetMouseState`
    to find the `x` and `y` coordinates of our mouse when the event occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can receive mouse input, let's create a simple user interface button.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to capture mouse input in WebAssembly using SDL, we can
    use this knowledge to create a button that can be clicked by a mouse. The first
    thing we will need to do is create a `UIButton` class definition inside of the
    `game.hpp` file. Our button will have more than one sprite texture associated
    with it. Buttons usually have a hover state and a clicked state, so we will want
    to display an alternative version of our sprite if the user is hovering the mouse
    cursor over the button, or has clicked the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/647d63a3-ca68-451a-9781-0dd05a7f5597.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: Button states'
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture these events, we will need functions to detect whether the mouse
    has clicked on our button or hovered over it. Here is what our class definition
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first three attributes are button state attributes that tell our render
    function what sprite to draw, or if the button is inactive, not to draw anything.
    The `m_Hover` attribute will cause our renderer to draw `m_HoverTexture` if it
    is `true`. The `m_Click` attribute will cause our renderer to draw `m_ClickTexture`
    if it is `true`. Finally, `m_Active`, if set to `false`, will cause our renderer
    not to draw anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line is a function pointer to our callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This function pointer is set in our constructor and is the function that we
    call whenever someone clicks on the button. After the function pointer, we have
    our destination rectangle, which will have the location, width, and height of
    the button image file after the constructor runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have three textures. These textures are used to draw an image to our
    canvas and chosen during the render, based on the state flags we discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the constructor function. This function takes in the `x` and
    `y` screen coordinates of our button. After that, there are three strings, which
    are the locations of the three PNG files we will use to load our textures. The
    last parameter is a pointer to the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, there are the three functions we will need to call after we call `SDL_PollEvent`,
    based on the current state of the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `KeyDown` function will take a key code if a key is pressed, and if the
    key code matches our hotkey, we would like to use it as an alternative to clicking
    the button with the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RenderUI` function is similar to the `Render` functions we''ve created
    for other objects. The difference between `RenderUI` and `Render` is that the
    `Render` function will take the camera position into account when rendering a
    sprite to the screen. The `RenderUI` function will always render in canvas space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will create user interface state information to track
    the current screen.
  prefs: []
  type: TYPE_NORMAL
- en: Screen states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin adding new screens to our game, we will need to create some
    screen states. We will do most of the management of these states from within the
    `main.cpp` file. Different screen states will require different input, will run
    different logic, and different render functions. We will manage all of this at
    the highest level of our code as functions called by our game loop. We will define
    a list of possible states from within the `game.hpp` file as an enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that even though there will only be three different screens,
    we have a total of five different screen states. `START_SCREEN` and `PLAY_SCREEN`
    are the start screen and play screen respectively. The `PLAY_TRANSITION` state
    transitions the screens between `START_SCREEN` and `PLAY_SCREEN` by fading in
    the gameplay instead of having an abrupt switch to play. We will use two different
    states for our game over screen. These states are `GAME_OVER_SCREEN` and `YOU_WIN_SCREEN`.
    The only difference between these two states is the message that's displayed when
    the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to games.hpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few additional changes we will need to make to our `game.hpp` file.
    In addition to our `UIButton` class, we will need to add a `UISprite` class definition
    file. The `UISprite` is just a plain, ordinary image drawn in canvas space. It
    will not have any functionality on top of just being a sprite rendered as a UI
    element. Here is what the definition looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the button, it has an active state that''s represented by the `m_Active`
    attribute. If this value is false, the sprite will not render. It also has a sprite
    texture and a destination attribute that tells the renderer what to draw and where
    to draw it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It has a simple constructor that takes in the `x` and `y` coordinates where
    we will render the sprite on the canvas, and the file name of the image in the
    virtual filesystem from which we will load the sprite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it has a render function called `RenderUI` that will render the sprite
    to the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the RenderManager class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RenderManager` class will need a new attribute and a new function. In previous
    versions of our game, we had one type of background that we could render, and
    that was our scrolling starfield. When we render our start screen, I would like
    to use a new custom background that includes some instructions for how to play
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the new version of the `RenderManager` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added a new `SDL_Texture`, which we will use to render the background
    image in the start screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the new attribute, we have added a new function to render that
    image when the start screen is active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The alpha value that's passed into this function will be used to fade out the
    start screen during the `PLAY_TRANSITION` screen state. That transition state
    will begin when the player clicks the "Play" button and will last for about a
    second.
  prefs: []
  type: TYPE_NORMAL
- en: New external variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to add three new `extern` variable definitions that will reference
    variables we declare in the `main.cpp` file. Two of these variables are pointers
    to `UISprite` objects, and one of these variables is a pointer to a `UIButton`.
    Here are the three `extern` definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We use these two `UISprite` pointers in the game over screen. The first, `you_win_sprite`,
    is the sprite that will be displayed when the player wins the game. The second
    sprite, `game_over_sprite`, is the sprite that will be displayed when the player
    loses. The final variable, `play_btn`, is the play button that will be displayed
    on the start screen.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to main.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We manage the new screen states from within our game loop. Because of this,
    we will make most of the changes in the `main.cpp` file. We will need to break
    the `input` function up into three new functions, one for each of our game screens.
    We will need to break our `render` function into `start_render` and `play_render`
    functions. We don't need an `end_render` function because we will continue to
    use the `play_render` function when the end screen is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need a function to display the transition between the start screen
    and the play screen. Inside of the game loop, we will need to add logic to perform
    different loop logic based on the current screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first change we need to make to our `main.cpp` file is to add new global
    variables. We will need new global variables for our user interface sprites and
    buttons. We will need a new global variable to represent the current screen state,
    the transition time between states, and a flag telling us if the player has won
    the game. Here are the new global variables we need in the `main.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two variables are `UIButton` object pointers. The first is `play_btn`,
    which is the start screen button that the user will click to begin playing the
    game. The second is `play_again_btn`, which is a button on the end game screen
    the player can click to restart the game. After the UIButtons, we have two `UISprite`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the sprites that are displayed on the end game screen. Which sprite
    is displayed depends on whether or not the player destroyed the enemy ship or
    vice versa. After those sprites, we have a `SCREEN_STATE` variable, which is used
    to track the current screen state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `transition_time` variable is used to keep track of the amount of time left
    in the transition state between the start screen and the play screen. The `you_win`
    flag is set when the game is over and is used to keep track of who won the game.
  prefs: []
  type: TYPE_NORMAL
- en: Input functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous version of our game had a single `input` function that used `SDL_PollEvent`
    to poll for key presses. In this version, we want an input function for each of
    the three screen states. The first thing we should do is rename the original `input`
    function `play_input`. This will no longer be a universal input function, – it
    will only perform the input functionality for the play screen. Now that we have
    renamed our original input function, let''s define the input function for our
    start screen and call it `start_input`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Like our `play_input` function, the `start_input` function will be making a
    call to `SDL_PollEvent`. In addition to checking `SDL_KEYDOWN` to determine whether
    a key was pressed, we will also be checking three mouse events: `SDL_MOUSEMOTION`,
    `SDL_MOUSEBUTTONDOWN`, and `SDL_MOUSEBUTTONUP`. When checking for those mouse
    events, we will call the `play_btn` functions based on the `SDL_GetMouseState`
    values we retrieve. A mouse event will trigger the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If `event.type` was `SDL_MOUSEMOTION`, we create `x_val` and `y_val` integer
    variables and use a call to `SDL_GetMouseState` to retrieve the `x` and `y` coordinates
    of our mouse cursor. We then call `play_btn->MouseMove(x_val, y_val)`. This passes
    the mouse x and y coordinates to the play button, which uses those values to determine
    whether the button is in a hover state. We do something similar if `event.type`
    is `SDL_MOUSEBUTTONDOWN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If the mouse button is pressed, we look inside of `event.button.button` to see
    if the button that was clicked was the left mouse button. If it is, we use `x_val`
    and `y_val` in combination with `SDL_GetMouseState` to find the mouse cursor position.
    We use those values to call `play_btn->MouseClick(x_val, y_val)`. The `MouseClick`
    function will determine whether the button click fell within the button and if
    so, it will call the button's callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that executes when the event is `SDL_MOUSEBUTTONUP` is very similar
    to `SDL_MOUSEBUTTONDOWN`, with the exception that it calls `play_btn->MouseUp`
    instead of `play_btn->MouseClick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the mouse events, we will be passing keyboard events to our
    button. This is done so that we can create a hotkey that will trigger the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The end_input function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the `start_input` function, we will define the `end_input` function.
    The `end_input` function is very similar to the `start_input` function. The only
    significant difference is that the `play_btn` object is replaced by the `play_again_btn`
    object, which will have a different callback and SDL texture associated with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The render functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous versions of our game, we had a single render function. Now, we
    must have a render function for both our start screen and our play screen. The
    existing renderer will become our new play screen renderer, so we must rename
    the `render` function `play_render`. We also need to add a rendering function
    for our start screen called `start_render`. This function will render our new
    background and `play_btn`. Here is the code for `start_render`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The collisions function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There will need to be some minor modifications to the `collisions()` function.
    When a player ship or an enemy ship gets destroyed, we will need to change the
    current screen to the game over screen. Depending on which ship gets destroyed,
    we will either need to change it to the win screen or the lose screen. Here is
    the new version of our collisions function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that every line where the player is destroyed, there is a call
    to `player->m_Explode->Run()`. We now follow that line with a call to `current_screen
    = GAME_OVER_SCREEN` to set the screen to the player lose screen. Another way we
    could have done this is by adding a function to the `Ship` class, which runs both
    the explosion animation and sets the game screen, but I chose to modify fewer
    files by making the change inside of the `main` function. If we were using this
    project for more than demonstration purposes, I probably would have done it the
    other way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other changes we have made to collisions are similar. Whenever an enemy
    was destroyed by running the `enemy->m_Explode->Run()` function, we followed it
    with a line that set the current screen to the "you win" screen, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The transition state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A sudden transition from the start screen into gameplay can be a little jarring.
    To make the transition smoother, we will create a transition function called `draw_play_transition`,
    which will use an alpha fade to transition our screen from the start screen to
    the gameplay screen. Here is what that function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This function uses the `transition_time` global variable we created earlier
    and subtracts the time in milliseconds since the last frame. It uses that value
    divided by 4 as the alpha value when drawing the start screen background to fade
    it out as it transitions to the gameplay. When the transition time drops below
    0, we set the current screen to the play screen. When the transition begins, we
    set `transition_time` to 1,020 milliseconds, which is a bit more than a second.
    Dividing that value by 4 gives us a value that transitions from 255 (full opacity)
    to 0 (full transparency).
  prefs: []
  type: TYPE_NORMAL
- en: The game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `game_loop` function will need to be modified to perform different logic
    for each screen. Here is what the new version of the game loop will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We have new branching logic that branches based on the current screen. The
    first `if` block runs if the current screen is the start screen. It runs the `start_input`
    and `start_render` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The play screen and the play transition have the same logic as the original
    game loop, except for the `if` block around `PLAY_TRANSITION` at the end of this
    block of code. This draws the play transition by calling the `draw_play_transition()`
    function that we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The final block of code in the function is for the game over screen. It will
    render `you_win_sprite` if the current screen is `YOU_WIN_SCREEN` and will render
    `game_over_sprite` if the current screen is `GAME_OVER_SCREEN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Play and play again callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After our changes to the game loop, we need to add some callback functions
    for our buttons. The first of these functions is the `play_click` function. This
    is the callback that runs when the player clicks the play button on the start
    screen. This function will set the current screen to the play transition and set
    the transition time to 1,020 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will define the `play_again_click` callback. This function runs
    when the player clicks the play again button on the game over screen. Because
    this is a web game, we will use a little trick to simplify this logic. In a game
    written for almost any other platform, you would need to create some reinitialization
    logic that would have to go back through your game and reset the state of everything.
    We are going to *cheat* by simply reloading the web page using JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This cheat won't work for all games. Reloading some games would cause unacceptable
    delays. For some games, there may be too much state information that we need to
    keep. However, for this game, reloading the page is a quick and easy way to get
    the job done.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the `main` function in our application to perform all of the game initialization.
    This is where we will need to add some code to initialize the sprites we will
    use on our game over screen and our new buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we have our new sprite initialization lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we are setting the `game_over_sprite` coordinates and the
    `you_win_sprite` coordinates to `400, 300`. That will place these sprites in the
    center of the screen. We are setting both sprites to be active because they will
    only be rendered on the end game screen anyway. Later in the code, we will call
    the constructors for our `UIButton` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This places both of these buttons at `400, 500`, centered on the x-axis, but
    near the bottom of the game screen on the y-axis. The callbacks are set to `play_click`
    and `play_again_click`, which we defined earlier. Here is what the entire `main`
    function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will define functions in our `ui_button.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: ui_button.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UIButton` object has several functions that must be defined. We have created
    a new `ui_button.cpp` file that will hold all of these new functions. We will
    need to define a constructor, as well as `MouseMove`, `MouseClick`, `MouseUp`,
    `KeyDown`, and `RenderUI`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will include our `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will define our constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor function starts by setting the callback function from the passed
    in parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it sets the `m_dest` rectangle''s `x` and `y` coordinates from the parameters
    we passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, it loads three different image files into three different textures
    for the button, the button''s hover state, and the button''s clicked state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should look pretty familiar because loading an image file
    into an `SDL_Texture` object is something we have done a lot at this point. After
    that, we use the width and height values we queried earlier to center the destination
    rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we set our hover, click, and active state flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The MouseMove function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a function to determine whether the mouse cursor has been moved to
    hover over our button. We call the `MouseMove` function from our input function,
    and we pass in the current mouse cursor `x` and `y` coordinates. We check these
    coordinates against our `m_dest` rectangle to see if they overlap. If so, we set
    our hover flag to `true`. If not, we set the hover flag to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The MouseClick function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MouseClick` function is very similar to the `MouseMove` function. It is
    also called from our input function when the user presses the left mouse button.
    The `x` and `y` coordinates of the mouse cursor are passed in, and the function
    uses the `m_dest` rectangle to see if the mouse cursor was over the button when
    it was clicked. If it was, we set the click flag to `true`. If not, we set the
    click flag to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The MouseUp function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the left mouse button is released, we call this function. No matter what
    the mouse cursor coordinates are, we want to set the click flag to `false`. If
    the mouse was over the button at the time the button was released, and the button
    is clicked, we need to make a call to our callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The KeyDown function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I could have made the key down function a little more flexible. It would have
    been better to have the hotkey set to a value that''s set in the object. That
    would have supported more than a single button on a screen. As it is, if someone
    hits the *Enter* key, all the buttons on the screen will be clicked. This is not
    a problem for our game because we aren''t going to have more than one button on
    a screen, but if you want to improve the hotkey functionality, this shouldn''t
    be too difficult. As the function is, it hard codes the key it is checking against
    to `SDLK_RETURN`. Here is the version of the function we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The RenderUI function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RenderUI` function checks the various state flags in the button and renders
    the correct sprite based on those values. If the `m_Active` flag is `false`, the
    function doesn''t render anything. Here is the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will define functions in our `ui_sprite.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: ui_sprite.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UISprite` class is pretty simple. It has only two functions: a constructor
    and a rendering function. Like with every other CPP file in our project, the first
    thing we must do is include the `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Defining the constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The constructor is very familiar. It sets the `m_dest` rectangle''s `x` and
    `y` values to the values that were passed into the constructor. It loads the texture
    from the virtual filesystem using the `file_name` variable that we passed in as
    a parameter. Finally, it centers the `m_dest` rectangle using the width and height
    values that were retrieved using the `SDL_QueryTexture` function. Here is the
    code for the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The RenderUI function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RenderUI` function for our sprite is also straightforward. It checks to
    see if the sprite is active, and if it is, calls the render manager''s `RenderUI`
    function. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Compile ui.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have added a user interface to our game, let''s compile it, serve
    it from our web server or emrun, and open it up in a web browser. Here is the
    `em++` command we need to compile our `ui.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The new version will open to our start screen. If you want to play the game,
    you will now need to click the *Play* button. Here is a screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af0aed53-ba7c-4980-82e7-52d72d32ed5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: Opening screen'
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the *opening screen* has instructions on how to play the
    game. It is usually good to have an opening screen in an action-oriented web game
    because the player isn't always ready to play when the page loads. Not all web
    games need an opening screen. My website, [classicsolitaire.com](https://www.classicsolitaire.com/),
    doesn't have a single one. This is because solitaire is a turn-based game where
    the player isn't thrown into the action right away. The user interface needs of
    your game are likely to be different than the game we are writing for this book.
    So, sketch up a storyboard and take the time to gather requirements. You'll be
    glad you did.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we spent some time gathering requirements for our user interface.
    We created a storyboard to help us think through what screens we require for our
    game and how they might look. We discussed the layout for our opening screen,
    and why we need it. We then broke out the screen that had been our entire game
    into the play screen. Then, we discussed the layout of the game over screen and
    what UI elements we required for it and learned how to use SDL to retrieve mouse
    input. We also created a button class as a part of our user interface, as well
    as an enumeration for our screen states and discussed transitions between those
    states. We then added a sprite user interface object, before modifying our render
    manager to allow us to render our start screen's background image. Finally, we
    made changes to our code to support multiple game screens.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to write new shaders and implement them
    using WebAssembly's OpenGL API.
  prefs: []
  type: TYPE_NORMAL
