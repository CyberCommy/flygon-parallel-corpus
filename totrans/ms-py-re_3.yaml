- en: Chapter 3. Grouping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Grouping is a powerful tool that allows you to perform operations such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating subexpressions to apply quantifiers. For instance, repeating a subexpression
    rather than a single character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the scope of the alternation. Instead of alternating the whole expression,
    we can define exactly what has to be alternated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting information from the matched pattern. For example, extracting a date
    from lists of orders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the extracted information again in the regex, which is probably the most
    useful property. One example would be to detect repeated words.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, we will explore groups, from the simplest to the most
    complex ones. We'll review some of the previous examples in order to bring clarity
    to how these operations work.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already used groups in several examples throughout [Chapter 2](ch02.html
    "Chapter 2. Regular Expressions with Python") *Regular Expressions with Python*.
    Grouping is accomplished through two metacharacters, the parentheses `()`. The
    simplest example of the use of parentheses would be building a subexpression.
    For example, imagine you have a list of products, the ID for each product being
    made up of two or three sequences of one digit followed by a dash and followed
    by one alphanumeric character, 1-a2-b:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, the parentheses indicate to the regex
    engine that the pattern inside them has to be treated like a unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see another example; in this case, we need to match whenever there is
    one or more `ab` followed by `c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, you could use parentheses whenever you want to group meaningful subpatterns
    inside the main pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Another simple example of their use is limiting the scope of alternation. For
    example, let's say we would like to write an expression to match if someone is
    from Spain. In Spanish, the country is spelled España and Spaniard is spelled
    Español. So, we want to match España and Español. The Spanish letter ñ can be
    confusing for non-Spanish speakers, so in order to avoid confusion we'll use Espana
    and Espanol instead of España and Español.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve it with the following alternation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that this also matches `ol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s try character classes as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It works, but here we have another problem: It also matches `"Espano"` and
    `"Espanl"` that doesn''t mean anything in Spanish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution here is to use parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's see another key feature of grouping, **capturing**. Groups also capture
    the matched pattern, so you can use them later in several operations, such as
    `sub` or in the regex itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine you have a list of products, the IDs of which are made
    up of digits representing the country of the product, a dash as a separator, and
    one or more alphanumeric characters as the ID in the DB. You''re requested to
    extract the country codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we've created a pattern to match the IDs, but we're
    only capturing a group made up of the country digits. Remember that when working
    with the `group` method, the index 0 returns the whole match, and the groups start
    at index 1.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing groups give a huge range of possibilities due to which they can also
    be used with several operations, which we would discuss in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Backreferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve mentioned previously, one of the most powerful functionalities that
    grouping gives us is the possibility of using the captured group inside the regex
    or other operations. That''s exactly what backreferences provide. Probably the
    best known example to bring some clarity is the regex to find duplicated words,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're capturing a group made up of one or more alphanumeric characters,
    after which the pattern tries to match a whitespace, and finally we have the `\1`
    backreference. You can see it highlighted in the code, meaning that it must exactly
    match the same thing it matched as the first group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Backreferences can be used with the first 99 groups .Obviously, with an increase
    in the number of groups, you will find the task of reading and maintaining the
    regex more complex. This is something that can be reduced with named groups; we''ll
    see them in the following section. But before that, we still have a lot of things
    to learn with backreferences. So, let''s continue with another operation in which
    backreferences really come in handy. Recall the previous example, in which we
    had a list of products. Now, let''s try to change the order of the ID, so we have
    the ID in the DB, a dash, and the country code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Easy, isn't it? Note that we're also capturing the ID in the DB,
    so we can use it later. With the highlighted code, we're saying, "Replace what
    you've matched with the second group, a dash, and the first group".
  prefs: []
  type: TYPE_NORMAL
- en: As with the previous example, using numbers can be difficult to follow and to
    maintain. So, let's see what Python, through the `re` module, offers to help with
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Named groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember from the previous chapter when we got a group through an index?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We just learnt how to access the groups using indexes to extract information
    and to use it as backreferences. Using numbers to refer to groups can be tedious
    and confusing, and the worst thing is that it doesn't allow you to give meaning
    or context to the group. That's why we have named groups.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a regex in which you have several backreferences, let's say 10, and
    you find out that the third one is invalid, so you remove it from the regex. That
    means you have to change the index for every backreference starting from that
    one onwards. In order to solve this problem, in 1997, Guido Van Rossum designed
    named groups for Python 1.5\. This feature was offered to Perl for cross-pollination.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, it can be found in almost any flavor. Basically it allows us to give
    names to the groups, so we can refer to them by their names in any operation where
    groups are involved.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use it, we have to use the syntax,`(?P<name>pattern)`, where the
    `P` comes from Python-specific extensions (as you can read in the e-mail Guido
    sent to Perl developers at [http://markmail.org/message/oyezhwvefvotacc3](http://markmail.org/message/oyezhwvefvotacc3))
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it works with the previous example in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, backreferences are now much simpler to use and maintain as is evident in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we see in the previous example, in order to reference a group by the name
    in the `sub` operation, we have to use \`g<name>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use named groups inside the pattern itself, as seen in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is simpler and more readable than using numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through these examples, we''ve used the following three different ways to refer
    to named groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Use | Syntax |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Inside a pattern | (?P=name) |'
  prefs: []
  type: TYPE_TB
- en: '| In the `repl` string of the `sub` operation | \g<name> |'
  prefs: []
  type: TYPE_TB
- en: '| In any of the operations of the `MatchObject` | match.group(''name'') |'
  prefs: []
  type: TYPE_TB
- en: Non-capturing groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve mentioned before, capturing content is not the only use of groups.
    There are cases when we want to use groups, but we''re not interested in extracting
    the information; alternation would be a good example. That''s why we have a way
    to create groups without capturing. Throughout this book, we''ve been using groups
    to create subexpressions, as can be seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we''ve captured a group even though we''re not interested
    in the content of the group. So, let''s try it without capturing, but first we
    have to know the syntax, which is almost the same as in normal groups, `(?:pattern)`.
    As you can see, we''ve only added `?:`. Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After using the new syntax, we have the same functionality as before, but now
    we're saving resources and the regex is easier to maintain. Note that the group
    cannot be referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: They're a special case of non-capturing groups; they're usually used to improve
    performance. It disables backtracking, so with them you can avoid cases where
    trying every possibility or path in the pattern doesn't make sense. This concept
    is difficult to understand, so stay with me up to the end of the section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `re` module doesn''t support atomic groups. So, in order to see an example,
    we''re going to use the regex module: [https://pypi.python.org/pypi/regex](https://pypi.python.org/pypi/regex).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we have to look for an ID made up of one or more alphanumeric characters
    followed by a dash and by a digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see step by step what''s happening here:'
  prefs: []
  type: TYPE_NORMAL
- en: The regex engine matches the first `a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then matches every character up to the end of the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It fails because it doesn't find the dash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, the engine does backtracking and tries the same with the following `a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the same process again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It tries this with every character. If you think about what we''re doing, it
    doesn''t make any sense to keep trying once you have failed the first time. And
    that''s exactly what an atomic group is useful for. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here we've added `?>`, which indicates an atomic group, so once the regex engine
    fails to match`,` it doesn't keep trying with every character in the data.
  prefs: []
  type: TYPE_NORMAL
- en: Special cases with groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python provides us with some forms of groups that can help us to modify the
    regular expressions or even to match a pattern only when a previous group exists
    in the match, such as an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Flags per group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a way to apply the flags we''ve seen in [Chapter 2](ch02.html "Chapter 2. Regular
    Expressions with Python") *Regular Expressions with Python*, using a special form
    of grouping: `(?iLmsux)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Letter | Flag |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **i** | re.IGNORECASE |'
  prefs: []
  type: TYPE_TB
- en: '| **L** | re.LOCALE |'
  prefs: []
  type: TYPE_TB
- en: '| **m** | re.MULTILINE |'
  prefs: []
  type: TYPE_TB
- en: '| **s** | re.DOTALL |'
  prefs: []
  type: TYPE_TB
- en: '| **u** | re.UNICODE |'
  prefs: []
  type: TYPE_TB
- en: '| **x** | re.VERBOSE |'
  prefs: []
  type: TYPE_TB
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We've seen what these examples do several times in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a flag is applied to the whole expression.
  prefs: []
  type: TYPE_NORMAL
- en: yes-pattern|no-pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a very useful case of groups. It tries to match a pattern in case a
    previous one was found. On the other hand, it doesn''t try to match a pattern
    in case a previous group was not found. In short, it''s like an if-else statement.
    The syntax for this operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression means: if the group with this ID has already been matched,
    then at this point of the string, the `yes-pattern` pattern has to match. If the
    group hasn''t been matched, then the `no-pattern` pattern has to match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it works continuing with our trite example. We have a list of
    products, but in this case the ID can be made in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The country code (two digits), a dash, three or four alphanumeric characters,
    a dash, and the area code (2 digits). For example: `34-adrl-01`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Three or four alphanumeric characters. For example: `adrl`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, when there is a country code, we need to match the country area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the previous example, there is a match when we have a country
    code and area code. Note that when there is a country code but no area code, there
    is no match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And what''s `no-pattern` for? Let''s add another constraint to the previous
    example: if there is no country code there has to be a name at the end of the
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The country code (2 digits), a dash, three or four alphanumeric characters,
    a dash, and the area code (2 digits). For example: `34-adrl-01`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Three or four alphanumeric characters, followed by three or four characters.
    For example: `adrl-sala`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As expected, if there is a country code and an area code, there is a match.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we do have a country area, but there is no area code,
    so there is no match.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And finally, when there is no country area, there must be a name, so we have
    a match.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `no-pattern` is optional, so in the first example, we've omitted it.
  prefs: []
  type: TYPE_NORMAL
- en: Overlapping groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout [Chapter 2](ch02.html "Chapter 2. Regular Expressions with Python"),
    *Regular Expressions with Python*, we''ve seen several operations where there
    was a warning about overlapping groups: for example, the `findall` operation.
    This is something that seems to confuse a lot of people. So, let''s try to bring
    some clarity with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: What's happening here? Why does the following expression give us `'a'` and `'a'`
    instead of `'aba'` and `'a'`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at it step by step to understand the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overlapping groups](graphics/3156OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Overlapping groups matching process
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the preceding figure, the characters `aba` are matched, but
    the captured group is only formed by `a`. This is because even though our regex
    is grouping every character, it stays with the last `a`. Keep this in mind because
    it''s the key to understanding how it works. Stop for a moment and think about
    it, we''re requesting the regex engine to capture all the groups made up of `a`
    or `b`, but just for one of the characters and that''s the key. So, how can you
    capture the groups made of several `''a''` or `''b''` in any order? The following
    expression does the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We're asking the regex engine to capture every group made up of the subexpression
    (`a|b`) and not to group just one character.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing on this— if we would want to obtain every group made of `a`
    or `b` with `findall`, we could write this simple expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're asking the regex engine to capture a group made of `a` or
    `b`. As we're using `findall`, we get every pattern matched, so we get four groups.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Rule of Thumb**'
  prefs: []
  type: TYPE_NORMAL
- en: It's better to keep regular expressions as simple as you can. So, you should
    begin with the simplest expression and then build more complex expressions step
    by step and not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don't allow the simplicity of the chapter to fool you, what we have learned
    throughout this chapter will be very useful in your day-to-day work with regex,
    and it'll give you a lot of leverage.
  prefs: []
  type: TYPE_NORMAL
- en: Let's summarize what we have learned so far. First, we have seen how a group
    can help us when we need to apply quantifiers to only some part of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: We have also learned how to use the captured groups in the pattern again or
    even in the replacement string in the `sub` operation, thanks to **backreferences**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have also viewed named groups, a tool for improving the
    readability and future maintenance of the regex.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, we have learned to match a subexpression just in case a previous group
    exists or on the other hand, to match it when a previous group doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to use groups, it's time to learn a more complex subject
    very close to groups; look around!
  prefs: []
  type: TYPE_NORMAL
