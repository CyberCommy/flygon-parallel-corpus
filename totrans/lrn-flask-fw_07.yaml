- en: Chapter 7. AJAX and RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will use Flask-Restless to create a RESTful API for the
    blogging app. A RESTful API is a way of accessing your blog programmatically,
    by providing highly structured data that represents your blog. Flask-Restless
    works very well with our SQLAlchemy models and also handles complex tasks such
    as serialization and result filtering. We will use our REST API to build an AJAX-powered
    commenting feature for our blog entries. By the end of this chapter, you will
    be able to create easily-configurable APIs for your SQLAlchemy models, and you'll
    make and respond to AJAX requests in your Flask app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a model to store comments on blog entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Flask-Restless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a RESTful API for the comment model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a frontend for communicating with our API using Ajax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a comment model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start creating our API, we need to create a database model for the
    resource that we wish to share. The API we are building will be used to create
    and retrieve comments using AJAX, so our model will contain all the fields that
    would be relevant for storing an unauthenticated user's comment on one of our
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, the following fields should be sufficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`, the name of the person making the comment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`, the e-mail address of the person commenting, which we will use solely
    to display an image of them from **Gravatar**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URL`, the URL to the commenters blog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ip_address`, the IP address of the commenter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`, the actual comment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`, one of either `Public`, `Spam,` or `Deleted`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_timestamp`, the timestamp with which the comment was created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry_id`, the ID of blog entry the comment relates to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lets begin coding by creating the Comment model definition in our app''s `models.py`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After adding the `Comment` model definition, we need to set up the SQLAlchemy
    relationship between the `Comment` and `Entry` models. As you will recall, we
    did this once before when setting up the relationship between `User` and `Entry`
    via the entries relationship. We will do this for `Comment` by adding a comments
    attribute to the `Entry` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the `tags` relationship, add the following code to the `Entry` model
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've specified the relationship as `lazy='dynamic'`, which, as you will recall
    from [Chapter 5](ch05.html "Chapter 5. Authenticating Users"), *Authenticating
    Users*, means that the `comments` attribute on any given `Entry` instance will
    be a filterable query.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a schema migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to start using our new model, we need to update our database schema.
    Using the `manage.py` helper, create a schema migration for the `Comment` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then apply the migration by running `upgrade`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Comment` model is now ready to use! At this point, if we were implementing
    comments using regular Flask views, we might create a comments blueprint and start
    writing a view to handle the comment creation. However, we will be exposing the
    comments using a REST API and create them using AJAX directly from the front-end.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Flask-Restless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our model in place, we are now ready to install Flask-Restless, a third-party
    Flask extension that makes it simple to build RESTful APIs for your SQLAlchemy
    models. After ensuring that you have activated the blog app''s virtual environment,
    install Flask-Restless using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can verify if the extension is installed by opening up the interactive interpreter
    and getting the version that is installed. Don't forget, your exact version number
    may differ.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have Flask-Restless installed, let's configure it to work with our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Flask-Restless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like other Flask extensions, we will begin in the `app.py` module by configuring
    an object that will manage our new API. In Flask-Restless, this object is called
    an `APIManager` and it will allow us to create RESTful endpoints for our SQLAlchemy
    models. Add the following lines to `app.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because the API will depend on both our Flask API object and our `Comment` model,
    we need to make sure that we don't create any circular module dependencies. We
    can avoid introducing circular imports by creating a new module, `api.py,` at
    the root of the app directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the bare minimum to see what Flask-Restless provides out-of-the-box.
    Add the following code to `api.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code in `api.py` calls the `create_api()` method on our `APIManager` object.
    This method will populate our app with additional URL routes and view code that,
    together, constitute a RESTful API. The methods parameter indicates that we will
    allow only `GET` and `POST` requests (meaning comments can be read or created,
    but not edited or deleted).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final action is to import the new API module in `main.py`, the entry-point
    into our application. We are importing the module purely for its side-effects,
    registering the URL routes. Add the following code to `main.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Making API requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In one terminal, start up the development server. In another terminal, let''s
    see what happens when we make a `GET` request to our API endpoint (note there
    is no trailing forward slash):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are no comments in the database, so no objects have been serialized and
    returned to us. However, there is some interesting metadata that tells us how
    many objects are there in the database, what page we are on, and how many total
    pages of comments exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new comment by POSTing some JSON data to our API (I will assume
    that the first entry in your database has an id of `1`). We will use `curl` to
    submit a `POST` request containing a JSON-encoded representation of a new comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that no typos were made, the API will respond with the following data,
    confirming the creation of the new `Comment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all the data we POSTed is included in the response, in addition
    to the rest of the field data, such as the new comment's id and timestamps. Surprisingly,
    even the corresponding `Entry` object has been serialized and included in the
    response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a comment in the database, let''s try making another `GET`
    request to our API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first object contains exactly the same data that was returned to us when
    we made the `POST` request. In addition, the surrounding metadata has changed
    to reflect the fact that there is now one comment in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating comments using AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to allow users to post comments, we first need a way to capture their
    input, which we will do by creating a `Form` class with `wtforms`. This form should
    allow users to enter their name, email address, an optional URL, and their comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the forms module in the entries blueprint, add the following form definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering why we are specifying validators, since the API will be
    handling the POSTed data. We do this because Flask-Restless does not provide validation,
    but it does provide a hook where we can perform validation. In this way, we can
    leverage WTForms validation inside our REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the form in the entry detail page, we need to pass the form
    into the context when rendering the detail template. Open the entries blueprint
    and import the new `CommentForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then modify the `detail` view to pass a form instance into the context. We
    will pre-populate the `entry_id` hidden field with the value of the requested
    entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With the form now in the detail template context, all that is left is to render
    the form. Create an empty template in `entries/templates/entries/includes/` named
    `comment_form.html` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The interesting thing to note is that we are not using the `form_field` macro
    for the `entry_id` field. This is because we do not want the comment form to display
    a label for a field that will not be visible to the user. Instead, we will initialize
    the form with this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need to include the comment form in the `detail.html` template.
    Below the entry body, add the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the development server, try navigating to the detail page for any entry.
    You should see a comment form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating comments using AJAX](img/1709_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: AJAX form submissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To simplify making AJAX requests, we are going to use the jQuery library. Feel
    free to substitute another JavaScript library if you prefer but, since jQuery
    is so ubiquitous (and plays nicely with Bootstrap), we will be using it for this
    section. If you have been following along with the code up to this point, jQuery
    should already be included on all pages. Now we need to create a JavaScript file
    to handle the comment submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in `statics/js/` named `comments.js` and add the following
    JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `comments.js` code handles POSTing the form data, serialized as JSON, to
    the REST API. It also handles taking the API response and displaying either a
    success or an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `detail.html` template, we simply need to include our script and bind
    the submit handler. Add the following block override to the detail template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and try submitting a comment or two.
  prefs: []
  type: TYPE_NORMAL
- en: Validating data in the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately for us, our API is not performing any type of validation on the
    incoming data. In order to validate the `POST` data, we need to use a hook provided
    by Flask-Restless. Flask-Restless calls these hooks request preprocessors and
    postprocessors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to use the POST preprocessor to perform some validation
    on our comment data. Start by opening `api.py` and making the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Our API will now validate the submitted comment using the validation logic from
    our `CommentForm`. We do this by specifying a preprocessor for the `POST` method.
    The `POST` preprocessor, which we've implemented as `post_preprocessor`, accepts
    the deserialized `POST` data as an argument. We can then feed that data into our
    `CommentForm` and call it's `validate()` method. In the event where validation
    fails, we will raise a `ProcessingException`, signaling to Flask-Restless that
    this data was unprocessable and returning a `400` Bad Request response.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, I have not supplied the **Comment** field, which
    is required. I receive an error message when I try to submit the comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating data in the API](img/1709_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Preprocessors and postprocessors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just looked at an example of using the `POST` method preprocessor with Flask-Restless.
    In the following table, you can see the other hooks that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method name | Description | Preprocessor arguments | Postprocessor arguments
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET_SINGLE` | Retrieve a single object by primary key | `instance_id`, the
    primary key of the object | `result`, the dictionary representation of the object
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET_MANY` | Retrieve multiple objects | `search_params`, a dictionary of
    search parameters used to filter the result set | `result`, the representation
    of the object''s`search_params` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT_SINGLE` | Update a single object by primary key | `instance_id`data,
    a dictionary of data used to update the object | `result`, the dictionary representation
    of the updated object |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT_MANY` | Update multiple objects | `search_params`, a dictionary of search
    parameters used to determine which objects to update.data, a dictionary of data
    used to update the object. | `query`, a SQLAlchemy query representing the objects
    to be updated.`data``search_params` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Create a new instance | `data`, the dictionary of data to populate
    the new object | `result`, a dictionary representation of the new object |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Delete an instance by primary key | `instance_id`, the primary
    key of the object to be deleted | `was_deleted`, a boolean value indicating whether
    the object was deleted |'
  prefs: []
  type: TYPE_TB
- en: Loading comments using AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are able to create validated comments using AJAX, let's use the
    API to retrieve the list of comments and display them beneath the blog entry.
    To do this, we will read the values from the API and dynamically create DOM elements
    to display the comments. As you might recall from the earlier API responses we
    examined, there is quite a bit of private information being returned, including
    the entire serialized representation of each comment's associated `Entry`. For
    our purposes, this information is redundant and will furthermore waste bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by doing a bit of additional configuration to our comments endpoint
    to restrict the `Comment` fields we return. In `api.py`, make the following addition
    to the call to `api.create_api()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Requesting the list of comments now gives us a more manageable response that
    doesn''t leak implementation details or private data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A nice feature would be to display an avatar next to a user's comment. Gravatar,
    a free avatar service, allows users to associate their e-mail address with an
    image. We will use the commenter's e-mail address to display their associated
    avatar (if one exists). If the user has not created an avatar, an abstract pattern
    will be shown instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a method on the `Comment` model to generate the URL for a user''s
    Gravatar image. Open `models.py` and add the following method to `Comment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You will also need to be sure to import `hashlib` and `urllib` at the top of
    the models module.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we attempt to include Gravatar in the list of columns, Flask-Restless will
    raise an exception because `gravatar` is actually a method. Luckily, Flask-Restless
    provides a way to include the results of method calls when serializing objects.
    In `api.py`, make the following addition to the `create_api()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and try fetching the list of comments. You should now see the Gravatar
    URL included in the serialized response.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the list of comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now need to return to our JavaScript file and add code to retrieve the list
    of comments. We will do this by passing in a search filter to the API, which will
    retrieve only the comments that are associated with the requested blog entry.
    Search queries are expressed as a list of filters, each filter specifying the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operation (for example, equals)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value to search for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open `comments.js` and add the following code after the line that begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, near the bottom of the file, export the load function alongside the `bindHandler`
    export as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The new JavaScript code that we added makes an AJAX request to the API for comments
    associated with a given Entry. If no comments exist, a message is displayed indicating
    no comments have been made yet. Otherwise, the entries are rendered as a list
    below the `Entry` body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final task left is to call `Comments.load()` in the details template when
    the page is rendered. Open `detail.html` and add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After making a couple comments, the comment list looks as seen in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving the list of comments](img/1709_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As an exercise, see if you can write code to render any new comment that is
    POSTed by the user. You will recall that, when a comment is successfully created,
    the new data will be returned as a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: Reading more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask-Restless supports a number of configuration options that, in the interests
    of space, could not be covered in this chapter. The search filters are a very
    powerful tool, and we only scratched the surface of what is possible. Additionally,
    the pre and postprocessing hooks can be used to implement a number of interesting
    features such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication, which can be implemented in the preprocessor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default filters for `GET_MANY`, which could be used to restrict the list of
    comments to those that are public, for instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom or calculated values to the serialized response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying incoming `POST` values to set default values on the model instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If REST API is a key component in your application, I strongly suggest spending
    time reading the Flask-Restless documentation. The documentation can be found
    online at [https://flask-restless.readthedocs.org/en/latest/](https://flask-restless.readthedocs.org/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added a simple REST API to our app using the Flask-Restless
    extension. We then used JavaScript and Ajax to integrate our frontend with the
    API, allowing users to view and post new comments, all without writing a single
    line of view code.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will work on creating apps that are testable and find
    ways to improve our code for this purpose. This will also allow us to verify that
    the code we have written is doing what we would like it to do; nothing more, nothing
    less. Automating this will give you confidence and ensure that the RESTful API
    is working as expected.
  prefs: []
  type: TYPE_NORMAL
