- en: '*Chapter 7*: Demystifying V4L2 and Video Capture Device Drivers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：解密V4L2和视频捕获设备驱动程序'
- en: 'Video has long been inherent in embedded systems. Given that Linux is the favorite
    kernel used in such systems, it goes without saying that it natively embeds its
    support for video. This is the so-called **V4L2**, which stands for **Video 4
    (for) Linux 2**. Yes! *2* because there was a first version, *V4L*. V4L2 augments
    V4L with memory management features and other elements that make this framework
    as generic as possible. Through this framework, the Linux kernel is able to deal
    with camera devices and the bridge to which they are connected, as well as the
    associated DMA engines. These are not the only elements supported by V4L2\. We
    will begin with an introduction to framework architecture, learning how it is
    organized, and walk through the main data structures it comprises. Then, we will
    learn how to design and write the bridge device driver, the one responsible for
    DMA operations, and finally, we will delve into sub-device drivers. That said,
    in this chapter, the following topics will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 视频一直是嵌入式系统中固有的。鉴于Linux是这些系统中常用的内核，可以毫不夸张地说它本身就原生支持视频。这就是所谓的**V4L2**，代表**Video
    4 (for) Linux 2**。是的！*2*是因为有第一个版本，*V4L*。V4L2通过内存管理功能和其他元素增强了V4L，使得该框架尽可能通用。通过这个框架，Linux内核能够处理摄像头设备和它们连接的桥接器，以及相关的DMA引擎。这些并不是V4L2支持的唯一元素。我们将从框架架构的介绍开始，了解它的组织方式，并浏览它包括的主要数据结构。然后，我们将学习如何设计和编写桥接设备驱动程序，负责DMA操作，最后，我们将深入研究子设备驱动程序。因此，在本章中，将涵盖以下主题：
- en: Framework architecture and the main data structures
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架架构和主要数据结构
- en: Bridge video device drivers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频桥设备驱动程序
- en: The concept of sub-devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子设备的概念
- en: V4L2 control infrastructure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V4L2控制基础设施
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are prerequisites for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的先决条件如下：
- en: Advanced computer architecture knowledge and C programming skills
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级计算机体系结构知识和C编程技能
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核v4.19.X源代码，可在[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)获取。
- en: Framework architecture and the main data structures
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架架构和主要数据结构
- en: Video devices are becoming increasingly complex. In such devices, hardware often
    comprises several integrated IPs that need to cooperate with one another in a
    controlled manner, and this leads to complex V4L2 drivers. This requires figuring
    out the architecture prior to delving into the code and this is precisely the
    requirement that this section addresses.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 视频设备变得越来越复杂。在这种设备中，硬件通常包括多个集成IP，需要以受控的方式相互合作，这导致复杂的V4L2驱动程序。这要求在深入代码之前弄清楚架构，这正是本节要解决的要求。
- en: It is known that drivers normally mirror the hardware model in programming.
    In the V4L2 context, the diverse IP components are modeled as software blocks
    called sub-devices. V4L2 sub-devices are usually kernel-only objects. Moreover,
    if the V4L2 driver implements the media device API (which we will discuss in the
    next chapter, [*Chapter 8*](B10985_08_ePub_AM.xhtml#_idTextAnchor342), *Integrating
    with V4L2 Async and Media Controller Frameworks*), those sub-devices will automatically
    inherit from media entities, allowing applications to enumerate the sub-devices
    and to discover the hardware topology using the media framework's entities, pads,
    and link-related enumeration APIs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，驱动程序通常在编程中反映硬件模型。在V4L2上下文中，各种IP组件被建模为称为子设备的软件块。V4L2子设备通常是仅内核对象。此外，如果V4L2驱动程序实现了媒体设备API（我们将在下一章[*第8章*]（B10985_08_ePub_AM.xhtml#_idTextAnchor342）中讨论，*与V4L2异步和媒体控制器框架集成*），这些子设备将自动继承自媒体实体，允许应用程序枚举子设备并使用媒体框架的实体、端口和链接相关的枚举API来发现硬件拓扑。
- en: Notwithstanding making sub-devices discoverable, drivers can likewise decide
    to make them configurable by applications in a straightforward manner. When both
    the sub-device driver and the V4L2 device driver uphold this, sub-devices will
    feature a character device node on which **ioctls** (**input/output controls**)
    can be invoked in order to query, read, and write sub-device capabilities (including
    controls), or to even negotiate image formats on individual sub-device pads.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使子设备可发现，驱动程序也可以决定以简单的方式使其可由应用程序配置。当子设备驱动程序和V4L2设备驱动程序都支持此功能时，子设备将在其上调用**ioctls**（输入/输出控制）的字符设备节点，以便查询、读取和写入子设备功能（包括控制），甚至在单个子设备端口上协商图像格式。
- en: 'At the driver level, V4L2 does a lot of work for the driver developer so that
    they just have to implement the hardware-related code and register the relevant
    device. Before going further, we must introduce several important structures that
    constitute the core of V4L2:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在驱动程序级别，V4L2为驱动程序开发人员做了很多工作，因此他们只需实现与硬件相关的代码并注册相关设备。在继续之前，我们必须介绍构成V4L2核心的几个重要结构：
- en: '`struct v4l2_device`: A hardware device may contain multiple child devices,
    such as a TV card in addition to a capture device, and possibly a VBI device or
    FM tuner. `v4l2_device` is the root node of all of these devices and is responsible
    for managing all child devices.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct v4l2_device`：硬件设备可能包含多个子设备，例如电视卡以及捕获设备，可能还有VBI设备或FM调谐器。`v4l2_device`是所有这些设备的根节点，负责管理所有子设备。'
- en: '`struct video_device`: The main purpose of this structure is to provide the
    well-known `/dev/videoX` or `/dev/v4l-subdevX` device nodes. This structure mainly
    abstracts the capture interface, also known as the `/dev/v4l-subdevX` nodes and
    their file operations. From within the sub-device driver, only the core accesses
    this structure in the underlying sub-device.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct video_device`：此结构的主要目的是提供众所周知的`/dev/videoX`或`/dev/v4l-subdevX`设备节点。此结构主要抽象了捕获接口，也称为`/dev/v4l-subdevX`节点及其文件操作。在子设备驱动程序中，只有核心访问底层子设备中的这个结构。'
- en: '`struct vb2_queue`: For me, this is the main data structure in the video driver,
    as it is used in the real logic of data streaming and the center part of the DMA
    operations, along with `struct vb2_v4l2_buffer`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct vb2_queue`：对我来说，这是视频驱动程序中的主要数据结构，因为它在数据流逻辑和DMA操作的中心部分中使用，以及`struct
    vb2_v4l2_buffer`。'
- en: '`struct v4l2_subdev`: This is the sub-device responsible for implementing specific
    functions and abstracting a specific function in the video system of the SoC.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct v4l2_subdev`：这是负责实现特定功能并在SoC的视频系统中抽象特定功能的子设备。'
- en: '`struct video_device` can be regarded as the base class for all devices and
    sub-devices. When we write our own drivers, access to this data structure may
    be direct (if we are dealing with a bridge driver) or indirect (if we are dealing
    with a sub-device, because sub-device APIs abstract and hide the underlying `struct
    video_device` embedded into each sub-device data structure).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct video_device`可以被视为所有设备和子设备的基类。当我们编写自己的驱动程序时，对这个数据结构的访问可能是直接的（如果我们正在处理桥接驱动程序）或间接的（如果我们正在处理子设备，因为子设备API抽象和隐藏了嵌入到每个子设备数据结构中的底层`struct
    video_device`）。'
- en: Now we are aware of the data structures this framework is made of. Moreover,
    we introduced their relationships and their respective purposes. It is now time
    for us to go deeper into the details by introducing how to initialize and register
    a V4L2 device with the system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这个框架由哪些数据结构组成。此外，我们介绍了它们的关系和各自的目的。现在是时候深入了解细节，介绍如何初始化和注册V4L2设备到系统中了。
- en: Initializing and registering a V4L2 device
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化和注册V4L2设备
- en: 'Prior to being used or part of the system, the V4L2 device must be initialized
    and registered, and this is the main topic of this section. Once the framework
    architecture description is complete, we can start going through the code. In
    this kernel, a V4L2 device is an instance of the `struct v4l2_device` structure.
    This is the highest data structure in the media framework, maintaining a list
    of sub-devices the media pipe is comprised of and acting as the parent of the
    bridge device. V4L2 drivers should include `<media/v4l2-device.h>`, which will
    bring in the following definition of a `struct v4l2_device`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在被使用或成为系统的一部分之前，V4L2设备必须被初始化和注册，这是本节的主要内容。一旦框架架构描述完成，我们就可以开始阅读代码了。在这个内核中，V4L2设备是`struct
    v4l2_device`结构的一个实例。这是媒体框架中的最高数据结构，维护着媒体管道由哪些子设备组成，并充当桥接设备的父级。V4L2驱动程序应该包括`<media/v4l2-device.h>`，这将引入`struct
    v4l2_device`的以下定义：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Unlike other video-related data structures that we will introduce in the following
    sections, there are only a few fields in this structure. Their meanings are as
    follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们将在以下部分介绍的其他与视频相关的数据结构不同，此结构中只有少数字段。它们的含义如下：
- en: '`dev` is a pointer to the parent `struct device` for this V4L2 device. This
    will be automatically set upon registration, and `dev->driver_data` will point
    to this `v4l2` struct.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`是指向此V4L2设备的父`struct device`的指针。这将在注册时自动设置，`dev->driver_data`将指向这个`v4l2`结构。'
- en: '`mdev` is a pointer to a `struct media_device` object to which this V4L2 device
    belongs. This field deals with the media controller framework and will be introduced
    in the related section. This may be `NULL` if integration with the media controller
    framework is not required.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdev`是指向此V4L2设备所属的`struct media_device`对象的指针。这个字段涉及媒体控制器框架，并将在相关部分介绍。如果不需要与媒体控制器框架集成，则可能为`NULL`。'
- en: '`subdevs` is the list of sub-devices for this V4L2 device.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subdevs`是此V4L2设备的子设备列表。'
- en: '`lock` is the lock protecting access to this structure.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock`是保护对此结构的访问的锁。'
- en: '`name` is a unique name for this V4L2 device. By default, it is derived from
    the driver name plus the bus ID.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是此V4L2设备的唯一名称。默认情况下，它是从驱动程序名称加上总线ID派生的。'
- en: '`notify` is a pointer to a notification callback, called by a sub-device to
    inform this V4L2 device of some events.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify`是指向通知回调的指针，由子设备调用以通知此V4L2设备某些事件。'
- en: '`ctrl_handler` is the control handler associated with this device. It keeps
    track of all of the controls this V4L2 device has. This may be `NULL` if there
    are no controls.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctrl_handler`是与此设备关联的控制处理程序。它跟踪此V4L2设备拥有的所有控件。如果没有控件，则可能为`NULL`。'
- en: '`prio` is the device''s priority state.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prio`是设备的优先级状态。'
- en: '`ref` is internally used by the core for reference counting.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ref`是核心用于引用计数的内部使用。'
- en: '`release` is the callback to be called when the last user of this structure
    goes off.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release`是当此结构的最后一个用户退出时要调用的回调函数。'
- en: 'This top-level structure is initialized and registered with the core by the
    same function, `v4l2_device_register()`, whose prototype is the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顶层结构通过相同的函数`v4l2_device_register()`初始化并注册到核心，其原型如下：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first `dev` argument is normally the struct device pointer of the bridge
    bus's related device-data structure. That is `pci_dev`, `usb_device`, or `platform_device`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`dev`参数通常是桥接总线相关设备数据结构的struct device指针。即`pci_dev`、`usb_device`或`platform_device`。
- en: If the `dev->driver_data` field is `NULL`, this function will make it point
    to the actual `v4l2_dev` object being registered. Moreover, if `v4l2_dev->name`
    is empty, then it will be set to a value resulting from the concatenation of `dev
    driver name + dev device name`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`dev->driver_data`字段为`NULL`，此函数将使其指向正在注册的实际`v4l2_dev`对象。此外，如果`v4l2_dev->name`为空，则将设置为从`dev
    driver name + dev device name`的连接结果。
- en: 'However, if the `dev` parameter is `NULL`, then you must set `v4l2_dev->name`
    before calling `v4l2_device_register()`. On the other hand, a previously registered
    V4L2 device can be unregistered using `v4l2_device_unregister()` as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Upon a call to this function, all sub-devices will be unregistered as well.
    This is all about the V4L2 device. However, you should keep in mind that it is
    the top-level structure, maintaining a list of sub-devices of the media device
    and acting as the parent of the bridge device.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with the main V4L2 device (the one that encompasses the
    other device-related data structures) initialization and registration, we can
    introduce specific device drivers, starting with the bridge driver, which is platform-specific.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Introducing video device drivers – the bridge driver
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bridge driver controls the platform `/USB/PCI/...` hardware that is responsible
    for the DMA transfers. This is the driver that handles data streaming from the
    device. One of the main data structures the bridge driver directly deals with
    is `struct video_device`. This structure embeds the entire element needed to perform
    video streaming, and one of its first interactions with the user space is to create
    device files in the `/dev/` directory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The `struct video_device` structure is defined in `include/media/v4l2-dev.h`,
    which means the driver code must contain `#include <media/v4l2-dev.h>`. The following
    is what this structure looks like from the header file where it is defined:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Not only does the bridge driver play with this structure – this structure is
    the main `v4l2` structure when it comes to representing V4L2-compatible devices,
    including sub-devices. However, depending on the nature of the driver (be it a
    bridge driver or sub-device driver), some elements may vary or may be `NULL`.
    The following are descriptions of each element in the structure:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '`entity`, `intf_node`, and `pipe` are part of the integration with the media
    framework, as we will see in the section of the same name. The former abstracts
    the video device (which becomes an entity) from within the media framework, while
    `intf_node` represents the media interface device node, and `pipe` represents
    the streaming pipe to which the entity belongs.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fops` represents the file operations for the video device''s file node. The
    V4L2 core overrides the virtual device file operation with some extra logic required
    by the subsystem.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cdev` is the character device structure, abstracting the underlying `/dev/videoX`
    file node. `vdev->cdev->ops` is set with `v4l2_fops` (defined in `drivers/media/v4l2-core/v4l2-dev.c`)
    by the V4L2 core. `v4l2_fops` is actually a generic (in term of ops implemented)
    and V4L2-oriented (in terms of what these ops do) file op assigned to each `/dev/videoX`
    char device and wraps the video device-specific ops defined in `vdev->fops`. At
    their return paths, each callback in `v4l2_fops` will call its counterpart in
    `vdev->fops`. `v4l2_fops` callbacks perform a sanity check prior to invoking the
    real ops in `vdev->fops`. For example, on a `mmap()` system call issued by the
    user space on a `/dev/videoX` file, `v4l2_fops->mmap` will be invoked first, which
    will make sure that `vdev->fops->mmap` is set prior to calling it and printing
    a debug message if needed.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ctrl_handler`: The default value is `vdev->v4l2_dev->ctrl_handler`.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queue` is the buffer management queue associated with this device node. This
    is one of the data structures only the bridge driver can play with. This may be
    `NULL`, especially when it comes to non-bridge video drivers (sub-devices, for
    example).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prio` is a pointer to `&struct v4l2_prio_state` with the device''s priority
    state. If this state is `NULL`, then `v4l2_dev->prio` will be used.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` is the name of the video device.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vfl_type` is the V4L device type. Possible values are defined by `enum vfl_devnode_type`,
    containing the following:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '– `VFL_TYPE_GRABBER`: For video input/output devices'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '– `VFL_TYPE_VBI`: For vertical blank data (undecoded)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_TYPE_VBI`：用于垂直空白数据（未解码）
- en: '– `VFL_TYPE_RADIO`: For radio cards'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_TYPE_RADIO`：用于无线电卡
- en: '– `VFL_TYPE_SUBDEV`: For V4L2 sub-devices'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_TYPE_SUBDEV`：用于 V4L2 子设备
- en: '– `VFL_TYPE_SDR`: Software-defined radio'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_TYPE_SDR`：软件定义无线电
- en: '– `VFL_TYPE_TOUCH`: For touch sensors'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_TYPE_TOUCH`：用于触摸传感器
- en: '`vfl_dir` is a V4L receiver, transmitter, or memory-to-memory (denoted m2m
    or mem2mem) device. Possible values are defined by `enum vfl_devnode_direction`,
    containing the following:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vfl_dir` 是一个 V4L 接收器、发射器或内存到内存（表示为 m2m 或 mem2mem）设备。可能的值由 `enum vfl_devnode_direction`
    定义，包括以下内容：'
- en: '– `VFL_DIR_RX`: For capture devices'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_DIR_RX`：用于捕获设备
- en: '– `VFL_DIR_TX`: For output devices'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_DIR_TX`：用于输出设备
- en: '– `VFL_DIR_M2M`: should be mem2mem devices (read mem-to-mem, and also known
    as memory-to-memory devices). A mem2mem device is a device that uses memory buffers
    passed by user space applications for both the source and destination. This is
    distinct from current and existing drivers that use memory buffers for only one
    of those at a time. Such a device would be of both the **OUTPUT** and **CAPTURE**
    types in terms of V4L2\. Although no such devices are present in the V4L2 framework,
    a demand for such a model exists, for example, for ''resizer devices'' or for
    the V4L2 loopback driver.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_DIR_M2M`：应该是 mem2mem 设备（读取内存到内存，也称为内存到内存设备）。mem2mem 设备是使用用户空间应用程序传递的内存缓冲区作为源和目的地的设备。这与当前和现有的仅使用其中一个的内存缓冲区的驱动程序不同。这样的设备在
    V4L2 框架中不存在，但是存在对这种模型的需求，例如，用于 '调整器设备' 或 V4L2 回环驱动程序。
- en: '`v4l2_dev` is the `v4l2_device` parent device of this video device.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v4l2_dev` 是此视频设备的 `v4l2_device` 父设备。'
- en: '`dev_parent` is the device parent for this video device. If not set, the core
    will set it with `vdev->v4l2_dev->dev`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev_parent` 是此视频设备的设备父级。如果未设置，核心将使用 `vdev->v4l2_dev->dev` 进行设置。'
- en: '`ioctl_ops` is a pointer to `&struct v4l2_ioctl_ops`, which defines a set of
    ioctl callbacks.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioctl_ops` 是指向 `&struct v4l2_ioctl_ops` 的指针，它定义了一组 ioctl 回调。'
- en: '`release` is a callback called by the core when the last user of the video
    device exits. This must be non-`NULL`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release` 是核心在视频设备的最后一个用户退出时调用的回调。这必须是非-`NULL`。'
- en: '`lock` is a mutex serializing access to this device. It is the principal serialization
    lock by means of which all ioctls are serialized. It is common for bridge drivers
    to set this field with the same mutex as the *queue->lock*, which is the lock
    for serializing access to the queue (serializing streaming). However, if *queue->lock*
    is set, then the streaming ioctls are serialized by that separate lock.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock` 是一个互斥锁，用于串行访问此设备。这是主要的串行化锁，通过它所有的 ioctls 都被串行化。桥接驱动程序通常会使用相同的互斥锁设置此字段，就像
    *queue->lock* 一样，这是用于串行化访问队列的锁（串行化流）。但是，如果设置了 *queue->lock*，那么流 ioctls 将由单独的锁串行化。'
- en: '`num` is the actual device node index assigned by the core. It corresponds
    to the *X* in `/dev/videoX`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num` 是核心分配的实际设备节点索引。它对应于 `/dev/videoX` 中的 *X*。'
- en: '`flags` are video device flags. You should use bit operations to set/clear/test
    flags. They contain a set of `&enum v4l2_video_device_flags` flags.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 是视频设备的标志。您应该使用位操作来设置/清除/测试标志。它们包含一组 `&enum v4l2_video_device_flags`
    标志。'
- en: '`fh_list` is a list of `struct v4l2_fh`, which describes a V4L2 file handler,
    enabling tracking of the number of opened file handles for this video device.
    `fh_lock` is the lock associated with this list.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fh_list` 是一个 `struct v4l2_fh` 列表，描述了一个 V4L2 文件处理程序，可以跟踪为此视频设备打开的文件句柄的数量。`fh_lock`
    是与此列表关联的锁。'
- en: '`class` corresponds to the sysfs class. It is assigned by the core. This class
    entry corresponds to the `/sys/video4linux/` sysfs directory.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class` 对应于 sysfs 类。它由核心分配。此类条目对应于 `/sys/video4linux/` sysfs 目录。'
- en: Initializing and registering the video device
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化和注册视频设备
- en: Prior to its registration, the video device can be allocated either dynamically
    using `video_device_alloc()` (which simply invokes `kzalloc()`), or statically
    embedded into a dynamically allocated structure, which is the device state structure
    most of time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册之前，视频设备可以动态分配，使用 `video_device_alloc()`（简单调用 `kzalloc()`），或者静态嵌入到动态分配的结构中，这是大多数情况下的设备状态结构。
- en: 'The video device is dynamically allocated using `video_device_alloc()`, as
    in the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 视频设备是使用 `video_device_alloc()` 动态分配的，就像以下示例中一样：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding excerpt, the last line provides the `release` method for the
    video device since the `.release` field must be non-`NULL`. The `video_device_release()`
    callback is provided by the kernel. It just calls `kfree()` to free the allocated
    memory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的摘录中，最后一行提供了视频设备的 `release` 方法，因为 `.release` 字段必须是非-`NULL`。内核提供了 `video_device_release()`
    回调。它只调用 `kfree()` 来释放分配的内存。
- en: 'When it is embedded into a device state structure, the code becomes as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当它嵌入到设备状态结构中时，代码变为如下：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the video device must not be released alone as it is part of a bigger
    picture. When the video device is embedded into another structure, as in the preceding
    example, it does not require anything to be deallocated. At this point, since
    the release callback must be non-`NULL`, we can assign an empty function, such
    as `video_device_release_empty()`, also provided by the kernel.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，视频设备不能单独释放，因为它是一个更大的整体的一部分。当视频设备嵌入到另一个结构中时，就像前面的示例中一样，它不需要任何东西被释放。在这一点上，由于释放回调必须是非-`NULL`，我们可以分配一个空函数，例如
    `video_device_release_empty()`，也由内核提供。
- en: 'We are done with allocation. At this point, we can use `video_register_device()`
    in order to register the video device. The following is the prototype of this
    function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了分配。在这一点上，我们可以使用 `video_register_device()` 来注册视频设备。以下是此函数的原型：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding prototype, `type` specifies the type of bridge device being
    registered. It will be assigned to the `vdev->vfl_type` field. In the remainder
    of the chapter, we will consider it set to `VFL_TYPE_GRABBER` since we are dealing
    with the video capture interface. `nr` is the desired device node number (*0 ==
    /dev/video0*, *1 == /dev/video1*, ...). However, setting its value to `-1` will
    instruct the kernel to pick the first free index and use it. Specifying a fixed
    index may be useful to build fancy *udev* rules since the device node name is
    known in advance. In order for the registration to succeed, the following requirements
    must be met:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: First, you *MUST* set the `vdev->release` function as it can't be empty. If
    you don't need it, you can pass the V4L2 core's empty release method.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, you *MUST* set the `vdev->v4l2_dev` pointer; it should point to the
    V4L2 parent of the video device.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, but not mandatorily, you should set `vdev->fops` and `vdev->ioctl_ops`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`video_register_device()` returns `0` when successful. However, it might fail
    if there is no free minor, if the device node number could be found, or if the
    registration of the device node failed. In either error case, it returns a negative
    error number. Each registered video device creates a directory entry in `/sys/class/video4linux`
    with some attributes inside.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Minor numbers are allocated dynamically unless the kernel is compiled with the
    kernel option `CONFIG_VIDEO_FIXED_MINOR_RANGES`. In that case, minor numbers are
    allocated in ranges depending on the device node type (video, radio, and so on),
    with a total limit for `VIDEO_NUM_DEVICES`, which is set to `256`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The `vdev->release()` callback will never be called if registration fails. In
    this case, you need to call `video_device_release()` to free the allocated `video_device`
    struct if it has been allocated dynamically, or free your own struct if the `video_device`
    was embedded in it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'On the unloading path of the driver, or when the video nodes are no longer
    needed, you should call `video_unregister_device()` on the video device in order
    to unregister it so that its nodes can be removed:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After the preceding call, the device sysfs entries will be removed, causing
    *udev* to remove nodes in `/dev/`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only discussed the simplest part of the registration process,
    but there are some complex fields in the video device that need to be initialized
    prior to registration. Those fields extend the driver capabilities by providing
    the video device file operations, a coherent set of ioctl callbacks, and, most
    importantly, the media's queue and memory management interface. We will discuss
    these in the forthcoming sections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Video device file operations
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The video device (by means of its driver) is meant to be exposed to the user
    space as a special file in the `/dev/` directory, which the user space can use
    to interact with the underlying device: streaming the data. In order for the video
    device to be able to address user space queries (by means of system calls), a
    set of standard callbacks has to be implemented from within the driver. These
    callbacks form what are known today as `struct v4l2_file_operations` type, defined
    in `include/media/v4l2-dev.h` as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'These can be regarded as top-level callbacks as they are actually called (following
    a number of sanity checks, of course) by another low-level device file op associated
    with the `vdev->cdev` field this time, and which is set with `vdev->cdev->ops
    = &v4l2_fops;` upon file node creation. This allows the kernel to implement an
    extra logic and enforce sanity:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '`owner` is the pointer to the module. Most of the time, it is `THIS_MODULE`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open` should contain operations needed to implement the `open()` system call.
    Most of the time, this could be set to `v4l2_fh_open`, which is a V4L2 helper
    that simply allocates and initializes a `v4l2_fh` struct and adds it to the `vdev->fh_list`
    list. However, if your device requires some extra initialization, perform your
    initialization inside, and then call `v4l2_fh_open(struct file * filp)`. In any
    case, you *MUST* deal with `v4l2_fh_open`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`应包含实现`open()`系统调用所需的操作。大多数情况下，这可以设置为`v4l2_fh_open`，这是一个V4L2助手，简单地分配和初始化一个`v4l2_fh`结构，并将其添加到`vdev->fh_list`列表中。但是，如果您的设备需要一些额外的初始化，请在内部执行初始化，然后调用`v4l2_fh_open(struct
    file * filp)`。无论如何，您*必须*处理`v4l2_fh_open`。'
- en: '`release` should contain operations needed to implement the `close()` system
    call. This callback must deal with `v4l2_fh_release`. It can be set to either
    of the following:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release`应包含实现`close()`系统调用所需的操作。这个回调必须处理`v4l2_fh_release`。它可以设置为以下之一：'
- en: – `vb2_fop_release`, which is a videobuf2-V4L2 release helper that will clean
    up any ongoing streaming. This helper will call `v4l2_fh_release`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '- `vb2_fop_release`，这是一个videobuf2-V4L2释放助手，将清理任何正在进行的流。这个助手将调用`v4l2_fh_release`。'
- en: – Your custom callback, undoing what has been done in `.open`, and which must
    call `v4l2_fh_release` either directly or indirectly (using the `_vb2_fop_release()`
    helper, for example, in order for the V4L2 core to handle the cleanup of any ongoing
    streaming).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '- 撤销`.open`中所做的工作的自定义回调，并且必须直接或间接调用`v4l2_fh_release`（例如，使用`_vb2_fop_release()`助手），以便V4L2核心处理任何正在进行的流的清理。'
- en: '`read` should contain operations needed to implement the `read()` system call.
    Most of the time, the videobuf2-V4L2 helper `vb2_fop_read` is enough.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`应包含实现`read()`系统调用所需的操作。大多数情况下，videobuf2-V4L2助手`vb2_fop_read`就足够了。'
- en: '`write` is not needed in our case as it is for an OUTPUT type device. However,
    using `vb2_fop_write` here does the job.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`在我们的情况下不需要，因为它是用于输出类型设备。但是，在这里使用`vb2_fop_write`可以完成工作。'
- en: '`unlocked_ioctl` must be set to `video_ioctl2` if you use `v4l2_ioctl_ops`.
    The next section explains this in detail. This V4L2 core helper is a wrapper around
    `__video_do_ioctl()`, which handles the real logic, and which routes each ioctl
    to the appropriate callback in `vdev->ioctl_ops`, which is where individual ioctl
    handlers are defined.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用`v4l2_ioctl_ops`，则必须将`unlocked_ioctl`设置为`video_ioctl2`。下一节将详细解释这一点。这个V4L2核心助手是`__video_do_ioctl()`的包装器，它处理真正的逻辑，并将每个ioctl路由到`vdev->ioctl_ops`中的适当回调，这是单独的ioctl处理程序定义的地方。
- en: '`mmap` should contain operations needed to implement the `mmap()` system call.
    Most of the time, the videobuf2-V4L2 helper `vb2_fop_mmap` is enough, unless additional
    elements are required prior to performing mapping. Video buffers in the kernel
    (allocated in response to the `VIDIOC_REQBUFS` ioctl) have to be mapped individually
    prior to being accessed in the user space. This is the purpose of this `.mmap`
    callback, which just has to map one, and only one, video buffer to the user space.
    Information needed to map a buffer to a user space is queried to the kernel using
    the `VIDIOC_QUERYBUF` ioctl. Given the `vma` parameter, you can grab a pointer
    to the corresponding video buffer as follows:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmap`应包含实现`mmap()`系统调用所需的操作。大多数情况下，videobuf2-V4L2助手`vb2_fop_mmap`就足够了，除非在执行映射之前需要额外的元素。内核中的视频缓冲区（响应于`VIDIOC_REQBUFS`ioctl而分配）在被访问用户空间之前必须单独映射。这就是这个`.mmap`回调的目的，它只需要将一个视频缓冲区映射到用户空间。查询将缓冲区映射到用户空间所需的信息是使用`VIDIOC_QUERYBUF`ioctl向内核查询的。给定`vma`参数，您可以按如下方式获取指向相应视频缓冲区的指针：'
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`poll` should contain operations needed to implement the `poll()` system call.
    Most of the time, the videobuf2-V4L2 helper `vb2_fop_call` is enough. If this
    helper doesn''t know how to lock (neither `queue->lock` nor `vdev->lock` are set),
    then you shouldn''t be using it, but you should write your own, which can rely
    on the `vb2_poll()` helper that does not handle locking.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll`应包含实现`poll()`系统调用所需的操作。大多数情况下，videobuf2-V4L2助手`vb2_fop_call`就足够了。如果这个助手不知道如何锁定（`queue->lock`和`vdev->lock`都没有设置），那么您不应该使用它，而应该编写自己的助手，可以依赖于不处理锁定的`vb2_poll()`助手。'
- en: 'In either of these callbacks, you can use the `v4l2_fh_is_singular_file()`
    helper in order to check whether the given file is the only file handle opened
    for the associated `video_device`. Its alternative is `v4l2_fh_is_singular()`,
    which relies on `v4l2_fh` this time:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个回调中，您可以使用`v4l2_fh_is_singular_file()`助手来检查给定的文件是否是关联`video_device`的唯一文件句柄。它的替代方法是`v4l2_fh_is_singular()`，这次依赖于`v4l2_fh`：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To summarize, the following is what a capture video device driver''s file operation
    may look like:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，捕获视频设备驱动程序的文件操作可能如下所示：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can observe that in the preceding block, we used only standard core helpers
    in our ﬁle operations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到，在前面的块中，我们在我们的文件操作中只使用了标准的核心助手。
- en: Important note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Mem2mem devices may use their related v4l2-mem2mem-based helpers. Have a look
    at `drivers/media/v4l2-core/v4l2-mem2mem.c`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Mem2mem设备可以使用它们相关的基于v4l2-mem2mem的助手。看看`drivers/media/v4l2-core/v4l2-mem2mem.c`。
- en: V4L2 ioctl handling
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: V4L2 ioctl处理
- en: Let's talk a bit more about the `v4l2_file_operations.unlocked_ioctl` callback.
    As we have seen in the previous section, it should be set to `video_ioctl2`. `video_ioctl2`
    takes care of argument copying between the kernel and user space and performs
    some sanity checks (for example, whether the ioctl command is valid) prior to
    dispatching each individual `ioctl()` call to the driver, which ends up in a callback
    entry in the `video_device->ioctl_ops` field, which is of the `struct v4l2_ioctl_ops`
    type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再谈谈`v4l2_file_operations.unlocked_ioctl`回调。正如我们在前一节中所看到的，它应该设置为`video_ioctl2`。`video_ioctl2`负责在内核和用户空间之间进行参数复制，并在将每个单独的`ioctl()`调用分派到驱动程序之前执行一些合理性检查（例如，ioctl命令是否有效），这最终会进入`video_device->ioctl_ops`字段中的回调条目，该字段是`struct
    v4l2_ioctl_ops`类型。
- en: 'The `struct v4l2_ioctl_ops` structure contains callbacks for every possible
    ioctl in the V4L2 framework. However, you should only set these depending on the
    type of your device and the capability of the driver. Each callback in the structure
    maps an ioctl, and the structure is defined as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This structure has more than 120 entries describing operations for each and
    every possible V4L2 ioctl, whatever the device type is. In the preceding excerpt,
    only those that may be of interest to us are listed. We will not introduce callbacks
    into this structure. However, when you reach [*Chapter 9*](B10985_09_ePub_AM.xhtml#_idTextAnchor396),
    *Leveraging V4L2 API from the User Space*, I encourage you to come back to this
    structure and things will be clearer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, because you have provided a callback, it remains accessible. There
    are situations where you may want a callback that you had specified in `v4l2_ioctl_ops`
    to be ignored. This tends to be needed if, based on external factors (for example,
    which card is being used), you want to turn off certain features in `v4l2_ioctl_ops`
    without having to make a new struct. In order for the core to be aware of that
    and to ignore the callback, you should call `v4l2_disable_ioctl()` on the ioctl
    commands in question before `video_register_device()` is called:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is an example: `v4l2_disable_ioctl(&tea->vd, VIDIOC_S_HW_FREQ_SEEK);`.
    The previous call will mark the `VIDIOC_S_HW_FREQ_SEEK` ioctl to be ignored on
    the `tea->vd` video device.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The videobuf2 interface and APIs
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The videobuf2 framework is used to connect the V4L2 driver layer to the user
    space layer, providing a channel for data exchange that can allocate and manage
    video frame data. The videobuf2 memory management backend is fully modular. This
    allows custom memory management routines for devices and platforms with non-standard
    memory management requirements to be plugged in, without changing the high-level
    buffer management functions and API. The framework provides the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of streaming I/O V4L2 ioctls and file operations
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level video buffer, video queue, and state management functions
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Video buffer memory allocation and management
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Videobuf2 (or just vb2) facilitates driver development, reduces the code size
    of drivers, and aids in the proper and consistent implementation of the V4L2 API
    in drivers. V4L2 drivers are then charged with the task of acquiring video data
    from a sensor (usually via some sort of DMA controller) and feeding to the buffer
    managed by the vb2 framework.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: This framework implements many ioctl functions, including buffer allocation,
    enqueue, dequeue, and data flow control. It then deprecates any vendor-specific
    solutions, reducing significantly the media framework code size and easing efforts
    required to write V4L2 device drivers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Every videobuf2 helper, API, and data structure is prefixed with `vb2_`, while
    the version 1 (videobuf, defined in `drivers/media/v4l2-core/videobuf-core.c`)
    counterpart used the `videobuf_` prefix.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: This framework includes a number of concepts that may be familiar to some of
    you, but that need to be discussed in detail nevertheless.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Concept of buffers
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A buffer is the unit of data exchanged in a single shot between vb2 and the
    user space. From the point of view of user space code, a V4L2 buffer represents
    the data corresponding to a video frame (in the case of a capture device, for
    example). Streaming entails exchanging buffers between the kernel and user spaces.
    vb2 uses the `struct vb2_buffer` data structure to describe a video buffer. This
    structure is defined in `include/media/videobuf2-core.h` as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding data structure, those fields of no interest to us have been
    removed. The remaining fields are defined as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '`vb2_queue` is the `vb2` queue to which this buffer belongs. This will lead
    us to the next section, where we introduce the concept of queues according to
    videobuf2.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index` is the ID for this buffer.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` is the type of buffer. It is set by `vb2` at the time of allocation.
    It matches the type of queue it belongs to: `vb->type = q->type`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`是缓冲区的类型。它由`vb2`在分配时设置。它与其所属队列的类型匹配：`vb->type = q->type`。'
- en: '`memory` is the type of memory model used to make the buffers visible on user
    spaces. The value of this field is of the `enum vb2_memory` type, which matches
    its V4L2 user space counterpart, `enum v4l2_memory`. This field is set by `vb2`
    at the time of buffer allocation and reports the vb2 equivalent of the user space
    value assigned to the `.memory` field of `v4l2_requestbuffers` given to `vIDIOC_REQBUFS`.
    Possible values include the following:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory`是用于使缓冲区在用户空间可见的内存模型类型。此字段的值是`enum vb2_memory`类型，与其V4L2用户空间对应项`enum
    v4l2_memory`相匹配。此字段由`vb2`在缓冲区分配时设置，并报告了与`vIDIOC_REQBUFS`给定的`v4l2_requestbuffers`的`.memory`字段分配的用户空间值的vb2等价项。可能的值包括以下内容：'
- en: '– `VB2_MEMORY_MMAP`: Its equivalent that is assigned in user space is `V4L2_MEMORY_MMAP`,
    which indicates that the buffer is used for memory mapping I/O.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_MEMORY_MMAP`：其在用户空间分配的等价物是`V4L2_MEMORY_MMAP`，表示缓冲区用于内存映射I/O。'
- en: '– `VB2_MEMORY_USERPTR`: Its equivalent that is assigned in user space is `V4L2_MEMORY_USERPTR`,
    indicating that the user allocates buffers in the user space, and passes a pointer
    via the `buf.m.userptr` member of `v4l2_buffer`. The purpose of `USERPTR` in V4L2
    is to allow users to pass buffers allocated in user space directly by `malloc()`
    or statically.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_MEMORY_USERPTR`：其在用户空间分配的等价物是`V4L2_MEMORY_USERPTR`，表示用户在用户空间分配缓冲区，并通过`v4l2_buffer`的`buf.m.userptr`成员传递指针。V4L2中`USERPTR`的目的是允许用户直接通过`malloc()`或静态方式传递在用户空间分配的缓冲区。'
- en: – `VB2_MEMORY_DMABUF`. Its equivalent that is assigned in user space is `V4L2_MEMORY_DMABUF`,
    indicating that the memory is allocated by the driver and exported as a DMABUF
    file handler. This DMABUF file handler may be imported in another driver.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_MEMORY_DMABUF`。其在用户空间分配的等价物是`V4L2_MEMORY_DMABUF`，表示内存由驱动程序分配并导出为DMABUF文件处理程序。这个DMABUF文件处理程序可以在另一个驱动程序中导入。'
- en: '`state` is of the `enum vb2_buffer_state` type and represents the current state
    of this video buffer. Drivers can use the `void vb2_buffer_done(struct vb2_buffer
    *vb, enum vb2_buffer_state state)` API in order to change this state. Possible
    state values include the following:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`是`enum vb2_buffer_state`类型，表示此视频缓冲区的当前状态。驱动程序可以使用`void vb2_buffer_done(struct
    vb2_buffer *vb, enum vb2_buffer_state state)` API来更改此状态。可能的状态值包括以下内容：'
- en: – `VB2_BUF_STATE_DEQUEUED` means the buffer is under user space control. It
    is set by the videobuf2 core in the execution path of the `VIDIOC_REQBUFS` ioctl.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_BUF_STATE_DEQUEUED` 表示缓冲区在用户空间控制之下。这是由videobuf2核心在`VIDIOC_REQBUFS` ioctl的执行路径中设置的。'
- en: – `VB2_BUF_STATE_PREPARING` means the buffer is being prepared in videobuf2\.
    This flag is set by the videobuf2 core in the execution path of the `VIDIOC_PREPARE_BUF`
    ioctl for drivers supporting it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_BUF_STATE_PREPARING` 表示缓冲区正在videobuf2中准备。这个标志是由videobuf2核心在支持的驱动程序的`VIDIOC_PREPARE_BUF`
    ioctl的执行路径中设置的。'
- en: – `VB2_BUF_STATE_QUEUED` means the buffer is queued in videobuf, but not yet
    in the driver. This is set by the videobuf2 core in the execution path of the
    `VIDIOC_QBUF` ioctl. However, the driver must set the state of all buffers to
    `VB2_BUF_STATE_QUEUED` if it fails to start streaming. This is the equivalent
    of returning the buffer back to videobuf2.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_BUF_STATE_QUEUED` 表示缓冲区在videobuf中排队，但尚未在驱动程序中。这是由videobuf2核心在`VIDIOC_QBUF`
    ioctl的执行路径中设置的。然而，如果驱动程序无法启动流，则驱动程序必须将所有缓冲区的状态设置为`VB2_BUF_STATE_QUEUED`。这相当于将缓冲区返回给videobuf2。'
- en: – `VB2_BUF_STATE_ACTIVE` means the buffer is actually queued in the driver and
    possibly used in a hardware operation (DMA, for example). There is no need for
    the driver to set this flag as it is set by the core right before calling the
    buffer `.buf_queue` callback.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_BUF_STATE_ACTIVE` 表示缓冲区实际上在驱动程序中排队，并可能在硬件操作（例如DMA）中使用。驱动程序无需设置此标志，因为在调用缓冲区`.buf_queue`回调之前，核心会设置此标志。'
- en: – `VB2_BUF_STATE_DONE` means the driver should set this flag on the success
    path of the DMA operation on this buffer in order to pass the buffer to vb2\.
    This means to the videobuf2 core that the buffer is returned from the driver to
    videobuf, but is not yet dequeued to the user space.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_BUF_STATE_DONE` 表示驱动程序应在此缓冲区的DMA操作成功路径上设置此标志，以将缓冲区传递给vb2。这意味着videobuf2核心从驱动程序返回缓冲区，但尚未将其出队到用户空间。'
- en: – `VB2_BUF_STATE_ERROR` is the same as the above, but the operation on the buffer
    has ended with an error, which will be reported to the user space when it is dequeued.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_BUF_STATE_ERROR` 与上述相同，但是对缓冲区的操作以错误结束，当它被出队时将向用户空间报告。'
- en: If the concept of buffer skills appears complex to you after this, then I encourage
    you to first read [*Chapter 9*](B10985_09_ePub_AM.xhtml#_idTextAnchor396), *Leveraging
    V4L2 API from the User Space*, prior to coming back here.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在阅读完后，缓冲区技能的概念对您来说显得复杂，那么我鼓励您先阅读[*第9章*](B10985_09_ePub_AM.xhtml#_idTextAnchor396)，*从用户空间利用V4L2
    API*，然后再回到这里。
- en: The concept of planes
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 平面的概念
- en: There are devices that require data for each input or output video frame to
    be placed in discontiguous memory buffers. In such cases, one video frame has
    to be addressed using more than one memory address, in other words, one pointer
    per "plane." A plane is a sub-buffer of the current frame (or a chunk of the frame).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有些设备要求每个输入或输出视频帧的数据放在不连续的内存缓冲区中。在这种情况下，一个视频帧必须使用多个内存地址来寻址，换句话说，每个“平面”有一个指针。平面是当前帧的子缓冲区（或帧的一部分）。
- en: Thus, on a single-planar system, a plane represents a whole video frame, whereas
    it represents only a chunk of the video frame in a multi-planar system. Because
    memory is discontiguous, multi-planar devices use Scatter/Gather DMA.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在单平面系统中，一个平面代表整个视频帧，而在多平面系统中，一个平面只代表视频帧的一部分。由于内存是不连续的，多平面设备使用Scatter/Gather
    DMA。
- en: The concept of queue
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列的概念
- en: 'The queue is the central element of streaming and is the DMA engine-related
    part of the bridge driver. In fact, it is the element through which the driver
    introduces itself to videobuf2\. It helps us to implement the data flow management
    module in the driver. A queue is represented through the following structure:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The structure should be zeroed, and the preceding fields filled in. The following
    are the meanings of each element in the structure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '`type` is the buffer type. This should be set with one of the values present
    in `enum v4l2_buf_type`, defined in `include/uapi/linux/videodev2.h`. This must
    be `V4L2_BUF_TYPE_VIDEO_CAPTURE` in our case.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io_modes` is a bitmask describing what types of buffers can be handled. Possible
    values include the following:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '– `VB2_MMAP`: Buffers allocated within the kernel and accessed via `mmap()`;
    vmalloc''ed and contiguous DMA buffers will usually be of this type.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '– `VB2_USERPTR`: This is for buffers allocated in user space. Normally, only
    devices that can do Scatter/Gather I/O can deal with user space buffers. However,
    contiguous I/O to huge pages is not supported. Interestingly, videobuf2 supports
    contiguous buffers allocated by the user space. The only way to get those, though,
    is to use some sort of special mechanism, such as the out-of-tree Android `pmem`
    driver.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '– `VB2_READ, VB2_WRITE`: These are user space buffers provided via the `read()`
    and `write()` system calls.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '`lock` is the mutex for serialization locks for the streaming ioctls. It is
    common to set this lock with the same mutex as `video_device->lock`, which is
    the main serialization lock. However, if some of the non-streaming ioctls were
    to take a long time to execute, then you might want to have a different lock here
    to prevent `VIDIOC_DQBUF` from being blocked while waiting for another action
    to finish.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ops` represents the driver-specific callbacks to set up this queue and control
    streaming operations. It is of the `struct vb2_ops` type. We will examine this
    structure in detail in the next section.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `mem_ops` field is where the driver tells videobuf2 what kind of buffers
    it is actually using; it should be set to one of `vb2_vmalloc_memops`, `vb2_dma_contig_memops`,
    or `vb2_dma_sg_memops`. These are the three basic types of buffer allocation videobuf2
    implements:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: – The first one is the `vmalloc()` and is thus virtually contiguous in the kernel
    space and is not guaranteed to be physically contiguous.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: – The second one is the `vb2_mem_ops` in order to meet that need. There are
    no limits.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: You may not care about `buf_ops` as it is provided by the `vb2` core if not
    set. However, it contains callbacks to deliver buffer information between the
    user space and kernel space.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min_buffers_needed` is the minimum number of buffers needed before you can
    start streaming. If that is non-zero, then `vb2_queue->ops->start_streaming` won''t
    be called until at least that many buffers have been queued up by the user space.
    In other words, it represents the number of available buffers the DMA engine needs
    to have before it can be started.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bufs` is an array of pointers to buffers in this queue. Its maximum is `VB2_MAX_FRAME`,
    which corresponds to the maximum number of buffers allowed per queue by the `vb2`
    core. It is set to `32`, which is already a quite considerable value.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_buffers` is the number of allocated/used buffers in the queue.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driver-speciﬁc streaming callbacks
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A bridge driver needs to expose a collection of functions for managing buffer
    queues, including queue and buffer initialization. These functions will handle
    buffer allocation, queueing, and streaming-related requests coming from the user
    space. This can be done by setting up an instance of `struct vb2_ops`, defined
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following are the purpose of each callback in this structure:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '`queue_setup`: This callback function is called by the driver''s `v4l2_ioctl_ops.vidioc_reqbufs()`
    method (in response to `VIDIOC_REQBUFS` and `VIDIOC_CREATE_BUFS` ioctls) to adjust
    the buffer count and size. This callback''s goal is to inform videobuf2-core of
    how many buffers and planes per buffer it requires, as well as the size and allocator
    context for each plane. In other words, the chosen vb2 memory allocator calls
    this method for negotiating with the driver about the number of buffers and planes
    per buffer to be used during streaming. `3` is a good choice for the minimum number
    of buffers since most DMA engines need at least `2` buffers in the queue. The
    parameters of this callback are defined as follows:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: – `q` is the `vb2_queue` pointer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: – `num_buffers` is the pointer to the number of buffers requested by the application.
    The driver should then set the granted number of buffers allocated in this `*num_buffers`
    field. Since this callback can be called twice during the negotiation process,
    you should check `queue->num_buffers` to have an idea of the number of buffers
    already allocated prior to setting this.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: – `num_planes` contains the number of distinct video planes needed to hold a
    frame. This should be set by the driver.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: – `sizes` contains the size (in bytes) of each plane. For a single-planar system,
    only `size[0]` should be set.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: – `alloc_devs` is an optional per-plane allocator-specific device array. Consider
    it as a pointer to the allocation context.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the `queue_setup` callback:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`buf_init` is called once on a buffer after memory has been allocated for it,
    or after a new `USERPTR` buffer is queued. This can be used, for example, to pin
    pages, verify contiguity, and set up IOMMU mappings.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buf_prepare` is called on the execution path of the `VIDIOC_QBUF` ioctl. It
    should prepare the buffer for queueing to the DMA engine. The buffer is prepared
    and the user space virtual address or user address is converted into a physical
    address.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buf_finish` is called on each `DQBUF` ioctl. It can be used, for example,
    for cache syncing and copying back from bounce buffers.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buf_cleanup` is called before freeing/releasing memory. It can be used for
    unmapping memory and suchlike.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buf_queue`: The videobuf2 core sets the `VB2_BUF_STATE_ACTIVE` flag in the
    buffer right before invoking this callback. However, it is invoked on behalf of
    the `VIDIOC_QBUF` ioctl. The user space queues buffers one by one, one after the
    other. Moreover, buffers may be queued faster than the bridge device grabs data
    from the capture device to the buffer. In the meantime, `VIDIOC_QBUF` may be called
    several times before issuing `VIDIOC_DQBUF`. It is recommended for the driver
    to maintain a list of buffers queued for DMA, so that in the event of any DMA
    completion, the filled buffer is moved off the list, given to the `vb2` core at
    the same time by filling its timestamp and adding the buffer to the videobuf2''s
    done buffers list, and DMA pointers are updated if necessary. Roughly speaking,
    this callback function should add a buffer to the driver DMA queue and start DMA
    on that buffer. In the meantime, it is common for drivers to reimplement their
    own buffer data structure, built on top of the generic `vb2_v4l2_buffer` structure,
    but adding a list in order to address the queueing issue we just described. The
    following is an example of such a custom buffer data structure:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`start_streaming` starts the DMA engine for streaming. Prior to starting streaming,
    you must first check whether the minimum number of buffers have been queued. If
    not, you should return `-ENOBUFS` and the `vb2` framework will call this function
    again the next time a buffer has been queued until enough buffers are available
    to actually start the DMA engine. You should also enable streaming on the sub-devices
    if the following is supported: `v4l2_subdev_call(subdev, video, s_stream, 1)`.
    You should get the next frame from the buffer queue and start DMA on it. Typically,
    interrupts happen after a new frame has been captured. It is the job of the handler
    to remove the new frame from the internal buffers (using the `list_del()`) list
    and give it back to the `vb2` framework (by means of `vb2_buffer_done()`), updating
    the sequence counter field and timestamp at the same time.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop_streaming` stops all pending DMA operations, stops the DMA engine, and
    releases DMA channel resources.You should also disable streaming on the sub-devices
    if the following is supported: `v4l2_subdev_call(subdev, video, s_stream, 0)`.
    Disable interruptions if necessary. Since the driver maintains a list of buffers
    queued for DMA, all buffers queued in that list must be returned to vb2 in the
    ERROR state.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing and releasing the vb2 queue
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order for the driver to complete the queue initialization, it should call
    the `vb2_queue_init()` function, given the queue as an argument. However, the
    `vb2_queue` structure should first be allocated by the driver. Additionally, the
    driver must have cleared its content and set initial values for some requisite
    entries before calling this function. Those required values are `q->ops`, `q->mem_ops`,
    `q->type`, and `q->io_modes`. Otherwise, the queue initialization will fail, as
    shown in the following `vb2_core_queue_init()` function, which is invoked and
    whose return value is checked from within `vb2_queue_init()`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding excerpt shows the body of `vb2_core_queue_init()` in the kernel.
    This internal API is a pure basic initialization method that simply does some
    sanity checks and initializes basic data structures (lists, mutexes, and spinlocks).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The concept of sub-devices
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the early days of the V4L2 subsystem, there were just two main data structures:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '`struct video_device`: This is the structure through which `/dev/<type>X` appears.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct vb2_queue`: This is responsible for buffer management.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This was enough in an era when there were not that many IP blocks embedded with
    the video bridge. Nowadays, image blocks in SoCs embed so many IP blocks, each
    of which plays a specific role by offloading specific tasks, such as image resizing,
    image converting, and video deinterlacing functionalities. In order to use a modular
    approach for addressing this diversity, the concept of the sub-device has been
    introduced. This brings a modular approach to the software modeling of the hardware,
    allowing to abstract each hardware component as a software block.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, each IP block (except the bridge device) participating in
    the processing pipe is seen as a sub-device, even the camera sensor itself. Whereas
    the bridge video device node has the `/dev/videoX` pattern, sub-devices on their
    side use the `/dev/v4l-subdevX` pattern (assuming they have the appropriate flag
    set prior to having their nodes created).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'For a better understanding of the difference between the bridge device and
    the sub-devices, you can consider the bridge device as the final element in the
    processing pipeline, sometimes the one responsible for the DMA transactions. One
    example is the Atmel-`drivers/media/platform/atmel/atmel-isc.c`: `Sensor-->PFE-->WB-->CFA-->CC-->GAM-->CSC-->CBC-->SUB-->RLP-->DMA`.
    You are encouraged to have a look in this driver for the meaning of each element.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'From a coding point of view, the driver should include `<media/v4l-subdev.h>`,
    which defines the `struct v4l2_subdev` structure, which is the abstraction data
    structure used to instantiate a sub-device in the kernel. This structure is defined
    as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `entity` field of this structure will be discussed in the next chapter,
    [*Chapter 8*](B10985_08_ePub_AM.xhtml#_idTextAnchor342)*, Integrating with V4L2
    Async and Media Controller Frameworks*. In the meantime, there are fields of no
    interest to us that have been removed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the other fields in the structure are defined as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '`list` is of the `list_head` type, and is used by the core to insert the current
    sub-device in the list of sub-devices maintained by `v4l2_device` to which it
    belongs.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`owner` is set by the core and represents the module owning this structure.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` represents the sub-device flags that the driver can set and that can
    have the following values:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '– `V4L2_SUBDEV_FL_IS_I2C`: You should set this flag if this sub-device is actually
    an I2C device.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: – `V4L2_SUBDEV_FL_IS_SPI` should be set if this sub-device is an SPI device.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: – `V4L2_SUBDEV_FL_HAS_DEVNODE` should be set if the sub-device needs a device
    node (the famous `/dev/v4l-subdevX` entry). An API using this flag is `v4l2_device_register_subdev_nodes()`,
    which is discussed later and called by the bridge in order to create the sub-device
    node entries.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: – `V4L2_SUBDEV_FL_HAS_EVENTS` means this sub-device generates events.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '`v4l2_dev` is set by the core on the sub-device registration and is a pointer
    to the `struct 4l2_device` to which this sub-device belongs.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ops` is optional. This is a pointer to `struct v4l2_subdev_ops`, which represents
    a set of operations and which should be set by the driver to provide the callbacks
    the core can rely upon for this sub-device.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ctrl_handler` is a pointer to `struct v4l2_ctrl_handler`. It represents the
    list of controls provided by this sub-device, as we will see in the *V4L2 controls
    infrastructure* section.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` is a unique name for the sub-device. It should be set by the driver
    after the sub-device has been initialized. For the I2C variant''s initialization,
    the default name assigned by the core is `("%s %d-%04x", driver->name, i2c_adapter_id(client->adapter),
    client->addr)`. When including the support of **media controller**, this name
    is used as the media entity name.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grp_id` is driver-specific and provided by the core when in asynchronous mode,
    and is used to group similar sub-devices.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev_priv` is the pointer to the device''s private data, if any.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host_priv` is a pointer to private data used by the device where the sub-device
    is attached.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devnode` is the device node for this sub-device, set by the core upon a call
    to `v4l2_device_register_subdev_nodes()`, not to be confused with the bridge device
    built on top of the same structure. You should keep in mind that every `v4l2`
    element (be they sub-devices or bridges) is a video device.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev` is the pointer to the physical device, if any. The driver can set this
    value using `void` `v4l2_set_subdevdata(struct v4l2_subdev *sd, void *p)` or can
    get it using `void *v4l2_get_subdevdata(const struct v4l2_subdev *sd)`.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fwnode` is the firmware node object handle for this sub-device. In older kernel
    versions, this member used to be `struct device_node *of_node` and pointed to
    the `struct fwnode_handle`, as it allows switching to/from the device-tree node/acpi
    device according to which it is used on the platform. In other words, it is either
    `dev->of_node->fwnode` or `dev->fwnode`, whichever is non-`NULL`.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `async_list`, `asd`, `subdev_notifier`, and `notifier` elements are part
    of the v4l2-async framework, as we will see in the next section. However, brief
    descriptions of these elements are provided here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '`async_list`: When registered with the async core, this member is used by the
    core to link this sub-device to a global `subdev_list` (which is a list of orphan
    sub-devices that do not belong to any notifier, meaning this sub-device has been
    registered prior to its parent, the bridge) or to its parent bridge''s `notifier->done`
    list. We discuss this in detail later in the next chapter, [*Chapter 8*](B10985_08_ePub_AM.xhtml#_idTextAnchor342)*,
    Integrating with V4L2 Async and Media Controller Frameworks*.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asd`: This field is of the `struct v4l2_async_subdev` type and abstracts this
    sub-device in the async core.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subdev_notifier`: This is the notifier implicitly registered by this sub-device
    in case it needs to be notified of the probing of some other sub-devices. It is
    commonly used on systems where the streaming pipeline involves several sub-devices,
    where the sub-device N needs to be notified of the probing of the sub-device N-1.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notifier`: This is set by the async core and corresponds to the notifier with
    which its underlying `.asd` async sub-device is matched.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pdata`: This is a common part of the sub-device platform data.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sub-device initialization
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each sub-device driver must have a `struct v4l2_subdev` structure, either standalone
    or embedded in the larger and device-specific structure. The second case is recommended
    as it allows the device state to be tracked. The following is an example of a
    typical device-specific structure:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Prior to being accessed, a V4L2 sub-device need to be initialized using the
    `v4l2_subdev_init()` API. However, when it comes to sub-devices with an I2C- or
    SPI-based control interface (typically camera sensors), the kernel provides `v4l2_spi_subdev_init()`
    and `v4l2_i2c_subdev_init()` variants:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All of these APIs take a pointer to the `struct v4l2_subdev` structure as a
    first argument. Registering our sub-device using our device-specific data structure
    would then appear as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `spi`/`i2c` variants wrap the `v4l2_subdev_init()` function. Additionally,
    they require the underlying low-level, bus-specific structure as a second argument.
    Moreover, these bus-specific variants will store the sub-device object (given
    as the first argument) as low-level, bus-specific device data and vice versa by
    storing the low-level, bus-specific structure as the sub-device's private data.
    This way, `i2c_client` (or `spi_device`) and `v4l2_subdev` point to one another,
    meaning that by having a pointer to the I2C client, for example, you can call
    `i2c_set_clientdata()` (such as `struct v4l2_subdev *sd = i2c_get_clientdata(client);`)
    in order to grab the pointer to our internal sub-device object, and use the `container_of`
    macro (such as `struct mychip_struct *foo = container_of(sd, struct mychip_struct,
    sd);`) in order to grab the pointer to the chip-specific structure. On the other
    hand, having a pointer to the sub-device object, you can use `v4l2_get_subdevdata()`
    in order to grab the underlying bus-specific structure.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Least but not last, these bus-specific variants will mangle the sub-device
    name, as explained when introducing the `struct v4l2_subdev` data structure. An
    excerpt of `v4l2_i2c_subdev_init()` can provide a better understanding of this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In each of the preceding three initialization APIs, `ops` is the last argument
    and is a pointer to a `struct v4l2_subdev_ops` representing operations exposed/supported
    by the sub-device. However, let's discuss this in the next section.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Sub-device operations
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sub-devices are devices that are somehow connected to the main bridge device.
    In the whole media device, each IP (sub-device) has its set of functionalities.
    These functionalities have to be exposed to the core by means of callbacks well
    defined by kernel developers for commonly used functionalities. This is the purpose
    of `struct v4l2_subdev_ops`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'However, some sub-devices can perform so many different and unrelated things
    that even `struct v4l2_subdev_ops` has been split into small and categorized coherent
    sub-structure ops, each gathering related functionalities so that `struct v4l2_subdev_ops`
    becomes the top-level ops structure, described as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Important note
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Operations should only be provided for sub-devices exposed to the user space
    by an underlying char device file node. When registered, this device file node
    will have the same file operations as discussed earlier, that is, `v4l2_fops`.
    However, as we have seen earlier, these low-level ops only wrap (deal with) `video_device->fops`.
    Therefore, in order to reach `v4l2_subdev_ops`, the core uses `subdev->video_device->fops`
    as an intermediate and assigns it another file ops upon initialization (`subdev->vdev->fops
    = &v4l2_subdev_fops;`), which will wrap and call the real subdev ops. The call
    chain here is `v4l2_fops ==> v4l2_subdev_fops ==> our_custom_subdev_ops`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the preceding top-level ops structure is made of pointers
    to category ops structures, which are as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '`core` of the `v4l2_subdev_core_ops` type: This is the core ops category, providing
    generic callbacks, such as logging and debugging. It also allows the provision
    of additional and custom ioctls (especially useful if the ioctl does not fit in
    any category).'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`video` of the `v4l2_subdev_video_ops` type: `.s_stream` is called when streaming
    starts. It writes different configuration values to a camera''s registers based
    on the chosen frame size and format.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pad` of the `v4l2_subdev_pad_ops` type: For cameras that support multiple
    frame sizes and image sample formats, these operations allow users to choose from
    the available options.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tuner`, `audio`, `vbi`, and `ir` are beyond the scope of this book.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensor` of the `v4l2_subdev_sensor_ops` type: This covers camera sensor operations,
    typically for known buggy sensors that need some frames or lines to be skipped
    because they are corrupted.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each callback in each category structure corresponds to an ioctl. The routing
    is actually done at a low level by `subdev_do_ioctl()`, defined in `drivers/media/v4l2-
    core/v4l2-subdev.c`, and which is indirectly called by `subdev_ioctl()`, which
    corresponds to `v4l2_subdev_fops.unlocked_ioctl`. The real call chain should be
    `v4l2_fops ==> v4l2_subdev_fops.unlocked_ioctl ==> our_custom_subdev_ops`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The nature of this top-level `struct v4l2_subdev_ops` structure just confirms
    how wide the range of devices is that may be supported by V4L2\. Ops categories
    that are of no interest to the sub-device driver can be left `NULL`. Do also note
    that the `.core` ops are common to all sub-devs. This does not mean it is mandatory;
    it merely means that any sub-device driver of whatever category is free to implement
    the `.core` ops as its callbacks are category-independent.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: struct v4l2_subdev_core_ops
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This structure implements generic callbacks and has the following definition:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding structure, fields of no interest to us have been removed.
    Those remaining are defined as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '`.log_status` is for logging purposes. You should use the `v4l2_info()` macro
    for this.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.s_power` puts the sub-device (the camera, for example) in power-saving mode
    (`on==0`) or normal operation mode (`on==1`).'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.load_fw` operation has to be called to load the sub-device's firmware.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.ioctl` should be defined if the sub-device provides extra ioctl commands.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.g_register` and `.s_register` are to be used for advanced debugging only
    and require the kernel config option `CONFIG_VIDEO_ADV_DEBUG` to be set. These
    operations allow the reading and writing of hardware registers in response to
    the `VIDIOC_DBG_G_REGISTER` and `VIDIOC_DBG_S_REGISTER` ioctls. The `reg` parameters
    (of the type `v4l2_dbg_register`, defined in `include/uapi/linux/videodev2.h`)
    are filled and given by the application.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.interrupt_service_routine` is called by the bridge from within its IRQ handler
    (it should use `v4l2_subdev_call` for this) when an interrupt status has been
    raised due to this sub-device, in order for the sub-device to handle the details.
    `handled` is an output parameter provided by the bridge driver, but has to be
    filled by the sub-device driver in order to inform (as *true or false*) on the
    result of its processing. We are in the IRQ context, so must not sleep. Sub-devices
    behind I2C/SPI buses should probably schedule their work in a threaded context.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.subscribe_event` and `.unsubscribe_event` are used to subscribe or unsubscribe
    to control change events. Please have a look at other V4L2 drivers implementing
    this to see how to implement yours.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: struct v4l2_subdev_video_ops or struct v4l2_subdev_pad_ops
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: People often need to decide whether to implement `struct v4l2_subdev_video_ops`
    or `struct v4l2_subdev_pad_ops`, because some of the callbacks are redundant in
    both of these structures. The thing is, the callbacks of the `struct v4l2_subdev_video_ops`
    structure are used when the V4L2 device was opened in video mode, which includes
    TVs, camera sensors, and framebuffer. So far, so good. The concept of `struct
    v4l2_subdev_pad_ops` is not needed either. However, the media controller framework
    abstracts the sub-device by means of an entity object (we will see this later),
    which connects to other elements via PAD. In this case, it makes sense to use
    PAD-related functionalities instead of sub-device-related ones, hence, using `struct
    v4l2_subdev_pad_ops` instead of `struct v4l2_subdev_video_ops`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have not introduced the media framework yet, we are only interested
    in the `struct v4l2_subdev_video_ops` structure, which is defined as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding excerpt, for the sake of readability, I removed the TV and
    video output-related callbacks as well as those not related to camera devices,
    which are also somehow useless for us. For the commonly used ones, they are defined
    as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '`querystd`: This is the callback for the `VIDIOC_QUERYSTD()` ioctl handler
    code.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_stream`: This is used to notify the driver that a video stream will start
    or has stopped, depending on the value of the `enable` parameter.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g_frame_interval`: This is the callback for the `VIDIOC_SUBDEV_G_FRAME_INTERVAL()`
    ioctl handler code.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_frame_interval`: This is the callback for the `VIDIOC_SUBDEV_S_FRAME_INTERVAL()`
    ioctl handler code.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: struct v4l2_subdev_sensor_ops
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are sensors that produce initial garbage frames when they start streaming.
    Such sensors possibly require some time in order to ensure the stability of some
    of their properties. This structure makes it possible to inform the core of the
    number of frames to skip in order to avoid garbage. Moreover, some sensors may
    always produce images with a certain number of corrupted lines at the top, or
    embed their metadata in these lines. In both cases, the resulting frames they
    produce are always corrupted. This structure also allows us to specify the number
    of lines to skip on each frame before it is grabbed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the definition of the `v4l2_subdev_sensor_ops` structure:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`g_skip_top_lines` is used to specify the number of lines to skip in each image
    of the sensors, while `g_skip_frames` allows us to specify the initial number
    of frames to skip in order to avoid garbage, as in the following example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `lines` and `frames` parameters are output parameters. Each callback should
    return `0`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Calling sub-device operations
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After all, if `subdev` callbacks are provided, then they are intended to be
    called. That said, invoking an ops callback is as simple as calling it directly,
    as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, there is a more convenient and safer way to achieve this, by using
    the `v4l2_subdev_call()` macro:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The macro, defined in `include/media/v4l2-subdev.h`, will perform the following
    actions:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: It will first check whether the sub-device is `NULL` and return `-ENODEV` otherwise.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will return `-ENOIOCTLCMD` if either the category (`subdev->video` in our
    example) or the callback itself (`subdev->video->s_stream` in our example) is
    `NULL`, or it will return the actual result of the `subdev->ops->video->s_stream`
    ops.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also possible to call all, or a subset, of the sub-devices:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Any sub-device that does not support this callback is skipped and error results
    are ignored. If you want to check for errors, use the following command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Any error except `-ENOIOCTLCMD` will exit the loop with that error. If no errors
    (except `- ENOIOCTLCMD`) occurred, then `0` is returned.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Traditional sub-device (un)registration
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways for a sub-device to be registered with the bridge, depending
    on the nature of the media device:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous mode**: This is the traditional method. In this mode, the bridge
    driver has the responsibility of registering sub-devices. The sub-device driver
    is either implemented from within the bridge driver or you have to find a way
    for the bridge driver to grab the handles of sub-devices it is responsible for.
    This is usually achieved by means of platform data, or by the bridge driver exposing
    a set of APIs that will be used by the sub-device drivers, which would allow the
    bridge driver to be aware of these sub-devices (by tracking them in a private
    internal list, for example).With this method, the bridge driver must be aware
    of the sub-devices connected to it, and know exactly when to register them. This
    is typically the case for internal sub-devices, such as video data processing
    units within SoCs or complex PCI(e) boards, or camera sensors in USB cameras or
    connected to SoCs.'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Asynchronous mode**: This is where information about sub-devices is made
    available to the system independently of the bridge devices, which is typically
    the case on devicetree-based systems. This will be discussed in the next chapter,
    [*Chapter 8*](B10985_08_ePub_AM.xhtml#_idTextAnchor342), *Integrating with V4L2
    Async and Media Controller Frameworks*.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'However, in order for a bridge driver to register a sub-device, it has to call
    `v4l2_device_register_subdev()`, while it has to call `v4l2_device_unregister_subdev()`
    to unregister this sub-device. In the meantime, after registering sub-devices
    with the core, it might be necessary to create their respective char file nodes,
    `/dev/v4l-subdevX`, only for sub-devices with the flag `V4L2_SUBDEV_FL_HAS_DEVNODE`
    set. You can use `v4l2_device_register_subdev_nodes()` to this end:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`v4l2_device_register_subdev()` will insert `sd` into `v4l2_dev->subdevs`,
    which is the list of sub-devices maintained by this V4L2 device. This can fail
    if the `subdev` module disappeared before it could be registered. After this function
    has been called successfully, the `subdev->v4l2_dev` field points to the `v4l2_device`.
    This function returns `0` in the event of success or `v4l2_device_unregister_subdev()`
    will take `sd` off that list. Then, `v4l2_device_register_subdev_nodes()` walks
    through `v4l2_dev->subdevs` and creates a special char file node (`/dev/v4l-subdevX`)
    for each sub-device with the flag `V4L2_SUBDEV_FL_HAS_DEVNODE` set.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The `/dev/v4l-subdevX` device nodes allow direct control of the advanced and
    hardware-specific features of sub-devices.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about sub-device initialization, operations, and registration,
    let's look at V4L2 controls in the next section.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: V4L2 controls infrastructure
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some devices have controls that are settable by the user in order to modify
    some defined properties. Some of these controls may support a list of predefined
    values, a default value, an adjustment, and so on. The thing is, different devices
    may provide different controls with different values. Moreover, while some of
    these controls are standard, others may be vendor-specific. The main purpose of
    the control framework is to present controls to the user without assumptions relating
    to their purpose. In this section, we only address standard controls.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The control framework relies on two main objects, both defined in `include/media/v4l2-
    ctrls.h`, like the rest of the data structures and APIs provided by this framework.
    The first is `struct v4l2_ctrl`. This structure describes the control properties
    and keeps track of the control''s value. The second and final one is `struct v4l2_ctrl_handler`,
    which keeps track of all the controls. Their detailed definitions are presented
    here:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding definition excerpt of `struct v4l2_ctrl_handler`, `ctrls`
    represents the list of controls owned by this handler. `notify` is a notify callback
    that is called whenever the control changes value. This callback is invoked with
    the handler''s `lock` held. At the end, `notify_priv` is the context data given
    as the argument to notify. The next one is `struct v4l2_ctrl`, defined as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This structure represents the control on its own, with important members present.
    These are defined as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '`node` is used to insert the control in the handler''s control list.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler` is the handler to which this control belongs.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ops` is of the `struct v4l2_ctrl_ops` type and represents the get/set operations
    for this control.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id` is the ID of this control.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` is the name of the control.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minimum` and `maximum` are the minimum and maximum values accepted by the
    control, respectively.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default_value` is the default value of the control.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step` is the incrementation/decrementation step for this non-menu control.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` covers the control''s flags. While the whole flag list is defined in
    `include/uapi/linux/videodev2.h`, some of the commonly used ones are as follows:'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: – `V4L2_CTRL_FLAG_DISABLED`, which means the control is disabled
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: – `V4L2_CTRL_FLAG_READ_ONLY`, for a read-only control
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: – `V4L2_CTRL_FLAG_WRITE_ONLY`, for a write-only control
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: – `V4L2_CTRL_FLAG_VOLATILE`, for a volatile control
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '`is_private`, if set, will prevent this control from being added to any other
    handlers. It makes this control private to the initial handler where it is added.
    This can be used to prevent making a `subdev` control available in the V4L2 driver
    controls.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '`enum` usually) like a kind of menu, hence the name *menu control*.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'V4L2 controls are identified by a unique ID. They are prefixed with `V4L2_CID_`
    and are all available in `include/uapi/linux/v4l2-controls.h`. The common standard
    controls supported in video capture devices are as follows (the following list
    is non-exhaustive):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding list includes standard controls only. To support a custom control,
    you should add its ID based on the control''s base class descriptor and make sure
    that the ID is not a duplication. To add control support to the driver, the control
    handler should first be initialized using the `v4l2_ctrl_handler_init()` macro.
    This macro accepts the handler to be initialized as well as the number of controls
    this handler can refer to, as shown in its following prototype:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once finished with the control handler, you can call `v4l2_ctrl_handler_free()`
    on this control handler in order to release its resources. Once the control handler
    is initialized, controls can be created and added to it. When it comes to standard
    V4L2 controls, you can use `v4l2_ctrl_new_std()` in order to allocate and initialize
    the new control:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This function will, in most fields, be based on the control ID. For custom
    controls, however (not discussed here), you should use the `v4l2_ctrl_new_custom()`
    helper instead. In the preceding prototype, the following elements are defined
    as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '`hdl` represents the control handler initialized previously.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ops` is of the `struct v4l2_ctrl_ops` type and represents the control ops.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id` is the control ID, defined as `V4L2_CID_*`.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min` is the minimum value this control can accept. Depending on the control
    ID, this value can be mangled by the core.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` is the maximum value this control can accept. Depending on the control
    ID, this value can be mangled by the core.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step` is the control''s step value.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def` is the control''s default value.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controls are meant to be set/get. This is the purpose of the preceding ops argument.
    This means that prior to initializing a control, you should first define the ops
    that will be called when setting/getting this control's value. That said, the
    whole control list can be addressed by the same ops. In this case, the ops callback
    will have to `switch ... case` to handle different controls.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen earlier, control operations are of the `struct v4l2_ctrl_ops`
    type and are defined as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding structure is made of three callbacks, each with a specific purpose:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '`g_volatile_ctrl` gets the new value for the given control. Providing this
    callback only makes sense for volatile (those changed by the hardware itself,
    and that are read-only most of the time, such as the signal strength or autogain,
    for example) controls.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`try_ctrl`, if set, is invoked to test whether the control''s value to be applied
    is valid. Providing this callback only makes sense if the usual min/max/step checks
    are insufficient.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_ctrl` is invoked to set the control''s value.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optionally, you can call `v4l2_ctrl_handler_setup()` on the control handler
    in order to set up this handler''s controls to their default values. This helps
    to ensure that the hardware and the driver''s internal data structures are in
    sync:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This function iterates over all the controls in the given handler and calls
    the `s_ctrl` callback with each control's default value.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: To summarize what we have seen throughout this V4L2 control interface section,
    let's now study in more detail an excerpt of the `OV7740` camera sensor's driver
    (present in `drivers/media/i2c/ov7740.c`), especially the part dealing with V4L2
    controls.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the implementation of the control `ops->sg_ctrl` callback:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding callback only addresses the control ID of `V4L2_CID_AUTOGAIN`.
    It makes sense as the gain value may be changed by the hardware while in *auto*
    mode. This driver implements the `ops->s_ctrl` control as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding code block also shows how easy it is to implement a menu control
    using the `V4L2_CID_EXPOSURE_AUTO` control as an example and whose possible values
    are enumerated in `enum v4l2_exposure_auto_type`. Finally, the control ops structure
    that will be given for control creation is defined as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once defined, this control op can be used to initialize controls. The following
    is the `ov7740_init_controls()` method (invoked in the `probe()` function) excerpt,
    mangled and shrunk for the purposes of readability:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can see the control handler being assigned to the sub-device at the return
    path of the preceding function. Finally, somewhere in the code (the ov7740''s
    driver does this from within the sub-device''s `v4l2_subdev_video_ops.s_stream`
    callback), you should set all controls to their default values:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There is more on V4L2 controls at [https://www.kernel.org/doc/html/v4.19/media/kapi/v4l2-controls.html](https://www.kernel.org/doc/html/v4.19/media/kapi/v4l2-controls.html).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: A word about control inheritance
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common for sub-device drivers to implement controls already implemented
    by the bridge's V4L2 driver.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: When `v4l2_device_register_subdev()` is invoked on `v4l2_subdev` and `v4l2_device`
    and the `ctrl_handler` fields of both are set, then the sub-device's controls
    will be added (by means of the `v4l2_ctrl_add_handler()` helper, which adds a
    given handler's control to another handler) to the `v4l2_device` controls. Sub-device
    controls that are already implemented by `v4l2_device` will be skipped. This means
    that a V4L2 driver can always override a `subdev` control.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: That said, a control may perform low-level, hardware-specific operations on
    a given sub-device and the sub-device driver may not want this control to be available
    to the V4L2 driver (and so is not added to its control handler). In this case,
    the sub-device driver has to set the `is_private` member of the control to `1`
    (or `true`). This will make the control private to the sub-device.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Even though sub-device controls are added to the V4L2 device, they remain accessible
    through the control device node.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dealt with V4L2 bridge device driver development, as well
    as the concept of sub-devices. We learned about the V4L2 architecture and are
    now familiar with its data structures. We studied the videobuf2 API and are now
    able to write platform bridge device drivers. Moreover, we should be able to implement
    sub-device operations, and to leverage the videobuf2 core.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: This chapter can be regarded as the first part of a big picture, since the next
    chapter still addresses V4L2, but we will deal with the async core and integration
    with the media controller frameworks.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
