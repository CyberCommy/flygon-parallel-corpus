- en: '*Chapter 15*: Testing Classes and Components'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue our pursuit for increasing your C++ programming repertoire
    beyond OOP concepts through exploring means to test the classes and components
    that comprise our OO programs. We will explore various strategies to help ensure
    that the code we write will be well-tested and robust.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter shows how to test your OO programs through testing individual classes,
    as well as testing the various components that work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding canonical class form; creating robust classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating drivers to test classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing classes related by inheritance, association, or aggregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing exception handling mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have various techniques in your programming
    arsenal to ensure that your code is well-tested before it goes into production.
    Having the skills to consistently produce robust code will help you become a more
    beneficial programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's increase our C++ skills set by examining various techniques for OO testing.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The online code for the full program examples can be found at the following
    GitHub URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter15` in a file named `Chp15-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/314TI8h](https://bit.ly/314TI8h).'
  prefs: []
  type: TYPE_NORMAL
- en: Contemplating OO testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software testing is immensely important prior to any code deployment. Testing
    object-oriented software will require different techniques than other types of
    software. Because OO software contains relationships between classes, we must
    understand how to test dependencies and relationships that may exist between classes.
    Additionally, each object may progress through different states based upon the
    order that operations are applied to each instance, as well as through specific
    interactions with related objects (for example, via association). The overall
    flow of control through an OO application is much more complex than with procedural
    applications because the combinations and order of operations applied to a given
    object and influences from associated objects are numerous.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, there are metrics and processes we can apply to test OO software.
    These range from understanding idioms and patterns we can apply for class specification,
    to creating drivers to test classes both independently and as they relate to other
    classes. These processes can further include creating scenarios to provide likely
    sequences of events or states that objects may progress through. Relationships
    between objects, such as inheritance, association, and aggregation, become very
    important in testing; related objects can influence the state of an existing object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin our quest in testing OO software by understanding a simple pattern
    that we can often apply to classes we develop. This idiom will ensure that a class
    is potentially complete, with no unexpected behavior. We will start with canonical
    class form.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding canonical class form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many classes in C++, it is reasonable to follow a pattern for class specification
    to ensure that a new class contains a full set of desired components. **Canonical
    class form** is a robust specification of a class that enables class instances
    to provide uniform behavior (analogous to standard data types) in areas such as
    initialization, assignment, argument passing, and usage in return values from
    functions. Canonical class form will apply to most classes that are either intended
    for instantiation or that will serve as public base classes for new derived classes.
    Classes that are intended to serve as private or protected base classes (even
    if they may be instantiated themselves) may not follow all parts of this idiom.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class following **orthodox** canonical form will include:'
  prefs: []
  type: TYPE_NORMAL
- en: A default constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A copy constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overloaded assignment operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A virtual destructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A class following **extended** canonical form will additionally include:'
  prefs: []
  type: TYPE_NORMAL
- en: A *move* copy constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *move* assignment operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each component of canonical class form in the next subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Default constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **default constructor** is necessary for simple instantiation. Though a default
    (empty) constructor will be provided if a class contains no constructors, it is
    important to recall that a default constructor will not be provided if a class
    contains constructors with other signatures. It is best to provide a default constructor
    with reasonable, basic initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, a default constructor for a given class' base class will be called
    in the absence of an alternate base class constructor specification in the member
    initialization list. If a base class has no such default constructor (and one
    hasn't been provided because a constructor with another signature exists), the
    implicit call to the base class constructor will be flagged as an error.
  prefs: []
  type: TYPE_NORMAL
- en: Let's also consider multiple inheritance situations in which a diamond-shaped
    hierarchy occurs, and virtual base classes are used to eliminate duplication of
    most base class sub-objects within instances of the most derived class. In this
    scenario, the default constructor for the now *shared* base class sub-object is
    called unless otherwise specified in the member initialization list of the derived
    class responsible for creating the diamond shape. This occurs even if non-default
    constructors are specified in the member initialization list at the middle level;
    remember these specifications are ignored when the mid-levels specify a potentially
    shared virtual base class.
  prefs: []
  type: TYPE_NORMAL
- en: Copy constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **copy constructor** is crucial for all objects containing pointer data members.
    Unless a copy constructor is supplied by the programmer, a system-supplied copy
    constructor will be linked in when necessary in the application. The system-supplied
    copy constructor performs a member-wise (shallow) copy of all data members. This
    means that multiple instances of a class may contain pointers to *shared* pieces
    of memory representing the data that should have been individualized. Also, remember
    to use the member initialization list in a derived class copy constructor to specify
    the base class' copy constructor to copy the base class data members. Certainly,
    copying the base class sub-object in a deep fashion is crucial; additionally,
    the base class data members are inevitably private so selecting the base class
    copy constructor in the derived class' member initialization list is very important.
  prefs: []
  type: TYPE_NORMAL
- en: By specifying a copy constructor, we also help provide an expected manner for
    the creation of objects passed (or returned) by value from a function. Ensuring
    deep copies in these scenarios is crucial. The user may think these copies are
    *by value*, yet if their pointer data members are actually shared with the source
    instance, it's not truly passing (or returning) an object by value.
  prefs: []
  type: TYPE_NORMAL
- en: Overloaded assignment operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **overloaded assignment operator**, much like the copy constructor, is also
    crucial for all objects containing pointer data members. The default behavior
    for the system-supplied assignment operator is a shallow assignment of data from
    source to destination object. Again, when data members are pointers, it is highly
    recommended that the assignment operator should be overloaded to allocate space
    for any such pointer data members.
  prefs: []
  type: TYPE_NORMAL
- en: Also, remember that an overloaded assignment operator is not *inherited*; each
    class is responsible for writing its own version. This makes sense, as the derived
    class inevitably has more data members to copy than the assignment operator in
    its base class. However, when overloading an assignment operator in a derived
    class, remember to call the base class' assignment operator to perform a deep
    assignment of inherited base class members (which may be private and otherwise
    inaccessible).
  prefs: []
  type: TYPE_NORMAL
- en: Virtual destructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **virtual destructor** is required when using public inheritance. Often, derived
    class instances are collected in a group and generalized by a set of base class
    pointers. Recall, upcasting in this fashion is only possible to public base classes
    (not to protected or private base classes). When pointers to objects are generalized
    in this fashion, a virtual destructor is crucial to allow the correct starting
    point in the destructor sequence to be determined through dynamic (that is, runtime)
    binding versus static binding. Recall, static binding would choose the starting
    destructor based on the pointer's type, not what type the object actually is.
    A good rule of thumb is if a class has one or more virtual functions, be sure
    to ensure that you also have a virtual destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Move copy constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `this`. We then must null the source object's pointers to those data members
    so that both instances do not *share* the dynamically allocated data members.
    We have, in essence, moved (the memory for) the pointer data members.
  prefs: []
  type: TYPE_NORMAL
- en: What about the non-pointer data members? The memory for these data members will
    be copied as usual. The memory for the non-pointer data members and the memory
    for the pointers themselves (not the memory pointed to by those pointers) still
    resides in the source instance. As such, the best we can do is designate a null
    value for the source object's pointers and place a `0` (or similar) value in the
    non-pointer data members to indicate that these members are no longer relevant.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `move()` function, found in the C++ Standard Library, to indicate
    a move copy constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, with classes related by inheritance, we will also use `move()`
    in the member initialization list of the derived class constructor. This will
    specify the base class move copy constructor to help initialize the sub-object.
  prefs: []
  type: TYPE_NORMAL
- en: Move assignment operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **move assignment operator** is much like an overloaded assignment operator,
    however, the goal is to again conserve memory by *moving* the dynamically allocated
    data of the source object to the destination object (versus performing a deep
    assignment). As with the overloaded assignment operator, we will test for self-assignment
    and then delete any previously dynamically allocated data members from the (pre-existing)
    destination object. However, we will then simply copy the pointer data members
    from the source object to those in the destination object. We will also null out
    the pointers in the source object so that the two instances do not share these
    dynamically allocated data members.
  prefs: []
  type: TYPE_NORMAL
- en: Also, much like the move copy constructor, non-pointer data members will be
    simply copied from source to destination object and replaced with a `0` value
    in the source object to indicate non-usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will again use the `move()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, with classes related by inheritance, we can again specify that
    the move assignment operator of the derived class will call the base class move
    assignment operator to help complete the task.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the components of canonical class form together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see an example of a pair of classes that embrace canonical class form.
    We will start with our `Person` class. This example can be found as a complete
    program in our GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15/Chp15-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15/Chp15-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous class definition, we notice that `Person` contains a default
    constructor, copy constructor, overloaded assignment operator, and virtual destructor.
    Here, we have embraced orthodox canonical class form as a pattern applicable for
    a class that might one day serve as a public base class. Also notice that we have
    added the prototypes for the move copy constructor and move assignment operator
    to additionally embrace the extended canonical class form.
  prefs: []
  type: TYPE_NORMAL
- en: The prototypes of the move copy constructor `Person(Person &&);` and the move
    assignment operator `Person &operator=(Person &&);` contain parameters of type
    `Person &&`. These are examples of `Person &`, will bind to the original copy
    constructor and overloaded assignment operator, whereas r-value reference parameters
    will bind to the applicable move methods instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the definitions for the methods contributing to the extended
    canonical class form – the move copy constructor and the move assignment operator
    for `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in the preceding move copy constructor, we overtake the source object's
    dynamically allocated memory by using simple pointer assignments (versus memory
    allocation such as we would employ in a deep copy constructor). We then place
    a null value in the source object's pointer data members. For non-pointer data
    members, we simply copy the values from source to destination object and place
    a zeroed value (such as `'\0'` for `p.middleInitial`) in the source object to
    indicate its further non-use.
  prefs: []
  type: TYPE_NORMAL
- en: In the move assignment operator, we check for self-assignment and then employ
    the same scheme to merely move the dynamically allocated memory from the source
    object to the destination object with a simple pointer assignment. We copy simple
    data members as well, and of course replace source object data values with either
    null pointers or zeroed values to indicate further non-use. The return value of
    `*this` allows for cascaded assignments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how a derived class, `Student`, employs both orthodox and extended
    canonical class form while utilizing its base class components to aid in the implementation
    of selected idiom methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding class definition, we again see that `Student` contains a default
    constructor, a copy constructor, an overloaded assignment operator, and a virtual
    destructor to complete the orthodox canonical class form.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, however, in the `Student` copy constructor, we specify the use of the
    `Person` copy constructor through the member initialization list. Similarly, in
    the `Student` overloaded assignment operator, once we check for self-assignment,
    we call the overloaded assignment operator in `Person` to help us complete the
    task using `Person::operator=(s);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the method definitions contributing to the extended canonical
    class form of `Student` – the move copy constructor and the move assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in the previously listed `Student` move copy constructor, we specify
    utilization of the base class move copy constructor in the member initialization
    list. The remainder of the `Student` move copy constructor is similar to that
    found in the `Person` base class.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, let's notice, in the `Student` move assignment operator, the call
    to the base class move `operator=` with `Person::operator=(move(s);`. The remainder
    of this method is similar to that found in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: A good rule of thumb is that most non-trivial classes should minimally utilize
    orthodox canonical class form. Of course, there are exceptions. For example, a
    class that will only serve as a protected or private base class need not have
    a virtual destructor because derived class instances cannot be upcast past a non-public
    inheritance boundary. Similarly, if we have a good reason to not want copies or
    to disallow assignment, we can prohibit copies or assignment using the `= delete`
    specification in the extended signature of either of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, canonical class form will add robustness to classes that embrace
    this idiom. The uniformity among classes utilizing this idiom with respect to
    their implementation of initialization, assignment, and argument passing will
    be valued by programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move forward to take a look at a complementary idea to canonical class
    form, that of robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring a class is robust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important feature of C++ is the ability to build libraries of classes for
    widespread reuse. Whether we wish to achieve this goal, or simply wish to provide
    reliable code for our own organization's use, it is important that our code is
    robust. A **robust class** will be well-tested, should follow canonical class
    form (except for requiring a virtual destructor in protected and private base
    classes), and be portable (or included in a platform-specific library). Any class
    that is a candidate for reuse, or that is to be used in any professional capacity,
    absolutely must be robust.
  prefs: []
  type: TYPE_NORMAL
- en: A robust class must ensure that all instances of a given class are fully constructed.
    A **fully constructed object** is one in which all data members are appropriately
    initialized. All constructors for a given class (including copy constructors)
    must be verified to initialize all data members. The values with which data members
    are loaded should be checked for range suitability. Remember, an un-initialized
    data member is a potential disaster! Precautions should be made in the event that
    a given constructor does not complete properly or if the initial values of data
    members are inappropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Fully constructed objects may be validated using a variety of techniques. A
    rudimentary technique is to embed a status data member into each class (or derive
    or embed a status ancestor/member). Set the status member to `0` in the member
    initialization list and to `1` as the last line of the constructor. Probe this
    value after instantiation. The huge downfall of this approach is that users will
    certainly forget to probe the *fully constructed* success flag.
  prefs: []
  type: TYPE_NORMAL
- en: A much better technique is to utilize exception handling. Embedding exception
    handling inside each constructor is ideal. If data members are not initialized
    within a suitable range, first try to re-enter their values, or open an alternate
    database for input, for example. As a last resort, you can throw an exception
    to report the *not fully constructed object*. We will more closely examine exception
    handling with respect to testing later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, let us move forward with a technique to rigorously test our classes
    and components – creating drivers to test classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating drivers to test classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199), *Exploring
    Classes in Detail*, we briefly talked about breaking our code into source and
    header files. Let us briefly recap. Typically, the header file will be named after
    the class (such as `Student.h`) and will contain the class definition, plus any
    inline member function definitions. By placing inline functions in a header file,
    they will be properly re-expanded should their implementations change (as the
    header is subsequently included in each source file, creating a dependency with
    that header).
  prefs: []
  type: TYPE_NORMAL
- en: The implementation for the methods of each class will be placed in a corresponding
    source code file (such as `Student.cpp`), which will include the header on which
    it is based (that is, `#include "Student.h"`). Note that the double quotes imply
    that this header is in our current working directory; we could also specify a
    path as to where to find the header. By comparison, the angle brackets used with
    C++ libraries tell the preprocessor to look in pre-designated directories by the
    compiler. Also, note that each derived class header file will include the header
    file for its base class (so that it may see member function prototypes).
  prefs: []
  type: TYPE_NORMAL
- en: With this header and source code file structure in mind, we can now create a
    driver to test each individual class or each grouping of closely related classes
    (such as those related through association or aggregation). Classes related through
    inheritance can be tested in their own, individual driver files. Each driver file
    can be named to reflect the class that is being tested, such as `StudentDriver.cpp`.
    The driver file will include the relevant header files for the class(es) being
    tested. Of course, the source files from the classes in question would be compiled
    and linked to the driver file as part of the compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: The driver file can simply contain a `main()` function as a testbed to instantiate
    the class(es) in question and serve as a scope to test each member function. The
    driver will test default instantiation, typical instantiation, copy construction,
    assignment between objects, and each of the additional methods in the class(es).
    Should virtual destructors or other virtual functions exist, we should instantiate
    derived class instances (in the derived class' driver), upcasting these instances
    to be stored using base class pointers, and then invoke the virtual functions
    to verify that the correct behaviors occur. In the case of a virtual destructor,
    we can trace which destructor is the entry point in the destruction sequence by
    deleting a dynamically allocated instance (or waiting for a stack instance to
    go out of scope) and single-stepping through our debugger to verify all is as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: We can also test that objects are fully constructed; we will see more on this
    topic shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we have our usual `Person` and `Student` class hierarchy, here is
    a simple driver to test the `Student` class. This driver can be found in our GitHub
    repository. To make a complete program, you will also need to compile and link
    together the `Student.cpp` and `Person.cpp` files found in this same directory.
    Here is the GitHub URL for the driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15/Chp15-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15/Chp15-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Briefly reviewing the preceding program fragment, we can see that we have tested
    each means for instantiation, including the copy constructor. We've also tested
    the assignment operator, verified each member function works (an example method
    is shown), and verified that the virtual functions (including virtual destructor)
    work as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen a basic driver test our classes, let's consider some additional
    metrics we can use when testing classes related via inheritance, association,
    or aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing related classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With OO programs, it is not sufficient to simply test an individual class for
    completeness and robustness, though these are good starting points. Completeness
    entails not only following canonical class form but also ensuring that data members
    have a safe means for access using appropriate access methods (labeled as `const`
    when not modifying the instance). Completeness also verifies that the required
    interface as specified by the OO design has been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Robustness leads us to verify that all of the aforementioned methods had been
    tested within an appropriate driver, evaluated for platform independence, and
    verified that each means for instantiation leads to a fully constructed object.
    We can augment this type of testing with threshold testing of data members for
    instances, noting when exceptions are thrown. Completeness and robustness, though
    seemingly comprehensive, are actually the most straightforward means for OO component
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: A more challenging means for testing is to test the interaction between related
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Testing classes related through inheritance, association, or aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes related through various object relationships require various additional
    means for component testing. Objects with various relationships with one another
    can impact the state progression a given instance may have during its life expectancy
    within the application. This type of testing will require the most detailed effort.
    We will find that scenarios will be useful to help us capture the usual interactions
    between related objects, leading to more comprehensive ways to test classes that
    interact with one another.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by considering how we can test classes related by inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Adding strategies to test inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes related through public inheritance need to have virtual functions verified.
    For example, have all intended derived class methods been overridden? Remember,
    a derived class does not need to override all virtual functions specified in its
    base class if base class behaviors are still deemed appropriate at the derived
    class level. It will be necessary to compare the implementation to the design
    to ensure that we have overridden all required polymorphic operations with suitable
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, the binding of virtual functions is done at runtime (that is, dynamic
    binding). It will be important to create derived class instances and store them
    using base class pointers so that the polymorphic operations can be applied. We
    then need to verify that the derived class behavior shines through. If not, perhaps
    we may find ourselves in an un-intended function hiding situation, or perhaps
    the base class operation wasn't marked virtual as intended (keeping in mind that
    the keywords virtual and override at the derived class level, though nice and
    recommended, are optional and do not affect the dynamic behavior).
  prefs: []
  type: TYPE_NORMAL
- en: Though classes related through inheritance have unique testing strategies, remember
    that instantiation will create a single object, that is, of a base class or of
    a derived class type. When we instantiate one such type, we have one such instance
    – not a pair of instances working together. A derived class merely has a base
    class sub-object, which is part of itself. Let's consider how this compares with
    associated objects or aggregates, which can be separate objects (association),
    potentially interacting with their companions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding strategies to test aggregation and association
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes related through association or aggregation may be multiple instances
    communicating with one another, and causing state changes with one another. This
    is certainly more complex than the object relationship of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Classes related via aggregation are generally easier to test than those related
    via association. Thinking of the most common form of aggregation (composition),
    the embedded (inner) object is part of the outer (whole) object. When the outer
    object is instantiated, we get the memory for the inner object embedded within
    the "*whole*." The memory layout is not tremendously different (other than the
    potential ordering) when compared to the memory layout of a derived class instance,
    which contains a base class sub-object. In each case, we are still dealing with
    a single instance (even though it has embedded *parts*). The point of comparison
    with testing, however, is that operations applied to the *whole* are often delegated
    to the *parts* or components. We will rigorously need to test the operations,
    on the whole, to ensure that they delegate necessary information to each of the
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: Classes related via the lesser-used form of a general aggregation (where the
    whole contains pointers to the parts versus the typical embedded object implementation
    of composition) have similar issues to an association, as the implementation is
    similar. With that in mind, let's take a look at testing issues relating to associated
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Classes related via an association are often independently existing objects,
    which at some point in the application have created a link to one another. There
    may or may not be a predetermined point in the application when the two objects
    create a link to one another. Operations applied on one object may cause a change
    in the associated object. For example, let us consider a `Student` and a `Course`.
    Both may exist independently, then at some point in the application, a `Student`
    may add a `Course` with `Student::AddCourse()`. By doing so, not only does a particular
    `Student` instance now contain a link to a specific `Course` instance, but the
    `Student::AddCourse()` operation has caused a change in the `Course` class. That
    particular `Student` instance is now part of a particular `Course` instance's
    roster. At any point, the `Course` may be canceled, rippling a change in all `Student`
    instances who are enrolled in that `Course`. These changes reflect states in which
    each associated object may exist. For example, a `Student` may be in a state of
    *currently enrolled*, or *dropping* a `Course`. There are many possibilities.
    How do we test all of them?
  prefs: []
  type: TYPE_NORMAL
- en: Adding scenarios to aid in testing object relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The notion of a scenario comes up in object-oriented analysis as a means to
    both create OO designs and to test them. A **scenario** is a descriptive walkthrough
    of a likely series of events that will occur in an application. A scenario will
    feature classes and how they may interact with one another for a specific situation.
    Many related scenarios can be collected into the OO concept of a **use-case**.
    In the OO analysis and design phases, scenarios help determine which classes may
    exist in the application as well as operations and relationships each may have.
    In testing, scenarios can be reused to form the basis for driver creation to test
    various object relationships. With this in mind, a series of drivers can be developed
    to test numerous scenarios (that is, use-cases). This type of modeling will more
    thoroughly be able to provide a test bed for related objects than the initial,
    simple means of testing for completeness and robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Another area of concern between any type of related classes is that of version
    control. What happens, for example, if a base class definition or default behavior
    changes? How will that impact a derived class? How will that impact associated
    objects? With each change, we inevitably will need to revisit component testing
    for all related classes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's consider how exception handling mechanisms factor into OO component
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing exception handling mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can create drivers to test each class (or a grouping of related
    classes), we will want to understand which methods in our code may throw exceptions.
    For these scenarios, we will want to add try blocks within the driver to ensure
    we know how to handle each potential exception thrown. Before doing so, we should
    ask ourselves, did we include adequate exception handling in our code during the
    development process? For example, considering instantiation, do our constructors
    check if an object is fully constructed? Do they throw exceptions if not? If the
    answer is no, our classes may not be as robust as we had anticipated.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider embedding exception handling into a constructor, and how we may
    construct a driver to test all potential means for instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding exception handling in constructors to create robust classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may recall from our recent [*Chapter 11*](B15702_11_Final_NM_ePub.xhtml#_idTextAnchor417),
    *Handling Exceptions*, that we can create our own exception classes, derived from
    the C++ Standard Library `exception` class. Let's assume that we have created
    such a class, namely `ConstructionException`. If at any point in a constructor
    we are not able to properly initialize a given instance to provide a fully constructed
    object, we can throw a `ConstructionException` from any constructor. The implication
    of potentially throwing a `ConstructionException` is that we now should enclose
    instantiation within try blocks and add matching catch blocks to anticipate a
    `ConstructionException` that may be thrown. Keep in mind, however, that instances
    declared within the scope of a try block have scope only within the try-catch
    pairing.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that if an object does not complete construction (that is,
    if an exception is thrown before the constructor completes), the object will technically
    not exist. If an object does not technically exist, there will be no necessary
    clean-up of a partially instantiated object. We will, however, need to think about
    what this means to our application if an instance we anticipate does not fully
    construct. How will that alter the progression in our code? Part of testing is
    to ensure that we have considered all ways in which our code may be used and bulletproof
    accordingly!
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the introduction of `try` and `catch` blocks may
    alter our program flow and it is crucial to include this type of testing in our
    drivers. We may seek scenarios that account for the `try` and `catch` blocks as
    we conduct our testing.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how we can augment our test drivers to accommodate classes
    that may throw exceptions. We have also discussed in this chapter adding scenarios
    in our drivers to help track the states between objects with relationships, and
    of course, simple class idioms we can follow to set us up for success. Let us
    now briefly recap these concepts before moving forward to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have increased our ability to become better C++ programmers
    by examining various OO class and component testing practices and strategies.
    Our primary goal is to ensure that our code is robust, well-tested, and can be
    deployed error-free to our various organizations.
  prefs: []
  type: TYPE_NORMAL
- en: We have considered programming idioms, such as following canonical class form
    to ensure that our classes are complete and have expected behavior for construction/destruction,
    assignment, and usage in argument passing and as return values from functions.
    We have talked about what it means to create a robust class – one that follows
    canonical class form, that is also well-tested, platform-independent, and tested
    for fully constructed objects.
  prefs: []
  type: TYPE_NORMAL
- en: We have also explored how to create drivers to test individual classes or sets
    of related classes. We have established a checklist of items to test individual
    classes within a driver. We have looked more thoroughly at object relationships
    to understand that objects that interact with one another require more sophisticated
    testing. That is, as objects move from state to state, they may be impacted by
    associated objects, which can further alter their course of progression. We've
    added utilizing scenarios as test cases for our drivers to better capture the
    dynamic states in which instances may move within an application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have taken a look at how exception handling mechanisms can impact
    how we test our code, augmenting our drivers to account for the flow of control
    that try and catch blocks may maneuver in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue forward with the next part of our book, design
    patterns and idioms in C++. We will start with [*Chapter 16*](B15702_16_Final_NM_ePub.xhtml#_idTextAnchor622),
    *Using the Observer Pattern*. In the remaining chapters, we will understand how
    to apply popular design patterns, employing them in our coding. These skills will
    make us better programmers. Let's move forward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider a pair of classes from one of your previous exercises containing an
    object relationship (Hint: public inheritance will be easier to consider than
    association).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Do your classes follow canonical class form? Orthodox or extended? Why or
    why not? If they do not and should, revise the classes to follow this idiom.
  prefs: []
  type: TYPE_NORMAL
- en: b. Would you consider your classes robust? Why or why not?
  prefs: []
  type: TYPE_NORMAL
- en: Create a driver (or two) to test your pair of classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Be sure to test for the usual checklist of items (construction, assignment,
    destruction, the public interface, upcasting (if applicable), and use of virtual
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: b. (Optional) If you selected two classes related to association, create a separate
    driver to follow a typical scenario detailing the interaction of the two classes.
  prefs: []
  type: TYPE_NORMAL
- en: c. Be sure to include the testing of exception handling in one of your test
    drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `ConstructionException` class (derived from the C++ Standard Library
    `exception`). Embed checks within your constructors in a sample class to throw
    a `ConstructionException` when necessary. Be sure to enclose all forms of instantiation
    of this class within appropriate `try` and `catch` block pairings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
