- en: Forms in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using forms, in general, is our way of collecting data from the web so we can
    later persist it. We have expectations of the form experience, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Easily being able to declare different kinds of input fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up different kind of validations and displaying any validation errors
    to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting different strategies for stopping a post submission if the form contains
    errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two approaches to handling forms: template-driven forms and reactive
    forms. Neither approach is considered better than the other; you just have to
    go with the one that suits your scenario the best. The major difference between
    the two approaches is who is responsible for what:'
  prefs: []
  type: TYPE_NORMAL
- en: In the template-driven approach, the template is responsible for creating elements,
    forms, and setting up validation rules, and synchronization happens with two-way
    data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the reactive approach, the `Component` class is responsible for creating
    the form, its elements, and setting up the validation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about template-driven forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind data models and interface types for forms and input controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design forms using the reactive forms approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dive into the alternatives for input validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build our own custom validators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template-driven forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template-driven forms are one of two different ways of setting up forms with
    Angular. This approach is all about doing the setup in the template, which greatly
    resembles the approach used in AngularJS. So, if you have a background in AngularJS,
    this approach will be quite familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: Turning a simple form into a template-driven form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have defined the following form, which consists of a `form` tag, two `input`
    fields, and a `button`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we clearly have two `input` fields that are required, hence the `required`
    attribute for the input elements. We also have a Save button. The requirement
    we have on such a form is that it should not submit its data until all required
    fields are filled in. To accomplish this, we need to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Save the input field values to an object with `[(ngModel)]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only submit the form if it has no errors, by using the `ngForm` directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now change the form to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s talk about the changes we made. First off, we have the following piece
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We created a view reference called `formPerson` that has the value `ngForm`assigned
    to it. This means we have a reference to the form. The form view reference now
    contains a lot of interesting properties that will help us determine whether the
    form is ready to be submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the second change we made, we connected the input data to `ngModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `ngModel` allows us to create a double binding to a property. It is known
    as a *banana in a box*, which is really a memory rule for you to be able to remember
    how to type it. We create it in two steps. First we have `ngModel`, then we add
    the banana, the parenthesis, like this: `(ngModel)`. After that we put the banana
    in a box. Square brackets will serve as our box, which means we finally have `[(ngModel)]`.
    Remember, it's called *banana in a box*, not *box in a banana*.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we ensured that the value of the input was saved down to `person.name`,
    by utilizing the `ngModel` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we decorated our button element using the `*ngIf` directive, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We used an `*ngIf`directive to be able to hide the button, should the form prove
    to be invalid. As you can see, we are utilizing our form view reference and its
    valid property. If the form is valid, then show the button; otherwise, hide it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the very basics of setting up a template-driven form. Let''s investigate
    this a little deeper by looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: What CSS is being rendered, so we can render that appropriately depending on
    the form state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to detect a specific error on an input element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input field error – from a CSS standpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different CSS classes being assigned to an input element depending
    on what state it is in. Let''s have a look at an input element with a required
    attribute set, prior to us inputting any data. We expect it to tell us that something
    is wrong, due to the fact that the `input` field is empty and we have added a
    `required` attribute to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the following classes have been set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ng-untouched`, which means that no one has attempted to press the Submit button
    yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-pristine`, which essentially means that no attempts have been made to input
    data into this field. It would be set to `false` if you enter a character and
    remove the said character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-invalid`, which means that the validator is reacting and says something
    is wrong'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entering a character into the field, we see that `ng-pristine` disappears. Entering
    some characters in both fields and pressing Submit, we see that `ng-untouched`
    turns into `ng-touched`. This also causes `ng-invalid` to turn into `ng-valid`.
  prefs: []
  type: TYPE_NORMAL
- en: OK, so now we have a better understanding of what CSS turns into what, at what
    time, and can style our component appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting an error on an input field with named references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have settled for looking at the form reference when we want to know
    whether our form is valid or not. We can do a lot better here, we can detect whether
    a specific input control has an error. An input control may have more than one
    validator, which means we might have more than one validation error to show as
    well. So how do we detect that? There are a number of steps to be taken to accomplish
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a view reference for each input element and also assign it the value
    `ngModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give each element a `name` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s update our form code and add view references and `name` attributes according
    to the preceding steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have done the pre-work, it is time to talk about what errors we can
    detect. There are two types of errors that are of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: A general error, which is an error that says there is something wrong on the
    input control, but doesn't specify what
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A specific error, which will indicate the exact type of error, for example,
    the value is too short
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with a general error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We use our view reference `firstName` and query it for its valid property, which
    indicates whether an error exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the other more detailed error. To detect a more detailed error we use
    the errors object on our view reference and output the whole object using the
    JSON pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we can suddenly find out whether a specific error has been set and
    we can therefore decide to display a conditional text based on a certain error
    being present, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Other specific errors will populate the errors object, and the only thing you
    have to do is know what the error is called. When in doubt, output the errors
    object using the JSON pipe to find out what the validation error is called for
    a certain validator, and what validation error values go with it.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have covered the basic mechanisms for knowing when a form is erroneous
    and how to display a text based on a specific error. Let''s build on that knowledge
    by covering some more examples. First off, we will add more validation types to
    our input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have added `minlength`as a validation rule to our element, besides the
    pre-existing required rule. Required is the prioritized error, so that will show
    first. If we input some characters then the required error goes away. It should
    now display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like with the required error, we can show an error text for just this
    error, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some validation rules already written for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`required`, which requires the value to be non empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requiredTrue`, which specifically requires the value to be `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minlength`, which says the value needs to have a certain minimum length'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxlength`, which says the value cannot be over a certain length'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern`, which forces the value to adhere to a `RegEx` pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullValidator`, which checks the value is not null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compose`, which is used if you want to compose multiple validators into one,
    the validation rule is the result of taking the union of all validators provided'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to see if any of those covers your scenario. You might find that some validation
    rules are missing. If that is the case, then this can be remedied by creating
    a custom validator. We will cover how to build a custom validator rule later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Showing errors at the right time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our form has had a behavior of not showing the Submit button if at least
    one error exists. There are alternate approaches to take here. Sometimes it might
    be perceived as the UI being broken when a button doesn't exist or shows as disabled.
    This has to do with how you construct the UI in other places. A consistent approach
    is better. For that reason, there are different ways we could control how a form
    gets submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Show the Submit button when there are no errors in the form, we have covered
    how to do this one already. This approach may look like we forgot to design the
    form properly because the button seems to be missing entirely when the form has
    an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable the submit button as long as there are form errors. It is nice if this
    is accompanied with showing validation errors to avoid any misunderstandings on
    why it is disabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the call to submit only when there are no errors, the major difference
    here is that the Submit button is clickable but the submit action won't be taking
    place. The drawback of this version is making the user feel like nothing is happening.
    This approach needs to be accompanied with showing the validation error that prevents
    the form from being submitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how you would code the first approach. Here, we hide the button if
    the form is not valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The second approach involves setting the button to a disabled state. We can
    do so by binding to the `disabled` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The third and final approach is to create a `Boolean` condition that needs
    to return `true` for the other statement to be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Reactive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For reactive forms, we have a programmatic approach to how we create form elements
    and set up validation. We set everything up in the `Component` class and merely
    point out our created constructs in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key classes involved in this approach are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FormGroup`, which is a grouping containing one-to-many form controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormControl`, which represents an input element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AbstractControl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both the `FormGroup` and `FormControl` inherit from `AbstractControl`, which
    contains a lot of interesting properties that we can look at and use to render
    the UI differently, based on what status a certain thing has. For example, you
    might want to differ UI-wise between a form that has never been interacted with
    and one that has. It could also be of interest to know whether a certain control
    has been interacted with at all, to know what values would be part of an update.
    As you can imagine, there are a lot of scenarios where it is interesting to know
    a specific status.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list contains all the possible statuses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`controls`, a list of `FormControl` instances that you added through the constructor`new
    FormGroup(group)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`, a dictionary representing a key-value pair. The key is the reference
    you gave the `FormControl` at creation and the value is what you entered in the
    input control `{ :''<reference>'', <value entered> }`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dirty`, once we enter something in the form it is considered dirty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled`, the form can be disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pristine`, a form where none of the controls have been interacted with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`, a string representation of whether it is valid or not,  it says invalid
    if it isn''t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touched`, the Submit button has been pressed at least once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`untouched`, the Submit button has not yet been pressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enabled`, Boolean saying whether the form is enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid`, if there are no errors this one is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalid`, the opposite of valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatic and dynamic approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a programmatic approach to how things are being done, and we have two
    possible approaches to this:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create forms with N number of elements. This means we can generate forms
    that are completely dynamic in what and how many input controls, as well as forms,
    that should be used. A typical example is when creating a content management system
    where pages and their content are completely configurable from a config file or
    database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create deep structures. Normally we have a form and N number of elements
    in it, but reactive forms allow us to nest forms within forms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice here how the `FormGroup`is being called a group and not a `Form`. This
    is because you should consider this as only a grouping and not necessarily the
    only one of its kind. You could easily have a structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Person : FormGroup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name : FormControl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Surname : FormControl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Age : FormControl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Address : FormGroup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`City: FormControl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Country: FormControl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here we have a representation of `Person` and we can see that we want to handle
    the input of that person's address in a form by itself, hence the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Turning a form into a dynamic form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FormGroup` is the construct that consists of many form controls. To create
    such a construct we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the reactive `Forms` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate as many `FormControls` as you need, through code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the controls in a dictionary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the dictionary as input to the `FormGroup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Associate our `Form` group instance with the `[formGroup]` directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Associate each `FormControl` instance to a `[formControlName]` directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step lies in importing the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step is creating form controls. Let''s create two different ones,
    one with validation and one without:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The third step is to create a dictionary for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth step is to assign the group to a `formGroup` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Your full code should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Your form''s UI should look like this. As you can see, your `start value` is
    set to the input control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a4b4d126-7af6-4300-b171-a4b4ca55a706.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding controls with validation rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a validator to a form control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you investigate the markup for this newly added form, you can see that indeed
    its CSSclass has been set to `ng-invalid` due to its value being empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the next burning question, how do I reference individual elements so I
    know what errors they may or may not have? The answer is simple, under your form
    member, of type `FormGroup`, is a controls dictionary that contains controls.
    One of these controls works just like a view reference with template forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code snippet, we can refer to an individual
    control through `form.controls[''key'']`. It has the properties valid and errors
    on it so we can show individual errors, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring – making the code more dynamic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we have understood the basic mechanisms so far with `FormGroup` and `FormControl`and
    the involved directives, but our code looks very static, so let''s fix that. We
    need to have some kind of dataset that we loop through that creates our `Form`
    controls on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for defining the UI. We have a list of questions that we use an `*ngFor`
    to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We loop through the questions array and assign the `[formControl]`directive
    the appropriate control. From our question instance, we are also able to output
    the question itself. This looks a lot more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have one step left, and that is accessing the values the user actually
    fills in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a dictionary of the form control reference along with any value
    the user entered in the input upon pressing Submit.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our component form model – using setValue and patchValue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First off, let''s have a little reminder of how we can create a form programmatically.
    We used to use the dictionary variable and pass that to the `FormGroup` constructor,
    but we may as well skip that variable and define the dictionary inline, as in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To change any of the values in the form, we can use one of two approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setValue()`, which will replace all values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patchValue()`, which will only update the mentioned controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: setValue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using this method completely replaces all the values. As long as you mention
    all the values that the form was created with then you are fine, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If however, you forget a field, you will get an error back saying you must
    specify a value for all fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you only wanted to do a partial update then the `patchValue()` function is
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: patchValue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `patchValue()` is as easy as typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if the previous values before calling `patchValue()` were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then applying `form.patchValue()`, defined earlier, will cause the resulting
    form to contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Upon closer inspection, we can see that the surname and name have been updated
    but the age property has been left alone.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up our form creation and introducing FormBuilder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been creating our forms like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This, however, constitutes a lot of noise. We can use a construct called `FormBuilder`to
    take away a lot of that noise. To use the `FormBuilder` we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Import it from `@angular/forms`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject it into the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the instance and call the group function on the `FormBuilder` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s showcase this in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This looks a lot easier to read and we don't have to deal with the `FormGroup` and `FormControl` data
    types explicitly, although that is what is being created implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three different ways of specifying a value to our element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`elementName : ''''`, here the default value is being set to a primitive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elementName: { value : '''',  disabled: false }`, here we assign the `elementName` to
    an entire object, where the property value in the object is what the default value
    will become'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elementName : [ ''default value'', <optional validator> ]`, here we assign
    it a complete array with the first item in the array being the default value and
    the second to Nth values being the validators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what the code looks like using all three approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are rendering out the mentioned field in our preceding backing code.
    As you can see, the key names in the group object correspond to the `formControlName` attribute
    in the markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we show a specific error though? That''s an easy one, it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note how we refer to the form by its property name on the class `dynamicForm2`,
    we call the `get()` method and specify the key as an argument, and lastly, we
    call `hasError`and ask for a specific error. In this particular case, the address
    property is defined in the code as consisting of city and country. Specifying
    an error like this would just tell us that either city or country has an error
    on it, or both.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own custom validator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the default validators won't cover all the scenarios that you might
    have in your application. Luckily, it is quite easy to write your own custom validator.
  prefs: []
  type: TYPE_NORMAL
- en: A custom validator is just a function that needs to return an object with the
    error specified or null. Null means we don't have an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting to define such a function is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are building a `minValue` validator. The outer function takes
    the parameter we will compare to. We return an inner function that tests the control''s
    value to our compare value. If our condition is `true` we raise an error where
    we return an error structure`{ ''minValue'' : {  value : control.value } }`, or
    if it is `false` then we return null.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this new validator all we have to do is import it in our component file
    and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And to show an error message in the template, if this error is raised, we just
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Watching state changes and being reactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how we can create forms programmatically using the `FormBuilder`
    and how we can specify all our fields and their validations in the code. We haven't
    really talked about why a reactive form is called *reactive.* Here is the thing,
    we can listen to changes on the input fields in the form when they happen and
    react accordingly. A suitable reaction could be to disable/enable a control, provide
    a visual hint, or something else. You get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: How is this made possible though? It is made possible by the fact that the fields
    we declare have two Observables connected to them, `statusChanges` and `valueChanges`.
    By subscribing to those, we are able to listen to changes and make the suggested
    changes we mentioned earlier in this paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting case for demonstrating how we can watch state changes is that
    of login. In a login scenario we want the user to type in their username and password,
    followed by pressing a button. What we should be able to support the user with
    in such a scenario is:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing a hint if something is wrong with the entered username, it may be empty
    or entered in a way that is not allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling the login button if not all required fields are entered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We opt for showing a hint if the username is not constructed correctly. We don't
    want to show the hint unless the user has started to enter values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do this in steps. We first build our component, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have set up a form with two input fields, a `username` field and a
    `password` field. We have also stated that these two fields are required by the
    way we have set up the validation rules. The next step is to set up the subscriber
    to the username fields so we can be notified of changes to it. The required changes
    are highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see here that we do this in two steps. First we create a reference to
    our username field by asking the `loginForm` for it, like so: `this.loginForm.controls[''username'']`.
    Then we set up a subscription to the form control reference `username:FormControl` by
    calling `username.subscribe(...)`. Inside of the `.subscribe()` we evaluate whether
    to set the `this.showUsernameHint`variable to `true` or `false`. The logic reads
    that if an `@` character is missing and the user has started typing, then show
    the visual hint. Setting the hint to `true` will trigger the template to show
    the hint text, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there is more to creating a login component, such as sending the
    username and password to an endpoint and rerouting the user to a suitable page,
    and so on, but this code shows off the reactive nature.  Hopefully, this has clearly
    conveyed how you can take advantage of the reactive nature of forms and respond
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we have learned that Angular provides you with two different
    flavors for creating forms, template-driven and reactive forms, and that neither
    approach can be said to be better than the other. We have also covered what different
    types of validations exist and we now know how to create our own validations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at how we can skin our application
    to look more beautiful with the help of the framework Angular Material. Angular
    Material comes with a lot of components and styling ready for you to use in your
    next project. So, let's give your Angular project the love it deserves.
  prefs: []
  type: TYPE_NORMAL
