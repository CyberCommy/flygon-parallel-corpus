- en: Understanding .NET Core Internals and Measuring Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing application architecture, knowing the internals of how the .NET
    framework works plays a vital role in ensuring the quality of the application's
    performance. In this chapter, we will focus on the internals of .NET Core that
    can help us write quality code and architecture for any application. This chapter
    will cover some of the core concepts of .NET Core internals, including the compilation
    process, garbage collection, and **Framework Class Library **(**FCL**). We will
    complete this chapter by going through the *BenchmarkDotNet* tool, which is mostly
    used in measuring code performance, and is highly recommended for benchmarking
    code snippets within an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core internals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing multiple cores of the CPU for high performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How releasing builds increases performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking .NET Core 2.0 applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '.NET Core contains two core components—the runtime CoreCLR and the base-class
    libraries CoreFX. In this section, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: CoreFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoreCLR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding MSIL, CLI, CTS, and CLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How CLR works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From compilation to execution—under the hood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Native and JIT compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoreFX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CoreFX is the code name of .NET Core's set of libraries. It contains all the
    libraries that start with Microsoft.* or System.*and contains collections, I/O,
    string manipulation, reflection, security, and many more features.
  prefs: []
  type: TYPE_NORMAL
- en: The CoreFX is runtime agnostic, and it can run on any platform regardless of
    what APIs it supports.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about each assembly, you can refer to the .NET Core source browser
    at [https://source.dot.net](https://source.dot.net).
  prefs: []
  type: TYPE_NORMAL
- en: CoreCLR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CoreCLR provides the common language runtime environment for .NET Core applications,
    and manages the execution of the complete application life cycle. It performs
    various operations when the program is running. Operations such as memory allocation,
    garbage collection, exception handling, type safety, thread management, and security
    are part of CoreCLR.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core's runtime provides the same **Garbage Collection** (**GC**) as .NET
    Framework and a new **Just In Time** (**JIT**) compiler that is more optimized,
    codenamed *RyuJIT*. When .NET Core was first released, it was only supported for
    64-bit platforms, but with the release of .NET Core 2.0, it is now available for
    32-bit platforms as well. However, the 32-bit version is only supported by Windows
    operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MSIL, CLI, CTS, and CLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we build our project, the code is compiled into the **Intermediate Language**(**IL**),
    also known as **Microsoft Intermediate Language** (**MSIL**). MSIL is compliant
    with the **Common Language Infrastructure** (**CLI**), where CLI is the standard
    that provides a common type system and a language specification, respectively
    known as the **Common Type System** (**CTS**) and **Common Language Specification** (**CLS**).
  prefs: []
  type: TYPE_NORMAL
- en: The CTS provides a common type system and compiles the language-specific types
    into the compliant data types. It standardizes all the .NET languages' data types
    to a common data type for language interoperability. For example, if the code
    is written in C#, it will be converted to the specific CTS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have two variables, defined in the following code fragment using
    C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On compilation, the compiler generates the MSIL into an assembly that will
    be available through the CoreCLR to perform the JIT and convert it into the native
    machine code. Note that the `int` and `long` types are converted to the `int32`
    and `int64` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is not necessary for every language to comply completely with the CTS, and
    it can support the smaller footprint of the CTS, too. For example, when VB.NET
    was first released in .NET Framework, it only supported the signed integer data
    types, and there was no provision to use unsigned integers. With later versions
    of .NET Framework, and now with .NET Core 2.0, we can use all managed languages,
    such as C#, F#, and VB.NET, to develop applications and easily reference any project's
    assembly.
  prefs: []
  type: TYPE_NORMAL
- en: How the CLR works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CLR is implemented as a set of in-process libraries that are loaded with
    the application, and runs inside the context of the application process. In the
    following diagram, we have two .NET Core applications running, named App1.exe
    and App2.exe*.* Each black box represents the application process address space,
    where the applications App1.exe and App2.exe are running their own CLR version
    side by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.gif)'
  prefs: []
  type: TYPE_IMG
- en: When packaging the .NET Core applications, we can either publish them as **framework-dependent
    deployments** (**FDDs**) or **self-contained deployment**s (**SCDs**). In FDDs,
    the published package does not contain the .NET Core runtime, and expects that
    the .NET Core is present on the target/hosting system. With SCDs, all the components,
    such as the .NET Core runtime and .NET Core libraries, are included in the published
    package, and the .NET Core installation on the target system is not required.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about FDDs or SCDs, please refer to [https://docs.microsoft.com/en-us/dotnet/core/deploying/](https://docs.microsoft.com/en-us/dotnet/core/deploying/).
  prefs: []
  type: TYPE_NORMAL
- en: From compilation to execution – Under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The .NET Core compilation process is like the one used with the .NET Framework.
    When the project is built, the internal .NET CLI command is invoked by the MSBuild
    system, which builds the project and generates the assembly (`.dll`) or executable
    (`.exe`) file. This assembly contains the manifest that contains the assembly''s
    metadata, and includes the version number, culture, type-reference information,
    information about the referenced assemblies, and a list of other files in the
    assembly and their association. This assembly manifest is stored either in the
    MSIL code or in a standalone **portable executable** (**PE**) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.gif)'
  prefs: []
  type: TYPE_IMG
- en: Now, when the executable is run, a new process is started and bootstraps the
    .NET Core runtime, which then initializes the execution environment, sets up the
    heap and thread pool, and loads the assembly into the process address space. Based
    on the program, it then executes the main entry point method (`Main`) and performs
    a JIT compilation. From here, the code starts executing and the objects start
    allocating memory on heap, where primitive types store on stack. For each method,
    the JIT compilation is done and the native machine code gets generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'When JIT compilation is done, and before generating a native machine code,
    however, it also performs a few validations. These validations include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying, that the MSIL was generated during the build process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying, whether any code was modified or new types added during the JIT compilation
    process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying, that the optimized code for the target machine has been generated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important features of CLR is the garbage collector. Since the
    .NET Core applications are managed applications, most of the garbage collection
    is done automatically by the CLR. The allocation of objects in the memory is efficiently
    done by the CLR. The CLR not only tunes the virtual memory resources from time
    to time, but it also reduces the fragmentation of underlying virtual memory to
    make it more efficient in terms of space.
  prefs: []
  type: TYPE_NORMAL
- en: When the program is run, the objects start allocating memory on the heap and
    each object's address is stored on the stack. This process continues until the
    memory reaches its maximum limit. Then the GC comes into play and starts reclaiming
    memory by removing the unused managed objects and allocating new objects. This
    is all done automatically by the GC, but there is also a way to invoke the GC
    to perform garbage collection by calling the `GC.Collect` method
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example where we have a `Car` object called `c` in the `Main`
    method. When the function is executed, the `Car` object will be allocated by the
    CLR into the heap memory and the reference to that `c` object will be stored in
    the stack address pointing to the `Car` object on the heap. When the garbage collector
    runs, it reclaims the memory from the heap and removes the reference from the
    stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.gif)'
  prefs: []
  type: TYPE_IMG
- en: Some important points to note are that the garbage collection is done automatically
    by the GC on managed objects, and that if there are any unmanaged objects, such
    as database connections, I/O operations, and so on, they need to be garbage collected
    explicitly. Otherwise, GC works efficiently on managed objects and ensures that
    the application will not experience any decrease in performance when the GC is
    performed.
  prefs: []
  type: TYPE_NORMAL
- en: Generations in GC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three kinds of generation in garbage collection known as Generation
    0, Generation 1, and Generation 2\. In this section, we will look at the concept
    of generations and how it affects the performance of the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we run an application that creates three objects named Object1,
    Object2, and Object3\. These objects will allocate the memory in Generation 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.gif)'
  prefs: []
  type: TYPE_IMG
- en: Now, when the garbage collector runs (this is an automatic process, unless you
    explicitly call the garbage collector from the code), it checks for the objects
    that are not needed by the application and have no reference in the program. It
    will simply remove those objects. For example, if the scope of Object1 is not
    referenced anywhere, the memory for this object will be reclaimed. However, the
    other two objects, Object1 and Object2, are still referenced in the program, and
    will be moved to Generation 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose two more objects, called Object4 and Object5, are created.
    We will store them in the Generation 0 slot, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'When garbage collection runs the second time, it will find two objects called Object4
    and Object5 in Generation 0 and two objects called Object2 and Object3 in Generation
    1\. Garbage collector will first check the reference of those objects in Generation
    0 and, if they are not used by the application, they will be removed. The same
    goes for the Generation 1 objects. For example, if Object3 is still referenced,
    it will be moved to Generation 2 and Object2 will be removed from Generation 1,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.gif)'
  prefs: []
  type: TYPE_IMG
- en: This concept of generations actually optimizes the performance of GC, and the
    objects stored in Generation 2 are more likely to be stored for a longer period.
    GC performs fewer visits and gains time instead of checking each object again
    and again. The same goes for Generation 1, which is also less likely to reclaim
    the space than Generation 0.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Native and JIT compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JIT compilation is done mostly at runtime, and it converts the MSIL code to
    the native machine code. This is when the code is run the first time, and it takes
    a little bit more time than its successive runs. In .NET Core today, we are developing
    applications for mobile and handheld devices that have limited resources in terms
    of CPU power and memory. Currently, the **Universal Windows Platform** (**UWP**)
    and the Xamarin platform run on .NET Core. With these platforms, .NET Core automatically
    generates that native assembly at compilation time or while generating the platform-specific
    packages. Though it does not require the JIT compilation process to be done at
    runtime, this eventually increases the performance of the application's boot-up
    time. This native compilation is done through a component known as .NET Native.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET Native begins the compilation process after the language-specific compiler
    finishes up the compilation process that is done at build time. The .NET Native
    toolchain reads the MSIL generated from the language compiler and performs the
    following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: It eliminates the metadata from the MSIL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It replaces the code that relies on reflection and metadata with the static
    native code when comparing field values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It checks the code that is invoked by the application and includes only that
    in the final assembly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It replaces the full CLR with a refactored runtime that contains the garbage
    collector and no JIT compiler. The refactored runtime goes with the app and is
    contained in the assembly named `mrt100_app.dll`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing multiple cores of the CPU for high performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These days, the nature of applications focuses more on connectivity, and there
    are cases where their operations take more time to execute. We also know that
    nowadays, all computers come with a multi-core processor, and using these cores
    effectively increases the performance of the application. Operations such as network/IO
    have latency issues, and the synchronous execution of the application program
    may often lead to a long waiting time. If the long-running tasks are executed
    in a separate thread or in an asynchronous manner, the resulting operation will
    take less time and increase responsiveness. Another benefit is performance that
    actually utilizes multiple cores of the processor and executes the task simultaneously.
    In the .NET world, we can achieve responsiveness and performance by splitting
    the tasks into multiple threads and using classic multithreading programming APIs,
    or a more simplified and advanced model known as the**task programming library** (**TPL**).
    The TPL is now supported in .NET Core 2.0, and we will soon explore how it can
    be used to execute tasks on multiple cores.
  prefs: []
  type: TYPE_NORMAL
- en: The TPL programming model is based on the task. A task is a unit of work—an
    object's representation of an ongoing operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple task can be created by writing the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the task can be initialized using a `Task` object, where
    `Execute` is the computational method that is executed when the `Start` method
    is called. The `Start` method tells the .NET Core that the task can start and
    returns immediately. It forks the program execution into two threads that run
    concurrently. The first thread is the actual application thread and the second
    one is the one that executes the `execute` method. We have used the `t.Wait` method
    to wait for the worker task to show the result on the console. Otherwise, once
    the program exits the block of code under the `Main` method, the application ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of parallel programming is to effectively use multiple cores. For
    example, we are running the preceding code in a single-core processor. These two
    threads will run and share the same processor. However, if the same program can
    run on a multi-core processor, it can run on multiple cores by utilizing each
    core separately, increasing the performance and achieving true parallelism:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Unlike TPL, the classic `Thread` object doesn't guarantee that your thread will
    be running on distinct cores of the CPU. With TPL, however, it guarantees that
    each thread will run on the distinct thread unless it reaches the number of tasks
    as per the CPU and shares the cores.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about what TPL provides, please refer to
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl).'
  prefs: []
  type: TYPE_NORMAL
- en: How releasing builds increases performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Release and debug builds are two build modes provided in .NET applications.
    Debug mode is mostly used when we are in the process of writing code or troubleshooting
    errors, whereas release build mode is often used while packaging the application
    to deploy on production servers. When developing the deployment package, developers
    often miss updating the build mode to the release build, and then they face performance
    issues when the application is deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table shows some differences between the debug and release modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Debug | Release |'
  prefs: []
  type: TYPE_TB
- en: '| No optimization of code is done by the compiler | Code is optimized and minified
    in size when built using release mode |'
  prefs: []
  type: TYPE_TB
- en: '| Stack trace is captured and thrown at the time of exception | No stack trace
    is captured |'
  prefs: []
  type: TYPE_TB
- en: '| The debug symbols are stored | All code and debug symbols under #debug directives
    are removed |'
  prefs: []
  type: TYPE_TB
- en: '| More memory is used by the source code at runtime | Less memory is used by
    the source code at runtime |'
  prefs: []
  type: TYPE_TB
- en: Benchmarking .NET Core 2.0 applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Benchmarking applications is the process of evaluating and comparing artifacts
    with the agreed upon standards. To benchmark .NET Core 2.0 application code, we
    can use the `BenchmarkDotNet` tool, which provides a very simple API to evaluate
    the performance of code in your application. Usually, benchmarking at the micro-level,
    such as with classes and methods, is not an easy task, and requires quite an effort
    to measure the performance, whereas `BenchmarkDotNet` does all the low-level plumbing
    and the complex work associated with benchmark solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring BenchmarkDotNet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore `BenchmarkDotNet` and learn how effectively
    it can be used to measure application performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can simply be installed using a NuGet package manager console window or
    through the Project References section of your project. To install `BenchmarkDotNet`,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command adds a `BenchmarkDotNet` package from `NuGet.org`.
  prefs: []
  type: TYPE_NORMAL
- en: To test the `BenchmarkDotNet` tool, we will create a simple class that contains
    two methods to generate a Fibonacci series for a sequence of `10` numbers. The
    Fibonacci series can be implemented in multiple ways, which is why we are using
    it to measure which code snippet is faster and more performance efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first method that generates the Fibonacci sequence iteratively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another method that uses the recursive approach to generate the Fibonacci
    series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that both of the main methods of the Fibonacci series contain a `Benchmark`
    attribute. This actually tells the `BenchmarkRunner` to measure methods that contain
    this attribute. Finally, we can call the `BenchmarkRunner` from the main entry
    point of the application that measures the performance and generates a report,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the benchmark is run, we will get the report as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As well as this, it also generates files in the root folder of an application
    that runs the `BenchmarkRunner`. Here is the .html file that contains the information
    about the version of `BenchmarkDotNet` and the OS, the processor, frequency, resolution,
    and timer details, the .NET version (in our case, .NET Core SDK 2.0.0), host,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The table contains four columns. However, we can add more columns, which are
    optional by default. We can also add custom columns as well. The Method is the
    name of the method that contains the benchmark attribute, the Mean is the average
    time it takes for all the measurements to be taken (where us is microseconds), Error
    is the time taken to process errors, and StdDev is the standard deviation of the
    measurements.
  prefs: []
  type: TYPE_NORMAL
- en: After comparing both the methods, the `FibonacciRecursive` method is more efficient
    as the Mean, Error, and StdDev values are smaller than the `Fibonacci` method.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the HTML, two more files are created, a **Comma Separated Value**
    (**CSV**) file and a **Markdown Documentation** (**MD**) file which contains the
    same information.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Benchmark generates a project at runtime for each benchmark method and builds
    it in release mode. It tries multiple combinations to measure the method's performance
    by launching that method multiple times. Once the multiple cycles are run, the
    report is generated, containing files and information about Benchmark.
  prefs: []
  type: TYPE_NORMAL
- en: Setting parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we tested the method with only one value. Practically,
    when testing an enterprise application, we want to test it with different values
    to estimate the method's performance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After running Benchmark, the following report is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Memory diagnostics using BenchmarkDotnet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `BenchmarkDotnet`, we can also diagnose any problems with the memory and
    measure the number of allocated bytes and garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be implemented using a `MemoryDiagnoser` attribute at the class level.
    To start, let''s just add the `MemoryDiagnoser` attribute to the `TestBenchmark`
    class that we created in the last example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the application. Now it will collect other memory allocation and garbage
    collection information and generate logs accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding table, the Gen 0 and Gen 1 columns each contain the number
    of that particular generation per 1,000 operations. If the value is 1, then it
    means that the garbage collection was done after 1,000 operations. However, note
    that in the first row, the value is *0.1984*, which means that the garbage collection
    was done after *198.4* seconds, whereas for Gen 1 of that row, no garbage collection
    took place. Allocated represents the size of the memory that is allocated while
    invoking that method. It does not include the Stackalloc/heap native allocations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Benchmark configuration can be defined by creating a custom class and inheriting
    it from the `ManualConfig` class. Here is an example of the `TestBenchmark` class
    that we created earlier containing some benchmark methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined the `Config` class that inherits the `ManualConfig`
    class provided in the benchmark framework. Rules can be defined inside the `Config`
    constructor. In the preceding example, there is a rule that stipulates that only
    those benchmark methods that contain `Recursive` should be executed. In our case,
    we have only one method, `FibonacciRecursive`, that will be executed and whose
    performance we will measure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of doing this is through the fluent API, where we can skip creating
    a `Config` class and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about `BenchmarkDotNet`, refer to [http://benchmarkdotnet.org/Configs.htm](http://benchmarkdotnet.org/Configs.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the core concepts of .NET Core, including
    the compilation process, garbage collection, how to develop high-performant .NET
    Core applications by utilizing multiple cores of the CPU, and publishing an application
    using a release build. We have also explored the benchmarking tool, which is highly
    used for code optimization, and provides results specific to class objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about multithreading and concurrent programming
    in .NET Core.
  prefs: []
  type: TYPE_NORMAL
