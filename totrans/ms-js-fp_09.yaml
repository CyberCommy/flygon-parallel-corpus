- en: Designing Functions - Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions
    - Pipelining And Composition*, we considered yet more ways to create new functions
    out of combining previous existing ones. Here, we are going to get into a different
    theme: how to actually design and write functions, in a typically functional way,
    by applying recursive techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what recursion is and how to think in order to produce recursive
    solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying recursion to some well-known problems, such as making change or the
    *Tower of Hanoi*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using recursion instead of iteration to re-implement some higher-order functions
    from earlier chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing search and backtrack algorithms with ease
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversing data structures, such as trees, to work with file system directories
    or with the browser DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting around some limitations caused by browser JS engine considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is a key technique in FP, to the degree that there are some languages
    that do not provide for any kind of iteration or loops and work exclusively with
    recursion (Haskell, which we already mentioned, is a prime example of that). A
    basic fact of computer science is that whatever you can do with recursion, you
    can also do with iteration (loops), and vice versa. The key concept is that there
    are many algorithms whose definition is far easier if you work recursively. On
    the other hand, recursion is not always taught, or many programmers, even knowing
    about it, prefer not to use it. So, in this section we shall see several examples
    of recursive thinking, so you can adapt it for your functional coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical, oft-quoted, and very old, computer joke! *Dictionary definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '**recursion**: (n) see **recursion***'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, what is recursion? There are many ways to define what recursion is, but
    the simplest one I''ve seen runs along the lines of *a function calls itself,
    again and again, until it doesn''t*. Recursion is a natural technique for several
    kinds of problems, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical definitions, such as the Fibonacci numbers or the Factorial of
    a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structure related algorithms, with recursively defined structures, such
    as *lists* (a list is either empty or consist of a head node, followed by a list
    of nodes) or *trees* (a tree might be defined as a special node, called the root,
    linked to zero or more trees)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax analysis for compilers, based on grammar rules which, themselves, depend
    on other rules, which also depend on other rules, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And many more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/702ab100-d540-4e19-a179-027a0c040b90.png)Google itself jokes about
    it: if you ask about recursion, it answers Did you mean: recursion!'
  prefs: []
  type: TYPE_NORMAL
- en: In any case, a recursive function, apart from some easy, *base*, cases, in which
    no further computation is required, always needs to call itself one or more times
    in order to perform part of the required calculations. This concept may be not
    very clear now, so let's see how we can think in a recursive fashion and then
    solve several common problems by applying that technique.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking recursively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The key to solving problems recursively is assuming that you already have a
    function that does whatever you need, and just call it normally. (Doesn''t this
    sound weird? Actually, it is quite appropriate: to solve a problem with recursion,
    you must first solve the problem...) On the other hand, if you try to work out
    in your head how the recursive calls work and attempt to follow the flow in your
    mind, you''ll probably just get lost. So, what you need to do is:'
  prefs: []
  type: TYPE_NORMAL
- en: Assume you already have an appropriate function to solve your problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, see how the big problem can be solved by solving one (or more) smaller
    problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve those problems by using the imagined function from step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide what are your *base cases*, simple enough that they be solved directly,
    not requiring any more calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these elements, you can solve problems by recursion, because you'll have
    the basic structure for your recursive solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three usual methods for solving problems by applying recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decrease and conquer** is the simplest case, in which solving a problem directly
    depends on solving a single, simpler case of itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Divide and conquer** is a more general approach. The idea is to try to divide
    your problem into two or more smaller versions, solve them recursively, and use
    such solutions to solve the original problem. The only difference between *decrease
    and conquer* is that here, you have to solve two or more other problems, instead
    of only one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic programming** can be seen as a variant of d*ivide and conquer*: basically,
    you solve a complex problem by breaking it into a set of somewhat simpler versions
    of the same problem and solving each in order. However, a key idea in this strategy
    is to store previously found solutions, so whenever you find yourself needing,
    again, the solution to a simpler case, you won''t directly apply recursion, but
    rather use the stored result and avoid unnecessary repeated calculations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we shall see a few problems and solve them by thinking in a
    recursive way. Of course, we shall see more applications of recursion in the rest
    of the chapter; here, we'll focus on the key decisions and questions needed to
    create such an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decrease and Conquer: searching'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most usual case of recursion involves just a single simpler case. We have
    already seen some examples of this, such as the ubiquitous factorial calculation:
    to calculate the factorial of *n*, you previously needed to calculate the factorial
    of *n-1*. (See [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming
    Functional - Several Questions*.) Let''s turn now to a non-mathematical example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To search for an element in an array, you would also use this *decrease and
    conquer* strategy. If the array is empty, obviously the searched value isn''t
    there. Otherwise, the result is in the array if, and only if, it''s the first
    element in it, or if it''s in the rest of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This implementation directly mirrors our explanation and it's easy to verify
    its correctness.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, just as a precaution, let's see two further implementations of the
    same concept. You can shorten the search function a bit -- is it still clear?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Sparseness can go even farther!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I'm not really suggesting you code the function in this way -- rather, consider
    it a warning against the tendency that some FP developers show to try to go for
    the tightest, shortest, possible solution... and never mind clarity!
  prefs: []
  type: TYPE_NORMAL
- en: 'Decrease and Conquer: doing powers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another classic example has to do with calculating powers of numbers in an
    efficient way. If you want to calculate, say, 2 to the 13th power (2^(13)), you
    may do this with 12 multiplications. However, you can do much better by writing
    2^(13) as:'
  prefs: []
  type: TYPE_NORMAL
- en: = 2 times 2^(12)
  prefs: []
  type: TYPE_NORMAL
- en: = 2 times 4⁶
  prefs: []
  type: TYPE_NORMAL
- en: = 2 times 16³
  prefs: []
  type: TYPE_NORMAL
- en: = 2 times 16 times 16²
  prefs: []
  type: TYPE_NORMAL
- en: = 2 times 16 times 256¹
  prefs: []
  type: TYPE_NORMAL
- en: = 8192
  prefs: []
  type: TYPE_NORMAL
- en: 'This reduction in the total number of multiplications may not look very impressive,
    but, in terms of algorithms complexity, it allows bringing down the order of the
    calculations from *O(n)* to *O(lg n)*. In some cryptographic related methods,
    which have to raise numbers to really high exponents, this makes a very important
    difference. We can implement this recursive algorithm in a few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When implemented for production, bit operations are used, instead of modulus
    and divisions. Checking if a number is odd can be written as `power & 1`, and
    division by 2 is achieved with `power > > 1`. These alternative calculations are
    way faster than the replaced operations.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating a power is simple when the base case is reached (raising something
    to the zeroth power), or is based upon previously calculating some power for a
    smaller exponent. (If you wanted to, you could add another base case for raising
    something to the power of one.) These observations show that we are seeing a textbook
    case for the *decrease and conquer* recursive strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some of our higher-order functions, such as `map()`, `reduce()`, or
    `filter()`, also apply this technique; we'll look into this later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Divide and conquer: The Tower of Hanoi'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this strategy, solving a problem requires two or more recursive solutions.
    For starters, let''s consider a classic puzzle, invented by a French mathematician,
    Édouard Lucas, in the XIX century. It seems that there is a temple in India, with
    three posts with 64 golden disks of decreasing diameter. The priests have to move
    the disks from the first post to the last one, following two rules: only one disk
    can be moved at a time, and a larger disk can never be placed on top of a smaller
    disk. According to the legend, when the 64 disks are moved, the world will end.
    This puzzle is usually marketed under the name *Towers of Hanoi* (yes, they changed
    countries!) with less than 10 disks. See figure 9.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bf050084-6ffd-480f-91c0-e04a23136daa.jpg)Figure 9.1- The classic
    Towers of Hanoi puzzle has a simple recursive solution.The solution for n disks
    requires *2^n-1* movements. The original puzzle, requiring *2^(64)-1* movements,
    at one movement per second, would take more than 584 billion years to finish ...
    a very long time, considering that the universe''s age is evaluated to *only*
    be 13.8 billion years!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we already had a function that was able to solve the problem of moving
    any number of disks from a source post, to a destination post, using the remaining
    post as an extra aid. So, now think about solving the general problem, if you
    already had a function to solve that problem: `hanoi(disks, from, to, extra)`.
    If you wanted to move several disks from a post to another, you could solve it
    easily by using this (still unwritten!) function, by:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving all of the disks but one to the extra post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the larger disk to the destination post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using your function, again, to move all of the disks from the extra post (where
    you had earlier placed them) to the destination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But, what about our bases cases? We could decide that to move a single disk,
    you needn''t use the function; you just go ahead and move it. Coded, it becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can quickly verify this code works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There's only a small detail to consider, which can simplify the function even
    further. In this code, our base case (the one that needs no further recursion)
    is when `disks` equal one. You could also solve it in a different way, by letting
    disks go down to zero and simply not doing anything -- after all, moving zero
    disks from a post to another is achieved by doing nothing at all!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Instead of checking if there are any disks to move before doing the recursive
    call, we can just skip the check and have the function test, at the next level,
    if there's something to be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are doing the puzzle by hand, there''s a simple solution for that: on
    odd turns, always move the smaller disk to the next post (if the total number
    of disks is odd) or to the previous post (if the total number of disks is even).
    On even turns, do the only possible move that doesn''t imply the smaller disk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the principle for recursive algorithm design works: assume you already
    have your desired function and use it to build it!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Divide and conquer: sorting'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can see another example of the d*ivide and conquer* strategy, with sorting.
    A way to sort arrays, called q*uicksort*, is based upon the following premises:'
  prefs: []
  type: TYPE_NORMAL
- en: If your array has 0 or 1 elements, do nothing; it's already sorted (this is
    the base case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Otherwise, pick some element of the array (called the "pivot") and split the
    rest of the array into two sub-arrays: the elements less than your pick, and the
    elements greater than your pick, or equal to it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively sort each sub-array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Concatenate both sorted results, with the pivot in-between, to produce the sorted
    version of the original array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see a simple version of this -- there are some better-optimized implementations,
    but we are interested in the recursive logic now. Usually, picking a random element
    of the array is suggested, to avoid some bad performance border cases, but for
    our example, let''s just take the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see how this works in figure 9.2: the pivot for each array and sub-array
    is underlined. Splitting is shown with dotted arrows and is joined with full lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6a70f2e3-5083-417d-ba2b-a5eb0a3122e0.jpg)Figure 9.2\. Quicksort
    sorts an array recursively, applying the divide and conquer strategy, to reduce
    the original problem to smaller ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic programming: making change'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third general strategy, *dynamic programming*, assumes that you will have
    to solve many smaller problems, but instead of using recursion each and every
    time, it depends on having stored the previously found solutions... memoization,
    in other terms! In [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml), *Behaving
    Properly - Pure Functions*, and later in a better fashion in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher - Order Functions*, we already saw how to optimize
    the calculations of the usual Fibonacci series, avoiding unnecessary repeated
    calls. Let's now consider another problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a certain amount of dollars and the list of existing bill values, calculate
    in how many different ways we can pay that amount of dollars with different combinations
    of bills. It is assumed that you have access to an unlimited number of each bill.
    How can we go about solving this? Let''s start by considering the base cases,
    where no further computation is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: Paying negative values is not possible, so in such cases, we should return 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paying zero dollars is only possible in a single way (by giving no bills), so
    in this case, we should return 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paying any positive amount of dollars isn't possible if no bills are provided,
    so in this case, also return 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we can answer the question: in how many ways can we pay `N` dollars
    with a given set of bills? We can consider two cases: we do not use the larger
    bill at all and pay the amount using only smaller denomination bills, or we can
    take one bill of the larger amount, and reconsider the question. (Let''s forget
    the avoidance of repeated calculations for now.)'
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, we should invoke our supposedly existing function with the
    same value of `N`, but have pruned the largest bill denomination from the list
    of available bills
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the second case, we should invoke our function with `N` minus the largest
    bill denomination, keeping the list of bills the same:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s do some optimizing. This algorithm often needs to re-calculate
    the same values over and over. (To verify this, add `console.log(n, bills.length)`
    as the first line in `makeChange()` -- but be ready for plenty of output!) But,
    we already have a solution for this: memoization! Since we are applying this technique
    to a binary function, we''ll need a version of the memoization algorithm that
    deals with more than one parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The memoized version of `makeChange()` is far more efficient, and you can verify
    it with logging. While it is certainly possible to deal with the repetitions by
    yourself (for example, by keeping an array of already computed values), the memoization
    solution is, in my opinion, better, because it composes two functions to produce
    a better solution for the given problem.
  prefs: []
  type: TYPE_NORMAL
- en: Higher order functions revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classic FP techniques do not use iteration at all, but work exclusively with
    recursion as the only way to do some looping. Let's revisit some of the functions
    that we already saw in [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),
    *Programming Declaratively - A Better Style*, such as `map()`, `reduce()`, `find()`,
    and `filter()`, to see how we can make do with the only recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not planning to exchange the basic JS functions for ours, though: it''s
    highly likely that performance will be worse for our *recursive polyfills* and
    we won''t derive any advantages just from having the functions use recursion.
    Rather, we want to study how iterations are performed in a recursive way, so our
    efforts are more pedagogical than practical, OK?'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping and filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mapping and filtering are quite similar, insofar both imply going through all
    the elements in an array and applying a callback to each to produce output. Let's
    work out first the mapping logic, which will have several points to solve, and
    then filtering will become almost trivially easy, requiring just small changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For mapping, according to the way we are using to develop recursive functions,
    we need a base case. Fortunately, that''s easy: mapping an empty array just produces
    a new empty array. Mapping a non-empty array can be done by first applying the
    mapping function to the first element of the array, then recursively mapping the
    rest of the array, and finally producing a single array accumulating both results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on that idea, we can work out a simple initial version: let''s call it
    `mapR()` just to remember we are dealing with our own, recursive, version of `map()`.
    However, be careful: our polyfill has some bugs! We''ll deal with them one at
    a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Great! Our `mapR()` function seemingly produces the same results than `.map()`...
    but, shouldn't our callback function receive a couple more parameters, specifically
    the index at the array and the original array itself? Our implementation isn't
    quite ready yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the definition for the callback function for `.map()` at: [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating the appropriate index position will require an extra parameter for
    the recursion, but is basically simple: when we start out, we have `index=0`,
    and when we call our function recursively, it''s starting at position `index+1`.
    Accessing the original array requires yet another parameter, which will never
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Great! When you do recursion instead of iteration, you don't have access to
    an index, so if you need it (as in our case), you'll have to generate it on your
    own. This is an often used technique, so working out our `.map()` substitute was
    a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, having extra arguments in the function is not so good; a developer
    might accidentally provide them and then the results would be unpredictable. So,
    using another usual technique, let''s define an inner function, `mapLoop()`, to
    handle looping. This is, in fact, the usual way looping is achieved when you only
    use recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s only one pending issue: if the original array has some missing elements,
    they should be skipped during the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately, fixing that is simple -- and be glad that all the experience gained
    here will help us write the other functions in this section!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow! This was more than we bargained for, but we saw several techniques: replacing
    iteration with recursion, how to accumulate a result across iterations, how to
    generate and provide the index value -- good tips! Furthermore, writing filtering
    code will prove much easier, since we''ll be able to apply very much the same
    logic as for mapping. The main difference is that we use the callback function
    to decide whether an element goes into the output array, so the inner loop function
    is a tad longer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: OK, we managed to implement two of our basic higher-order functions with pretty
    similar recursive functions. What about others?
  prefs: []
  type: TYPE_NORMAL
- en: Other higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming `.reduce()` is, from the outset, a bit trickier, since you can decide
    to omit the initial value for the accumulator. Since we mentioned earlier that
    providing that value is generally better, let's work here under the assumption
    that it will be given; dealing with the other possibility wouldn't be too hard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base case is simple: if the array is empty, the result is the accumulator.
    Otherwise, we must apply the reduce function to the current element and the accumulator,
    update the latter, and then continue working with the rest of the array. This
    can be a bit confusing because of the ternary operators, but after all, we''ve
    seen, it should be clear enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, `.find()` is particularly apt for recursive logic, since
    the very definition of how you (attempt to) find something, is recursive on its
    own:'
  prefs: []
  type: TYPE_NORMAL
- en: You look at the first place you think of -- and if you find what you were seeking,
    you are done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you look at the other places, to see if what you seek is there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are only missing the base case, but that''s simple: if you have no places
    left, where to look into, then you know you won''t be successful in your search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Equivalently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can quickly verify that it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's finish with our pipelining function. The definition of a pipeline lends
    itself to a quick implementation.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to pipeline a single function, then that's the result of the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, if we want to pipeline several functions, then we must first apply
    the initial function, and then pass that result as input to the pipeline of the
    other functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can directly turn this into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify its correctness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Doing the same for composition is easy, except that you cannot use the spread
    operator to simplify the function definition and you'll have to work with array
    indices - work it out!
  prefs: []
  type: TYPE_NORMAL
- en: Searching and backtracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Searching for solutions to problems, especially when there is no direct algorithm
    and you must resort to trial-and-error, is particularly appropriate for recursion.
    Many of these algorithms fall into a scheme such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Out of many choices available, pick one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no options are available, you've failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you could pick one, apply the same algorithm, but find a solution to the
    rest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you succeed, you are done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, try another choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With small variants, you can also apply a similar logic to find a good--or possibly,
    optimum--solution to a given problem. Each time you find a possible solution,
    you match it with previous ones you might have found and decide which to keep.
    This may go on until all possible solutions have been evaluated, or until a good
    enough has been found.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many problems for which this logic applies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding a way out of mazes -- pick any path, mark it as *already followed*
    and try to find some way out of the maze that won''t re-use that path: if you
    succeed, you are done, and if not, go back to pick a different path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling out Sudoku puzzles -- if an empty cell can contain only a single number,
    then assign it; otherwise, run through all of the possible assignments and, for
    each one, recursively try to see if the rest of the puzzle can be filled out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing Chess -- where you aren't likely to be able to follow through all possible
    move sequences and so you rather opt for the best-estimated position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s apply these techniques for two problems: solving the *8 Queens* puzzle
    and traversing a complete file directory.'
  prefs: []
  type: TYPE_NORMAL
- en: The Eight Queens puzzle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Eight Queens* puzzle was invented in the XIX Century and requires placing
    eight chess queens on a standard chessboard. The special condition is that no
    queen may attack another -- implying that no pair of queens may share a row, column,
    or diagonal line. The puzzle may ask for any solution or, as we shall do it, for
    the total number of distinct solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The puzzle may also be generalized to *n queens*, by working on an *nxn* square
    board. It is known that there are solutions for all values of n, except n=2 (pretty
    simple to see why: after placing one queen, all of the board is threatened) and
    n=3 (if you place a queen on the center, all of the board is threatened, and if
    you place a queen on a side, only two squares are unthreatened--but they threaten
    each other, making it impossible to place queens on them).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start our solution with the top level logic. Because of the given rules,
    there will be a single queen in each column, so we use a `places()` array to take
    note of each queen''s row within the given column. The `SIZE` constant could be
    modified to solve a more general problem. We''ll count each found distribution
    of queens in the `solutions` variable. Finally, the `finder()` function will do
    the recursive search for solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we want to place a queen in a given row within a certain column, we must
    check if any of the previously placed queens was already placed on the same row,
    or in a diagonal with respect to it. Let''s write a `checkPlace(column, row)`
    function to verify if a queen can be safely placed in the given square. The most
    straightforward way is by using `.every()`, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This declarative fashion seems best: when we place a queen in a position, we
    want to make sure that every other previously placed queen is in a different row
    and diagonals. A recursive solution would have been possible, too, so let''s see
    that. How do we know that a square is safe?'
  prefs: []
  type: TYPE_NORMAL
- en: 'A base case is: when there are no more columns to check, the square is safe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the square is in the same row or diagonal as any other queen, it's not safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we have checked a column, and found no problem, we can recursively now check
    the following one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The code works, but I wouldn''t be using that since the declarative version
    is clearer. Anyway, having worked out this check, we can pay attention to the
    main `finder()` logic, which will do the recursive search. The process proceeds
    as we described at the beginning: trying out a possible placement for a queen,
    and if that is acceptable, using the same search procedure to try and place the
    remaining queens. We start at column 0, and our base case is when we reach the
    last column, meaning that all queens have been successfully placed: we can print
    out the solution, count it, and go back to search for a new configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Check out how we use `.map()` and a simple arrow function to print the rows
    of the queens, column by column, as numbers between 1 and 8, instead of 0 and
    7\. In Chess, rows are numbered from 1 to 8 (and columns from *a* to *h*, but
    that doesn't matter here).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The inner `testRowsInColumn()` function also fulfills an iterative role, but
    recursively. The idea is to attempt placing a queen in every possible row, starting
    at zero: if the square is safe, `finder()` is called to start searching from the
    next column onward. No matter whether a solution was or wasn''t found, all rows
    in the column are tried out, since we are interested in the total number of solutions;
    in other search problems, you might be content with finding just any solution
    and you would stop your search right there.'
  prefs: []
  type: TYPE_NORMAL
- en: We have come this far, let's find the answer to our problem!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Each solution is given as the row positions for the queens, column by column
    -- and there are 92 solutions in all.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing a tree structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data structures, which include recursion in their definition, are naturally
    appropriate for recursive techniques. Let''s consider here, for example, how to
    traverse a complete file system directory, listing all of its contents. Where''s
    the recursion? The answer follows if you consider that each directory can do either
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Be empty -- a base case, in which there's nothing to do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include one or more entries, each of which is either a file or a directory itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s work out a full recursive directory listing -- meaning, when we encounter
    a directory, we proceed to also list its contents and, if those include more directories,
    we also list them, and so on. We''ll be using the same Node.js functions as in
    `getDir()` (from the *Building Pipelines by Hand* section in [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining And Composition*), plus a few more in order
    to test whether a directory entry is a symbolic link (which we won''t follow,
    to avoid possible infinite loops), a directory (which will require a recursive
    listing), or a common file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The listing is long but correct. I opted to list the `/boot` directory in my
    own OpenSUSE Linux laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, we may apply the same structure to a similar problem: traversing
    a DOM structure. We could list all of the tags, starting from a given element,
    by using essentially the same approach: we list a node, and (by applying the same
    algorithm) all of its children. The base case is also the same as before: when
    a node has no children, no more recursive calls are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `depth` variable to know how many *levels below* the original
    element we are. We could also use it to make the traversing logic stop at a certain
    level, of course; in our case, we are using it only to add some bars and spaces
    to appropriately indent each element, according to its place in the DOM hierarchy.
    The result of this function is as follows. It would be easy to list more information
    and not just the element tag, but I wanted to focus on the recursive process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there''s an ugly point there: why are we doing a loop to go through
    all of the children? We should know better! The problem is that the structure
    we get from the DOM isn''t really an array. However, there''s a way out: we can
    use `Array.from()` to create a real array out of it, and then write a more declarative
    solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Writing `[...node.children].forEach()` would have worked as well, but I think
    using `Array.from()` makes it clearer to the would-be reader that we are trying
    to make an array out of something that looks like one, but really isn't.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While recursion is a very good technique, it may face some problems due to details
    in the actual implementations. Each function call, recursive or not, requires
    an entry in the internal JS stack. When you are working with recursion, each recursive
    call itself counts as another call and you might find some situations in which
    your code will crash and throw an error, due to having run out of memory, just
    because of multiple calls. On the other hand, with most current JS engines, you
    can probably have several thousand pending recursive calls without a problem (but
    with earlier browsers and smaller machines, the number could drop into the hundreds
    and could imaginably go even lower), so it could be argued that at present, you
    are not likely to suffer from any particular memory problems.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, let's review the problem and go over some possible solutions because,
    even if you don't get to actually apply them, they represent valid FP ideas for
    which you may find place in yet other problems.
  prefs: []
  type: TYPE_NORMAL
- en: Tail call optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When is a recursive call not a recursive call? Put in this way, the question
    may make little sense, but there''s a common optimization --for other languages,
    alas, but not JS!-- which explains the answer. If the recursive call is the very
    last thing a function will do, then the call could be transformed to a simple
    jump to the start of the function, without needing to create a new stack entry.
    (Why? The stack entry wouldn''t be required: after the recursive call is done,
    the function would have nothing else to do, so there was no need to further save
    any of the elements that had been pushed into the stack on entering the function.)
    The original stack entry would then no longer be needed and could simply be replaced
    by a new one, corresponding to the recent call.'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that a recursive call, a quintessential FP technique, is being implemented
    by a base imperative `GO TO` statement, may be considered an ultimate irony!
  prefs: []
  type: TYPE_NORMAL
- en: These calls are known as *tail calls* (for obvious reasons) and imply higher
    efficiency, not only because of the saved stack space, but also because a jump
    is quite faster than any alternative. If the browser implements this enhancement,
    it is doing a *Tail Call Optimization*, or TCO for short. However, a glance at
    compatibility tables at [http://kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)
    shows that now (mid-2017), the only browser that provides TCO is Safari.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d80bc118-3f87-4478-b8e2-9291a1c7361a.png)Figure 9.3\. To understand
    this joke, you must previously understand it!'
  prefs: []
  type: TYPE_NORMAL
- en: '(Note: this XKCD comic is available online at https://xkcd.com/1270/.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a simple (though non-standard) test that lets you to verify if your
    browser provides TCO. (I found this snippet of code at several places on the web,
    but I''m sorry to say I cannot attest to the original author. However, I believe
    it is Csaba Hellinger, from Hungary.) Calling `detectTCO()` lets you know if your
    browser does or does not use TCO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Error().stack` result is not a JS standard, but modern browsers support
    it, albeit in somewhat different ways. In any case, the idea is that when a function
    with a long name calls another function with a shorter name, the stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: Should get shorter if the browser implements TCO, since the old entry for the
    longer named function would be replaced with the entry for the shorter named one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should get longer without TCO, since a complete new stack entry would be created,
    without doing away with the original one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I''m using Chrome at my Linux laptop and I added a `console.log()` statement
    to show `Error().stack`. You can see that both stack entries (for `inner()` and
    `detectTCO()`) are *live*, so there''s no TCO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, there''s also another way of learning if your environment includes
    TCO: just try out the following function, which does nothing, with large enough
    numbers. If you manage to run it with numbers like, say, 100,000 or 1,000,000,
    you may be fairly sure that your JS engine is doing TCO!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Let's finish this section with a very short quiz, to be sure we understand what
    tail calls are. Is the recursive call in the factorial function that we saw in
    [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional-
    Several Questions*, a tail call?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Think about it, because the answer is important! You might be tempted to answer
    in the affirmative, but the correct answer is a *no*. There''s good reason for
    this, and it''s a key point: after the recursive call is done, and the value for
    `fact(n-1)` has been calculated, the function *still* has work to do. (So, doing
    the recursive call wasn''t actually the last thing the function would do.) You
    would see it more clearly if you wrote the function in this equivalent way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So... the takeaways from this section should be two: TCO isn''t usually offered
    by browsers, and even if it were, you may not take advantage of it if your calls
    aren''t actual tail calls. Now that we know what the problem is, let''s see some
    FP ways of working around it!'
  prefs: []
  type: TYPE_NORMAL
- en: Continuation passing style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we have recursive calls stacked too high, we already know that our logic
    will fail. On the other hand, we know that tail calls should alleviate that problem...
    but don't, because of browser implementations! However, there's a way out for
    this. Let's first consider how we can transform recursive calls into tail calls,
    by using a well-known FP concept, *continuations*, and we'll leave the problem
    of solving TCO limitations for the next section. (We mentioned continuations in
    the *Callbacks, promises, and continuations* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out With Functions - A Core Concept*, but we didn't go into detail at
    that point.)
  prefs: []
  type: TYPE_NORMAL
- en: In FP parlance, a *continuation* is something that represents the state of a
    process and allows processing to continue. This may be too abstract, so let's
    get down to earth for our needs. The key idea is that, when you call a function,
    you also provide it with a continuation (in reality, a simple function) which
    will be called at return time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a trivial example. Suppose you have a function that returns the
    time of the day, and you want to show that on the console. The usual way to do
    it could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were doing CPS (**Continuation Passing Style**), you would pass a continuation
    to the `getTime()` function. Instead of returning a calculated value, the function
    would invoke the continuation, giving it the value as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s the difference? The key is that we can apply this mechanism to make
    a recursive call into a tail call because all of the code *that comes after* will
    be provided in the recursive call itself. To make this clear, let''s revisit the
    factorial function, in the version that made it explicit that we weren''t doing
    tail calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add a new parameter to the function, for the continuation. What do
    we do with the result of the `fact(n-1)` call? We multiply it by `n`, so let''s
    provide a continuation that will do just that. I''ll rename the factorial function
    to `factC()` to make it clear we are working with continuations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'How would we get the final result? Easy: we can call `factC()` with a continuation
    that will just return whatever it''s given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In FP, a function that returns its argument as result is usually called `identity()`
    for obvious reasons. In combinatory logic (which we won't be using), we would
    speak of the **I** combinator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you understand how it worked? Let''s then go for a more complex case, with
    the Fibonacci function, which has *two* recursive calls in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is trickier: we call `fibC()` with `n-2`, and a continuation that says
    that whatever that call returned, then, call `fibC()` with `n-1`, and when *that*
    call returns, then sum the results of both calls and pass that result to the original
    continuation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s just see one more example, one that involves a loop with an undefined
    number of recursive calls, and by then, you should have some idea about how to
    apply CPS to your code -- though I''ll readily admit, it can become really complex!
    We saw this function in the *Traversing a Tree Structure*section earlier in this
    chapter. The idea was to print out the DOM structure, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The function we ended designing was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by making this fully recursive, getting rid of the `forEach()`
    loop. We have seen this technique before, so we can just move on to the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to add a continuation to `traverseDom3()`. The only difference
    with the previous cases is that the function doesn''t return anything, so we won''t
    be passing any arguments to the continuation. Also, it''s important to remember
    the implicit `return` at the end of the `traverseChildren()` loop: we must call
    the continuation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We opted to give a default value to `cont`, so we can simply call `traverseDom3C(document.body)`
    as before. If we try out this logic, it works -- but the problem with the potential
    high number of pending calls hasn't been solved; let's look for a solution for
    that now.
  prefs: []
  type: TYPE_NORMAL
- en: Trampolines and thunks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the last key to our problem, we shall have to think about the cause of the
    problem. Each pending recursive call creates a new entry stack. Whenever the stack
    gets too empty, the program crashes and your algorithm is history. So, if we can
    work out a way to avoid the stack growth, we should be free. The solution, in
    this case, is quite sonorous and requires thunks and a trampoline -- let's see
    what these are!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a *thunk* is really quite simple: it''s just a nullary function (so,
    with no parameters) that helps delay a computation, providing for a form of *lazy
    evaluation*. If you have a thunk, unless you call it, you won''t get its value.
    For example, if you want to get the current date and time in ISO format, you could
    get it with `new Date().toISOString()`. However, if you provide a thunk that calculates
    that, you won''t get the value until you actually invoke it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: What's the use of this? The problem with recursion is that a function calls
    itself, and calls itself, and calls itself, and so on until the stack blows over.
    Instead of directly calling itself, we are going to have the function return a
    thunk -- which, when executed, will actually recursively call the function. So,
    instead of having the stack grow more and more, it will actually be quite flat,
    since the function will never get to actually call itself -- the stack will grow
    by one position, when you call the function, and then get back to its size, as
    soon as the function returns its thunk.
  prefs: []
  type: TYPE_NORMAL
- en: But... who gets to do the recursion? That's where the concept of a *trampoline*
    gets in. A trampoline is just a loop that calls a function, gets its return, and
    if it is a thunk, then it calls it, so recursion will proceed -- but in a flat,
    linear, way! The loop is exited when the thunk evaluation returns an actual value,
    instead of a new function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How can we apply this to an actual function? Let's start with a simple one,
    that just sums all numbers from 1 to n, but in a recursive, guaranteed-to-cause-stack-crash,
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The stack problem will come up sooner or later depending on your machine, your
    memory size, and so on, but it will come, no doubt about that. Let's rewrite the
    function in continuation passing style, so it will become tail recursive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s apply a simple rule: whenever you are going to return from a call,
    instead return a thunk that will, when executed, do the call that you actually
    wanted to do.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Whenever there would have been a call to a function, we now return a thunk.
    How do we get to run this function? This is the missing detail. You need an initial
    call that will invoke `sumAllT()` a first time and (unless the function was called
    with a zero argument) a thunk will be immediately returned. The trampoline function
    will call the thunk, and that will cause a new call, and so on until we eventually
    get a thunk that simply returns a value, and then the calculation will be ended.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, you wouldn''t probably want a separate `sumAllT()` function, so you''d
    go for something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s only one problem left: what would we do if the result of our recursive
    function wasn''t a value, but rather a function? The problem there would be on
    the `trampoline()` code that, as long as the result of the thunk evaluation is
    a function, goes back again and again to evaluate it. The simplest solution would
    be to return a thunk, but wrapped in an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The difference now would be that, instead of returning a thunk, you'd write
    something as `return (v) => new Thunk(() => cont(v+n))`, so our new trampolining
    function can now distinguish an actual thunk (meant to be invoked and executed)
    from any other kind of result (meant to be returned).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you happen to have a really complex algorithm, for which a recursive
    solution is best, but that won''t run because of stack limits, you can fix it
    in a reasonable way by:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing all recursive calls to tail recursion, by using continuations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replacing all return statements so they'll return thunks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replacing the call to the original function with a trampoline call, to start
    the calculations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, this doesn't come free. You'll notice that, when using this mechanism,
    there's extra work involving returning thunks, evaluating them, and so on, so
    you can expect the total time to go up. Nonetheless, this is a cheap price to
    pay if the alternative is having a non-working solution to a problem!
  prefs: []
  type: TYPE_NORMAL
- en: Recursion elimination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s yet one other possibility you might want to explore, but that falls
    beyond the realm of FP, and rather into algorithm design. It''s a computer science
    fact that any algorithm that is implemented using recursion has an equivalent
    version that doesn''t use recursion at all and rather depends on a stack. There
    are ways to systematically transform recursive algorithms into iterative ones,
    so if you run out of all options (meaning: not even continuations or thunks help
    you) then you''d have a final opportunity, by replacing all recursion with iteration.
    We won''t be getting into it --as I said, this elimination has little to do with
    FP-- but it''s important to know that the tool exists and you might be able to
    use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9.1\. **Into reverse**. Can you program a `reverse()` function, but implement
    it in a recursive fashion? Obviously, the best way to go about this would be using
    the standard String `.reverse()` method, as detailed in [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse),
    but that wouldn't do as a question on recursion, would it...?
  prefs: []
  type: TYPE_NORMAL
- en: 9.2\. **Climbing steps**. Suppose you want to climb up a ladder with *n* steps.
    At each time, you may opt to take 1 or 2 steps. In how many different ways can
    you climb up that ladder? As an example, you may climb a four steps ladder in
    five different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Always taking one step at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always taking two steps at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking two steps first, then one, and again one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking one step first, then two, and then one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking one step first, then another one, and finishing with two
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '9.3\. **Longest common subsequence**. A classic dynamic programming problem
    is as follows: given two strings, find the length of the longest subsequence present
    in both of them. Be careful: we define a subsequence as a sequence of characters
    that appear in the same relative order but not necessarily next to each other.
    For example, the longest common subsequence of INTERNATIONAL and CONTRACTOR is
    N...T...R...A...T...O. Try it out with or without memoizing and see the difference!'
  prefs: []
  type: TYPE_NORMAL
- en: 9.4\. **Symmetrical queens**. In the Eight Queens puzzle that we solved above,
    there is only one solution which shows symmetry in the placement of the queens.
    Can you modify your algorithm to find it?
  prefs: []
  type: TYPE_NORMAL
- en: 9.5\. **Sorting recursively**. There are many sorting algorithms that can be
    described with recursion; can you implement them?
  prefs: []
  type: TYPE_NORMAL
- en: '**Selection sort**: find the maximum element of the array, remove it, recursively
    sort the rest, and then push the maximum element at the end of the sorted rest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Insertion sort**: take the first element of the array; sort the rest; finish
    by inserting the removed element into its correct place in the sorted rest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Merge sort**: divide the array into two parts; sort each one; finish by merging
    the two sorted parts into a sorted list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.6\. **Completing callbacks**. In our `findR()` function, we did not provide
    all possible parameters to the `cb()` callback. Can you fix that? Your solution
    should be along the lines of what we did for `map()` and other functions.
  prefs: []
  type: TYPE_NORMAL
- en: '9.7\. **Recursive logic**. We didn''t get to code `.every()` and `.some()`
    using recursion: can you do that?'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how we can use recursion, a basic tool in FP,
    as a powerful technique to create algorithms, for problems that would probably
    require far more complex solutions otherwise. We started by considering what is
    recursion and how to think recursively in order to solve problems, then moved
    on to see recursive solutions to several problems in different areas, and ended
    by analyzing potential problems with deep recursion and how to solve them.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml), *Ensuring Purity
    - Immutability*, we shall get back to a concept we saw earlier in the book, function
    purity, and see some techniques that will help us guarantee that a function won't
    do any side effects, by ensuring the immutability of arguments and data structures.
  prefs: []
  type: TYPE_NORMAL
