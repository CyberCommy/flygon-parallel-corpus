- en: Building a Location Tracking App Using GPS and Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a location tracking app that saves the location
    of the user and display it as a heat map. We will look at how to run tasks in
    the background on iOS and Android devices and how to use custom renderers to extend
    the functionality of Xamarin.Forms maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracking the location of a user in the background on an iOS device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking the location of a user in the background on an Android device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to show maps in a Xamarin.Forms app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extend the functionality of Xamarin.Forms maps with custom renderers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to complete the project, you need to have Visual Studio for Mac or
    PC installed, as well as the Xamarin components. See [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin*, for more details on how to set up your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many apps could be made richer by adding a map and location services. In this
    project, we will build a location tracking app that we will call **MeTracker**.
    The app will track the position of the user and save it to an SQLite database
    so we can visualize the result in the form of a heat map. To build this app, we
    will learn how to set up processes in the background, on both iOS and Android, because
    we cannot share code between iOS and Android. For the map, we will use the `Xamarin.Forms.Maps`
    component and extend its functionality in order to build a heat map. To do this,
    we will use a custom renderer for iOS and a custom renderer for Android so that
    we can use the platform APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use either Visual Studio 2017 on a PC or Visual Studio for Mac to do
    this project. To build an iOS app using Visual Studio for PC, you have to have
    a Mac connected. If you don't have access to a Mac at all, you can just do the
    Android part of this project.
  prefs: []
  type: TYPE_NORMAL
- en: Building the MeTracker app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to start building the app. Create a **Mobile App (Xamarin.Forms)**.
    We will find that template under the **Cross-Platform** ta in the New Project
    dialog. We will name the project `MeTracker`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f1e8d6f-a293-4877-b4b6-c3ab000085f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Use .NET Standard as the code sharing strategy and select iOS and Android as
    the platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aec81384-04d7-4520-a668-6571e93d02ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Make sure that you are compiling using Android version Oreo (API level 26) or
    higher. We can set this in the project Properties under the Applicationtab.
  prefs: []
  type: TYPE_NORMAL
- en: Update the NuGet packages that was added by the template to make sure that we
    use the latest versions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repository to save the location of the users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we will do is create a repository that we can use to save the
    location of the users.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model for the location data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we create the repository, we will create a model class that will represent
    a user location by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder that we can use for this and other models, called `Models`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class with the name `Location` in the `Models` folder and add properties
    for the `Id`, the `Latitude`, and the `Longitude`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create two constructors, one empty and one that takes the `latitude` and `longitude`
    as arguments, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have created a model, we can move on to creating the repository.
    First, we will create an interface for the repository by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker` project, create a new folder, called `Repositories`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our new folder, we will create an interface that we will call `ILocationRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code in the new file that we created for the `interface`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Add a `using` directive for `MeTracker.Models` and `System.Threading.Tasks` to
    resolve the references for `Location` and `Task`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we have an `interface`, we need to create an implementation of it by going
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker` project, create a new class with the name `LocationRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `ILocationRepository` interface and add the `async` keyword to
    the `Save`method using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To store the data, we will use an SQLite database and the **object relational
    mapper** (**ORM**), SQLite-net, so that we can write code against a domain model
    instead of using SQL for operations against the database. This is an open source
    library created by Frank A. Krueger. Let''s set this up by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the NuGet package, `sqlite-net-pcl`, for the `MeTracker` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Location` model class and add a `PrimaryKeyAttribute` and an `AutoIncrementAttribute`
    to the `Id` property. When we add the attributes, the `Id` property will be a
    primary key in the database, and a value for it will automatically be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code in the` LocationRepository` class to create a connection
    to the SQLite database. The `if` statement is to check whether we have already
    created a connection. If this is the case, we will not create a new one; we will
    instead use the connection that we already created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to implement the `Save` method, which will take a location object
    as a parameter and store it in the database.
  prefs: []
  type: TYPE_NORMAL
- en: We will now use the `CreateConnection`method in the `Save` method so we can
    be sure that a connection is created when we try to save data to the database.
    When we know that we have an active connection, we can just use the `InsertAsync`
    method and pass the `location` parameter of the `Save` method as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `Save` method in the `LocationRepository` class to look like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Xamarin.Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Xamarin.Essentials** is a library that was created by Microsoft and Xamarin
    to make it possible for developers to use platform-specific APIs from shared code. Xamarin.Essentials targets Xamarin.iOS, Xamarin.Android, and UWP.
    In this project, we will use Xamarin.Essentials for various tasks, including getting
    a location and executing code on the main thread.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the NuGet package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, Xamarin.Essentials is in preview. To find the NuGet
    packages in preview, we will have to check the Include Prerelease checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Xamarin.Essentials on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to initialize Xamarin.Essentials on Android by calling an initialization
    method. We do this by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Android project, open the `MainActivity.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code in bold under the `global::Xamarin.Forms.Forms.Init` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We are all good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service for location tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To track a user's location, we need to write the code according to the platform.
    Xamarin.Essentials has methods for getting the location of a user in shared code,
    but it cannot be used in the background. To be able to use the code that we will
    write for each platform, we need to create an interface. For the `ILocationRepository`
    interface, there will be just one implementation that will be used on both platforms,
    whereas for the location tracking service, we will have one implementation for
    the iOS platform and one for the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go through the following steps to create the `ILocationRepository` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker` project, create a new folder and name it `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new interface in the `Services` folder with the name `ILocationTrackingService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the interface, add a method called `StartTracking` as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For the moment, we will just create an empty implementation of the interface
    in both the iOS and the Android projects by going through the following steps.
    We will come back to each implementation later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder named `Services `in both the iOS and Android projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an empty implementation as shown in the following code, in a class called `LocationTrackingService`
    in the new `Service` folder in both the iOS and Android projects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the app logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now created the interfaces we need to track the location of the user
    and save it locally on the device. It's time to write code to start the tracking
    of a user. We still don't have any code that actually tracks the location of the
    user, but it will be easier to write this if we have already written the code
    that starts the tracking.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a view with a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with, we will create a view with a simple map that is centered on
    the position of the user. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker` project, create a new folder called `Views`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Views` folder, create a XAML-based `ContentPage` and name it `MainView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5888007b-7310-4c28-813f-7e9458ad3da0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Xamarin.Forms package has no map controls, but there is an official package
    from Microsoft and Xamarin that can be used to show maps in a Xamarin.Forms app.
    This package is called `Xamarin.Forms.Maps`, and we can install it from NuGet
    by following the steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `Xamarin.Forms.Maps` in the `MeTracker`, `MeTracker.Android`, and `MeTracker.iOS`
    projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the namespace for `Xamarin.Forms.Maps` to the `MainView` using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the map in our view. Because we want the `Map` to cover the
    whole page, we can add it to the root of the `ContentPage`. Let''s set this up
    by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `map` to the `ContentPage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the map a name so we can access it from the code-behind. Name it `Map`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the `map` control, we need to run code on each platform to initialize
    it by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the iOS project, go to `AppDelegate.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `FinishedLaunching` method, after the `Init` of `Xamarin.Forms`, add
    `global::Xamarin.FormsMaps.Init()` to initialize the `map` control for the iOS
    app using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue with to initialize it for Android:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Android project, go to `MainActivity.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `OnCreate` method, after the `Init` of `Xamarin.Forms`, add `global::Xamarin.FormsMaps.Init(this, savedInstanceState)`to
    initialize the `map` control for iOS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize Xamarin.Essentials by using   `Xamarin.Essentials.Platform.Init(this, savedInstanceState)` as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For Android, we also need to decide what happens when a user has answered a
    request for permission dialog and send the result to Xamarin.Essentials. We will
    do that by adding the following code to `MainActivity.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For Android, we will need an **API key** for Google Maps in order to get the
    maps to work. The Microsoft documentation about how to obtain an API key can be
    found at [https://docs.microsoft.com/en-us/xamarin/android/platform/maps-and-location/maps/obtaining-a-google-maps-api-key](https://docs.microsoft.com/en-us/xamarin/android/platform/maps-and-location/maps/obtaining-a-google-maps-api-key).
    Here''s how we go about obtaining the API key:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `AndroidMainfest.xml`, which is located in the `Properties` folder in the
    Android project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert a metadata element as a child of the application element, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want the map to be centered on the position of the user. We will do
    this in the constructor of the `MainView.xaml.cs`. Because we want to run the
    fetching of the user''s location asynchronously and it needs to be executed on
    the main thread, we will wrap it in `MainThread.BeginInvokeOnMainThread`. To get
    the current location of the user, we will use Xamarin.Essentials. When we have
    the location, we can use the `MoveToRegion` method of the `Map`.  We can set this
    up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker` project, open `MainView.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code in bold in the following code fragment to the constructor of the
    `MainView.xaml.cs` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating a ViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we create an actual view model, we will create an abstract base view
    model that all view models can inherit from. The idea behind this base view model
    is that we can write common code in it. In this case, we will implement the `INotifyPropertyChanged`
    interface by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder with the name `ViewModels` in the `MeTracker` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code and resolve all references:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the actual view model that will use `ViewModel`
    as a base class. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker` project, create a new class called `MainViewModel` in the
    `ViewModels` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the `MainViewModel` inherit the `ViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a read-only field of the `ILocationTrackingService` type and name it `locationTrackingService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a read-only field of the `ILocationRepository` type and name it `locationRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a constructor with the `ILocationTrackingService` and the `ILocationRepository`
    as parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the values of the fields that we created in *step* *3* and *step* *4* with
    the values from the parameters, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make the iOS app start tracking the location of a user, we need
    to run the code that starts the tracking on the main thread by going through the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor of the newly created `MainViewModel`, add an invocation to
    the main thread using `MainThread.BeginInvokeOnMainThread` from Xamarin.Essentials.
    Xamarin.Forms has a helper method for invoking code on the main thread, but if
    we use the one from Xamarin.Essentials, we can have a view model without any dependencies on
    Xamarin.Forms. If we do not have any dependencies to Xamarin.Forms in the ViewModels
    we can reuse them in apps where we not using Xamarin.Forms if we will add other
    platforms in the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call `locationService.StartTracking` in the action that we pass to the `BeginInvokeOnMainThread`
    method, shown in the following code marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to inject a `MainViewModel` into the constructor of the `MainView`
    and assign the `MainViewModel` instance to the binding context of the view by
    going through the following steps. This will allow the data binding to be processed,
    and the properties of `MainViewModel` will be bound to the controls in the user
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker` project, go to the constructor of the `Views/MainView.xaml.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `MainViewModel` as a parameter of the constructor and call it `viewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set `BindingContext`to the instance of the `MainViewModel`, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating a resolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using dependency injection in this project, for which we will use
    a library called Autofac.Autofac is an open source **inversion of control** (**IoC**)
    container. We will create a `Resolver` class in order to easily resolve types
    that we will add to the container later in this chapter. To do so, we will go
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Autofac from NuGet in the `MeTracker`, `MeTracker.Android`, and `MeTracker.iOS `projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `MeTracker` project, create a new class called `Resolver` in the root
    of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `private static IContainer` field called `container`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `static` method called `Initialized` that has an `IContainer` argument
    and set the value of the `container` field as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `Initialize` method will be called after the configuration of Autofac is
    complete, which we will do when we create the bootstrapper. This method simply
    takes the `container` that it gets as an argument and stores it in the `static`
    container field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a method to access it from. Create one more `static` method, called
    `Resolve`. This method will be generic, and when we use it, we will specify its
    type as the type that will be resolved. Use the `container` field to resolve the
    type as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `Resolve<T>` method takes a type as an argument and looks in the container
    to see whether there is any information on how to construct this type. If there
    is, then we return it.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we have the `Resolver` that we will use to resolve instances of
    types of objects, we need to configure it. That's the job of the bootstrapper.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the bootstrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure the dependency injection and initialize the `Resolver`, we will
    create a bootstrapper. We will have one shared bootstrapper, as well as other
    bootstrappers for each platform to meet their specific configurations. The reason
    that we need them to be platform-specific is that we will have different implementations
    of the `ILocationTrackingService` on iOS and Android. To create a bootstrapper,
    we go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class in the `MeTracker` project and name it `Bootstrapper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code in the new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Creating the iOS bootstrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the iOS bootstrapper, we will have configurations that are specific to the
    iOS app. To create an iOS app, we go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the iOS project, create a new class and name it `Bootstrapper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the new class inherit from `MeTracker.Bootstrapper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Go to `AppDelegate.cs` in the iOS project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before the call to `LoadApplication`, in the `FinishedLaunching` method, call
    the `Init` method of the platform-specific bootstrapper, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Android bootstrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Android bootstrapper, we will have configurations that are specific
    to the Android app. To create the bootstrapper in Android, we go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Android project, create a new class and name it `Bootstrapper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the new class inherit from `MeTracker.Bootstrapper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Go to the `MainActivity.cs` file in the Android project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before the call to `LoadApplication`, in the `OnCreate` method, call the `Init` method
    of the platform-specific bootstrapper, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Setting the MainPage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step before we can start the app for the first time is to set the
    `MainPage` property in the `App.xaml.cs` file by going through the following steps.
    But first, we can delete the `MainPage.xaml` file and the `MainPage.xaml.cs` file
    that we created when we started the project because we are not using them here:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the `MainPage.xaml` and the `MainPage.xaml.cs` in the `MeTracker` project,
    since we will be setting our `MainView` as the first view that the user sees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Resolver` to create an instance of the `MainView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `MainPage` in the constructor to the instance of the `MainView`, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The resolver uses Autofac to figure out all the dependencies we need in order
    to create a `MainView` instance. It looks at the constructor of the `MainView`
    and decides that it requires a `MainViewModel`. If the `MainViewModel` has further
    dependencies, then the process iterates through all those dependencies and builds
    all the instances we need.
  prefs: []
  type: TYPE_NORMAL
- en: We will now be able to run the app. It will be showing us a map centered at
    the current location of the user. We will now add code to track the location over
    time using background location tracking.
  prefs: []
  type: TYPE_NORMAL
- en: Background location tracking on iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for location tracking is something that we need to write for each platform.
    For iOS, we will use the `CLLocationManager` from the `CoreLocation` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling location updates in the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we want to perform tasks in the background in an iOS app, we need to declare
    what we want to do in the `info.plist` file. The following steps show how we go
    about it:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker.iOS` project, open `info.plist`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Capabilities tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Enable Background Modes and Location updates, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d435c61a-a1ae-4858-9b37-45fa9be0f004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also enable background modes directly in the `info.plist` file, if we
    open it with an XML editor. In this case, we will add the following XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Getting permissions to use the location of the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can request permissions for using the location of the user, we need
    to add a description of what we will use the location for. Since the introduction
    of iOS 11, we are no longer allowed to just ask for permission to track the location
    of the user all the time; the user has to be able to give us permission to only
    track their location while they are using the app. We will add the description
    to the `info.plist` file by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `info.plist` with the XML (text) editor that can be found in the `MeTracker.iOS`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the key, `NSLocationWhenInUseUsageDescription`, with a description.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the key, `NSLocationAlwaysAndWhenInUsageDescription`, with a description,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Subscribing to location updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have prepared the `info.plist` file for location tracking, it is
    time to write the actual code that will track the location of the user. If we
    don''t set the `CLLocationManager` to not pause location updates, location updates
    can be paused automatically by iOS when the location data is unlikely to change.
    In this app, we don''t want that to happen because we want to save the location
    multiple times so that we can establish whether a user visits a particular location
    frequently. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker.iOS` project, open the `LocationTrackingService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a private field for the `CLLocationManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `CLLocationMananger` in the `StartTracking` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `PausesLocationUpdatesAutomatically` to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set `AllowBackgroundLocationUpdates` to `true`(as shown in the following code)so
    that the location updates will continue even when the app is running in the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to ask the user for permission to track their location. We
    will request permission to track their location all the time, but the user has
    the option of only giving us permission to track their location when they are
    using the app. Because the user also has the option of denying us permission to
    track their location, we need to check before we start to. Let''s set this up
    by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an event listener for when the authorization is changed by hooking up the
    `AuthorizationChanged` event on the `locationManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the event listener, create an `if` statement to check whether the user allows
    us to track their location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `RequestAlwaysAuthorization` method of the instance that we recently
    created in the `CLLocationManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should be placed under the `// Add code here` comment, as shown in
    bold in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we start to track the location of the user, we will set the accuracy
    of the data that we want to receive from the `CLLocationManager`. We will also
    add an event handler to handle the location updates. Let''s set this up by going
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `DesiredAccuracy` to `CLLocation.AccurracyBestForNavigation`. One of
    the constraints when running the app in the background is that the `DesiredAccuracy`
    needs to be set to either `AccurracyBest` or `AccurracyBestForNavigation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an event handler for `LocationsUpdated` and, after that, call the `StartUpdatingLocation`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should be placed at the `// Next section goes here` comment, and it
    should look like the code in bold in the following fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The higher the accuracy we set, the higher the battery consumption. If we only
    want to track where the user has been and not how popular a place is, we could
    also set `AllowDeferredLocationUpdatesUntil`. This way, we can specify that the
    user has to move a specific distance before the location is updated. We can also
    specify how often we want locations to be updated using the `timeout` argument.
    The most power-efficient solution to track how long a user has been at a place
    is to use the  `StartMonitoringVisits` method of `CLLocationManager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to handle the `LocationsUpdated` event. Let''s go through the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a private field with the name `locationRepository` that is of the `ILocationRepository `type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a constructor that has `ILocationRepository` as a parameter. Set the value
    of the parameter to the `locationRepository` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the latest location of the `Locations` property on  `CLLocationsUpdatedEventArgs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `MeTracker.Models.Location` and pass the latitude
    and longitude of the latest location to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the location using the `Save` method of the `ILocationRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should be placed at the `// Final block of code goes here` comment,
    and it should look like the code in bold in the following fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have completed the tracking part of the app for iOS. We will now implement
    background tracking for Android. After this, we will visualize the data.
  prefs: []
  type: TYPE_NORMAL
- en: Background location tracking with Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android way to carry out background updates is very different from how we
    implemented this with iOS. With Android, we need to create a `JobService` and
    schedule it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the required permissions to use the location of the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To track the location of the user in the background with Android, we need to
    request five permissions, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `ACCESS_COARSE_LOCATION` | To get an approximate location for the user |'
  prefs: []
  type: TYPE_TB
- en: '| `ACCESS_FINE_LOCATION` | To get a precise location for the user |'
  prefs: []
  type: TYPE_TB
- en: '| `ACCESS_NETWORK_STATE` | Because the location services in Android  use information
    from a network to determine the location of the user |'
  prefs: []
  type: TYPE_TB
- en: '| `ACCESS_WIFI_STATE` | Because the location services in Android use information
    from a Wi-Fi network to determine the location of the user |'
  prefs: []
  type: TYPE_TB
- en: '| `RECEIVE_BOOT_COMPLETED` | So that the background job can start again after
    the device is rebooted |'
  prefs: []
  type: TYPE_TB
- en: Permissions can be set either from the Android Manifest tab in the properties
    of the `MeTracker.Android` project or via the `AndroidManifest.xml` file in the
    `Properties` folder. When changes are made from the Android Manifest tab, the
    changes will be written to the `AndroidMainfest.xml` file as well, so it doesn't
    matter which method you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of setting the permissions in the Android Manifest
    tab in the properties of the `MeTracker.Android` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/783ecaab-f536-46f5-82ec-95ff0eefd4d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `uses-permission` elements should be added to the `manifest` element in
    the `AndroidManifest.xml`file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Creating a background job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To track the location of users in the background, we need to create a background
    job by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Android project, create a new class with the name `LocationJobService`
    in the `Services` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the class `public` and add `Android.App.Job.JobService` as a base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the abstract methods `OnStartJob` and `OnStopJob`, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'All services in an Android app need to be added to the `AndroidManifest.xml`
    file. We don''t have to do this manually; however, we can instead add an attribute
    to the class, which will then be generated in the `AndroidManifest.xml` file.
    We will use the `Name` and `Permission` properties to set the required information,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Scheduling a background job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have created a job, we can schedule it. We will do this from the `LocationTrackingService`
    in the `MeTracker.Android` project. To configure the job, we will use the `JobInfo.Builder`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `SetPersisted` method to ensure that the job starts again after
    a reboot. This is why we added the `RECEIVE_BOOT_COMPLETED` permission earlier.
  prefs: []
  type: TYPE_NORMAL
- en: To schedule a job, at least one constraint is needed. In this case, we will
    use `SetOverrideDeadline`. This will specify that the job needs to run before
    the specified time (in milliseconds) has elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetRequiresDeviceIdle` code phrase can be used to make sure that a job
    only runs when the device is not being used by a user. We could pass `true` to
    the method if we want to make sure that we don't slow down the device when the
    user is using it.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetRequiresBatteryNotLow` code phrase can be used to specify that a job
    should not run when the battery level is low. We recommend that this should always
    be set to `true` if you don't have a good reason to run it when the battery is
    low. This is because we don't want our applications to drain the user's battery.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s implement the `LocationTrackingService` that is found in the Android
    project in the `Services` folder by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `JobInfo.Builder` based on an ID that we specify (we will use `1` here)
    and on the component name (which we create from the application context and the
    Java class) in the `StartTracking` method. The component name is used to specify
    which code will run during the job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `SetOverrideDeadline` method and pass `1000` to it to make the job run
    before one second has elapsed from when the job was created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `SetPersisted` method and pass `true` to make the job persist even after
    the device is rebooted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `SetRequiresDeviceIdle` method and pass `false` so that the job will
    run even when a user is using the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `SetRequiresBatteryLow` method and pass `true` to make sure that we
    don't drain the user's battery. This method was added in Android API level 26.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code for the `LocationTrackingService` should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JobScheduler` service is a system service. To get an instance of a system
    service, we will use the application context by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `GetSystemService` method on the `Application.Context` to get the `JobScheduler`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cast the result to the `JobScheduler`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `Schedule` method on the `JobScheduler` class and pass the `JobInfo`
    object to schedule the job, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Subscribing to location updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have scheduled the job, we can write the code to specify what the job
    should do, which is track the location of a user. To do this, we will use the `LocationManager`,
    which is a `SystemService`. With the `LocationManager`, we can either request
    a single location update or we can subscribe to location updates. In this case,
    we want to subscribe to location updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating an instance of the `ILocationRepository` interface
    that we will use to save the locations to the SQlite database. Let''s set this
    up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a constructor for the `LocationJobService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a private read-only field for the `ILocationRepository` interface with
    the name `locationRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `Resolver` in the constructor to create an instance of the `ILocationRepository`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we subscribe to location updates, we will add a listener. To do this,
    we will use the `Android.Locations.ILocationListener`interface by going through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Android.Locations.ILocationListener` to the `LocationJobService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all instances of `throw new NotImplementedException();`, which is added
    to the methods, if you let Visual Studio generate the implementation of the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `OnLocationChanged` method, map the `Android.Locations.Location` object
    to the `Model.Location` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `Save` method on the `LocationRepository` class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have created a listener, we can subscribe for location updates by going
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `StartJob` method in the `LocationJobService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a static field of the `LocationManager` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the `LocationManager` by using the `GetSystemService` on the `ApplicationContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To subscribe for location updates, use the `RequestLocationUpdates` method,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The first argument that we pass to the `RequestLocationUpdates`method ensures
    that we get locations from the GPS. The second ensures that at least `1000` milliseconds will elapse
    between location updates. The third argument ensures that the user has to move
    at least `0.1` meters to get a location update. The last one specifies which listener
    we should use. Because the current class implements the `Android.Locations.ILocationListener`interface,
    we will pass `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a heat map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To visualize the data that we have collected, we will create a heat map. We
    will add lots of dots to a map and make them different colors, based on how much
    time a user spends in a particular place. The most popular places will have a
    warm color and the least popular places will have a cold color.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a GetAll method to the LocationRepository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to visualize the data, we need to write code so that is can be read
    from the database. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker` project, open the `ILocationRepository.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `GetAll` method, which returns a list of `Location` objects using the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the `MeTracker` project, open the`LocationRepository.cs` file, which implements
    the `ILocationRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the new `GetAll` method and return all the saved locations in the
    database, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Preparing the data for visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can visualize the data on the map, we need to prepare the data. The
    first thing we will do is create a new model that we can use for the prepared
    data. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Models` folder in the `MeTracker` project, create a new class and name
    it `Point`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add properties for the `Location`, the `Count`, and the `Heat`, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MainViewModel` will store the locations that we will find later on. Let''s
    add a property for storing the `Points` by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker` project, open the `MainViewModel` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `private` field with the name `points`, which has the `List<Point>` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a property with the name `Points` that has the `List<Point>` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `get` method, return the value of the `points` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `set` method, set the `points` field to the new value and call `RaisePropertyChanged` with
    the name of the property as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the end of the `LoadData` method, assign the `pointList` variable to the `Points` property,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the storage for our points, we must add code to add locations.
    We will do this by implementing the `LoadData` method of the `MainViewModel` class
    and making sure that it is called on the main thread right after the location
    tracking has started.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will do is to group the saved locations so that all locations
    within 200 meters will be handled as one point. We will track how many times we
    have logged a position within that point so we can later decide which color the
    point will be on the map. Let''s set this up using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an `async` method with the name LoadData, which returns a `Task` to the
    `MainViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the `LoadData` method from the constructor after the call to the `StartTracking`
    method on the `ILocationTrackingService`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step in the `LoadData` method is to read all tracked locations from
    the SQLite database. When we have all the locations, we will loop through them
    and create the points. To calculate the distance between a location and a point,
    we will use the `CalculateDistance` method from `Xamarin.Essentials.Location`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have a list of points, we can calculate the heat color for each point.
    We are going to use the **hue, s****aturation, and lightness** (**HSL**) representation
    of a color, as described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hue**:Hue is a degree on the color wheel that goes from 0 to 360, 0 being
    red and 240 being blue. Because we want our most popular places to be red (hot)
    and our least popular places to be blue (cold), we will calculate a value between
    0 and 240 for each point, based on how many times the user has been to that point.
    This means that we will only use two-thirds of the scale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saturation**:Saturation is a percentage value: 0% is a shade of gray, while
    100% is full color. In our app, we will always use 100% (this will be represented
    as `1` in the code).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lightness**: Lightness is a percentage value of the amount of light: 0% is
    black and 100% is white. We want it to be neutral, so we will use 50% (this will
    be represented as `0.5` in the code).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is find out how many times the user has
    been in the most popular and least popular places. We find this out by going through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, check that the list of points is not empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the `Min` and `Max` values for the `Count` property in the list of points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the difference between the minimum and the maximum values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should be added at the `// Next section of code goes` comment at the
    bottom of  the `LoadData` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now be able to calculate the heat for each point by going through the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Loop through all the points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the following calculation to calculate the heat for each point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should be added at the `// Last section of code goes here` comment
    at the bottom of the `LoadData()` method, as shown in bold in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: That's it for setting up location tracking in the `MeTracker` project. Let's
    turn our attention to visualizing the data we get.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom renderers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Custom renderers** are a powerful way to extend Xamarin.Forms. As mentioned
    in [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction to Xamarin*,
    Xamarin.Forms is built with renderers, so for each Xamarin.Forms control there
    is a renderer that creates a native control. By overriding an existing renderer
    or creating a new one, we can extend and customize how Xamarin.Forms controls
    are rendered to native controls. We can also use renderers to create new Xamarin.Forms
    controls from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: Renderers are platform specific, so when we create custom renderers, we have
    to create one for each platform that we want to change or use to extend the behavior
    of a control. To make our renderers visible for Xamarin.Forms, we will use the
    assembly attribute `ExportRenderer`. This contains information about which control
    the renderer is for and which renderer will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom control for the map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to show the heat map on our map, we will create a new control, for
    which we will use a custom renderer. We set this up by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker` project, create a new folder with the name `Controls`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class with the name `CustomMap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Xamarin.Forms.Maps.Map` as a base class to the new class, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to have properties that we want to bind data to, we need to create
    a `BindableProperty`. This should be a `public static` field in the class. We
    also need to create a *regular* property. The naming of the properties is really
    important. The name of the `BindableProperty` needs to be `{NameOfTheProperty}Property`;
    for example, the name of the `BindableProperty` that we will create in the following
    steps will be `PointsProperty`, because the name of the property is `Points`.
    A `BindableProperty` is created using the static `Create` method on the `BindableProperty`
    class. This requires at least four arguments, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`propertyName`:This is the name of the property as a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`returnType`: This is the type that will be returned from the property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`declaringType`:This is the type of the class in which the `BindableProperty`
    is declared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultValue`:This is the default value that will be returned if no value
    is set. This is an optional argument. If it is not set, Xamarin.Forms will use
    `null` as a default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `set` and `get` methods for the property will call methods in the base
    class to `set` or `get` values from the `BindableProperty`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeTracker` project, create a `BindableProperty` with the name `PointsProperty`,
    as shown in the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a property of the `List<Models.Point>` type with the name `Points`. Remember
    to cast the result of the `GetValue` as the same type as the property, because
    the `GetValue` will return the value as the type object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have created a custom map control, we will use it to replace the `Map`
    control in the `MainView` by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MainView.xaml` file, declare the namespace for the custom control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the `Map` control with the new control that we have created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a binding to the `Points` property in the `MainViewModel`, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '**# Creating a custom renderer to extend the map in the iOS app'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a custom renderer for iOS by going through the following
    steps. Because we want to extend the functionality, we will use the `MapRenderer`
    as a base class:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder with the name `Renderers` in the `MeTracker.iOS` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class in this folder and name it `CustomMapRenderer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `MapRenderer` as a base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `ExportRenderer` attribute, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When a property changes for the control that we are writing a custom renderer
    for, the `OnElementPropertyChanged` method is called. The method is a virtual
    method, which means that we can override it. We want to listen to any changes
    to the `Points` property in our `CustomMap` control.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Override the `OnElementPropertyChanged`method. This method will run every time
    a property value is changed in the element (the Xamarin.Forms control).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `if` statement to check that it is the `Points` property that has changed,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the heat map, we will add circles as overlays to the map, one circle
    for each point. Before we do this, however, we need to add some code to specify
    how an overlay should be rendered. Let''s set this up by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `mapView` variable. Cast the `Control` property to `MKMapView` and
    assign it to the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `customMap` variable. Cast the `Element` property to the `CustomMap`
    and assign it to the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an action using an expression with parameters for `MKMapView` and `IMKOverlay`and
    assign it to the `OverlayRenderer` property on the `map` view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cast the `overlay` parameter to `MKCircle` and assign it to a new variable called
    `circle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the circle variable is not `null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the point object from the point list on the `CustomMap` object using coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `MKCircleRenderer` object and pass the circle variable to the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `FillColor` property to the heat color of the point. Convert it to `UIColor`
    using the extension method `ToUIColor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Alpha` property to `1.0f` to make sure that the circle not will be
    transparent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the `circleRenderer` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return `null` if the circle variable is `null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should look like the bold code in the following fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We have implemented how we want each overlay of the map to be rendered. What
    we need to do now is to go through all the points we have gathered so far and
    create an `Overlay` for each one. Let''s set this up by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Loop through all the points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a circle overlay with the `static` method `Circle` on the `MKCircle`
    class, as shown in the following code. The first argument is the position of the
    `Circle` and the second one is the radius of the `Circle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the overlay to the map using the `AddOverlay` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should now look like the bold code in the following fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the section on how to extend the `Maps` control for iOS. Let's
    do the same for Android.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom renderer to extend the map in the Android app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create a custom renderer for Android. The structure is the same
    as the one we used for iOS. We will use the `ExportRenderer` attribute in the
    same way and we will also add the` MapRenderer` class as the base class. This,
    however, is the Android-specific `MapRenderer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a custom renderer for our `CustomMap` control. The renderer
    will inherit from the `MapRenderer` base class so that we can extend any existing
    functionality. To do this, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder with the name `Renderers` in the `MeTracker.Android` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class in this folder and name it `CustomMapRenderer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `MapRenderer` as a base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `ExportRenderer` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a constructor that has `Context` as a parameter. Pass the parameter to the
    constructor of the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Resolve all the references, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a map object to work with, we need to request it. We do this by overriding
    the `OnElementChanged` method that all custom renderers have. This method is called
    each time an element changes, such as when it''s set for the first time when parsing
    the XAML, or when it''s replaced in code. Let''s set this up by going through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Override the `OnElementChanged` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the `NewElement` property of the `ElementChangedEventArgs` is not `null`,
    request the map object with the `GetMapAsync` method on the `Control` property,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have a map to work with, the virtual `OnMapReady` method will be called.
    To add code of our own to handle this, we override this method by going through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a private field of the `GoogleMap` type and name it `map`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `OnMapReady` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign the new field with the parameter from the method body, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as we did with the iOS renderer, we need to handle changes in the `Points`
    property of our custom map. To do this, we override the `OnElementPropertyChanged`
    method that is called each time a property on the control we are writing our renderer
    for changes. Let''s do this by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Override the `OnElementPropertyChanged`method. This method will run every time
    a property value is changed in the `Element` (the Xamarin.Forms control).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `if` statement to check that it is the `Points` property that has changed,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add code to handle the specific event of the `Points` property being
    set by drawing the location out on the map. To do this, go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: For each point, create an instance of the `CircleOptions` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `InvokeStrokeWidth` method to set the stroke width of the circle to
    `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `InvokeFillColor` method to set the color of the circle. Use the `ToAndroid `extension
    method to convert the color to an `Android.Graphics.Color`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `InvokeRadius` method to set the size of the circle to `200`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `InvokeCenter` method to set where on the map the circle should be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the circle to the `map` using the `AddCircle` method on the `map` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should look the same as the bold code in the following fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Refreshing the map when resuming the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last thing we will do is to make sure that the map is up to date with the
    latest points when the app is resumed. The easiest way to do this is to set the
    `MainPage` property in the `App.xaml.cs` file to a new instance of `MainView`,
    in the same way as the constructor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built an app for iOS and Android that tracked the location
    of a user. When we built the app, we learned how to use maps in Xamarin.Forms
    and how to use location tracking running in the background. We also learned how
    to extend Xamarin.Forms with custom controls and custom renderers. With this knowledge,
    we can create applications that perform other tasks in the background. We also learned
    how to extend most controls in Xamarin.Forms.
  prefs: []
  type: TYPE_NORMAL
- en: The next project will be a real-time chat app. In the next chapter, we will
    set up a serverless backend based on services in Microsoft Azure. We will use
    that backend in a later chapter once we have built the app.**
  prefs: []
  type: TYPE_NORMAL
