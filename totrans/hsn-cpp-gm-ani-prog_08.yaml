- en: '*Chapter 8*: Creating Curves, Frames, and Tracks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early 2000s, it was common for games to take an animation that was authored
    in a 3D content creation tool such as Blender or Maya, play back the animation,
    and sample the transform of every joint in the animation at set intervals. Once
    the animation was sampled, the game's runtime linearly interpolated between the
    sampled frames.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this works (and is doable with glTF files), it''s not the most accurate
    way to play back animations. It wastes memory by including frames that don''t
    actually need to exist. In a 3D content creation tool, animations are created
    using curves, such as the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: The Blender 3D curve editor](img/Figure_8.1_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The Blender 3D curve editor'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern games and animation systems evaluate these curves directly. Evaluating
    the animation curves directly saves memory, but curves are a bit more expensive
    in terms of processing power. By the end of this chapter, you should be able to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand cubic Bézier splines and how to evaluate them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand cubic Hermite splines and how to evaluate them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand common interpolation methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to create cubic, linear, and constant keyframes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how keyframes make up a cubic, linear, or constant track
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to evaluate cubic, linear, and constant tracks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to combine three independent tracks into one transform track
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding cubic Bézier splines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement game animation, you need some understanding of curves. Let''s
    start with the basics—a cubic Bézier spline. A Bézier spline has two points to
    interpolate between and two control points that help generate a curve. This is
    what a cubic Bézier spline looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: A cubic Bézier spline](img/Figure_8.2_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: A cubic Bézier spline'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the two points and the two controls, how is the curve generated? Let''s
    explore interpolating the curve for a given time, **t**. Start by drawing a line
    from **P1** to **C1**, from **C1** to **C2**, and from **C2** to **P2**. Then,
    linearly interpolate along those lines with the value of **t**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Linearly interpolating between points and control points](img/Figure_8.3_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Linearly interpolating between points and control points'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interpolated points from **P1** to **C1** is **A**, from **C2** to **P2**
    is **B**, and from **C1** to **C2** is **C**. Next, you need to repeat this process,
    drawing lines and interpolating from **A** to **C** and from **C** to **B**. Let''s
    call these newly interpolated points E and F:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Linearly interpolating the results of figure 8.3](img/Figure_8.4_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Linearly interpolating the results of figure 8.3'
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat this one more time, drawing a line from **E** to **F** and interpolating
    along that line by **t** as well. Let''s call the resulting point **R**. This
    point, **R**, is somewhere on the Bézier spline. If you were to calculate all
    points from *t=0* to *t=1*, you could plot the curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Linearly interpolating the results of figure 8.4](img/Figure_8.5_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Linearly interpolating the results of figure 8.4'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the code required to draw a Bézier spline. Bézier splines will
    not be used anywhere else in this book, so implementing the following code is
    not required to follow along with the rest of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to define what a Bézier spline is. Create a new templated class
    that contains two points and two control points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the `Interpolate` function. This function takes a Bézier spline
    reference and a value, `t`, to interpolate the spline. It''s assumed that `t`
    is greater than or equal to `0` and less than or equal to `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code sample demonstrates how the Bezier class and the `Interpolate`
    function can be used to plot a Bézier spline:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to create the data that will be plotted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, draw the points and handles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, plot the spline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding sample code, you can see that you can implement the Bézier
    `Interpolate` function by using six linear interpolations. To understand how Bézier
    splines work, you need to expand the `lerp` functions to what they actually are.
    Linear interpolation, `lerp(a, b, t)`, expands to `(1-t) * a + t * b`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rewrite the `Interpolate` function so that all the `lerp` calls are expanded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing has changed, but you no longer need to call the `lerp` function. This
    works for any data type, `T`, as long as `T operator*(const T& t, float f)` is
    defined. Let''s try to simplify this in a mathematical sense. Instead of using
    the `A`, `B`, `C`, `D`, `E`, and `R` variables, expand these equations to the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the equivalent of inlining all the `lerp` functions by hand. The resulting
    code is a little hard to read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Why go through all this trouble? To start simplifying the math, let''s start
    by combining like terms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that''s starting to look like an equation! This simplified equation can
    be expressed in code as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Take this simplification a bit further by isolating some of the terms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In code, this is expressed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Simplify the function one more time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for this final simplification looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you plot these final equations out with *t* ranging from `0` to `1`, you
    get the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: The basis functions of a Bézier spline](img/Figure_8.6_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: The basis functions of a Bézier spline'
  prefs: []
  type: TYPE_NORMAL
- en: These are the point basis functions of the cubic Bézier spline. They express
    how the value of the spline changes over time. For example, the influence of P1
    drops over time; at *t=0*, the influence is full—it has a value of 1\. However,
    by the time *t=1*, the influence of P1 is gone—it has a value of 0.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you went through the exercise of simplifying the Bézier spline
    evaluation function to arrive at the basis function of the spline. With Bézier
    splines, it's easy to follow this logic since you can start with an easy-to-understand
    implementation that just uses six lerp functions. With other curves, there is
    no easy place to start.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore another type of cubic spline—the cubic
    Hermite spline. Using the knowledge you learned in this section, you will be able
    to implement the Hermite evaluation function using only the basis function graph.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding cubic Hermite splines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common spline type used in animation for games is a **cubic Hermite
    spline**. Unlike Bézier, a Hermite spline doesn't use points in space for its
    control; rather, it uses the tangents of points along the spline. You still have
    four values, as with a Bézier spline, but they are interpreted differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Hermite spline, you don''t have two points and two control points;
    instead, you have two points and two slopes. The slopes are also referred to as
    tangents—throughout the rest of this chapter, the slope and tangent terms will
    be used interchangeably. The point basis functions for Hermite splines look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: The point basis functions of Hermite splines](img/Figure_8.7_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: The point basis functions of Hermite splines'
  prefs: []
  type: TYPE_NORMAL
- en: 'When given the point basis functions, you can implement the spline evaluation
    function similar to how the Bézier interpolation function was implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It's possible to switch between Bézier and Hermite splines, but that's beyond
    the scope of what you need to know for animation. Some 3D content creation applications,
    such as Maya, let animators create animations using a Hermite spline, while others,
    such as Blender 3D, use Bézier curves.
  prefs: []
  type: TYPE_NORMAL
- en: It's useful to understand how these functions work, regardless of which one
    drives your animation system. There are, of course, more curve types, but Bézier
    and Hermite are the most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: The glTF file format supports the constant, linear, and cubic interpolation
    types. You just learned how to do cubic interpolation, but you still need to implement
    both constant and linear interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When defining an animation curve, generally, it follows one of three interpolation
    methods—constant, linear, or cubic. Cubic curves can be expressed using any cubic
    equation, such as Bézier curves (which is what Blender uses) or Hermite splines
    (which is what Maya uses). This book uses Hermite splines to represent cubic curves.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **constant curve** keeps its value the same until the next keyframe. Sometimes,
    this type of curve is called a step curve. Visually, a constant curve looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: A constant curve](img/Figure_8.8_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: A constant curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **linear curve** interpolates between two frames in a linear fashion (that
    is, in a straight line). As you saw with the sampled curve approximation example
    earlier, if the samples of a linear track are close enough, it can start to approximate
    other types of curves as well. A linear curve looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9: A linear curve](img/Figure_8.9_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: A linear curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **cubic curve** lets you define a curve in terms of values and tangents.
    The benefit of cubic curves is that you can express complex curves with little
    data. The downside is that interpolation becomes a bit more expensive. A cubic
    curve looks as follows (the tangents are the lines coming out of the keyframes):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: A cubic curve](img/Figure_8.10_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: A cubic curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interpolation types can be expressed as a simple `enum` class. Create a new
    file—`Interpolation.h`. Add header guards and add the following `enum` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These are the three interpolation types that glTF supports as well. In the next
    section, you will start to implement animation tracks by creating a `Frame` structure
    to hold keyframe data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Frame struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a frame of data? That depends on the interpolation type. If the interpolation
    is constant (step) or linear, a frame is just a time and value. When the interpolation
    is cubic, you need to store the tangents as well.
  prefs: []
  type: TYPE_NORMAL
- en: A Hermite curve is made by connecting Hermite splines. Each control point consists
    of a time, a value, an incoming tangent, and an outgoing tangent. The incoming
    tangent is used if the control point is evaluated with the point that comes before
    it. The outgoing tangent is used if the control point is evaluated with the point
    that comes after it.
  prefs: []
  type: TYPE_NORMAL
- en: The time value stored in a frame is scalar, but what about the data and tangents?
    Should these values be scalar, a vector, or a quaternion? To make that decision,
    you have to think about how you might want to organize a collection of frames
    into a curve.
  prefs: []
  type: TYPE_NORMAL
- en: There are two strategies to choose from. You could create a scalar curve object,
    where the data and tangents are scalar values. Then, when you need a vector curve,
    you can combine several scalar curve objects into a vector curve object.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of having a scalar track and compositing higher-order tracks from
    it is that each component of a vector or quaternion curve can be interpolated
    differently. It can also save on memory since each component of the curve could
    have a different number of frames. The disadvantage is the additional effort of
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The other strategy is to have specialized frame and curve types, such as a scalar
    frame, a vector frame, and a quaternion frame. Similarly, you could create separate
    classes to represent a scalar curve, a vector curve, and a quaternion curve.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using specialized frames and curves is their ease of implementation.
    You can take advantage of using templates to avoid writing duplicate code. glTF
    files store animation tracks this way as well. The disadvantage is memory; every
    component of a curve is required to have the same number of keyframes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, you will implement explicit frames and curves (tracks). The `Frame`
    class will contain a time, a value, and both in and out tangents. If the interpolation
    type doesn''t need tangents, you can simply ignore them. A frame can be an arbitrary
    size (such as scalar, vector 2, vector 3, quat, and so on). The time it contains
    will always be a scalar, but the value and tangent lengths can be anything:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `Frame.h`. Add the declaration of the `Frame` class to this
    new file. The `Frame` class needs arrays for the value and the in and out tangents,
    and a scalar for the time. Use a template to specify the size of each frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `typedef` data types for the common frame types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Frame` class you just implemented is used to store keyframes in an animation
    track. An animation track is a collection of keyframes. In the next section, you
    will learn how to implement a `Track` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Track class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Track` class is a collection of frames. Interpolating a track returns the
    data type of the track; the result is the value along whatever curve the track
    defines at a specific point in time. A track must have at least two frames to
    interpolate between.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the *Creating the Frame struct* section, by following the examples
    in this book, you will implement explicit frame and track types. There will be
    separate classes for scalar, vector, and quaternion tracks. These classes are
    templated to avoid having to write duplicate code. A `vec3` track, for example,
    contains the `Frame<3>` type frames.
  prefs: []
  type: TYPE_NORMAL
- en: Because tracks have an explicit type, you can't make a keyframe in the *X* component
    of a `vec3` track without also adding a keyframe to the *Y* and *Z* components
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can eat up more memory if you have a component that doesn''t change. For
    example, notice how, in the following figure, the *Z* component has many frames,
    even though it''s a straight line and two should be enough. This isn''t a big
    trade-off; the additional memory that''s taken is insignificant:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11: The components of a vec3 track](img/Figure_8.11_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: The components of a vec3 track'
  prefs: []
  type: TYPE_NORMAL
- en: For skinned mesh rendering, animation tracks always animate joint transforms.
    However, animation tracks can be used to animate other values in a game as well,
    such as the intensity of a light or switching between two-dimensional sprites
    for a flipbook effect. In the next section, you will create a new header file
    and start declaring the actual `Track` class.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the Track class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A track is a collection of frames. The `Frame` class is templated, so the `Track`
    class needs to be templated as well. The `Track` class takes two template parameters—the
    first is the type (which is intended to be `float`, `vec3`, `quat`, and so on)
    and the other is the number of components that the type contains:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Track` class only needs two members—a vector of frames and an interpolation
    type. Create a new file, `Track.h`, and add the declaration of the `Track` class
    to this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Track` class only needs a default constructor to initialize the `mInterpolation`
    variable. The generated copy constructor, assignment operator, and destructor
    are fine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create getter and setter functions for the number of frames a track has, as
    well as its interpolation type and the start and end time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Track` class needs a way to sample the track when given a time. This `Sample`
    method should take a time value and whether the track is looping or not. Overload
    the `[] operator` to retrieve a reference to a frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to declare some helper functions. A track can be constant, linear,
    or cubic. There is only one `Sample` function that needs to handle all three of
    these cases. Rather than making a huge, hard-to-read function, create a helper
    function for each interpolation type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a helper function to evaluate the Hermite splines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a function to retrieve the frame index for a given time. This is the last
    frame right before the requested time. Also, add a helper function that takes
    an input time that is outside the range of the track and adjusts it to be a valid
    time on the track:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need a way of casting an array of floats (the data inside a frame)
    to the templated type of the track. This function is specialized for each type
    of track:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `Frame` class, add the `typedef` data types for the common `Track`
    types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The API of the `Track` class is small, which makes the class easy to work with.
    However, there is a lot of hidden complexity to the `Track` class; after all,
    this class is at the core of the animation system you are building. In the next
    section, you will start to implement the actual `Track` class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Track class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Track` class is templated, but it''s not meant to be used outside of the
    animation system. Add template definitions for the `float`, `vec3`, and `quat`
    tracks to `Track.cpp`. This makes the compiler generate the code for these templates
    in the CPP file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For character animation, the `vec3` and `quat` track types are all you need.
    If you need to add a new type of track, don't forget to add the template type
    to the `Track.cpp` file. In the following section, you will start to implement
    helper functions to load track data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing helper functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Track` class is templated to avoid having to write duplicate code for all
    the track types. However, some functionality needs to be specific to the type
    of the `Track` class. Besides the `Cast` function, all type-specific functions
    reside in a new namespace—`TrackHelpers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These helper functions are not a part of the `Track` class; they rely on function
    overloading to make sure the right version of the helper function is called. One
    of the key responsibilities of these helper classes is to make sure quaternions
    are normalized and are in the right neighborhood. Because this code interpolates
    quaternions, neighborhooding is a concern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a track to be linearly interpolated, you need to create interpolation functions
    that work with each track type. Add the following helper functions to `Track.cpp`
    that provide the correct interpolation method for each of the data types that
    a track might contain. These functions belong in the `TrackHelpers` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When a Hermite spline is interpolated, if the input type was a quaternion,
    the result needs to be normalized. Rather than providing a quaternion specification
    of the Hermite function, you can create helper functions that only normalize quaternions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There also needs to be a common `Neighborhood` operation that makes sure two
    quaternions are in the correct neighborhood. This function should do nothing for
    the other data types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The reason these helper functions exist is to avoid having to make specialized
    versions of the interpolation functions. Instead, the generic interpolation functions
    call these helper methods and function overloading makes sure the correct function
    is called. This does mean that you need to add new helper functions if you add
    a new type of track. In the next section, you will start implementing some of
    the `Track` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Track functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you will start to implement the member functions of the `Track`
    class. The `Track` class has several unimportant functions that either need to
    call helper functions or are simply getter and setter functions. Begin implementing
    the `Track` class with these functions first:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Track` constructor needs to set the track''s interpolation type. The getter
    and setter functions for the start and end times of the track are simple getter
    functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Sample` function needs to call `SampleConstant`, `SampleLinear`, or `SampleCubic`,
    depending on the track type. The `[]` `operator` returns a reference to the specified
    frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Resize` and `Size` functions are simple getter and setters around the
    size of the frames vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The interpolation type of the track also has simple getter and setter functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Hermite` function implements the basic functions covered in the *Understanding
    cubic Hermite splines* section of this chapter. The second point might need to
    be negated by the `Neighborhood` helper function. Quaternions also need to be
    normalized. Both neighborhooding and normalization are carried out by helper functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the following sections, you will implement some of the more difficult functions
    of the `Track` class, starting with the `FrameIndex` function.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the FrameIndex function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `FrameIndex` function takes time as an argument; it should return the frame
    immediately before that time (on the left). This behavior changes depending on
    whether the track is intended to be sampled looping or not. Follow these steps
    to implement the `FrameIndex` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the track has one frame or less, it is invalid. If an invalid track is encountered,
    return `-1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If the track is sampled as looping, the input time needs to be adjusted so
    that it falls between the start and end frames. This means you need to know the
    time at the first frame of the track, the time at the frame of the track, and
    the duration of the track:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the track is looping, `time` needs to be adjusted so that it is within
    a valid range. To do this, make `time` relative to duration by subtracting the
    start time from it and modulo the result with duration. If `time` is negative,
    add the duration. Don''t forget to add the start time back into `time`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If the track doesn''t loop, any `time` value that is less than the start frame
    should clamp to `0` and any `time` value that is greater than the second-to-last
    frame should clamp to the second-to-last frame''s index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the time is in a valid range, loop through every frame. The frame
    that is closest to the time (but still less) is the frame whose index should be
    returned. This frame can be found by looping through the frames of the track backward
    and returning the first index whose time is less than the time that is looked
    up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If a track does not loop and the time is greater than the last frame's time,
    the index of the second-to-last frame is used. Why the second-to-last frame and
    not the last frame? The `Sample` function always needs a current and next frame,
    and the next frame is found by adding `1` to the result of the `FrameIndex` function.
    When `time` equals the time of the last frame, the two frames that need to be
    interpolated are still the second-to-last frame and the last frame.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will implement the `AdjustTimeToFitTrack` function.
    This function is used to make sure any time that is sampled has a valid value.
    A valid value is any time between the start and end times of the track.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the AdjustTimeToFitTrack function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next function to implement is `AdjustTimeToFitTrack`. When given a time,
    this function needs to adjust the time to be in the range of the start/end frames
    of the track. This is, of course, different depending on whether the track loops.
    Take the following steps to implement the `AdjustTimeToFitTrack` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a track has less than one frame, the track is invalid. If an invalid track
    is used, return `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the start time, end time, and duration of the track. The start time is
    the time of the first frame, the end time is the time of the last frame, and the
    duration is the difference between the two. If the track has a `0` duration, it
    is invalid—return `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If the track loops, adjust the time by the duration of the track:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If the track does not loop, clamp the time to the first or last frame. Return
    the adjusted time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AdjustTimeToFitTrack` function is useful because it keeps the animation
    sampling time in the range. This function is intended to be called when the playback
    time of an animation changes. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Any time the `Update` function is called in the example, the `mAnimTime` variable
    is incremented by `deltaTime` of the frame. However, because the incremented time
    is passed to `AdjustTimeToFitTrack` before it is assigned, it never has an invalid
    animation time value.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will implement the `Cast` function of the `Track`
    class. The `Cast` function is used to take an array of floats and cast it to whatever
    the templated type of the `Track` class is.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Cast function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Cast` function is specialized; an implementation needs to be provided
    for every type of track. The `Cast` function takes a floating-point array and
    returns whatever the templated type, `T`, is of the `Track` class. The supported
    types are `float`, `vec3`, and `quat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This `Cast` function is important because it can cast a `float` array stored
    in a `Frame` class into the data type that the `Frame` class represents. For example,
    `Frame<3>` is cast to `vec3`. In the following sections, you will use the `Cast`
    function to return the correct data type when sampling a `Track` class.
  prefs: []
  type: TYPE_NORMAL
- en: Constant track sampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you will implement the first of three sampling functions for
    a `Track` class—the `FrameIndex` helper. Make sure the frame is valid, then cast
    the value of that frame to the correct data type and return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Constant sampling is often used for things such as visibility flags, where it
    makes sense for the value of a variable to change from one frame to the next without
    any real interpolation. In the following section, you will learn how to implement
    linear track sampling. Linear sampling is very common; most content creation applications
    offer a "sampled" export option that exports linearly interpolated tracks.
  prefs: []
  type: TYPE_NORMAL
- en: Linear track sampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second type of sampling, `FrameIndex` function, you should never be in a
    situation where the current frame is the last frame of the track and the next
    frame is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Once you know the current frame, the next frame, and the delta time between
    them, you can interpolate. Call `AdjustTimeToFitTrack` to make sure the time is
    valid, subtract the time of the first frame from it, and divide the result by
    the frame delta. This results in the interpolation value, `t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing the interpolation value, call the `TrackHelpers::Interpolate` function
    to do the interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Linear sampling is common as many 3D content creation applications provide an
    option to approximate animation curves by sampling them at set intervals. In the
    following section, you will learn how to carry out the cubic interpolation of
    curves. Cubic interpolation stores less data than linear interpolation, but is
    more expensive to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: Cubic track sampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final type of sampling, `Hermite` helper function to do its interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you imagine `time` as a play-head on a track, it is on the right of the
    first point and the left of the second point. Therefore, you need the out slope
    of the first point (because the play-head is moving away from it) and the in slope
    of the second point (because the play-head is moving toward it). Both slopes need
    to be scaled by the frame delta:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Why do the slopes use `memcpy` instead of the `Cast` function? This is because
    the `Cast` function normalizes quaternions, which is bad because slopes are not
    meant to be quaternions. Using `memcpy` instead of `Cast` copies the values directly,
    avoiding normalization.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to combine vector and quaternion tracks
    into a `TransformTrack`. The actual animation framework will work on the `TransformTrack`
    classes, which will not be templated.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the TransformTrack class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any animated transform, you don't want to maintain separate vector and quaternion
    tracks; instead, you build a higher-level structure—the transform track. A transform
    track encapsulates three tracks—one for the position, one for the rotation, and
    one for scale. You can sample the transform track at any point and get a full
    transform back, even if the component tracks are of different durations or start
    at different times.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to consider is how you want to store these transform tracks in relation
    to an animated model. The skeleton of a model contains several bones. You can
    either store a vector of transform tracks—one for each bone—or you can add bone
    ID as a member of the transform track and only store as many as are needed.
  prefs: []
  type: TYPE_NORMAL
- en: This is important because a character can have a lot of bones, but not all animations
    will animate all of those bones. If you store one transform track for each bone,
    it wastes memory, but sampling an animation is faster. If you store only as many
    transform tracks as needed, sampling becomes a bit more expensive, but memory
    consumption goes down.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation choices tend to always end up being memory versus speed. On modern
    systems, the delta on either axis should be trivial. In this section, you will
    add a bone ID to the transform tracks and only store as many tracks as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the TransformTrack class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TransformTrack` class will need to hold an integer that represents which
    bone (joint) the track will affect. It also needs actual tracks for the position,
    rotation, and scale. These four pieces of information should together be enough
    to animate a joint's position, rotation, and scale.
  prefs: []
  type: TYPE_NORMAL
- en: As with the `Track` class, the `TransformTrack` class has getter and setter
    functions for the start and end times of the transform track. The start and end
    times of a transform track is dependent on its component tracks. Component tracks
    are the position, rotation, and scale tracks.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the three tracks, the start time that is the lowest is used as the transform
    track's start time. The end time that is the largest of the three tracks is used
    as the transform track's end time.
  prefs: []
  type: TYPE_NORMAL
- en: Not all of the component tracks in a transform track need to be valid. For example,
    if only the position of a transform is animated, the rotation and scale component
    tracks can be left as invalid. A transform track is valid so long as at least
    one of its component tracks is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because not all of the component tracks are guaranteed to be valid, the `Sample`
    function of the `TransformTrack` class needs to take a reference transform. Take
    the following steps to declare the `TransformTrack` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `TransformTrack.h`, and start adding the `TransformTrack`
    definition to it by defining the member variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The public API is straightforward. You need the default constructor to assign
    a default value to the joint ID of the track. You also need getter functions for
    the ID, the component tracks, and the start/end times, as well as the duration
    and validity. Only the ID needs a setter function; the component getter functions
    return mutable references:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, you will start implementing the functions of `TransfromTrack`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the TransformTrack class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the `TransformTrack` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `TransformTrack.cpp`, to implement the `TransformTrack`
    class in. The constructor of the `TransformTrack` class is unimportant; assign
    a default value to the joint that the transform track represents. The getter and
    setter functions for the track ID are also trivial:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement functions to access the different component tracks stored in
    the transform track. These functions need to return a reference so that you can
    mutate the returned tracks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsValid` helper function should only return `true` if at least one of
    the component tracks stored in the `TransformTrack` class is valid. For a track
    to be valid, it needs to have two or more frames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetStartTime` function should return the smallest start time of the three
    component tracks. If none of the components are valid (that is, they all have
    one or no frames), then `TransformTrack` isn''t valid. In this case, just return
    `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetEndTime` function is similar to the `GetStartTime` function. The only
    difference is that this function looks for the greatest track end time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Sample` function only samples one of its component tracks if that track
    has two or more frames. Since a `TransformTrack` class can animate only one component,
    such as the position, this function needs to take a reference transform as an
    argument. If one of the transform components isn''t animated by the transform
    track, the value of the reference transform is used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Because not all animations contain the same tracks, it's important to reset
    the pose that you are sampling any time the animation that you are sampling switches.
    This ensures that the reference transform is always correct. To reset the pose,
    assign it to be the same as the rest pose.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the building blocks of animation, what is
    in one frame of data, how several frames can make a track, and how a few tracks
    can animate a transform. You explored the different interpolation methods for
    interpolating an animation track and made these methods work for scalar, vector,
    and quaternion tracks.
  prefs: []
  type: TYPE_NORMAL
- en: The classes you built in this chapter will be used as the building blocks for
    creating animation clips in the next chapter. In the next chapter, you will implement
    animation clips and poses. The animation clips will be made of the `TransformTrack`
    objects. These tracks are at the core of a modern animation system.
  prefs: []
  type: TYPE_NORMAL
- en: There are two samples in the `Chapter08` folder of the downloadable content
    for this book. `Sample00` contains all the code used up to this point in the book
    and `Sample01` creates several tracks and plots them all on screen. Visually plotting
    tracks is a good idea as it can help prevent debug problems early on.
  prefs: []
  type: TYPE_NORMAL
