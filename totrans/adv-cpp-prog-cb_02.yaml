- en: Using Exceptions for Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn some advanced C++ exception handling techniques.
    We assume here that you have a basic understanding of how to throw as well as
    catch a C++ exception. Instead of focusing on the basics of C++ exceptions, this
    chapter will teach you some of the more advanced techniques of C++ exception handling.
    This includes the proper use of the `noexcept` specifier and the `noexcept` operator
    so that you can properly mark your APIs as either possibly throwing an exception
    or explicitly not throwing a C++ exception, instead of calling `std::terminate()`
    when an error occurs that cannot be handled.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also explain what the term **Resource Acquisition is Initialization**
    (**RAII**) is and how it complements C++ exception handling. We will also discuss
    why you should never throw a C++ exception from a class's destructor and how to
    handle these types of issues. Finally, we will look at how to create your own
    custom C++ exceptions including providing some basic guidelines on what to do
    and what not to do when creating your own exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: From the information provided in this chapter, you will gain a better understanding
    of how C++ exceptions work under the hood and the types of things that can be
    done with C++ exceptions to build more robust and reliable C++ programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the noexcept specifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the noexcept operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RAII
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning why to never throw exceptions in destructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily creating your own exception classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Before running these examples, you must install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  prefs: []
  type: TYPE_NORMAL
- en: Using the noexcept specifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `noexcept` specifier is used to tell the compiler whether a function may
    or may not throw a C++ exception. If a function is marked with the `noexcept`
    specifier, it is not allowed to throw an exception and, if it does, `std::terminate()`
    will be called when the exception is thrown. If the function doesn't have the
    `noexcept` specifier, exceptions can be thrown as normal.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore how to use the `noexcept` specifier in your
    own code. This specifier is important because it is a contract between the API
    that you are creating and the user of the API. When the `noexcept` specifier is
    used, it tells the user of the API that they do not need to consider exceptions
    when using the API. It also tells the author that if they add the `noexcept` specifier
    to their API, they have to ensure that no exceptions are thrown, which, in some
    cases, requires the author to catch all possible exceptions and either handle
    them or call `std::terminate()` if the exception cannot be handled. Also, there
    are certain operations, such as `std::move`, where exceptions cannot be thrown
    without the fear of corruption as a move operation oftentimes cannot be safely
    reversed if an exception is thrown. Finally, with some compilers, adding `noexcept`
    to your APIs will reduce the overall size of the function, resulting in a smaller
    overall application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To try this recipe, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s briefly review how C++ exceptions are thrown and caught. In the
    following example, we will throw an exception from a function and then catch the
    exception in our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, we created a function called `foo()` that
    throws an exception. This function is called in our `main()` function inside a
    `try`/`catch` block, which is used to catch any exceptions that might be thrown
    by the code executed inside the `try` block, which in this case is the `foo()`
    function. When the exception is thrown by the `foo()` function, it is successfully
    caught and outputted to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this works because we did not add the `noexcept` specifier to the `foo()`
    function. By default, a function is allowed to throw an exception, just as we
    did in this example. In some cases, however, we do not want to allow exceptions
    to be thrown, depending on how we expect a function to execute. Specifically,
    how a function handles exceptions can be defined as the following (known as exception
    safety):'
  prefs: []
  type: TYPE_NORMAL
- en: '**No-throw guarantee**: The function cannot throw an exception, and if an exception
    is thrown internally, the exception must be caught and handled, including allocation
    failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strong exception safety**: The function can throw an exception, and if an
    exception is thrown, any state that was modified by the function is rolled back
    or undone with no side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basic exception safety**: The function can throw an exception, and if an
    exception is thrown, any state that was modified by the function is rolled back
    or undone, but side effects are possible. It should be noted that these side effects
    do not include invariants, meaning the program is in a valid, non-corrupted state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No exception safety**: The function can throw an exception, and if an exception
    is thrown, the program could enter a corrupted state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, if a function has a no-throw guarantee, it is labeled with `noexcept`;
    otherwise, it is not. An example of why exception safety is so important is with
    `std::move`. For example, suppose we have two instances of `std::vector` and we
    wish to move one vector into another. To perform the move, `std::vector` might
    move each element of the vector from one instance to the other. If the object
    is allowed to throw when it is moved, the vector could end up with an exception
    in the middle of the move (that is, half of the objects in the vector are moved
    successfully). When the exception occurs, `std::vector` would obviously attempt
    to undo the moves that it has already performed by moving these back to the original
    vector before returning the exception. The problem is, attempting to move the
    objects back would require `std::move()`, which could throw and exception again,
    resulting in a nested exception. In practice, moving one `std::vector` instance
    to another doesn't actually perform an object-by-object move, but resizing does,
    and, in this specific issue, the standard library requires the use of `std::move_if_noexcept`
    to handle this situation to provide exception safety, which falls back to a copy
    when the move constructor of an object is allowed to throw.
  prefs: []
  type: TYPE_NORMAL
- en: The `noexcept` specifier is used to overcome these types of issues by explicitly
    stating that the function is not allowed to throw an exception. This not only
    tells the user of the API that they can safely use the function without fear of
    an exception being thrown and potentially corrupting the execution of the program,
    but it also forces the author of the function to safely handle all possible exceptions
    or call `std::terminate()`. Although `noexcept`, depending on the compiler, also
    provides optimizations by reducing the overall size of the application when defined,
    its main use is to state the exception safety of a function such that other functions
    can reason about how a function will execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we add the `noexcept` specifier to our `foo()` function
    defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When this example is compiled and executed, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f99d2218-74b5-47f1-8108-6a38646732a8.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, the `noexcept` specifier was added, which
    tells the compiler that `foo()` is not allowed to throw an exception. Since, however,
    the `foo()` function does throw an exception, when it is executed, `std::terminate()`
    is called. In fact, in this example, `std::terminate()` will always be called,
    which is something the compiler is able to detect and warn about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `std::terminate()` is obviously not the desired outcome of a program.
    In this specific case, since the author has labeled the function as `noexcept`,
    it is up to the author to handle all possible exceptions. This can be done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, the exception is wrapped in a `try`/`catch`
    block to ensure the exception is safely handled before the `foo()` function completes
    its execution. Also, in this example, only exceptions that originate from `std::exception()`
    are caught. This is the author's way of saying which types of exceptions can be
    safely handled. If, for example, an integer was thrown instead of `std::exception()`,
    `std::terminate()` would still be executed automatically since `noexcept` was
    added to the `foo()` function. In other words, as the author, you are only required
    to handle the exceptions that you can, in fact, safely handle. The rest will be
    sent to `std::terminate()` for you; just understand that, by doing this, you change
    the exception safety of the function. If you intend for a function to be defined
    with a no-throw guarantee, the function cannot throw an exception at all.
  prefs: []
  type: TYPE_NORMAL
- en: It should also be noted that if you mark a function as `noexcept`, you need
    to not only pay attention to exceptions that you throw but also to the functions
    that may throw themselves. In this case, `std::cout` is being used inside the
    `foo()` function, which means the author has to either knowingly ignore any exceptions
    that `std::cout` could throw, which would result in a call to `std::terminate()`
    (which is what we are doing here), or the author needs to identify which exceptions
    `std::cout` could throw and attempt to safely handle them, including exceptions
    such as `std::bad_alloc`.
  prefs: []
  type: TYPE_NORMAL
- en: The `std::vector.at()` function throws an `std::out_of_range()` exception if
    the provided index is out of bounds with respect to the vector. In this case,
    the author can catch this type of exception and return a default value, allowing
    the author to safely mark the function as `noexcept`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `noexcept` specifier is also capable of acting as a function, taking a
    Boolean expression, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c75fc0ac-3445-4fe6-a20c-934b783a5d96.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, the `noexcept` specifier was written as `noexcept(true)`.
    If the expression evaluates to true, it is as if `noexcept` was provided. If the
    expression evaluates to false, it is as if the `noexcept` specifier was left out,
    allowing exceptions to be thrown. In the preceding example, the expression evaluates
    to true, which means that the function is not allowed to throw an exception, which
    results in `std::terminate()` being called when `foo()` throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a more complicated example to demonstrate how this can be used.
    In the following example, we will create a function called `foo()` that will shift
    an integer value by 32 bits and cast the result to a 64-bit integer. This example
    will be written using template metaprogramming, allowing us to use this function
    on any integer type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/182cbe31-a769-4160-884a-7f9445e380d2.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, the issue with the `foo()` function is that
    if the user provides a 64-bit integer, it cannot shift by 32 bits without generating
    an overflow. If the integer provided, however, is 32 bits or less, the `foo()`
    function is perfectly safe. To implement the `foo()` function, we used the `noexcept`
    specifier to state that the function is not allowed to throw an exception if the
    provided integer is 32 bits or less. If the provided integer is greater than 32
    bits, an exception is allowed to throw, which, in this case, is an `std::runtime_error()` exception
    stating that the integer is too large to be safely shifted.
  prefs: []
  type: TYPE_NORMAL
- en: Using the noexcept operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `noexcept` operator is a compile-time check that is used to ask the compiler
    whether a function is labeled `noexcept` or not. With C++17, this can be paired
    with a compile-time `if` statement (that is, an `if` statement that is evaluated
    at compile time and that can be used to add/remove code from an executable during
    compilation) to change the semantics of a program based on whether or not a function
    is allowed to throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore how to use the `noexcept` operator in your own
    code. This operator is important because, in some cases, you may not know whether
    a function is capable of throwing an exception by simply looking at its definition.
    For example, if a function uses the `noexcept` specifier, your code might not
    be able to determine whether the function will throw, as you might not know—based
    on the function's inputs—what the `noexcept` specifier will evaluate to. The `noexcept`
    operator provides you with a mechanism to handle these types of scenarios, which
    is essential, especially when metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `noexcept` operator is used to determine whether a function can throw.
    Let''s start with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afafa314-071a-4aa9-8896-0c19d3282f99.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, we defined a `foo()` function that outputs
    to `stdout`. We don't actually execute `foo()` but, instead, we use the `noexcept`
    operator to check to see whether the `foo()` function could throw. As you can
    see, the answer is yes; this function can throw. This is because we did not label
    the `foo()` function with `noexcept`, and, as stated in the previous recipe, functions
    can throw by default.
  prefs: []
  type: TYPE_NORMAL
- en: It should also be noted that we added `!` to the `noexcept` expression. This
    is because `noexcept` returns `true` if the function is labeled `noexcept`, which
    means that the function is not allowed to throw. However, in our example, we are
    not asking whether the function cannot throw, but instead we are asking whether
    the function can throw, hence the logical Boolean reversal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s expand upon this by adding a couple more functions to our example. Specifically,
    in the following example, we will add some functions that throw as well as some
    functions that are labeled `noexcept`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c634422-311e-40ae-a7f8-e20aa940f7a4.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, if a function is labeled with `noexcept`,
    the `noexcept` operator returns `true` (which, in our example, outputs `false`).
    More importantly, a keen observer would notice that the functions that throw exceptions
    do not change the output of the `noexcept` operator. That is, the `noexcept` operator
    returns `false` if a function *can* throw an exception, not if it *will* throw
    an exception. This is important as the only way to know whether a function *will*
    throw an exception is to execute it. The only thing the `noexcept` specifier states
    is whether or not an exception is allowed to be thrown by the function. It doesn't
    state whether or not an exception *will* be thrown. By extension, the `noexcept`
    operator doesn't tell you whether the function *will* throw or not but instead
    tells you whether the function is labeled with the `noexcept` specifier (and,
    more importantly, what the `noexcept` specifier evaluates to).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we attempt to use the `noexcept` specifier in a more realistic example,
    let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we have defined a `foo()` function that
    throws, and then we call this function from our main function, resulting in `std::terminate()`
    being called because we didn''t handle the exception before leaving the program.
    In a more complicated setting, we might not know whether `foo()` throws or not,
    and, as a result, we may not want to add the additional overhead of exception
    handling if it is not needed. To better explain this, let''s examine the resulting
    assembly code for the `main()` function for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8741e7cf-194c-44e7-84c5-b48af8c04011.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `main` function is simple and doesn't contain any additional
    logic outside of calling the `foo` function. Specifically, the `main` function
    doesn't have any catch logic in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use the `noexcept` operator in a more concrete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we use the `noexcept` operator in conjunction
    with the `constepxr` operator in the `if` statement that was added in C++17\.
    This allows us to ask the compiler whether `foo()` is allowed to throw. If it
    is, we execute the `foo()` function inside a `try`/`catch` block so that we can
    handle any possible exceptions as needed. If we examine the assembly of this function,
    as shown in the following screenshot, we can see that some additional `catch`
    logic was added to the resulting binary to handle the exceptions as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49f6bfba-8bae-40ba-8987-e352f7b9625c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s take this same example one step further by stating that the `foo()`
    function is not allowed to throw using the `noexcept` specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, the program calls `std::terminate()` since
    the `foo()` function was labeled `noexcept`. Furthermore, if we look at the resulting
    assembly, we can see that the `main()` function no longer contains the additional
    `try`/`catch` logic, which means that our optimization worked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d0478f9-51e3-4438-b303-7d4872bf5a80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we might possibly not know how to label our own function if we do
    not know whether a function that was called can throw or not. Let''s look at the
    following example to demonstrate this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c98505b-2992-4bc6-a927-e4eb3315fd00.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, the `foo1()` function is not labeled with
    the `noexcept` specifier, which means it is allowed to throw an exception. In
    `foo2()`, we want to ensure that our `noexcept` specifier is correct but we call
    `foo1()`, and, in this example, we assume that we don't know whether `foo1()`
    is `noexcept` or not.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure `foo2()` is labeled properly, we combine the lessons learned in this
    recipe and the previous one to mark the function properly. Specifically, we use
    the `noexcept` operator to tell us whether the `foo1()` function will throw, and
    then we use the `noexcept` specifier's Boolean expression syntax to use the results
    of the `noexcept` operator to label `foo2()` as `noexcept` or not. If `foo1()`
    is labeled with `noexcept`, the `noexcept` operator will return `true`, resulting
    in `foo2()` being marked as `noexcept(true)`, which is the same as simply stating
    `noexcept`. If `foo1()` is not labeled as `noexcept`, the `noexcept` operator
    will return `false`, in which case the `noexcept` specifier will be labeled as
    `noexcept(false)`, which is the same as not adding the `noexcept` specifier (that
    is, the function is allowed to throw an exception).
  prefs: []
  type: TYPE_NORMAL
- en: Using RAII
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RAII is a programming principle that states that a resource is tied to the lifetime
    of the object that acquired the resource. RAII is a powerful feature of the C++
    language that really helps to set C++ apart from C, helping to prevent resource
    leaks and general instability.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will dive into how RAII works and how RAII can be used to
    ensure that C++ exceptions do not introduce resource leaks. RAII is a critical
    technology for any C++ application and should be used whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To better understand how RAII works, we must first examine how a class in C++
    works as C++ classes are used to implement RAII. Let''s look at a simple example. C++
    classes provide support for both constructors and destructors as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following when compiled and executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1991efef-e0b0-48f0-9c36-1a62bfbec715.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we create a class with both a constructor and a destructor.
    When we create an instance of the class, the constructor is called, and, when
    the instance of the class loses scope, the class is destroyed. This is a simple
    C++ pattern that has been around since the initial versions of C++ were created
    by Bjarne Stroustrup. Under the hood, the compiler calls a construction function
    when the class is first instantiated, but, more importantly, the compiler has
    to inject code into the program that executes the destruction function when the
    instantiation of the class loses scope. The important thing to understand here
    is that this additional logic is inserted into the program automatically by the
    compiler for the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Before the introduction of the classes, the programmer had to add construction
    and destruction logic to the program manually, and, while construction is a fairly
    simple thing to get right, destruction is not. A classic example of this type
    of issue in C is storing a file handle. The programmer will add a call to an `open()`
    function to open the file handle and, when the file is done, will add a call to
    `close()` to close the file handle, forgetting to execute the `close()` function
    on all possible error cases that might crop up. This is inclusive of when the
    code is hundreds of lines long and someone new to the program adds another error
    case, forgetting also to call `close()` as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'RAII solves this issue by ensuring that, once the class loses scope, the resource
    that was acquired is released, no matter what the control-flow path was. Let''s
    look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we allocate an integer and initialize it in the constructor
    of a class. The important thing to notice here is that we do not need to check
    for `nullptr` from the `new` operator. This is because the `new` operator will
    throw an exception if the memory allocation fails. If this occurs, not only will
    the rest of the constructor not be executed, but the object itself will not be
    constructed. This means if the constructor successfully executed, you know that
    the instance of the class is in a valid state and actually contains a resource
    that will be destroyed when the instance of the class loses scope
  prefs: []
  type: TYPE_NORMAL
- en: The destructor of the class then outputs to `stdout` and deletes the previously
    allocated memory. The important thing to understand here is that, no matter what
    control path the code takes, this resource will be released when the instance
    of the class loses scope. The programmer only needs to worry about the lifetime
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This idea that the lifetime of the resource is directly tied to the lifetime
    of the object that allocated the resource is important as it solves a complicated
    issue for the control flow of a program in the presence of C++ exceptions. Let''s
    look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create the same class as the previous example, but, in our
    `foo()` function, we throw an exception. The `foo()` function, however, doesn't
    need to catch this exception to ensure that the memory allocated is properly freed.
    Instead, the destructor handles this for us. In C++, many functions might throw
    and, without RAII, every single function that could throw would need to be wrapped
    in a `try`/`catch` block to ensure that any resources that were allocated are
    properly freed. We, in fact, see this pattern a lot in C code, especially in kernel-level
    programming where `goto` statements are used to ensure that, within a function,
    if an error occurs, the function can properly unwind itself to release any resources
    might have previously been acquired. This result is a nest of code dedicated to
    checking the result of every function call within the program and the logic needed
    to properly handle the error.
  prefs: []
  type: TYPE_NORMAL
- en: With this type of programming model, it's no wonder that resource leaks are
    so common in C. RAII combined with C++ exceptions remove the need for this error-prone
    logic, resulting in code that is less likely to leak resources.
  prefs: []
  type: TYPE_NORMAL
- en: How RAII is handled in the presence of C++ exceptions is outside the scope of
    this book as it requires a deeper dive into how C++ exception support is implemented.
    The important thing to remember is that C++ exceptions are faster than checking
    the return value of a function for an error (as C++ exceptions are implemented
    using a no overhead algorithm) but are slow when an actual exception is thrown
    (as the program has to unwind the stack and properly execute each class destructor
    as needed). For this reason, and others such as maintainability, C++ exceptions
    should never be used for valid control flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way that RAII can be used is the `finally` pattern, which is provided
    by the C++ **Guideline Support Library** (**GSL**). The `finally` pattern leverages
    the destructor-only portion of RAII to provide a simple mechanism to perform non-resource-based
    cleanup when the control flow of a function is complicated or could throw. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a class that is capable of storing a lambda
    function that is executed when an instance of the `finally` class loses scope.
    In this particular case, we output to `stdout` when the `finally` class is destroyed.
    Although this uses a pattern similar to that of RAII, this technically is not
    RAII as no resource has been acquired.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if a resource does need to be acquired, RAII should be used instead of
    the `finally` pattern. The `finally` pattern, instead, is useful when you are
    not acquiring a resource but want to execute code when a function returns no matter
    what control flow path the program takes (a conditional branch or C++ exception).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s look at a more complicated example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/974fa02a-a5bd-462b-aa43-3951b03d15dc.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we want to ensure that we always output to `stdout`
    no matter what the code does. In the middle of execution, we throw an exception,
    and even though the exception was thrown, our `finally` code is executed as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Learning why to never throw exceptions in destructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss the issues with C++ exceptions, specifically
    in regard to throwing exceptions within a class destructor, something that should
    be avoided at all costs. The lessons learned in this recipe are important because,
    unlike other functions, a C++ class destructor is marked as `noexcept` by default,
    which means that if you accidentally throw an exception inside a class destructor,
    your program will call `std::terminate()`, even though the destructor my not be
    overtly labeled `noexcept`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher, and run the following in a Terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn why throwing exceptions in a destructor is a
    *bad* idea, and why class destructors are labeled as `noexcept` by default. To
    start, let''s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute this, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d30c668-41a6-430a-8fc4-a95a1da1f660.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we can see that if we throw an exception from a class destructor,
    `std::terminate()` is called. This is because, by default, a class destructor
    is marked as `noexcept`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change this by explicitly allowing a class destructor to throw by marking
    the class''s destructor as `noexcept(false)`, as shown in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, when the class is destroyed, an exception
    is thrown and properly handled. Even though this was successfully handled, we
    have to ask ourselves, what is the state of the program after we catch this exception?
    The destructor didn't successfully complete. If this class was more complex and
    had state/resources that it was managing, can we conclude that the state/resources
    that we care about were properly handled/released? The short answer is no. This
    is the same as destroying a hard drive with a hammer. If you slam a hard drive
    with a hammer to destroy it, did you actually destroy the data on the hard drive?
    There is no way to know because, when you hit the hard drive with the hammer,
    you broke the electronics that would have been used to answer that very question.
    When you attempt to destroy a hard drive, you need a reliable process that ensures
    that, under no circumstance could the process of destroying the drive leave data
    in a recoverable state. Otherwise, you have no way of knowing what state you are
    in, with no way of going back.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to C++ classes. Destroying a C++ class needs to be an operation
    that must provide basic exception safety (that is, the state of the program is
    deterministic with some possible side effects). Otherwise, the only other logical
    course of action is to call `std::terminate()` since you cannot be sure what will
    happen if the program continues to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides putting the program in an undefined state, the other issue with throwing
    an exception from a destructor is, what happens if an exception has already been
    thrown? What does the `try`/`catch` block catch? Let''s look at an example of
    this type of issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we mark the destructor as `noexcept(false)` just
    like we did in the previous example, but we throw before the destructor is called,
    which means that, when the destructor is called, there is already an exception
    being processed. Now, when we attempt to throw, `std::terminate()` is called even
    though the destructor was marked as `noexcept(false)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afeb2214-83a3-4320-bc7d-abea44492169.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The reason for this is the C++ library has no way of handling this situation
    because the `try`/`catch` block cannot handle more than one exception. It is possible,
    however, to have more than one pending exception; we simply need a `try`/`catch`
    block to handle each exception. This situation occurs when we have nested exceptions,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we will start by creating a class that outputs the results
    of calling `std::uncaught_exceptions()`, which returns the total number of exceptions
    currently being processed. We will then create a second class that creates the
    first class and then throws from its destructor, with the important note that
    all of the code in the destructor is wrapped in a `try`/`catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When this example is executed, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afcfefea-5caa-45ba-8cb6-817eb3023c2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we will create this second class and throw again with another `try`/`catch`
    block. Unlike the previous example, all of the exceptions are being properly handled,
    and, in fact, `noexcept(false)` is not needed to ensure that this code executes
    properly as, for each exception that is thrown, we have a `try`/`catch` block.
    Even though an exception was thrown inside a destructor, it was properly handled,
    which means that the destructor executes safely and remains `noexcept`-compliant,
    even though the second class is executing in the presence of the two exceptions
    being processed.
  prefs: []
  type: TYPE_NORMAL
- en: Easily creating your own exception classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to easily create your own exception types.
    This is an important lesson to learn as, although C++ exceptions are easy to create
    yourself, some guidelines should be followed to ensure this is done safely.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating your own C++ exceptions allows you to filter out what type of exception
    you are getting. For example, did the exception come from your code or the C++
    library? By creating your own C++ exceptions, you can easily answer these questions
    during runtime in your own code. Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, we create our own C++ exception by inheriting
    `std::exception`. This is not a requirement. Technically, anything can be a C++
    exception including an integer. Starting from `std::exception`, however, gives
    you a standard interface to work from including overriding the `what()` function,
    which describes the exception that was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: In this preceding example, we return a hardcoded string in the `what()` function.
    This is the ideal type of exception (even more so than the exceptions that are
    provided by the C++ library). This is because this type of exception is `nothrow
    copy-constructable`. Specifically, this means that the exception itself can be
    copied without the copy generating an exception, for example, due to `std::bad_alloc`.
    The exception types provided by the C++ library support construction from `std::string()`,
    which could throw `std::bad_alloc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue with the preceding C++ exception is that you would need `1` exception
    type for every type of message you wish to provide. Another way to implement a
    safe exception type is to use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we store a pointer to `const char*` (that is, a C-style
    string). C-style strings are stored globally as constants within the program.
    This type of exception satisfies all of the same preceding rules, and no allocations
    are taking place during the construction of the exception. It should also be noted
    that, since the strings are stored globally, this type of operation is safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many types of exceptions can be created using this approach, including things
    other than strings that are accessible through custom getters (that is, without
    having to use the `what()` function). If, however, these preceding rules are not
    an issue for you, the easiest way to create a custom C++ exception is to simply
    subclass an existing C++ exception such as `std::runtime_error()`, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When this example is executed, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a982b81c-4220-43df-82f3-73b32e54b2ae.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we create our own C++ exception in just a few lines
    of code by subclassing `std::runtime_error()`. We can then use different `catch`
    blocks to figure out what type of exception was thrown. Just remember that if
    you use the `std::string` version of `std::runtime_error()`, you could end up
    with `std::bad_alloc` being thrown during the construction of the exception itself.
  prefs: []
  type: TYPE_NORMAL
